{
  "address": "0xB6FF36e7d04e6017E0323F1f92A8184370d48907",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "colLiquidated",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "debtLiquidated",
          "type": "uint256"
        }
      ],
      "name": "FluidLiquidateResult",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "errorId_",
          "type": "uint256"
        }
      ],
      "name": "FluidSafeTransferError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "errorId_",
          "type": "uint256"
        }
      ],
      "name": "FluidVaultError",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "colAbsorbedRaw_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "debtAbsorbedRaw_",
          "type": "uint256"
        }
      ],
      "name": "LogAbsorb",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "liquidator_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "colAmt_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "debtAmt_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "to_",
          "type": "address"
        }
      ],
      "name": "LogLiquidate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "user_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "nftId_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "colAmt_",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "debtAmt_",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "to_",
          "type": "address"
        }
      ],
      "name": "LogOperate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "int256",
          "name": "colAmt_",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "debtAmt_",
          "type": "int256"
        }
      ],
      "name": "LogRebalance",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "supplyExPrice_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "borrowExPrice_",
          "type": "uint256"
        }
      ],
      "name": "LogUpdateExchangePrice",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "vaultVariables_",
          "type": "uint256"
        },
        {
          "internalType": "int256",
          "name": "maxTick_",
          "type": "int256"
        }
      ],
      "name": "absorb",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "colToken0MinMax_",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "colToken1MinMax_",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "debtToken0MinMax_",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "debtToken1MinMax_",
          "type": "int256"
        }
      ],
      "name": "rebalance",
      "outputs": [
        {
          "internalType": "int256",
          "name": "supplyAmt_",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "borrowAmt_",
          "type": "int256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "transactionHash": "0x723d94a69892ed139ec14f54b94c80d64371620ec66ef18c8e1a8cd53c1a5481",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x0Ed35B1609Ec45c7079E80d11149a52717e4859A",
    "contractAddress": null,
    "transactionIndex": 115,
    "gasUsed": "1980648",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000001000000000000000000000000000000004000000000000000040001000000000000080000000000000000100000000000000000000000000000000000000000000000000000000004000000000000100020",
    "blockHash": "0x940570acebff3cf9112a18c767a7a37c0c148b586eed681a1a7de229fd5c5fb9",
    "transactionHash": "0x723d94a69892ed139ec14f54b94c80d64371620ec66ef18c8e1a8cd53c1a5481",
    "logs": [
      {
        "transactionIndex": 115,
        "blockNumber": 69290322,
        "transactionHash": "0x723d94a69892ed139ec14f54b94c80d64371620ec66ef18c8e1a8cd53c1a5481",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x0000000000000000000000000ed35b1609ec45c7079e80d11149a52717e4859a",
          "0x000000000000000000000000127685d6dd6683085da4b6a041efcef1681e5c9c"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000f6489c3190132800000000000000000000000000000000000000000000000acb3877f54b4fe0f30000000000000000000000000000000000000000000005fc5f912883cef8d06b00000000000000000000000000000000000000000000000aca422f5919bfcdcb0000000000000000000000000000000000000000000005fc608771200088e393",
        "logIndex": 455,
        "blockHash": "0x940570acebff3cf9112a18c767a7a37c0c148b586eed681a1a7de229fd5c5fb9"
      }
    ],
    "blockNumber": 69290322,
    "cumulativeGasUsed": "15126343",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "9f5cd0e9c1eda40ac59a3b10ab974fc1",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"colLiquidated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtLiquidated\",\"type\":\"uint256\"}],\"name\":\"FluidLiquidateResult\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorId_\",\"type\":\"uint256\"}],\"name\":\"FluidSafeTransferError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorId_\",\"type\":\"uint256\"}],\"name\":\"FluidVaultError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"colAbsorbedRaw_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtAbsorbedRaw_\",\"type\":\"uint256\"}],\"name\":\"LogAbsorb\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"colAmt_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtAmt_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"}],\"name\":\"LogLiquidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"colAmt_\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"debtAmt_\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"}],\"name\":\"LogOperate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"colAmt_\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"debtAmt_\",\"type\":\"int256\"}],\"name\":\"LogRebalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supplyExPrice_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowExPrice_\",\"type\":\"uint256\"}],\"name\":\"LogUpdateExchangePrice\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultVariables_\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"maxTick_\",\"type\":\"int256\"}],\"name\":\"absorb\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"colToken0MinMax_\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"colToken1MinMax_\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"debtToken0MinMax_\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"debtToken1MinMax_\",\"type\":\"int256\"}],\"name\":\"rebalance\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"supplyAmt_\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"borrowAmt_\",\"type\":\"int256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"absorb(uint256,int256)\":{\"details\":\"absorb function absorbs the bad debt if the bad debt is above max limit. The main use of it is if the bad debt didn't got liquidated in time maybe due to sudden price drop or bad debt was extremely small to liquidate and the bad debt goes above 100% ratio then there's no incentive for anyone to liquidate now hence absorb functions absorbs that bad debt to allow newer bad debt to liquidate seamlessly. if absorbing were to happen after this it's on governance on how to deal with it although it can still be removed through liquidate via liquidator if the price goes back up and liquidation becomes beneficial upon absorbed user position gets 100% liquidated.\"},\"rebalance(int256,int256,int256,int256)\":{\"details\":\"Checks total supply of vault's in Liquidity Layer & Vault contract and rebalance it accordingly if vault supply is more than Liquidity Layer then deposit difference through reserve/rebalance contract if vault supply is less than Liquidity Layer then withdraw difference to reserve/rebalance contract if vault borrow is more than Liquidity Layer then borrow difference to reserve/rebalance contract if vault borrow is less than Liquidity Layer then payback difference through reserve/rebalance contract\"}},\"version\":1},\"userdoc\":{\"errors\":{\"FluidLiquidateResult(uint256,uint256)\":[{\"notice\":\"used to simulate liquidation to find the maximum liquidatable amounts\"}]},\"events\":{\"LogAbsorb(uint256,uint256)\":{\"notice\":\"emitted when `absorb()` was executed to absorb bad debt.\"},\"LogLiquidate(address,uint256,uint256,address)\":{\"notice\":\"emitted when a liquidation has been executed.\"},\"LogOperate(address,uint256,int256,int256,address)\":{\"notice\":\"emitted when an operate() method is executed that changes collateral (`colAmt_`) / debt (debtAmt_`) amount for a `user_` position with `nftId_`. Receiver of any funds is the address `to_`.\"},\"LogRebalance(int256,int256)\":{\"notice\":\"emitted when a `rebalance()` has been executed, balancing out total supply / borrow between Vault and Fluid Liquidity pools. if `colAmt_` is positive then loss, meaning transfer from rebalancer address to vault and deposit. if `colAmt_` is negative then profit, meaning withdrawn from vault and sent to rebalancer address. if `debtAmt_` is positive then profit, meaning borrow from vault and sent to rebalancer address. if `debtAmt_` is negative then loss, meaning transfer from rebalancer address to vault and payback.\"},\"LogUpdateExchangePrice(uint256,uint256)\":{\"notice\":\"emitted when the exchange prices are updated in storage.\"}},\"kind\":\"user\",\"methods\":{},\"notice\":\"Fluid Vault protocol secondary methods contract.         Implements `absorb()` and `rebalance()` methods, extracted from main contract due to contract size limits.         Methods are limited to be called via delegateCall only (as done by Vault CoreModule contract).\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocols/vault/vaultTypesCommon/coreModule/main2.sol\":\"FluidVaultSecondary\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[]},\"sources\":{\"contracts/infiniteProxy/interfaces/iProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IProxy {\\n    function setAdmin(address newAdmin_) external;\\n\\n    function setDummyImplementation(address newDummyImplementation_) external;\\n\\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\\n\\n    function removeImplementation(address implementation_) external;\\n\\n    function getAdmin() external view returns (address);\\n\\n    function getDummyImplementation() external view returns (address);\\n\\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\\n\\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\\n\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n}\\n\",\"keccak256\":\"0xbb605491d4bac08e816248feecae7dd17cfc1877c88b2e555abece2970f5ea00\",\"license\":\"MIT\"},\"contracts/libraries/bigMathMinified.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\\n/// result in significant gas cost reduction due to storage space reduction.\\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\\nlibrary BigMathMinified {\\n    /// @dev constants to use for `roundUp` input param to increase readability\\n    bool internal constant ROUND_DOWN = false;\\n    bool internal constant ROUND_UP = true;\\n\\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\\n    /// e.g.:\\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\\n    /// exponent =                                            0011,0011     (51)\\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\\n    ///\\n    /// @param normal number which needs to be converted into Big Number\\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\\n    /// @param roundUp signals if result should be rounded down or up\\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\\n    function toBigNumber(\\n        uint256 normal,\\n        uint256 coefficientSize,\\n        uint256 exponentSize,\\n        bool roundUp\\n    ) internal pure returns (uint256 bigNumber) {\\n        assembly {\\n            let lastBit_\\n            let number_ := normal\\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x80, number_)\\n                lastBit_ := 0x80\\n            }\\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x40, number_)\\n                lastBit_ := add(lastBit_, 0x40)\\n            }\\n            if gt(number_, 0xFFFFFFFF) {\\n                number_ := shr(0x20, number_)\\n                lastBit_ := add(lastBit_, 0x20)\\n            }\\n            if gt(number_, 0xFFFF) {\\n                number_ := shr(0x10, number_)\\n                lastBit_ := add(lastBit_, 0x10)\\n            }\\n            if gt(number_, 0xFF) {\\n                number_ := shr(0x8, number_)\\n                lastBit_ := add(lastBit_, 0x8)\\n            }\\n            if gt(number_, 0xF) {\\n                number_ := shr(0x4, number_)\\n                lastBit_ := add(lastBit_, 0x4)\\n            }\\n            if gt(number_, 0x3) {\\n                number_ := shr(0x2, number_)\\n                lastBit_ := add(lastBit_, 0x2)\\n            }\\n            if gt(number_, 0x1) {\\n                lastBit_ := add(lastBit_, 1)\\n            }\\n            if gt(number_, 0) {\\n                lastBit_ := add(lastBit_, 1)\\n            }\\n            if lt(lastBit_, coefficientSize) {\\n                // for throw exception\\n                lastBit_ := coefficientSize\\n            }\\n            let exponent := sub(lastBit_, coefficientSize)\\n            let coefficient := shr(exponent, normal)\\n            if and(roundUp, gt(exponent, 0)) {\\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\\n                coefficient := add(coefficient, 1)\\n                if eq(shl(coefficientSize, 1), coefficient) {\\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\\n                    coefficient := shl(sub(coefficientSize, 1), 1)\\n                    exponent := add(exponent, 1)\\n                }\\n            }\\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\\n                // if exponent is >= exponentSize, the normal number is too big to fit within\\n                // BigNumber with too small sizes for coefficient and exponent\\n                revert(0, 0)\\n            }\\n            bigNumber := shl(exponentSize, coefficient)\\n            bigNumber := add(bigNumber, exponent)\\n        }\\n    }\\n\\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\\n    function fromBigNumber(\\n        uint256 bigNumber,\\n        uint256 exponentSize,\\n        uint256 exponentMask\\n    ) internal pure returns (uint256 normal) {\\n        assembly {\\n            let coefficient := shr(exponentSize, bigNumber)\\n            let exponent := and(bigNumber, exponentMask)\\n            normal := shl(exponent, coefficient)\\n        }\\n    }\\n\\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\\n    /// e.g.\\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\\n        assembly {\\n            let number_ := normal\\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x80, number_)\\n                lastBit := 0x80\\n            }\\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x40, number_)\\n                lastBit := add(lastBit, 0x40)\\n            }\\n            if gt(number_, 0xFFFFFFFF) {\\n                number_ := shr(0x20, number_)\\n                lastBit := add(lastBit, 0x20)\\n            }\\n            if gt(number_, 0xFFFF) {\\n                number_ := shr(0x10, number_)\\n                lastBit := add(lastBit, 0x10)\\n            }\\n            if gt(number_, 0xFF) {\\n                number_ := shr(0x8, number_)\\n                lastBit := add(lastBit, 0x8)\\n            }\\n            if gt(number_, 0xF) {\\n                number_ := shr(0x4, number_)\\n                lastBit := add(lastBit, 0x4)\\n            }\\n            if gt(number_, 0x3) {\\n                number_ := shr(0x2, number_)\\n                lastBit := add(lastBit, 0x2)\\n            }\\n            if gt(number_, 0x1) {\\n                lastBit := add(lastBit, 1)\\n            }\\n            if gt(number_, 0) {\\n                lastBit := add(lastBit, 1)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf0be1002909edf30aec3dc6623c2bd2407ed94064b62674c01032b844dec206a\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary LibsErrorTypes {\\n    /***********************************|\\n    |         LiquidityCalcs            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\\n\\n    /// @notice thrown when rate data is set to a version that is not implemented\\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\\n\\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\\n\\n    /***********************************|\\n    |           SafeTransfer            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when safe transfer from for an ERC20 fails\\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\\n\\n    /// @notice thrown when safe transfer for an ERC20 fails\\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\\n\\n    /***********************************|\\n    |           SafeApprove             | \\n    |__________________________________*/\\n\\n    /// @notice thrown when safe approve from for an ERC20 fails\\n    uint256 internal constant SafeApprove__ApproveFailed = 81001;\\n}\\n\",\"keccak256\":\"0x4057f500fd44ce9e89049512d06d5f72c46f91938ed37312fb044c204451009b\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/fluidProtocolTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ninterface IFluidProtocol {\\n    function TYPE() external view returns (uint256);\\n}\\n\\n/// @notice implements helper methods to filter Fluid protocols by a certain type\\nlibrary FluidProtocolTypes {\\n    uint256 internal constant VAULT_T1_TYPE = 10000; // VaultT1 borrow protocol type vaults\\n    uint256 internal constant VAULT_T2_SMART_COL_TYPE = 20000; // DEX protocol type vault\\n    uint256 internal constant VAULT_T3_SMART_DEBT_TYPE = 30000; // DEX protocol type vault\\n    uint256 internal constant VAULT_T4_SMART_COL_SMART_DEBT_TYPE = 40000; // DEX protocol type vault\\n\\n    /// @dev filters input `addresses_` by protocol `type_`. Input addresses must be actual Fluid protocols, otherwise\\n    ///      they would be wrongly assumed to be VaultT1 even if they are not Fluid VaultT1 smart contracts.\\n    ///      `type_` must be a listed constant type of this library.\\n    ///      Example usage is to filter all vault addresses at the Vault factory by a certain type, e.g. to not include\\n    ///      DEX protocol type vaults.\\n    function filterBy(address[] memory addresses_, uint256 type_) internal view returns (address[] memory filtered_) {\\n        uint256 curType_;\\n        uint256 filteredProtocols_ = addresses_.length;\\n        for (uint256 i; i < addresses_.length; ) {\\n            try IFluidProtocol(addresses_[i]).TYPE() returns (uint256 protocolType_) {\\n                curType_ = protocolType_;\\n            } catch {\\n                curType_ = VAULT_T1_TYPE;\\n            }\\n\\n            if (curType_ != type_) {\\n                addresses_[i] = address(0);\\n                --filteredProtocols_;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        filtered_ = new address[](filteredProtocols_);\\n        uint256 index_;\\n        unchecked {\\n            for (uint256 i; i < addresses_.length; ) {\\n                if (addresses_[i] != address(0)) {\\n                    filtered_[index_] = addresses_[i];\\n                    ++index_;\\n                }\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x98868cc272fea53dbd4504e02df4f4fcd709a4144a8b37a85513edd638bd073b\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/liquidityCalcs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { LibsErrorTypes as ErrorTypes } from \\\"./errorTypes.sol\\\";\\nimport { LiquiditySlotsLink } from \\\"./liquiditySlotsLink.sol\\\";\\nimport { BigMathMinified } from \\\"./bigMathMinified.sol\\\";\\n\\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\\n/// borrow rate, withdrawal / borrow limits, revenue amount.\\nlibrary LiquidityCalcs {\\n    error FluidLiquidityCalcsError(uint256 errorId_);\\n\\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\\n    event BorrowRateMaxCap();\\n\\n    /// @dev constants as from Liquidity variables.sol\\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\\n\\n    /// @dev Ignoring leap years\\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\\n    // constants used for BigMath conversion from and to storage\\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\\n\\n    uint256 internal constant FOUR_DECIMALS = 1e4;\\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\\n    uint256 internal constant X14 = 0x3fff;\\n    uint256 internal constant X15 = 0x7fff;\\n    uint256 internal constant X16 = 0xffff;\\n    uint256 internal constant X18 = 0x3ffff;\\n    uint256 internal constant X24 = 0xffffff;\\n    uint256 internal constant X33 = 0x1ffffffff;\\n    uint256 internal constant X64 = 0xffffffffffffffff;\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                  CALC EXCHANGE PRICES                  /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\\n    function calcExchangePrices(\\n        uint256 exchangePricesAndConfig_\\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\\n        // Extracting exchange prices\\n        supplyExchangePrice_ =\\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\\n            X64;\\n        borrowExchangePrice_ =\\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\\n            X64;\\n\\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\\n        }\\n\\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\\n\\n        unchecked {\\n            // last timestamp can not be > current timestamp\\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\\n\\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\\n                X15;\\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\\n                return (supplyExchangePrice_, borrowExchangePrice_);\\n            }\\n\\n            // calculate new borrow exchange price.\\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\\n            borrowExchangePrice_ +=\\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\\n\\n            // FOR SUPPLY EXCHANGE PRICE:\\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\\n            //\\n            // Example:\\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\\n            // yield is 10 (so half a year must have passed).\\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 20%) = 62,5%\\n            // supplyRate = (40% * (100% - 10%)) * = 36% * 62,5% = 22.5%\\n            // increase in supplyExchangePrice, assuming 100 as previous price.\\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\\n\\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\\n\\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\\n\\n            if (temp_ == 1) {\\n                // if no raw supply: no exchange price update needed\\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\\n                return (supplyExchangePrice_, borrowExchangePrice_);\\n            }\\n\\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\\n            if (temp_ & 1 == 1) {\\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\\n                temp_ = temp_ >> 1;\\n\\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\\n                // in the if statement a little above.\\n\\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\\n                // so ratioSupplyYield must come out as 2.5 (250%).\\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\\n                temp_ =\\n                    // utilization * (100% + 100% / supplyRatio)\\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\\n                    (FOUR_DECIMALS);\\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\\n            } else {\\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\\n                temp_ = temp_ >> 1;\\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\\n\\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\\n                temp_ =\\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\\n                    (1e27 *\\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\\n                        (FOUR_DECIMALS + temp_)) /\\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\\n            }\\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\\n\\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\\n            if (borrowRatio_ & 1 == 1) {\\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\\n                borrowRatio_ = borrowRatio_ >> 1;\\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\\n\\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\\n\\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\\n            } else {\\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\\n                borrowRatio_ = borrowRatio_ >> 1;\\n\\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\\n            }\\n\\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\\n\\n            // 2. calculate supply rate\\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\\n            // but more suppliers not earning interest.\\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\\n                temp_ * // ratioSupplyYield\\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\\n\\n            // 3. calculate increase in supply exchange price\\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                     CALC REVENUE                       /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\\n    /// and the current balance of the Fluid liquidity contract for the token.\\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\\n    /// @return revenueAmount_ collectable revenue amount\\n    function calcRevenue(\\n        uint256 totalAmounts_,\\n        uint256 exchangePricesAndConfig_,\\n        uint256 liquidityTokenBalance_\\n    ) internal view returns (uint256 revenueAmount_) {\\n        // @dev no need to super-optimize this method as it is only used by admin\\n\\n        // calculate the new exchange prices based on earned interest\\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\\n\\n        // total supply = interest free + with interest converted from raw\\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\\n\\n        if (totalSupply_ > 0) {\\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\\n            // ensure there is no possible case because of rounding etc. where this would revert,\\n            // explicitly check if >\\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\\n            // can only be revenue.\\n        } else {\\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\\n            revenueAmount_ = liquidityTokenBalance_;\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                      CALC LIMITS                       /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev calculates withdrawal limit before an operate execution:\\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\\n    /// @param userSupplyData_ user supply data packed uint256 from storage\\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\\n    function calcWithdrawalLimitBeforeOperate(\\n        uint256 userSupplyData_,\\n        uint256 userSupply_\\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\\n        // a deposit anyway. Important is that it would not revert.\\n\\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\\n        // is the fully expanded limit immediately.\\n\\n        // extract last set withdrawal limit\\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\\n        lastWithdrawalLimit_ =\\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\\n        if (lastWithdrawalLimit_ == 0) {\\n            // withdrawal limit is not activated. Max withdrawal allowed\\n            return 0;\\n        }\\n\\n        uint256 maxWithdrawableLimit_;\\n        uint256 temp_;\\n        unchecked {\\n            // extract max withdrawable percent of user supply and\\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\\n\\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            maxWithdrawableLimit_ =\\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\\n                FOUR_DECIMALS;\\n\\n            // time elapsed since last withdrawal limit was set (in seconds)\\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\\n            // last timestamp can not be > current timestamp\\n            temp_ =\\n                block.timestamp -\\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\\n        }\\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\\n        temp_ =\\n            (maxWithdrawableLimit_ * temp_) /\\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\\n        unchecked {\\n            // underflow explicitly checked & handled\\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\\n            temp_ = userSupply_ - maxWithdrawableLimit_;\\n        }\\n        // if withdrawal limit is decreased below minimum then set minimum\\n        // (e.g. when more than expandDuration time has elapsed)\\n        if (temp_ > currentWithdrawalLimit_) {\\n            currentWithdrawalLimit_ = temp_;\\n        }\\n    }\\n\\n    /// @dev calculates withdrawal limit after an operate execution:\\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\\n    /// @param userSupplyData_ user supply data packed uint256 from storage\\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\\n    ///                          raw for with interest mode, normal amount for interest free mode!\\n    function calcWithdrawalLimitAfterOperate(\\n        uint256 userSupplyData_,\\n        uint256 userSupply_,\\n        uint256 newWithdrawalLimit_\\n    ) internal pure returns (uint256) {\\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        // if user supply is below base limit then max withdrawals are allowed\\n        if (userSupply_ < temp_) {\\n            return 0;\\n        }\\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\\n        unchecked {\\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\\n        }\\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\\n        // increased deposit amount outpaces withrawals.\\n        if (temp_ > newWithdrawalLimit_) {\\n            return temp_;\\n        }\\n        return newWithdrawalLimit_;\\n    }\\n\\n    /// @dev calculates borrow limit before an operate execution:\\n    /// total amount user borrow can reach (not borrowable amount in current operation).\\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\\n    ///                             raw for with interest mode, normal amount for interest free mode!\\n    function calcBorrowLimitBeforeOperate(\\n        uint256 userBorrowData_,\\n        uint256 userBorrow_\\n    ) internal view returns (uint256 currentBorrowLimit_) {\\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\\n\\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\\n\\n        uint256 maxExpansionLimit_;\\n        uint256 maxExpandedBorrowLimit_;\\n        unchecked {\\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\\n\\n            // calculate max borrow limit: Max point limit can increase to since last interaction\\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\\n        }\\n\\n        // currentBorrowLimit_ = extract base borrow limit\\n        currentBorrowLimit_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\\n        currentBorrowLimit_ =\\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\\n            return currentBorrowLimit_;\\n        }\\n        // time elapsed since last borrow limit was set (in seconds)\\n        unchecked {\\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\\n            temp_ =\\n                block.timestamp -\\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\\n        }\\n\\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\\n        currentBorrowLimit_ =\\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\\n            ((maxExpansionLimit_ * temp_) /\\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\\n            //  extract last set borrow limit\\n            BigMathMinified.fromBigNumber(\\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\\n                DEFAULT_EXPONENT_SIZE,\\n                DEFAULT_EXPONENT_MASK\\n            );\\n\\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\\n        // so set to `maxExpandedBorrowLimit_` in that case.\\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\\n        }\\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (currentBorrowLimit_ > temp_) {\\n            currentBorrowLimit_ = temp_;\\n        }\\n    }\\n\\n    /// @dev calculates borrow limit after an operate execution:\\n    /// total amount user borrow can reach (not borrowable amount in current operation).\\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\\n    function calcBorrowLimitAfterOperate(\\n        uint256 userBorrowData_,\\n        uint256 userBorrow_,\\n        uint256 newBorrowLimit_\\n    ) internal pure returns (uint256 borrowLimit_) {\\n        // temp_ = extract borrow expand percent\\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\\n\\n        unchecked {\\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\\n        }\\n\\n        // temp_ = extract base borrow limit\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (borrowLimit_ < temp_) {\\n            // below base limit, borrow limit is always base limit\\n            return temp_;\\n        }\\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        // make sure fully expanded borrow limit is not above hard max borrow limit\\n        if (borrowLimit_ > temp_) {\\n            borrowLimit_ = temp_;\\n        }\\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\\n        if (newBorrowLimit_ > borrowLimit_) {\\n            return borrowLimit_;\\n        }\\n        return newBorrowLimit_;\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                      CALC RATES                        /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev Calculates new borrow rate from utilization for a token\\n    /// @param rateData_ rate data packed uint256 from storage for the token\\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\\n        // extract rate version: 4 bits (0xF) starting from bit 0\\n        uint256 rateVersion_ = (rateData_ & 0xF);\\n\\n        if (rateVersion_ == 1) {\\n            rate_ = calcRateV1(rateData_, utilization_);\\n        } else if (rateVersion_ == 2) {\\n            rate_ = calcRateV2(rateData_, utilization_);\\n        } else {\\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\\n        }\\n\\n        if (rate_ > X16) {\\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\\n            // this is unlikely to ever happen if configs stay within expected levels.\\n            rate_ = X16;\\n            // emit event to more easily become aware\\n            emit BorrowRateMaxCap();\\n        }\\n    }\\n\\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\\n    /// @param rateData_ rate data packed uint256 from storage for the token\\n    /// @param utilization_  in 1e2 (100% = 1e4)\\n    /// @return rate_ rate in 1e2 precision\\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\\n        /// For rate v1 (one kink) ------------------------------------------------------\\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\\n\\n        // y = mx + c.\\n        // y is borrow rate\\n        // x is utilization\\n        // m = slope (m can also be negative for declining rates)\\n        // c is constant (c can be negative)\\n\\n        uint256 y1_;\\n        uint256 y2_;\\n        uint256 x1_;\\n        uint256 x2_;\\n\\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\\n        if (utilization_ < kink1_) {\\n            // if utilization is less than kink\\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\\n            x1_ = 0; // 0%\\n            x2_ = kink1_;\\n        } else {\\n            // else utilization is greater than kink\\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\\n            x1_ = kink1_;\\n            x2_ = FOUR_DECIMALS; // 100%\\n        }\\n\\n        int256 constant_;\\n        int256 slope_;\\n        unchecked {\\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\\n\\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\\n\\n            // calculating new borrow rate\\n            // - slope_ max value is 65535 * 1e12,\\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\\n            // - constant max value is 65535 * 1e12\\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\\n            // divisor TWELVE_DECIMALS can not be 0\\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\\n            if (slope_ < 0) {\\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\\n            }\\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\\n        }\\n    }\\n\\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\\n    /// @param rateData_ rate data packed uint256 from storage for the token\\n    /// @param utilization_  in 1e2 (100% = 1e4)\\n    /// @return rate_ rate in 1e4 precision\\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\\n        /// For rate v2 (two kinks) -----------------------------------------------------\\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Last 156 bits => 100-255 => blank, might come in use in future\\n\\n        // y = mx + c.\\n        // y is borrow rate\\n        // x is utilization\\n        // m = slope (m can also be negative for declining rates)\\n        // c is constant (c can be negative)\\n\\n        uint256 y1_;\\n        uint256 y2_;\\n        uint256 x1_;\\n        uint256 x2_;\\n\\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\\n        if (utilization_ < kink1_) {\\n            // if utilization is less than kink1\\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\\n            x1_ = 0; // 0%\\n            x2_ = kink1_;\\n        } else {\\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\\n            if (utilization_ < kink2_) {\\n                // if utilization is less than kink2\\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\\n                x1_ = kink1_;\\n                x2_ = kink2_;\\n            } else {\\n                // else utilization is greater than kink2\\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\\n                x1_ = kink2_;\\n                x2_ = FOUR_DECIMALS;\\n            }\\n        }\\n\\n        int256 constant_;\\n        int256 slope_;\\n        unchecked {\\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\\n\\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\\n\\n            // calculating new borrow rate\\n            // - slope_ max value is 65535 * 1e12,\\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\\n            // - constant max value is 65535 * 1e12\\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\\n            // divisor TWELVE_DECIMALS can not be 0\\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\\n            if (slope_ < 0) {\\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\\n            }\\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\\n        }\\n    }\\n\\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\\n    function getTotalSupply(\\n        uint256 totalAmounts_,\\n        uint256 supplyExchangePrice_\\n    ) internal pure returns (uint256 totalSupply_) {\\n        // totalSupply_ => supplyInterestFree\\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\\n\\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\\n\\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\\n    }\\n\\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\\n    function getTotalBorrow(\\n        uint256 totalAmounts_,\\n        uint256 borrowExchangePrice_\\n    ) internal pure returns (uint256 totalBorrow_) {\\n        // totalBorrow_ => borrowInterestFree\\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\\n\\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\\n\\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\\n    }\\n}\\n\",\"keccak256\":\"0xa65e2f84b2c33769ceb6b28fbd3221be29da2f8ac96e4d8b8cea91948d81a707\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/liquiditySlotsLink.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\\nlibrary LiquiditySlotsLink {\\n    /// @dev storage slot for status at Liquidity\\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\\n    /// @dev storage slot for auths mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\\n    /// @dev storage slot for guardians mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\\n    /// @dev storage slot for user class mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\\n    /// @dev storage slot for rateData mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\\n    /// @dev storage slot for totalAmounts mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\\n    /// @dev storage slot for user supply double mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\\n    /// @dev storage slot for user borrow double mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\\n    /// @dev storage slot for listed tokens array at Liquidity\\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\\n    /// @dev storage slot for listed tokens array at Liquidity\\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\\n\\n    // --------------------------------\\n    // @dev stacked uint256 storage slots bits position data for each:\\n\\n    // ExchangePricesAndConfig\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\\n\\n    // RateData:\\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\\n    // RateData: V1\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\\n    // RateData: V2\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\\n\\n    // TotalAmounts\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\\n\\n    // UserSupplyData\\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\\n\\n    // UserBorrowData\\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\\n\\n    // Configs2\\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\\n\\n    // --------------------------------\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\\n    function calculateDoubleMappingStorageSlot(\\n        uint256 slot_,\\n        address key1_,\\n        address key2_\\n    ) internal pure returns (bytes32) {\\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\\n        return keccak256(abi.encode(key2_, intermediateSlot_));\\n    }\\n}\\n\",\"keccak256\":\"0x0ae3e1d231bb6c14b54fc1f5ffa306edc0ac827a6a92279c77c0c09627fe08ae\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/safeTransfer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport { LibsErrorTypes as ErrorTypes } from \\\"./errorTypes.sol\\\";\\n\\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\\nlibrary SafeTransfer {\\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 20000; // pass max. 20k gas for native transfers\\n\\n    error FluidSafeTransferError(uint256 errorId_);\\n\\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\\n        bool success_;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from_\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to_\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \\\"amount_\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success_ := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        if (!success_) {\\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\\n        }\\n    }\\n\\n    /// @dev Transfer `amount_` of `token_` to `to_`.\\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\\n        bool success_;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to_\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \\\"amount_\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success_ := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        if (!success_) {\\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\\n        }\\n    }\\n\\n    /// @dev Transfer `amount_` of ` native token to `to_`.\\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\\n    function safeTransferNative(address to_, uint256 amount_) internal {\\n        bool success_;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\\n        }\\n\\n        if (!success_) {\\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7f7d3a39d984c62e41c669a3d11deb899b3512ace9313263592575bf48a6e079\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/libraries/tickMath.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @title library that calculates number \\\"tick\\\" and \\\"ratioX96\\\" from this: ratioX96 = (1.0015^tick) * 2^96\\n/// @notice this library is used in Fluid Vault protocol for optimiziation.\\n/// @dev \\\"tick\\\" supports between -32767 and 32767. \\\"ratioX96\\\" supports between 37075072 and 169307877264527972847801929085841449095838922544595\\nlibrary TickMath {\\n    /// The minimum tick that can be passed in getRatioAtTick. 1.0015**-32767\\n    int24 internal constant MIN_TICK = -32767;\\n    /// The maximum tick that can be passed in getRatioAtTick. 1.0015**32767\\n    int24 internal constant MAX_TICK = 32767;\\n\\n    uint256 internal constant FACTOR00 = 0x100000000000000000000000000000000;\\n    uint256 internal constant FACTOR01 = 0xff9dd7de423466c20352b1246ce4856f; // 2^128/1.0015**1 = 339772707859149738855091969477551883631\\n    uint256 internal constant FACTOR02 = 0xff3bd55f4488ad277531fa1c725a66d0; // 2^128/1.0015**2 = 339263812140938331358054887146831636176\\n    uint256 internal constant FACTOR03 = 0xfe78410fd6498b73cb96a6917f853259; // 2^128/1.0015**4 = 338248306163758188337119769319392490073\\n    uint256 internal constant FACTOR04 = 0xfcf2d9987c9be178ad5bfeffaa123273; // 2^128/1.0015**8 = 336226404141693512316971918999264834163\\n    uint256 internal constant FACTOR05 = 0xf9ef02c4529258b057769680fc6601b3; // 2^128/1.0015**16 = 332218786018727629051611634067491389875\\n    uint256 internal constant FACTOR06 = 0xf402d288133a85a17784a411f7aba082; // 2^128/1.0015**32 = 324346285652234375371948336458280706178\\n    uint256 internal constant FACTOR07 = 0xe895615b5beb6386553757b0352bda90; // 2^128/1.0015**64 = 309156521885964218294057947947195947664\\n    uint256 internal constant FACTOR08 = 0xd34f17a00ffa00a8309940a15930391a; // 2^128/1.0015**128 = 280877777739312896540849703637713172762 \\n    uint256 internal constant FACTOR09 = 0xae6b7961714e20548d88ea5123f9a0ff; // 2^128/1.0015**256 = 231843708922198649176471782639349113087\\n    uint256 internal constant FACTOR10 = 0x76d6461f27082d74e0feed3b388c0ca1; // 2^128/1.0015**512 = 157961477267171621126394973980180876449\\n    uint256 internal constant FACTOR11 = 0x372a3bfe0745d8b6b19d985d9a8b85bb; // 2^128/1.0015**1024 = 73326833024599564193373530205717235131\\n    uint256 internal constant FACTOR12 = 0x0be32cbee48979763cf7247dd7bb539d; // 2^128/1.0015**2048 = 15801066890623697521348224657638773661\\n    uint256 internal constant FACTOR13 = 0x8d4f70c9ff4924dac37612d1e2921e;   // 2^128/1.0015**4096 = 733725103481409245883800626999235102\\n    uint256 internal constant FACTOR14 = 0x4e009ae5519380809a02ca7aec77;     // 2^128/1.0015**8192 = 1582075887005588088019997442108535\\n    uint256 internal constant FACTOR15 = 0x17c45e641b6e95dee056ff10;         // 2^128/1.0015**16384 = 7355550435635883087458926352\\n\\n    /// The minimum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MIN_TICK). ~ Equivalent to `(1 << 96) * (1.0015**-32767)`\\n    uint256 internal constant MIN_RATIOX96 = 37075072;\\n    /// The maximum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MAX_TICK).\\n    /// ~ Equivalent to `(1 << 96) * (1.0015**32767)`, rounding etc. leading to minor difference\\n    uint256 internal constant MAX_RATIOX96 = 169307877264527972847801929085841449095838922544595;\\n\\n    uint256 internal constant ZERO_TICK_SCALED_RATIO = 0x1000000000000000000000000; // 1 << 96 // 79228162514264337593543950336\\n    uint256 internal constant _1E26 = 1e26;\\n\\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return ratioX96 ratio = (debt amount/collateral amount)\\n    function getRatioAtTick(int tick) internal pure returns (uint256 ratioX96) {\\n        assembly {\\n            let absTick_ := sub(xor(tick, sar(255, tick)), sar(255, tick))\\n\\n            if gt(absTick_, MAX_TICK) {\\n                revert(0, 0)\\n            }\\n            let factor_ := FACTOR00\\n            if and(absTick_, 0x1) {\\n                factor_ := FACTOR01\\n            }\\n            if and(absTick_, 0x2) {\\n                factor_ := shr(128, mul(factor_, FACTOR02))\\n            }\\n            if and(absTick_, 0x4) {\\n                factor_ := shr(128, mul(factor_, FACTOR03))\\n            }\\n            if and(absTick_, 0x8) {\\n                factor_ := shr(128, mul(factor_, FACTOR04))\\n            }\\n            if and(absTick_, 0x10) {\\n                factor_ := shr(128, mul(factor_, FACTOR05))\\n            }\\n            if and(absTick_, 0x20) {\\n                factor_ := shr(128, mul(factor_, FACTOR06))\\n            }\\n            if and(absTick_, 0x40) {\\n                factor_ := shr(128, mul(factor_, FACTOR07))\\n            }\\n            if and(absTick_, 0x80) {\\n                factor_ := shr(128, mul(factor_, FACTOR08))\\n            }\\n            if and(absTick_, 0x100) {\\n                factor_ := shr(128, mul(factor_, FACTOR09))\\n            }\\n            if and(absTick_, 0x200) {\\n                factor_ := shr(128, mul(factor_, FACTOR10))\\n            }\\n            if and(absTick_, 0x400) {\\n                factor_ := shr(128, mul(factor_, FACTOR11))\\n            }\\n            if and(absTick_, 0x800) {\\n                factor_ := shr(128, mul(factor_, FACTOR12))\\n            }\\n            if and(absTick_, 0x1000) {\\n                factor_ := shr(128, mul(factor_, FACTOR13))\\n            }\\n            if and(absTick_, 0x2000) {\\n                factor_ := shr(128, mul(factor_, FACTOR14))\\n            }\\n            if and(absTick_, 0x4000) {\\n                factor_ := shr(128, mul(factor_, FACTOR15))\\n            }\\n\\n            let precision_ := 0\\n            if iszero(and(tick, 0x8000000000000000000000000000000000000000000000000000000000000000)) {\\n                factor_ := div(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, factor_)\\n                // we round up in the division so getTickAtRatio of the output price is always consistent\\n                if mod(factor_, 0x100000000) {\\n                    precision_ := 1\\n                }\\n            }\\n            ratioX96 := add(shr(32, factor_), precision_)\\n        }\\n    }\\n\\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\\n    /// @dev Throws if ratioX96 > max ratio || ratioX96 < min ratio\\n    /// @param ratioX96 The input ratio; ratio = (debt amount/collateral amount)\\n    /// @return tick The output tick for the above formula. Returns in round down form. if tick is 123.23 then 123, if tick is -123.23 then returns -124\\n    /// @return perfectRatioX96 perfect ratio for the above tick\\n    function getTickAtRatio(uint256 ratioX96) internal pure returns (int tick, uint perfectRatioX96) {\\n        assembly {\\n            if or(gt(ratioX96, MAX_RATIOX96), lt(ratioX96, MIN_RATIOX96)) {\\n                revert(0, 0)\\n            }\\n\\n            let cond := lt(ratioX96, ZERO_TICK_SCALED_RATIO)\\n            let factor_\\n\\n            if iszero(cond) {\\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\\n                factor_ := div(mul(ratioX96, _1E26), ZERO_TICK_SCALED_RATIO)\\n            }\\n            if cond {\\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\\n                factor_ := div(mul(ZERO_TICK_SCALED_RATIO, _1E26), ratioX96)\\n            }\\n\\n            // put in https://www.wolframalpha.com/ whole equation: (1.0015^tick) * 2^96 * 10^26 / 79228162514264337593543950336\\n\\n            // for tick = 16384\\n            // ratioX96 = (1.0015^16384) * 2^96 = 3665252098134783297721995888537077351735\\n            // 3665252098134783297721995888537077351735 * 10^26 / 79228162514264337593543950336 =\\n            // 4626198540796508716348404308345255985.06131964639489434655721\\n            if iszero(lt(factor_, 4626198540796508716348404308345255985)) {\\n                tick := or(tick, 0x4000)\\n                factor_ := div(mul(factor_, _1E26), 4626198540796508716348404308345255985)\\n            }\\n            // for tick = 8192\\n            // ratioX96 = (1.0015^8192) * 2^96 = 17040868196391020479062776466509865\\n            // 17040868196391020479062776466509865 * 10^26 / 79228162514264337593543950336 =\\n            // 21508599537851153911767490449162.3037648642153898377655505172\\n            if iszero(lt(factor_, 21508599537851153911767490449162)) {\\n                tick := or(tick, 0x2000)\\n                factor_ := div(mul(factor_, _1E26), 21508599537851153911767490449162)\\n            }\\n            // for tick = 4096\\n            // ratioX96 = (1.0015^4096) * 2^96 = 36743933851015821532611831851150\\n            // 36743933851015821532611831851150 * 10^26 / 79228162514264337593543950336 =\\n            // 46377364670549310883002866648.9777607649742626173648716941385\\n            if iszero(lt(factor_, 46377364670549310883002866649)) {\\n                tick := or(tick, 0x1000)\\n                factor_ := div(mul(factor_, _1E26), 46377364670549310883002866649)\\n            }\\n            // for tick = 2048\\n            // ratioX96 = (1.0015^2048) * 2^96 = 1706210527034005899209104452335\\n            // 1706210527034005899209104452335 * 10^26 / 79228162514264337593543950336 =\\n            // 2153540449365864845468344760.06357108484096046743300420319322\\n            if iszero(lt(factor_, 2153540449365864845468344760)) {\\n                tick := or(tick, 0x800)\\n                factor_ := div(mul(factor_, _1E26), 2153540449365864845468344760)\\n            }\\n            // for tick = 1024\\n            // ratioX96 = (1.0015^1024) * 2^96 = 367668226692760093024536487236\\n            // 367668226692760093024536487236 * 10^26 / 79228162514264337593543950336 =\\n            // 464062544207767844008185024.950588990554136265212906454481127\\n            if iszero(lt(factor_, 464062544207767844008185025)) {\\n                tick := or(tick, 0x400)\\n                factor_ := div(mul(factor_, _1E26), 464062544207767844008185025)\\n            }\\n            // for tick = 512\\n            // ratioX96 = (1.0015^512) * 2^96 = 170674186729409605620119663668\\n            // 170674186729409605620119663668 * 10^26 / 79228162514264337593543950336 =\\n            // 215421109505955298802281577.031879604792139232258508172947569\\n            if iszero(lt(factor_, 215421109505955298802281577)) {\\n                tick := or(tick, 0x200)\\n                factor_ := div(mul(factor_, _1E26), 215421109505955298802281577)\\n            }\\n            // for tick = 256\\n            // ratioX96 = (1.0015^256) * 2^96 = 116285004205991934861656513301\\n            // 116285004205991934861656513301 * 10^26 / 79228162514264337593543950336 =\\n            // 146772309890508740607270614.667650899656438875541505058062410\\n            if iszero(lt(factor_, 146772309890508740607270615)) {\\n                tick := or(tick, 0x100)\\n                factor_ := div(mul(factor_, _1E26), 146772309890508740607270615)\\n            }\\n            // for tick = 128\\n            // ratioX96 = (1.0015^128) * 2^96 = 95984619659632141743747099590\\n            // 95984619659632141743747099590 * 10^26 / 79228162514264337593543950336 =\\n            // 121149622323187099817270416.157248837742741760456796835775887\\n            if iszero(lt(factor_, 121149622323187099817270416)) {\\n                tick := or(tick, 0x80)\\n                factor_ := div(mul(factor_, _1E26), 121149622323187099817270416)\\n            }\\n            // for tick = 64\\n            // ratioX96 = (1.0015^64) * 2^96 = 87204845308406958006717891124\\n            // 87204845308406958006717891124 * 10^26 / 79228162514264337593543950336 =\\n            // 110067989135437147685980801.568068573422377364214113968609839\\n            if iszero(lt(factor_, 110067989135437147685980801)) {\\n                tick := or(tick, 0x40)\\n                factor_ := div(mul(factor_, _1E26), 110067989135437147685980801)\\n            }\\n            // for tick = 32\\n            // ratioX96 = (1.0015^32) * 2^96 = 83120873769022354029916374475\\n            // 83120873769022354029916374475 * 10^26 / 79228162514264337593543950336 =\\n            // 104913292358707887270979599.831816586773651266562785765558183\\n            if iszero(lt(factor_, 104913292358707887270979600)) {\\n                tick := or(tick, 0x20)\\n                factor_ := div(mul(factor_, _1E26), 104913292358707887270979600)\\n            }\\n            // for tick = 16\\n            // ratioX96 = (1.0015^16) * 2^96 = 81151180492336368327184716176\\n            // 81151180492336368327184716176 * 10^26 / 79228162514264337593543950336 =\\n            // 102427189924701091191840927.762844039579442328381455567932128\\n            if iszero(lt(factor_, 102427189924701091191840928)) {\\n                tick := or(tick, 0x10)\\n                factor_ := div(mul(factor_, _1E26), 102427189924701091191840928)\\n            }\\n            // for tick = 8\\n            // ratioX96 = (1.0015^8) * 2^96 = 80183906840906820640659903620\\n            // 80183906840906820640659903620 * 10^26 / 79228162514264337593543950336 =\\n            // 101206318935480056907421312.890625\\n            if iszero(lt(factor_, 101206318935480056907421313)) {\\n                tick := or(tick, 0x8)\\n                factor_ := div(mul(factor_, _1E26), 101206318935480056907421313)\\n            }\\n            // for tick = 4\\n            // ratioX96 = (1.0015^4) * 2^96 = 79704602139525152702959747603\\n            // 79704602139525152702959747603 * 10^26 / 79228162514264337593543950336 =\\n            // 100601351350506250000000000\\n            if iszero(lt(factor_, 100601351350506250000000000)) {\\n                tick := or(tick, 0x4)\\n                factor_ := div(mul(factor_, _1E26), 100601351350506250000000000)\\n            }\\n            // for tick = 2\\n            // ratioX96 = (1.0015^2) * 2^96 = 79466025265172787701084167660\\n            // 79466025265172787701084167660 * 10^26 / 79228162514264337593543950336 =\\n            // 100300225000000000000000000\\n            if iszero(lt(factor_, 100300225000000000000000000)) {\\n                tick := or(tick, 0x2)\\n                factor_ := div(mul(factor_, _1E26), 100300225000000000000000000)\\n            }\\n            // for tick = 1\\n            // ratioX96 = (1.0015^1) * 2^96 = 79347004758035734099934266261\\n            // 79347004758035734099934266261 * 10^26 / 79228162514264337593543950336 =\\n            // 100150000000000000000000000\\n            if iszero(lt(factor_, 100150000000000000000000000)) {\\n                tick := or(tick, 0x1)\\n                factor_ := div(mul(factor_, _1E26), 100150000000000000000000000)\\n            }\\n            if iszero(cond) {\\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\\n                perfectRatioX96 := div(mul(ratioX96, _1E26), factor_)\\n            }\\n            if cond {\\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\\n                tick := not(tick)\\n                perfectRatioX96 := div(mul(ratioX96, factor_), 100150000000000000000000000)\\n            }\\n            // perfect ratio should always be <= ratioX96\\n            // not sure if it can ever be bigger but better to have extra checks\\n            if gt(perfectRatioX96, ratioX96) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc5c13deaa16bb036a4370c0e38c33445712e8e7da1c792018dd3dc4a641ea0c0\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/adminModule/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Structs {\\n    struct AddressBool {\\n        address addr;\\n        bool value;\\n    }\\n\\n    struct AddressUint256 {\\n        address addr;\\n        uint256 value;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 1\\n    struct RateDataV1Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\\n        uint256 kink;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink;\\n        ///\\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 2\\n    struct RateDataV2Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\\n        uint256 kink1;\\n        ///\\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\\n        uint256 kink2;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink1;\\n        ///\\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\\n        uint256 rateAtUtilizationKink2;\\n        ///\\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set token config\\n    struct TokenConfig {\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 fee;\\n        ///\\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 threshold;\\n        ///\\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\\n        uint256 maxUtilization;\\n    }\\n\\n    /// @notice struct to set user supply & withdrawal config\\n    struct UserSupplyConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration withdrawal limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseWithdrawalLimit;\\n    }\\n\\n    /// @notice struct to set user borrow & payback config\\n    struct UserBorrowConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which debt limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration debt limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseDebtCeiling;\\n        ///\\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 maxDebtCeiling;\\n    }\\n}\\n\",\"keccak256\":\"0x10353c70015f27b880125cefab806dbed24a4458f187da66964f3ef60488f757\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/interfaces/iLiquidity.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { IProxy } from \\\"../../infiniteProxy/interfaces/iProxy.sol\\\";\\nimport { Structs as AdminModuleStructs } from \\\"../adminModule/structs.sol\\\";\\n\\ninterface IFluidLiquidityAdmin {\\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\\n    /// @param authsStatus_ array of structs setting allowed status for an address.\\n    ///                     status true => add auth, false => remove auth\\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\\n\\n    /// @notice adds/removes guardians. Only callable by Governance.\\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\\n    ///                         status true => add guardian, false => remove guardian\\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\\n\\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\\n    /// @param revenueCollector_  new revenue collector address\\n    function updateRevenueCollector(address revenueCollector_) external;\\n\\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\\n    /// @param newStatus_ new status\\n    ///        status = 2 -> pause, status = 1 -> resume.\\n    function changeStatus(uint256 newStatus_) external;\\n\\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\\n\\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\\n\\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\\n    ///         Only callable by Auths.\\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\\n\\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\\n    ///         Only callable by Auths.\\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\\n\\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\\n    ///         Only callable by Auths.\\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\\n\\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\\n    /// @param user_ user address for which to update the withdrawal limit\\n    /// @param token_ token address for which to update the withdrawal limit\\n    /// @param newLimit_ new limit until which user supply can decrease to.\\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\\n    ///                  current user supply as limit respectively.\\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\\n    ///                  below base limit then fully down to 0.\\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\\n\\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\\n    ///         Only callable by Auths.\\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\\n\\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\\n    /// Only callable by Guardians.\\n    /// @param user_          address of user to pause operations for\\n    /// @param supplyTokens_  token addresses to pause withdrawals for\\n    /// @param borrowTokens_  token addresses to pause borrowings for\\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\\n\\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\\n    /// Only callable by Guardians.\\n    /// @param user_          address of user to unpause operations for\\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\\n    /// @param borrowTokens_  token addresses to unpause borrowings for\\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\\n\\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\\n    /// @param tokens_  array of tokens to collect revenue for\\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\\n    function collectRevenue(address[] calldata tokens_) external;\\n\\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\\n    /// @param tokens_ tokens to update exchange prices for\\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\\n    function updateExchangePrices(\\n        address[] calldata tokens_\\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\\n}\\n\\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\\n    /// @notice Single function which handles supply, withdraw, borrow & payback\\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\\n    /// @param withdrawTo_ if withdrawal then to which address\\n    /// @param borrowTo_ if borrow then to which address\\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\\n    /// @return memVar3_ updated supplyExchangePrice\\n    /// @return memVar4_ updated borrowExchangePrice\\n    /// @dev to trigger skipping in / out transfers (gas optimization):\\n    /// -  ` callbackData_` MUST be encoded so that \\\"from\\\" address is the last 20 bytes in the last 32 bytes slot,\\n    ///     also for native token operations where liquidityCallback is not triggered!\\n    ///     from address must come at last position if there is more data. I.e. encode like:\\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\\n    /// -   this \\\"from\\\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\\n    ///     in the slot before (bytes 32 to 63)\\n    /// -   `msg.value` must be 0.\\n    /// -   Amounts must be either:\\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\\n    function operate(\\n        address token_,\\n        int256 supplyAmount_,\\n        int256 borrowAmount_,\\n        address withdrawTo_,\\n        address borrowTo_,\\n        bytes calldata callbackData_\\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\\n}\\n\\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\\n\",\"keccak256\":\"0x4aa83e84baa7c2f4d58b07a3eca4ab7fe7d6fc660898daaac338dc3f129c4123\",\"license\":\"MIT\"},\"contracts/protocols/dex/interfaces/iDexT1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IFluidDexT1 {\\n    error FluidDexError(uint256 errorId);\\n\\n    /// @notice used to simulate swap to find the output amount\\n    error FluidDexSwapResult(uint256 amountOut);\\n\\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\\n\\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\\n\\n    error FluidDexLiquidityOutput(uint256 shares);\\n\\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\\n\\n    /// @notice returns the dex id\\n    function DEX_ID() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct Implementations {\\n        address shift;\\n        address admin;\\n        address colOperations;\\n        address debtOperations;\\n        address perfectOperationsAndOracle;\\n    }\\n\\n    struct ConstantViews {\\n        uint256 dexId;\\n        address liquidity;\\n        address factory;\\n        Implementations implementations;\\n        address deployerContract;\\n        address token0;\\n        address token1;\\n        bytes32 supplyToken0Slot;\\n        bytes32 borrowToken0Slot;\\n        bytes32 supplyToken1Slot;\\n        bytes32 borrowToken1Slot;\\n        bytes32 exchangePriceToken0Slot;\\n        bytes32 exchangePriceToken1Slot;\\n        uint256 oracleMapping;\\n    }\\n\\n    struct ConstantViews2 {\\n        uint token0NumeratorPrecision;\\n        uint token0DenominatorPrecision;\\n        uint token1NumeratorPrecision;\\n        uint token1DenominatorPrecision;\\n    }\\n\\n    struct PricesAndExchangePrice {\\n        uint lastStoredPrice; // last stored price in 1e27 decimals\\n        uint centerPrice; // last stored price in 1e27 decimals\\n        uint upperRange; // price at upper range in 1e27 decimals\\n        uint lowerRange; // price at lower range in 1e27 decimals\\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\\n        uint supplyToken0ExchangePrice;\\n        uint borrowToken0ExchangePrice;\\n        uint supplyToken1ExchangePrice;\\n        uint borrowToken1ExchangePrice;\\n    }\\n\\n    struct CollateralReserves {\\n        uint token0RealReserves;\\n        uint token1RealReserves;\\n        uint token0ImaginaryReserves;\\n        uint token1ImaginaryReserves;\\n    }\\n\\n    struct DebtReserves {\\n        uint token0Debt;\\n        uint token1Debt;\\n        uint token0RealReserves;\\n        uint token1RealReserves;\\n        uint token0ImaginaryReserves;\\n        uint token1ImaginaryReserves;\\n    }\\n\\n    function getCollateralReserves(\\n        uint geometricMean_,\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint token0SupplyExchangePrice_,\\n        uint token1SupplyExchangePrice_\\n    ) external view returns (CollateralReserves memory c_);\\n\\n    function getDebtReserves(\\n        uint geometricMean_,\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint token0BorrowExchangePrice_,\\n        uint token1BorrowExchangePrice_\\n    ) external view returns (DebtReserves memory d_);\\n\\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\\n    function getPricesAndExchangePrices() external;\\n\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\\n\\n    struct Oracle {\\n        uint twap1by0; // TWAP price\\n        uint lowestPrice1by0; // lowest price point\\n        uint highestPrice1by0; // highest price point\\n        uint twap0by1; // TWAP price\\n        uint lowestPrice0by1; // lowest price point\\n        uint highestPrice0by1; // highest price point\\n    }\\n\\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountIn_ The exact amount of input tokens to swap\\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\\n    /// @return amountOut_ The amount of output tokens received from the swap\\n    function swapIn(\\n        bool swap0to1_,\\n        uint256 amountIn_,\\n        uint256 amountOutMin_,\\n        address to_\\n    ) external payable returns (uint256 amountOut_);\\n\\n    /// @dev Swap tokens with perfect amount out\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountOut_ The exact amount of tokens to receive after swap\\n    /// @param amountInMax_ Maximum amount of tokens to swap in\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\\n    /// @return amountIn_ The amount of input tokens used for the swap\\n    function swapOut(\\n        bool swap0to1_,\\n        uint256 amountOut_,\\n        uint256 amountInMax_,\\n        address to_\\n    ) external payable returns (uint256 amountIn_);\\n\\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\\n    /// @param shares_ The number of shares to mint\\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\\n    /// @return token0Amt_ Amount of token0 deposited\\n    /// @return token1Amt_ Amount of token1 deposited\\n    function depositPerfect(\\n        uint shares_,\\n        uint maxToken0Deposit_,\\n        uint maxToken1Deposit_,\\n        bool estimate_\\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\\n    /// @param shares_ The number of shares to withdraw\\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\\n    /// @return token0Amt_ The amount of token0 withdrawn\\n    /// @return token1Amt_ The amount of token1 withdrawn\\n    function withdrawPerfect(\\n        uint shares_,\\n        uint minToken0Withdraw_,\\n        uint minToken1Withdraw_,\\n        address to_\\n    ) external returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\\n    /// @param shares_ The number of shares to borrow\\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\\n    /// @return token0Amt_ Amount of token0 borrowed\\n    /// @return token1Amt_ Amount of token1 borrowed\\n    function borrowPerfect(\\n        uint shares_,\\n        uint minToken0Borrow_,\\n        uint minToken1Borrow_,\\n        address to_\\n    ) external returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\\n    /// @param shares_ The number of shares to pay back\\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\\n    /// @return token0Amt_ Amount of token0 paid back\\n    /// @return token1Amt_ Amount of token1 paid back\\n    function paybackPerfect(\\n        uint shares_,\\n        uint maxToken0Payback_,\\n        uint maxToken1Payback_,\\n        bool estimate_\\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\\n    /// @param token0Amt_ The amount of token0 to deposit\\n    /// @param token1Amt_ The amount of token1 to deposit\\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\\n    /// @return shares_ The amount of shares minted for the deposit\\n    function deposit(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint minSharesAmt_,\\n        bool estimate_\\n    ) external payable returns (uint shares_);\\n\\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\\n    /// @param token0Amt_ The amount of token0 to withdraw\\n    /// @param token1Amt_ The amount of token1 to withdraw\\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\\n    /// @return shares_ The number of shares burned for the withdrawal\\n    function withdraw(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint maxSharesAmt_,\\n        address to_\\n    ) external returns (uint shares_);\\n\\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\\n    /// @param token0Amt_ The amount of token0 to borrow\\n    /// @param token1Amt_ The amount of token1 to borrow\\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\\n    function borrow(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint maxSharesAmt_,\\n        address to_\\n    ) external returns (uint shares_);\\n\\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\\n    /// @param token0Amt_ The amount of token0 to payback\\n    /// @param token1Amt_ The amount of token1 to payback\\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\\n    /// @return shares_ The amount of borrow shares burned for the payback\\n    function payback(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint minSharesAmt_,\\n        bool estimate_\\n    ) external payable returns (uint shares_);\\n\\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\\n    /// @param shares_ The number of shares to burn for withdrawal\\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\\n    function withdrawPerfectInOneToken(\\n        uint shares_,\\n        uint minToken0_,\\n        uint minToken1_,\\n        address to_\\n    ) external returns (\\n        uint withdrawAmt_\\n    );\\n\\n    /// @dev This function allows users to payback their debt with perfect shares in one token\\n    /// @param shares_ The number of shares to burn for payback\\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\\n    function paybackPerfectInOneToken(\\n        uint shares_,\\n        uint maxToken0_,\\n        uint maxToken1_,\\n        bool estimate_\\n    ) external payable returns (\\n        uint paybackAmt_\\n    );\\n\\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\\n    /// but the difference due to interest will be super low so this difference is ignored\\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\\n    /// @return currentPrice_ price of pool after the most recent swap\\n    function oraclePrice(\\n        uint[] memory secondsAgos_\\n    ) external view returns (\\n        Oracle[] memory twaps_,\\n        uint currentPrice_\\n    );\\n}\\n\",\"keccak256\":\"0xa405007cdd45409412ce0fe02a991cadbae17760bc15402c839375505f69d7b2\",\"license\":\"MIT\"},\"contracts/protocols/vault/error.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Error {\\n    error FluidVaultError(uint256 errorId_);\\n\\n    /// @notice used to simulate liquidation to find the maximum liquidatable amounts\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n}\\n\",\"keccak256\":\"0x3109fe35234c0428642d43e70b56bcdbbfeef1d9e5ca29f4c8b8a181d7b8d83c\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary ErrorTypes {\\n    /***********************************|\\n    |           Vault Factory           | \\n    |__________________________________*/\\n\\n    uint256 internal constant VaultFactory__InvalidOperation = 30001;\\n    uint256 internal constant VaultFactory__Unauthorized = 30002;\\n    uint256 internal constant VaultFactory__SameTokenNotAllowed = 30003;\\n    uint256 internal constant VaultFactory__InvalidParams = 30004;\\n    uint256 internal constant VaultFactory__InvalidVault = 30005;\\n    uint256 internal constant VaultFactory__InvalidVaultAddress = 30006;\\n    uint256 internal constant VaultFactory__OnlyDelegateCallAllowed = 30007;\\n\\n    /***********************************|\\n    |            Vault                  | \\n    |__________________________________*/\\n\\n    /// @notice thrown at reentrancy\\n    uint256 internal constant Vault__AlreadyEntered = 31001;\\n\\n    /// @notice thrown when user sends deposit & borrow amount as 0\\n    uint256 internal constant Vault__InvalidOperateAmount = 31002;\\n\\n    /// @notice thrown when msg.value is not in sync with native token deposit or payback\\n    uint256 internal constant Vault__InvalidMsgValueOperate = 31003;\\n\\n    /// @notice thrown when msg.sender is not the owner of the vault\\n    uint256 internal constant Vault__NotAnOwner = 31004;\\n\\n    /// @notice thrown when user's position does not exist. Sending the wrong index from the frontend\\n    uint256 internal constant Vault__TickIsEmpty = 31005;\\n\\n    /// @notice thrown when the user's position is above CF and the user tries to make it more risky by trying to withdraw or borrow\\n    uint256 internal constant Vault__PositionAboveCF = 31006;\\n\\n    /// @notice thrown when the top tick is not initialized. Happens if the vault is totally new or all the user's left\\n    uint256 internal constant Vault__TopTickDoesNotExist = 31007;\\n\\n    /// @notice thrown when msg.value in liquidate is not in sync payback\\n    uint256 internal constant Vault__InvalidMsgValueLiquidate = 31008;\\n\\n    /// @notice thrown when slippage is more on liquidation than what the liquidator sent\\n    uint256 internal constant Vault__ExcessSlippageLiquidation = 31009;\\n\\n    /// @notice thrown when msg.sender is not the rebalancer/reserve contract\\n    uint256 internal constant Vault__NotRebalancer = 31010;\\n\\n    /// @notice thrown when NFT of one vault interacts with the NFT of other vault\\n    uint256 internal constant Vault__NftNotOfThisVault = 31011;\\n\\n    /// @notice thrown when the token is not initialized on the liquidity contract\\n    uint256 internal constant Vault__TokenNotInitialized = 31012;\\n\\n    /// @notice thrown when admin updates fallback if a non-auth calls vault\\n    uint256 internal constant Vault__NotAnAuth = 31013;\\n\\n    /// @notice thrown in operate when user tries to witdhraw more collateral than deposited\\n    uint256 internal constant Vault__ExcessCollateralWithdrawal = 31014;\\n\\n    /// @notice thrown in operate when user tries to payback more debt than borrowed\\n    uint256 internal constant Vault__ExcessDebtPayback = 31015;\\n\\n    /// @notice thrown when user try to withdrawal more than operate's withdrawal limit\\n    uint256 internal constant Vault__WithdrawMoreThanOperateLimit = 31016;\\n\\n    /// @notice thrown when caller of liquidityCallback is not Liquidity\\n    uint256 internal constant Vault__InvalidLiquidityCallbackAddress = 31017;\\n\\n    /// @notice thrown when reentrancy is not already on\\n    uint256 internal constant Vault__NotEntered = 31018;\\n\\n    /// @notice thrown when someone directly calls operate or secondary implementation contract\\n    uint256 internal constant Vault__OnlyDelegateCallAllowed = 31019;\\n\\n    /// @notice thrown when the safeTransferFrom for a token amount failed\\n    uint256 internal constant Vault__TransferFromFailed = 31020;\\n\\n    /// @notice thrown when exchange price overflows while updating on storage\\n    uint256 internal constant Vault__ExchangePriceOverFlow = 31021;\\n\\n    /// @notice thrown when debt to liquidate amt is sent wrong\\n    uint256 internal constant Vault__InvalidLiquidationAmt = 31022;\\n\\n    /// @notice thrown when user debt or collateral goes above 2**128 or below -2**128\\n    uint256 internal constant Vault__UserCollateralDebtExceed = 31023;\\n\\n    /// @notice thrown if on liquidation branch debt becomes lower than 100\\n    uint256 internal constant Vault__BranchDebtTooLow = 31024;\\n\\n    /// @notice thrown when tick's debt is less than 10000\\n    uint256 internal constant Vault__TickDebtTooLow = 31025;\\n\\n    /// @notice thrown when the received new liquidity exchange price is of unexpected value (< than the old one)\\n    uint256 internal constant Vault__LiquidityExchangePriceUnexpected = 31026;\\n\\n    /// @notice thrown when user's debt is less than 10000\\n    uint256 internal constant Vault__UserDebtTooLow = 31027;\\n\\n    /// @notice thrown when on only payback and only deposit the ratio of position increases\\n    uint256 internal constant Vault__InvalidPaybackOrDeposit = 31028;\\n\\n    /// @notice thrown when liquidation just happens of a single partial or when there's nothing to liquidate\\n    uint256 internal constant Vault__InvalidLiquidation = 31029;\\n\\n    /// @notice thrown when msg.value is sent wrong in rebalance\\n    uint256 internal constant Vault__InvalidMsgValueInRebalance = 31030;\\n\\n    /// @notice thrown when nothing rebalanced\\n    uint256 internal constant Vault__NothingToRebalance = 31031;\\n\\n    /// @notice thrown on unforseen liquidation scenarios. Might never come in use.\\n    uint256 internal constant Vault__LiquidationReverts = 31032;\\n\\n    /// @notice thrown when oracle price is > 1e54\\n    uint256 internal constant Vault__InvalidOraclePrice = 31033;\\n\\n    /// @notice thrown when constants are not set properly via contructor\\n    uint256 internal constant Vault__ImproperConstantsSetup = 31034;\\n\\n    /// @notice thrown when externally calling fetchLatestPosition function\\n    uint256 internal constant Vault__FetchLatestPositionFailed = 31035;\\n\\n    /// @notice thrown when dex callback is not from dex\\n    uint256 internal constant Vault__InvalidDexCallbackAddress = 31036;\\n\\n    /// @notice thrown when dex callback is already set\\n    uint256 internal constant Vault__DexFromAddressAlreadySet = 31037;\\n\\n    /// @notice thrown when an invalid min / max amounts config is passed to rebalance()\\n    uint256 internal constant Vault__InvalidMinMaxInRebalance = 31038;\\n\\n    /***********************************|\\n    |              ERC721               | \\n    |__________________________________*/\\n\\n    uint256 internal constant ERC721__InvalidParams = 32001;\\n    uint256 internal constant ERC721__Unauthorized = 32002;\\n    uint256 internal constant ERC721__InvalidOperation = 32003;\\n    uint256 internal constant ERC721__UnsafeRecipient = 32004;\\n    uint256 internal constant ERC721__OutOfBoundsIndex = 32005;\\n\\n    /***********************************|\\n    |            Vault Admin            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when admin tries to setup invalid value which are crossing limits\\n    uint256 internal constant VaultAdmin__ValueAboveLimit = 33001;\\n\\n    /// @notice when someone directly calls admin implementation contract\\n    uint256 internal constant VaultAdmin__OnlyDelegateCallAllowed = 33002;\\n\\n    /// @notice thrown when auth sends NFT ID as 0 while collecting dust debt\\n    uint256 internal constant VaultAdmin__NftIdShouldBeNonZero = 33003;\\n\\n    /// @notice thrown when trying to collect dust debt of NFT which is not of this vault\\n    uint256 internal constant VaultAdmin__NftNotOfThisVault = 33004;\\n\\n    /// @notice thrown when dust debt of NFT is 0, meaning nothing to collect\\n    uint256 internal constant VaultAdmin__DustDebtIsZero = 33005;\\n\\n    /// @notice thrown when final debt after liquidation is not 0, meaning position 100% liquidated\\n    uint256 internal constant VaultAdmin__FinalDebtShouldBeZero = 33006;\\n\\n    /// @notice thrown when NFT is not liquidated state\\n    uint256 internal constant VaultAdmin__NftNotLiquidated = 33007;\\n\\n    /// @notice thrown when total absorbed dust debt is 0\\n    uint256 internal constant VaultAdmin__AbsorbedDustDebtIsZero = 33008;\\n\\n    /// @notice thrown when address is set as 0\\n    uint256 internal constant VaultAdmin__AddressZeroNotAllowed = 33009;\\n\\n    /***********************************|\\n    |            Vault Rewards          | \\n    |__________________________________*/\\n\\n    uint256 internal constant VaultRewards__Unauthorized = 34001;\\n    uint256 internal constant VaultRewards__AddressZero = 34002;\\n    uint256 internal constant VaultRewards__InvalidParams = 34003;\\n    uint256 internal constant VaultRewards__NewMagnifierSameAsOldMagnifier = 34004;\\n    uint256 internal constant VaultRewards__NotTheInitiator = 34005;\\n    uint256 internal constant VaultRewards__NotTheGovernance = 34006;\\n    uint256 internal constant VaultRewards__AlreadyStarted = 34007;\\n    uint256 internal constant VaultRewards__RewardsNotStartedOrEnded = 34008;\\n    uint256 internal constant VaultRewards__InvalidStartTime = 34009;\\n    uint256 internal constant VaultRewards__AlreadyEnded = 34010;\\n\\n    /***********************************|\\n    |          Vault DEX Types          | \\n    |__________________________________*/\\n\\n    uint256 internal constant VaultDex__InvalidOperateAmount = 35001;\\n    uint256 internal constant VaultDex__DebtSharesPaidMoreThanAvailableLiquidation = 35002;\\n\\n    /***********************************|\\n    |        Vault Borrow Rewards       | \\n    |__________________________________*/\\n\\n    uint256 internal constant VaultBorrowRewards__Unauthorized = 36001;\\n    uint256 internal constant VaultBorrowRewards__AddressZero = 36002;\\n    uint256 internal constant VaultBorrowRewards__InvalidParams = 36003;\\n    uint256 internal constant VaultBorrowRewards__NewMagnifierSameAsOldMagnifier = 36004;\\n    uint256 internal constant VaultBorrowRewards__NotTheInitiator = 36005;\\n    uint256 internal constant VaultBorrowRewards__NotTheGovernance = 36006;\\n    uint256 internal constant VaultBorrowRewards__AlreadyStarted = 36007;\\n    uint256 internal constant VaultBorrowRewards__RewardsNotStartedOrEnded = 36008;\\n    uint256 internal constant VaultBorrowRewards__InvalidStartTime = 36009;\\n    uint256 internal constant VaultBorrowRewards__AlreadyEnded = 36010;\\n}\\n\",\"keccak256\":\"0x60266494213793e62a94cf7989487939e4e88aeb052150c4dc17dbfb1648693d\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/interfaces/iLiquidityDexCommon.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { IFluidLiquidityLogic } from \\\"../../../liquidity/interfaces/iLiquidity.sol\\\";\\nimport { IFluidDexT1 } from \\\"../../dex/interfaces/iDexT1.sol\\\";\\n\\ninterface ILiquidityDexCommon is IFluidLiquidityLogic, IFluidDexT1 {\\n    /// @notice only importing IFluidLiquidityLogic as readFromStorage is also defined in iDexT1 as well so to avoid clashing\\n}\\n\",\"keccak256\":\"0x513dd93f3a1e8d4611980212a9a7731a324afe06825777a0936f113ccccf54d3\",\"license\":\"MIT\"},\"contracts/protocols/vault/interfaces/iVault.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\\ninterface IFluidVault {\\n    /// @notice returns the vault id\\n    function VAULT_ID() external view returns (uint256);\\n\\n    /// @notice returns the vault id\\n    function TYPE() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct Tokens {\\n        address token0;\\n        address token1;\\n    }\\n\\n    struct ConstantViews {\\n        address liquidity;\\n        address factory;\\n        address operateImplementation;\\n        address adminImplementation;\\n        address secondaryImplementation;\\n        address deployer; // address which deploys oracle\\n        address supply; // either liquidity layer or DEX protocol\\n        address borrow; // either liquidity layer or DEX protocol\\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\\n        uint256 vaultId;\\n        uint256 vaultType;\\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n    }\\n\\n    /// @notice returns all Vault constants\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    /// @notice fetches the latest user position after a liquidation\\n    function fetchLatestPosition(\\n        int256 positionTick_,\\n        uint256 positionTickId_,\\n        uint256 positionRawDebt_,\\n        uint256 tickData_\\n    )\\n        external\\n        view\\n        returns (\\n            int256, // tick\\n            uint256, // raw debt\\n            uint256, // raw collateral\\n            uint256, // branchID_\\n            uint256 // branchData_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices\\n    function updateExchangePrices(\\n        uint256 vaultVariables2_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices and writes them to storage\\n    function updateExchangePricesOnStorage()\\n        external\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice returns the liquidity contract address\\n    function LIQUIDITY() external view returns (address);\\n\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n\\n    function rebalance(\\n        int colToken0MinMax_,\\n        int colToken1MinMax_,\\n        int debtToken0MinMax_,\\n        int debtToken1MinMax_\\n    ) external payable returns (int supplyAmt_, int borrowAmt_);\\n\\n    /// @notice reverts with FluidLiquidateResult\\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\\n}\\n\",\"keccak256\":\"0xdd764652f8451a71d2f2006b2572fccd9c21f1d64196869bfc291d10f151f0c6\",\"license\":\"MIT\"},\"contracts/protocols/vault/vaultTypesCommon/common/tokenTransfers.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { SafeTransfer } from \\\"../../../../libraries/safeTransfer.sol\\\";\\nimport { ErrorTypes } from \\\"../../errorTypes.sol\\\";\\nimport { Error } from \\\"../../error.sol\\\";\\n\\nabstract contract TokenTransfers is Error {\\n    function _validateEth(uint initialEth_) internal {\\n        uint finalEth_ = payable(address(this)).balance;\\n        if (finalEth_ > initialEth_) {\\n            unchecked {\\n                SafeTransfer.safeTransferNative(msg.sender, finalEth_ - initialEth_); // sending back excess ETH\\n            }\\n        } else if (finalEth_ < initialEth_) {\\n            revert FluidVaultError(ErrorTypes.Vault__InvalidMsgValueOperate);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdc250682d374ea372440cbbc5f60ed5c05cefee234e3756bb650b517ff30af27\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/vaultTypesCommon/common/variables.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Variables {\\n    /***********************************|\\n    |         Storage Variables         |\\n    |__________________________________*/\\n\\n    /// note: in all variables. For tick >= 0 are represented with bit as 1, tick < 0 are represented with bit as 0\\n    /// note: read all the variables through storageRead.sol\\n\\n    /// note: vaultVariables contains vault variables which need regular updates through transactions\\n    /// First 1 bit => 0 => re-entrancy. If 0 then allow transaction to go, else throw.\\n    /// Next 1 bit => 1 => Is the current active branch liquidated? If true then check the branch's minima tick before creating a new position\\n    /// If the new tick is greater than minima tick then initialize a new branch, make that as current branch & do proper linking\\n    /// Next 1 bit => 2 => sign of topmost tick (0 -> negative; 1 -> positive)\\n    /// Next 19 bits => 3-21 => absolute value of topmost tick\\n    /// Next 30 bits => 22-51 => current branch ID\\n    /// Next 30 bits => 52-81 => total branch ID\\n    /// Next 64 bits => 82-145 => Total supply\\n    /// Next 64 bits => 146-209 => Total borrow\\n    /// Next 32 bits => 210-241 => Total positions\\n    uint256 internal vaultVariables;\\n\\n    /// note: vaultVariables2 contains variables which do not update on every transaction. So mainly admin/auth set amount\\n    /// First 16 bits => 0-15 => supply rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\\n    /// Next 16 bits => 16-31 => borrow rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\\n    /// Next 10 bits => 32-41 => collateral factor. 800 = 0.8 = 80% (max precision of 0.1%)\\n    /// Next 10 bits => 42-51 => liquidation Threshold. 900 = 0.9 = 90% (max precision of 0.1%)\\n    /// Next 10 bits => 52-61 => liquidation Max Limit. 950 = 0.95 = 95% (max precision of 0.1%) (above this 100% liquidation can happen)\\n    /// Next 10 bits => 62-71 => withdraw gap. 100 = 0.1 = 10%. (max precision of 0.1%) (max 7 bits can also suffice for the requirement here of 0.1% to 10%). Needed to save some limits on withdrawals so liquidate can work seamlessly.\\n    /// Next 10 bits => 72-81 => liquidation penalty. 100 = 0.01 = 1%. (max precision of 0.01%) (max liquidation penantly can be 10.23%). Applies when tick is in between liquidation Threshold & liquidation Max Limit.\\n    /// Next 10 bits => 82-91 => borrow fee. 100 = 0.01 = 1%. (max precision of 0.01%) (max borrow fee can be 10.23%). Fees on borrow.\\n    /// Next 30 bits => 92-121 => bits to calculate address of oracle\\n    /// Next 33 bits => 122-154 => last update timestamp\\n    uint256 internal vaultVariables2;\\n\\n    /// note: stores absorbed liquidity\\n    /// First 128 bits raw debt amount\\n    /// last 128 bits raw col amount\\n    uint256 internal absorbedLiquidity;\\n\\n    /// position index => position data uint\\n    /// if the entire variable is 0 (meaning not initialized) at the start that means no position at all\\n    /// First 1 bit => 0 => position type (0 => borrow position; 1 => supply position)\\n    /// Next 1 bit => 1 => sign of user's tick (0 => negative; 1 => positive)\\n    /// Next 19 bits => 2-20 => absolute value of user's tick\\n    /// Next 24 bits => 21-44 => user's tick's id\\n    /// Below we are storing user's collateral & not debt, because the position can also be only collateral with no tick but it can never be only debt\\n    /// Next 64 bits => 45-108 => user's supply amount. Debt will be calculated through supply & ratio.\\n    /// Next 64 bits => 109-172 => user's dust debt amount. User's net debt = total debt - dust amount. Total debt is calculated through supply & ratio\\n    /// User won't pay any extra interest on dust debt & hence we will not show it as a debt on UI. For user's there's no dust.\\n    mapping(uint256 => uint256) internal positionData;\\n\\n    /// Tick has debt only keeps data of non liquidated positions. liquidated tick's data stays in branch itself\\n    /// tick parent => uint (represents bool for 256 children)\\n    /// parent of (i)th tick:-\\n    /// if (i>=0) (i / 256);\\n    /// else ((i + 1) / 256) - 1\\n    /// first bit of the variable is the smallest tick & last bit is the biggest tick of that slot\\n    mapping(int256 => uint256) internal tickHasDebt;\\n\\n    /// mapping tickId => tickData\\n    /// Tick related data. Total debt & other things\\n    /// First bit => 0 => If 1 then liquidated else not liquidated\\n    /// Next 24 bits => 1-24 => Total IDs. ID should start from 1.\\n    /// If not liquidated:\\n    /// Next 64 bits => 25-88 => raw debt\\n    /// If liquidated\\n    /// The below 3 things are of last ID. This is to be updated when user creates a new position\\n    /// Next 1 bit => 25 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated (100% liquidated)\\n    /// Next 30 bits => 26-55 => branch ID where this tick got liquidated\\n    /// Next 50 bits => 56-105 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\\n    mapping(int256 => uint256) internal tickData;\\n\\n    /// tick id => previous tick id liquidation data. ID starts from 1\\n    /// One tick ID contains 3 IDs of 80 bits in it, holding liquidation data of previously active but liquidated ticks\\n    /// 81 bits data below\\n    /// #### First 85 bits ####\\n    /// 1st bit => 0 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\\n    /// Next 30 bits => 1-30 => branch ID where this tick got liquidated\\n    /// Next 50 bits => 31-80 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\\n    /// #### Second 85 bits ####\\n    /// 85th bit => 85 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\\n    /// Next 30 bits => 86-115 => branch ID where this tick got liquidated\\n    /// Next 50 bits => 116-165 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\\n    /// #### Third 85 bits ####\\n    /// 170th bit => 170 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\\n    /// Next 30 bits => 171-200 => branch ID where this tick got liquidated\\n    /// Next 50 bits => 201-250 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\\n    mapping(int256 => mapping(uint256 => uint256)) internal tickId;\\n\\n    /// mapping branchId => branchData\\n    /// First 2 bits => 0-1 => if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\\n    /// merged means the branch is merged into it's base branch\\n    /// closed means all the users are 100% liquidated\\n    /// Next 1 bit => 2 => minima tick sign of this branch. Will only be there if any liquidation happened.\\n    /// Next 19 bits => 3-21 => minima tick of this branch. Will only be there if any liquidation happened.\\n    /// Next 30 bits => 22-51 => Partials of minima tick of branch this is connected to. 0 if master branch.\\n    /// Next 64 bits => 52-115 Debt liquidity at this branch. Similar to last's top tick data. Remaining debt will move here from tickData after first liquidation\\n    /// If not merged\\n    /// Next 50 bits => 116-165 => Debt factor or of this branch. (35 bits coefficient | 15 bits expansion)\\n    /// If merged\\n    /// Next 50 bits => 116-165 => Connection/adjustment debt factor of this branch with the next branch.\\n    /// If closed\\n    /// Next 50 bits => 116-165 => Debt factor as 0. As all the user's positions are now fully gone\\n    /// following values are present always again (merged / not merged / closed)\\n    /// Next 30 bits => 166-195 => Branch's ID with which this branch is connected. If 0 then that means this is the master branch\\n    /// Next 1 bit => 196 => sign of minima tick of branch this is connected to. 0 if master branch.\\n    /// Next 19 bits => 197-215 => minima tick of branch this is connected to. 0 if master branch.\\n    mapping(uint256 => uint256) internal branchData;\\n\\n    /// Exchange prices are in 1e12\\n    /// First 64 bits => 0-63 => Liquidity's collateral token supply exchange price\\n    /// First 64 bits => 64-127 => Liquidity's debt token borrow exchange price\\n    /// First 64 bits => 128-191 => Vault's collateral token supply exchange price\\n    /// First 64 bits => 192-255 => Vault's debt token borrow exchange price\\n    uint256 internal rates;\\n\\n    /// address of rebalancer\\n    address internal rebalancer;\\n\\n    uint256 internal absorbedDustDebt;\\n\\n    address internal dexFromAddress;\\n}\\n\",\"keccak256\":\"0x9570e35a881e0d48efe60f486744c4818f9ae87ae350b4aeab2bfbf499fef586\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/vaultTypesCommon/coreModule/events.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Events {\\n    /// @notice emitted when an operate() method is executed that changes collateral (`colAmt_`) / debt (debtAmt_`)\\n    /// amount for a `user_` position with `nftId_`. Receiver of any funds is the address `to_`.\\n    event LogOperate(address user_, uint256 nftId_, int256 colAmt_, int256 debtAmt_, address to_);\\n\\n    /// @notice emitted when the exchange prices are updated in storage.\\n    event LogUpdateExchangePrice(uint256 supplyExPrice_, uint256 borrowExPrice_);\\n\\n    /// @notice emitted when a liquidation has been executed.\\n    event LogLiquidate(address liquidator_, uint256 colAmt_, uint256 debtAmt_, address to_);\\n\\n    /// @notice emitted when `absorb()` was executed to absorb bad debt.\\n    event LogAbsorb(uint colAbsorbedRaw_, uint debtAbsorbedRaw_);\\n\\n    /// @notice emitted when a `rebalance()` has been executed, balancing out total supply / borrow between Vault\\n    /// and Fluid Liquidity pools.\\n    /// if `colAmt_` is positive then loss, meaning transfer from rebalancer address to vault and deposit.\\n    /// if `colAmt_` is negative then profit, meaning withdrawn from vault and sent to rebalancer address.\\n    /// if `debtAmt_` is positive then profit, meaning borrow from vault and sent to rebalancer address.\\n    /// if `debtAmt_` is negative then loss, meaning transfer from rebalancer address to vault and payback.\\n    event LogRebalance(int colAmt_, int debtAmt_);\\n}\\n\",\"keccak256\":\"0x3a04edff692d5367929cec3a8cc2ee5be997dd95bf5e0bae47a5abd3c5f8d0a9\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/vaultTypesCommon/coreModule/main2.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Variables } from \\\"../common/variables.sol\\\";\\nimport { TickMath } from \\\"../../../../libraries/tickMath.sol\\\";\\nimport { BigMathMinified } from \\\"../../../../libraries/bigMathMinified.sol\\\";\\nimport { Error } from \\\"../../error.sol\\\";\\nimport { ErrorTypes } from \\\"../../errorTypes.sol\\\";\\nimport { IFluidVault } from \\\"../../interfaces/iVault.sol\\\";\\nimport { Structs } from \\\"./structs.sol\\\";\\nimport { Events } from \\\"./events.sol\\\";\\nimport { LiquiditySlotsLink } from \\\"../../../../libraries/liquiditySlotsLink.sol\\\";\\nimport { LiquidityCalcs } from \\\"../../../../libraries/liquidityCalcs.sol\\\";\\nimport { ILiquidityDexCommon } from \\\"../../interfaces/iLiquidityDexCommon.sol\\\";\\nimport { SafeTransfer } from \\\"../../../../libraries/safeTransfer.sol\\\";\\nimport { TokenTransfers } from \\\"../common/tokenTransfers.sol\\\";\\nimport { FluidProtocolTypes } from \\\"../../../../libraries/fluidProtocolTypes.sol\\\";\\n\\n/// @notice Fluid Vault protocol secondary methods contract.\\n///         Implements `absorb()` and `rebalance()` methods, extracted from main contract due to contract size limits.\\n///         Methods are limited to be called via delegateCall only (as done by Vault CoreModule contract).\\ncontract FluidVaultSecondary is Variables, Error, Structs, Events, TokenTransfers {\\n    using BigMathMinified for uint;\\n\\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    // 30 bits (used for partials mainly)\\n    uint internal constant X8 = 0xff;\\n    uint internal constant X10 = 0x3ff;\\n    uint internal constant X16 = 0xffff;\\n    uint internal constant X19 = 0x7ffff;\\n    uint internal constant X20 = 0xfffff;\\n    uint internal constant X24 = 0xffffff;\\n    uint internal constant X25 = 0x1ffffff;\\n    uint internal constant X30 = 0x3fffffff;\\n    uint internal constant X35 = 0x7ffffffff;\\n    uint internal constant X50 = 0x3ffffffffffff;\\n    uint internal constant X64 = 0xffffffffffffffff;\\n    uint internal constant X96 = 0xffffffffffffffffffffffff;\\n    uint internal constant X128 = 0xffffffffffffffffffffffffffffffff;\\n\\n    address private immutable addressThis;\\n\\n    constructor() {\\n        addressThis = address(this);\\n    }\\n\\n    modifier _verifyCaller() {\\n        if (address(this) == addressThis) {\\n            revert FluidVaultError(ErrorTypes.Vault__OnlyDelegateCallAllowed);\\n        }\\n        _;\\n    }\\n\\n    /// @dev absorb function absorbs the bad debt if the bad debt is above max limit. The main use of it is\\n    /// if the bad debt didn't got liquidated in time maybe due to sudden price drop or bad debt was extremely small to liquidate\\n    /// and the bad debt goes above 100% ratio then there's no incentive for anyone to liquidate now\\n    /// hence absorb functions absorbs that bad debt to allow newer bad debt to liquidate seamlessly.\\n    /// if absorbing were to happen after this it's on governance on how to deal with it\\n    /// although it can still be removed through liquidate via liquidator if the price goes back up and liquidation becomes beneficial\\n    /// upon absorbed user position gets 100% liquidated.\\n    function absorb(uint vaultVariables_, int maxTick_) public payable _verifyCaller returns (uint) {\\n        AbsorbMemoryVariables memory a_;\\n\\n        // Temporary holder variables, used many times for different small few liner things\\n        uint temp_;\\n        uint temp2_;\\n\\n        TickHasDebt memory tickHasDebt_;\\n\\n        {\\n            // liquidating ticks above max ratio\\n\\n            // temp_ -> top tick\\n            temp_ = ((vaultVariables_ >> 2) & X20);\\n            // increasing startingTick_ by 1 so the current tick comes into looping equation\\n            a_.startingTick = (temp_ & 1) == 1 ? (int(temp_ >> 1) + 1) : (-int(temp_ >> 1) + 1);\\n\\n            tickHasDebt_.mapId = a_.startingTick < 0 ? ((a_.startingTick + 1) / 256) - 1 : a_.startingTick / 256;\\n\\n            tickHasDebt_.tickHasDebt = tickHasDebt[tickHasDebt_.mapId];\\n\\n            {\\n                // For last user remaining in vault there could be a lot of while loop.\\n                // Chances of this to happen is extremely low (like ~0%)\\n                tickHasDebt_.nextTick = TickMath.MAX_TICK;\\n                while (true) {\\n                    if (tickHasDebt_.tickHasDebt > 0) {\\n                        a_.mostSigBit = tickHasDebt_.tickHasDebt.mostSignificantBit();\\n                        tickHasDebt_.nextTick = tickHasDebt_.mapId * 256 + int(a_.mostSigBit) - 1;\\n\\n                        while (tickHasDebt_.nextTick > maxTick_) {\\n                            // storing tickData into temp_\\n                            temp_ = tickData[tickHasDebt_.nextTick];\\n                            // temp2_ -> tick's debt\\n                            temp2_ = (temp_ >> 25) & X64;\\n                            // converting big number into normal number\\n                            temp2_ = (temp2_ >> 8) << (temp2_ & X8);\\n                            // Absorbing tick's debt & collateral\\n                            a_.debtAbsorbed += temp2_;\\n                            // calculating collateral from debt & ratio and adding to a_.colAbsorbed\\n                            a_.colAbsorbed += ((temp2_ * TickMath.ZERO_TICK_SCALED_RATIO) /\\n                                TickMath.getRatioAtTick(int24(tickHasDebt_.nextTick)));\\n                            // Update tick data on storage. Making tick as 100% liquidated\\n                            tickData[tickHasDebt_.nextTick] = 1 | (temp_ & 0x1fffffe) | (1 << 25); // set as 100% liquidated\\n\\n                            // temp_ = bits to remove\\n                            temp_ = 257 - a_.mostSigBit;\\n                            tickHasDebt_.tickHasDebt = (tickHasDebt_.tickHasDebt << temp_) >> temp_;\\n                            if (tickHasDebt_.tickHasDebt == 0) break;\\n\\n                            a_.mostSigBit = tickHasDebt_.tickHasDebt.mostSignificantBit();\\n                            tickHasDebt_.nextTick = tickHasDebt_.mapId * 256 + int(a_.mostSigBit) - 1;\\n                        }\\n                        // updating tickHasDebt on storage\\n                        tickHasDebt[tickHasDebt_.mapId] = tickHasDebt_.tickHasDebt;\\n                    }\\n\\n                    // tickHasDebt_.tickHasDebt == 0 from here.\\n\\n                    if (tickHasDebt_.nextTick <= maxTick_) {\\n                        break;\\n                    }\\n\\n                    if (tickHasDebt_.mapId < -129) {\\n                        tickHasDebt_.nextTick = type(int).min;\\n                        break;\\n                    }\\n\\n                    // Fetching next tickHasDebt by decreasing tickHasDebt_.mapId first\\n                    tickHasDebt_.tickHasDebt = tickHasDebt[--tickHasDebt_.mapId];\\n                }\\n            }\\n        }\\n\\n        // After the above loop we will get nextTick stored in tickHasDebt_ which we will use to compare & set things in the end\\n\\n        {\\n            TickData memory tickInfo_;\\n            BranchData memory branch_;\\n            // if this remains 0 that means create a new branch over the end\\n            uint newBranchId_;\\n\\n            {\\n                // Liquidate branches in a loop and store the end branch\\n                branch_.id = (vaultVariables_ >> 22) & X30;\\n                branch_.data = branchData[branch_.id];\\n                // Checking if current branch is liquidated\\n                if ((vaultVariables_ & 2) == 0) {\\n                    // current branch is not liquidated hence it can be used as a new branch if needed\\n                    newBranchId_ = branch_.id;\\n\\n                    // Checking the base branch minima tick. temp_ = base branch minima tick\\n                    temp_ = (branch_.data >> 196) & X20;\\n                    if (temp_ > 0) {\\n                        // Setting the base branch as current liquidatable branch\\n                        branch_.id = (branch_.data >> 166) & X30;\\n                        branch_.data = branchData[branch_.id];\\n                        branch_.minimaTick = (temp_ & 1) == 1 ? int(temp_ >> 1) : -int(temp_ >> 1);\\n                    } else {\\n                        // the current branch is base branch, hence need to setup a new base branch\\n                        branch_.id = 0;\\n                        branch_.data = 0;\\n                        branch_.minimaTick = type(int).min;\\n                    }\\n                } else {\\n                    // current branch is liquidated\\n                    temp_ = (branch_.data >> 2) & X20;\\n                    branch_.minimaTick = (temp_ & 1) == 1 ? int(temp_ >> 1) : -int(temp_ >> 1);\\n                }\\n                while (branch_.minimaTick > maxTick_) {\\n                    // Check base branch, if exists then check if minima tick is above max tick then liquidate it.\\n                    tickInfo_.ratio = TickMath.getRatioAtTick(int24(branch_.minimaTick));\\n                    tickInfo_.ratioOneLess = (tickInfo_.ratio * 10000) / 10015;\\n                    tickInfo_.length = tickInfo_.ratio - tickInfo_.ratioOneLess;\\n\\n                    // partials\\n                    tickInfo_.partials = (branch_.data >> 22) & X30;\\n\\n                    tickInfo_.currentRatio = tickInfo_.ratioOneLess + ((tickInfo_.length * tickInfo_.partials) / X30);\\n\\n                    // debt in branch\\n                    temp2_ = (branch_.data >> 52) & X64;\\n                    // converting big number into normal number\\n                    temp2_ = (temp2_ >> 8) << (temp2_ & X8);\\n                    // Absorbing branch's debt & collateral\\n                    a_.debtAbsorbed += temp2_;\\n                    // calculating branch's collateral using debt & ratio and adding it to a_.colAbsorbed\\n                    a_.colAbsorbed += (temp2_ * TickMath.ZERO_TICK_SCALED_RATIO) / tickInfo_.currentRatio;\\n\\n                    // Closing branch\\n                    branchData[branch_.id] = branch_.data | 3;\\n\\n                    // Setting new branch\\n                    temp_ = (branch_.data >> 196) & X20; // temp_ -> minima tick of connected branch\\n                    if (temp_ > 0) {\\n                        // Setting the base branch as current liquidatable branch\\n                        branch_.id = (branch_.data >> 166) & X30;\\n                        branch_.data = branchData[branch_.id];\\n                        branch_.minimaTick = (temp_ & 1) == 1 ? int(temp_ >> 1) : -int(temp_ >> 1);\\n                    } else {\\n                        // the current branch is base branch, hence need to setup a new base branch\\n                        branch_.id = 0;\\n                        branch_.data = 0;\\n                        branch_.minimaTick = type(int).min;\\n                    }\\n                }\\n            }\\n\\n            if (tickHasDebt_.nextTick >= branch_.minimaTick) {\\n                // new top tick is not liquidated\\n                // temp2_ = tick to insert\\n                if (tickHasDebt_.nextTick > type(int).min) {\\n                    temp2_ = tickHasDebt_.nextTick < 0\\n                        ? (uint(-tickHasDebt_.nextTick) << 1)\\n                        : ((uint(tickHasDebt_.nextTick) << 1) | 1);\\n                } else {\\n                    temp2_ = 0;\\n                }\\n                if (newBranchId_ == 0) {\\n                    // initializing a new branch\\n                    // newBranchId_ = total current branches + 1\\n                    unchecked {\\n                        newBranchId_ = ((vaultVariables_ >> 52) & X30) + 1;\\n                    }\\n                    vaultVariables_ =\\n                        ((vaultVariables_ >> 82) << 82) |\\n                        (temp2_ << 2) |\\n                        (newBranchId_ << 22) |\\n                        (newBranchId_ << 52);\\n                } else {\\n                    // using already initialized non liquidated branch\\n                    vaultVariables_ = ((vaultVariables_ >> 22) << 22) | (temp2_ << 2);\\n                }\\n\\n                if (branch_.minimaTick > type(int).min) {\\n                    temp2_ = branch_.minimaTick < 0\\n                        ? (uint(-branch_.minimaTick) << 1)\\n                        : ((uint(branch_.minimaTick) << 1) | 1);\\n                    // set base branch id and minima tick\\n                    branchData[newBranchId_] = (branch_.id << 166) | (temp2_ << 196);\\n                } else {\\n                    // new base branch does not have any connected branch\\n                    branchData[newBranchId_] = 0;\\n                }\\n            } else {\\n                // new top tick is liquidated\\n                temp2_ = branch_.minimaTick < 0\\n                    ? (uint(-branch_.minimaTick) << 1)\\n                    : ((uint(branch_.minimaTick) << 1) | 1);\\n                if (newBranchId_ == 0) {\\n                    vaultVariables_ = ((vaultVariables_ >> 52) << 52) | 2 | (temp2_ << 2) | (branch_.id << 22);\\n                } else {\\n                    // uninitializing the non liquidated branch\\n                    vaultVariables_ =\\n                        ((vaultVariables_ >> 82) << 82) |\\n                        2 |\\n                        (temp2_ << 2) |\\n                        (branch_.id << 22) |\\n                        ((newBranchId_ - 1) << 52); // decreasing total branch by 1\\n                    branchData[newBranchId_] = 0;\\n                }\\n            }\\n        }\\n\\n        // updating absorbed liquidity on storage\\n        absorbedLiquidity = absorbedLiquidity + a_.debtAbsorbed + (a_.colAbsorbed << 128);\\n\\n        emit LogAbsorb(a_.colAbsorbed, a_.debtAbsorbed);\\n\\n        // returning updated vault variables\\n        return vaultVariables_;\\n    }\\n\\n    /// @dev Checks total supply of vault's in Liquidity Layer & Vault contract and rebalance it accordingly\\n    /// if vault supply is more than Liquidity Layer then deposit difference through reserve/rebalance contract\\n    /// if vault supply is less than Liquidity Layer then withdraw difference to reserve/rebalance contract\\n    /// if vault borrow is more than Liquidity Layer then borrow difference to reserve/rebalance contract\\n    /// if vault borrow is less than Liquidity Layer then payback difference through reserve/rebalance contract\\n    function rebalance(\\n        int colToken0MinMax_,\\n        int colToken1MinMax_,\\n        int debtToken0MinMax_,\\n        int debtToken1MinMax_\\n    ) external payable _verifyCaller returns (int supplyAmt_, int borrowAmt_) {\\n        if (msg.sender != rebalancer) {\\n            revert FluidVaultError(ErrorTypes.Vault__NotRebalancer);\\n        }\\n\\n        uint vaultVariables_ = vaultVariables;\\n        // ############# turning re-entrancy bit on #############\\n        if (vaultVariables_ & 1 == 0) {\\n            // Updating on storage\\n            vaultVariables = vaultVariables_ | 1;\\n        } else {\\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\\n        }\\n\\n        RebalanceMemoryVariables memory r_;\\n        // note: any of the excess ETH sent will be returned back by checking initial and final balance\\n        r_.initialEth = address(this).balance - msg.value;\\n\\n        IFluidVault.ConstantViews memory c_ = IFluidVault(address(this)).constantsView();\\n\\n        // if supply is smart col then it's DEX address else liquidity address\\n        ILiquidityDexCommon supply_ = ILiquidityDexCommon(c_.supply);\\n        // if borrow is smart debt then it's DEX address else liquidity address\\n        ILiquidityDexCommon borrow_ = ILiquidityDexCommon(c_.borrow);\\n\\n        (r_.liqSupplyExPrice, r_.liqBorrowExPrice, r_.vaultSupplyExPrice, r_.vaultBorrowExPrice) = IFluidVault(\\n            address(this)\\n        ).updateExchangePrices(vaultVariables2);\\n\\n        // extract vault supply at Liquidity -> 64 bits starting from bit 1 (first bit is interest mode)\\n        r_.totalSupply =\\n            (supply_.readFromStorage(c_.userSupplySlot) >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) &\\n            X64;\\n        r_.totalSupply = (r_.totalSupply >> 8) << (r_.totalSupply & X8);\\n        r_.totalSupply = (r_.totalSupply * r_.liqSupplyExPrice) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\\n\\n        // extract vault borrowings at Liquidity -> 64 bits starting from bit 1 (first bit is interest mode)\\n        r_.totalBorrow =\\n            (borrow_.readFromStorage(c_.userBorrowSlot) >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) &\\n            X64;\\n        r_.totalBorrow = (r_.totalBorrow >> 8) << (r_.totalBorrow & X8);\\n        r_.totalBorrow = (r_.totalBorrow * r_.liqBorrowExPrice) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\\n\\n        r_.totalSupplyVault = (vaultVariables_ >> 82) & X64;\\n        r_.totalSupplyVault = (r_.totalSupplyVault >> 8) << (r_.totalSupplyVault & X8);\\n        r_.totalSupplyVault = (r_.totalSupplyVault * r_.vaultSupplyExPrice) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\\n\\n        r_.totalBorrowVault = (vaultVariables_ >> 146) & X64;\\n        r_.totalBorrowVault = (r_.totalBorrowVault >> 8) << (r_.totalBorrowVault & X8);\\n        r_.totalBorrowVault = (r_.totalBorrowVault * r_.vaultBorrowExPrice) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\\n\\n        uint value_;\\n\\n        if (r_.totalSupplyVault > r_.totalSupply) {\\n            // Fetch tokens from revenue/rebalance contract and supply in liquidity/dex contract\\n            // This is the scenario when the supply rewards are going in vault, hence\\n            // the vault total supply is increasing at a higher pace than Liquidity/DEX contract.\\n            // We are not transferring rewards right when we set the rewards to keep things clean.\\n            // Also, this can also happen in case when supply rate magnifier is greater than 1.\\n\\n            supplyAmt_ = int(r_.totalSupplyVault) - int(r_.totalSupply);\\n\\n            if (\\n                c_.vaultType == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE ||\\n                c_.vaultType == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\\n            ) {\\n                if (colToken0MinMax_ <= 0 || colToken1MinMax_ <= 0) {\\n                    revert FluidVaultError(ErrorTypes.Vault__InvalidMinMaxInRebalance);\\n                }\\n\\n                try\\n                    supply_.depositPerfect{\\n                        value: (c_.supplyToken.token0 == NATIVE_TOKEN)\\n                            ? uint(colToken0MinMax_)\\n                            : (c_.supplyToken.token1 == NATIVE_TOKEN)\\n                                ? uint(colToken1MinMax_)\\n                                : 0\\n                    }(uint(supplyAmt_), uint(colToken0MinMax_), uint(colToken1MinMax_), false)\\n                returns (uint, uint) {\\n                    // if success then do nothing\\n                } catch {\\n                    supplyAmt_ = 0;\\n                }\\n            } else {\\n                if (c_.supplyToken.token0 == NATIVE_TOKEN) {\\n                    value_ = uint(supplyAmt_);\\n                } else {\\n                    value_ = 0;\\n                }\\n\\n                try\\n                    supply_.operate{ value: value_ }(\\n                        c_.supplyToken.token0,\\n                        supplyAmt_,\\n                        0,\\n                        address(0),\\n                        address(0),\\n                        abi.encode(msg.sender)\\n                    )\\n                {\\n                    // if success then do nothing\\n                } catch {\\n                    supplyAmt_ = 0;\\n                }\\n            }\\n        } else if (r_.totalSupply > r_.totalSupplyVault) {\\n            // Withdraw from Liquidity/DEX contract and send it to revenue contract.\\n            // This is the scenario when the vault user's are getting less APR than what's going on Liquidity contract.\\n            // When supply rate magnifier is less than 1.\\n\\n            supplyAmt_ = int(r_.totalSupplyVault) - int(r_.totalSupply);\\n\\n            if (\\n                c_.vaultType == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE ||\\n                c_.vaultType == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\\n            ) {\\n                if (colToken0MinMax_ >= 0 || colToken1MinMax_ >= 0) {\\n                    revert FluidVaultError(ErrorTypes.Vault__InvalidMinMaxInRebalance);\\n                }\\n\\n                try\\n                    supply_.withdrawPerfect(\\n                        uint(-supplyAmt_),\\n                        uint(-colToken0MinMax_),\\n                        uint(-colToken1MinMax_),\\n                        msg.sender\\n                    )\\n                returns (uint, uint) {\\n                    // if success then do nothing\\n                } catch {\\n                    supplyAmt_ = 0;\\n                }\\n            } else {\\n                try supply_.operate(c_.supplyToken.token0, supplyAmt_, 0, msg.sender, address(0), new bytes(0)) {\\n                    // if success then do nothing\\n                } catch {\\n                    supplyAmt_ = 0;\\n                }\\n            }\\n        }\\n\\n        if (r_.totalBorrowVault > r_.totalBorrow) {\\n            // Borrow from Liquidity/DEX contract and send to revenue/rebalance contract\\n            // This is the scenario when the vault is charging more borrow to user than the Liquidity contract.\\n            // When borrow rate magnifier is greater than 1.\\n\\n            borrowAmt_ = int(r_.totalBorrowVault) - int(r_.totalBorrow);\\n\\n            if (\\n                c_.vaultType == FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE ||\\n                c_.vaultType == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\\n            ) {\\n                if (debtToken0MinMax_ <= 0 || debtToken1MinMax_ <= 0) {\\n                    revert FluidVaultError(ErrorTypes.Vault__InvalidMinMaxInRebalance);\\n                }\\n\\n                try\\n                    borrow_.borrowPerfect(\\n                        uint(borrowAmt_),\\n                        uint(debtToken0MinMax_),\\n                        uint(debtToken1MinMax_),\\n                        msg.sender\\n                    )\\n                returns (uint, uint) {\\n                    // if success then do nothing\\n                } catch {\\n                    borrowAmt_ = 0;\\n                }\\n            } else {\\n                try borrow_.operate(c_.borrowToken.token0, 0, borrowAmt_, address(0), msg.sender, new bytes(0)) {\\n                    // if success then do nothing\\n                } catch {\\n                    borrowAmt_ = 0;\\n                }\\n            }\\n        } else if (r_.totalBorrow > r_.totalBorrowVault) {\\n            // Transfer from revenue/rebalance contract and payback on Liquidity contract\\n            // This is the scenario when vault protocol is earning rewards so effective borrow rate for users is low.\\n            // Or the case where borrow rate magnifier is less than 1\\n\\n            borrowAmt_ = int(r_.totalBorrow) - int(r_.totalBorrowVault);\\n\\n            if (\\n                c_.vaultType == FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE ||\\n                c_.vaultType == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\\n            ) {\\n                if (debtToken0MinMax_ >= 0 || debtToken1MinMax_ >= 0) {\\n                    revert FluidVaultError(ErrorTypes.Vault__InvalidMinMaxInRebalance);\\n                }\\n\\n                try\\n                    borrow_.paybackPerfect{\\n                        value: (c_.borrowToken.token0 == NATIVE_TOKEN)\\n                            ? uint(-debtToken0MinMax_)\\n                            : (c_.borrowToken.token1 == NATIVE_TOKEN)\\n                                ? uint(-debtToken1MinMax_)\\n                                : 0\\n                    }(\\n                        uint(borrowAmt_), // not doing -borrowAmt_ because we already calculated it positively\\n                        uint(-debtToken0MinMax_),\\n                        uint(-debtToken1MinMax_),\\n                        false\\n                    )\\n                returns (uint, uint) {\\n                    // if success then do nothing\\n                    borrowAmt_ = -borrowAmt_;\\n                } catch {\\n                    borrowAmt_ = 0;\\n                }\\n            } else {\\n                if (c_.borrowToken.token0 == NATIVE_TOKEN) {\\n                    value_ = uint(borrowAmt_);\\n                } else {\\n                    value_ = 0;\\n                }\\n\\n                borrowAmt_ = -borrowAmt_;\\n\\n                try\\n                    borrow_.operate{ value: value_ }(\\n                        c_.borrowToken.token0,\\n                        0,\\n                        borrowAmt_,\\n                        address(0),\\n                        address(0),\\n                        abi.encode(msg.sender)\\n                    )\\n                {\\n                    // if success then do nothing\\n                } catch {\\n                    borrowAmt_ = 0;\\n                }\\n            }\\n        }\\n\\n        if (supplyAmt_ == 0 && borrowAmt_ == 0) {\\n            revert FluidVaultError(ErrorTypes.Vault__NothingToRebalance);\\n        }\\n\\n        // Updating vault variable on storage to turn off the reentrancy bit\\n        vaultVariables = vaultVariables_;\\n\\n        _validateEth(r_.initialEth);\\n\\n        emit LogRebalance(supplyAmt_, borrowAmt_);\\n    }\\n}\\n\",\"keccak256\":\"0x59c27af59fe124b1a4a61a7ca1661bf6467a00eb3c1dce51a1874f508299e284\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/vaultTypesCommon/coreModule/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Structs {\\n    // structs are used to mitigate Stack too deep errors\\n\\n    struct OperateMemoryVars {\\n        // ## User's position before update ##\\n        uint oldColRaw;\\n        uint oldNetDebtRaw; // total debt - dust debt\\n        int oldTick;\\n        // ## User's position after update ##\\n        uint colRaw;\\n        uint debtRaw;\\n        uint dustDebtRaw;\\n        int tick;\\n        uint tickId;\\n        // others\\n        uint256 vaultVariables2;\\n        uint256 branchId;\\n        int256 topTick;\\n        uint liquidityExPrice;\\n        uint supplyExPrice;\\n        uint borrowExPrice;\\n        uint branchData;\\n        // user's supply slot data in liquidity\\n        uint userSupplyLiquidityData;\\n    }\\n\\n    struct BranchData {\\n        uint id;\\n        uint data;\\n        uint ratio;\\n        uint debtFactor;\\n        int minimaTick;\\n        uint baseBranchData;\\n    }\\n\\n    struct TickData {\\n        int tick;\\n        uint data;\\n        uint ratio;\\n        uint ratioOneLess;\\n        uint length;\\n        uint currentRatio; // current tick is ratio with partials.\\n        uint partials;\\n    }\\n\\n    // note: All the below token amounts are in raw form.\\n    struct CurrentLiquidity {\\n        uint256 debtRemaining; // Debt remaining to liquidate\\n        uint256 debt; // Current liquidatable debt before reaching next check point\\n        uint256 col; // Calculate using debt & ratioCurrent\\n        uint256 colPerDebt; // How much collateral to liquidate per unit of Debt\\n        uint256 totalDebtLiq; // Total debt liquidated till now\\n        uint256 totalColLiq; // Total collateral liquidated till now\\n        int tick; // Current tick to liquidate\\n        uint ratio; // Current ratio to liquidate\\n        uint tickStatus; // if 1 then it's a perfect tick, if 2 that means it's a liquidated tick\\n        int refTick; // ref tick to liquidate\\n        uint refRatio; // ratio at ref tick\\n        uint refTickStatus; // if 1 then it's a perfect tick, if 2 that means it's a liquidated tick, if 3 that means it's a liquidation threshold\\n    }\\n\\n    struct TickHasDebt {\\n        int tick; // current tick\\n        int nextTick; // next tick with liquidity\\n        int mapId; // mapping ID of tickHasDebt\\n        uint bitsToRemove; // liquidity to remove till tick_ so we can search for next tick\\n        uint tickHasDebt; // getting tickHasDebt_ from tickHasDebt[mapId_]\\n        uint mostSigBit; // most significant bit in tickHasDebt_ to get the next tick\\n    }\\n\\n    struct LiquidateMemoryVars {\\n        uint256 vaultVariables2;\\n        int liquidationTick;\\n        int maxTick;\\n        uint256 supplyExPrice;\\n        uint256 borrowExPrice;\\n        uint256 actualDebtAmt;\\n        uint256 actualColAmt;\\n    }\\n\\n    struct AbsorbMemoryVariables {\\n        uint256 debtAbsorbed;\\n        uint256 colAbsorbed;\\n        int256 startingTick;\\n        uint256 mostSigBit;\\n    }\\n\\n    struct Tokens {\\n        address token0;\\n        address token1;\\n    }\\n\\n    struct ConstantViews {\\n        address liquidity;\\n        address factory;\\n        address operateImplementation;\\n        address adminImplementation;\\n        address secondaryImplementation;\\n        address deployer; // address which deploys oracle\\n        address supply; // either liquidity layer or DEX protocol\\n        address borrow; // either liquidity layer or DEX protocol\\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\\n        uint256 vaultId;\\n        uint256 vaultType;\\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n    }\\n\\n    struct RebalanceMemoryVariables {\\n        uint256 liqSupplyExPrice;\\n        uint256 liqBorrowExPrice;\\n        uint256 vaultSupplyExPrice;\\n        uint256 vaultBorrowExPrice;\\n        uint256 totalSupply;\\n        uint256 totalBorrow;\\n        uint256 totalSupplyVault;\\n        uint256 totalBorrowVault;\\n        uint256 initialEth;\\n    }\\n}\\n\",\"keccak256\":\"0xd43c09235d198f2f0b0720a07e4705b5250f33cd55793044352d58f3862bef43\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b50306080526080516123026100366000396000818160960152610ffc01526123026000f3fe6080604052600436106100295760003560e01c80631593a34b1461002e5780639e3e48211461005b575b600080fd5b61004161003c366004611cf0565b61007c565b604080519283526020830191909152015b60405180910390f35b61006e610069366004611d22565b610fe3565b604051908152602001610052565b60008073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036100f7576040517f60121cca00000000000000000000000000000000000000000000000000000000815261792b60048201526024015b60405180910390fd5b60095473ffffffffffffffffffffffffffffffffffffffff16331461014c576040517f60121cca00000000000000000000000000000000000000000000000000000000815261792260048201526024016100ee565b6000805490600182169003610167576001811760005561019d565b6040517f60121cca00000000000000000000000000000000000000000000000000000000815261791960048201526024016100ee565b6101ec6040518061012001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6101f63447611d73565b8161010001818152505060003073ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa15801561024e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102729190611e85565b60c081015160e08201516001546040517f09f0d8cb0000000000000000000000000000000000000000000000000000000081526004810191909152929350909130906309f0d8cb90602401608060405180830381865afa1580156102da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102fe9190611f9d565b606088015260408088019190915260208701919091529085526101c084015190517fb5c736e4000000000000000000000000000000000000000000000000000000008152600481019190915267ffffffffffffffff9060019073ffffffffffffffffffffffffffffffffffffffff85169063b5c736e490602401602060405180830381865afa158015610395573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103b99190611fd3565b901c16600881901c60ff9091161b60808501819052845164e8d4a51000916103e19190611fec565b6103eb9190612032565b60808501526101e08301516040517fb5c736e4000000000000000000000000000000000000000000000000000000008152600481019190915267ffffffffffffffff9060019073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490602401602060405180830381865afa15801561046f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104939190611fd3565b901c16600881901c60ff9091161b60a08501819052602085015164e8d4a51000916104be9190611fec565b6104c89190612032565b60a085015266ffffffffffffff605a86901c1660ff605287901c161b60c08501819052604085015164e8d4a51000916105019190611fec565b61050b9190612032565b60c085015266ffffffffffffff609a86901c1660ff609287901c161b60e08501819052606085015164e8d4a51000916105449190611fec565b61054e9190612032565b60e0850152608084015160c085015160009110156107e95784608001518560c0015161057a9190612046565b9750614e2084610160015114806105975750619c40846101600151145b1561071a5760008c1315806105ad575060008b13155b156105e8576040517f60121cca00000000000000000000000000000000000000000000000000000000815261793e60048201526024016100ee565b6101008401515173ffffffffffffffffffffffffffffffffffffffff80851691634d9036de911673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14610670576101008601516020015173ffffffffffffffffffffffffffffffffffffffff1673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee1461066a576000610672565b8c610672565b8d5b8a8f8f60006040518663ffffffff1660e01b81526004016106ae9493929190938452602084019290925260408301521515606082015260800190565b604080518083038185885af193505050508015610706575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526107039181019061206d565b60015b6107135760009750610a27565b5050610a27565b6101008401515173ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffff111111111111111111111111111111111111111201610764575086610768565b5060005b61010084015151604080513360208083019190915282518083039091018152818301928390527fad967e150000000000000000000000000000000000000000000000000000000090925273ffffffffffffffffffffffffffffffffffffffff86169263ad967e159285926106ae92918e9160009182918291906044016120f5565b8460c0015185608001511115610a275784608001518560c0015161080d9190612046565b9750614e20846101600151148061082a5750619c40846101600151145b156109515760008c121580610840575060008b12155b1561087b576040517f60121cca00000000000000000000000000000000000000000000000000000000815261793e60048201526024016100ee565b73ffffffffffffffffffffffffffffffffffffffff83166335f0df986108a08a61214e565b6108a98f61214e565b6108b28f61214e565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815260048101939093526024830191909152604482015233606482015260840160408051808303816000875af1925050508015610706575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526107039181019061206d565b6101008401515160408051600080825260208201928390527fad967e150000000000000000000000000000000000000000000000000000000090925273ffffffffffffffffffffffffffffffffffffffff86169263ad967e15926109bf928d919033908290602481016120f5565b60408051808303816000875af1925050508015610a17575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610a149181019061206d565b60015b610a245760009750610a27565b50505b8460a001518560e001511115610bf5578460a001518560e00151610a4b9190612046565b96506175308461016001511480610a685750619c40846101600151145b15610b885760008a131580610a7e575060008913155b15610ab9576040517f60121cca00000000000000000000000000000000000000000000000000000000815261793e60048201526024016100ee565b6040517fe27203cd00000000000000000000000000000000000000000000000000000000815260048101889052602481018b9052604481018a905233606482015273ffffffffffffffffffffffffffffffffffffffff83169063e27203cd906084015b60408051808303816000875af1925050508015610b74575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610b719181019061206d565b60015b610b815760009650610f40565b5050610f40565b6101208401515160408051600080825260208201928390527fad967e150000000000000000000000000000000000000000000000000000000090925273ffffffffffffffffffffffffffffffffffffffff85169263ad967e1592610b1c928c9082903390602481016120f5565b8460e001518560a001511115610f40578460e001518560a00151610c199190612046565b96506175308461016001511480610c365750619c40846101600151145b15610df55760008a121580610c4c575060008912155b15610c87576040517f60121cca00000000000000000000000000000000000000000000000000000000815261793e60048201526024016100ee565b6101208401515173ffffffffffffffffffffffffffffffffffffffff80841691635b3d38d7911673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14610d17576101208601516020015173ffffffffffffffffffffffffffffffffffffffff1673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14610d09576000610d20565b610d128b61214e565b610d20565b610d208c61214e565b89610d2a8e61214e565b610d338e61214e565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e087901b16815260048101939093526024830191909152604482015260006064820152608401604080518083038185885af193505050508015610dd6575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610dd39181019061206d565b60015b610de35760009650610f40565b610dec8961214e565b98505050610f40565b6101208401515173ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffff111111111111111111111111111111111111111201610e3f575085610e43565b5060005b610e4c8761214e565b96508173ffffffffffffffffffffffffffffffffffffffff1663ad967e15828661012001516000015160008b60008033604051602001610ea8919073ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b6040516020818303038152906040526040518863ffffffff1660e01b8152600401610ed8969594939291906120f5565b604080518083038185885af193505050508015610f30575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610f2d9181019061206d565b60015b610f3d5760009650610f40565b50505b87158015610f4c575086155b15610f87576040517f60121cca00000000000000000000000000000000000000000000000000000000815261793760048201526024016100ee565b6000869055610100850151610f9b9061192f565b60408051898152602081018990527f9a85dfb89c634cdc63db5d8cedaf8f9cfa4926df888bad563d70b7314a33a0ae910160405180910390a150505050505094509492505050565b600073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003611058576040517f60121cca00000000000000000000000000000000000000000000000000000000815261792b60048201526024016100ee565b6110836040518060800160405280600081526020016000815260200160008152602001600081525090565b6000806110bf6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b620fffff600288901c169250826001166001146110f3576110e3600184901c61214e565b6110ee906001612186565b611101565b611101600184811c90612186565b6040850181905260001361112657610100846040015161112191906121ae565b611150565b60016101008560400151600161113c9190612186565b61114691906121ae565b6111509190612046565b60408083018290526000918252600460209081529120546080830152617fff908201525b6080810151156113015761118b8160800151611987565b606085018190526040820151600191906111a790610100612216565b6111b19190612186565b6111bb9190612046565b60208201525b85816020015113156112e957602080820151600090815260059091526040902054845190935066ffffffffffffff602185901c1660ff601986901c161b92508290859061120f908390612262565b90525060208101516112239060020b611a3d565b61123a6c0100000000000000000000000084611fec565b6112449190612032565b846020018181516112559190612262565b905250602080820151600090815260059091526040902063020000016301fffffe8516179055606084015161128c90610101611d73565b608082018051821b821c90819052909350156112e9576112af8160800151611987565b606085018190526040820151600191906112cb90610100612216565b6112d59190612186565b6112df9190612046565b60208201526111c1565b60808101516040808301516000908152600460205220555b8581602001511315611396577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f81604001511215611364577f80000000000000000000000000000000000000000000000000000000000000006020820152611396565b6004600082604001805161137790612275565b9081905281526020810191909152604001600020546080820152611174565b6113d66040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b61140f6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b601689901c633fffffff1680825260009081526007602090815260408220549083015260028a1681036114da57508051602082015160c41c620fffff16955085156114a5576020808301805160a61c633fffffff1680855260009081526007909252604090912054905260018087161461149557611490600187901c61214e565b61149b565b600186901c5b6080830152611513565b600080835260208301527f80000000000000000000000000000000000000000000000000000000000000006080830152611513565b620fffff60028360200151901c1695508560011660011461150757611502600187901c61214e565b61150d565b600186901c5b60808301525b88826080015113156116905761152f826080015160020b611a3d565b6040840181905261271f9061154690612710611fec565b6115509190612032565b6060840181905260408401516115669190611d73565b60808401819052602083015160161c633fffffff90811660c0860181905290916115909190611fec565b61159a9190612032565b83606001516115a99190612262565b8360a001818152505067ffffffffffffffff60348360200151901c16945060ff8516600886901c901b945084876000018181516115e69190612262565b90525060a08301516116056c0100000000000000000000000087611fec565b61160f9190612032565b876020018181516116209190612262565b90525060208083018051845160009081526007909352604090922060039092179091555160c41c620fffff16955085156114a5576020808301805160a61c633fffffff1680855260009081526007909252604090912054905260018087161461149557611490600187901c61214e565b8160800151846020015112611801577f8000000000000000000000000000000000000000000000000000000000000000846020015113156117025760008460200151126116e85760018460200151901b6001176116fb565b600184602001516116f89061214e565b901b5b9450611707565b600094505b8060000361174057633fffffff60348b901c166001019050603481901b601682901b600287901b6052808e901c901b171717995061176c565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00000909916600285901b17985b7f8000000000000000000000000000000000000000000000000000000000000000826080015113156117ed5760008260800151126117b55760018260800151901b6001176117c8565b600182608001516117c59061214e565b901b5b8251600083815260076020526040902060a69190911b60c483901b17905594506118b8565b6000818152600760205260408120556118b8565b600082608001511261181e5760018260800151901b600117611831565b6001826080015161182e9061214e565b901b5b94508060000361185d5760168260000151901b600286901b6034808d901c901b600217171799506118b8565b603461186a600183611d73565b8351600084815260076020526040812055911b60169190911b600287811b7ffffffffffffffffffffffffffffffffffffffffffffc000000000000000000009d909d169c909c171717909917985b50505060808460200151901b84600001516002546118d69190612262565b6118e09190612262565b600255602084810151855160408051928352928201527f115609402b8e0707cb9654c5da38e5c0790ccad443a92f71160fe645aa342d04910160405180910390a1869450505050505b92915050565b3031818111156119495761194533838303611c9f565b5050565b81811015611945576040517f60121cca00000000000000000000000000000000000000000000000000000000815261791b60048201526024016100ee565b6000816fffffffffffffffffffffffffffffffff8311156119a95760809150811c5b67ffffffffffffffff8111156119c1576040918201911c5b63ffffffff8111156119d5576020918201911c5b61ffff8111156119e7576010918201911c5b60ff8111156119f8576008918201911c5b600f811115611a09576004918201911c5b6003811115611a1a576002918201911c5b6001811115611a2a576001820191505b8015611a37576001820191505b50919050565b600060ff82901d80831803617fff811115611a5757600080fd5b7001000000000000000000000000000000006001821615611a8557506fff9dd7de423466c20352b1246ce4856f5b6002821615611aa4576fff3bd55f4488ad277531fa1c725a66d00260801c5b6004821615611ac3576ffe78410fd6498b73cb96a6917f8532590260801c5b6008821615611ae2576ffcf2d9987c9be178ad5bfeffaa1232730260801c5b6010821615611b01576ff9ef02c4529258b057769680fc6601b30260801c5b6020821615611b20576ff402d288133a85a17784a411f7aba0820260801c5b6040821615611b3f576fe895615b5beb6386553757b0352bda900260801c5b6080821615611b5e576fd34f17a00ffa00a8309940a15930391a0260801c5b610100821615611b7e576fae6b7961714e20548d88ea5123f9a0ff0260801c5b610200821615611b9e576f76d6461f27082d74e0feed3b388c0ca10260801c5b610400821615611bbe576f372a3bfe0745d8b6b19d985d9a8b85bb0260801c5b610800821615611bde576f0be32cbee48979763cf7247dd7bb539d0260801c5b611000821615611bfd576e8d4f70c9ff4924dac37612d1e2921e0260801c5b612000821615611c1b576d4e009ae5519380809a02ca7aec770260801c5b614000821615611c37576b17c45e641b6e95dee056ff100260801c5b600091507f80000000000000000000000000000000000000000000000000000000000000008416611c95577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0463ffffffff811615611c9557600191505b60201c0192915050565b60008060008060008587614e20f1905080611ceb576040517fdee51a8a0000000000000000000000000000000000000000000000000000000081526201155a60048201526024016100ee565b505050565b60008060008060808587031215611d0657600080fd5b5050823594602084013594506040840135936060013592509050565b60008060408385031215611d3557600080fd5b50508035926020909101359150565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8181038181111561192957611929611d44565b604051610200810167ffffffffffffffff81118282101715611dd1577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405290565b805173ffffffffffffffffffffffffffffffffffffffff81168114611dfb57600080fd5b919050565b600060408284031215611e1257600080fd5b6040516040810181811067ffffffffffffffff82111715611e5c577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604052905080611e6b83611dd7565b8152611e7960208401611dd7565b60208201525092915050565b60006102408284031215611e9857600080fd5b611ea0611d86565b611ea983611dd7565b8152611eb760208401611dd7565b6020820152611ec860408401611dd7565b6040820152611ed960608401611dd7565b6060820152611eea60808401611dd7565b6080820152611efb60a08401611dd7565b60a0820152611f0c60c08401611dd7565b60c0820152611f1d60e08401611dd7565b60e0820152610100611f3185828601611e00565b90820152610140611f4485858301611e00565b61012083015261018080850151828401526101a09150818501516101608401526101c080860151828501526101e09150818601518385015261020086015181850152506102208501518184015250508091505092915050565b60008060008060808587031215611fb357600080fd5b505082516020840151604085015160609095015191969095509092509050565b600060208284031215611fe557600080fd5b5051919050565b808202811582820484141761192957611929611d44565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008261204157612041612003565b500490565b818103600083128015838313168383128216171561206657612066611d44565b5092915050565b6000806040838503121561208057600080fd5b505080516020909101519092909150565b6000815180845260005b818110156120b75760208185018101518683018201520161209b565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b600073ffffffffffffffffffffffffffffffffffffffff8089168352876020840152866040840152808616606084015280851660808401525060c060a083015261214260c0830184612091565b98975050505050505050565b60007f8000000000000000000000000000000000000000000000000000000000000000820361217f5761217f611d44565b5060000390565b80820182811260008312801582168215821617156121a6576121a6611d44565b505092915050565b6000826121bd576121bd612003565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83147f80000000000000000000000000000000000000000000000000000000000000008314161561221157612211611d44565b500590565b808202600082127f80000000000000000000000000000000000000000000000000000000000000008414161561224e5761224e611d44565b818105831482151761192957611929611d44565b8082018082111561192957611929611d44565b60007f800000000000000000000000000000000000000000000000000000000000000082036122a6576122a6611d44565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019056fea264697066735822122028aae685a75536068b490e0cd1d1f767f16246d27be1014b62441d90577dc1dc64736f6c63430008150033",
  "deployedBytecode": "0x6080604052600436106100295760003560e01c80631593a34b1461002e5780639e3e48211461005b575b600080fd5b61004161003c366004611cf0565b61007c565b604080519283526020830191909152015b60405180910390f35b61006e610069366004611d22565b610fe3565b604051908152602001610052565b60008073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036100f7576040517f60121cca00000000000000000000000000000000000000000000000000000000815261792b60048201526024015b60405180910390fd5b60095473ffffffffffffffffffffffffffffffffffffffff16331461014c576040517f60121cca00000000000000000000000000000000000000000000000000000000815261792260048201526024016100ee565b6000805490600182169003610167576001811760005561019d565b6040517f60121cca00000000000000000000000000000000000000000000000000000000815261791960048201526024016100ee565b6101ec6040518061012001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6101f63447611d73565b8161010001818152505060003073ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa15801561024e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102729190611e85565b60c081015160e08201516001546040517f09f0d8cb0000000000000000000000000000000000000000000000000000000081526004810191909152929350909130906309f0d8cb90602401608060405180830381865afa1580156102da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102fe9190611f9d565b606088015260408088019190915260208701919091529085526101c084015190517fb5c736e4000000000000000000000000000000000000000000000000000000008152600481019190915267ffffffffffffffff9060019073ffffffffffffffffffffffffffffffffffffffff85169063b5c736e490602401602060405180830381865afa158015610395573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103b99190611fd3565b901c16600881901c60ff9091161b60808501819052845164e8d4a51000916103e19190611fec565b6103eb9190612032565b60808501526101e08301516040517fb5c736e4000000000000000000000000000000000000000000000000000000008152600481019190915267ffffffffffffffff9060019073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490602401602060405180830381865afa15801561046f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104939190611fd3565b901c16600881901c60ff9091161b60a08501819052602085015164e8d4a51000916104be9190611fec565b6104c89190612032565b60a085015266ffffffffffffff605a86901c1660ff605287901c161b60c08501819052604085015164e8d4a51000916105019190611fec565b61050b9190612032565b60c085015266ffffffffffffff609a86901c1660ff609287901c161b60e08501819052606085015164e8d4a51000916105449190611fec565b61054e9190612032565b60e0850152608084015160c085015160009110156107e95784608001518560c0015161057a9190612046565b9750614e2084610160015114806105975750619c40846101600151145b1561071a5760008c1315806105ad575060008b13155b156105e8576040517f60121cca00000000000000000000000000000000000000000000000000000000815261793e60048201526024016100ee565b6101008401515173ffffffffffffffffffffffffffffffffffffffff80851691634d9036de911673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14610670576101008601516020015173ffffffffffffffffffffffffffffffffffffffff1673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee1461066a576000610672565b8c610672565b8d5b8a8f8f60006040518663ffffffff1660e01b81526004016106ae9493929190938452602084019290925260408301521515606082015260800190565b604080518083038185885af193505050508015610706575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526107039181019061206d565b60015b6107135760009750610a27565b5050610a27565b6101008401515173ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffff111111111111111111111111111111111111111201610764575086610768565b5060005b61010084015151604080513360208083019190915282518083039091018152818301928390527fad967e150000000000000000000000000000000000000000000000000000000090925273ffffffffffffffffffffffffffffffffffffffff86169263ad967e159285926106ae92918e9160009182918291906044016120f5565b8460c0015185608001511115610a275784608001518560c0015161080d9190612046565b9750614e20846101600151148061082a5750619c40846101600151145b156109515760008c121580610840575060008b12155b1561087b576040517f60121cca00000000000000000000000000000000000000000000000000000000815261793e60048201526024016100ee565b73ffffffffffffffffffffffffffffffffffffffff83166335f0df986108a08a61214e565b6108a98f61214e565b6108b28f61214e565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815260048101939093526024830191909152604482015233606482015260840160408051808303816000875af1925050508015610706575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526107039181019061206d565b6101008401515160408051600080825260208201928390527fad967e150000000000000000000000000000000000000000000000000000000090925273ffffffffffffffffffffffffffffffffffffffff86169263ad967e15926109bf928d919033908290602481016120f5565b60408051808303816000875af1925050508015610a17575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610a149181019061206d565b60015b610a245760009750610a27565b50505b8460a001518560e001511115610bf5578460a001518560e00151610a4b9190612046565b96506175308461016001511480610a685750619c40846101600151145b15610b885760008a131580610a7e575060008913155b15610ab9576040517f60121cca00000000000000000000000000000000000000000000000000000000815261793e60048201526024016100ee565b6040517fe27203cd00000000000000000000000000000000000000000000000000000000815260048101889052602481018b9052604481018a905233606482015273ffffffffffffffffffffffffffffffffffffffff83169063e27203cd906084015b60408051808303816000875af1925050508015610b74575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610b719181019061206d565b60015b610b815760009650610f40565b5050610f40565b6101208401515160408051600080825260208201928390527fad967e150000000000000000000000000000000000000000000000000000000090925273ffffffffffffffffffffffffffffffffffffffff85169263ad967e1592610b1c928c9082903390602481016120f5565b8460e001518560a001511115610f40578460e001518560a00151610c199190612046565b96506175308461016001511480610c365750619c40846101600151145b15610df55760008a121580610c4c575060008912155b15610c87576040517f60121cca00000000000000000000000000000000000000000000000000000000815261793e60048201526024016100ee565b6101208401515173ffffffffffffffffffffffffffffffffffffffff80841691635b3d38d7911673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14610d17576101208601516020015173ffffffffffffffffffffffffffffffffffffffff1673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14610d09576000610d20565b610d128b61214e565b610d20565b610d208c61214e565b89610d2a8e61214e565b610d338e61214e565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e087901b16815260048101939093526024830191909152604482015260006064820152608401604080518083038185885af193505050508015610dd6575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610dd39181019061206d565b60015b610de35760009650610f40565b610dec8961214e565b98505050610f40565b6101208401515173ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffff111111111111111111111111111111111111111201610e3f575085610e43565b5060005b610e4c8761214e565b96508173ffffffffffffffffffffffffffffffffffffffff1663ad967e15828661012001516000015160008b60008033604051602001610ea8919073ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b6040516020818303038152906040526040518863ffffffff1660e01b8152600401610ed8969594939291906120f5565b604080518083038185885af193505050508015610f30575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610f2d9181019061206d565b60015b610f3d5760009650610f40565b50505b87158015610f4c575086155b15610f87576040517f60121cca00000000000000000000000000000000000000000000000000000000815261793760048201526024016100ee565b6000869055610100850151610f9b9061192f565b60408051898152602081018990527f9a85dfb89c634cdc63db5d8cedaf8f9cfa4926df888bad563d70b7314a33a0ae910160405180910390a150505050505094509492505050565b600073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003611058576040517f60121cca00000000000000000000000000000000000000000000000000000000815261792b60048201526024016100ee565b6110836040518060800160405280600081526020016000815260200160008152602001600081525090565b6000806110bf6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b620fffff600288901c169250826001166001146110f3576110e3600184901c61214e565b6110ee906001612186565b611101565b611101600184811c90612186565b6040850181905260001361112657610100846040015161112191906121ae565b611150565b60016101008560400151600161113c9190612186565b61114691906121ae565b6111509190612046565b60408083018290526000918252600460209081529120546080830152617fff908201525b6080810151156113015761118b8160800151611987565b606085018190526040820151600191906111a790610100612216565b6111b19190612186565b6111bb9190612046565b60208201525b85816020015113156112e957602080820151600090815260059091526040902054845190935066ffffffffffffff602185901c1660ff601986901c161b92508290859061120f908390612262565b90525060208101516112239060020b611a3d565b61123a6c0100000000000000000000000084611fec565b6112449190612032565b846020018181516112559190612262565b905250602080820151600090815260059091526040902063020000016301fffffe8516179055606084015161128c90610101611d73565b608082018051821b821c90819052909350156112e9576112af8160800151611987565b606085018190526040820151600191906112cb90610100612216565b6112d59190612186565b6112df9190612046565b60208201526111c1565b60808101516040808301516000908152600460205220555b8581602001511315611396577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f81604001511215611364577f80000000000000000000000000000000000000000000000000000000000000006020820152611396565b6004600082604001805161137790612275565b9081905281526020810191909152604001600020546080820152611174565b6113d66040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b61140f6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b601689901c633fffffff1680825260009081526007602090815260408220549083015260028a1681036114da57508051602082015160c41c620fffff16955085156114a5576020808301805160a61c633fffffff1680855260009081526007909252604090912054905260018087161461149557611490600187901c61214e565b61149b565b600186901c5b6080830152611513565b600080835260208301527f80000000000000000000000000000000000000000000000000000000000000006080830152611513565b620fffff60028360200151901c1695508560011660011461150757611502600187901c61214e565b61150d565b600186901c5b60808301525b88826080015113156116905761152f826080015160020b611a3d565b6040840181905261271f9061154690612710611fec565b6115509190612032565b6060840181905260408401516115669190611d73565b60808401819052602083015160161c633fffffff90811660c0860181905290916115909190611fec565b61159a9190612032565b83606001516115a99190612262565b8360a001818152505067ffffffffffffffff60348360200151901c16945060ff8516600886901c901b945084876000018181516115e69190612262565b90525060a08301516116056c0100000000000000000000000087611fec565b61160f9190612032565b876020018181516116209190612262565b90525060208083018051845160009081526007909352604090922060039092179091555160c41c620fffff16955085156114a5576020808301805160a61c633fffffff1680855260009081526007909252604090912054905260018087161461149557611490600187901c61214e565b8160800151846020015112611801577f8000000000000000000000000000000000000000000000000000000000000000846020015113156117025760008460200151126116e85760018460200151901b6001176116fb565b600184602001516116f89061214e565b901b5b9450611707565b600094505b8060000361174057633fffffff60348b901c166001019050603481901b601682901b600287901b6052808e901c901b171717995061176c565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00000909916600285901b17985b7f8000000000000000000000000000000000000000000000000000000000000000826080015113156117ed5760008260800151126117b55760018260800151901b6001176117c8565b600182608001516117c59061214e565b901b5b8251600083815260076020526040902060a69190911b60c483901b17905594506118b8565b6000818152600760205260408120556118b8565b600082608001511261181e5760018260800151901b600117611831565b6001826080015161182e9061214e565b901b5b94508060000361185d5760168260000151901b600286901b6034808d901c901b600217171799506118b8565b603461186a600183611d73565b8351600084815260076020526040812055911b60169190911b600287811b7ffffffffffffffffffffffffffffffffffffffffffffc000000000000000000009d909d169c909c171717909917985b50505060808460200151901b84600001516002546118d69190612262565b6118e09190612262565b600255602084810151855160408051928352928201527f115609402b8e0707cb9654c5da38e5c0790ccad443a92f71160fe645aa342d04910160405180910390a1869450505050505b92915050565b3031818111156119495761194533838303611c9f565b5050565b81811015611945576040517f60121cca00000000000000000000000000000000000000000000000000000000815261791b60048201526024016100ee565b6000816fffffffffffffffffffffffffffffffff8311156119a95760809150811c5b67ffffffffffffffff8111156119c1576040918201911c5b63ffffffff8111156119d5576020918201911c5b61ffff8111156119e7576010918201911c5b60ff8111156119f8576008918201911c5b600f811115611a09576004918201911c5b6003811115611a1a576002918201911c5b6001811115611a2a576001820191505b8015611a37576001820191505b50919050565b600060ff82901d80831803617fff811115611a5757600080fd5b7001000000000000000000000000000000006001821615611a8557506fff9dd7de423466c20352b1246ce4856f5b6002821615611aa4576fff3bd55f4488ad277531fa1c725a66d00260801c5b6004821615611ac3576ffe78410fd6498b73cb96a6917f8532590260801c5b6008821615611ae2576ffcf2d9987c9be178ad5bfeffaa1232730260801c5b6010821615611b01576ff9ef02c4529258b057769680fc6601b30260801c5b6020821615611b20576ff402d288133a85a17784a411f7aba0820260801c5b6040821615611b3f576fe895615b5beb6386553757b0352bda900260801c5b6080821615611b5e576fd34f17a00ffa00a8309940a15930391a0260801c5b610100821615611b7e576fae6b7961714e20548d88ea5123f9a0ff0260801c5b610200821615611b9e576f76d6461f27082d74e0feed3b388c0ca10260801c5b610400821615611bbe576f372a3bfe0745d8b6b19d985d9a8b85bb0260801c5b610800821615611bde576f0be32cbee48979763cf7247dd7bb539d0260801c5b611000821615611bfd576e8d4f70c9ff4924dac37612d1e2921e0260801c5b612000821615611c1b576d4e009ae5519380809a02ca7aec770260801c5b614000821615611c37576b17c45e641b6e95dee056ff100260801c5b600091507f80000000000000000000000000000000000000000000000000000000000000008416611c95577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0463ffffffff811615611c9557600191505b60201c0192915050565b60008060008060008587614e20f1905080611ceb576040517fdee51a8a0000000000000000000000000000000000000000000000000000000081526201155a60048201526024016100ee565b505050565b60008060008060808587031215611d0657600080fd5b5050823594602084013594506040840135936060013592509050565b60008060408385031215611d3557600080fd5b50508035926020909101359150565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8181038181111561192957611929611d44565b604051610200810167ffffffffffffffff81118282101715611dd1577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405290565b805173ffffffffffffffffffffffffffffffffffffffff81168114611dfb57600080fd5b919050565b600060408284031215611e1257600080fd5b6040516040810181811067ffffffffffffffff82111715611e5c577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604052905080611e6b83611dd7565b8152611e7960208401611dd7565b60208201525092915050565b60006102408284031215611e9857600080fd5b611ea0611d86565b611ea983611dd7565b8152611eb760208401611dd7565b6020820152611ec860408401611dd7565b6040820152611ed960608401611dd7565b6060820152611eea60808401611dd7565b6080820152611efb60a08401611dd7565b60a0820152611f0c60c08401611dd7565b60c0820152611f1d60e08401611dd7565b60e0820152610100611f3185828601611e00565b90820152610140611f4485858301611e00565b61012083015261018080850151828401526101a09150818501516101608401526101c080860151828501526101e09150818601518385015261020086015181850152506102208501518184015250508091505092915050565b60008060008060808587031215611fb357600080fd5b505082516020840151604085015160609095015191969095509092509050565b600060208284031215611fe557600080fd5b5051919050565b808202811582820484141761192957611929611d44565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008261204157612041612003565b500490565b818103600083128015838313168383128216171561206657612066611d44565b5092915050565b6000806040838503121561208057600080fd5b505080516020909101519092909150565b6000815180845260005b818110156120b75760208185018101518683018201520161209b565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b600073ffffffffffffffffffffffffffffffffffffffff8089168352876020840152866040840152808616606084015280851660808401525060c060a083015261214260c0830184612091565b98975050505050505050565b60007f8000000000000000000000000000000000000000000000000000000000000000820361217f5761217f611d44565b5060000390565b80820182811260008312801582168215821617156121a6576121a6611d44565b505092915050565b6000826121bd576121bd612003565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83147f80000000000000000000000000000000000000000000000000000000000000008314161561221157612211611d44565b500590565b808202600082127f80000000000000000000000000000000000000000000000000000000000000008414161561224e5761224e611d44565b818105831482151761192957611929611d44565b8082018082111561192957611929611d44565b60007f800000000000000000000000000000000000000000000000000000000000000082036122a6576122a6611d44565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019056fea264697066735822122028aae685a75536068b490e0cd1d1f767f16246d27be1014b62441d90577dc1dc64736f6c63430008150033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "absorb(uint256,int256)": {
        "details": "absorb function absorbs the bad debt if the bad debt is above max limit. The main use of it is if the bad debt didn't got liquidated in time maybe due to sudden price drop or bad debt was extremely small to liquidate and the bad debt goes above 100% ratio then there's no incentive for anyone to liquidate now hence absorb functions absorbs that bad debt to allow newer bad debt to liquidate seamlessly. if absorbing were to happen after this it's on governance on how to deal with it although it can still be removed through liquidate via liquidator if the price goes back up and liquidation becomes beneficial upon absorbed user position gets 100% liquidated."
      },
      "rebalance(int256,int256,int256,int256)": {
        "details": "Checks total supply of vault's in Liquidity Layer & Vault contract and rebalance it accordingly if vault supply is more than Liquidity Layer then deposit difference through reserve/rebalance contract if vault supply is less than Liquidity Layer then withdraw difference to reserve/rebalance contract if vault borrow is more than Liquidity Layer then borrow difference to reserve/rebalance contract if vault borrow is less than Liquidity Layer then payback difference through reserve/rebalance contract"
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "FluidLiquidateResult(uint256,uint256)": [
        {
          "notice": "used to simulate liquidation to find the maximum liquidatable amounts"
        }
      ]
    },
    "events": {
      "LogAbsorb(uint256,uint256)": {
        "notice": "emitted when `absorb()` was executed to absorb bad debt."
      },
      "LogLiquidate(address,uint256,uint256,address)": {
        "notice": "emitted when a liquidation has been executed."
      },
      "LogOperate(address,uint256,int256,int256,address)": {
        "notice": "emitted when an operate() method is executed that changes collateral (`colAmt_`) / debt (debtAmt_`) amount for a `user_` position with `nftId_`. Receiver of any funds is the address `to_`."
      },
      "LogRebalance(int256,int256)": {
        "notice": "emitted when a `rebalance()` has been executed, balancing out total supply / borrow between Vault and Fluid Liquidity pools. if `colAmt_` is positive then loss, meaning transfer from rebalancer address to vault and deposit. if `colAmt_` is negative then profit, meaning withdrawn from vault and sent to rebalancer address. if `debtAmt_` is positive then profit, meaning borrow from vault and sent to rebalancer address. if `debtAmt_` is negative then loss, meaning transfer from rebalancer address to vault and payback."
      },
      "LogUpdateExchangePrice(uint256,uint256)": {
        "notice": "emitted when the exchange prices are updated in storage."
      }
    },
    "kind": "user",
    "methods": {},
    "notice": "Fluid Vault protocol secondary methods contract.         Implements `absorb()` and `rebalance()` methods, extracted from main contract due to contract size limits.         Methods are limited to be called via delegateCall only (as done by Vault CoreModule contract).",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 123063,
        "contract": "contracts/protocols/vault/vaultTypesCommon/coreModule/main2.sol:FluidVaultSecondary",
        "label": "vaultVariables",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 123066,
        "contract": "contracts/protocols/vault/vaultTypesCommon/coreModule/main2.sol:FluidVaultSecondary",
        "label": "vaultVariables2",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 123069,
        "contract": "contracts/protocols/vault/vaultTypesCommon/coreModule/main2.sol:FluidVaultSecondary",
        "label": "absorbedLiquidity",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 123074,
        "contract": "contracts/protocols/vault/vaultTypesCommon/coreModule/main2.sol:FluidVaultSecondary",
        "label": "positionData",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 123079,
        "contract": "contracts/protocols/vault/vaultTypesCommon/coreModule/main2.sol:FluidVaultSecondary",
        "label": "tickHasDebt",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_int256,t_uint256)"
      },
      {
        "astId": 123084,
        "contract": "contracts/protocols/vault/vaultTypesCommon/coreModule/main2.sol:FluidVaultSecondary",
        "label": "tickData",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_int256,t_uint256)"
      },
      {
        "astId": 123091,
        "contract": "contracts/protocols/vault/vaultTypesCommon/coreModule/main2.sol:FluidVaultSecondary",
        "label": "tickId",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_int256,t_mapping(t_uint256,t_uint256))"
      },
      {
        "astId": 123096,
        "contract": "contracts/protocols/vault/vaultTypesCommon/coreModule/main2.sol:FluidVaultSecondary",
        "label": "branchData",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 123099,
        "contract": "contracts/protocols/vault/vaultTypesCommon/coreModule/main2.sol:FluidVaultSecondary",
        "label": "rates",
        "offset": 0,
        "slot": "8",
        "type": "t_uint256"
      },
      {
        "astId": 123102,
        "contract": "contracts/protocols/vault/vaultTypesCommon/coreModule/main2.sol:FluidVaultSecondary",
        "label": "rebalancer",
        "offset": 0,
        "slot": "9",
        "type": "t_address"
      },
      {
        "astId": 123104,
        "contract": "contracts/protocols/vault/vaultTypesCommon/coreModule/main2.sol:FluidVaultSecondary",
        "label": "absorbedDustDebt",
        "offset": 0,
        "slot": "10",
        "type": "t_uint256"
      },
      {
        "astId": 123106,
        "contract": "contracts/protocols/vault/vaultTypesCommon/coreModule/main2.sol:FluidVaultSecondary",
        "label": "dexFromAddress",
        "offset": 0,
        "slot": "11",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_int256": {
        "encoding": "inplace",
        "label": "int256",
        "numberOfBytes": "32"
      },
      "t_mapping(t_int256,t_mapping(t_uint256,t_uint256))": {
        "encoding": "mapping",
        "key": "t_int256",
        "label": "mapping(int256 => mapping(uint256 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_uint256)"
      },
      "t_mapping(t_int256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_int256",
        "label": "mapping(int256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}