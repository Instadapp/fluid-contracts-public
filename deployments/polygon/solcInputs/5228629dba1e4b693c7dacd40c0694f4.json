{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/config/bufferRateHandler/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { Structs as AdminModuleStructs } from \"../../liquidity/adminModule/structs.sol\";\n\nabstract contract Constants {\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n    IFluidLiquidity public immutable LIQUIDITY;\n\n    /// @notice supply token at Liquidity which borrow rate is based on\n    address public immutable SUPPLY_TOKEN;\n    /// @notice borrow token at Liquidity for which the borrow rate is managed\n    address public immutable BORROW_TOKEN;\n\n    /// @notice buffer at kink1 for the rate. borrow rate = supply rate + buffer. In percent (100 = 1%, 1 = 0.01%)\n    int256 public immutable RATE_BUFFER_KINK1;\n    /// @notice buffer at kink2 for the rate. borrow rate = supply rate + buffer. In percent (100 = 1%, 1 = 0.01%)\n    /// @dev only used if CURRENT borrow rate mode at Liquidity is V2 (with 2 kinks).\n    int256 public immutable RATE_BUFFER_KINK2;\n\n    /// @dev minimum percent difference to trigger an update. In percent (100 = 1%, 1 = 0.01%)\n    uint256 public immutable MIN_UPDATE_DIFF;\n\n    bytes32 internal immutable _LIQUDITY_SUPPLY_TOTAL_AMOUNTS_SLOT;\n    bytes32 internal immutable _LIQUDITY_SUPPLY_EXCHANGE_PRICES_AND_CONFIG_SLOT;\n\n    bytes32 internal immutable _LIQUDITY_BORROW_RATE_DATA_SLOT;\n\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xff;\n\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n    uint256 internal constant FOUR_DECIMALS = 10000;\n}\n\nabstract contract Events {\n    /// @notice emitted when borrow rate for `BORROW_TOKEN` is updated based on\n    ///          supply rate of `SUPPLY_TOKEN` + buffer.\n    event LogUpdateRate(\n        uint256 supplyRate,\n        uint256 oldRateKink1,\n        uint256 newRateKink1,\n        uint256 oldRateKink2,\n        uint256 newRateKink2\n    );\n}\n\n/// @notice Sets borrow rate for `BORROW_TOKEN` at Liquidaty based on supply rate of `SUPPLY_TOKEN` + buffer.\ncontract FluidBufferRateHandler is Constants, Error, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.BufferRateConfigHandler__AddressZero);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract)\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.BufferRateConfigHandler__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(\n        IFluidReserveContract reserveContract_,\n        IFluidLiquidity liquidity_,\n        address supplyToken_,\n        address borrowToken_,\n        int256 rateBufferKink1_,\n        int256 rateBufferKink2_,\n        uint256 minUpdateDiff_\n    )\n        validAddress(address(reserveContract_))\n        validAddress(address(liquidity_))\n        validAddress(supplyToken_)\n        validAddress(borrowToken_)\n    {\n        if (\n            minUpdateDiff_ == 0 ||\n            // rate buffer should be within +100% to - 100%\n            rateBufferKink1_ > 1e4 ||\n            rateBufferKink1_ < -int256(1e4) ||\n            rateBufferKink2_ > 1e4 ||\n            rateBufferKink2_ < -int256(1e4)\n        ) {\n            revert FluidConfigError(ErrorTypes.BufferRateConfigHandler__InvalidParams);\n        }\n\n        RESERVE_CONTRACT = reserveContract_;\n        LIQUIDITY = liquidity_;\n        SUPPLY_TOKEN = supplyToken_;\n        BORROW_TOKEN = borrowToken_;\n        MIN_UPDATE_DIFF = minUpdateDiff_;\n\n        RATE_BUFFER_KINK1 = rateBufferKink1_;\n        RATE_BUFFER_KINK2 = rateBufferKink2_;\n\n        _LIQUDITY_SUPPLY_TOTAL_AMOUNTS_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT,\n            supplyToken_\n        );\n        _LIQUDITY_SUPPLY_EXCHANGE_PRICES_AND_CONFIG_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            supplyToken_\n        );\n\n        _LIQUDITY_BORROW_RATE_DATA_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_RATE_DATA_MAPPING_SLOT,\n            borrowToken_\n        );\n    }\n\n    function configPercentDiff() public view returns (uint256 configPercentDiff_) {\n        uint256 rateConfig_ = LIQUIDITY.readFromStorage(_LIQUDITY_BORROW_RATE_DATA_SLOT);\n\n        (uint256 newRateKink1_, uint256 newRateKink2_) = _calcBorrowRates(supplyTokenLendingRate(), rateConfig_);\n\n        uint256 rateVersion_ = rateConfig_ & 0xF;\n        if (rateVersion_ == 1) {\n            uint256 oldRateKink1_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) &\n                X16;\n            configPercentDiff_ = _percentDiffForValue(oldRateKink1_, newRateKink1_);\n        } else if (rateVersion_ == 2) {\n            uint256 oldRateKink1_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) &\n                X16;\n            uint256 oldRateKink2_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) &\n                X16;\n\n            configPercentDiff_ = _percentDiffForValue(oldRateKink1_, newRateKink1_);\n            uint256 rateKink2Diff_ = _percentDiffForValue(oldRateKink2_, newRateKink2_);\n            // final diff = biggest diff between all config values\n            configPercentDiff_ = configPercentDiff_ > rateKink2Diff_ ? configPercentDiff_ : rateKink2Diff_;\n        } else {\n            revert FluidConfigError(ErrorTypes.BufferRateConfigHandler__RateVersionUnsupported);\n        }\n    }\n\n    function rebalance() external onlyRebalancer {\n        uint256 supplyLendingRate_ = supplyTokenLendingRate();\n        uint256 rateConfig_ = LIQUIDITY.readFromStorage(_LIQUDITY_BORROW_RATE_DATA_SLOT);\n\n        uint256 rateVersion_ = rateConfig_ & 0xF;\n        if (rateVersion_ == 1) {\n            _rebalanceRateV1(supplyLendingRate_, rateConfig_);\n        } else if (rateVersion_ == 2) {\n            _rebalanceRateV2(supplyLendingRate_, rateConfig_);\n        } else {\n            revert FluidConfigError(ErrorTypes.BufferRateConfigHandler__RateVersionUnsupported);\n        }\n    }\n\n    /// @notice returns the current calculcated borrow rates at kink1 and kink 2 (for rate data v2).\n    function calcBorrowRates() public view returns (uint256 rateKink1_, uint256 rateKink2_) {\n        return _calcBorrowRates(supplyTokenLendingRate(), LIQUIDITY.readFromStorage(_LIQUDITY_BORROW_RATE_DATA_SLOT));\n    }\n\n    /// @notice  get current `SUPPLY_TOKEN` lending `rate_` at Liquidity\n    function supplyTokenLendingRate() public view returns (uint256 rate_) {\n        // @dev logic here based on Liquidity Resolver .getOverallTokenData()\n        uint256 totalAmounts_ = LIQUIDITY.readFromStorage(_LIQUDITY_SUPPLY_TOTAL_AMOUNTS_SLOT);\n\n        // Extract supply & borrow amounts\n        uint256 supplyRawInterest_ = totalAmounts_ & X64;\n        supplyRawInterest_ =\n            (supplyRawInterest_ >> DEFAULT_EXPONENT_SIZE) <<\n            (supplyRawInterest_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 borrowRawInterest_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) &\n            X64;\n        borrowRawInterest_ =\n            (borrowRawInterest_ >> DEFAULT_EXPONENT_SIZE) <<\n            (borrowRawInterest_ & DEFAULT_EXPONENT_MASK);\n\n        if (supplyRawInterest_ > 0) {\n            uint256 exchangePriceAndConfig_ = LIQUIDITY.readFromStorage(\n                _LIQUDITY_SUPPLY_EXCHANGE_PRICES_AND_CONFIG_SLOT\n            );\n\n            // use old exchange prices for supply rate to be at same level as borrow rate from storage.\n            // Note the rate here can be a tiny bit with higher precision because we use borrowWithInterest_ / supplyWithInterest_\n            // which has higher precision than the utilization used from storage in LiquidityCalcs\n            uint256 supplyWithInterest_ = (supplyRawInterest_ *\n                ((exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) & X64)) /\n                EXCHANGE_PRICES_PRECISION; // normalized from raw\n            uint256 borrowWithInterest_ = (borrowRawInterest_ *\n                ((exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) & X64)) /\n                EXCHANGE_PRICES_PRECISION; // normalized from raw\n\n            uint256 borrowRate_ = exchangePriceAndConfig_ & X16;\n            uint256 fee_ = (exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14;\n\n            rate_ =\n                (borrowRate_ * (FOUR_DECIMALS - fee_) * borrowWithInterest_) /\n                (supplyWithInterest_ * FOUR_DECIMALS);\n        }\n    }\n\n    /// @dev calculates current borrow rates at kinks for supply rate and current rate data\n    function _calcBorrowRates(\n        uint256 supplyRate_,\n        uint256 rateConfig_\n    ) internal view returns (uint256 rateKink1_, uint256 rateKink2_) {\n        // rate can never be <0, > X16.\n        rateKink1_ = (int256(supplyRate_) + RATE_BUFFER_KINK1) > 0\n            ? uint256((int256(supplyRate_) + RATE_BUFFER_KINK1))\n            : 0;\n        // rate can never be > X16\n        rateKink1_ = rateKink1_ > X16 ? X16 : rateKink1_;\n        if ((rateConfig_ & 0xF) == 1) {\n            // v1: only 1 kink\n            // rate at last kink must always be <= rate at 100% utilization\n            uint256 rateAtUtilizationMax_ = (rateConfig_ >>\n                LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\n            if (rateKink1_ > rateAtUtilizationMax_) {\n                rateKink1_ = rateAtUtilizationMax_;\n            }\n        } else {\n            // v2: 2 kinks\n            // rate can never be <0, > X16.\n            rateKink2_ = (int256(supplyRate_) + RATE_BUFFER_KINK2) > 0\n                ? uint256(int256(supplyRate_) + RATE_BUFFER_KINK2)\n                : 0;\n            // rate can never be > X16\n            rateKink2_ = rateKink2_ > X16 ? X16 : rateKink2_;\n            // rate at kink must always be <= rate at 100% utilization\n            uint256 rateAtUtilizationMax_ = (rateConfig_ >>\n                LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\n            if (rateKink1_ > rateAtUtilizationMax_) {\n                rateKink1_ = rateAtUtilizationMax_;\n            }\n            if (rateKink2_ > rateAtUtilizationMax_) {\n                rateKink2_ = rateAtUtilizationMax_;\n            }\n        }\n    }\n\n    /// @dev gets the percentage difference between `oldValue_` and `newValue_` in relation to `oldValue_`\n    function _percentDiffForValue(\n        uint256 oldValue_,\n        uint256 newValue_\n    ) internal pure returns (uint256 configPercentDiff_) {\n        if (oldValue_ == newValue_) {\n            return 0;\n        }\n\n        if (oldValue_ > newValue_) {\n            // % of how much new value would be smaller\n            configPercentDiff_ = oldValue_ - newValue_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 10 -> 2000 (20%)\n        } else {\n            // % of how much new value would be bigger\n            configPercentDiff_ = newValue_ - oldValue_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 8 -> 2500 (25%)\n        }\n\n        configPercentDiff_ = (configPercentDiff_ * 1e4) / oldValue_;\n    }\n\n    /// @dev rebalances for a RateV1 config\n    function _rebalanceRateV1(uint256 supplyRate_, uint256 rateConfig_) internal {\n        AdminModuleStructs.RateDataV1Params memory rateData_;\n\n        uint256 oldRateKink1_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n        (rateData_.rateAtUtilizationKink, ) = _calcBorrowRates(supplyRate_, rateConfig_);\n\n        // check if diff is enough to trigger update\n        if (_percentDiffForValue(oldRateKink1_, rateData_.rateAtUtilizationKink) < MIN_UPDATE_DIFF) {\n            revert FluidConfigError(ErrorTypes.BufferRateConfigHandler__NoUpdate);\n        }\n\n        rateData_.token = BORROW_TOKEN;\n        // values that stay the same: kink, rate at 0%, rate at 100%\n        rateData_.rateAtUtilizationZero =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) &\n            X16;\n        rateData_.kink = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n        rateData_.rateAtUtilizationMax =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) &\n            X16;\n\n        // trigger update\n        AdminModuleStructs.RateDataV1Params[] memory params_ = new AdminModuleStructs.RateDataV1Params[](1);\n        params_[0] = rateData_;\n        LIQUIDITY.updateRateDataV1s(params_);\n\n        // emit event\n        emit LogUpdateRate(supplyRate_, oldRateKink1_, rateData_.rateAtUtilizationKink, 0, 0);\n    }\n\n    /// @dev rebalances for a RateV2 config\n    function _rebalanceRateV2(uint256 supplyRate_, uint256 rateConfig_) internal {\n        AdminModuleStructs.RateDataV2Params memory rateData_;\n\n        uint256 oldRateKink1_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n        uint256 oldRateKink2_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n        (rateData_.rateAtUtilizationKink1, rateData_.rateAtUtilizationKink2) = _calcBorrowRates(\n            supplyRate_,\n            rateConfig_\n        );\n\n        // check if diff is enough to trigger update\n        if (\n            _percentDiffForValue(oldRateKink1_, rateData_.rateAtUtilizationKink1) < MIN_UPDATE_DIFF &&\n            _percentDiffForValue(oldRateKink2_, rateData_.rateAtUtilizationKink2) < MIN_UPDATE_DIFF\n        ) {\n            revert FluidConfigError(ErrorTypes.BufferRateConfigHandler__NoUpdate);\n        }\n\n        rateData_.token = BORROW_TOKEN;\n        // values that stay the same: kink1, kink2, rate at 0%, rate at 100%\n        rateData_.rateAtUtilizationZero =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) &\n            X16;\n        rateData_.kink1 = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\n        rateData_.kink2 = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\n        rateData_.rateAtUtilizationMax =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) &\n            X16;\n\n        // trigger update\n        AdminModuleStructs.RateDataV2Params[] memory params_ = new AdminModuleStructs.RateDataV2Params[](1);\n        params_[0] = rateData_;\n        LIQUIDITY.updateRateDataV2s(params_);\n\n        // emit event\n        emit LogUpdateRate(\n            supplyRate_,\n            oldRateKink1_,\n            rateData_.rateAtUtilizationKink1,\n            oldRateKink2_,\n            rateData_.rateAtUtilizationKink2\n        );\n    }\n}\n"
    },
    "contracts/config/collectRevenueAuth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nabstract contract Constants {\n    /// @notice Fluid liquidity address\n    IFluidLiquidity public immutable LIQUIDITY;\n\n    /// @notice Team multisig allowed to trigger collecting revenue\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n\n    /// @notice Fluid reserve contract, allowed rebalancers there are allowed to trigger collecting revenue\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n}\n\nabstract contract Events {\n    /// @notice emitted when revenue is collected\n    event LogCollectRevenue(address[]);\n}\n\n/// @notice Collects the revenue from the Fluid Liquidity layer to the configured revenue collector\ncontract FluidCollectRevenueAuth is Constants, Error, Events {\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract) or team multisig\n    modifier onlyRebalancerOrMultisig() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender) && msg.sender != TEAM_MULTISIG) {\n            revert FluidConfigError(ErrorTypes.CollectRevenueAuth__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(address liquidity_, address reserveContract_) {\n        if (liquidity_ == address(0) || reserveContract_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.CollectRevenueAuth__InvalidParams);\n        }\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        RESERVE_CONTRACT = IFluidReserveContract(reserveContract_);\n    }\n\n    /// @notice calls the collectRevenue method in the liquidity layer for `tokens_`\n    function collectRevenue(address[] calldata tokens_) external onlyRebalancerOrMultisig {\n        LIQUIDITY.collectRevenue(tokens_);\n\n        emit LogCollectRevenue(tokens_);\n    }\n}\n"
    },
    "contracts/config/dexFeeAuth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nimport { DexSlotsLink } from \"../../libraries/dexSlotsLink.sol\";\nimport { IFluidDexT1 } from \"../../protocols/dex/interfaces/iDexT1.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\n\ninterface IFluidDexT1Admin {\n    /// @notice sets a new fee and revenue cut for a certain dex\n    /// @param fee_ new fee (scaled so that 1% = 10000)\n    /// @param revenueCut_ new revenue cut\n    function updateFeeAndRevenueCut(uint fee_, uint revenueCut_) external;\n}\n\nabstract contract Events {\n    /// @notice emitted when the fee is updated\n    event LogSetFee(address dex, uint oldFee, uint newFee);\n\n    /// @notice emitted when the revenue cut is updated\n    event LogSetRevenueCut(address dex, uint oldRevenueCut, uint newRevenueCut);\n}\n\nabstract contract Constants {\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X17 = 0x1ffff;\n\n    /// @notice Team multisigs allowed to trigger methods\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n    address public constant TEAM_MULTISIG2 = 0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\n}\n\ncontract FluidDexFeeAuth is Constants, Error, Events {\n    /// @dev Validates that an address is team multisig\n    modifier onlyMultisig() {\n        if (TEAM_MULTISIG != msg.sender && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.DexFeeAuth__Unauthorized);\n        }\n        _;\n    }\n\n    function getDexFeeAndRevenueCut(address dex_) public view returns (uint256 fee_, uint256 revenueCut_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        fee_ = (dexVariables2_ >> 2) & X17;\n        revenueCut_ = (dexVariables2_ >> 19) & X7;\n    }\n\n    /// @notice Sets the fee for a given DEX.\n    /// @dev Only callable by team multisig addresses.\n    /// @param dex_ The address of the DEX contract.\n    /// @param newFee_ in 4 decimals, 10000 = 1%\n    function setDexFee(address dex_, uint256 newFee_) external onlyMultisig {\n        (uint256 currentFee_, uint256 currentRevenueCut_) = getDexFeeAndRevenueCut(dex_);\n\n        IFluidDexT1Admin(dex_).updateFeeAndRevenueCut(newFee_, currentRevenueCut_ * FOUR_DECIMALS);\n\n        emit LogSetFee(dex_, currentFee_, newFee_);\n    }\n\n    /// @notice Sets the revenue cut for a given DEX.\n    /// @dev Only callable by team multisig addresses.\n    /// @param dex_ The address of the DEX contract.\n    /// @param newRevenueCut_ in 4 decimals, 100000 = 10%, 10% cut on fee_, so if fee is 1% and cut is 10% then cut in swap amount will be 10% of 1% = 0.1%\n    function setDexRevenueCut(address dex_, uint256 newRevenueCut_) external onlyMultisig {\n        (uint256 currentFee_, uint256 currentRevenueCut_) = getDexFeeAndRevenueCut(dex_);\n\n        IFluidDexT1Admin(dex_).updateFeeAndRevenueCut(currentFee_, newRevenueCut_);\n\n        emit LogSetRevenueCut(dex_, currentRevenueCut_, newRevenueCut_);\n    }\n}\n"
    },
    "contracts/config/dexFeeHandler/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { AddressCalcs } from \"../../libraries/addressCalcs.sol\";\nimport { DexSlotsLink } from \"../../libraries/dexSlotsLink.sol\";\nimport { IFluidDexT1 } from \"../../protocols/dex/interfaces/iDexT1.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\n\ninterface IFluidDexT1Admin {\n    /// @notice sets a new fee and revenue cut for a certain dex\n    /// @param fee_ new fee (scaled so that 1% = 10000)\n    /// @param revenueCut_ new revenue cut\n    function updateFeeAndRevenueCut(uint fee_, uint revenueCut_) external;\n}\n\ninterface ICenterPrice {\n    /// @notice Retrieves the center price for the pool\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\n    /// @return price The current price ratio of token1 to token0, expressed with 27 decimal places\n    function centerPrice() external returns (uint price);\n}\n\nabstract contract Events is Error {\n    /// @notice emitted when rebalancer successfully changes the fee and revenue cut\n    event LogRebalanceFeeAndRevenueCut(address dex, uint fee, uint revenueCut);\n}\n\nabstract contract Constants is Events {\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant SIX_DECIMALS = 1e6;\n\n    uint256 internal constant SCALE = 1e27;\n\n    /// @notice Whether the center price is active\n    bool public immutable CENTER_PRICE_ACTIVE;\n\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X17 = 0x1ffff;\n    uint256 internal constant X20 = 0xfffff;\n    uint256 internal constant X28 = 0xfffffff;\n    uint256 internal constant X30 = 0x3fffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X40 = 0xffffffffff;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    /// @dev Address of contract used for deploying center price & hook related contract\n    address internal immutable DEPLOYER_CONTRACT;\n\n    uint256 public immutable MIN_FEE; // e.g. 10 -> 0.001%\n    uint256 public immutable MAX_FEE; // e.g. 100 -> 0.01%\n    uint256 public immutable MIN_DEVIATION; // in 1e27 scale, e.g. 3e23 -> 0.003\n    uint256 public immutable MAX_DEVIATION; // in 1e27 scale, e.g. 1e24 -> 0.01\n\n    uint256 public immutable UPDATE_FEE_TRIGGER_BUFFER = 10; // e.g. 1e4 -> 1%\n\n    address public immutable DEX;\n\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n}\n\nabstract contract DexHelpers is Constants {\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\n        }\n        _;\n    }\n\n    constructor(\n        address dex_,\n        address deployerContract_,\n        bool isCenterPriceActive_\n    ) validAddress(dex_) validAddress(deployerContract_) {\n        DEX = dex_;\n        DEPLOYER_CONTRACT = deployerContract_;\n        CENTER_PRICE_ACTIVE = isCenterPriceActive_;\n    }\n\n    function _getCenterPriceShift() internal view returns (uint256) {\n        return IFluidDexT1(DEX).readFromStorage(bytes32(DexSlotsLink.DEX_CENTER_PRICE_SHIFT_SLOT));\n    }\n\n    function _getDexVariables() internal view returns (uint256) {\n        return IFluidDexT1(DEX).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES_SLOT));\n    }\n\n    function _getDexVariables2() internal view returns (uint256) {\n        return IFluidDexT1(DEX).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n    }\n\n    function _getCenterPriceFromCenterPriceAddress(uint256 centerPriceNonce_) internal view returns (uint256) {\n        address centerPriceAddress_ = AddressCalcs.addressCalc(DEPLOYER_CONTRACT, centerPriceNonce_);\n        (bool success_, bytes memory data_) = centerPriceAddress_.staticcall(\n            abi.encodeWithSelector(ICenterPrice.centerPrice.selector)\n        );\n        require(success_, \"Static call failed\");\n        return abi.decode(data_, (uint256));\n    }\n\n    function _calcCenterPrice(uint dexVariables_, uint centerPriceNonce_) internal view returns (uint newCenterPrice_) {\n        uint oldCenterPrice_ = (dexVariables_ >> 81) & X40;\n        oldCenterPrice_ = (oldCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (oldCenterPrice_ & DEFAULT_EXPONENT_MASK);\n\n        uint centerPriceShift_ = _getCenterPriceShift();\n\n        uint startTimeStamp_ = centerPriceShift_ & X33;\n        uint percent_ = (centerPriceShift_ >> 33) & X20;\n        uint time_ = (centerPriceShift_ >> 53) & X20;\n\n        uint fromTimeStamp_ = (dexVariables_ >> 121) & X33;\n        fromTimeStamp_ = fromTimeStamp_ > startTimeStamp_ ? fromTimeStamp_ : startTimeStamp_;\n\n        newCenterPrice_ = _getCenterPriceFromCenterPriceAddress(centerPriceNonce_);\n        uint priceShift_ = (oldCenterPrice_ * percent_ * (block.timestamp - fromTimeStamp_)) / (time_ * SIX_DECIMALS);\n\n        if (newCenterPrice_ > oldCenterPrice_) {\n            // shift on positive side\n            oldCenterPrice_ += priceShift_;\n            if (newCenterPrice_ > oldCenterPrice_) {\n                newCenterPrice_ = oldCenterPrice_;\n            }\n        } else {\n            unchecked {\n                oldCenterPrice_ = oldCenterPrice_ > priceShift_ ? oldCenterPrice_ - priceShift_ : 0;\n                // In case of oldCenterPrice_ ending up 0, which could happen when a lot of time has passed (pool has no swaps for many days or weeks)\n                // then below we get into the else logic which will fully conclude shifting and return newCenterPrice_\n                // as it was fetched from the external center price source.\n                // not ideal that this would ever happen unless the pool is not in use and all/most users have left leaving not enough liquidity to trade on\n            }\n            if (newCenterPrice_ < oldCenterPrice_) {\n                newCenterPrice_ = oldCenterPrice_;\n            }\n        }\n    }\n\n    function _fetchCenterPrice() internal view returns (uint256 centerPrice_) {\n        (uint256 dexVariables_, uint256 dexVariables2_) = (_getDexVariables(), _getDexVariables2());\n\n        // centerPrice_ => center price hook\n        centerPrice_ = (dexVariables2_ >> 112) & X30;\n\n        // whether centerPrice shift is active or not\n        if (((dexVariables2_ >> 248) & 1) == 0) {\n            if (centerPrice_ == 0) {\n                centerPrice_ = (dexVariables_ >> 81) & X40;\n                centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n            } else {\n                // center price should be fetched from external source. For exmaple, in case of wstETH <> ETH pool,\n                // we would want the center price to be pegged to wstETH exchange rate into ETH\n                centerPrice_ = _getCenterPriceFromCenterPriceAddress(centerPrice_);\n            }\n        } else {\n            // an active centerPrice_ shift is going on\n            centerPrice_ = _calcCenterPrice(dexVariables_, centerPrice_);\n        }\n\n        {\n            uint maxCenterPrice_ = (dexVariables2_ >> 172) & X28;\n            maxCenterPrice_ = (maxCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (maxCenterPrice_ & DEFAULT_EXPONENT_MASK);\n\n            if (centerPrice_ > maxCenterPrice_) {\n                // if center price is greater than max center price\n                centerPrice_ = maxCenterPrice_;\n            } else {\n                // check if center price is less than min center price\n                uint minCenterPrice_ = (dexVariables2_ >> 200) & X28;\n                minCenterPrice_ =\n                    (minCenterPrice_ >> DEFAULT_EXPONENT_SIZE) <<\n                    (minCenterPrice_ & DEFAULT_EXPONENT_MASK);\n                if (centerPrice_ < minCenterPrice_) {\n                    centerPrice_ = minCenterPrice_;\n                }\n            }\n        }\n    }\n\n    function _getDexFee() internal view returns (uint256 fee_) {\n        return (_getDexVariables2() >> 2) & X17;\n    }\n\n    function getDexCenterPrice() public view returns (uint256) {\n        return _fetchCenterPrice();\n    }\n\n    /// @notice returns the revenue cut for the dex\n    function getDexRevenueCut() public view returns (uint256 revenueCut_) {\n        return (_getDexVariables2() >> 19) & X7;\n    }\n\n    /// @notice returns the fee and revenue cut for the dex\n    function getDexFeeAndRevenueCut() public view returns (uint256 fee_, uint256 revenueCut_) {\n        uint256 dexVariables2_ = _getDexVariables2();\n\n        fee_ = (dexVariables2_ >> 2) & X17;\n        revenueCut_ = (dexVariables2_ >> 19) & X7;\n    }\n\n    /// @notice returns the last stored prices of the pool and the last interaction time stamp\n    function getDexVariables()\n        public\n        view\n        returns (uint256 lastToLastStoredPrice_, uint256 lastStoredPriceOfPool_, uint256 lastInteractionTimeStamp_)\n    {\n        uint256 dexVariables_ = _getDexVariables();\n\n        lastToLastStoredPrice_ = (dexVariables_ >> 1) & X40;\n        lastToLastStoredPrice_ =\n            (lastToLastStoredPrice_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastToLastStoredPrice_ & DEFAULT_EXPONENT_MASK);\n\n        lastStoredPriceOfPool_ = (dexVariables_ >> 41) & X40;\n        lastStoredPriceOfPool_ =\n            (lastStoredPriceOfPool_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastStoredPriceOfPool_ & DEFAULT_EXPONENT_MASK);\n\n        lastInteractionTimeStamp_ = (dexVariables_ >> 121) & X33;\n    }\n}\n\nabstract contract DynamicFee is DexHelpers {\n    constructor(uint256 _minFee, uint256 _maxFee, uint256 _minDeviation, uint256 _maxDeviation) {\n        // check for zero values\n        if (_minFee == 0 || _maxFee == 0 || _minDeviation == 0 || _maxDeviation == 0)\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\n\n        // check that max fee is not greater or equal to 1%\n        if (_maxFee >= 1e4) revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\n\n        // check that min deviation is not greater than max deviation\n        if (_minDeviation > _maxDeviation) revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\n\n        // check that min fee is not greater than max fee\n        if (_minFee > _maxFee) revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\n\n        MIN_FEE = _minFee;\n        MAX_FEE = _maxFee;\n        MIN_DEVIATION = _minDeviation;\n        MAX_DEVIATION = _maxDeviation;\n    }\n\n    /// @notice Calculates the deviation from the given price.\n    function getDeviationFromPrice(uint256 price_) public view returns (uint256) {\n        if (CENTER_PRICE_ACTIVE) {\n            uint256 centerPrice_ = _fetchCenterPrice();\n            uint256 deviation_ = price_ > centerPrice_ ? price_ - centerPrice_ : centerPrice_ - price_;\n            return (deviation_ * SCALE) / centerPrice_;\n        } else {\n            return price_ > SCALE ? price_ - SCALE : SCALE - price_;\n        }\n    }\n\n    /// @notice Calculates the dynamic fee based on the given price.\n    function dynamicFeeFromPrice(uint256 price) external view returns (uint256) {\n        return _computeDynamicFee(getDeviationFromPrice(price));\n    }\n\n    /// @notice Calculates the dynamic fee based on the given deviation.\n    function dynamicFeeFromDeviation(uint256 deviation) external view returns (uint256) {\n        return _computeDynamicFee(deviation);\n    }\n\n    /**\n     * @dev Internal helper that implements a smooth-step curve for fee calculation\n     * @param deviation Deviation from the target price in SCALE (1e27)\n     * @return Fee in basis points (1e4 = 1%)\n     */\n    function _computeDynamicFee(uint256 deviation) internal view returns (uint256) {\n        if (deviation <= MIN_DEVIATION) {\n            return MIN_FEE;\n        } else if (deviation >= MAX_DEVIATION) {\n            return MAX_FEE;\n        } else {\n            // Calculate normalized position between min and max deviation (0 to 1 in SCALE)\n            uint256 alpha = ((deviation - MIN_DEVIATION) * SCALE) / (MAX_DEVIATION - MIN_DEVIATION);\n\n            // Smooth step formula: 3x² - 2x³\n            // https://en.wikipedia.org/wiki/Smoothstep\n            uint256 alpha2 = _scaleMul(alpha, alpha);\n            uint256 alpha3 = _scaleMul(alpha2, alpha);\n\n            uint256 smooth = _scaleMul(3 * SCALE, alpha2) - _scaleMul(2 * SCALE, alpha3);\n\n            uint256 feeDelta = MAX_FEE - MIN_FEE;\n            uint256 interpolatedFee = MIN_FEE + (_scaleMul(smooth, feeDelta));\n\n            return interpolatedFee;\n        }\n    }\n\n    function _scaleMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * b) / SCALE;\n    }\n}\n\nabstract contract FluidDexFeeHandlerHelpers is DynamicFee {\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(\n        uint256 minFee_,\n        uint256 maxFee_,\n        uint256 minDeviation_,\n        uint256 maxDeviation_,\n        address dex_,\n        address deployerContract_,\n        IFluidReserveContract reserveContract_,\n        bool centerPriceActive_\n    )\n        validAddress(address(reserveContract_))\n        DexHelpers(dex_, deployerContract_, centerPriceActive_)\n        DynamicFee(minFee_, maxFee_, minDeviation_, maxDeviation_)\n    {\n        RESERVE_CONTRACT = reserveContract_;\n    }\n\n    /// @notice returns the dynamic fee for the dex based on the last stored price of the pool\n    function getDexDynamicFee() public view returns (uint256) {\n        (\n            uint256 lastToLastStoredPrice_,\n            uint256 lastStoredPriceOfPool_,\n            uint256 lastInteractionTimeStamp_\n        ) = getDexVariables();\n\n        if (lastInteractionTimeStamp_ == block.timestamp) lastStoredPriceOfPool_ = lastToLastStoredPrice_;\n\n        return _computeDynamicFee(getDeviationFromPrice(lastStoredPriceOfPool_));\n    }\n\n    function _configPercentDiff(\n        uint256 currentFee_,\n        uint256 newFee_\n    ) internal pure returns (uint256 configPercentDiff_) {\n        if (currentFee_ == newFee_) {\n            return 0;\n        }\n\n        if (currentFee_ > newFee_) configPercentDiff_ = currentFee_ - newFee_;\n        else configPercentDiff_ = newFee_ - currentFee_;\n\n        return (configPercentDiff_ * FOUR_DECIMALS) / currentFee_;\n    }\n}\n\ncontract FluidDexFeeHandler is FluidDexFeeHandlerHelpers {\n    constructor(\n        uint256 minFee_,\n        uint256 maxFee_,\n        uint256 minDeviation_,\n        uint256 maxDeviation_,\n        address dex_,\n        address deployerContract_,\n        IFluidReserveContract reserveContract_,\n        bool centerPriceActive_\n    )\n        FluidDexFeeHandlerHelpers(\n            minFee_,\n            maxFee_,\n            minDeviation_,\n            maxDeviation_,\n            dex_,\n            deployerContract_,\n            reserveContract_,\n            centerPriceActive_\n        )\n    {}\n\n    /// @notice rebalances the fee\n    function rebalance() external onlyRebalancer {\n        uint256 newFee_ = getDexDynamicFee();\n\n        (uint256 currentFee_, uint256 currentRevenueCut_) = getDexFeeAndRevenueCut();\n\n        uint256 feePercentageChange_ = _configPercentDiff(currentFee_, newFee_);\n\n        // should be more than 0.001% to update\n        if (feePercentageChange_ > UPDATE_FEE_TRIGGER_BUFFER) {\n            IFluidDexT1Admin(DEX).updateFeeAndRevenueCut(newFee_, currentRevenueCut_ * FOUR_DECIMALS);\n            emit LogRebalanceFeeAndRevenueCut(DEX, newFee_, currentRevenueCut_ * FOUR_DECIMALS);\n        } else {\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__FeeUpdateNotRequired);\n        }\n    }\n\n    /// @notice returns how much new config would be different from current config in percent (100 = 1%, 1 = 0.01%).\n    function relativeConfigPercentDiff() public view returns (uint256) {\n        return _configPercentDiff(_getDexFee(), getDexDynamicFee());\n    }\n\n    /// @notice returns how much new config would be different from current config.\n    function absoluteConfigDiff() public view returns (uint256) {\n        uint256 newFee_ = getDexDynamicFee();\n        uint256 oldFee_ = _getDexFee();\n\n        return newFee_ > oldFee_ ? newFee_ - oldFee_ : oldFee_ - newFee_;\n    }\n\n    /// @notice returns the new calculated fee\n    function newConfig() public view returns (uint256) {\n        return getDexDynamicFee();\n    }\n\n    /// @notice returns the currently configured fee\n    function currentConfig() public view returns (uint256) {\n        return _getDexFee();\n    }\n}\n"
    },
    "contracts/config/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Error {\n    error FluidConfigError(uint256 errorId_);\n}\n"
    },
    "contracts/config/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |    ExpandPercentConfigHandler     | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant ExpandPercentConfigHandler__AddressZero = 100001;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant ExpandPercentConfigHandler__Unauthorized = 100002;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant ExpandPercentConfigHandler__InvalidParams = 100003;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant ExpandPercentConfigHandler__NoUpdate = 100004;\n\n    /// @notice thrown when slot is not used, e.g. when borrow token is 0 there is no borrow data\n    uint256 internal constant ExpandPercentConfigHandler__SlotDoesNotExist = 100005;\n\n    /***********************************|\n    |      EthenaRateConfigHandler      | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant EthenaRateConfigHandler__AddressZero = 100011;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant EthenaRateConfigHandler__Unauthorized = 100012;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant EthenaRateConfigHandler__InvalidParams = 100013;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant EthenaRateConfigHandler__NoUpdate = 100014;\n\n    /***********************************|\n    |       MaxBorrowConfigHandler      | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant MaxBorrowConfigHandler__AddressZero = 100021;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant MaxBorrowConfigHandler__Unauthorized = 100022;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant MaxBorrowConfigHandler__InvalidParams = 100023;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant MaxBorrowConfigHandler__NoUpdate = 100024;\n\n    /***********************************|\n    |       BufferRateConfigHandler     | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant BufferRateConfigHandler__AddressZero = 100031;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant BufferRateConfigHandler__Unauthorized = 100032;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant BufferRateConfigHandler__InvalidParams = 100033;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant BufferRateConfigHandler__NoUpdate = 100034;\n\n    /// @notice thrown when rate data version is not supported\n    uint256 internal constant BufferRateConfigHandler__RateVersionUnsupported = 100035;\n\n    /***********************************|\n    |          FluidRatesAuth           | \n    |__________________________________*/\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant RatesAuth__NoUpdate = 100041;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant RatesAuth__Unauthorized = 100042;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant RatesAuth__InvalidParams = 100043;\n\n    /// @notice thrown when cooldown is not yet expired\n    uint256 internal constant RatesAuth__CooldownLeft = 100044;\n\n    /// @notice thrown when version is invalid\n    uint256 internal constant RatesAuth__InvalidVersion = 100045;\n\n    /***********************************|\n    |       LiquidityTokenAuth          | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant LiquidityTokenAuth__Unauthorized = 100051;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant LiquidityTokenAuth_AlreadyInitialized = 100052;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant LiquidityTokenAuth__InvalidParams = 100053;\n\n    /***********************************|\n    |       CollectRevenueAuth          | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant CollectRevenueAuth__Unauthorized = 100061;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant CollectRevenueAuth__InvalidParams = 100062;\n\n    /***********************************|\n    |       FluidWithdrawLimitAuth      | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant WithdrawLimitAuth__NoUserSupply = 100071;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant WithdrawLimitAuth__Unauthorized = 100072;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant WithdrawLimitAuth__InvalidParams = 100073;\n\n    /// @notice thrown when no more withdrawal limit can be set for the day\n    uint256 internal constant WithdrawLimitAuth__DailyLimitReached = 100074;\n\n    /// @notice thrown when no more withdrawal limit can be set for the hour\n    uint256 internal constant WithdrawLimitAuth__HourlyLimitReached = 100075;\n\n    /// @notice thrown when the withdrawal limit and userSupply difference exceeds 5%\n    uint256 internal constant WithdrawLimitAuth__ExcessPercentageDifference = 100076;\n\n    /***********************************|\n    |       DexFeeHandler               | \n    |__________________________________*/\n\n    /// @notice thrown when fee update is not required\n    uint256 internal constant DexFeeHandler__FeeUpdateNotRequired = 100081;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant DexFeeHandler__InvalidParams = 100082;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls\n    uint256 internal constant DexFeeHandler__Unauthorized = 100083;\n\n    /***********************************|\n    |           RangeAuthDex            | \n    |__________________________________*/\n\n    uint256 internal constant RangeAuthDex__InvalidParams = 100091;\n    uint256 internal constant RangeAuthDex__CooldownLeft = 100092;\n    uint256 internal constant RangeAuthDex__Unauthorized = 100093;\n    uint256 internal constant RangeAuthDex__ExceedAllowedPercentageChange = 100094;\n    uint256 internal constant RangeAuthDex__InvalidShiftTime = 100095;\n\n    /***********************************|\n    |           FluidLimitsAuth         | \n    |__________________________________*/\n\n    uint256 internal constant LimitsAuth__InvalidParams = 100101;\n    uint256 internal constant LimitsAuth__Unauthorized = 100102;\n    uint256 internal constant LimitsAuth__UserNotDefinedYet = 100103;\n    uint256 internal constant LimitsAuth__ExceedAllowedPercentageChange = 100104;\n    uint256 internal constant LimitsAuth__CoolDownPending = 100105;\n\n    /***********************************|\n    |          DexFeeAuth               | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls\n    uint256 internal constant DexFeeAuth__Unauthorized = 100111;\n\n    /***********************************|\n    |       VaultFeeRewardsAuth         | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls\n    uint256 internal constant VaultFeeRewardsAuth__Unauthorized = 100121;\n    /// @notice thrown when magnifier or rate is being updated for a non matching vault type\n    uint256 internal constant VaultFeeRewardsAuth__InvalidVaultType = 100122;\n}\n"
    },
    "contracts/config/ethenaRateHandler/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Events {\n    /// @notice emitted when borrow magnifier is updated at vault\n    event LogUpdateBorrowRateMagnifier(uint256 oldMagnifier, uint256 newMagnifier);\n}\n"
    },
    "contracts/config/ethenaRateHandler/interfaces/iStakedUSDe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\ninterface IStakedUSDe is IERC4626 {\n    /// @notice The amount of the last asset distribution from the controller contract into this\n    /// contract + any unvested remainder at that time\n    function vestingAmount() external view returns (uint256);\n\n    /// @notice The timestamp of the last asset distribution from the controller contract into this contract\n    function lastDistributionTimestamp() external view returns (uint256);\n\n    /// @notice Returns the amount of USDe tokens that are vested in the contract.\n    function totalAssets() external view returns (uint256);\n}\n"
    },
    "contracts/config/ethenaRateHandler/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { IFluidVaultT1 } from \"../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { FluidVaultT1Admin } from \"../../protocols/vault/vaultT1/adminModule/main.sol\";\nimport { IStakedUSDe } from \"./interfaces/iStakedUSDe.sol\";\nimport { Variables } from \"./variables.sol\";\nimport { Events } from \"./events.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\n/// @notice Sets borrow rate for sUSDe/debtToken vaults based on sUSDe yield rate, by adjusting the borrowRateMagnifier\ncontract FluidEthenaRateConfigHandler is Variables, Error, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.EthenaRateConfigHandler__AddressZero);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract)\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.EthenaRateConfigHandler__Unauthorized);\n        }\n        _;\n    }\n\n    // vault2 is optional, set to address zero if only triggering on one vault. borrow token must be vault1 == vault2!\n    constructor(\n        IFluidReserveContract reserveContract_,\n        IFluidLiquidity liquidity_,\n        IFluidVaultT1 vault_,\n        IFluidVaultT1 vault2_,\n        IStakedUSDe stakedUSDe_,\n        address borrowToken_,\n        uint256 ratePercentMargin_,\n        uint256 maxRewardsDelay_,\n        uint256 utilizationPenaltyStart_,\n        uint256 utilization100PenaltyPercent_\n    )\n        validAddress(address(reserveContract_))\n        validAddress(address(liquidity_))\n        validAddress(address(vault_))\n        validAddress(address(stakedUSDe_))\n        validAddress(borrowToken_)\n    {\n        if (\n            ratePercentMargin_ == 0 ||\n            ratePercentMargin_ >= 1e4 ||\n            maxRewardsDelay_ == 0 ||\n            utilizationPenaltyStart_ >= 1e4 ||\n            utilization100PenaltyPercent_ == 0\n        ) {\n            revert FluidConfigError(ErrorTypes.EthenaRateConfigHandler__InvalidParams);\n        }\n\n        RESERVE_CONTRACT = reserveContract_;\n        LIQUIDITY = liquidity_;\n        SUSDE = stakedUSDe_;\n        VAULT = vault_;\n        VAULT2 = vault2_;\n        BORROW_TOKEN = borrowToken_;\n\n        _LIQUDITY_BORROW_TOKEN_EXCHANGE_PRICES_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            borrowToken_\n        );\n\n        RATE_PERCENT_MARGIN = ratePercentMargin_;\n        MAX_REWARDS_DELAY = maxRewardsDelay_;\n\n        UTILIZATION_PENALTY_START = utilizationPenaltyStart_;\n        UTILIZATION100_PENALTY_PERCENT = utilization100PenaltyPercent_;\n    }\n\n    /// @notice Rebalances the borrow rate magnifier for `VAULT` (and `VAULT2`) based on borrow rate at Liquidity in\n    /// relation to sUSDe yield rate (`getSUSDEYieldRate()`).\n    /// Emits `LogUpdateBorrowRateMagnifier` in case of update. Reverts if no update is needed.\n    /// Can only be called by an authorized rebalancer.\n    function rebalance() external onlyRebalancer {\n        uint256 targetMagnifier_ = calculateMagnifier();\n        uint256 currentMagnifier_ = currentMagnifier();\n\n        // execute update on vault if necessary\n        if (targetMagnifier_ == currentMagnifier_) {\n            revert FluidConfigError(ErrorTypes.EthenaRateConfigHandler__NoUpdate);\n        }\n\n        FluidVaultT1Admin(address(VAULT)).updateBorrowRateMagnifier(targetMagnifier_);\n        if (address(VAULT2) != address(0)) {\n            FluidVaultT1Admin(address(VAULT2)).updateBorrowRateMagnifier(targetMagnifier_);\n        }\n\n        emit LogUpdateBorrowRateMagnifier(currentMagnifier_, targetMagnifier_);\n    }\n\n    /// @notice Calculates the new borrow rate magnifier based on sUSDe yield rate and utilization\n    /// @return magnifier_ the calculated magnifier value.\n    function calculateMagnifier() public view returns (uint256 magnifier_) {\n        uint256 sUSDeYieldRate_ = getSUSDeYieldRate();\n        uint256 exchangePriceAndConfig_ = LIQUIDITY.readFromStorage(_LIQUDITY_BORROW_TOKEN_EXCHANGE_PRICES_SLOT);\n\n        uint256 utilization_ = (exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14;\n\n        // calculate target borrow rate. scaled by 1e18.\n        // borrow rate is based on sUSDeYieldRate_ and a margin that goes to lenders\n        // e.g. when RATE_PERCENT_MARGIN = 1000 (10%), then borrow rate will be 90% of the sUSDe yield rate\n        // e.g. when sUSDe yield is 60%, borrow rate would be 54%\n        uint256 targetBorrowRate_ = (sUSDeYieldRate_ * (1e4 - RATE_PERCENT_MARGIN)) / 1e4;\n\n        if (utilization_ > UTILIZATION_PENALTY_START) {\n            // above UTILIZATION_PENALTY_START (e.g. 90%), penalty should rise linearly according to UTILIZATION100_PENALTY_PERCENT\n            // e.g. from 10% margin at 90% utilization to 10% - penalty margin at 100% utilization\n            // so from +RATE_PERCENT_MARGIN at UTILIZATION_PENALTY_START to +RATE_PERCENT_MARGIN - UTILIZATION100_PENALTY_PERCENT at 100%\n            if (utilization_ < 1e4) {\n                uint256 utilizationAbovePenaltyStart_ = utilization_ - UTILIZATION_PENALTY_START; // e.g. 95 - 90 = 5%\n                uint256 penaltyUtilizationDiff_ = 1e4 - UTILIZATION_PENALTY_START; // e.g. 100 - 90 = 10%\n\n                // e.g. when current utilization = 96%, start penalty utilization = 90%, penalty at 100 = 12%, rate margin = 15%:\n                // utilizationAbovePenaltyStart_ = 600 (6%)\n                // penaltyUtilizationDiff_ = 1000 (10%)\n                // UTILIZATION100_PENALTY_PERCENT = 1200 (12%)\n                // marginAfterPenalty_ = 1200 * 600 / 1000 = 720 (7.2%)\n                uint256 marginAfterPenalty_ = (UTILIZATION100_PENALTY_PERCENT * utilizationAbovePenaltyStart_) /\n                    penaltyUtilizationDiff_;\n\n                // for above example, when sUSDe yield is 60%, borrow rate would become 57.89% (from 60% * (90% + 7.2%) / 100% )\n                targetBorrowRate_ = (sUSDeYieldRate_ * ((1e4 - RATE_PERCENT_MARGIN) + marginAfterPenalty_)) / 1e4;\n            } else {\n                // above 100% utilization, cap at RATE_PERCENT_MARGIN - UTILIZATION100_PENALTY_PERCENT penalty\n                targetBorrowRate_ =\n                    (sUSDeYieldRate_ * (1e4 - RATE_PERCENT_MARGIN + UTILIZATION100_PENALTY_PERCENT)) /\n                    1e4;\n            }\n        }\n\n        // get current neutral borrow rate at Liquidity (without any magnifier).\n        // exchangePriceAndConfig slot at Liquidity, first 16 bits\n        uint256 liquidityBorrowRate_ = exchangePriceAndConfig_ & X16;\n\n        if (liquidityBorrowRate_ == 0) {\n            return 1e4;\n        }\n\n        // calculate magnifier needed to reach target borrow rate.\n        // liquidityBorrowRate_ * x = targetBorrowRate_. so x = targetBorrowRate_ / liquidityBorrowRate_.\n        // must scale liquidityBorrowRate_ from 1e2 to 1e18 as targetBorrowRate_ is in 1e18. magnifier itself is scaled\n        // by 1e4 (1x = 10000)\n        magnifier_ = (1e4 * targetBorrowRate_) / (liquidityBorrowRate_ * 1e16);\n\n        // make sure magnifier is within allowed limits\n        if (magnifier_ < _MIN_MAGNIFIER) {\n            return _MIN_MAGNIFIER;\n        }\n        if (magnifier_ > _MAX_MAGNIFIER) {\n            return _MAX_MAGNIFIER;\n        }\n    }\n\n    /// @notice returns the currently configured borrow magnifier at the `VAULT` (and `VAULT2`).\n    function currentMagnifier() public view returns (uint256) {\n        // read borrow rate magnifier from Vault `vaultVariables2` located in storage slot 1, 16 bits from 16-31\n        return (VAULT.readFromStorage(bytes32(uint256(1))) >> 16) & X16;\n    }\n\n    /// @notice calculates updated vesting yield rate based on `vestingAmount` and `totalAssets` of StakedUSDe contract\n    /// @return rate_ sUSDe yearly yield rate scaled by 1e18 (1e18 = 1%, 1e20 = 100%)\n    function getSUSDeYieldRate() public view returns (uint256 rate_) {\n        if (block.timestamp > SUSDE.lastDistributionTimestamp() + _SUSDE_VESTING_PERIOD + MAX_REWARDS_DELAY) {\n            // if rewards update on StakedUSDe contract is delayed by more than `MAX_REWARDS_DELAY`, we use rate as 0\n            // as we can't know if e.g. funding would have gone negative and there are indeed no rewards.\n            return 0;\n        }\n\n        // vestingAmount is yield per 8 hours (`SUSDE_VESTING_PERIOD`)\n        rate_ = (SUSDE.vestingAmount() * 1e20) / SUSDE.totalAssets(); // 8 hours rate\n        // turn into yearly yield\n        rate_ = (rate_ * 365 * 24 hours) / _SUSDE_VESTING_PERIOD; // 365 days * 24 hours / 8 hours -> rate_ * 1095\n    }\n}\n"
    },
    "contracts/config/ethenaRateHandler/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { IFluidVaultT1 } from \"../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { IStakedUSDe } from \"./interfaces/iStakedUSDe.sol\";\n\nabstract contract Constants {\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n    IFluidLiquidity public immutable LIQUIDITY;\n    IFluidVaultT1 public immutable VAULT;\n    IFluidVaultT1 public immutable VAULT2;\n    IStakedUSDe public immutable SUSDE;\n    address public immutable BORROW_TOKEN;\n\n    /// @notice sUSDe vesting yield reward rate percent margin that goes to lenders\n    /// e.g. RATE_PERCENT_MARGIN = 10% then borrow rate for debt token ends up as 90% of the sUSDe yield.\n    /// (in 1e2: 100% = 10_000; 1% = 100)\n    uint256 public immutable RATE_PERCENT_MARGIN;\n\n    /// @notice max delay in seconds for rewards update after vesting period ended, after which we assume rate is 0.\n    /// e.g. 15 min\n    uint256 public immutable MAX_REWARDS_DELAY;\n\n    /// @notice utilization penalty start point (in 1e2: 100% = 10_000; 1% = 100). above this, a penalty percent\n    ///         is applied, to incentivize deleveraging.\n    uint256 public immutable UTILIZATION_PENALTY_START;\n    /// @notice penalty percent target at 100%, on top of sUSDe yield rate if utilization is above UTILIZATION_PENALTY_START\n    ///         (in 1e2: 100% = 10_000; 1% = 100)\n    uint256 public immutable UTILIZATION100_PENALTY_PERCENT;\n\n    bytes32 internal immutable _LIQUDITY_BORROW_TOKEN_EXCHANGE_PRICES_SLOT;\n\n    /// @dev vesting period defined as private constant on StakedUSDe contract\n    uint256 internal constant _SUSDE_VESTING_PERIOD = 8 hours;\n\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant _MIN_MAGNIFIER = 1e4; // min magnifier is always at least 1x (10000)\n    uint256 internal constant _MAX_MAGNIFIER = 65535; // max magnifier to fit in storage slot is 65535 (16 bits)\n}\n\nabstract contract Variables is Constants {}\n"
    },
    "contracts/config/expandPercentHandler/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { Structs as AdminModuleStructs } from \"../../liquidity/adminModule/structs.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nabstract contract Constants {\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n    IFluidLiquidity public immutable LIQUIDITY;\n    address public immutable PROTOCOL;\n    address public immutable WITHDRAW_TOKEN;\n    address public immutable BORROW_TOKEN;\n\n    uint256 public immutable BORROW_CHECKPOINT1;\n    uint256 public immutable BORROW_CHECKPOINT2;\n    uint256 public immutable BORROW_CHECKPOINT3;\n    uint256 public immutable BORROW_EXPAND_UNTIL_CHECKPOINT1;\n    uint256 public immutable BORROW_EXPAND_UNTIL_CHECKPOINT2;\n    uint256 public immutable BORROW_EXPAND_UNTIL_CHECKPOINT3;\n    uint256 public immutable BORROW_EXPAND_ABOVE_CHECKPOINT3;\n\n    uint256 public immutable WITHDRAW_CHECKPOINT1;\n    uint256 public immutable WITHDRAW_CHECKPOINT2;\n    uint256 public immutable WITHDRAW_CHECKPOINT3;\n    uint256 public immutable WITHDRAW_EXPAND_UNTIL_CHECKPOINT1;\n    uint256 public immutable WITHDRAW_EXPAND_UNTIL_CHECKPOINT2;\n    uint256 public immutable WITHDRAW_EXPAND_UNTIL_CHECKPOINT3;\n    uint256 public immutable WITHDRAW_EXPAND_ABOVE_CHECKPOINT3;\n\n    bytes32 internal immutable _LIQUDITY_WITHDRAW_TOKEN_EXCHANGE_PRICES_SLOT;\n    bytes32 internal immutable _LIQUDITY_BORROW_TOKEN_EXCHANGE_PRICES_SLOT;\n\n    bytes32 internal immutable _LIQUDITY_PROTOCOL_SUPPLY_SLOT;\n    bytes32 internal immutable _LIQUDITY_PROTOCOL_BORROW_SLOT;\n\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xff;\n\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n}\n\nabstract contract Events {\n    /// @notice emitted when withdraw limit expand percent is updated\n    event LogUpdateWithdrawLimitExpansion(uint256 supply, uint256 oldExpandPercent, uint256 newExpandPercent);\n\n    /// @notice emitted when borrow limit expand percent is updated\n    event LogUpdateBorrowLimitExpansion(uint256 borrow, uint256 oldExpandPercent, uint256 newExpandPercent);\n}\n\nabstract contract Structs {\n    struct LimitCheckPoints {\n        uint256 tvlCheckPoint1; // e.g. 20M\n        uint256 expandPercentUntilCheckPoint1; // e.g. 25%\n        uint256 tvlCheckPoint2; // e.g. 30M\n        uint256 expandPercentUntilCheckPoint2; // e.g. 20%\n        uint256 tvlCheckPoint3; // e.g. 40M\n        uint256 expandPercentUntilCheckPoint3; // e.g. 15%\n        uint256 expandPercentAboveCheckPoint3; // e.g. 10%\n    }\n}\n\n/// @notice Sets limits on Liquidity for a protocol based on TVL checkpoints.\ncontract FluidExpandPercentConfigHandler is Constants, Error, Events, Structs {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.ExpandPercentConfigHandler__AddressZero);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract)\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.ExpandPercentConfigHandler__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(\n        IFluidReserveContract reserveContract_,\n        IFluidLiquidity liquidity_,\n        address protocol_,\n        address withdrawToken_, // can be unused in some cases (e.g. StETH)\n        address borrowToken_, // can be unused in some cases (e.g. Lending)\n        LimitCheckPoints memory withdrawCheckPoints_, // can be skipped if withdrawToken is not set.\n        LimitCheckPoints memory borrowCheckPoints_ // can be skipped if borrowToken_ is not set.\n    ) validAddress(address(reserveContract_)) validAddress(address(liquidity_)) validAddress(protocol_) {\n        RESERVE_CONTRACT = reserveContract_;\n        LIQUIDITY = liquidity_;\n        PROTOCOL = protocol_;\n        WITHDRAW_TOKEN = withdrawToken_;\n        BORROW_TOKEN = borrowToken_;\n\n        // set withdraw limit values\n        if (withdrawToken_ == address(0)) {\n            if (borrowToken_ == address(0)) {\n                revert FluidConfigError(ErrorTypes.ExpandPercentConfigHandler__InvalidParams);\n            }\n\n            _LIQUDITY_PROTOCOL_SUPPLY_SLOT = bytes32(0);\n        } else {\n            _LIQUDITY_PROTOCOL_SUPPLY_SLOT = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n                protocol_,\n                withdrawToken_\n            );\n            _LIQUDITY_WITHDRAW_TOKEN_EXCHANGE_PRICES_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n                withdrawToken_\n            );\n\n            _validateLimitCheckPoints(withdrawCheckPoints_);\n\n            WITHDRAW_CHECKPOINT1 = withdrawCheckPoints_.tvlCheckPoint1;\n            WITHDRAW_CHECKPOINT2 = withdrawCheckPoints_.tvlCheckPoint2;\n            WITHDRAW_CHECKPOINT3 = withdrawCheckPoints_.tvlCheckPoint3;\n            WITHDRAW_EXPAND_UNTIL_CHECKPOINT1 = withdrawCheckPoints_.expandPercentUntilCheckPoint1;\n            WITHDRAW_EXPAND_UNTIL_CHECKPOINT2 = withdrawCheckPoints_.expandPercentUntilCheckPoint2;\n            WITHDRAW_EXPAND_UNTIL_CHECKPOINT3 = withdrawCheckPoints_.expandPercentUntilCheckPoint3;\n            WITHDRAW_EXPAND_ABOVE_CHECKPOINT3 = withdrawCheckPoints_.expandPercentAboveCheckPoint3;\n        }\n\n        // set borrow limit values\n        if (borrowToken_ == address(0)) {\n            _LIQUDITY_PROTOCOL_BORROW_SLOT = bytes32(0);\n        } else {\n            _validateLimitCheckPoints(borrowCheckPoints_);\n\n            _LIQUDITY_PROTOCOL_BORROW_SLOT = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n                protocol_,\n                borrowToken_\n            );\n            _LIQUDITY_BORROW_TOKEN_EXCHANGE_PRICES_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n                borrowToken_\n            );\n\n            BORROW_CHECKPOINT1 = borrowCheckPoints_.tvlCheckPoint1;\n            BORROW_CHECKPOINT2 = borrowCheckPoints_.tvlCheckPoint2;\n            BORROW_CHECKPOINT3 = borrowCheckPoints_.tvlCheckPoint3;\n            BORROW_EXPAND_UNTIL_CHECKPOINT1 = borrowCheckPoints_.expandPercentUntilCheckPoint1;\n            BORROW_EXPAND_UNTIL_CHECKPOINT2 = borrowCheckPoints_.expandPercentUntilCheckPoint2;\n            BORROW_EXPAND_UNTIL_CHECKPOINT3 = borrowCheckPoints_.expandPercentUntilCheckPoint3;\n            BORROW_EXPAND_ABOVE_CHECKPOINT3 = borrowCheckPoints_.expandPercentAboveCheckPoint3;\n        }\n    }\n\n    /// @notice returns `PROTOCOL` total supply at Liquidity\n    function getProtocolSupplyData()\n        public\n        view\n        returns (uint256 supply_, uint256 oldExpandPercent_, uint256 userSupplyData_)\n    {\n        if (_LIQUDITY_PROTOCOL_SUPPLY_SLOT == bytes32(0)) {\n            revert FluidConfigError(ErrorTypes.ExpandPercentConfigHandler__SlotDoesNotExist);\n        }\n        userSupplyData_ = LIQUIDITY.readFromStorage(_LIQUDITY_PROTOCOL_SUPPLY_SLOT); // total storage slot\n\n        oldExpandPercent_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n\n        // get supply in raw converted from BigNumber\n        supply_ = BigMathMinified.fromBigNumber(\n            (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64,\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        );\n\n        if (userSupplyData_ & 1 == 1) {\n            uint256 exchangePrice_ = ((LIQUIDITY.readFromStorage(_LIQUDITY_WITHDRAW_TOKEN_EXCHANGE_PRICES_SLOT) >>\n                LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) & X64);\n\n            supply_ = (supply_ * exchangePrice_) / 1e12; // convert raw to normal amount\n        }\n    }\n\n    /// @notice returns `PROTOCOL` total borrow at Liquidity\n    function getProtocolBorrowData()\n        public\n        view\n        returns (uint256 borrow_, uint256 oldExpandPercent_, uint256 userBorrowData_)\n    {\n        if (_LIQUDITY_PROTOCOL_BORROW_SLOT == bytes32(0)) {\n            revert FluidConfigError(ErrorTypes.ExpandPercentConfigHandler__SlotDoesNotExist);\n        }\n        userBorrowData_ = LIQUIDITY.readFromStorage(_LIQUDITY_PROTOCOL_BORROW_SLOT); // total storage slot\n\n        oldExpandPercent_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        // get borrow in raw converted from BigNumber\n        borrow_ = BigMathMinified.fromBigNumber(\n            (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64,\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        );\n\n        if (userBorrowData_ & 1 == 1) {\n            uint256 exchangePrice_ = ((LIQUIDITY.readFromStorage(_LIQUDITY_BORROW_TOKEN_EXCHANGE_PRICES_SLOT) >>\n                LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) & X64);\n\n            borrow_ = (borrow_ * exchangePrice_) / 1e12; // convert raw to normal amount\n        }\n    }\n\n    /// @notice Rebalances the configs for `PROTOCOL` at Fluid Liquidity based on protocol total supply & total borrow.\n    /// Emits `LogUpdateWithdrawLimitExpansion` or `LogUpdateBorrowLimitExpansion` if any update is executed.\n    /// Reverts if no update is needed.\n    /// Can only be called by an authorized rebalancer.\n    function rebalance() external onlyRebalancer {\n        bool anyUpdateDone_;\n        if (WITHDRAW_TOKEN != address(0)) {\n            // check update withdrawal limits based on protocol supply\n            anyUpdateDone_ = _updateWithdrawLimits();\n        }\n\n        if (BORROW_TOKEN != address(0)) {\n            // check update borrow limits based on protocol borrow\n            anyUpdateDone_ = _updateBorrowLimits() || anyUpdateDone_;\n        }\n\n        if (!anyUpdateDone_) {\n            revert FluidConfigError(ErrorTypes.ExpandPercentConfigHandler__NoUpdate);\n        }\n    }\n\n    /***********************************|\n    |            INTERNALS              | \n    |__________________________________*/\n\n    function _updateWithdrawLimits() internal returns (bool updated_) {\n        (uint256 supply_, uint256 oldExpandPercent_, uint256 userSupplyData_) = getProtocolSupplyData();\n\n        // get current expand percent for supply_\n        uint256 newExpandPercent_;\n        if (supply_ < WITHDRAW_CHECKPOINT1) {\n            newExpandPercent_ = WITHDRAW_EXPAND_UNTIL_CHECKPOINT1;\n        } else if (supply_ < WITHDRAW_CHECKPOINT2) {\n            newExpandPercent_ = WITHDRAW_EXPAND_UNTIL_CHECKPOINT2;\n        } else if (supply_ < WITHDRAW_CHECKPOINT3) {\n            newExpandPercent_ = WITHDRAW_EXPAND_UNTIL_CHECKPOINT3;\n        } else {\n            newExpandPercent_ = WITHDRAW_EXPAND_ABOVE_CHECKPOINT3;\n        }\n\n        // check if not already set to that value\n        if (oldExpandPercent_ == newExpandPercent_) {\n            return false;\n        }\n\n        // execute update at Liquidity\n        AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_ = new AdminModuleStructs.UserSupplyConfig[](1);\n        userSupplyConfigs_[0] = AdminModuleStructs.UserSupplyConfig({\n            user: PROTOCOL,\n            token: WITHDRAW_TOKEN,\n            mode: uint8(userSupplyData_ & 1), // first bit\n            expandPercent: newExpandPercent_,\n            expandDuration: (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24, // set same as old\n            baseWithdrawalLimit: BigMathMinified.fromBigNumber(\n                (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            ) // set same as old\n        });\n        LIQUIDITY.updateUserSupplyConfigs(userSupplyConfigs_);\n\n        emit LogUpdateWithdrawLimitExpansion(supply_, oldExpandPercent_, newExpandPercent_);\n\n        return true;\n    }\n\n    function _updateBorrowLimits() internal returns (bool updated_) {\n        (uint256 borrow_, uint256 oldExpandPercent_, uint256 userBorrowData_) = getProtocolBorrowData();\n\n        // get current expand percent for borrow_\n        uint256 newExpandPercent_;\n        if (borrow_ < BORROW_CHECKPOINT1) {\n            newExpandPercent_ = BORROW_EXPAND_UNTIL_CHECKPOINT1;\n        } else if (borrow_ < BORROW_CHECKPOINT2) {\n            newExpandPercent_ = BORROW_EXPAND_UNTIL_CHECKPOINT2;\n        } else if (borrow_ < BORROW_CHECKPOINT3) {\n            newExpandPercent_ = BORROW_EXPAND_UNTIL_CHECKPOINT3;\n        } else {\n            newExpandPercent_ = BORROW_EXPAND_ABOVE_CHECKPOINT3;\n        }\n\n        // check if not already set to that value\n        if (oldExpandPercent_ == newExpandPercent_) {\n            return false;\n        }\n\n        // execute update at Liquidity\n        AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_ = new AdminModuleStructs.UserBorrowConfig[](1);\n        userBorrowConfigs_[0] = AdminModuleStructs.UserBorrowConfig({\n            user: PROTOCOL,\n            token: BORROW_TOKEN,\n            mode: uint8(userBorrowData_ & 1), // first bit\n            expandPercent: newExpandPercent_,\n            expandDuration: (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24, // set same as old\n            baseDebtCeiling: BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            ), // set same as old\n            maxDebtCeiling: BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            ) // set same as old\n        });\n        LIQUIDITY.updateUserBorrowConfigs(userBorrowConfigs_);\n\n        emit LogUpdateBorrowLimitExpansion(borrow_, oldExpandPercent_, newExpandPercent_);\n\n        return true;\n    }\n\n    function _validateLimitCheckPoints(LimitCheckPoints memory checkPoints_) internal pure {\n        if (\n            checkPoints_.tvlCheckPoint1 == 0 ||\n            checkPoints_.expandPercentUntilCheckPoint1 == 0 ||\n            checkPoints_.tvlCheckPoint2 == 0 ||\n            checkPoints_.expandPercentUntilCheckPoint2 == 0 ||\n            checkPoints_.tvlCheckPoint3 == 0 ||\n            checkPoints_.expandPercentUntilCheckPoint3 == 0 ||\n            checkPoints_.expandPercentAboveCheckPoint3 == 0\n        ) {\n            revert FluidConfigError(ErrorTypes.ExpandPercentConfigHandler__InvalidParams);\n        }\n    }\n}\n"
    },
    "contracts/config/limitsAuth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { Structs as AdminModuleStructs } from \"../../liquidity/adminModule/structs.sol\";\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\n\nabstract contract Events {\n    /// @notice emitted when multisig successfully changes the withdrawal limit\n    event LogSetWithdrawalLimit(address user, address token, uint256 newLimit);\n\n    /// @notice emitted when multisig changes the withdrawal limit config\n    event LogSetUserWithdrawLimit(address user, address token, uint256 baseLimit);\n\n    /// @notice emitted when multisig changes the borrow limit config\n    event LogSetUserBorrowLimits(address user, address token, uint256 baseLimit, uint256 maxLimit);\n}\n\nabstract contract Constants {\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    /// @dev This represents 20%.\n    uint256 internal constant MAX_PERCENT_CHANGE = 20;\n\n    IFluidLiquidity public immutable LIQUIDITY;\n    /// @notice Team multisigs allowed to trigger methods\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n    address public constant TEAM_MULTISIG2 = 0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\n\n    uint256 internal constant COOLDOWN_PERIOD = 4 days;\n}\n\nabstract contract Variables is Constants {\n    // user => token => lastUpdateTime for cooldown checks\n    mapping(address => mapping(address => uint256)) public lastUpdateTime;\n}\n\ncontract FluidLimitsAuth is Variables, Events, Error {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__InvalidParams);\n        }\n        _;\n    }\n\n    modifier onlyMultisig() {\n        if (TEAM_MULTISIG != msg.sender && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(address liquidity_) validAddress(liquidity_) {\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n    }\n\n    /// @notice Sets the withdrawal limit for a specific token of a user in the liquidity\n    /// @dev This function can only be called by team multisig\n    /// @param user_ The address of the user for which to set the withdrawal limit\n    /// @param token_ The address of the token for which to set the withdrawal limit\n    /// @param newLimit_ The new withdrawal limit to be set\n    function setWithdrawalLimit(address user_, address token_, uint256 newLimit_) external onlyMultisig {\n        LIQUIDITY.updateUserWithdrawalLimit(user_, token_, newLimit_);\n        emit LogSetWithdrawalLimit(user_, token_, newLimit_);\n    }\n\n    /// @notice sets withdraw base limit without restrictions. Can only be called by team multisig.\n    /// @param user_ The address of the user for which to set the user withdraw limit\n    /// @param token_ The address of the token for which to set the user withdraw limit\n    /// @param baseLimit_ The base limit for the user supply. Set to 0 to keep current value.\n    /// @param skipMaxPercentChangeCheck_ allow full range of limit check. Keep to false by default to have additional human error check.\n    function setUserWithdrawLimit(\n        address user_,\n        address token_,\n        uint256 baseLimit_,\n        bool skipMaxPercentChangeCheck_\n    ) external onlyMultisig {\n        if (baseLimit_ == 0) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__InvalidParams);\n        }\n\n        AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs = new AdminModuleStructs.UserSupplyConfig[](1);\n        userSupplyConfigs[0] = getUserSupplyConfig(user_, token_);\n\n        if (userSupplyConfigs[0].user == address(0)) {\n            // user is not defined yet\n            revert FluidConfigError(ErrorTypes.LimitsAuth__UserNotDefinedYet);\n        }\n\n        if (!skipMaxPercentChangeCheck_) {\n            _validateWithinMaxPercentChange(userSupplyConfigs[0].baseWithdrawalLimit, baseLimit_);\n        }\n\n        userSupplyConfigs[0].baseWithdrawalLimit = baseLimit_;\n\n        LIQUIDITY.updateUserSupplyConfigs(userSupplyConfigs);\n\n        emit LogSetUserWithdrawLimit(user_, token_, userSupplyConfigs[0].baseWithdrawalLimit);\n    }\n\n    /// @notice Sets the user borrow limits for a specific token of a user, with time and max percent change restrictions.\n    ///         Can only be called by team multisig.\n    /// @dev This function can only be called by team multisig\n    /// @param user_ The address of the user for which to set the user borrow limit\n    /// @param token_ The address of the token for which to set the user borrow limit\n    /// @param baseLimit_ The base limit for the user borrow. Set to 0 to keep current value.\n    /// @param maxLimit_ The max limit for the user borrow. Set to 0 to keep current value.\n    function setUserBorrowLimits(\n        address user_,\n        address token_,\n        uint256 baseLimit_,\n        uint256 maxLimit_\n    ) external onlyMultisig {\n        if (baseLimit_ == 0 && maxLimit_ == 0) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__InvalidParams);\n        }\n\n        AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs = new AdminModuleStructs.UserBorrowConfig[](1);\n        userBorrowConfigs[0] = getUserBorrowConfig(user_, token_);\n\n        if (userBorrowConfigs[0].user == address(0)) {\n            // user is not defined yet\n            revert FluidConfigError(ErrorTypes.LimitsAuth__UserNotDefinedYet);\n        }\n\n        _validateLastUpdateTime(lastUpdateTime[user_][token_]);\n\n        if (baseLimit_ != 0) {\n            _validateWithinMaxPercentChange(userBorrowConfigs[0].baseDebtCeiling, baseLimit_);\n            userBorrowConfigs[0].baseDebtCeiling = baseLimit_;\n        }\n\n        if (maxLimit_ != 0) {\n            _validateWithinMaxPercentChange(userBorrowConfigs[0].maxDebtCeiling, maxLimit_);\n            userBorrowConfigs[0].maxDebtCeiling = maxLimit_;\n        }\n\n        lastUpdateTime[user_][token_] = block.timestamp;\n\n        LIQUIDITY.updateUserBorrowConfigs(userBorrowConfigs);\n\n        emit LogSetUserBorrowLimits(\n            user_,\n            token_,\n            userBorrowConfigs[0].baseDebtCeiling,\n            userBorrowConfigs[0].maxDebtCeiling\n        );\n    }\n\n    /// @notice Returns the user supply config for a given user and token.\n    function getUserSupplyConfig(\n        address user_,\n        address token_\n    ) public view returns (AdminModuleStructs.UserSupplyConfig memory userSupplyConfigs_) {\n        uint256 userSupply_ = LIQUIDITY.readFromStorage(\n            LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n                user_,\n                token_\n            )\n        );\n\n        if (userSupply_ > 0) {\n            userSupplyConfigs_ = AdminModuleStructs.UserSupplyConfig({\n                user: user_,\n                token: token_,\n                mode: uint8(userSupply_ & 1),\n                baseWithdrawalLimit: BigMathMinified.fromBigNumber(\n                    (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18,\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                ),\n                expandPercent: (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14,\n                expandDuration: (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24\n            });\n        }\n    }\n\n    /// @notice Returns the user borrow config for a given user and token.\n    function getUserBorrowConfig(\n        address user_,\n        address token_\n    ) public view returns (AdminModuleStructs.UserBorrowConfig memory userBorrowConfigs_) {\n        uint256 userBorrow_ = LIQUIDITY.readFromStorage(\n            LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n                user_,\n                token_\n            )\n        );\n\n        if (userBorrow_ > 0) {\n            userBorrowConfigs_ = AdminModuleStructs.UserBorrowConfig({\n                user: user_,\n                token: token_,\n                mode: uint8(userBorrow_ & 1),\n                baseDebtCeiling: BigMathMinified.fromBigNumber(\n                    (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18,\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                ),\n                maxDebtCeiling: BigMathMinified.fromBigNumber(\n                    (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18,\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                ),\n                expandPercent: (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14,\n                expandDuration: (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24\n            });\n        }\n    }\n\n    /// @dev Validates that the new limit is within the allowed max percent change.\n    function _validateWithinMaxPercentChange(uint256 oldLimit_, uint256 newLimit_) internal pure {\n        uint256 maxDelta = (oldLimit_ * MAX_PERCENT_CHANGE) / 100; // 20% of oldLimit_\n\n        if (newLimit_ > oldLimit_ && (newLimit_ - oldLimit_) > maxDelta) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__ExceedAllowedPercentageChange);\n        } else if (newLimit_ < oldLimit_ && (oldLimit_ - newLimit_) > maxDelta) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__ExceedAllowedPercentageChange);\n        }\n    }\n\n    /// @dev Validates that the cooldown period has passed since the last update.\n    function _validateLastUpdateTime(uint256 lastUpdateTime_) internal view {\n        if (block.timestamp - lastUpdateTime_ < COOLDOWN_PERIOD) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__CoolDownPending);\n        }\n    }\n}\n"
    },
    "contracts/config/limitsAuthDex/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { DexSlotsLink } from \"../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../libraries/dexCalcs.sol\";\nimport { IFluidDexT1 } from \"../../protocols/dex/interfaces/iDexT1.sol\";\nimport { Structs as AdminModuleStructs } from \"../../protocols/dex/poolT1/adminModule/structs.sol\";\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\ninterface IFluidDexT1Admin {\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\n\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\n\n    function updateMaxBorrowShares(uint maxBorrowShares_) external;\n\n    function updateMaxSupplyShares(uint maxSupplyShares_) external;\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, uint256 newLimit_) external;\n}\n\nabstract contract Events {\n    /// @notice emitted when multisig successfully changes the withdrawal limit\n    event LogSetWithdrawalLimit(address dex, address user, uint256 newLimit);\n\n    /// @notice emitted when multisig changes the withdrawal limit config\n    event LogSetUserWithdrawLimit(address dex, address user, uint256 baseLimit);\n\n    /// @notice emitted when multisig changes the borrow limit config\n    event LogSetUserBorrowLimits(address dex, address user, uint256 baseLimit, uint256 maxLimit);\n\n    /// @notice emitted when multisig changes the max borrow shares\n    event LogSetMaxBorrowShares(address dex, uint256 maxBorrowShares);\n\n    /// @notice emitted when multisig changes the max supply shares\n    event LogSetMaxSupplyShares(address dex, uint256 maxSupplyShares);\n}\n\nabstract contract Constants {\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    /// @dev Set this to 20 for a +/-20% limit\n    uint256 internal constant MAX_PERCENT_CHANGE = 20;\n\n    /// @notice Team multisigs allowed to trigger methods\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n    address public constant TEAM_MULTISIG2 = 0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\n\n    uint256 internal constant COOLDOWN_PERIOD = 4 days;\n}\n\nabstract contract Variables is Constants {\n    // dex => user => lastUpdateTime for cooldown checks\n    mapping(address => mapping(address => uint256)) public lastUpdateTime;\n}\n\ncontract FluidLimitsAuthDex is Variables, Error, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__InvalidParams);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is the team multisig\n    modifier onlyMultisig() {\n        if (TEAM_MULTISIG != msg.sender && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__Unauthorized);\n        }\n        _;\n    }\n\n    /// @notice Sets the withdrawal limit for a specific user at a dex\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex\n    /// @param user_ The address of the user for which to set the withdrawal limit\n    /// @param newLimit_ The new withdrawal limit to be set\n    function setWithdrawalLimit(address dex_, address user_, uint256 newLimit_) external onlyMultisig {\n        IFluidDexT1Admin(dex_).updateUserWithdrawalLimit(user_, newLimit_);\n        emit LogSetWithdrawalLimit(dex_, user_, newLimit_);\n    }\n\n    /// @notice Sets the user withdraw base limit at a specific dex for a user (vault) without restrictions. Can only be called by team multisig.\n    /// @param dex_ The address of the dex at which to set the user withdraw limit\n    /// @param user_ The address of the user for which to set the user withdraw limit\n    /// @param baseLimit_ The base limit for the user supply. Set to 0 to keep current value.\n    /// @param skipMaxPercentChangeCheck_ allow full range of limit check. Keep to false by default to have additional human error check.\n    function setUserWithdrawLimit(\n        address dex_,\n        address user_,\n        uint256 baseLimit_,\n        bool skipMaxPercentChangeCheck_\n    ) external onlyMultisig {\n        if (baseLimit_ == 0) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__InvalidParams);\n        }\n\n        AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs = new AdminModuleStructs.UserSupplyConfig[](1);\n        userSupplyConfigs[0] = getUserSupplyConfig(dex_, user_);\n\n        if (userSupplyConfigs[0].user == address(0)) {\n            // user is not defined yet\n            revert FluidConfigError(ErrorTypes.LimitsAuth__UserNotDefinedYet);\n        }\n\n        if (!skipMaxPercentChangeCheck_) {\n            _validateWithinMaxPercentChange(userSupplyConfigs[0].baseWithdrawalLimit, baseLimit_);\n        }\n\n        userSupplyConfigs[0].baseWithdrawalLimit = baseLimit_;\n\n        IFluidDexT1Admin(dex_).updateUserSupplyConfigs(userSupplyConfigs);\n\n        emit LogSetUserWithdrawLimit(dex_, user_, userSupplyConfigs[0].baseWithdrawalLimit);\n    }\n\n    /// @notice Sets the user borrow limits at a specific dex for a user (vault), with time and max percent change restrictions.\n    ///         Can only be called by team multisig.\n    /// @param dex_ The address of the dex at which to set the user borrow limit\n    /// @param user_ The address of the user for which to set the user borrow limit\n    /// @param baseLimit_ The base limit for the user borrow. Set to 0 to keep current value.\n    /// @param maxLimit_ The max limit for the user borrow. Set to 0 to keep current value.\n    function setUserBorrowLimits(\n        address dex_,\n        address user_,\n        uint256 baseLimit_,\n        uint256 maxLimit_\n    ) external onlyMultisig {\n        if (baseLimit_ == 0 && maxLimit_ == 0) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__InvalidParams);\n        }\n\n        AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs = new AdminModuleStructs.UserBorrowConfig[](1);\n        userBorrowConfigs[0] = getUserBorrowConfig(dex_, user_);\n\n        if (userBorrowConfigs[0].user == address(0)) {\n            // user is not defined yet\n            revert FluidConfigError(ErrorTypes.LimitsAuth__UserNotDefinedYet);\n        }\n\n        _validateLastUpdateTime(lastUpdateTime[dex_][user_]);\n\n        if (baseLimit_ != 0) {\n            _validateWithinMaxPercentChange(userBorrowConfigs[0].baseDebtCeiling, baseLimit_);\n            userBorrowConfigs[0].baseDebtCeiling = baseLimit_;\n        }\n\n        if (maxLimit_ != 0) {\n            _validateWithinMaxPercentChange(userBorrowConfigs[0].maxDebtCeiling, maxLimit_);\n            userBorrowConfigs[0].maxDebtCeiling = maxLimit_;\n        }\n\n        lastUpdateTime[dex_][user_] = block.timestamp;\n\n        IFluidDexT1Admin(dex_).updateUserBorrowConfigs(userBorrowConfigs);\n\n        emit LogSetUserBorrowLimits(\n            dex_,\n            user_,\n            userBorrowConfigs[0].baseDebtCeiling,\n            userBorrowConfigs[0].maxDebtCeiling\n        );\n    }\n\n    /// @notice Sets the max borrow shares of a DEX. To update max supply and max borrow shares at once within same coolDown, use setMaxShares.\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex at which to set the max borrow shares\n    /// @param maxBorrowShares_ The max borrow shares.\n    /// @param confirmLiquidityLimitsCoverCap_  Reminder to manually confirm that the limits for the dex at liquidity layer cover the cap.\n    function setMaxBorrowShares(\n        address dex_,\n        uint256 maxBorrowShares_,\n        bool confirmLiquidityLimitsCoverCap_\n    ) external onlyMultisig {\n        _validateSetDexShares(dex_, confirmLiquidityLimitsCoverCap_);\n        _setMaxBorrowShares(dex_, maxBorrowShares_);\n    }\n\n    /// @notice Sets the max supply shares of a DEX. To update max supply and max borrow shares at once within same coolDown, use setMaxShares.\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex at which to set the max supply shares\n    /// @param maxSupplyShares_ The max supply shares.\n    /// @param confirmLiquidityLimitsCoverCap_  Reminder to manually confirm that the limits for the dex at liquidity layer cover the cap.\n    function setMaxSupplyShares(\n        address dex_,\n        uint256 maxSupplyShares_,\n        bool confirmLiquidityLimitsCoverCap_\n    ) external onlyMultisig {\n        _validateSetDexShares(dex_, confirmLiquidityLimitsCoverCap_);\n        _setMaxSupplyShares(dex_, maxSupplyShares_);\n    }\n\n    /// @notice Sets both max borrow shares and max supply shares of a DEX at once.\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex at which to set the max shares\n    /// @param maxSupplyShares_ The max supply shares.\n    /// @param maxBorrowShares_ The max borrow shares.\n    /// @param confirmLiquidityLimitsCoverCap_  Reminder to manually confirm that the limits for the dex at liquidity layer cover the cap.\n    function setMaxShares(\n        address dex_,\n        uint256 maxSupplyShares_,\n        uint256 maxBorrowShares_,\n        bool confirmLiquidityLimitsCoverCap_\n    ) external onlyMultisig {\n        _validateSetDexShares(dex_, confirmLiquidityLimitsCoverCap_);\n        _setMaxSupplyShares(dex_, maxSupplyShares_);\n        _setMaxBorrowShares(dex_, maxBorrowShares_);\n    }\n\n    ////////////////////////////////// INTERNAL HELPERS ////////////////////////////////////////////////////////\n\n    /// @dev Validates parameters for setting DEX shares.\n    function _validateSetDexShares(address dex_, bool confirmLiquidityLimitsCoverCap_) internal {\n        if (!confirmLiquidityLimitsCoverCap_) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__InvalidParams);\n        }\n\n        _validateLastUpdateTime(lastUpdateTime[dex_][dex_]);\n        lastUpdateTime[dex_][dex_] = block.timestamp;\n    }\n\n    /// @dev Sets the max borrow shares for a DEX.\n    function _setMaxBorrowShares(address dex_, uint256 maxBorrowShares_) internal {\n        uint256 currentMaxBorrowShares_ = getMaxBorrowShares(dex_);\n        _validateWithinMaxPercentChange(currentMaxBorrowShares_, maxBorrowShares_);\n\n        IFluidDexT1Admin(dex_).updateMaxBorrowShares(maxBorrowShares_);\n\n        emit LogSetMaxBorrowShares(dex_, maxBorrowShares_);\n    }\n\n    /// @dev Sets the max supply shares for a DEX.\n    function _setMaxSupplyShares(address dex_, uint256 maxSupplyShares_) internal {\n        uint256 currentMaxSupplyShares_ = getMaxSupplyShares(dex_);\n        _validateWithinMaxPercentChange(currentMaxSupplyShares_, maxSupplyShares_);\n\n        IFluidDexT1Admin(dex_).updateMaxSupplyShares(maxSupplyShares_);\n\n        emit LogSetMaxSupplyShares(dex_, maxSupplyShares_);\n    }\n\n    /// @dev Validates that the new limit is within the allowed max percent change.\n    function _validateWithinMaxPercentChange(uint256 oldLimit_, uint256 newLimit_) internal pure {\n        uint256 maxDelta = (oldLimit_ * MAX_PERCENT_CHANGE) / 100; // 20% of oldLimit_\n\n        if (newLimit_ > oldLimit_ && (newLimit_ - oldLimit_) > maxDelta) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__ExceedAllowedPercentageChange);\n        } else if (newLimit_ < oldLimit_ && (oldLimit_ - newLimit_) > maxDelta) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__ExceedAllowedPercentageChange);\n        }\n    }\n\n    /// @dev Validates that the cooldown period has passed since the last update.\n    function _validateLastUpdateTime(uint256 lastUpdateTime_) internal view {\n        if (block.timestamp - lastUpdateTime_ < COOLDOWN_PERIOD) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__CoolDownPending);\n        }\n    }\n\n    ////////////////////////////////// GETTERS ////////////////////////////////////////////////////////\n\n    /// @notice Get the max borrow shares of a DEX\n    /// @param dex_ The address of the DEX\n    /// @return The max borrow shares\n    function getMaxBorrowShares(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_TOTAL_BORROW_SHARES_SLOT)) >> 128;\n    }\n\n    /// @notice Get the max supply shares of a DEX\n    /// @param dex_ The address of the DEX\n    /// @return The max supply shares\n    function getMaxSupplyShares(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_TOTAL_SUPPLY_SHARES_SLOT)) >> 128;\n    }\n\n    /// @notice Returns the user supply config for a given dex and user.\n    function getUserSupplyConfig(\n        address dex_,\n        address user_\n    ) public view returns (AdminModuleStructs.UserSupplyConfig memory userSupplyConfigs_) {\n        uint256 userSupply_ = IFluidDexT1(dex_).readFromStorage(\n            DexSlotsLink.calculateMappingStorageSlot(DexSlotsLink.DEX_USER_SUPPLY_MAPPING_SLOT, user_)\n        );\n\n        if (userSupply_ > 0) {\n            userSupplyConfigs_ = AdminModuleStructs.UserSupplyConfig({\n                user: user_,\n                baseWithdrawalLimit: BigMathMinified.fromBigNumber(\n                    (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18,\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                ),\n                expandPercent: (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14,\n                expandDuration: (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24\n            });\n        }\n    }\n\n    /// @notice Returns the user borrow config for a given dex and user.\n    function getUserBorrowConfig(\n        address dex_,\n        address user_\n    ) public view returns (AdminModuleStructs.UserBorrowConfig memory userBorrowConfigs_) {\n        uint256 userBorrow_ = IFluidDexT1(dex_).readFromStorage(\n            DexSlotsLink.calculateMappingStorageSlot(DexSlotsLink.DEX_USER_BORROW_MAPPING_SLOT, user_)\n        );\n\n        if (userBorrow_ > 0) {\n            userBorrowConfigs_ = AdminModuleStructs.UserBorrowConfig({\n                user: user_,\n                baseDebtCeiling: BigMathMinified.fromBigNumber(\n                    (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18,\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                ),\n                maxDebtCeiling: BigMathMinified.fromBigNumber(\n                    (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18,\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                ),\n                expandPercent: (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14,\n                expandDuration: (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24\n            });\n        }\n    }\n}\n"
    },
    "contracts/config/liquidityTokenAuth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Structs as AdminModuleStructs } from \"../../liquidity/adminModule/structs.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\n\nabstract contract Constants {\n    /// @notice Fluid liquidity address\n    IFluidLiquidity public immutable LIQUIDITY;\n\n    /// @notice Team multisig allowed to trigger collecting revenue\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n    address public constant TEAM_MULTISIG2 = 0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\n\n    /// @notice reserve contract for fetching allowed rebalancers\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n\n    uint256 internal constant FOUR_DECIMALS = 10000;\n    uint256 internal constant X14 = 0x3fff;\n}\n\nabstract contract Events {\n    /// @notice emitted when RateDataV2Params is initiated\n    event LogInitiateRateDateV2Params(address token);\n\n    /// @notice emitted when TokenConfig is initiated\n    event LogInitiateTokenConfig(address token);\n\n    /// @notice emitted when the reserve factor for a token is updated\n    event LogUpdateReserveFactor(address token, uint256 oldReserveFactor, uint256 newReserveFactor);\n}\n\n/// @notice Initializes a token at Liquidity Layer if token is not already initialized and update token reserve factor\ncontract FluidLiquidityTokenAuth is Constants, Error, Events {\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract) or team multisig\n    modifier onlyRebalancerOrMultisig() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender) && msg.sender != TEAM_MULTISIG && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.LiquidityTokenAuth__Unauthorized);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract) or team multisig\n    modifier onlyMultisig() {\n        if (msg.sender != TEAM_MULTISIG && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.LiquidityTokenAuth__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(address liquidity_, IFluidReserveContract reserveContract_) {\n        if (liquidity_ == address(0) || address(reserveContract_) == address(0)) {\n            revert FluidConfigError(ErrorTypes.LiquidityTokenAuth__InvalidParams);\n        }\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        RESERVE_CONTRACT = reserveContract_;\n    }\n\n    /// @notice Initializes rateDataV2 for a token at Liquidity Layer if token is not initialized and sets default token config\n    function listToken(address token_) external onlyRebalancerOrMultisig {\n        _initializeRateDataV2(token_);\n        _initializeTokenConfig(token_);\n    }\n\n    /// @notice Updates the reserve factor for a token at Liquidity Layer\n    /// @param token_ The address of the token to update\n    /// @param newReserveFactor_ The new reserve factor to set (in 1e2: 100% = 10_000; 1% = 100)\n    function updateReserveFactor(address token_, uint256 newReserveFactor_) external onlyMultisig {\n        uint256 exchangePricesAndConfig_ = LIQUIDITY.readFromStorage(\n            LiquiditySlotsLink.calculateMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n                token_\n            )\n        );\n        if (exchangePricesAndConfig_ == 0) {\n            revert FluidConfigError(ErrorTypes.LiquidityTokenAuth__InvalidParams);\n        }\n\n        /// Next  14 bits =>  44- 57 => update on storage threshold (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n        uint256 storageUpdateThreshold_ = (exchangePricesAndConfig_ >>\n            LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD) & X14;\n\n        /// First 14 bits =>   0- 13 => max allowed utilization (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n        uint256 maxUtilization_ = FOUR_DECIMALS;\n\n        /// Next  14 bits =>  16- 29 => fee on interest from borrowers to lenders (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n        uint256 oldReserveFactor_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14;\n\n        if ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_USES_CONFIGS2) & 1 == 1) {\n            uint256 configs2_ = LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_CONFIGS2_MAPPING_SLOT,\n                    token_\n                )\n            );\n            maxUtilization_ = configs2_ & X14;\n        }\n\n        AdminModuleStructs.TokenConfig[] memory tokenConfigs_ = new AdminModuleStructs.TokenConfig[](1);\n        tokenConfigs_[0] = AdminModuleStructs.TokenConfig({\n            token: token_,\n            fee: newReserveFactor_,\n            threshold: storageUpdateThreshold_,\n            maxUtilization: maxUtilization_\n        });\n\n        LIQUIDITY.updateTokenConfigs(tokenConfigs_);\n\n        emit LogUpdateReserveFactor(token_, oldReserveFactor_, newReserveFactor_);\n    }\n\n    /// @notice Initializes rateDataV2 for a token at Liquidity Layer if token is not initialized\n    function _initializeRateDataV2(address token_) internal {\n        bytes32 borrowRateDataSlot = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_RATE_DATA_MAPPING_SLOT,\n            token_\n        );\n        uint256 rateConfig_ = LIQUIDITY.readFromStorage(borrowRateDataSlot);\n        if (rateConfig_ > 0) {\n            revert FluidConfigError(ErrorTypes.LiquidityTokenAuth_AlreadyInitialized);\n        }\n\n        AdminModuleStructs.RateDataV2Params[] memory params_ = new AdminModuleStructs.RateDataV2Params[](1);\n        params_[0] = AdminModuleStructs.RateDataV2Params({\n            token: token_,\n            kink1: 5000,\n            kink2: 8000,\n            rateAtUtilizationZero: 0,\n            rateAtUtilizationKink1: 2000,\n            rateAtUtilizationKink2: 4000,\n            rateAtUtilizationMax: 10000\n        });\n        LIQUIDITY.updateRateDataV2s(params_);\n\n        emit LogInitiateRateDateV2Params(token_);\n    }\n\n    /// @notice Initializes token at Liquidity Layer if not already initialized\n    function _initializeTokenConfig(address token_) internal {\n        uint256 exchangePricesAndConfig_ = LIQUIDITY.readFromStorage(\n            LiquiditySlotsLink.calculateMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n                token_\n            )\n        );\n\n        if (exchangePricesAndConfig_ > 0) {\n            revert FluidConfigError(ErrorTypes.LiquidityTokenAuth_AlreadyInitialized);\n        }\n\n        AdminModuleStructs.TokenConfig[] memory tokenConfigs_ = new AdminModuleStructs.TokenConfig[](1);\n        tokenConfigs_[0] = AdminModuleStructs.TokenConfig({\n            token: token_,\n            fee: 1000,\n            threshold: 30,\n            maxUtilization: 10000\n        });\n\n        LIQUIDITY.updateTokenConfigs(tokenConfigs_);\n\n        emit LogInitiateTokenConfig(token_);\n    }\n}\n"
    },
    "contracts/config/maxBorrowHandler/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { IFluidLiquidityResolver } from \"../../periphery/resolvers/liquidity/iLiquidityResolver.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { LiquidityCalcs } from \"../../libraries/liquidityCalcs.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { Structs as AdminModuleStructs } from \"../../liquidity/adminModule/structs.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nabstract contract Constants {\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n    IFluidLiquidity public immutable LIQUIDITY;\n    IFluidLiquidityResolver public immutable LIQUIDITY_RESOLVER;\n    address public immutable PROTOCOL;\n    address public immutable BORROW_TOKEN;\n\n    /// @dev max utilization of total supply that will be set as max borrow limit. In percent (100 = 1%, 1 = 0.01%)\n    uint256 public immutable MAX_UTILIZATION;\n\n    /// @dev minimum percent difference to trigger an update. In percent (100 = 1%, 1 = 0.01%)\n    uint256 public immutable MIN_UPDATE_DIFF;\n\n    bytes32 internal immutable _LIQUDITY_PROTOCOL_BORROW_SLOT;\n\n    uint256 internal constant MAX_UTILIZATION_PRECISION = 1e4;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xff;\n\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n}\n\nabstract contract Events {\n    /// @notice emitted when borrow max limit is updated\n    event LogUpdateBorrowMaxDebtCeiling(\n        uint256 totalSupplyNormal,\n        uint256 oldMaxDebtCeilingRaw,\n        uint256 maxDebtCeilingRaw,\n        uint256 borrowExchangePrice\n    );\n}\n\n/// @notice Sets max borrow limit for a protocol on Liquidity based on utilization of total supply of the same borrow token\ncontract FluidMaxBorrowConfigHandler is Constants, Error, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.MaxBorrowConfigHandler__AddressZero);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract)\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.MaxBorrowConfigHandler__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(\n        IFluidReserveContract reserveContract_,\n        IFluidLiquidity liquidity_,\n        IFluidLiquidityResolver liquidityResolver_,\n        address protocol_,\n        address borrowToken_,\n        uint256 maxUtilization_,\n        uint256 minUpdateDiff_\n    )\n        validAddress(address(reserveContract_))\n        validAddress(address(liquidity_))\n        validAddress(address(liquidityResolver_))\n        validAddress(protocol_)\n        validAddress(borrowToken_)\n    {\n        RESERVE_CONTRACT = reserveContract_;\n        LIQUIDITY = liquidity_;\n        LIQUIDITY_RESOLVER = liquidityResolver_;\n        PROTOCOL = protocol_;\n        BORROW_TOKEN = borrowToken_;\n\n        if (maxUtilization_ > MAX_UTILIZATION_PRECISION || minUpdateDiff_ == 0) {\n            revert FluidConfigError(ErrorTypes.MaxBorrowConfigHandler__InvalidParams);\n        }\n\n        _LIQUDITY_PROTOCOL_BORROW_SLOT = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n            protocol_,\n            borrowToken_\n        );\n\n        MAX_UTILIZATION = maxUtilization_;\n        MIN_UPDATE_DIFF = minUpdateDiff_;\n    }\n\n    /// @notice returns `BORROW_TOKEN` total supply at Liquidity (in normal).\n    function getTotalSupply() public view returns (uint256 totalSupplyNormal_) {\n        (totalSupplyNormal_, ) = _getTotalSupply();\n    }\n\n    /// @notice returns the currently set max debt ceiling (in raw for mode with interest!).\n    function currentMaxDebtCeiling() public view returns (uint256 maxDebtCeiling_) {\n        return\n            BigMathMinified.fromBigNumber(\n                (LIQUIDITY.readFromStorage(_LIQUDITY_PROTOCOL_BORROW_SLOT) >>\n                    LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n    }\n\n    /// @notice returns the max debt ceiling that should be set according to current state (in normal).\n    function calcMaxDebtCeilingNormal() public view returns (uint256 maxDebtCeilingNormal_) {\n        (uint256 maxDebtCeilingRaw_, , uint256 borrowExchangePrice_, , ) = _calcMaxDebtCeiling();\n        // convert to normal\n        maxDebtCeilingNormal_ = (maxDebtCeilingRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION;\n    }\n\n    /// @notice returns the max debt ceiling that should be set according to current state (in raw for mode with interest!).\n    function calcMaxDebtCeiling() public view returns (uint256 maxDebtCeiling_) {\n        (maxDebtCeiling_, , , , ) = _calcMaxDebtCeiling();\n    }\n\n    /// @notice returns how much new config would be different from current config in percent (100 = 1%, 1 = 0.01%).\n    function configPercentDiff() public view returns (uint256 configPercentDiff_) {\n        (uint256 maxDebtCeilingRaw_, , , uint256 userBorrowData_, ) = _calcMaxDebtCeiling();\n\n        (configPercentDiff_, ) = _configPercentDiff(userBorrowData_, maxDebtCeilingRaw_);\n    }\n\n    /// @notice Rebalances the configs for `PROTOCOL` at Fluid Liquidity based on protocol total supply & total borrow.\n    /// Emits `LogUpdateBorrowMaxDebtCeiling` if update is executed.\n    /// Reverts if no update is needed.\n    /// Can only be called by an authorized rebalancer.\n    function rebalance() external onlyRebalancer {\n        if (!_updateBorrowLimits()) {\n            revert FluidConfigError(ErrorTypes.MaxBorrowConfigHandler__NoUpdate);\n        }\n    }\n\n    /***********************************|\n    |            INTERNALS              | \n    |__________________________________*/\n\n    function _getTotalSupply() internal view returns (uint256 totalSupplyNormal_, uint256 borrowExchangePrice_) {\n        uint256 supplyExchangePrice_;\n\n        (supplyExchangePrice_, borrowExchangePrice_) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY_RESOLVER.getExchangePricesAndConfig(BORROW_TOKEN)\n        );\n\n        totalSupplyNormal_ = LiquidityCalcs.getTotalSupply(\n            LIQUIDITY_RESOLVER.getTotalAmounts(BORROW_TOKEN),\n            supplyExchangePrice_\n        );\n    }\n\n    function _calcMaxDebtCeiling()\n        internal\n        view\n        returns (\n            uint256 maxDebtCeilingRaw_,\n            uint256 totalSupplyNormal_,\n            uint256 borrowExchangePrice_,\n            uint256 userBorrowData_,\n            uint256 baseDebtCeilingRaw_\n        )\n    {\n        (totalSupplyNormal_, borrowExchangePrice_) = _getTotalSupply();\n\n        uint256 maxDebtCeilingNormal_ = (MAX_UTILIZATION * totalSupplyNormal_) / MAX_UTILIZATION_PRECISION;\n\n        // turn into maxDebtCeiling Raw\n        maxDebtCeilingRaw_ = (maxDebtCeilingNormal_ * EXCHANGE_PRICES_PRECISION) / borrowExchangePrice_;\n\n        userBorrowData_ = LIQUIDITY.readFromStorage(_LIQUDITY_PROTOCOL_BORROW_SLOT); // total storage slot\n\n        baseDebtCeilingRaw_ = BigMathMinified.fromBigNumber(\n            (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18,\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        );\n\n        if (baseDebtCeilingRaw_ > maxDebtCeilingRaw_) {\n            // max debt ceiling can never be < base debt ceiling\n            maxDebtCeilingRaw_ = baseDebtCeilingRaw_;\n        }\n    }\n\n    function _configPercentDiff(\n        uint256 userBorrowData_,\n        uint256 maxDebtCeilingRaw_\n    ) internal pure returns (uint256 configPercentDiff_, uint256 oldMaxDebtCeilingRaw_) {\n        oldMaxDebtCeilingRaw_ = BigMathMinified.fromBigNumber(\n            (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18,\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        );\n\n        if (oldMaxDebtCeilingRaw_ == maxDebtCeilingRaw_) {\n            return (0, oldMaxDebtCeilingRaw_);\n        }\n\n        if (oldMaxDebtCeilingRaw_ > maxDebtCeilingRaw_) {\n            // % of how much new max debt ceiling would be smaller\n            configPercentDiff_ = oldMaxDebtCeilingRaw_ - maxDebtCeilingRaw_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 10 -> 2000 (20%)\n        } else {\n            // % of how much new max debt ceiling would be bigger\n            configPercentDiff_ = maxDebtCeilingRaw_ - oldMaxDebtCeilingRaw_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 8 -> 2500 (25%)\n        }\n\n        configPercentDiff_ = (configPercentDiff_ * 1e4) / oldMaxDebtCeilingRaw_;\n    }\n\n    function _updateBorrowLimits() internal returns (bool updated_) {\n        (\n            uint256 maxDebtCeilingRaw_,\n            uint256 totalSupplyNormal_,\n            uint256 borrowExchangePrice_,\n            uint256 userBorrowData_,\n            uint256 baseDebtCeilingRaw_\n        ) = _calcMaxDebtCeiling();\n\n        (uint256 configPercentDiff_, uint256 oldMaxDebtCeilingRaw_) = _configPercentDiff(\n            userBorrowData_,\n            maxDebtCeilingRaw_\n        );\n\n        // check if min config deviation is reached\n        if (configPercentDiff_ < MIN_UPDATE_DIFF) {\n            return false;\n        }\n\n        // execute update at Liquidity\n        AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_ = new AdminModuleStructs.UserBorrowConfig[](1);\n        userBorrowConfigs_[0] = AdminModuleStructs.UserBorrowConfig({\n            user: PROTOCOL,\n            token: BORROW_TOKEN,\n            mode: uint8(userBorrowData_ & 1), // first bit\n            expandPercent: (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14, // set same as old\n            expandDuration: (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24, // set same as old\n            baseDebtCeiling: baseDebtCeilingRaw_, // set same as old\n            maxDebtCeiling: maxDebtCeilingRaw_\n        });\n        LIQUIDITY.updateUserBorrowConfigs(userBorrowConfigs_);\n\n        emit LogUpdateBorrowMaxDebtCeiling(\n            totalSupplyNormal_,\n            oldMaxDebtCeilingRaw_,\n            maxDebtCeilingRaw_,\n            borrowExchangePrice_\n        );\n\n        return true;\n    }\n}\n"
    },
    "contracts/config/rangeAuthDex/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { DexSlotsLink } from \"../../libraries/dexSlotsLink.sol\";\nimport { IFluidDexT1 } from \"../../protocols/dex/interfaces/iDexT1.sol\";\n\ninterface IFluidDexT1Admin {\n    /// @notice updates the upper and lower percent configs for a dex\n    /// @param upperPercent_ in 4 decimals, 10000 = 1%\n    /// @param lowerPercent_ in 4 decimals, 10000 = 1%\n    /// @param shiftTime_ in secs, in how much time the upper percent configs change should be fully done\n    function updateRangePercents(uint upperPercent_, uint lowerPercent_, uint shiftTime_) external;\n\n    /// @param upperThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param lowerThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param thresholdShiftTime_ in secs, in how much time the threshold percent should take to shift the ranges\n    /// @param shiftTime_ in secs, in how much time the upper config changes should be fully done.\n    function updateThresholdPercent(\n        uint upperThresholdPercent_,\n        uint lowerThresholdPercent_,\n        uint thresholdShiftTime_,\n        uint shiftTime_\n    ) external;\n}\n\nabstract contract Events {\n    /// @notice emitted when multisig successfully changes the upper and lower range percent configs\n    event LogSetRanges(address dex, uint upperPercent, uint lowerPercent, uint shiftTime);\n\n    /// @notice emitted when multisig successfully changes threshold configs\n    event LogSetThresholdConfig(\n        address dex,\n        uint upperPercent,\n        uint lowerPercent,\n        uint thresholdShiftTime,\n        uint shiftTime\n    );\n}\n\nabstract contract Constants {\n    uint256 internal constant X10 = 0x3ff;\n    uint256 internal constant X20 = 0xfffff;\n    uint256 internal constant X24 = 0xffffff;\n\n    uint256 internal constant THREE_DECIMALS = 1e3;\n\n    /// @dev cooldown for config updates is 4 days\n    uint256 public constant COOLDOWN = 4 days;\n\n    /// @dev max percent range change allowed is 20%\n    uint256 public constant MAX_PERCENT_RANGE_CHANGE_ALLOWED = 20 * 1e4;\n\n    /// @dev shift time must be >= 2 days <= 12 days (except for wsteth and weeth eth dexes)\n    uint256 public constant MIN_SHIFT_TIME = 2 days;\n    uint256 public constant MAX_SHIFT_TIME = 12 days;\n\n    /// @notice Team multisigs allowed to trigger methods\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n    address public constant TEAM_MULTISIG2 = 0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\n\n    /// @dev wsteth eth dex, must shift instantly (only on mainnet)\n    address public immutable WSTETH_ETH_DEX;\n\n    /// @dev weeth eth dex, must shift instantly (only on mainnet)\n    address public immutable WEETH_ETH_DEX;\n}\n\nabstract contract Variables is Constants {\n    enum UpdateType {\n        RANGES, // 0\n        THRESHOLD // 1\n    }\n\n    /// @notice dex => UpdateType => last update time when a Dex config was updated\n    mapping(address => mapping(UpdateType => uint256)) public dexLastUpdateTimestamp;\n}\n\ncontract FluidRangeAuthDex is Variables, Error, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.RangeAuthDex__InvalidParams);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is the team multisig\n    modifier onlyMultisig() {\n        if (TEAM_MULTISIG != msg.sender && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.RangeAuthDex__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(address wstethEthDex_, address weethEthDex_) {\n        if ((block.chainid == 1) && (wstethEthDex_ == address(0) || weethEthDex_ == address(0))) {\n            revert FluidConfigError(ErrorTypes.RangeAuthDex__InvalidParams);\n        }\n        WSTETH_ETH_DEX = wstethEthDex_;\n        WEETH_ETH_DEX = weethEthDex_;\n    }\n\n    function getRanges(address dex_) public view returns (uint256 upperRangePercent_, uint256 lowerRangePercent_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n\n        upperRangePercent_ = (dexVariables2_ >> 27) & X20;\n        lowerRangePercent_ = (dexVariables2_ >> 47) & X20;\n    }\n\n    function getThresholdConfig(\n        address dex_\n    )\n        public\n        view\n        returns (uint256 upperThresholdPercent_, uint256 lowerThresholdPercent_, uint256 thresholdShiftTime_)\n    {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n\n        upperThresholdPercent_ = ((dexVariables2_ >> 68) & X10) * THREE_DECIMALS;\n        lowerThresholdPercent_ = ((dexVariables2_ >> 78) & X10) * THREE_DECIMALS;\n        thresholdShiftTime_ = (dexVariables2_ >> 88) & X24;\n    }\n\n    /// @notice Sets the upper and lower range for a dex\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex\n    /// @param upperRangePercent_ The new upper range to be set\n    /// @param lowerRangePercent_ The new lower range to be set\n    function setRanges(\n        address dex_,\n        uint256 upperRangePercent_,\n        uint256 lowerRangePercent_,\n        uint256 shiftTime_\n    ) external onlyMultisig {\n        _validateLastUpdateTime(dex_, UpdateType.RANGES);\n        _validateShiftTime(dex_, shiftTime_);\n\n        (uint256 currentUpperRangePercent_, uint256 currentLowerRangePercent_) = getRanges(dex_);\n\n        _validateChange(currentUpperRangePercent_, upperRangePercent_);\n        _validateChange(currentLowerRangePercent_, lowerRangePercent_);\n\n        dexLastUpdateTimestamp[dex_][UpdateType.RANGES] = block.timestamp;\n\n        IFluidDexT1Admin(dex_).updateRangePercents(upperRangePercent_, lowerRangePercent_, shiftTime_);\n\n        emit LogSetRanges(dex_, upperRangePercent_, lowerRangePercent_, shiftTime_);\n    }\n\n    /// @notice Sets the upper and lower range for a dex by percentage to change from current config\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex\n    /// @param newUpperRangePercentage_ The new upper range percentage change, 10000 = 1%. Positive to increase, negative to decrease\n    /// @param newLowerRangePercentage_ The new lower range percentage change, 10000 = 1%. Positive to increase, negative to decrease\n    function setRangesByPercentage(\n        address dex_,\n        int256 newUpperRangePercentage_,\n        int256 newLowerRangePercentage_,\n        uint256 shiftTime_\n    ) external onlyMultisig {\n        _validateLastUpdateTime(dex_, UpdateType.RANGES);\n        _validateShiftTime(dex_, shiftTime_);\n\n        _validatePercentChange(_abs(newUpperRangePercentage_));\n        _validatePercentChange(_abs(newLowerRangePercentage_));\n\n        (uint256 currentUpperRangePercent_, uint256 currentLowerRangePercent_) = getRanges(dex_);\n\n        uint256 newUpperRangePercent_ = _getNewRange(currentUpperRangePercent_, newUpperRangePercentage_);\n        uint256 newLowerRangePercent_ = _getNewRange(currentLowerRangePercent_, newLowerRangePercentage_);\n\n        dexLastUpdateTimestamp[dex_][UpdateType.RANGES] = block.timestamp;\n\n        IFluidDexT1Admin(dex_).updateRangePercents(newUpperRangePercent_, newLowerRangePercent_, shiftTime_);\n\n        emit LogSetRanges(dex_, newUpperRangePercent_, newLowerRangePercent_, shiftTime_);\n    }\n\n    /// @notice Sets the upper and lower threshold percent for a dex\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex\n    /// @param upperThresholdPercent_ The new upper threshold percent, 10000 = 1%\n    /// @param lowerThresholdPercent_ The new lower threshold percent, 10000 = 1%\n    /// @param thresholdShiftTime_ The new threshold shift time\n    function setThresholdConfig(\n        address dex_,\n        uint256 upperThresholdPercent_,\n        uint256 lowerThresholdPercent_,\n        uint256 thresholdShiftTime_,\n        uint256 shiftTime_\n    ) external onlyMultisig {\n        _validateLastUpdateTime(dex_, UpdateType.THRESHOLD);\n        _validateShiftTime(dex_, shiftTime_);\n\n        (\n            uint256 currentUpperThresholdPercent_,\n            uint256 currentLowerThresholdPercent_,\n            uint256 currentThresholdShiftTime_\n        ) = getThresholdConfig(dex_);\n\n        _validateChange(currentUpperThresholdPercent_, upperThresholdPercent_);\n        _validateChange(currentLowerThresholdPercent_, lowerThresholdPercent_);\n        _validateChange(currentThresholdShiftTime_, thresholdShiftTime_);\n\n        dexLastUpdateTimestamp[dex_][UpdateType.THRESHOLD] = block.timestamp;\n\n        IFluidDexT1Admin(dex_).updateThresholdPercent(\n            upperThresholdPercent_,\n            lowerThresholdPercent_,\n            thresholdShiftTime_,\n            shiftTime_\n        );\n\n        emit LogSetThresholdConfig(\n            dex_,\n            upperThresholdPercent_,\n            lowerThresholdPercent_,\n            thresholdShiftTime_,\n            shiftTime_\n        );\n    }\n\n    function _percentDiffForValue(\n        uint256 oldValue_,\n        uint256 newValue_\n    ) internal pure returns (uint256 configPercentDiff_) {\n        if (oldValue_ == 0 || oldValue_ == newValue_) {\n            return 0;\n        }\n\n        if (oldValue_ > newValue_) {\n            // % of how much new value would be smaller\n            configPercentDiff_ = oldValue_ - newValue_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 10 -> 2000 (20%)\n        } else {\n            // % of how much new value would be bigger\n            configPercentDiff_ = newValue_ - oldValue_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 8 -> 2500 (25%)\n        }\n\n        configPercentDiff_ = (configPercentDiff_ * 1e6) / oldValue_;\n    }\n\n    function _getNewRange(uint256 currentRange_, int256 newRangePercentage_) internal pure returns (uint256 newRange_) {\n        if (newRangePercentage_ > 0) {\n            /// @dev newRangePercentage_ is 10000 = 1%\n            newRange_ = currentRange_ + (currentRange_ * uint256(newRangePercentage_)) / 1e6;\n        } else {\n            newRange_ = currentRange_ - (currentRange_ * uint256(-newRangePercentage_)) / 1e6;\n        }\n    }\n\n    function _validatePercentChange(uint256 percent_) internal pure {\n        if (percent_ > MAX_PERCENT_RANGE_CHANGE_ALLOWED) {\n            revert FluidConfigError(ErrorTypes.RangeAuthDex__ExceedAllowedPercentageChange);\n        }\n    }\n\n    function _validateChange(uint256 oldConfig_, uint256 newConfig_) internal pure {\n        uint256 configPercentage_ = _percentDiffForValue(oldConfig_, newConfig_);\n        _validatePercentChange(configPercentage_);\n    }\n\n    function _validateShiftTime(address dex_, uint256 shiftTime_) internal view {\n        if ((block.chainid == 1) && (dex_ == WSTETH_ETH_DEX || dex_ == WEETH_ETH_DEX)) {\n            /// @dev wsteth eth and weeth dex has zero shift time\n            if (shiftTime_ != 0) {\n                revert FluidConfigError(ErrorTypes.RangeAuthDex__InvalidShiftTime);\n            }\n        } else {\n            if (shiftTime_ < MIN_SHIFT_TIME || shiftTime_ > MAX_SHIFT_TIME) {\n                revert FluidConfigError(ErrorTypes.RangeAuthDex__InvalidShiftTime);\n            }\n        }\n    }\n\n    function _validateLastUpdateTime(address dex_, UpdateType updateType_) internal view {\n        if (block.timestamp - dexLastUpdateTimestamp[dex_][updateType_] < COOLDOWN) {\n            revert FluidConfigError(ErrorTypes.RangeAuthDex__CooldownLeft);\n        }\n    }\n\n    function _abs(int256 value_) internal pure returns (uint256) {\n        return value_ > 0 ? uint256(value_) : uint256(-value_);\n    }\n}\n"
    },
    "contracts/config/ratesAuth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Structs as AdminModuleStructs } from \"../../liquidity/adminModule/structs.sol\";\n\nabstract contract Constants {\n    IFluidLiquidity public immutable LIQUIDITY;\n    /// @notice Team multisigs allowed to trigger methods\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n    address public constant TEAM_MULTISIG2 = 0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\n\n    uint256 internal constant X16 = 0xffff;\n\n    uint256 public immutable PERCENT_RATE_CHANGE_ALLOWED;\n    uint256 public immutable COOLDOWN;\n}\n\nabstract contract Events {\n    /// @notice emitted when borrow rate for specified borrow token is updated based on\n    ///         team multisig input of rate at kinks\n    event LogUpdateRateAtKink(\n        address borrowToken,\n        uint256 oldRateKink1,\n        uint256 newRateKink1,\n        uint256 oldRateKink2,\n        uint256 newRateKink2\n    );\n}\n\nabstract contract Structs {\n    struct RateAtKinkV1 {\n        address token;\n        uint256 rateAtUtilizationKink;\n    }\n\n    struct RateAtKinkV2 {\n        address token;\n        uint256 rateAtUtilizationKink1;\n        uint256 rateAtUtilizationKink2;\n    }\n}\n\nabstract contract Variables {\n    /// @notice  last timestamp when a token's rate was updated\n    mapping(address => uint256) public tokenLastUpdateTimestamp;\n}\n\n/// @notice Sets borrow rate for specified borrow token at Liquidity based on team multisig input.\ncontract FluidRatesAuth is Constants, Error, Events, Structs, Variables {\n    /// @dev Validates that an address is a multisig (taken from reserve auth)\n    modifier onlyMultisig() {\n        if (TEAM_MULTISIG != msg.sender && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(address liquidity_, uint256 percentRateChangeAllowed_, uint256 cooldown_) {\n        if (liquidity_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__InvalidParams);\n        }\n        if (percentRateChangeAllowed_ == 0 || cooldown_ == 0) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__InvalidParams);\n        }\n        if (percentRateChangeAllowed_ > 1e4) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__InvalidParams);\n        }\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        PERCENT_RATE_CHANGE_ALLOWED = percentRateChangeAllowed_;\n        COOLDOWN = cooldown_;\n    }\n\n    function updateRateDataV1(RateAtKinkV1 calldata rateStruct_) external onlyMultisig {\n        bytes32 borrowRateDataSlot_ = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_RATE_DATA_MAPPING_SLOT,\n            rateStruct_.token\n        );\n        uint256 rateConfig_ = LIQUIDITY.readFromStorage(borrowRateDataSlot_);\n        if (rateConfig_ & 0xF != 1) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__InvalidVersion);\n        }\n\n        if (block.timestamp - tokenLastUpdateTimestamp[rateStruct_.token] < COOLDOWN) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__CooldownLeft);\n        }\n\n        AdminModuleStructs.RateDataV1Params memory rateData_;\n        rateData_.token = rateStruct_.token;\n\n        uint256 oldRateKink1_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n\n        // checks the diff to be lesser than allowed\n        if (_percentDiffForValue(oldRateKink1_, rateStruct_.rateAtUtilizationKink) > PERCENT_RATE_CHANGE_ALLOWED) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__NoUpdate);\n        }\n\n        // setting up the rateData_ struct\n        rateData_.token = rateStruct_.token;\n        rateData_.kink = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n        rateData_.rateAtUtilizationZero =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) &\n            X16;\n        rateData_.rateAtUtilizationKink = rateStruct_.rateAtUtilizationKink;\n        rateData_.rateAtUtilizationMax =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) &\n            X16;\n\n        AdminModuleStructs.RateDataV1Params[] memory liquidityParams_ = new AdminModuleStructs.RateDataV1Params[](1);\n        liquidityParams_[0] = rateData_;\n        LIQUIDITY.updateRateDataV1s(liquidityParams_);\n\n        tokenLastUpdateTimestamp[rateData_.token] = block.timestamp;\n\n        emit LogUpdateRateAtKink(rateData_.token, oldRateKink1_, rateStruct_.rateAtUtilizationKink, 0, 0);\n    }\n\n    function updateRateDataV2(RateAtKinkV2 calldata rateStruct_) external onlyMultisig {\n        bytes32 borrowRateDataSlot_ = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_RATE_DATA_MAPPING_SLOT,\n            rateStruct_.token\n        );\n        uint256 rateConfig_ = LIQUIDITY.readFromStorage(borrowRateDataSlot_);\n        if (rateConfig_ & 0xF != 2) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__InvalidVersion);\n        }\n\n        if (block.timestamp - tokenLastUpdateTimestamp[rateStruct_.token] < COOLDOWN) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__CooldownLeft);\n        }\n\n        AdminModuleStructs.RateDataV2Params memory rateData_;\n\n        uint256 oldRateKink1_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n        uint256 oldRateKink2_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n\n        if (\n            _percentDiffForValue(oldRateKink1_, rateStruct_.rateAtUtilizationKink1) > PERCENT_RATE_CHANGE_ALLOWED ||\n            _percentDiffForValue(oldRateKink2_, rateStruct_.rateAtUtilizationKink2) > PERCENT_RATE_CHANGE_ALLOWED\n        ) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__NoUpdate);\n        }\n\n        // setting up the rateData_ struct\n        rateData_.token = rateStruct_.token;\n        rateData_.kink1 = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\n        rateData_.kink2 = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\n        rateData_.rateAtUtilizationZero =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) &\n            X16;\n        rateData_.rateAtUtilizationKink1 = rateStruct_.rateAtUtilizationKink1;\n        rateData_.rateAtUtilizationKink2 = rateStruct_.rateAtUtilizationKink2;\n        rateData_.rateAtUtilizationMax =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) &\n            X16;\n\n        AdminModuleStructs.RateDataV2Params[] memory params_ = new AdminModuleStructs.RateDataV2Params[](1);\n        params_[0] = rateData_;\n        LIQUIDITY.updateRateDataV2s(params_);\n        tokenLastUpdateTimestamp[rateStruct_.token] = block.timestamp;\n\n        emit LogUpdateRateAtKink(\n            rateStruct_.token,\n            oldRateKink1_,\n            rateStruct_.rateAtUtilizationKink1,\n            oldRateKink2_,\n            rateStruct_.rateAtUtilizationKink2\n        );\n    }\n\n    /// @dev gets the percentage difference between `oldValue_` and `newValue_` in relation to `oldValue_`\n    function _percentDiffForValue(\n        uint256 oldValue_,\n        uint256 newValue_\n    ) internal pure returns (uint256 configPercentDiff_) {\n        if (oldValue_ == newValue_) {\n            return 0;\n        }\n\n        if (oldValue_ > newValue_) {\n            // % of how much new value would be smaller\n            configPercentDiff_ = oldValue_ - newValue_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 10 -> 2000 (20%)\n        } else {\n            // % of how much new value would be bigger\n            configPercentDiff_ = newValue_ - oldValue_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 8 -> 2500 (25%)\n        }\n\n        configPercentDiff_ = (configPercentDiff_ * 1e4) / oldValue_;\n    }\n}\n"
    },
    "contracts/config/vaultFeeRewardsAuth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidVaultT1Admin } from \"../../protocols/vault/vaultT1/adminModule/main.sol\";\nimport { FluidVaultT2Admin } from \"../../protocols/vault/vaultT2/adminModule/main.sol\";\nimport { FluidVaultT3Admin } from \"../../protocols/vault/vaultT3/adminModule/main.sol\";\nimport { IFluidVault } from \"../../protocols/vault/interfaces/iVault.sol\";\nimport { FluidProtocolTypes } from \"../../libraries/fluidProtocolTypes.sol\";\n\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nabstract contract Constants {\n    /// @notice Team multisig allowed to trigger collecting revenue\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n    address public constant TEAM_MULTISIG2 = 0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\n\n    uint internal constant X15 = 0x7fff;\n    uint internal constant X16 = 0xffff;\n}\n\nabstract contract Events {\n    /// @notice emitted when supply rate magnifier is updated at a vault\n    /// @param vault The address of the vault\n    /// @param oldSupplyRateMagnifier The previous supply rate magnifier value\n    /// @param newSupplyRateMagnifier The new supply rate magnifier value\n    event LogUpdateSupplyRateMagnifier(address vault, uint256 oldSupplyRateMagnifier, uint256 newSupplyRateMagnifier);\n\n    /// @notice emitted when borrow rate magnifier is updated at a vault\n    /// @param vault The address of the vault\n    /// @param oldBorrowRateMagnifier The previous borrow rate magnifier value\n    /// @param newBorrowRateMagnifier The new borrow rate magnifier value\n    event LogUpdateBorrowRateMagnifier(address vault, uint256 oldBorrowRateMagnifier, uint256 newBorrowRateMagnifier);\n\n    /// @notice emitted when supply rate is updated at a vault\n    /// @param vault The address of the vault\n    /// @param oldSupplyRate The previous supply rate value\n    /// @param newSupplyRate The new supply rate value\n    event LogUpdateSupplyRate(address vault, int256 oldSupplyRate, int256 newSupplyRate);\n\n    /// @notice emitted when borrow rate is updated at a vault\n    /// @param vault The address of the vault\n    /// @param oldBorrowRate The previous borrow rate value\n    /// @param newBorrowRate The new borrow rate value\n    event LogUpdateBorrowRate(address vault, int256 oldBorrowRate, int256 newBorrowRate);\n}\n\ncontract FluidVaultFeeRewardsAuth is Constants, Error, Events {\n    /// @dev Validates that an address is the team multisig\n    modifier onlyMultisig() {\n        if (msg.sender != TEAM_MULTISIG && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.VaultFeeRewardsAuth__Unauthorized);\n        }\n        _;\n    }\n\n    /// @notice updates the supply rate for a given SMART COL vault.\n    /// @param smartColVault_ The address of the SMART COL vault to update\n    /// @param newSupplyRate_ The new supply rate to set. Input in 1e2 (1% = 100, 100% = 10_000). If positive then incentives else charging\n    function updateSupplyRate(address smartColVault_, int newSupplyRate_) external onlyMultisig {\n        int256 oldSupplyRate_ = currentSupplyRate(smartColVault_);\n\n        FluidVaultT2Admin(address(smartColVault_)).updateSupplyRate(newSupplyRate_);\n\n        emit LogUpdateSupplyRate(smartColVault_, oldSupplyRate_, newSupplyRate_);\n    }\n\n    /// @notice updates the borrow rate for a given SMART DEBT vault.\n    /// @param smartDebtVault_ The address of the SMART DEBT vault to update\n    /// @param newBorrowRate_ The new borrow rate to set. Input in 1e2 (1% = 100, 100% = 10_000). If positive then charging else incentives\n    function updateBorrowRate(address smartDebtVault_, int newBorrowRate_) external onlyMultisig {\n        int256 oldBorrowRate_ = currentBorrowRate(smartDebtVault_);\n\n        FluidVaultT3Admin(address(smartDebtVault_)).updateBorrowRate(newBorrowRate_);\n\n        emit LogUpdateBorrowRate(smartDebtVault_, oldBorrowRate_, newBorrowRate_);\n    }\n\n    /// @notice Sets the supply rate magnifier for a given NORMAL COL vault.\n    /// @param normalColVault_ The address of the NORMAL COL vault to update.\n    /// @param newMagnifier_ The new supply rate magnifier value to set.\n    function updateSupplyRateMagnifier(address normalColVault_, uint256 newMagnifier_) external onlyMultisig {\n        uint256 oldMagnifier_ = currentSupplyRateMagnifier(normalColVault_);\n\n        FluidVaultT1Admin(address(normalColVault_)).updateSupplyRateMagnifier(newMagnifier_);\n\n        emit LogUpdateSupplyRateMagnifier(normalColVault_, oldMagnifier_, newMagnifier_);\n    }\n\n    /// @notice Sets the borrow rate magnifier for a given NORMAL DEBT vault.\n    /// @param normalDebtVault_ The address of the NORMAL DEBT vault to update.\n    /// @param newMagnifier_ The new borrow rate magnifier value to set.\n    function updateBorrowRateMagnifier(address normalDebtVault_, uint256 newMagnifier_) external onlyMultisig {\n        uint256 oldMagnifier_ = currentBorrowRateMagnifier(normalDebtVault_);\n\n        FluidVaultT1Admin(address(normalDebtVault_)).updateBorrowRateMagnifier(newMagnifier_);\n\n        emit LogUpdateBorrowRateMagnifier(normalDebtVault_, oldMagnifier_, newMagnifier_);\n    }\n\n    /// @notice Get the type of a vault (assumes valid Fluid vault address is passed in)\n    /// @param vault_ The address of the vault.\n    /// @return isSmartCol_ True if the vault is a SMART COL vault, false otherwise.\n    /// @return isSmartDebt_ True if the vault is a SMART DEBT vault, false otherwise.\n    function getVaultType(address vault_) public view returns (bool isSmartCol_, bool isSmartDebt_) {\n        try IFluidVault(vault_).TYPE() returns (uint type_) {\n            if (type_ == FluidProtocolTypes.VAULT_T1_TYPE) {\n                return (false, false);\n            }\n            if (type_ == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE) {\n                return (true, false);\n            }\n            if (type_ == FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE) {\n                return (false, true);\n            }\n            if (type_ == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE) {\n                return (true, true);\n            }\n        } catch {\n            // if TYPE() is not available but address is valid vault id, it must be vault T1\n            return (false, false);\n        }\n    }\n\n    /// @notice returns the currently configured supply rate magnifier at the `vault_`\n    /// @param normalColVault_ The address of the NORMAL COL vault to query.\n    /// @return The current supply rate magnifier value.\n    function currentSupplyRateMagnifier(address normalColVault_) public view returns (uint256) {\n        (bool isSmartCol_, ) = getVaultType(normalColVault_);\n        if (isSmartCol_) {\n            revert FluidConfigError(ErrorTypes.VaultFeeRewardsAuth__InvalidVaultType);\n        }\n\n        // read supply rate magnifier from Vault `vaultVariables2` located in storage slot 1, 16 bits from 0-15\n        return (IFluidVault(normalColVault_).readFromStorage(bytes32(uint256(1)))) & X16;\n    }\n\n    /// @notice returns the currently configured borrow rate magnifier at the `vault_`\n    /// @param normalDebtVault_ The address of the NORMAL DEBT vault to query.\n    /// @return The current borrow rate magnifier value.\n    function currentBorrowRateMagnifier(address normalDebtVault_) public view returns (uint256) {\n        (, bool isSmartDebt_) = getVaultType(normalDebtVault_);\n        if (isSmartDebt_) {\n            revert FluidConfigError(ErrorTypes.VaultFeeRewardsAuth__InvalidVaultType);\n        }\n\n        // read borrow rate magnifier from Vault `vaultVariables2` located in storage slot 1, 16 bits from 16-31\n        return (IFluidVault(normalDebtVault_).readFromStorage(bytes32(uint256(1))) >> 16) & X16;\n    }\n\n    /// @notice returns the currently configured supply rate at the `vault_`\n    /// @param smartColVault_ The address of the SMART COL vault to query.\n    /// @return supplyRate_ The current supply rate value.\n    function currentSupplyRate(address smartColVault_) public view returns (int256 supplyRate_) {\n        (bool isSmartCol_, ) = getVaultType(smartColVault_);\n        if (!isSmartCol_) {\n            revert FluidConfigError(ErrorTypes.VaultFeeRewardsAuth__InvalidVaultType);\n        }\n        uint256 supplyRateMagnifier_ = (IFluidVault(smartColVault_).readFromStorage(bytes32(uint256(1)))) & X16;\n\n        // in case of smart collateral supply magnifier bits stores supply interest rate positive or negative\n        // negative meaning charging users, positive means incentivizing users\n        supplyRate_ = int256((supplyRateMagnifier_ >> 1) & X15);\n        // if first bit == 1 then positive else negative\n        if ((supplyRateMagnifier_ & 1) == 0) {\n            supplyRate_ = -supplyRate_;\n        }\n    }\n\n    /// @notice returns the currently configured borrow rate at the `vault_`\n    /// @param smartDebtVault_ The address of the SMART DEBT vault to query.\n    /// @return borrowRate_ The current borrow rate value.\n    function currentBorrowRate(address smartDebtVault_) public view returns (int256 borrowRate_) {\n        (, bool isSmartDebt_) = getVaultType(smartDebtVault_);\n        if (!isSmartDebt_) {\n            revert FluidConfigError(ErrorTypes.VaultFeeRewardsAuth__InvalidVaultType);\n        }\n\n        uint256 borrowRateMagnifier_ = (IFluidVault(smartDebtVault_).readFromStorage(bytes32(uint256(1))) >> 16) & X16;\n\n        // in case of smart debt borrow magnifier bits stores borrow interest rate positive or negative\n        // negative meaning incentivizing users, positive means charging users\n        borrowRate_ = int256((borrowRateMagnifier_ >> 1) & X15);\n        // if first bit == 1 then positive else negative\n        if ((borrowRateMagnifier_ & 1) == 0) {\n            borrowRate_ = -borrowRate_;\n        }\n    }\n}\n"
    },
    "contracts/config/withdrawLimitAuth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { LiquidityCalcs } from \"../../libraries/liquidityCalcs.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nabstract contract Structs {\n    struct UserSupplyHistory {\n        uint40 initialDailyTimestamp;\n        uint40 initialHourlyTimestamp;\n        uint8 rebalancesIn1Hour;\n        uint8 rebalancesIn24Hours;\n        uint160 leastDailyUserSupply;\n    }\n}\n\nabstract contract Events {\n    /// @notice emitted when rebalancer successfully changes the withdrawal limit\n    event LogRebalanceWithdrawalLimit(address user, address token, uint256 newLimit);\n\n    /// @notice emitted when multisig successfully changes the withdrawal limit\n    event LogSetWithdrawalLimit(address user, address token, uint256 newLimit);\n}\n\nabstract contract Constants {\n    uint256 internal constant X64 = 0xffffffffffffffff;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    address public immutable TEAM_MULTISIG;\n\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n\n    IFluidLiquidity public immutable LIQUIDITY;\n\n    uint256 internal constant MAX_PERCENT_CHANGE = 5; // 5% max percent change at once\n}\n\nabstract contract Variables is Structs, Constants {\n    mapping(address => mapping(address => UserSupplyHistory)) public userData;\n}\n\ncontract FluidWithdrawLimitAuth is Variables, Error, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__InvalidParams);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract)\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__Unauthorized);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is the team multisig\n    modifier onlyMultisig() {\n        if (msg.sender != TEAM_MULTISIG) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(\n        IFluidReserveContract reserveContract_,\n        address liquidity_,\n        address multisig_\n    ) validAddress(address(reserveContract_)) validAddress(liquidity_) validAddress(multisig_) {\n        RESERVE_CONTRACT = reserveContract_;\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        TEAM_MULTISIG = multisig_;\n    }\n\n    /// @notice updates the withdrawal limit for a specific token of a user in the liquidity\n    /// @dev This function can only be called by the rebalancer\n    /// @param user_ The address of the user for which to set the withdrawal limit\n    /// @param token_ The address of the token for which to set the withdrawal limit\n    /// @param newLimit_ The new withdrawal limit to be set\n    function rebalanceWithdrawalLimit(address user_, address token_, uint256 newLimit_) external onlyRebalancer {\n        // getting the user supply data from liquidity\n        uint256 userSupplyData_ = LIQUIDITY.readFromStorage(\n            LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n                user_,\n                token_\n            )\n        );\n\n        uint256 initialUserSupply_ = BigMathMinified.fromBigNumber(\n            (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64,\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        );\n\n        uint256 initialWithdrawLimit_ = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(\n            userSupplyData_,\n            initialUserSupply_\n        );\n\n        if (initialUserSupply_ == 0) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__NoUserSupply);\n        }\n\n        uint256 maxPercentOfCurrentLimit_ = (initialWithdrawLimit_ * (100 - MAX_PERCENT_CHANGE)) / 100;\n\n        if (newLimit_ < maxPercentOfCurrentLimit_) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__ExcessPercentageDifference);\n        }\n\n        // getting the limit history from the contract\n        UserSupplyHistory memory userSupplyHistory_ = userData[user_][token_];\n\n        // if one day is crossed\n        if (block.timestamp - uint256(userSupplyHistory_.initialDailyTimestamp) > 1 days) {\n            userSupplyHistory_.leastDailyUserSupply = uint128(newLimit_);\n            userSupplyHistory_.rebalancesIn24Hours = 1;\n            userSupplyHistory_.rebalancesIn1Hour = 1;\n            userSupplyHistory_.initialDailyTimestamp = uint40(block.timestamp);\n            userSupplyHistory_.initialHourlyTimestamp = uint40(block.timestamp);\n        } else {\n            // if one day is not crossed\n            if (newLimit_ < userSupplyHistory_.leastDailyUserSupply) {\n                if (userSupplyHistory_.rebalancesIn24Hours == 4) {\n                    revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__DailyLimitReached);\n                }\n                if (block.timestamp - uint256(userSupplyHistory_.initialHourlyTimestamp) > 1 hours) {\n                    userSupplyHistory_.rebalancesIn1Hour = 1;\n                    userSupplyHistory_.rebalancesIn24Hours += 1;\n                    userSupplyHistory_.initialHourlyTimestamp = uint40(block.timestamp);\n                } else {\n                    if (userSupplyHistory_.rebalancesIn1Hour == 2) {\n                        revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__HourlyLimitReached);\n                    }\n                    userSupplyHistory_.rebalancesIn1Hour += 1;\n                    userSupplyHistory_.rebalancesIn24Hours += 1;\n                }\n                userSupplyHistory_.leastDailyUserSupply = uint128(newLimit_);\n            }\n        }\n        userData[user_][token_] = userSupplyHistory_;\n        LIQUIDITY.updateUserWithdrawalLimit(user_, token_, newLimit_);\n        emit LogRebalanceWithdrawalLimit(user_, token_, newLimit_);\n    }\n\n    /// @notice Sets the withdrawal limit for a specific token of a user in the liquidity\n    /// @dev This function can only be called by team multisig\n    /// @param user_ The address of the user for which to set the withdrawal limit\n    /// @param token_ The address of the token for which to set the withdrawal limit\n    /// @param newLimit_ The new withdrawal limit to be set\n    function setWithdrawalLimit(address user_, address token_, uint256 newLimit_) external onlyMultisig {\n        LIQUIDITY.updateUserWithdrawalLimit(user_, token_, newLimit_);\n        emit LogSetWithdrawalLimit(user_, token_, newLimit_);\n    }\n\n    function getUsersData(\n        address[] memory users_,\n        address[] memory tokens_\n    ) public view returns (uint256[] memory initialUsersSupply_, uint256[] memory initialWithdrawLimit_) {\n        if (users_.length != tokens_.length) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__InvalidParams);\n        }\n\n        initialUsersSupply_ = new uint256[](users_.length);\n        initialWithdrawLimit_ = new uint256[](users_.length);\n\n        for (uint i; i < tokens_.length; i++) {\n            uint256 userSupplyData_ = LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n                    users_[i],\n                    tokens_[i]\n                )\n            );\n\n            initialUsersSupply_[i] = BigMathMinified.fromBigNumber(\n                (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n            initialWithdrawLimit_[i] = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(\n                userSupplyData_,\n                initialUsersSupply_[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/config/withdrawLimitAuthDex/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { DexSlotsLink } from \"../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../libraries/dexCalcs.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { IFluidDexT1 } from \"../../protocols/dex/interfaces/iDexT1.sol\";\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\ninterface IFluidDexT1Admin {\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, uint256 newLimit_) external;\n}\n\nabstract contract Structs {\n    struct UserSupplyHistory {\n        uint40 initialDailyTimestamp;\n        uint40 initialHourlyTimestamp;\n        uint8 rebalancesIn1Hour;\n        uint8 rebalancesIn24Hours;\n        uint160 leastDailyUserSupply;\n    }\n}\n\nabstract contract Events {\n    /// @notice emitted when rebalancer successfully changes the withdrawal limit\n    event LogRebalanceWithdrawalLimit(address dex, address user, uint256 newLimit);\n\n    /// @notice emitted when multisig successfully changes the withdrawal limit\n    event LogSetWithdrawalLimit(address dex, address user, uint256 newLimit);\n}\n\nabstract contract Constants {\n    uint256 internal constant X64 = 0xffffffffffffffff;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    address public immutable TEAM_MULTISIG;\n\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n\n    uint256 internal constant MAX_PERCENT_CHANGE = 5; // 5% max percent change at once\n}\n\nabstract contract Variables is Structs, Constants {\n    mapping(address => UserSupplyHistory) public userData;\n}\n\ncontract FluidWithdrawLimitAuthDex is Variables, Error, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__InvalidParams);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract)\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__Unauthorized);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is the team multisig\n    modifier onlyMultisig() {\n        if (msg.sender != TEAM_MULTISIG) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(\n        IFluidReserveContract reserveContract_,\n        address multisig_\n    ) validAddress(address(reserveContract_)) validAddress(multisig_) {\n        RESERVE_CONTRACT = reserveContract_;\n        TEAM_MULTISIG = multisig_;\n    }\n\n    /// @notice updates the withdrawal limit for a specific user at a dex\n    /// @dev This function can only be called by the rebalancer\n    /// @param dex_ The address of the dex\n    /// @param user_ The address of the user for which to set the withdrawal limit\n    /// @param newLimit_ The new withdrawal limit to be set\n    function rebalanceWithdrawalLimit(address dex_, address user_, uint256 newLimit_) external onlyRebalancer {\n        // getting the user supply data from the dex\n        uint256 userSupplyData_ = IFluidDexT1(dex_).readFromStorage(\n            DexSlotsLink.calculateMappingStorageSlot(DexSlotsLink.DEX_USER_SUPPLY_MAPPING_SLOT, user_)\n        );\n\n        uint256 initialUserSupply_ = BigMathMinified.fromBigNumber(\n            (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64,\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        );\n\n        uint256 initialWithdrawLimit_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, initialUserSupply_);\n\n        if (initialUserSupply_ == 0) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__NoUserSupply);\n        }\n\n        uint256 maxPercentOfCurrentLimit_ = (initialWithdrawLimit_ * (100 - MAX_PERCENT_CHANGE)) / 100;\n\n        if (newLimit_ < maxPercentOfCurrentLimit_) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__ExcessPercentageDifference);\n        }\n\n        // getting the limit history from the contract\n        UserSupplyHistory memory userSupplyHistory_ = userData[user_];\n\n        // if one day is crossed\n        if (block.timestamp - uint256(userSupplyHistory_.initialDailyTimestamp) > 1 days) {\n            userSupplyHistory_.leastDailyUserSupply = uint128(newLimit_);\n            userSupplyHistory_.rebalancesIn24Hours = 1;\n            userSupplyHistory_.rebalancesIn1Hour = 1;\n            userSupplyHistory_.initialDailyTimestamp = uint40(block.timestamp);\n            userSupplyHistory_.initialHourlyTimestamp = uint40(block.timestamp);\n        } else {\n            // if one day is not crossed\n            if (newLimit_ < userSupplyHistory_.leastDailyUserSupply) {\n                if (userSupplyHistory_.rebalancesIn24Hours == 4) {\n                    revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__DailyLimitReached);\n                }\n                if (block.timestamp - uint256(userSupplyHistory_.initialHourlyTimestamp) > 1 hours) {\n                    userSupplyHistory_.rebalancesIn1Hour = 1;\n                    userSupplyHistory_.rebalancesIn24Hours += 1;\n                    userSupplyHistory_.initialHourlyTimestamp = uint40(block.timestamp);\n                } else {\n                    if (userSupplyHistory_.rebalancesIn1Hour == 2) {\n                        revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__HourlyLimitReached);\n                    }\n                    userSupplyHistory_.rebalancesIn1Hour += 1;\n                    userSupplyHistory_.rebalancesIn24Hours += 1;\n                }\n                userSupplyHistory_.leastDailyUserSupply = uint128(newLimit_);\n            }\n        }\n        userData[user_] = userSupplyHistory_;\n        IFluidDexT1Admin(dex_).updateUserWithdrawalLimit(user_, newLimit_);\n        emit LogRebalanceWithdrawalLimit(dex_, user_, newLimit_);\n    }\n\n    /// @notice Sets the withdrawal limit for a specific user at a dex\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex\n    /// @param user_ The address of the user for which to set the withdrawal limit\n    /// @param newLimit_ The new withdrawal limit to be set\n    function setWithdrawalLimit(address dex_, address user_, uint256 newLimit_) external onlyMultisig {\n        IFluidDexT1Admin(dex_).updateUserWithdrawalLimit(user_, newLimit_);\n        emit LogSetWithdrawalLimit(dex_, user_, newLimit_);\n    }\n\n    function getUsersData(\n        address dex_,\n        address[] memory users_\n    ) public view returns (uint256[] memory initialUsersSupply_, uint256[] memory initialWithdrawLimit_) {\n        initialUsersSupply_ = new uint256[](users_.length);\n        initialWithdrawLimit_ = new uint256[](users_.length);\n\n        for (uint i; i < users_.length; i++) {\n            uint256 userSupplyData_ = IFluidDexT1(dex_).readFromStorage(\n                DexSlotsLink.calculateMappingStorageSlot(DexSlotsLink.DEX_USER_SUPPLY_MAPPING_SLOT, users_[i])\n            );\n\n            initialUsersSupply_[i] = BigMathMinified.fromBigNumber(\n                (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n            initialWithdrawLimit_[i] = DexCalcs.calcWithdrawalLimitBeforeOperate(\n                userSupplyData_,\n                initialUsersSupply_[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/infiniteProxy/interfaces/iProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IProxy {\n    function setAdmin(address newAdmin_) external;\n\n    function setDummyImplementation(address newDummyImplementation_) external;\n\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\n\n    function removeImplementation(address implementation_) external;\n\n    function getAdmin() external view returns (address);\n\n    function getDummyImplementation() external view returns (address);\n\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\n\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/bigMathMinified.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\nlibrary BigMathMinified {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/dexCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\nimport { DexSlotsLink } from \"./dexSlotsLink.sol\";\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// @DEV ATTENTION: ON ANY CHANGES HERE, MAKE SURE THAT LOGIC IN VAULTS WILL STILL BE VALID.\n// SOME CODE THERE ASSUMES DEXCALCS == LIQUIDITYCALCS.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n/// @notice implements calculation methods used for Fluid Dex such as updated withdrawal / borrow limits.\nlibrary DexCalcs {\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) &\n            X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ = block.timestamp - ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ = block.timestamp - ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n}\n"
    },
    "contracts/libraries/dexSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\nlibrary DexSlotsLink {\n    /// @dev storage slot for variables at Dex\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\n    /// @dev storage slot for variables2 at Dex\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\n    /// @dev storage slot for total supply shares at Dex\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\n    /// @dev storage slot for user supply mapping at Dex\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\n    /// @dev storage slot for total borrow shares at Dex\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\n    /// @dev storage slot for user borrow mapping at Dex\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\n    /// @dev storage slot for oracle mapping at Dex\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\n    /// @dev storage slot for range and threshold shifts at Dex\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\n    /// @dev storage slot for center price shift at Dex\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n\n    /***********************************|\n    |           SafeApprove             | \n    |__________________________________*/\n\n    /// @notice thrown when safe approve from for an ERC20 fails\n    uint256 internal constant SafeApprove__ApproveFailed = 81001;\n}\n"
    },
    "contracts/libraries/fluidProtocolTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ninterface IFluidProtocol {\n    function TYPE() external view returns (uint256);\n}\n\n/// @notice implements helper methods to filter Fluid protocols by a certain type\nlibrary FluidProtocolTypes {\n    uint256 internal constant VAULT_T1_TYPE = 10000; // VaultT1 borrow protocol type vaults\n    uint256 internal constant VAULT_T2_SMART_COL_TYPE = 20000; // DEX protocol type vault\n    uint256 internal constant VAULT_T3_SMART_DEBT_TYPE = 30000; // DEX protocol type vault\n    uint256 internal constant VAULT_T4_SMART_COL_SMART_DEBT_TYPE = 40000; // DEX protocol type vault\n\n    /// @dev filters input `addresses_` by protocol `type_`. Input addresses must be actual Fluid protocols, otherwise\n    ///      they would be wrongly assumed to be VaultT1 even if they are not Fluid VaultT1 smart contracts.\n    ///      `type_` must be a listed constant type of this library.\n    ///      Example usage is to filter all vault addresses at the Vault factory by a certain type, e.g. to not include\n    ///      DEX protocol type vaults.\n    function filterBy(address[] memory addresses_, uint256 type_) internal view returns (address[] memory filtered_) {\n        uint256 curType_;\n        uint256 filteredProtocols_ = addresses_.length;\n        for (uint256 i; i < addresses_.length; ) {\n            try IFluidProtocol(addresses_[i]).TYPE() returns (uint256 protocolType_) {\n                curType_ = protocolType_;\n            } catch {\n                curType_ = VAULT_T1_TYPE;\n            }\n\n            if (curType_ != type_) {\n                addresses_[i] = address(0);\n                --filteredProtocols_;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        filtered_ = new address[](filteredProtocols_);\n        uint256 index_;\n        unchecked {\n            for (uint256 i; i < addresses_.length; ) {\n                if (addresses_[i] != address(0)) {\n                    filtered_[index_] = addresses_[i];\n                    ++index_;\n                }\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/liquidityCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\nimport { LiquiditySlotsLink } from \"./liquiditySlotsLink.sol\";\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\n\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\n/// borrow rate, withdrawal / borrow limits, revenue amount.\nlibrary LiquidityCalcs {\n    error FluidLiquidityCalcsError(uint256 errorId_);\n\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\n    event BorrowRateMaxCap();\n\n    /// @dev constants as from Liquidity variables.sol\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X15 = 0x7fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                  CALC EXCHANGE PRICES                  /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\n    function calcExchangePrices(\n        uint256 exchangePricesAndConfig_\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\n        // Extracting exchange prices\n        supplyExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\n            X64;\n        borrowExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\n            X64;\n\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\n        }\n\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\n\n        unchecked {\n            // last timestamp can not be > current timestamp\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\n\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\n                X15;\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // calculate new borrow exchange price.\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\n            borrowExchangePrice_ +=\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\n\n            // FOR SUPPLY EXCHANGE PRICE:\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\n            //\n            // Example:\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\n            // yield is 10 (so half a year must have passed).\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 20%) = 62,5%\n            // supplyRate = (40% * (100% - 10%)) * = 36% * 62,5% = 22.5%\n            // increase in supplyExchangePrice, assuming 100 as previous price.\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\n\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\n\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\n\n            if (temp_ == 1) {\n                // if no raw supply: no exchange price update needed\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\n            if (temp_ & 1 == 1) {\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n                temp_ = temp_ >> 1;\n\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\n                // in the if statement a little above.\n\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\n                // so ratioSupplyYield must come out as 2.5 (250%).\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\n                temp_ =\n                    // utilization * (100% + 100% / supplyRatio)\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\n                    (FOUR_DECIMALS);\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\n            } else {\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n                temp_ = temp_ >> 1;\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\n\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\n                temp_ =\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\n                    (1e27 *\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\n                        (FOUR_DECIMALS + temp_)) /\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\n            }\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\n\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\n            if (borrowRatio_ & 1 == 1) {\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\n\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\n            } else {\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\n            }\n\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\n\n            // 2. calculate supply rate\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\n            // but more suppliers not earning interest.\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\n                temp_ * // ratioSupplyYield\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\n\n            // 3. calculate increase in supply exchange price\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                     CALC REVENUE                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\n    /// and the current balance of the Fluid liquidity contract for the token.\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\n    /// @return revenueAmount_ collectable revenue amount\n    function calcRevenue(\n        uint256 totalAmounts_,\n        uint256 exchangePricesAndConfig_,\n        uint256 liquidityTokenBalance_\n    ) internal view returns (uint256 revenueAmount_) {\n        // @dev no need to super-optimize this method as it is only used by admin\n\n        // calculate the new exchange prices based on earned interest\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\n\n        // total supply = interest free + with interest converted from raw\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\n\n        if (totalSupply_ > 0) {\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\n            // ensure there is no possible case because of rounding etc. where this would revert,\n            // explicitly check if >\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\n            // can only be revenue.\n        } else {\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\n            revenueAmount_ = liquidityTokenBalance_;\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ =\n                block.timestamp -\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ =\n                block.timestamp -\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC RATES                        /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev Calculates new borrow rate from utilization for a token\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\n        // extract rate version: 4 bits (0xF) starting from bit 0\n        uint256 rateVersion_ = (rateData_ & 0xF);\n\n        if (rateVersion_ == 1) {\n            rate_ = calcRateV1(rateData_, utilization_);\n        } else if (rateVersion_ == 2) {\n            rate_ = calcRateV2(rateData_, utilization_);\n        } else {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\n        }\n\n        if (rate_ > X16) {\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\n            // this is unlikely to ever happen if configs stay within expected levels.\n            rate_ = X16;\n            // emit event to more easily become aware\n            emit BorrowRateMaxCap();\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e2 precision\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v1 (one kink) ------------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // else utilization is greater than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\n            x1_ = kink1_;\n            x2_ = FOUR_DECIMALS; // 100%\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e4 precision\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v2 (two kinks) -----------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 156 bits => 100-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink1\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\n            if (utilization_ < kink2_) {\n                // if utilization is less than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                x1_ = kink1_;\n                x2_ = kink2_;\n            } else {\n                // else utilization is greater than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\n                x1_ = kink2_;\n                x2_ = FOUR_DECIMALS;\n            }\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\n    function getTotalSupply(\n        uint256 totalAmounts_,\n        uint256 supplyExchangePrice_\n    ) internal pure returns (uint256 totalSupply_) {\n        // totalSupply_ => supplyInterestFree\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\n    function getTotalBorrow(\n        uint256 totalAmounts_,\n        uint256 borrowExchangePrice_\n    ) internal pure returns (uint256 totalBorrow_) {\n        // totalBorrow_ => borrowInterestFree\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n}\n"
    },
    "contracts/libraries/liquiditySlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\nlibrary LiquiditySlotsLink {\n    /// @dev storage slot for status at Liquidity\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\n    /// @dev storage slot for auths mapping at Liquidity\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\n    /// @dev storage slot for guardians mapping at Liquidity\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\n    /// @dev storage slot for user class mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\n    /// @dev storage slot for rateData mapping at Liquidity\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\n    /// @dev storage slot for totalAmounts mapping at Liquidity\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\n    /// @dev storage slot for user supply double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\n    /// @dev storage slot for user borrow double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // ExchangePricesAndConfig\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\n\n    // RateData:\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\n    // RateData: V1\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\n    // RateData: V2\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\n\n    // TotalAmounts\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\n\n    // Configs2\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/safeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\n\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\nlibrary SafeTransfer {\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 20000; // pass max. 20k gas for native transfers\n\n    error FluidSafeTransferError(uint256 errorId_);\n\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from_\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of `token_` to `to_`.\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of ` native token to `to_`.\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\n    function safeTransferNative(address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n}\n"
    },
    "contracts/libraries/tickMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that calculates number \"tick\" and \"ratioX96\" from this: ratioX96 = (1.0015^tick) * 2^96\n/// @notice this library is used in Fluid Vault protocol for optimiziation.\n/// @dev \"tick\" supports between -32767 and 32767. \"ratioX96\" supports between 37075072 and 169307877264527972847801929085841449095838922544595\nlibrary TickMath {\n    /// The minimum tick that can be passed in getRatioAtTick. 1.0015**-32767\n    int24 internal constant MIN_TICK = -32767;\n    /// The maximum tick that can be passed in getRatioAtTick. 1.0015**32767\n    int24 internal constant MAX_TICK = 32767;\n\n    uint256 internal constant FACTOR00 = 0x100000000000000000000000000000000;\n    uint256 internal constant FACTOR01 = 0xff9dd7de423466c20352b1246ce4856f; // 2^128/1.0015**1 = 339772707859149738855091969477551883631\n    uint256 internal constant FACTOR02 = 0xff3bd55f4488ad277531fa1c725a66d0; // 2^128/1.0015**2 = 339263812140938331358054887146831636176\n    uint256 internal constant FACTOR03 = 0xfe78410fd6498b73cb96a6917f853259; // 2^128/1.0015**4 = 338248306163758188337119769319392490073\n    uint256 internal constant FACTOR04 = 0xfcf2d9987c9be178ad5bfeffaa123273; // 2^128/1.0015**8 = 336226404141693512316971918999264834163\n    uint256 internal constant FACTOR05 = 0xf9ef02c4529258b057769680fc6601b3; // 2^128/1.0015**16 = 332218786018727629051611634067491389875\n    uint256 internal constant FACTOR06 = 0xf402d288133a85a17784a411f7aba082; // 2^128/1.0015**32 = 324346285652234375371948336458280706178\n    uint256 internal constant FACTOR07 = 0xe895615b5beb6386553757b0352bda90; // 2^128/1.0015**64 = 309156521885964218294057947947195947664\n    uint256 internal constant FACTOR08 = 0xd34f17a00ffa00a8309940a15930391a; // 2^128/1.0015**128 = 280877777739312896540849703637713172762 \n    uint256 internal constant FACTOR09 = 0xae6b7961714e20548d88ea5123f9a0ff; // 2^128/1.0015**256 = 231843708922198649176471782639349113087\n    uint256 internal constant FACTOR10 = 0x76d6461f27082d74e0feed3b388c0ca1; // 2^128/1.0015**512 = 157961477267171621126394973980180876449\n    uint256 internal constant FACTOR11 = 0x372a3bfe0745d8b6b19d985d9a8b85bb; // 2^128/1.0015**1024 = 73326833024599564193373530205717235131\n    uint256 internal constant FACTOR12 = 0x0be32cbee48979763cf7247dd7bb539d; // 2^128/1.0015**2048 = 15801066890623697521348224657638773661\n    uint256 internal constant FACTOR13 = 0x8d4f70c9ff4924dac37612d1e2921e;   // 2^128/1.0015**4096 = 733725103481409245883800626999235102\n    uint256 internal constant FACTOR14 = 0x4e009ae5519380809a02ca7aec77;     // 2^128/1.0015**8192 = 1582075887005588088019997442108535\n    uint256 internal constant FACTOR15 = 0x17c45e641b6e95dee056ff10;         // 2^128/1.0015**16384 = 7355550435635883087458926352\n\n    /// The minimum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MIN_TICK). ~ Equivalent to `(1 << 96) * (1.0015**-32767)`\n    uint256 internal constant MIN_RATIOX96 = 37075072;\n    /// The maximum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MAX_TICK).\n    /// ~ Equivalent to `(1 << 96) * (1.0015**32767)`, rounding etc. leading to minor difference\n    uint256 internal constant MAX_RATIOX96 = 169307877264527972847801929085841449095838922544595;\n\n    uint256 internal constant ZERO_TICK_SCALED_RATIO = 0x1000000000000000000000000; // 1 << 96 // 79228162514264337593543950336\n    uint256 internal constant _1E26 = 1e26;\n\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return ratioX96 ratio = (debt amount/collateral amount)\n    function getRatioAtTick(int tick) internal pure returns (uint256 ratioX96) {\n        assembly {\n            let absTick_ := sub(xor(tick, sar(255, tick)), sar(255, tick))\n\n            if gt(absTick_, MAX_TICK) {\n                revert(0, 0)\n            }\n            let factor_ := FACTOR00\n            if and(absTick_, 0x1) {\n                factor_ := FACTOR01\n            }\n            if and(absTick_, 0x2) {\n                factor_ := shr(128, mul(factor_, FACTOR02))\n            }\n            if and(absTick_, 0x4) {\n                factor_ := shr(128, mul(factor_, FACTOR03))\n            }\n            if and(absTick_, 0x8) {\n                factor_ := shr(128, mul(factor_, FACTOR04))\n            }\n            if and(absTick_, 0x10) {\n                factor_ := shr(128, mul(factor_, FACTOR05))\n            }\n            if and(absTick_, 0x20) {\n                factor_ := shr(128, mul(factor_, FACTOR06))\n            }\n            if and(absTick_, 0x40) {\n                factor_ := shr(128, mul(factor_, FACTOR07))\n            }\n            if and(absTick_, 0x80) {\n                factor_ := shr(128, mul(factor_, FACTOR08))\n            }\n            if and(absTick_, 0x100) {\n                factor_ := shr(128, mul(factor_, FACTOR09))\n            }\n            if and(absTick_, 0x200) {\n                factor_ := shr(128, mul(factor_, FACTOR10))\n            }\n            if and(absTick_, 0x400) {\n                factor_ := shr(128, mul(factor_, FACTOR11))\n            }\n            if and(absTick_, 0x800) {\n                factor_ := shr(128, mul(factor_, FACTOR12))\n            }\n            if and(absTick_, 0x1000) {\n                factor_ := shr(128, mul(factor_, FACTOR13))\n            }\n            if and(absTick_, 0x2000) {\n                factor_ := shr(128, mul(factor_, FACTOR14))\n            }\n            if and(absTick_, 0x4000) {\n                factor_ := shr(128, mul(factor_, FACTOR15))\n            }\n\n            let precision_ := 0\n            if iszero(and(tick, 0x8000000000000000000000000000000000000000000000000000000000000000)) {\n                factor_ := div(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, factor_)\n                // we round up in the division so getTickAtRatio of the output price is always consistent\n                if mod(factor_, 0x100000000) {\n                    precision_ := 1\n                }\n            }\n            ratioX96 := add(shr(32, factor_), precision_)\n        }\n    }\n\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\n    /// @dev Throws if ratioX96 > max ratio || ratioX96 < min ratio\n    /// @param ratioX96 The input ratio; ratio = (debt amount/collateral amount)\n    /// @return tick The output tick for the above formula. Returns in round down form. if tick is 123.23 then 123, if tick is -123.23 then returns -124\n    /// @return perfectRatioX96 perfect ratio for the above tick\n    function getTickAtRatio(uint256 ratioX96) internal pure returns (int tick, uint perfectRatioX96) {\n        assembly {\n            if or(gt(ratioX96, MAX_RATIOX96), lt(ratioX96, MIN_RATIOX96)) {\n                revert(0, 0)\n            }\n\n            let cond := lt(ratioX96, ZERO_TICK_SCALED_RATIO)\n            let factor_\n\n            if iszero(cond) {\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\n                factor_ := div(mul(ratioX96, _1E26), ZERO_TICK_SCALED_RATIO)\n            }\n            if cond {\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\n                factor_ := div(mul(ZERO_TICK_SCALED_RATIO, _1E26), ratioX96)\n            }\n\n            // put in https://www.wolframalpha.com/ whole equation: (1.0015^tick) * 2^96 * 10^26 / 79228162514264337593543950336\n\n            // for tick = 16384\n            // ratioX96 = (1.0015^16384) * 2^96 = 3665252098134783297721995888537077351735\n            // 3665252098134783297721995888537077351735 * 10^26 / 79228162514264337593543950336 =\n            // 4626198540796508716348404308345255985.06131964639489434655721\n            if iszero(lt(factor_, 4626198540796508716348404308345255985)) {\n                tick := or(tick, 0x4000)\n                factor_ := div(mul(factor_, _1E26), 4626198540796508716348404308345255985)\n            }\n            // for tick = 8192\n            // ratioX96 = (1.0015^8192) * 2^96 = 17040868196391020479062776466509865\n            // 17040868196391020479062776466509865 * 10^26 / 79228162514264337593543950336 =\n            // 21508599537851153911767490449162.3037648642153898377655505172\n            if iszero(lt(factor_, 21508599537851153911767490449162)) {\n                tick := or(tick, 0x2000)\n                factor_ := div(mul(factor_, _1E26), 21508599537851153911767490449162)\n            }\n            // for tick = 4096\n            // ratioX96 = (1.0015^4096) * 2^96 = 36743933851015821532611831851150\n            // 36743933851015821532611831851150 * 10^26 / 79228162514264337593543950336 =\n            // 46377364670549310883002866648.9777607649742626173648716941385\n            if iszero(lt(factor_, 46377364670549310883002866649)) {\n                tick := or(tick, 0x1000)\n                factor_ := div(mul(factor_, _1E26), 46377364670549310883002866649)\n            }\n            // for tick = 2048\n            // ratioX96 = (1.0015^2048) * 2^96 = 1706210527034005899209104452335\n            // 1706210527034005899209104452335 * 10^26 / 79228162514264337593543950336 =\n            // 2153540449365864845468344760.06357108484096046743300420319322\n            if iszero(lt(factor_, 2153540449365864845468344760)) {\n                tick := or(tick, 0x800)\n                factor_ := div(mul(factor_, _1E26), 2153540449365864845468344760)\n            }\n            // for tick = 1024\n            // ratioX96 = (1.0015^1024) * 2^96 = 367668226692760093024536487236\n            // 367668226692760093024536487236 * 10^26 / 79228162514264337593543950336 =\n            // 464062544207767844008185024.950588990554136265212906454481127\n            if iszero(lt(factor_, 464062544207767844008185025)) {\n                tick := or(tick, 0x400)\n                factor_ := div(mul(factor_, _1E26), 464062544207767844008185025)\n            }\n            // for tick = 512\n            // ratioX96 = (1.0015^512) * 2^96 = 170674186729409605620119663668\n            // 170674186729409605620119663668 * 10^26 / 79228162514264337593543950336 =\n            // 215421109505955298802281577.031879604792139232258508172947569\n            if iszero(lt(factor_, 215421109505955298802281577)) {\n                tick := or(tick, 0x200)\n                factor_ := div(mul(factor_, _1E26), 215421109505955298802281577)\n            }\n            // for tick = 256\n            // ratioX96 = (1.0015^256) * 2^96 = 116285004205991934861656513301\n            // 116285004205991934861656513301 * 10^26 / 79228162514264337593543950336 =\n            // 146772309890508740607270614.667650899656438875541505058062410\n            if iszero(lt(factor_, 146772309890508740607270615)) {\n                tick := or(tick, 0x100)\n                factor_ := div(mul(factor_, _1E26), 146772309890508740607270615)\n            }\n            // for tick = 128\n            // ratioX96 = (1.0015^128) * 2^96 = 95984619659632141743747099590\n            // 95984619659632141743747099590 * 10^26 / 79228162514264337593543950336 =\n            // 121149622323187099817270416.157248837742741760456796835775887\n            if iszero(lt(factor_, 121149622323187099817270416)) {\n                tick := or(tick, 0x80)\n                factor_ := div(mul(factor_, _1E26), 121149622323187099817270416)\n            }\n            // for tick = 64\n            // ratioX96 = (1.0015^64) * 2^96 = 87204845308406958006717891124\n            // 87204845308406958006717891124 * 10^26 / 79228162514264337593543950336 =\n            // 110067989135437147685980801.568068573422377364214113968609839\n            if iszero(lt(factor_, 110067989135437147685980801)) {\n                tick := or(tick, 0x40)\n                factor_ := div(mul(factor_, _1E26), 110067989135437147685980801)\n            }\n            // for tick = 32\n            // ratioX96 = (1.0015^32) * 2^96 = 83120873769022354029916374475\n            // 83120873769022354029916374475 * 10^26 / 79228162514264337593543950336 =\n            // 104913292358707887270979599.831816586773651266562785765558183\n            if iszero(lt(factor_, 104913292358707887270979600)) {\n                tick := or(tick, 0x20)\n                factor_ := div(mul(factor_, _1E26), 104913292358707887270979600)\n            }\n            // for tick = 16\n            // ratioX96 = (1.0015^16) * 2^96 = 81151180492336368327184716176\n            // 81151180492336368327184716176 * 10^26 / 79228162514264337593543950336 =\n            // 102427189924701091191840927.762844039579442328381455567932128\n            if iszero(lt(factor_, 102427189924701091191840928)) {\n                tick := or(tick, 0x10)\n                factor_ := div(mul(factor_, _1E26), 102427189924701091191840928)\n            }\n            // for tick = 8\n            // ratioX96 = (1.0015^8) * 2^96 = 80183906840906820640659903620\n            // 80183906840906820640659903620 * 10^26 / 79228162514264337593543950336 =\n            // 101206318935480056907421312.890625\n            if iszero(lt(factor_, 101206318935480056907421313)) {\n                tick := or(tick, 0x8)\n                factor_ := div(mul(factor_, _1E26), 101206318935480056907421313)\n            }\n            // for tick = 4\n            // ratioX96 = (1.0015^4) * 2^96 = 79704602139525152702959747603\n            // 79704602139525152702959747603 * 10^26 / 79228162514264337593543950336 =\n            // 100601351350506250000000000\n            if iszero(lt(factor_, 100601351350506250000000000)) {\n                tick := or(tick, 0x4)\n                factor_ := div(mul(factor_, _1E26), 100601351350506250000000000)\n            }\n            // for tick = 2\n            // ratioX96 = (1.0015^2) * 2^96 = 79466025265172787701084167660\n            // 79466025265172787701084167660 * 10^26 / 79228162514264337593543950336 =\n            // 100300225000000000000000000\n            if iszero(lt(factor_, 100300225000000000000000000)) {\n                tick := or(tick, 0x2)\n                factor_ := div(mul(factor_, _1E26), 100300225000000000000000000)\n            }\n            // for tick = 1\n            // ratioX96 = (1.0015^1) * 2^96 = 79347004758035734099934266261\n            // 79347004758035734099934266261 * 10^26 / 79228162514264337593543950336 =\n            // 100150000000000000000000000\n            if iszero(lt(factor_, 100150000000000000000000000)) {\n                tick := or(tick, 0x1)\n                factor_ := div(mul(factor_, _1E26), 100150000000000000000000000)\n            }\n            if iszero(cond) {\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\n                perfectRatioX96 := div(mul(ratioX96, _1E26), factor_)\n            }\n            if cond {\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\n                tick := not(tick)\n                perfectRatioX96 := div(mul(ratioX96, factor_), 100150000000000000000000000)\n            }\n            // perfect ratio should always be <= ratioX96\n            // not sure if it can ever be bigger but better to have extra checks\n            if gt(perfectRatioX96, ratioX96) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "contracts/liquidity/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    /// @notice struct to set borrow rate data for version 1\n    struct RateDataV1Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\n        uint256 kink;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink;\n        ///\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set borrow rate data for version 2\n    struct RateDataV2Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\n        uint256 kink1;\n        ///\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\n        uint256 kink2;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink1;\n        ///\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\n        uint256 rateAtUtilizationKink2;\n        ///\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set token config\n    struct TokenConfig {\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\n        uint256 fee;\n        ///\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\n        uint256 threshold;\n        ///\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\n        uint256 maxUtilization;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/liquidity/interfaces/iLiquidity.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IProxy } from \"../../infiniteProxy/interfaces/iProxy.sol\";\nimport { Structs as AdminModuleStructs } from \"../adminModule/structs.sol\";\n\ninterface IFluidLiquidityAdmin {\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\n    /// @param authsStatus_ array of structs setting allowed status for an address.\n    ///                     status true => add auth, false => remove auth\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\n\n    /// @notice adds/removes guardians. Only callable by Governance.\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\n    ///                         status true => add guardian, false => remove guardian\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\n\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\n    /// @param revenueCollector_  new revenue collector address\n    function updateRevenueCollector(address revenueCollector_) external;\n\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\n    /// @param newStatus_ new status\n    ///        status = 2 -> pause, status = 1 -> resume.\n    function changeStatus(uint256 newStatus_) external;\n\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\n\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\n\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\n    ///         Only callable by Auths.\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\n\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\n    ///         Only callable by Auths.\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\n\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param token_ token address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\n\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\n\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to pause operations for\n    /// @param supplyTokens_  token addresses to pause withdrawals for\n    /// @param borrowTokens_  token addresses to pause borrowings for\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to unpause operations for\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\n    /// @param borrowTokens_  token addresses to unpause borrowings for\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\n    /// @param tokens_  array of tokens to collect revenue for\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\n    function collectRevenue(address[] calldata tokens_) external;\n\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\n    /// @param tokens_ tokens to update exchange prices for\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\n    function updateExchangePrices(\n        address[] calldata tokens_\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\n}\n\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\n    /// @notice Single function which handles supply, withdraw, borrow & payback\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\n    /// @param withdrawTo_ if withdrawal then to which address\n    /// @param borrowTo_ if borrow then to which address\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\n    /// @return memVar3_ updated supplyExchangePrice\n    /// @return memVar4_ updated borrowExchangePrice\n    /// @dev to trigger skipping in / out transfers (gas optimization):\n    /// -  ` callbackData_` MUST be encoded so that \"from\" address is the last 20 bytes in the last 32 bytes slot,\n    ///     also for native token operations where liquidityCallback is not triggered!\n    ///     from address must come at last position if there is more data. I.e. encode like:\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\n    /// -   this \"from\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\n    ///     in the slot before (bytes 32 to 63)\n    /// -   `msg.value` must be 0.\n    /// -   Amounts must be either:\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\n}\n\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\n"
    },
    "contracts/oracle/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Error {\n    error FluidOracleError(uint256 errorId_);\n}\n"
    },
    "contracts/oracle/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |           FluidOracleL2           | \n    |__________________________________*/\n\n    /// @notice thrown when sequencer on a L2 has an outage and grace period has not yet passed.\n    uint256 internal constant FluidOracleL2__SequencerOutage = 60000;\n\n    /***********************************|\n    |     UniV3CheckCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the delta between main price source and check rate source is exceeding the allowed delta\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidPrice = 60001;\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidParams = 60002;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant UniV3CheckCLRSOracle__ExchangeRateZero = 60003;\n\n    /***********************************|\n    |           FluidOracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid info name is passed into a fluid oracle (e.g. not set or too long)\n    uint256 internal constant FluidOracle__InvalidInfoName = 60010;\n\n    /***********************************|\n    |            sUSDe Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDeOracle__InvalidParams = 60102;\n\n    /***********************************|\n    |           Pendle Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PendleOracle__InvalidParams = 60201;\n\n    /// @notice thrown when the Pendle market Oracle has not been initialized yet\n    uint256 internal constant PendleOracle__MarketNotInitialized = 60202;\n\n    /// @notice thrown when the Pendle market does not have 18 decimals\n    uint256 internal constant PendleOracle__MarketInvalidDecimals = 60203;\n\n    /// @notice thrown when the Pendle market returns an unexpected price\n    uint256 internal constant PendleOracle__InvalidPrice = 60204;\n\n    /***********************************|\n    |    CLRS2UniV3CheckCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant CLRS2UniV3CheckCLRSOracleL2__ExchangeRateZero = 60301;\n\n    /***********************************|\n    |    Ratio2xFallbackCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant Ratio2xFallbackCLRSOracleL2__ExchangeRateZero = 60311;\n\n    /***********************************|\n    |            WeETHsOracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHsOracle__InvalidParams = 60321;\n\n    /***********************************|\n    |        DexSmartColOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexSmartColOracle__InvalidParams = 60331;\n\n    /// @notice thrown when smart col is not enabled\n    uint256 internal constant DexSmartColOracle__SmartColNotEnabled = 60332;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexSmartColOracle__ExchangeRateZero = 60333;\n\n    /***********************************|\n    |        DexSmartDebtOracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexSmartDebtOracle__InvalidParams = 60341;\n\n    /// @notice thrown when smart debt is not enabled\n    uint256 internal constant DexSmartDebtOracle__SmartDebtNotEnabled = 60342;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexSmartDebtOracle__ExchangeRateZero = 60343;\n\n    /***********************************|\n    |            CappedRate           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant CappedRate__InvalidParams = 60351;\n\n    /// @notice thrown when caller is not authorized\n    uint256 internal constant CappedRate__Unauthorized = 60352;\n\n    /// @notice thrown when minimum diff for triggering update on the stared rate is not reached\n    uint256 internal constant CappedRate__MinUpdateDiffNotReached = 60353;\n\n    /// @notice thrown when the external rate source returns 0 for the new rate\n    uint256 internal constant CappedRate__NewRateZero = 60354;\n\n    /// @notice thrown when the new rate source does not fit in 192 bit storage uint, should never happen.\n    uint256 internal constant CappedRate__StorageOverflow = 60355;\n\n    /***********************************|\n    |            sUSDs Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDsOracle__InvalidParams = 60361;\n\n    /***********************************|\n    |            Peg Oracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PegOracle__InvalidParams = 60371;\n\n    /***********************************|\n    |              DexOracle            | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexOracle__InvalidParams = 60381;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexOracle__ExchangeRateZero = 60382;\n\n    /***********************************|\n    |           GenericOracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant GenericOracle__InvalidParams = 60401;\n\n    /// @notice thrown when reaching an unexepcted config state\n    uint256 internal constant GenericOracle__UnexpectedConfig = 60402;\n\n    /// @notice thrown when the exchange rate is zero\n    uint256 internal constant GenericOracle__RateZero = 60403;\n\n    /***********************************|\n    |          Chainlink Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant ChainlinkOracle__InvalidParams = 61001;\n\n    /***********************************|\n    |          UniswapV3 Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3Oracle__InvalidParams = 62001;\n\n    /// @notice thrown when constructor is called with invalid ordered seconds agos values\n    uint256 internal constant UniV3Oracle__InvalidSecondsAgos = 62002;\n\n    /// @notice thrown when constructor is called with invalid delta values > 100%\n    uint256 internal constant UniV3Oracle__InvalidDeltas = 62003;\n\n    /***********************************|\n    |            WstETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WstETHOracle__InvalidParams = 63001;\n\n    /***********************************|\n    |           Redstone Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant RedstoneOracle__InvalidParams = 64001;\n\n    /***********************************|\n    |          Fallback Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant FallbackOracle__InvalidParams = 65001;\n\n    /***********************************|\n    |       FallbackCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant FallbackCLRSOracle__ExchangeRateZero = 66001;\n\n    /***********************************|\n    |         WstETHCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant WstETHCLRSOracle__ExchangeRateZero = 67001;\n\n    /***********************************|\n    |        CLFallbackUniV3Oracle      | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant CLFallbackUniV3Oracle__ExchangeRateZero = 68001;\n\n    /***********************************|\n    |  WstETHCLRS2UniV3CheckCLRSOracle  | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant WstETHCLRS2UniV3CheckCLRSOracle__ExchangeRateZero = 69001;\n\n    /***********************************|\n    |             WeETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHOracle__InvalidParams = 70001;\n}\n"
    },
    "contracts/oracle/fluidOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"./interfaces/iFluidOracle.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { Error as OracleError } from \"./error.sol\";\n\n/// @title   FluidOracle\n/// @notice  Base contract that any Fluid Oracle must implement\nabstract contract FluidOracle is IFluidOracle, OracleError {\n    /// @dev short helper string to easily identify the oracle. E.g. token symbols\n    //\n    // using a bytes32 because string can not be immutable.\n    bytes32 private immutable _infoName;\n\n    /// @dev target decimals of the oracle when scaling to 1e27. E.g. for ETH / USDC it would be 15\n    /// because diff of ETH decimals to 1e27 is 9, and USDC has 6 decimals, so 6+9 = 15, e.g. 2029,047772120364926\n    /// For USDC / ETH: 21 + 18 = 39, e.g. 0,000492842018675092636829357843847601646\n    uint8 private immutable _targetDecimals;\n\n    constructor(string memory infoName_, uint8 targetDecimals_) {\n        if (bytes(infoName_).length > 32 || bytes(infoName_).length == 0) {\n            revert FluidOracleError(ErrorTypes.FluidOracle__InvalidInfoName);\n        }\n\n        if (targetDecimals_ < 15 || targetDecimals_ > 39) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__InvalidParams);\n        }\n        _targetDecimals = targetDecimals_;\n\n        // convert string to bytes32\n        bytes32 infoNameBytes32_;\n        assembly {\n            infoNameBytes32_ := mload(add(infoName_, 32))\n        }\n        _infoName = infoNameBytes32_;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function targetDecimals() external view returns (uint8) {\n        return _targetDecimals;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function infoName() external view returns (string memory) {\n        // convert bytes32 to string\n        uint256 length_;\n        while (length_ < 32 && _infoName[length_] != 0) {\n            length_++;\n        }\n        bytes memory infoNameBytes_ = new bytes(length_);\n        for (uint256 i; i < length_; i++) {\n            infoNameBytes_[i] = _infoName[i];\n        }\n        return string(infoNameBytes_);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() external view virtual returns (uint256 exchangeRate_);\n}\n"
    },
    "contracts/oracle/interfaces/iFluidOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidOracle {\n    /// @dev Deprecated. Use `getExchangeRateOperate()` and `getExchangeRateLiquidate()` instead. Only implemented for\n    ///      backwards compatibility.\n    function getExchangeRate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for operates\n    function getExchangeRateOperate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for liquidations\n    function getExchangeRateLiquidate() external view returns (uint256 exchangeRate_);\n\n    /// @notice helper string to easily identify the oracle. E.g. token symbols\n    function infoName() external view returns (string memory);\n\n    /// @notice target decimals of the returned oracle rate when scaling to 1e27. E.g. for ETH / USDC it would be 15\n    /// because diff of ETH decimals to 1e27 is 9, and USDC has 6 decimals, so 6+9 = 15, e.g. 2029,047772120364926\n    /// For USDC / ETH: 21 + 18 = 39, e.g. 0,000492842018675092636829357843847601646\n    function targetDecimals() external view returns (uint8);\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/iLiquidityResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Structs as LiquidityStructs } from \"../../../periphery/resolvers/liquidity/structs.sol\";\n\ninterface IFluidLiquidityResolver {\n    /// @notice gets the `revenueAmount_` for a `token_`.\n    function getRevenue(address token_) external view returns (uint256 revenueAmount_);\n\n    /// @notice address of contract that gets sent the revenue. Configurable by governance\n    function getRevenueCollector() external view returns (address);\n\n    /// @notice Liquidity contract paused status: status = 1 -> normal. status = 2 -> paused.\n    function getStatus() external view returns (uint256);\n\n    /// @notice checks if `auth_` is an allowed auth on Liquidity.\n    /// Auths can set most config values. E.g. contracts that automate certain flows like e.g. adding a new fToken.\n    /// Governance can add/remove auths. Governance is auth by default.\n    function isAuth(address auth_) external view returns (uint256);\n\n    /// @notice checks if `guardian_` is an allowed Guardian on Liquidity.\n    /// Guardians can pause lower class users.\n    /// Governance can add/remove guardians. Governance is guardian by default.\n    function isGuardian(address guardian_) external view returns (uint256);\n\n    /// @notice gets user class for `user_`. Class defines which protocols can be paused by guardians.\n    /// Currently there are 2 classes: 0 can be paused by guardians. 1 cannot be paused by guardians.\n    /// New protocols are added as class 0 and will be upgraded to 1 over time.\n    function getUserClass(address user_) external view returns (uint256);\n\n    /// @notice gets exchangePricesAndConfig packed uint256 storage slot for `token_`.\n    function getExchangePricesAndConfig(address token_) external view returns (uint256);\n\n    /// @notice gets rateConfig packed uint256 storage slot for `token_`.\n    function getRateConfig(address token_) external view returns (uint256);\n\n    /// @notice gets totalAmounts packed uint256 storage slot for `token_`.\n    function getTotalAmounts(address token_) external view returns (uint256);\n\n    /// @notice gets configs2 packed uint256 storage slot for `token_`.\n    function getConfigs2(address token_) external view returns (uint256);\n\n    /// @notice gets userSupply data packed uint256 storage slot for `user_` and `token_`.\n    function getUserSupply(address user_, address token_) external view returns (uint256);\n\n    /// @notice gets userBorrow data packed uint256 storage slot for `user_` and `token_`.\n    function getUserBorrow(address user_, address token_) external view returns (uint256);\n\n    /// @notice returns all `listedTokens_` at the Liquidity contract. Once configured, a token can never be removed.\n    function listedTokens() external view returns (address[] memory listedTokens_);\n\n    /// @notice get the Rate config data `rateData_` for a `token_` compiled from the packed uint256 rateConfig storage slot\n    function getTokenRateData(address token_) external view returns (LiquidityStructs.RateData memory rateData_);\n\n    /// @notice get the Rate config datas `rateDatas_` for multiple `tokens_` compiled from the packed uint256 rateConfig storage slot\n    function getTokensRateData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.RateData[] memory rateDatas_);\n\n    /// @notice returns general data for `token_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokenData(\n        address token_\n    ) external view returns (LiquidityStructs.OverallTokenData memory overallTokenData_);\n\n    /// @notice returns general data for multiple `tokens_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokensData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns general data for all `listedTokens()` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getAllOverallTokensData()\n        external\n        view\n        returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserSupplyData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData memory userSupplyData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleSupplyData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserBorrowData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData memory userBorrowData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleBorrowData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `supplyTokens_`\n    ///     and returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `borrowTokens_`\n    function getUserMultipleBorrowSupplyData(\n        address user_,\n        address[] calldata supplyTokens_,\n        address[] calldata borrowTokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallSupplyTokensData_,\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallBorrowTokensData_\n        );\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs as AdminModuleStructs } from \"../../../liquidity/adminModule/structs.sol\";\n\nabstract contract Structs {\n    struct RateData {\n        uint256 version;\n        AdminModuleStructs.RateDataV1Params rateDataV1;\n        AdminModuleStructs.RateDataV2Params rateDataV2;\n    }\n\n    struct OverallTokenData {\n        uint256 borrowRate;\n        uint256 supplyRate;\n        uint256 fee; // revenue fee\n        uint256 lastStoredUtilization;\n        uint256 storageUpdateThreshold;\n        uint256 lastUpdateTimestamp;\n        uint256 supplyExchangePrice;\n        uint256 borrowExchangePrice;\n        uint256 supplyRawInterest;\n        uint256 supplyInterestFree;\n        uint256 borrowRawInterest;\n        uint256 borrowInterestFree;\n        uint256 totalSupply;\n        uint256 totalBorrow;\n        uint256 revenue;\n        uint256 maxUtilization; // maximum allowed utilization\n        RateData rateData;\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserSupplyData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 supply; // user supply amount\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\n        uint256 withdrawalLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\n        uint256 baseWithdrawalLimit;\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\n        uint256 withdrawableUntilLimit;\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserBorrowData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 borrow; // user borrow amount\n        uint256 borrowLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseBorrowLimit;\n        uint256 maxBorrowLimit;\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\n    }\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexT1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexT1 {\n    error FluidDexError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares);\n\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\n\n    /// @notice returns the dex id\n    function DEX_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndOracle;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) external view returns (CollateralReserves memory c_);\n\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) external view returns (DebtReserves memory d_);\n\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\n    function getPricesAndExchangePrices() external;\n\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount in and callback functionality\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of tokens to swap in\n    /// @param amountOutMin_ The minimum amount of tokens to receive after swap\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapInWithCallback(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Swap tokens with perfect amount out and callback functionality\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOutWithCallback(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(uint token0Amt_, uint token1Amt_, uint maxSharesAmt_, address to_) external returns (uint shares_);\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) external returns (uint withdrawAmt_);\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) external payable returns (uint paybackAmt_);\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(uint[] memory secondsAgos_) external view returns (Oracle[] memory twaps_, uint currentPrice_);\n}\n"
    },
    "contracts/protocols/dex/poolT1/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct InitializeVariables {\n        bool smartCol;\n        uint token0ColAmt;\n        bool smartDebt;\n        uint token0DebtAmt;\n        uint centerPrice;\n        uint fee;\n        uint revenueCut;\n        uint upperPercent;\n        uint lowerPercent;\n        uint upperShiftThreshold;\n        uint lowerShiftThreshold;\n        uint thresholdShiftTime;\n        uint centerPriceAddress;\n        uint hookAddress;\n        uint maxCenterPrice;\n        uint minCenterPrice;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/protocols/vault/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Error {\n    error FluidVaultError(uint256 errorId_);\n\n    /// @notice used to simulate liquidation to find the maximum liquidatable amounts\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n}\n"
    },
    "contracts/protocols/vault/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |           Vault Factory           | \n    |__________________________________*/\n\n    uint256 internal constant VaultFactory__InvalidOperation = 30001;\n    uint256 internal constant VaultFactory__Unauthorized = 30002;\n    uint256 internal constant VaultFactory__SameTokenNotAllowed = 30003;\n    uint256 internal constant VaultFactory__InvalidParams = 30004;\n    uint256 internal constant VaultFactory__InvalidVault = 30005;\n    uint256 internal constant VaultFactory__InvalidVaultAddress = 30006;\n    uint256 internal constant VaultFactory__OnlyDelegateCallAllowed = 30007;\n\n    /***********************************|\n    |            Vault                  | \n    |__________________________________*/\n\n    /// @notice thrown at reentrancy\n    uint256 internal constant Vault__AlreadyEntered = 31001;\n\n    /// @notice thrown when user sends deposit & borrow amount as 0\n    uint256 internal constant Vault__InvalidOperateAmount = 31002;\n\n    /// @notice thrown when msg.value is not in sync with native token deposit or payback\n    uint256 internal constant Vault__InvalidMsgValueOperate = 31003;\n\n    /// @notice thrown when msg.sender is not the owner of the vault\n    uint256 internal constant Vault__NotAnOwner = 31004;\n\n    /// @notice thrown when user's position does not exist. Sending the wrong index from the frontend\n    uint256 internal constant Vault__TickIsEmpty = 31005;\n\n    /// @notice thrown when the user's position is above CF and the user tries to make it more risky by trying to withdraw or borrow\n    uint256 internal constant Vault__PositionAboveCF = 31006;\n\n    /// @notice thrown when the top tick is not initialized. Happens if the vault is totally new or all the user's left\n    uint256 internal constant Vault__TopTickDoesNotExist = 31007;\n\n    /// @notice thrown when msg.value in liquidate is not in sync payback\n    uint256 internal constant Vault__InvalidMsgValueLiquidate = 31008;\n\n    /// @notice thrown when slippage is more on liquidation than what the liquidator sent\n    uint256 internal constant Vault__ExcessSlippageLiquidation = 31009;\n\n    /// @notice thrown when msg.sender is not the rebalancer/reserve contract\n    uint256 internal constant Vault__NotRebalancer = 31010;\n\n    /// @notice thrown when NFT of one vault interacts with the NFT of other vault\n    uint256 internal constant Vault__NftNotOfThisVault = 31011;\n\n    /// @notice thrown when the token is not initialized on the liquidity contract\n    uint256 internal constant Vault__TokenNotInitialized = 31012;\n\n    /// @notice thrown when admin updates fallback if a non-auth calls vault\n    uint256 internal constant Vault__NotAnAuth = 31013;\n\n    /// @notice thrown in operate when user tries to witdhraw more collateral than deposited\n    uint256 internal constant Vault__ExcessCollateralWithdrawal = 31014;\n\n    /// @notice thrown in operate when user tries to payback more debt than borrowed\n    uint256 internal constant Vault__ExcessDebtPayback = 31015;\n\n    /// @notice thrown when user try to withdrawal more than operate's withdrawal limit\n    uint256 internal constant Vault__WithdrawMoreThanOperateLimit = 31016;\n\n    /// @notice thrown when caller of liquidityCallback is not Liquidity\n    uint256 internal constant Vault__InvalidLiquidityCallbackAddress = 31017;\n\n    /// @notice thrown when reentrancy is not already on\n    uint256 internal constant Vault__NotEntered = 31018;\n\n    /// @notice thrown when someone directly calls operate or secondary implementation contract\n    uint256 internal constant Vault__OnlyDelegateCallAllowed = 31019;\n\n    /// @notice thrown when the safeTransferFrom for a token amount failed\n    uint256 internal constant Vault__TransferFromFailed = 31020;\n\n    /// @notice thrown when exchange price overflows while updating on storage\n    uint256 internal constant Vault__ExchangePriceOverFlow = 31021;\n\n    /// @notice thrown when debt to liquidate amt is sent wrong\n    uint256 internal constant Vault__InvalidLiquidationAmt = 31022;\n\n    /// @notice thrown when user debt or collateral goes above 2**128 or below -2**128\n    uint256 internal constant Vault__UserCollateralDebtExceed = 31023;\n\n    /// @notice thrown if on liquidation branch debt becomes lower than 100\n    uint256 internal constant Vault__BranchDebtTooLow = 31024;\n\n    /// @notice thrown when tick's debt is less than 10000\n    uint256 internal constant Vault__TickDebtTooLow = 31025;\n\n    /// @notice thrown when the received new liquidity exchange price is of unexpected value (< than the old one)\n    uint256 internal constant Vault__LiquidityExchangePriceUnexpected = 31026;\n\n    /// @notice thrown when user's debt is less than 10000\n    uint256 internal constant Vault__UserDebtTooLow = 31027;\n\n    /// @notice thrown when on only payback and only deposit the ratio of position increases\n    uint256 internal constant Vault__InvalidPaybackOrDeposit = 31028;\n\n    /// @notice thrown when liquidation just happens of a single partial or when there's nothing to liquidate\n    uint256 internal constant Vault__InvalidLiquidation = 31029;\n\n    /// @notice thrown when msg.value is sent wrong in rebalance\n    uint256 internal constant Vault__InvalidMsgValueInRebalance = 31030;\n\n    /// @notice thrown when nothing rebalanced\n    uint256 internal constant Vault__NothingToRebalance = 31031;\n\n    /// @notice thrown on unforseen liquidation scenarios. Might never come in use.\n    uint256 internal constant Vault__LiquidationReverts = 31032;\n\n    /// @notice thrown when oracle price is > 1e54\n    uint256 internal constant Vault__InvalidOraclePrice = 31033;\n\n    /// @notice thrown when constants are not set properly via contructor\n    uint256 internal constant Vault__ImproperConstantsSetup = 31034;\n\n    /// @notice thrown when externally calling fetchLatestPosition function\n    uint256 internal constant Vault__FetchLatestPositionFailed = 31035;\n\n    /// @notice thrown when dex callback is not from dex\n    uint256 internal constant Vault__InvalidDexCallbackAddress = 31036;\n\n    /// @notice thrown when dex callback is already set\n    uint256 internal constant Vault__DexFromAddressAlreadySet = 31037;\n\n    /// @notice thrown when an invalid min / max amounts config is passed to rebalance()\n    uint256 internal constant Vault__InvalidMinMaxInRebalance = 31038;\n\n    /***********************************|\n    |              ERC721               | \n    |__________________________________*/\n\n    uint256 internal constant ERC721__InvalidParams = 32001;\n    uint256 internal constant ERC721__Unauthorized = 32002;\n    uint256 internal constant ERC721__InvalidOperation = 32003;\n    uint256 internal constant ERC721__UnsafeRecipient = 32004;\n    uint256 internal constant ERC721__OutOfBoundsIndex = 32005;\n\n    /***********************************|\n    |            Vault Admin            | \n    |__________________________________*/\n\n    /// @notice thrown when admin tries to setup invalid value which are crossing limits\n    uint256 internal constant VaultAdmin__ValueAboveLimit = 33001;\n\n    /// @notice when someone directly calls admin implementation contract\n    uint256 internal constant VaultAdmin__OnlyDelegateCallAllowed = 33002;\n\n    /// @notice thrown when auth sends NFT ID as 0 while collecting dust debt\n    uint256 internal constant VaultAdmin__NftIdShouldBeNonZero = 33003;\n\n    /// @notice thrown when trying to collect dust debt of NFT which is not of this vault\n    uint256 internal constant VaultAdmin__NftNotOfThisVault = 33004;\n\n    /// @notice thrown when dust debt of NFT is 0, meaning nothing to collect\n    uint256 internal constant VaultAdmin__DustDebtIsZero = 33005;\n\n    /// @notice thrown when final debt after liquidation is not 0, meaning position 100% liquidated\n    uint256 internal constant VaultAdmin__FinalDebtShouldBeZero = 33006;\n\n    /// @notice thrown when NFT is not liquidated state\n    uint256 internal constant VaultAdmin__NftNotLiquidated = 33007;\n\n    /// @notice thrown when total absorbed dust debt is 0\n    uint256 internal constant VaultAdmin__AbsorbedDustDebtIsZero = 33008;\n\n    /// @notice thrown when address is set as 0\n    uint256 internal constant VaultAdmin__AddressZeroNotAllowed = 33009;\n\n    /***********************************|\n    |            Vault Rewards          | \n    |__________________________________*/\n\n    uint256 internal constant VaultRewards__Unauthorized = 34001;\n    uint256 internal constant VaultRewards__AddressZero = 34002;\n    uint256 internal constant VaultRewards__InvalidParams = 34003;\n    uint256 internal constant VaultRewards__NewMagnifierSameAsOldMagnifier = 34004;\n    uint256 internal constant VaultRewards__NotTheInitiator = 34005;\n    uint256 internal constant VaultRewards__NotTheGovernance = 34006;\n    uint256 internal constant VaultRewards__AlreadyStarted = 34007;\n    uint256 internal constant VaultRewards__RewardsNotStartedOrEnded = 34008;\n    uint256 internal constant VaultRewards__InvalidStartTime = 34009;\n    uint256 internal constant VaultRewards__AlreadyEnded = 34010;\n\n    /***********************************|\n    |          Vault DEX Types          | \n    |__________________________________*/\n\n    uint256 internal constant VaultDex__InvalidOperateAmount = 35001;\n    uint256 internal constant VaultDex__DebtSharesPaidMoreThanAvailableLiquidation = 35002;\n\n    /***********************************|\n    |        Vault Borrow Rewards       | \n    |__________________________________*/\n\n    uint256 internal constant VaultBorrowRewards__Unauthorized = 36001;\n    uint256 internal constant VaultBorrowRewards__AddressZero = 36002;\n    uint256 internal constant VaultBorrowRewards__InvalidParams = 36003;\n    uint256 internal constant VaultBorrowRewards__NewMagnifierSameAsOldMagnifier = 36004;\n    uint256 internal constant VaultBorrowRewards__NotTheInitiator = 36005;\n    uint256 internal constant VaultBorrowRewards__NotTheGovernance = 36006;\n    uint256 internal constant VaultBorrowRewards__AlreadyStarted = 36007;\n    uint256 internal constant VaultBorrowRewards__RewardsNotStartedOrEnded = 36008;\n    uint256 internal constant VaultBorrowRewards__InvalidStartTime = 36009;\n    uint256 internal constant VaultBorrowRewards__AlreadyEnded = 36010;\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVault.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\ninterface IFluidVault {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice returns the vault id\n    function TYPE() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Tokens {\n        address token0;\n        address token1;\n    }\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address operateImplementation;\n        address adminImplementation;\n        address secondaryImplementation;\n        address deployer; // address which deploys oracle\n        address supply; // either liquidity layer or DEX protocol\n        address borrow; // either liquidity layer or DEX protocol\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\n        uint256 vaultId;\n        uint256 vaultType;\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n\n    function rebalance(\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_\n    ) external payable returns (int supplyAmt_, int borrowAmt_);\n\n    /// @notice reverts with FluidLiquidateResult\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT1.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidVaultT1 {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice returns the vault factory address\n    function VAULT_FACTORY() external view returns (address);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address adminImplementation;\n        address secondaryImplementation;\n        address supplyToken;\n        address borrowToken;\n        uint8 supplyDecimals;\n        uint8 borrowDecimals;\n        uint vaultId;\n        bytes32 liquiditySupplyExchangePriceSlot;\n        bytes32 liquidityBorrowExchangePriceSlot;\n        bytes32 liquidityUserSupplySlot;\n        bytes32 liquidityUserBorrowSlot;\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    function operate(\n        uint256 nftId_, // if 0 then new position\n        int256 newCol_, // if negative then withdraw\n        int256 newDebt_, // if negative then payback\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint actualDebtAmt_, uint actualColAmt_);\n\n    function absorb() payable external;\n\n    function rebalance() external payable returns (int supplyAmt_, int borrowAmt_);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n}\n"
    },
    "contracts/protocols/vault/vaultT1/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Events {\n    /// @notice emitted when the supply rate magnifier config is updated\n    event LogUpdateSupplyRateMagnifier(uint supplyRateMagnifier_);\n\n    /// @notice emitted when the borrow rate magnifier config is updated\n    event LogUpdateBorrowRateMagnifier(uint borrowRateMagnifier_);\n\n    /// @notice emitted when the collateral factor config is updated\n    event LogUpdateCollateralFactor(uint collateralFactor_);\n\n    /// @notice emitted when the liquidation threshold config is updated\n    event LogUpdateLiquidationThreshold(uint liquidationThreshold_);\n\n    /// @notice emitted when the liquidation max limit config is updated\n    event LogUpdateLiquidationMaxLimit(uint liquidationMaxLimit_);\n\n    /// @notice emitted when the withdrawal gap config is updated\n    event LogUpdateWithdrawGap(uint withdrawGap_);\n\n    /// @notice emitted when the liquidation penalty config is updated\n    event LogUpdateLiquidationPenalty(uint liquidationPenalty_);\n\n    /// @notice emitted when the borrow fee config is updated\n    event LogUpdateBorrowFee(uint borrowFee_);\n\n    /// @notice emitted when the core setting configs are updated\n    event LogUpdateCoreSettings(\n        uint supplyRateMagnifier_,\n        uint borrowRateMagnifier_,\n        uint collateralFactor_,\n        uint liquidationThreshold_,\n        uint liquidationMaxLimit_,\n        uint withdrawGap_,\n        uint liquidationPenalty_,\n        uint borrowFee_\n    );\n\n    /// @notice emitted when the oracle is updated\n    event LogUpdateOracle(address indexed newOracle_);\n\n    /// @notice emitted when the allowed rebalancer is updated\n    event LogUpdateRebalancer(address indexed newRebalancer_);\n\n    /// @notice emitted when funds are rescued\n    event LogRescueFunds(address indexed token_);\n\n    /// @notice emitted when dust debt is absorbed for `nftIds_`\n    event LogAbsorbDustDebt(uint256[] nftIds_, uint256 absorbedDustDebt_);\n}\n"
    },
    "contracts/protocols/vault/vaultT1/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { Variables } from \"../common/variables.sol\";\nimport { Events } from \"./events.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { IFluidVaultT1 } from \"../../interfaces/iVaultT1.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { TickMath } from \"../../../../libraries/tickMath.sol\";\nimport { SafeTransfer } from \"../../../../libraries/safeTransfer.sol\";\n\n/// @notice Fluid Vault protocol Admin Module contract.\n///         Implements admin related methods to set configs such as liquidation params, rates\n///         oracle address etc.\n///         Methods are limited to be called via delegateCall only. Vault CoreModule (\"VaultT1\" contract)\n///         is expected to call the methods implemented here after checking the msg.sender is authorized.\n///         All methods update the exchange prices in storage before changing configs.\ncontract FluidVaultT1Admin is Variables, Events, Error {\n    uint private constant X8 = 0xff;\n    uint private constant X10 = 0x3ff;\n    uint private constant X16 = 0xffff;\n    uint private constant X19 = 0x7ffff;\n    uint private constant X24 = 0xffffff;\n    uint internal constant X64 = 0xffffffffffffffff;\n    uint private constant X96 = 0xffffffffffffffffffffffff;\n    address private constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address private immutable addressThis;\n\n    constructor() {\n        addressThis = address(this);\n    }\n\n    modifier _verifyCaller() {\n        if (address(this) == addressThis) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev updates exchange price on storage, called on all admin methods in combination with _verifyCaller modifier so\n    /// only called by authorized delegatecall\n    modifier _updateExchangePrice() {\n        IFluidVaultT1(address(this)).updateExchangePricesOnStorage();\n        _;\n    }\n\n    function _checkLiquidationMaxLimitAndPenalty(uint liquidationMaxLimit_, uint liquidationPenalty_) private pure {\n        // liquidation max limit with penalty should not go above 99.7%\n        // As liquidation with penalty can happen from liquidation Threshold to max limit\n        // If it goes above 100% than that means liquidator is getting more collateral than user's available\n        if ((liquidationMaxLimit_ + liquidationPenalty_) > 9970) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n    }\n\n    /// @notice updates the supply rate magnifier to `supplyRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateSupplyRateMagnifier(uint supplyRateMagnifier_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateSupplyRateMagnifier(supplyRateMagnifier_);\n\n        if (supplyRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000) |\n            supplyRateMagnifier_;\n    }\n\n    /// @notice updates the borrow rate magnifier to `borrowRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateBorrowRateMagnifier(uint borrowRateMagnifier_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowRateMagnifier(borrowRateMagnifier_);\n\n        if (borrowRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff) |\n            (borrowRateMagnifier_ << 16);\n    }\n\n    /// @notice updates the collateral factor to `collateralFactor_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateCollateralFactor(uint collateralFactor_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateCollateralFactor(collateralFactor_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\n\n        collateralFactor_ = collateralFactor_ / 10;\n\n        if (collateralFactor_ >= liquidationThreshold_) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffc00ffffffff) |\n            (collateralFactor_ << 32);\n    }\n\n    /// @notice updates the liquidation threshold to `liquidationThreshold_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationThreshold(uint liquidationThreshold_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationThreshold(liquidationThreshold_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint collateralFactor_ = ((vaultVariables2_ >> 32) & X10);\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\n\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n\n        if ((collateralFactor_ >= liquidationThreshold_) || (liquidationThreshold_ >= liquidationMaxLimit_))\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffff003ffffffffff) |\n            (liquidationThreshold_ << 42);\n    }\n\n    /// @notice updates the liquidation max limit to `liquidationMaxLimit_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationMaxLimit(uint liquidationMaxLimit_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationMaxLimit(liquidationMaxLimit_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\n        uint liquidationPenalty_ = ((vaultVariables2_ >> 72) & X10);\n\n        // both are in 1e2 decimals (1e2 = 1%)\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n\n        if (liquidationThreshold_ >= liquidationMaxLimit_)\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffc00fffffffffffff) |\n            (liquidationMaxLimit_ << 52);\n    }\n\n    /// @notice updates the withdrawal gap to `withdrawGap_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateWithdrawGap(uint withdrawGap_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateWithdrawGap(withdrawGap_);\n\n        withdrawGap_ = withdrawGap_ / 10;\n\n        // withdrawGap must not be > 100%\n        if (withdrawGap_ > 1000) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffff003fffffffffffffff) |\n            (withdrawGap_ << 62);\n    }\n\n    /// @notice updates the liquidation penalty to `liquidationPenalty_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationPenalty(uint liquidationPenalty_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationPenalty(liquidationPenalty_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\n\n        // Converting liquidationMaxLimit_ in 1e2 decimals (1e2 = 1%)\n        _checkLiquidationMaxLimitAndPenalty((liquidationMaxLimit_ * 10), liquidationPenalty_);\n\n        if (liquidationPenalty_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffc00ffffffffffffffffff) |\n            (liquidationPenalty_ << 72);\n    }\n\n    /// @notice updates the borrow fee to `borrowFee_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateBorrowFee(uint borrowFee_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowFee(borrowFee_);\n\n        if (borrowFee_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff003ffffffffffffffffffff) |\n            (borrowFee_ << 82);\n    }\n\n    /// @notice updates the all Vault core settings according to input params.\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\n    function updateCoreSettings(\n        uint256 supplyRateMagnifier_,\n        uint256 borrowRateMagnifier_,\n        uint256 collateralFactor_,\n        uint256 liquidationThreshold_,\n        uint256 liquidationMaxLimit_,\n        uint256 withdrawGap_,\n        uint256 liquidationPenalty_,\n        uint256 borrowFee_\n    ) public _updateExchangePrice _verifyCaller {\n        // emitting the event at the start as then we are updating numbers to store in a more optimized way\n        emit LogUpdateCoreSettings(\n            supplyRateMagnifier_,\n            borrowRateMagnifier_,\n            collateralFactor_,\n            liquidationThreshold_,\n            liquidationMaxLimit_,\n            withdrawGap_,\n            liquidationPenalty_,\n            borrowFee_\n        );\n\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        collateralFactor_ = collateralFactor_ / 10;\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n        withdrawGap_ = withdrawGap_ / 10;\n\n        if (\n            (supplyRateMagnifier_ > X16) ||\n            (borrowRateMagnifier_ > X16) ||\n            (collateralFactor_ >= liquidationThreshold_) ||\n            (liquidationThreshold_ >= liquidationMaxLimit_) ||\n            (withdrawGap_ > X10) ||\n            (liquidationPenalty_ > X10) ||\n            (borrowFee_ > X10)\n        ) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff00000000000000000000000) |\n            supplyRateMagnifier_ |\n            (borrowRateMagnifier_ << 16) |\n            (collateralFactor_ << 32) |\n            (liquidationThreshold_ << 42) |\n            (liquidationMaxLimit_ << 52) |\n            (withdrawGap_ << 62) |\n            (liquidationPenalty_ << 72) |\n            (borrowFee_ << 82);\n    }\n\n    /// @notice updates the Vault oracle to `newOracle_`. Must implement the FluidOracle interface.\n    function updateOracle(address newOracle_) public _updateExchangePrice _verifyCaller {\n        if (newOracle_ == address(0)) revert FluidVaultError(ErrorTypes.VaultAdmin__AddressZeroNotAllowed);\n\n        // Removing current oracle by masking only first 96 bits then inserting new oracle as bits\n        vaultVariables2 = (vaultVariables2 & X96) | (uint256(uint160(newOracle_)) << 96);\n\n        emit LogUpdateOracle(newOracle_);\n    }\n\n    /// @notice updates the allowed rebalancer to `newRebalancer_`.\n    function updateRebalancer(address newRebalancer_) public _updateExchangePrice _verifyCaller {\n        if (newRebalancer_ == address(0)) revert FluidVaultError(ErrorTypes.VaultAdmin__AddressZeroNotAllowed);\n\n        rebalancer = newRebalancer_;\n\n        emit LogUpdateRebalancer(newRebalancer_);\n    }\n\n    /// @notice sends any potentially stuck funds to Liquidity contract.\n    /// @dev this contract never holds any funds as all operations send / receive funds from user <-> Liquidity.\n    function rescueFunds(address token_) external _verifyCaller {\n        if (token_ == NATIVE_TOKEN) {\n            SafeTransfer.safeTransferNative(IFluidVaultT1(address(this)).LIQUIDITY(), address(this).balance);\n        } else {\n            SafeTransfer.safeTransfer(\n                token_,\n                IFluidVaultT1(address(this)).LIQUIDITY(),\n                IERC20(token_).balanceOf(address(this))\n            );\n        }\n\n        emit LogRescueFunds(token_);\n    }\n\n    /// @notice absorbs accumulated dust debt\n    /// @dev in decades if a lot of positions are 100% liquidated (aka absorbed) then dust debt can mount up\n    /// which is basically sort of an extra revenue for the protocol.\n    //\n    // this function might never come in use that's why adding it in admin module\n    function absorbDustDebt(uint[] memory nftIds_) public _verifyCaller {\n        uint256 vaultVariables_ = vaultVariables;\n        // re-entrancy check\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        uint nftId_;\n        uint posData_;\n        int posTick_;\n        uint tickId_;\n        uint posCol_;\n        uint posDebt_;\n        uint posDustDebt_;\n        uint tickData_;\n\n        uint absorbedDustDebt_ = absorbedDustDebt;\n\n        for (uint i = 0; i < nftIds_.length; ) {\n            nftId_ = nftIds_[i];\n            if (nftId_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftIdShouldBeNonZero);\n            }\n\n            // user's position data\n            posData_ = positionData[nftId_];\n\n            if (posData_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotOfThisVault);\n            }\n\n            posCol_ = (posData_ >> 45) & X64;\n            // Converting big number into normal number\n            posCol_ = (posCol_ >> 8) << (posCol_ & X8);\n\n            posDustDebt_ = (posData_ >> 109) & X64;\n            // Converting big number into normal number\n            posDustDebt_ = (posDustDebt_ >> 8) << (posDustDebt_ & X8);\n\n            if (posDustDebt_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__DustDebtIsZero);\n            }\n\n            // borrow position (has collateral & debt)\n            posTick_ = posData_ & 2 == 2 ? int((posData_ >> 2) & X19) : -int((posData_ >> 2) & X19);\n            tickId_ = (posData_ >> 21) & X24;\n\n            posDebt_ = (TickMath.getRatioAtTick(int24(posTick_)) * posCol_) >> 96;\n\n            // Tick data from user's tick\n            tickData_ = tickData[posTick_];\n\n            // Checking if tick is liquidated OR if the total IDs of tick is greater than user's tick ID\n            if (((tickData_ & 1) == 1) || (((tickData_ >> 1) & X24) > tickId_)) {\n                // User got liquidated\n                (, posDebt_, , , ) = IFluidVaultT1(address(this)).fetchLatestPosition(\n                    posTick_,\n                    tickId_,\n                    posDebt_,\n                    tickData_\n                );\n                if (posDebt_ > 0) {\n                    revert FluidVaultError(ErrorTypes.VaultAdmin__FinalDebtShouldBeZero);\n                }\n                // absorbing user's debt as it's 100% or almost 100% liquidated\n                absorbedDustDebt_ = absorbedDustDebt_ + posDustDebt_;\n                // making position as supply only\n                positionData[nftId_] = 1;\n            } else {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotLiquidated);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n\n        if (absorbedDustDebt_ == 0) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__AbsorbedDustDebtIsZero);\n        }\n\n        uint totalBorrow_ = (vaultVariables_ >> 146) & X64;\n        // Converting big number into normal number\n        totalBorrow_ = (totalBorrow_ >> 8) << (totalBorrow_ & X8);\n        // note: by default dust debt is not added into total borrow but on 100% liquidation (aka absorb) dust debt equivalent\n        // is removed from total borrow so adding it back again here\n        totalBorrow_ = totalBorrow_ + absorbedDustDebt_;\n        totalBorrow_ = BigMathMinified.toBigNumber(totalBorrow_, 56, 8, BigMathMinified.ROUND_UP);\n\n        // adding absorbed dust debt to total borrow so it will get included in the next rebalancing.\n        // there is some fuzziness here as when the position got fully liquidated (aka absorbed) the exchange price was different\n        // than what it'll be now. The fuzziness which will be extremely small so we can ignore it\n        // updating on storage\n        vaultVariables =\n            (vaultVariables_ & 0xfffffffffffc0000000000000003ffffffffffffffffffffffffffffffffffff) |\n            (totalBorrow_ << 146);\n\n        // updating on storage\n        absorbedDustDebt = 0;\n\n        emit LogAbsorbDustDebt(nftIds_, absorbedDustDebt_);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT1/common/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Variables {\n    /***********************************|\n    |         Storage Variables         |\n    |__________________________________*/\n\n    /// note: in all variables. For tick >= 0 are represented with bit as 1, tick < 0 are represented with bit as 0\n    /// note: read all the variables through storageRead.sol\n\n    /// note: vaultVariables contains vault variables which need regular updates through transactions\n    /// First 1 bit => 0 => re-entrancy. If 0 then allow transaction to go, else throw.\n    /// Next 1 bit => 1 => Is the current active branch liquidated? If true then check the branch's minima tick before creating a new position\n    /// If the new tick is greater than minima tick then initialize a new branch, make that as current branch & do proper linking\n    /// Next 1 bit => 2 => sign of topmost tick (0 -> negative; 1 -> positive)\n    /// Next 19 bits => 3-21 => absolute value of topmost tick\n    /// Next 30 bits => 22-51 => current branch ID\n    /// Next 30 bits => 52-81 => total branch ID\n    /// Next 64 bits => 82-145 => Total supply\n    /// Next 64 bits => 146-209 => Total borrow\n    /// Next 32 bits => 210-241 => Total positions\n    uint256 internal vaultVariables;\n\n    /// note: vaultVariables2 contains variables which do not update on every transaction. So mainly admin/auth set amount\n    /// First 16 bits => 0-15 => supply rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\n    /// Next 16 bits => 16-31 => borrow rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\n    /// Next 10 bits => 32-41 => collateral factor. 800 = 0.8 = 80% (max precision of 0.1%)\n    /// Next 10 bits => 42-51 => liquidation Threshold. 900 = 0.9 = 90% (max precision of 0.1%)\n    /// Next 10 bits => 52-61 => liquidation Max Limit. 950 = 0.95 = 95% (max precision of 0.1%) (above this 100% liquidation can happen)\n    /// Next 10 bits => 62-71 => withdraw gap. 100 = 0.1 = 10%. (max precision of 0.1%) (max 7 bits can also suffice for the requirement here of 0.1% to 10%). Needed to save some limits on withdrawals so liquidate can work seamlessly.\n    /// Next 10 bits => 72-81 => liquidation penalty. 100 = 0.01 = 1%. (max precision of 0.01%) (max liquidation penantly can be 10.23%). Applies when tick is in between liquidation Threshold & liquidation Max Limit.\n    /// Next 10 bits => 82-91 => borrow fee. 100 = 0.01 = 1%. (max precision of 0.01%) (max borrow fee can be 10.23%). Fees on borrow.\n    /// Next 4  bits => 92-95 => empty\n    /// Next 160 bits => 96-255 => Oracle address\n    uint256 internal vaultVariables2;\n\n    /// note: stores absorbed liquidity\n    /// First 128 bits raw debt amount\n    /// last 128 bits raw col amount\n    uint256 internal absorbedLiquidity;\n\n    /// position index => position data uint\n    /// if the entire variable is 0 (meaning not initialized) at the start that means no position at all\n    /// First 1 bit => 0 => position type (0 => borrow position; 1 => supply position)\n    /// Next 1 bit => 1 => sign of user's tick (0 => negative; 1 => positive)\n    /// Next 19 bits => 2-20 => absolute value of user's tick\n    /// Next 24 bits => 21-44 => user's tick's id\n    /// Below we are storing user's collateral & not debt, because the position can also be only collateral with no tick but it can never be only debt\n    /// Next 64 bits => 45-108 => user's supply amount. Debt will be calculated through supply & ratio.\n    /// Next 64 bits => 109-172 => user's dust debt amount. User's net debt = total debt - dust amount. Total debt is calculated through supply & ratio\n    /// User won't pay any extra interest on dust debt & hence we will not show it as a debt on UI. For user's there's no dust.\n    mapping(uint256 => uint256) internal positionData;\n\n    /// Tick has debt only keeps data of non liquidated positions. liquidated tick's data stays in branch itself\n    /// tick parent => uint (represents bool for 256 children)\n    /// parent of (i)th tick:-\n    /// if (i>=0) (i / 256);\n    /// else ((i + 1) / 256) - 1\n    /// first bit of the variable is the smallest tick & last bit is the biggest tick of that slot\n    mapping(int256 => uint256) internal tickHasDebt;\n\n    /// mapping tickId => tickData\n    /// Tick related data. Total debt & other things\n    /// First bit => 0 => If 1 then liquidated else not liquidated\n    /// Next 24 bits => 1-24 => Total IDs. ID should start from 1.\n    /// If not liquidated:\n    /// Next 64 bits => 25-88 => raw debt\n    /// If liquidated\n    /// The below 3 things are of last ID. This is to be updated when user creates a new position\n    /// Next 1 bit => 25 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated (100% liquidated)\n    /// Next 30 bits => 26-55 => branch ID where this tick got liquidated\n    /// Next 50 bits => 56-105 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    mapping(int256 => uint256) internal tickData;\n\n    /// tick id => previous tick id liquidation data. ID starts from 1\n    /// One tick ID contains 3 IDs of 80 bits in it, holding liquidation data of previously active but liquidated ticks\n    /// 81 bits data below\n    /// #### First 85 bits ####\n    /// 1st bit => 0 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 1-30 => branch ID where this tick got liquidated\n    /// Next 50 bits => 31-80 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    /// #### Second 85 bits ####\n    /// 85th bit => 85 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 86-115 => branch ID where this tick got liquidated\n    /// Next 50 bits => 116-165 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    /// #### Third 85 bits ####\n    /// 170th bit => 170 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 171-200 => branch ID where this tick got liquidated\n    /// Next 50 bits => 201-250 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    mapping(int256 => mapping(uint256 => uint256)) internal tickId;\n\n    /// mapping branchId => branchData\n    /// First 2 bits => 0-1 => if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\n    /// merged means the branch is merged into it's base branch\n    /// closed means all the users are 100% liquidated\n    /// Next 1 bit => 2 => minima tick sign of this branch. Will only be there if any liquidation happened.\n    /// Next 19 bits => 3-21 => minima tick of this branch. Will only be there if any liquidation happened.\n    /// Next 30 bits => 22-51 => Partials of minima tick of branch this is connected to. 0 if master branch.\n    /// Next 64 bits => 52-115 Debt liquidity at this branch. Similar to last's top tick data. Remaining debt will move here from tickData after first liquidation\n    /// If not merged\n    /// Next 50 bits => 116-165 => Debt factor or of this branch. (35 bits coefficient | 15 bits expansion)\n    /// If merged\n    /// Next 50 bits => 116-165 => Connection/adjustment debt factor of this branch with the next branch.\n    /// If closed\n    /// Next 50 bits => 116-165 => Debt factor as 0. As all the user's positions are now fully gone\n    /// following values are present always again (merged / not merged / closed)\n    /// Next 30 bits => 166-195 => Branch's ID with which this branch is connected. If 0 then that means this is the master branch\n    /// Next 1 bit => 196 => sign of minima tick of branch this is connected to. 0 if master branch.\n    /// Next 19 bits => 197-215 => minima tick of branch this is connected to. 0 if master branch.\n    mapping(uint256 => uint256) internal branchData;\n\n    /// Exchange prices are in 1e12\n    /// First 64 bits => 0-63 => Liquidity's collateral token supply exchange price\n    /// First 64 bits => 64-127 => Liquidity's debt token borrow exchange price\n    /// First 64 bits => 128-191 => Vault's collateral token supply exchange price\n    /// First 64 bits => 192-255 => Vault's debt token borrow exchange price\n    uint256 internal rates;\n\n    /// address of rebalancer\n    address internal rebalancer;\n\n    uint256 internal absorbedDustDebt;\n}\n"
    },
    "contracts/protocols/vault/vaultT2/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract VaultT2Events {\n    /// @notice emitted when the supply rate config is updated\n    event LogUpdateSupplyRate(int supplyRate_);\n\n    /// @notice emitted when the borrow rate magnifier config is updated\n    event LogUpdateBorrowRateMagnifier(uint borrowRateMagnifier_);\n\n    /// @notice emitted when the core setting configs are updated\n    event LogUpdateCoreSettings(\n        int supplyRate_,\n        uint borrowRateMagnifier_,\n        uint collateralFactor_,\n        uint liquidationThreshold_,\n        uint liquidationMaxLimit_,\n        uint withdrawGap_,\n        uint liquidationPenalty_,\n        uint borrowFee_\n    );\n}\n"
    },
    "contracts/protocols/vault/vaultT2/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidVaultAdmin } from \"../../vaultTypesCommon/adminModule/main.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { VaultT2Events } from \"./events.sol\";\n\n/// @notice Fluid Vault protocol Admin Module contract.\n///         Implements admin related methods to set configs such as liquidation params, rates\n///         oracle address etc.\n///         Methods are limited to be called via delegateCall only. Vault CoreModule is expected\n///         to call the methods implemented here after checking the msg.sender is authorized.\n///         All methods update the exchange prices in storage before changing configs.\ncontract FluidVaultT2Admin is FluidVaultAdmin, VaultT2Events {\n    /// @notice updates the supply rate. Input in 1e2 (1% = 100, 100% = 10_000). If positive then incentives else charging\n    function updateSupplyRate(int supplyRate_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateSupplyRate(supplyRate_);\n\n        if ((supplyRate_ > int(X15)) || (-supplyRate_ > int(X15))) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        uint supplyRateToInsert_ = supplyRate_ < 0 ? (uint(-supplyRate_) << 1) : (uint(1) | (uint(supplyRate_) << 1));\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000) |\n            supplyRateToInsert_;\n    }\n\n    /// @notice updates the borrow rate magnifier to `borrowRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateBorrowRateMagnifier(uint borrowRateMagnifier_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowRateMagnifier(borrowRateMagnifier_);\n\n        if (borrowRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff) |\n            (borrowRateMagnifier_ << 16);\n    }\n\n    /// @notice updates the all Vault core settings according to input params.\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\n    function updateCoreSettings(\n        int256 supplyRate_,\n        uint256 borrowRateMagnifier_,\n        uint256 collateralFactor_,\n        uint256 liquidationThreshold_,\n        uint256 liquidationMaxLimit_,\n        uint256 withdrawGap_,\n        uint256 liquidationPenalty_,\n        uint256 borrowFee_\n    ) public _updateExchangePrice _verifyCaller {\n        // emitting the event at the start as then we are updating numbers to store in a more optimized way\n        emit LogUpdateCoreSettings(\n            supplyRate_,\n            borrowRateMagnifier_,\n            collateralFactor_,\n            liquidationThreshold_,\n            liquidationMaxLimit_,\n            withdrawGap_,\n            liquidationPenalty_,\n            borrowFee_\n        );\n\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        collateralFactor_ = collateralFactor_ / 10;\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n        withdrawGap_ = withdrawGap_ / 10;\n\n        if (\n            (supplyRate_ > int(X15)) ||\n            (-supplyRate_ > int(X15)) ||\n            (borrowRateMagnifier_ > X16) ||\n            (collateralFactor_ >= liquidationThreshold_) ||\n            (liquidationThreshold_ >= liquidationMaxLimit_) ||\n            (withdrawGap_ > X10) ||\n            (liquidationPenalty_ > X10) ||\n            (borrowFee_ > X10)\n        ) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        uint supplyRateToInsert_ = supplyRate_ < 0 ? (uint(-supplyRate_) << 1) : (uint(1) | (uint(supplyRate_) << 1));\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff00000000000000000000000) |\n            supplyRateToInsert_ |\n            (borrowRateMagnifier_ << 16) |\n            (collateralFactor_ << 32) |\n            (liquidationThreshold_ << 42) |\n            (liquidationMaxLimit_ << 52) |\n            (withdrawGap_ << 62) |\n            (liquidationPenalty_ << 72) |\n            (borrowFee_ << 82);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT3/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract VaultT3Events {\n    /// @notice emitted when the supply rate magnifier config is updated\n    event LogUpdateSupplyRateMagnifier(uint supplyRateMagnifier_);\n\n    /// @notice emitted when the borrow rate config is updated\n    event LogUpdateBorrowRate(int borrowRate_);\n\n    /// @notice emitted when the core setting configs are updated\n    event LogUpdateCoreSettings(\n        uint supplyRateMagnifier_,\n        int borrowRate_,\n        uint collateralFactor_,\n        uint liquidationThreshold_,\n        uint liquidationMaxLimit_,\n        uint withdrawGap_,\n        uint liquidationPenalty_,\n        uint borrowFee_\n    );\n}\n"
    },
    "contracts/protocols/vault/vaultT3/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidVaultAdmin } from \"../../vaultTypesCommon/adminModule/main.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { VaultT3Events } from \"./events.sol\";\n\n/// @notice Fluid Vault protocol Admin Module contract.\n///         Implements admin related methods to set configs such as liquidation params, rates\n///         oracle address etc.\n///         Methods are limited to be called via delegateCall only. Vault CoreModule is expected\n///         to call the methods implemented here after checking the msg.sender is authorized.\n///         All methods update the exchange prices in storage before changing configs.\ncontract FluidVaultT3Admin is FluidVaultAdmin, VaultT3Events {\n    /// @notice updates the supply rate magnifier to `supplyRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateSupplyRateMagnifier(uint supplyRateMagnifier_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateSupplyRateMagnifier(supplyRateMagnifier_);\n\n        if (supplyRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000) |\n            supplyRateMagnifier_;\n    }\n\n    /// @notice updates the borrow rate. Input in 1e2 (1% = 100, 100% = 10_000). If positive then charging else incentives\n    function updateBorrowRate(int borrowRate_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowRate(borrowRate_);\n\n        if ((borrowRate_ > int(X15)) || (-borrowRate_ > int(X15))) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        uint borrowRateToInsert_ = borrowRate_ < 0 ? ((uint(-borrowRate_) << 1)) : (uint(1) | (uint(borrowRate_) << 1));\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff) |\n            (borrowRateToInsert_ << 16);\n    }\n\n    /// @notice updates the all Vault core settings according to input params.\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\n    function updateCoreSettings(\n        uint256 supplyRateMagnifier_,\n        int256 borrowRate_,\n        uint256 collateralFactor_,\n        uint256 liquidationThreshold_,\n        uint256 liquidationMaxLimit_,\n        uint256 withdrawGap_,\n        uint256 liquidationPenalty_,\n        uint256 borrowFee_\n    ) public _updateExchangePrice _verifyCaller {\n        // emitting the event at the start as then we are updating numbers to store in a more optimized way\n        emit LogUpdateCoreSettings(\n            supplyRateMagnifier_,\n            borrowRate_,\n            collateralFactor_,\n            liquidationThreshold_,\n            liquidationMaxLimit_,\n            withdrawGap_,\n            liquidationPenalty_,\n            borrowFee_\n        );\n\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        collateralFactor_ = collateralFactor_ / 10;\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n        withdrawGap_ = withdrawGap_ / 10;\n\n        if (\n            (supplyRateMagnifier_ > X16) ||\n            (borrowRate_ > int(X15)) ||\n            (-borrowRate_ > int(X15)) ||\n            (collateralFactor_ >= liquidationThreshold_) ||\n            (liquidationThreshold_ >= liquidationMaxLimit_) ||\n            (withdrawGap_ > X10) ||\n            (liquidationPenalty_ > X10) ||\n            (borrowFee_ > X10)\n        ) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        uint borrowRateToInsert_ = borrowRate_ < 0 ? ((uint(-borrowRate_) << 1)) : (uint(1) | (uint(borrowRate_) << 1));\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff00000000000000000000000) |\n            supplyRateMagnifier_ |\n            (borrowRateToInsert_ << 16) |\n            (collateralFactor_ << 32) |\n            (liquidationThreshold_ << 42) |\n            (liquidationMaxLimit_ << 52) |\n            (withdrawGap_ << 62) |\n            (liquidationPenalty_ << 72) |\n            (borrowFee_ << 82);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Events {\n    /// @notice emitted when the collateral factor config is updated\n    event LogUpdateCollateralFactor(uint collateralFactor_);\n\n    /// @notice emitted when the liquidation threshold config is updated\n    event LogUpdateLiquidationThreshold(uint liquidationThreshold_);\n\n    /// @notice emitted when the liquidation max limit config is updated\n    event LogUpdateLiquidationMaxLimit(uint liquidationMaxLimit_);\n\n    /// @notice emitted when the withdrawal gap config is updated\n    event LogUpdateWithdrawGap(uint withdrawGap_);\n\n    /// @notice emitted when the liquidation penalty config is updated\n    event LogUpdateLiquidationPenalty(uint liquidationPenalty_);\n\n    /// @notice emitted when the borrow fee config is updated\n    event LogUpdateBorrowFee(uint borrowFee_);\n\n    /// @notice emitted when the oracle is updated\n    event LogUpdateOracle(uint indexed deploymentNonce_, address indexed newOracle_);\n\n    /// @notice emitted when the allowed rebalancer is updated\n    event LogUpdateRebalancer(address indexed newRebalancer_);\n\n    /// @notice emitted when funds are rescued\n    event LogRescueFunds(address indexed token_);\n\n    /// @notice emitted when dust debt is absorbed for `nftIds_`\n    event LogAbsorbDustDebt(uint256[] nftIds_, uint256 absorbedDustDebt_);\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IFluidOracle } from \"../../../../oracle/fluidOracle.sol\";\n\nimport { Variables } from \"../common/variables.sol\";\nimport { Events } from \"./events.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { IFluidVault } from \"../../interfaces/iVault.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { TickMath } from \"../../../../libraries/tickMath.sol\";\nimport { AddressCalcs } from \"../../../../libraries/addressCalcs.sol\";\nimport { SafeTransfer } from \"../../../../libraries/safeTransfer.sol\";\n\n/// @notice Fluid Vault protocol Admin Module contract.\n///         Implements admin related methods to set configs such as liquidation params, rates\n///         oracle address etc.\n///         Methods are limited to be called via delegateCall only. Vault CoreModule (\"VaultT1\" contract)\n///         is expected to call the methods implemented here after checking the msg.sender is authorized.\n///         All methods update the exchange prices in storage before changing configs.\nabstract contract FluidVaultAdmin is Variables, Events, Error {\n    uint internal constant X8 = 0xff;\n    uint internal constant X10 = 0x3ff;\n    uint internal constant X15 = 0x7fff;\n    uint internal constant X16 = 0xffff;\n    uint internal constant X19 = 0x7ffff;\n    uint internal constant X24 = 0xffffff;\n    uint internal constant X30 = 0x3fffffff;\n    uint internal constant X64 = 0xffffffffffffffff;\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address internal immutable addressThis;\n\n    constructor() {\n        addressThis = address(this);\n    }\n\n    modifier _verifyCaller() {\n        if (address(this) == addressThis) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev updates exchange price on storage, called on all admin methods in combination with _verifyCaller modifier so\n    /// only called by authorized delegatecall\n    modifier _updateExchangePrice() {\n        IFluidVault(address(this)).updateExchangePricesOnStorage();\n        _;\n    }\n\n    function _checkLiquidationMaxLimitAndPenalty(uint liquidationMaxLimit_, uint liquidationPenalty_) internal pure {\n        // liquidation max limit with penalty should not go above 99.7%\n        // As liquidation with penalty can happen from liquidation Threshold to max limit\n        // If it goes above 100% than that means liquidator is getting more collateral than user's available\n        if ((liquidationMaxLimit_ + liquidationPenalty_) > 9970) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n    }\n\n    /// @notice updates the collateral factor to `collateralFactor_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateCollateralFactor(uint collateralFactor_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateCollateralFactor(collateralFactor_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\n\n        collateralFactor_ = collateralFactor_ / 10;\n\n        if (collateralFactor_ >= liquidationThreshold_) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffc00ffffffff) |\n            (collateralFactor_ << 32);\n    }\n\n    /// @notice updates the liquidation threshold to `liquidationThreshold_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationThreshold(uint liquidationThreshold_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationThreshold(liquidationThreshold_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint collateralFactor_ = ((vaultVariables2_ >> 32) & X10);\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\n\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n\n        if ((collateralFactor_ >= liquidationThreshold_) || (liquidationThreshold_ >= liquidationMaxLimit_))\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffff003ffffffffff) |\n            (liquidationThreshold_ << 42);\n    }\n\n    /// @notice updates the liquidation max limit to `liquidationMaxLimit_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationMaxLimit(uint liquidationMaxLimit_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationMaxLimit(liquidationMaxLimit_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\n        uint liquidationPenalty_ = ((vaultVariables2_ >> 72) & X10);\n\n        // both are in 1e2 decimals (1e2 = 1%)\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n\n        if (liquidationThreshold_ >= liquidationMaxLimit_)\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffc00fffffffffffff) |\n            (liquidationMaxLimit_ << 52);\n    }\n\n    /// @notice updates the withdrawal gap to `withdrawGap_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateWithdrawGap(uint withdrawGap_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateWithdrawGap(withdrawGap_);\n\n        withdrawGap_ = withdrawGap_ / 10;\n\n        // withdrawGap must not be > 100%\n        if (withdrawGap_ > 1000) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffff003fffffffffffffff) |\n            (withdrawGap_ << 62);\n    }\n\n    /// @notice updates the liquidation penalty to `liquidationPenalty_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationPenalty(uint liquidationPenalty_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationPenalty(liquidationPenalty_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\n\n        // Converting liquidationMaxLimit_ in 1e2 decimals (1e2 = 1%)\n        _checkLiquidationMaxLimitAndPenalty((liquidationMaxLimit_ * 10), liquidationPenalty_);\n\n        if (liquidationPenalty_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffc00ffffffffffffffffff) |\n            (liquidationPenalty_ << 72);\n    }\n\n    /// @notice updates the borrow fee to `borrowFee_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateBorrowFee(uint borrowFee_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowFee(borrowFee_);\n\n        if (borrowFee_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff003ffffffffffffffffffff) |\n            (borrowFee_ << 82);\n    }\n\n    /// @notice updates the Vault oracle to `newOracleNonce_`. Must implement the FluidOracle interface.\n    function updateOracle(uint newOracleNonce_) public _updateExchangePrice _verifyCaller {\n        if (newOracleNonce_ > X30) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        // masking to remove old oracle and keep all the other values intact\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffc0000000fffffffffffffffffffffff) |\n            (newOracleNonce_ << 92);\n\n        IFluidVault.ConstantViews memory c_ = IFluidVault(address(this)).constantsView();\n\n        address oracle_ = AddressCalcs.addressCalc(c_.deployer, newOracleNonce_);\n\n        // checking if oracle address follows the standard\n        IFluidOracle(oracle_).getExchangeRateOperate();\n        IFluidOracle(oracle_).getExchangeRateLiquidate();\n\n        emit LogUpdateOracle(newOracleNonce_, oracle_);\n    }\n\n    /// @notice updates the allowed rebalancer to `newRebalancer_`.\n    function updateRebalancer(address newRebalancer_) public _updateExchangePrice _verifyCaller {\n        if (newRebalancer_ == address(0)) revert FluidVaultError(ErrorTypes.VaultAdmin__AddressZeroNotAllowed);\n\n        rebalancer = newRebalancer_;\n\n        emit LogUpdateRebalancer(newRebalancer_);\n    }\n\n    /// @notice sends any potentially stuck funds to Liquidity contract.\n    /// @dev this contract never holds any funds as all operations send / receive funds from user <-> Liquidity.\n    function rescueFunds(address token_) external _verifyCaller {\n        if (token_ == NATIVE_TOKEN) {\n            SafeTransfer.safeTransferNative(IFluidVault(address(this)).LIQUIDITY(), address(this).balance);\n        } else {\n            SafeTransfer.safeTransfer(\n                token_,\n                IFluidVault(address(this)).LIQUIDITY(),\n                IERC20(token_).balanceOf(address(this))\n            );\n        }\n\n        emit LogRescueFunds(token_);\n    }\n\n    /// @notice absorbs accumulated dust debt\n    /// @dev in decades if a lot of positions are 100% liquidated (aka absorbed) then dust debt can mount up\n    /// which is basically sort of an extra revenue for the protocol.\n    //\n    // this function might never come in use that's why adding it in admin module\n    function absorbDustDebt(uint[] memory nftIds_) public _verifyCaller {\n        uint256 vaultVariables_ = vaultVariables;\n        // re-entrancy check\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        uint nftId_;\n        uint posData_;\n        int posTick_;\n        uint tickId_;\n        uint posCol_;\n        uint posDebt_;\n        uint posDustDebt_;\n        uint tickData_;\n\n        uint absorbedDustDebt_ = absorbedDustDebt;\n\n        for (uint i = 0; i < nftIds_.length; ) {\n            nftId_ = nftIds_[i];\n            if (nftId_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftIdShouldBeNonZero);\n            }\n\n            // user's position data\n            posData_ = positionData[nftId_];\n\n            if (posData_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotOfThisVault);\n            }\n\n            posCol_ = (posData_ >> 45) & X64;\n            // Converting big number into normal number\n            posCol_ = (posCol_ >> 8) << (posCol_ & X8);\n\n            posDustDebt_ = (posData_ >> 109) & X64;\n            // Converting big number into normal number\n            posDustDebt_ = (posDustDebt_ >> 8) << (posDustDebt_ & X8);\n\n            if (posDustDebt_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__DustDebtIsZero);\n            }\n\n            // borrow position (has collateral & debt)\n            posTick_ = posData_ & 2 == 2 ? int((posData_ >> 2) & X19) : -int((posData_ >> 2) & X19);\n            tickId_ = (posData_ >> 21) & X24;\n\n            posDebt_ = (TickMath.getRatioAtTick(int24(posTick_)) * posCol_) >> 96;\n\n            // Tick data from user's tick\n            tickData_ = tickData[posTick_];\n\n            // Checking if tick is liquidated OR if the total IDs of tick is greater than user's tick ID\n            if (((tickData_ & 1) == 1) || (((tickData_ >> 1) & X24) > tickId_)) {\n                // User got liquidated\n                (, posDebt_, , , ) = IFluidVault(address(this)).fetchLatestPosition(\n                    posTick_,\n                    tickId_,\n                    posDebt_,\n                    tickData_\n                );\n                if (posDebt_ > 0) {\n                    revert FluidVaultError(ErrorTypes.VaultAdmin__FinalDebtShouldBeZero);\n                }\n                // absorbing user's debt as it's 100% or almost 100% liquidated\n                absorbedDustDebt_ = absorbedDustDebt_ + posDustDebt_;\n                // making position as supply only\n                positionData[nftId_] = 1;\n            } else {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotLiquidated);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n\n        if (absorbedDustDebt_ == 0) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__AbsorbedDustDebtIsZero);\n        }\n\n        uint totalBorrow_ = (vaultVariables_ >> 146) & X64;\n        // Converting big number into normal number\n        totalBorrow_ = (totalBorrow_ >> 8) << (totalBorrow_ & X8);\n        // note: by default dust debt is not added into total borrow but on 100% liquidation (aka absorb) dust debt equivalent\n        // is removed from total borrow so adding it back again here\n        totalBorrow_ = totalBorrow_ + absorbedDustDebt_;\n        totalBorrow_ = BigMathMinified.toBigNumber(totalBorrow_, 56, 8, BigMathMinified.ROUND_UP);\n\n        // adding absorbed dust debt to total borrow so it will get included in the next rebalancing.\n        // there is some fuzziness here as when the position got fully liquidated (aka absorbed) the exchange price was different\n        // than what it'll be now. The fuzziness which will be extremely small so we can ignore it\n        // updating on storage\n        vaultVariables =\n            (vaultVariables_ & 0xfffffffffffc0000000000000003ffffffffffffffffffffffffffffffffffff) |\n            (totalBorrow_ << 146);\n\n        // updating on storage\n        absorbedDustDebt = 0;\n\n        emit LogAbsorbDustDebt(nftIds_, absorbedDustDebt_);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/common/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Variables {\n    /***********************************|\n    |         Storage Variables         |\n    |__________________________________*/\n\n    /// note: in all variables. For tick >= 0 are represented with bit as 1, tick < 0 are represented with bit as 0\n    /// note: read all the variables through storageRead.sol\n\n    /// note: vaultVariables contains vault variables which need regular updates through transactions\n    /// First 1 bit => 0 => re-entrancy. If 0 then allow transaction to go, else throw.\n    /// Next 1 bit => 1 => Is the current active branch liquidated? If true then check the branch's minima tick before creating a new position\n    /// If the new tick is greater than minima tick then initialize a new branch, make that as current branch & do proper linking\n    /// Next 1 bit => 2 => sign of topmost tick (0 -> negative; 1 -> positive)\n    /// Next 19 bits => 3-21 => absolute value of topmost tick\n    /// Next 30 bits => 22-51 => current branch ID\n    /// Next 30 bits => 52-81 => total branch ID\n    /// Next 64 bits => 82-145 => Total supply\n    /// Next 64 bits => 146-209 => Total borrow\n    /// Next 32 bits => 210-241 => Total positions\n    uint256 internal vaultVariables;\n\n    /// note: vaultVariables2 contains variables which do not update on every transaction. So mainly admin/auth set amount\n    /// First 16 bits => 0-15 => supply rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\n    /// Next 16 bits => 16-31 => borrow rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\n    /// Next 10 bits => 32-41 => collateral factor. 800 = 0.8 = 80% (max precision of 0.1%)\n    /// Next 10 bits => 42-51 => liquidation Threshold. 900 = 0.9 = 90% (max precision of 0.1%)\n    /// Next 10 bits => 52-61 => liquidation Max Limit. 950 = 0.95 = 95% (max precision of 0.1%) (above this 100% liquidation can happen)\n    /// Next 10 bits => 62-71 => withdraw gap. 100 = 0.1 = 10%. (max precision of 0.1%) (max 7 bits can also suffice for the requirement here of 0.1% to 10%). Needed to save some limits on withdrawals so liquidate can work seamlessly.\n    /// Next 10 bits => 72-81 => liquidation penalty. 100 = 0.01 = 1%. (max precision of 0.01%) (max liquidation penantly can be 10.23%). Applies when tick is in between liquidation Threshold & liquidation Max Limit.\n    /// Next 10 bits => 82-91 => borrow fee. 100 = 0.01 = 1%. (max precision of 0.01%) (max borrow fee can be 10.23%). Fees on borrow.\n    /// Next 30 bits => 92-121 => bits to calculate address of oracle\n    /// Next 33 bits => 122-154 => last update timestamp\n    uint256 internal vaultVariables2;\n\n    /// note: stores absorbed liquidity\n    /// First 128 bits raw debt amount\n    /// last 128 bits raw col amount\n    uint256 internal absorbedLiquidity;\n\n    /// position index => position data uint\n    /// if the entire variable is 0 (meaning not initialized) at the start that means no position at all\n    /// First 1 bit => 0 => position type (0 => borrow position; 1 => supply position)\n    /// Next 1 bit => 1 => sign of user's tick (0 => negative; 1 => positive)\n    /// Next 19 bits => 2-20 => absolute value of user's tick\n    /// Next 24 bits => 21-44 => user's tick's id\n    /// Below we are storing user's collateral & not debt, because the position can also be only collateral with no tick but it can never be only debt\n    /// Next 64 bits => 45-108 => user's supply amount. Debt will be calculated through supply & ratio.\n    /// Next 64 bits => 109-172 => user's dust debt amount. User's net debt = total debt - dust amount. Total debt is calculated through supply & ratio\n    /// User won't pay any extra interest on dust debt & hence we will not show it as a debt on UI. For user's there's no dust.\n    mapping(uint256 => uint256) internal positionData;\n\n    /// Tick has debt only keeps data of non liquidated positions. liquidated tick's data stays in branch itself\n    /// tick parent => uint (represents bool for 256 children)\n    /// parent of (i)th tick:-\n    /// if (i>=0) (i / 256);\n    /// else ((i + 1) / 256) - 1\n    /// first bit of the variable is the smallest tick & last bit is the biggest tick of that slot\n    mapping(int256 => uint256) internal tickHasDebt;\n\n    /// mapping tickId => tickData\n    /// Tick related data. Total debt & other things\n    /// First bit => 0 => If 1 then liquidated else not liquidated\n    /// Next 24 bits => 1-24 => Total IDs. ID should start from 1.\n    /// If not liquidated:\n    /// Next 64 bits => 25-88 => raw debt\n    /// If liquidated\n    /// The below 3 things are of last ID. This is to be updated when user creates a new position\n    /// Next 1 bit => 25 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated (100% liquidated)\n    /// Next 30 bits => 26-55 => branch ID where this tick got liquidated\n    /// Next 50 bits => 56-105 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    mapping(int256 => uint256) internal tickData;\n\n    /// tick id => previous tick id liquidation data. ID starts from 1\n    /// One tick ID contains 3 IDs of 80 bits in it, holding liquidation data of previously active but liquidated ticks\n    /// 81 bits data below\n    /// #### First 85 bits ####\n    /// 1st bit => 0 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 1-30 => branch ID where this tick got liquidated\n    /// Next 50 bits => 31-80 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    /// #### Second 85 bits ####\n    /// 85th bit => 85 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 86-115 => branch ID where this tick got liquidated\n    /// Next 50 bits => 116-165 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    /// #### Third 85 bits ####\n    /// 170th bit => 170 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 171-200 => branch ID where this tick got liquidated\n    /// Next 50 bits => 201-250 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    mapping(int256 => mapping(uint256 => uint256)) internal tickId;\n\n    /// mapping branchId => branchData\n    /// First 2 bits => 0-1 => if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\n    /// merged means the branch is merged into it's base branch\n    /// closed means all the users are 100% liquidated\n    /// Next 1 bit => 2 => minima tick sign of this branch. Will only be there if any liquidation happened.\n    /// Next 19 bits => 3-21 => minima tick of this branch. Will only be there if any liquidation happened.\n    /// Next 30 bits => 22-51 => Partials of minima tick of branch this is connected to. 0 if master branch.\n    /// Next 64 bits => 52-115 Debt liquidity at this branch. Similar to last's top tick data. Remaining debt will move here from tickData after first liquidation\n    /// If not merged\n    /// Next 50 bits => 116-165 => Debt factor or of this branch. (35 bits coefficient | 15 bits expansion)\n    /// If merged\n    /// Next 50 bits => 116-165 => Connection/adjustment debt factor of this branch with the next branch.\n    /// If closed\n    /// Next 50 bits => 116-165 => Debt factor as 0. As all the user's positions are now fully gone\n    /// following values are present always again (merged / not merged / closed)\n    /// Next 30 bits => 166-195 => Branch's ID with which this branch is connected. If 0 then that means this is the master branch\n    /// Next 1 bit => 196 => sign of minima tick of branch this is connected to. 0 if master branch.\n    /// Next 19 bits => 197-215 => minima tick of branch this is connected to. 0 if master branch.\n    mapping(uint256 => uint256) internal branchData;\n\n    /// Exchange prices are in 1e12\n    /// First 64 bits => 0-63 => Liquidity's collateral token supply exchange price\n    /// First 64 bits => 64-127 => Liquidity's debt token borrow exchange price\n    /// First 64 bits => 128-191 => Vault's collateral token supply exchange price\n    /// First 64 bits => 192-255 => Vault's debt token borrow exchange price\n    uint256 internal rates;\n\n    /// address of rebalancer\n    address internal rebalancer;\n\n    uint256 internal absorbedDustDebt;\n\n    address internal dexFromAddress;\n}\n"
    },
    "contracts/reserve/interfaces/iReserveContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\n\ninterface IFluidReserveContract {\n    function isRebalancer(address user) external returns (bool);\n\n    function initialize(\n        address[] memory _auths,\n        address[] memory _rebalancers,\n        IFluidLiquidity liquidity_,\n        address owner_\n    ) external;\n\n    function rebalanceFToken(address protocol_) external;\n\n    function rebalanceVault(address protocol_) external;\n\n    function transferFunds(address token_) external;\n\n    function getProtocolTokens(address protocol_) external;\n\n    function updateAuth(address auth_, bool isAuth_) external;\n\n    function updateRebalancer(address rebalancer_, bool isRebalancer_) external;\n\n    function approve(address[] memory protocols_, address[] memory tokens_, uint256[] memory amounts_) external;\n\n    function revoke(address[] memory protocols_, address[] memory tokens_) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}