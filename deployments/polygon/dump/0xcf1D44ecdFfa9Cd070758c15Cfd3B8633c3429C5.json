{
  "address": "0xcf1D44ecdFfa9Cd070758c15Cfd3B8633c3429C5",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IFluidVaultResolver",
          "name": "vaultResolver_",
          "type": "address"
        },
        {
          "internalType": "contract IFluidLiquidity",
          "name": "liquidity_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "errorId_",
          "type": "uint256"
        }
      ],
      "name": "FluidLiquidityCalcsError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FluidVaultLiquidationsResolver__AddressZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FluidVaultLiquidationsResolver__InvalidParams",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LIQUIDITY",
      "outputs": [
        {
          "internalType": "contract IFluidLiquidity",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VAULT_RESOLVER",
      "outputs": [
        {
          "internalType": "contract IFluidVaultResolver",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenIn_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenOut_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "outAmt_",
          "type": "uint256"
        }
      ],
      "name": "approxOutput",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "inAmt_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "approxOutAmt_",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenIn_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenOut_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "inAmt_",
          "type": "uint256"
        }
      ],
      "name": "exactInput",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "actualInAmt_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "outAmt_",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "targetApproxOutAmt_",
          "type": "uint256"
        }
      ],
      "name": "filterToApproxOutAmt",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "filteredSwaps_",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "actualInAmt_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "approxOutAmt_",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "targetInAmt_",
          "type": "uint256"
        }
      ],
      "name": "filterToTargetInAmt",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "filteredSwaps_",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "actualInAmt_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "approxOutAmt_",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllSwapPaths",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "protocol",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            }
          ],
          "internalType": "struct Structs.SwapPath[]",
          "name": "paths_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllVaultsSwap",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllVaultsSwapData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "inAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmt",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "withAbsorb",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "ratio",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.SwapData[]",
          "name": "withoutAbsorb_",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "inAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmt",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "withAbsorb",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "ratio",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.SwapData[]",
          "name": "withAbsorb_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllVaultsSwapRaw",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "tokensIn_",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "tokensOut_",
          "type": "address[]"
        }
      ],
      "name": "getAnySwapPaths",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "protocol",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            }
          ],
          "internalType": "struct Structs.SwapPath[]",
          "name": "paths_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "tokensIn_",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "tokensOut_",
          "type": "address[]"
        }
      ],
      "name": "getAnySwaps",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "tokensIn_",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "tokensOut_",
          "type": "address[]"
        }
      ],
      "name": "getAnySwapsRaw",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "protocol_",
          "type": "address"
        }
      ],
      "name": "getSwapForProtocol",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap",
          "name": "swap_",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenIn_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenOut_",
          "type": "address"
        }
      ],
      "name": "getSwapPaths",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "protocol",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            }
          ],
          "internalType": "struct Structs.SwapPath[]",
          "name": "paths_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap",
          "name": "swap_",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "receiver_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "slippage_",
          "type": "uint256"
        }
      ],
      "name": "getSwapTx",
      "outputs": [
        {
          "internalType": "address",
          "name": "target_",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "calldata_",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        },
        {
          "internalType": "address",
          "name": "receiver_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "slippage_",
          "type": "uint256"
        }
      ],
      "name": "getSwapTxs",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "targets_",
          "type": "address[]"
        },
        {
          "internalType": "bytes[]",
          "name": "calldatas_",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenIn_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenOut_",
          "type": "address"
        }
      ],
      "name": "getSwaps",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "protocol",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            }
          ],
          "internalType": "struct Structs.SwapPath[]",
          "name": "paths_",
          "type": "tuple[]"
        }
      ],
      "name": "getSwapsForPaths",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "protocol",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            }
          ],
          "internalType": "struct Structs.SwapPath[]",
          "name": "paths_",
          "type": "tuple[]"
        }
      ],
      "name": "getSwapsForPathsRaw",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenIn_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenOut_",
          "type": "address"
        }
      ],
      "name": "getSwapsRaw",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getVaultSwapData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "inAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmt",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "withAbsorb",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "ratio",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.SwapData",
          "name": "withoutAbsorb_",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "inAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmt",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "withAbsorb",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "ratio",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.SwapData",
          "name": "withAbsorb_",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "vaults_",
          "type": "address[]"
        }
      ],
      "name": "getVaultsSwap",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "vaults_",
          "type": "address[]"
        }
      ],
      "name": "getVaultsSwapData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "inAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmt",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "withAbsorb",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "ratio",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.SwapData[]",
          "name": "withoutAbsorb_",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "inAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmt",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "withAbsorb",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "ratio",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.SwapData[]",
          "name": "withAbsorb_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "vaults_",
          "type": "address[]"
        }
      ],
      "name": "getVaultsSwapRaw",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x1679f6013fa26c2095d63567cfc7db4e38102ce16d55cc701824fd6072404e4c",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x0Ed35B1609Ec45c7079E80d11149a52717e4859A",
    "contractAddress": null,
    "transactionIndex": 62,
    "gasUsed": "3779709",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000010000008000000000000000000000000000000000000000000000000000000000800000000000000000000100020000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000001000000000000000000000000000000004000000000000000040001000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000020100000",
    "blockHash": "0x7d1402831b61f1268bee12b7ba9853755871b7f502549856e586b8adf36b385a",
    "transactionHash": "0x1679f6013fa26c2095d63567cfc7db4e38102ce16d55cc701824fd6072404e4c",
    "logs": [
      {
        "transactionIndex": 62,
        "blockNumber": 68520458,
        "transactionHash": "0x1679f6013fa26c2095d63567cfc7db4e38102ce16d55cc701824fd6072404e4c",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x0000000000000000000000000ed35b1609ec45c7079e80d11149a52717e4859a",
          "0x000000000000000000000000794e44d1334a56fea7f4df12633b88820d0c5888"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000192d8c2625506ee000000000000000000000000000000000000000000000000b4db937d508311a8000000000000000000000000000000000000000000000032ad8745608cedf417000000000000000000000000000000000000000000000000b348babaee2e0aba000000000000000000000000000000000000000000000032af1a1e22ef42fb05",
        "logIndex": 215,
        "blockHash": "0x7d1402831b61f1268bee12b7ba9853755871b7f502549856e586b8adf36b385a"
      }
    ],
    "blockNumber": 68520458,
    "cumulativeGasUsed": "8959935",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x3c64Ec468D7f0998cB6dea05d4D8AB847573fE4D",
    "0x52Aa899454998Be5b000Ad077a46Bbe360F4e497"
  ],
  "numDeployments": 1,
  "solcInputHash": "4f63da12d66a256eeca1b26617ce10fe",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IFluidVaultResolver\",\"name\":\"vaultResolver_\",\"type\":\"address\"},{\"internalType\":\"contract IFluidLiquidity\",\"name\":\"liquidity_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorId_\",\"type\":\"uint256\"}],\"name\":\"FluidLiquidityCalcsError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FluidVaultLiquidationsResolver__AddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FluidVaultLiquidationsResolver__InvalidParams\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LIQUIDITY\",\"outputs\":[{\"internalType\":\"contract IFluidLiquidity\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT_RESOLVER\",\"outputs\":[{\"internalType\":\"contract IFluidVaultResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outAmt_\",\"type\":\"uint256\"}],\"name\":\"approxOutput\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"inAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approxOutAmt_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmt_\",\"type\":\"uint256\"}],\"name\":\"exactInput\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"actualInAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"targetApproxOutAmt_\",\"type\":\"uint256\"}],\"name\":\"filterToApproxOutAmt\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"filteredSwaps_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"actualInAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approxOutAmt_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"targetInAmt_\",\"type\":\"uint256\"}],\"name\":\"filterToTargetInAmt\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"filteredSwaps_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"actualInAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approxOutAmt_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllSwapPaths\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath[]\",\"name\":\"paths_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllVaultsSwap\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllVaultsSwapData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData[]\",\"name\":\"withoutAbsorb_\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData[]\",\"name\":\"withAbsorb_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllVaultsSwapRaw\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensIn_\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokensOut_\",\"type\":\"address[]\"}],\"name\":\"getAnySwapPaths\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath[]\",\"name\":\"paths_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensIn_\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokensOut_\",\"type\":\"address[]\"}],\"name\":\"getAnySwaps\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensIn_\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokensOut_\",\"type\":\"address[]\"}],\"name\":\"getAnySwapsRaw\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol_\",\"type\":\"address\"}],\"name\":\"getSwapForProtocol\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap\",\"name\":\"swap_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut_\",\"type\":\"address\"}],\"name\":\"getSwapPaths\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath[]\",\"name\":\"paths_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap\",\"name\":\"swap_\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slippage_\",\"type\":\"uint256\"}],\"name\":\"getSwapTx\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"target_\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"calldata_\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slippage_\",\"type\":\"uint256\"}],\"name\":\"getSwapTxs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"targets_\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas_\",\"type\":\"bytes[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut_\",\"type\":\"address\"}],\"name\":\"getSwaps\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath[]\",\"name\":\"paths_\",\"type\":\"tuple[]\"}],\"name\":\"getSwapsForPaths\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath[]\",\"name\":\"paths_\",\"type\":\"tuple[]\"}],\"name\":\"getSwapsForPathsRaw\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut_\",\"type\":\"address\"}],\"name\":\"getSwapsRaw\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getVaultSwapData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"withoutAbsorb_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"withAbsorb_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaults_\",\"type\":\"address[]\"}],\"name\":\"getVaultsSwap\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaults_\",\"type\":\"address[]\"}],\"name\":\"getVaultsSwapData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData[]\",\"name\":\"withoutAbsorb_\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData[]\",\"name\":\"withAbsorb_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaults_\",\"type\":\"address[]\"}],\"name\":\"getVaultsSwapRaw\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Note that on the same protocol, if \\\"withAbsorb = true\\\" is executed, this also consumes the swap         that would be on the same protocol with \\\"withAbsorb = false\\\". So the total available swap amount         at a protocol if both a swap with and without absorb is available is not `with inAmt + without inAmt`         but rather `with inAmt`.         Sometimes with absorb can provide better swaps, sometimes without absorb can provide better swaps.         But available liquidity for \\\"withAbsorb\\\" amounts will always be >= without absorb amounts.The \\\"Raw\\\" methods return both the with and without absorb swaps for the same Fluid Vault, the non-\\\"Raw\\\"         methods automatically filter by the better ratio swap. For same cases a better optimization of ratios         is possible with custom logic based on the \\\"Raw\\\" methods, see details in comments.for native token, send 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE.returned swaps Struct can be fed into `getSwapTx` to prepare the tx that executes the swaps.non-view methods in this contract are expected to be called with callStatic,         although they would anyway not do any actual state changes.\",\"kind\":\"dev\",\"methods\":{\"approxOutput(address,address,uint256)\":{\"details\":\"The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better but the target swap amount is more than the available without absorb liquidity. For this currently the available withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity. The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing amount up to the target amount with the worse ratio with absorb liquidity.\",\"params\":{\"outAmt_\":\"exact output token amount that should be swapped to from input token\",\"tokenIn_\":\"input token\",\"tokenOut_\":\"output token\"},\"returns\":{\"approxOutAmt_\":\"approximate output token amount. Can be less than `outAmt_` if all available swaps can not cover                       the target amount.\",\"inAmt_\":\"input token amount needed to receive `actualOutAmt_`\",\"swaps_\":\"swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\"}},\"exactInput(address,address,uint256)\":{\"details\":\"The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better but the target swap amount is more than the available without absorb liquidity. For this, currently the available withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity. The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing amount up to the target amount with the worse ratio with absorb liquidity.\",\"params\":{\"inAmt_\":\"exact input token amount that should be swapped to output token\",\"tokenIn_\":\"input token\",\"tokenOut_\":\"output token\"},\"returns\":{\"actualInAmt_\":\"actual input token amount. Can be less than inAmt_ if all available swaps can not cover                      the target amount.\",\"outAmt_\":\"output token amount received for `actualInAmt_`\",\"swaps_\":\"swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\"}},\"filterToApproxOutAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)\":{\"returns\":{\"actualInAmt_\":\"actual input amount.\",\"approxOutAmt_\":\"APPROXIMATE actual output amount. Can be less than targetOutAmt_ if all available swaps                      can not cover the target amount.\",\"filteredSwaps_\":\"swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\"}},\"filterToTargetInAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)\":{\"returns\":{\"actualInAmt_\":\"actual input amount. Can be less than targetInAmt_ if all available swaps can not cover                      the target amount.\",\"approxOutAmt_\":\"actual estimated output amount.\",\"filteredSwaps_\":\"swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\"}},\"getSwapTx(((address,address,address),(uint256,uint256,bool,uint256)),address,uint256)\":{\"params\":{\"receiver_\":\"receiver address that the output token is sent to\",\"slippage_\":\"maximum allowed slippage for the expected output token amount. Reverts iIf received token out                  amount is lower than this. in 1e4 percentage, e.g. 1% = 10000, 0.3% = 3000, 0.01% = 100, 0.0001% = 1.\",\"swap_\":\"Swap struct as returned by other methods\"},\"returns\":{\"calldata_\":\"the calldata that can be used to trigger the liquidation call, resulting in the desired swap.\",\"target_\":\"target address where `calldata_` must be executed\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"FluidVaultLiquidationsResolver__AddressZero()\":[{\"notice\":\"thrown if an input param address is zero\"}],\"FluidVaultLiquidationsResolver__InvalidParams()\":[{\"notice\":\"thrown if an invalid param is given to a method\"}]},\"kind\":\"user\",\"methods\":{\"LIQUIDITY()\":{\"notice\":\"address of the liquidity contract\"},\"approxOutput(address,address,uint256)\":{\"notice\":\"finds all swaps from `tokenIn_` to `tokenOut_` for an APPROXIMATE output amount `outAmt_`.         filters the available swaps and sorts them by ratio, so the returned swaps are the best available         swaps to reach the target `outAmt_`.         If the full available amount is less than the target `outAmt_`, the available amount is returned as `actualOutAmt_`.         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to         approximately estimate the required input amounts to reach a certain output amount. This         will change until execution and should be controlled with a maximum slippage.         Recommended to use exact input methods instead.\"},\"constructor\":{\"notice\":\"constructor sets the immutable vault resolver address\"},\"exactInput(address,address,uint256)\":{\"notice\":\"finds all swaps from `tokenIn_` to `tokenOut_` for an exact input amount `inAmt_`.         filters the available swaps and sorts them by ratio, so the returned swaps are the best available         swaps to reach the target `inAmt_`.         If the full available amount is less than the target `inAmt_`, the available amount is returned as `actualInAmt_`.\"},\"filterToApproxOutAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)\":{\"notice\":\"filters the `swaps_` to the point where APPROXIMATELY `targetOutAmt_` is reached.         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to         approximately estimate the required input amounts to reach a certain output amount. This         will change until execution and should be controlled with a maximum slippage.         Recommended to use exact input methods instead.         This is best used in combination with the \\\"Raw\\\" methods, as the `targetInAmt_` allows for more optimized         filtering than otherwise done with the non-\\\"Raw\\\" methods.\"},\"filterToTargetInAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)\":{\"notice\":\"filters the `swaps_` to the point where `targetInAmt_` is reached.         This is best used in combination with the \\\"Raw\\\" methods, as the `targetInAmt_` allows for more optimized         filtering than otherwise done with the non-\\\"Raw\\\" methods.\"},\"getAllSwapPaths()\":{\"notice\":\"returns all available token swap paths\"},\"getAllVaultsSwap()\":{\"notice\":\"returns all available `swaps_` for all Fluid vaults. Only returns non-zero swaps.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio.\"},\"getAllVaultsSwapData()\":{\"notice\":\"returns the swap data for with and without absorb for all Fluid vaults.\"},\"getAllVaultsSwapRaw()\":{\"notice\":\"returns all available `swaps_` for all Fluid vaults raw. Only returns non-zero swaps.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\"},\"getAnySwapPaths(address[],address[])\":{\"notice\":\"returns all available swap paths for any `tokensIn_` to any `tokensOut_`.\"},\"getAnySwaps(address[],address[])\":{\"notice\":\"finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.         Token pairs that are not available or where available swap amounts are zero         will not be present in the returned `swaps_` array.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio.\"},\"getAnySwapsRaw(address[],address[])\":{\"notice\":\"finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.         Token pairs that are not available or where available swap amounts are zero         will not be present in the returned `swaps_` array.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\"},\"getSwapForProtocol(address)\":{\"notice\":\"returns the available swap amounts at a certain `protocol_`. Only returns non-zero swaps.         For vault protocol considering both a swap that uses liquidation with absorb and without absorb.\"},\"getSwapPaths(address,address)\":{\"notice\":\"returns all swap paths for a certain `tokenIn_` swapped to a `tokenOut_`.         returns empty array if no swap path is available for a given pair.\"},\"getSwapTx(((address,address,address),(uint256,uint256,bool,uint256)),address,uint256)\":{\"notice\":\"returns the calldata to execute a swap as returned by the other methods in this contract.         `swap_.data.inAmt` must come from msg.sender, `swap_.data.outAmt` goes to `receiver_`. If the input token         is the native token, msg.value must be sent along when triggering the actual call with the returned calldata         which should be `swap_.data.inAmt`.\"},\"getSwapTxs(((address,address,address),(uint256,uint256,bool,uint256))[],address,uint256)\":{\"notice\":\"returns the same data as `getSwapTx` for an array of input `swaps_` at once.\"},\"getSwaps(address,address)\":{\"notice\":\"finds all available `swaps_` for `tokenIn_` to `tokenOut_`.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio.\"},\"getSwapsForPaths((address,address,address)[])\":{\"notice\":\"returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio.\"},\"getSwapsForPathsRaw((address,address,address)[])\":{\"notice\":\"returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\"},\"getSwapsRaw(address,address)\":{\"notice\":\"finds all available `swaps_` for `tokenIn_` to `tokenOut_`.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\"},\"getVaultSwapData(address)\":{\"notice\":\"returns the swap data for with and without absorb for a Fluid `vault_`.\"},\"getVaultsSwap(address[])\":{\"notice\":\"returns all available `swaps_` for multiple Fluid `vaults_`. Only returns non-zero swaps.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio.\"},\"getVaultsSwapData(address[])\":{\"notice\":\"returns the swap data for with and without absorb for multiple Fluid `vaults_`.\"},\"getVaultsSwapRaw(address[])\":{\"notice\":\"returns all available `swaps_` for multiple Fluid `vaults_` raw. Only returns non-zero swaps.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\"}},\"notice\":\"Resolver contract that helps in finding available token (liquidation) swaps available in Fluid VaultT1s.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/periphery/resolvers/vaultLiquidation/main.sol\":\"FluidVaultLiquidationResolver\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[]},\"sources\":{\"contracts/infiniteProxy/interfaces/iProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IProxy {\\n    function setAdmin(address newAdmin_) external;\\n\\n    function setDummyImplementation(address newDummyImplementation_) external;\\n\\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\\n\\n    function removeImplementation(address implementation_) external;\\n\\n    function getAdmin() external view returns (address);\\n\\n    function getDummyImplementation() external view returns (address);\\n\\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\\n\\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\\n\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n}\\n\",\"keccak256\":\"0xbb605491d4bac08e816248feecae7dd17cfc1877c88b2e555abece2970f5ea00\",\"license\":\"MIT\"},\"contracts/libraries/bigMathMinified.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\\n/// result in significant gas cost reduction due to storage space reduction.\\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\\nlibrary BigMathMinified {\\n    /// @dev constants to use for `roundUp` input param to increase readability\\n    bool internal constant ROUND_DOWN = false;\\n    bool internal constant ROUND_UP = true;\\n\\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\\n    /// e.g.:\\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\\n    /// exponent =                                            0011,0011     (51)\\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\\n    ///\\n    /// @param normal number which needs to be converted into Big Number\\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\\n    /// @param roundUp signals if result should be rounded down or up\\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\\n    function toBigNumber(\\n        uint256 normal,\\n        uint256 coefficientSize,\\n        uint256 exponentSize,\\n        bool roundUp\\n    ) internal pure returns (uint256 bigNumber) {\\n        assembly {\\n            let lastBit_\\n            let number_ := normal\\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x80, number_)\\n                lastBit_ := 0x80\\n            }\\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x40, number_)\\n                lastBit_ := add(lastBit_, 0x40)\\n            }\\n            if gt(number_, 0xFFFFFFFF) {\\n                number_ := shr(0x20, number_)\\n                lastBit_ := add(lastBit_, 0x20)\\n            }\\n            if gt(number_, 0xFFFF) {\\n                number_ := shr(0x10, number_)\\n                lastBit_ := add(lastBit_, 0x10)\\n            }\\n            if gt(number_, 0xFF) {\\n                number_ := shr(0x8, number_)\\n                lastBit_ := add(lastBit_, 0x8)\\n            }\\n            if gt(number_, 0xF) {\\n                number_ := shr(0x4, number_)\\n                lastBit_ := add(lastBit_, 0x4)\\n            }\\n            if gt(number_, 0x3) {\\n                number_ := shr(0x2, number_)\\n                lastBit_ := add(lastBit_, 0x2)\\n            }\\n            if gt(number_, 0x1) {\\n                lastBit_ := add(lastBit_, 1)\\n            }\\n            if gt(number_, 0) {\\n                lastBit_ := add(lastBit_, 1)\\n            }\\n            if lt(lastBit_, coefficientSize) {\\n                // for throw exception\\n                lastBit_ := coefficientSize\\n            }\\n            let exponent := sub(lastBit_, coefficientSize)\\n            let coefficient := shr(exponent, normal)\\n            if and(roundUp, gt(exponent, 0)) {\\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\\n                coefficient := add(coefficient, 1)\\n                if eq(shl(coefficientSize, 1), coefficient) {\\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\\n                    coefficient := shl(sub(coefficientSize, 1), 1)\\n                    exponent := add(exponent, 1)\\n                }\\n            }\\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\\n                // if exponent is >= exponentSize, the normal number is too big to fit within\\n                // BigNumber with too small sizes for coefficient and exponent\\n                revert(0, 0)\\n            }\\n            bigNumber := shl(exponentSize, coefficient)\\n            bigNumber := add(bigNumber, exponent)\\n        }\\n    }\\n\\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\\n    function fromBigNumber(\\n        uint256 bigNumber,\\n        uint256 exponentSize,\\n        uint256 exponentMask\\n    ) internal pure returns (uint256 normal) {\\n        assembly {\\n            let coefficient := shr(exponentSize, bigNumber)\\n            let exponent := and(bigNumber, exponentMask)\\n            normal := shl(exponent, coefficient)\\n        }\\n    }\\n\\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\\n    /// e.g.\\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\\n        assembly {\\n            let number_ := normal\\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x80, number_)\\n                lastBit := 0x80\\n            }\\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x40, number_)\\n                lastBit := add(lastBit, 0x40)\\n            }\\n            if gt(number_, 0xFFFFFFFF) {\\n                number_ := shr(0x20, number_)\\n                lastBit := add(lastBit, 0x20)\\n            }\\n            if gt(number_, 0xFFFF) {\\n                number_ := shr(0x10, number_)\\n                lastBit := add(lastBit, 0x10)\\n            }\\n            if gt(number_, 0xFF) {\\n                number_ := shr(0x8, number_)\\n                lastBit := add(lastBit, 0x8)\\n            }\\n            if gt(number_, 0xF) {\\n                number_ := shr(0x4, number_)\\n                lastBit := add(lastBit, 0x4)\\n            }\\n            if gt(number_, 0x3) {\\n                number_ := shr(0x2, number_)\\n                lastBit := add(lastBit, 0x2)\\n            }\\n            if gt(number_, 0x1) {\\n                lastBit := add(lastBit, 1)\\n            }\\n            if gt(number_, 0) {\\n                lastBit := add(lastBit, 1)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf0be1002909edf30aec3dc6623c2bd2407ed94064b62674c01032b844dec206a\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary LibsErrorTypes {\\n    /***********************************|\\n    |         LiquidityCalcs            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\\n\\n    /// @notice thrown when rate data is set to a version that is not implemented\\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\\n\\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\\n\\n    /***********************************|\\n    |           SafeTransfer            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when safe transfer from for an ERC20 fails\\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\\n\\n    /// @notice thrown when safe transfer for an ERC20 fails\\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\\n\\n    /***********************************|\\n    |           SafeApprove             | \\n    |__________________________________*/\\n\\n    /// @notice thrown when safe approve from for an ERC20 fails\\n    uint256 internal constant SafeApprove__ApproveFailed = 81001;\\n}\\n\",\"keccak256\":\"0x4057f500fd44ce9e89049512d06d5f72c46f91938ed37312fb044c204451009b\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/fluidProtocolTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ninterface IFluidProtocol {\\n    function TYPE() external view returns (uint256);\\n}\\n\\n/// @notice implements helper methods to filter Fluid protocols by a certain type\\nlibrary FluidProtocolTypes {\\n    uint256 internal constant VAULT_T1_TYPE = 10000; // VaultT1 borrow protocol type vaults\\n    uint256 internal constant VAULT_T2_SMART_COL_TYPE = 20000; // DEX protocol type vault\\n    uint256 internal constant VAULT_T3_SMART_DEBT_TYPE = 30000; // DEX protocol type vault\\n    uint256 internal constant VAULT_T4_SMART_COL_SMART_DEBT_TYPE = 40000; // DEX protocol type vault\\n\\n    /// @dev filters input `addresses_` by protocol `type_`. Input addresses must be actual Fluid protocols, otherwise\\n    ///      they would be wrongly assumed to be VaultT1 even if they are not Fluid VaultT1 smart contracts.\\n    ///      `type_` must be a listed constant type of this library.\\n    ///      Example usage is to filter all vault addresses at the Vault factory by a certain type, e.g. to not include\\n    ///      DEX protocol type vaults.\\n    function filterBy(address[] memory addresses_, uint256 type_) internal view returns (address[] memory filtered_) {\\n        uint256 curType_;\\n        uint256 filteredProtocols_ = addresses_.length;\\n        for (uint256 i; i < addresses_.length; ) {\\n            try IFluidProtocol(addresses_[i]).TYPE() returns (uint256 protocolType_) {\\n                curType_ = protocolType_;\\n            } catch {\\n                curType_ = VAULT_T1_TYPE;\\n            }\\n\\n            if (curType_ != type_) {\\n                addresses_[i] = address(0);\\n                --filteredProtocols_;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        filtered_ = new address[](filteredProtocols_);\\n        uint256 index_;\\n        unchecked {\\n            for (uint256 i; i < addresses_.length; ) {\\n                if (addresses_[i] != address(0)) {\\n                    filtered_[index_] = addresses_[i];\\n                    ++index_;\\n                }\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x98868cc272fea53dbd4504e02df4f4fcd709a4144a8b37a85513edd638bd073b\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/liquidityCalcs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { LibsErrorTypes as ErrorTypes } from \\\"./errorTypes.sol\\\";\\nimport { LiquiditySlotsLink } from \\\"./liquiditySlotsLink.sol\\\";\\nimport { BigMathMinified } from \\\"./bigMathMinified.sol\\\";\\n\\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\\n/// borrow rate, withdrawal / borrow limits, revenue amount.\\nlibrary LiquidityCalcs {\\n    error FluidLiquidityCalcsError(uint256 errorId_);\\n\\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\\n    event BorrowRateMaxCap();\\n\\n    /// @dev constants as from Liquidity variables.sol\\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\\n\\n    /// @dev Ignoring leap years\\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\\n    // constants used for BigMath conversion from and to storage\\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\\n\\n    uint256 internal constant FOUR_DECIMALS = 1e4;\\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\\n    uint256 internal constant X14 = 0x3fff;\\n    uint256 internal constant X15 = 0x7fff;\\n    uint256 internal constant X16 = 0xffff;\\n    uint256 internal constant X18 = 0x3ffff;\\n    uint256 internal constant X24 = 0xffffff;\\n    uint256 internal constant X33 = 0x1ffffffff;\\n    uint256 internal constant X64 = 0xffffffffffffffff;\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                  CALC EXCHANGE PRICES                  /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\\n    function calcExchangePrices(\\n        uint256 exchangePricesAndConfig_\\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\\n        // Extracting exchange prices\\n        supplyExchangePrice_ =\\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\\n            X64;\\n        borrowExchangePrice_ =\\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\\n            X64;\\n\\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\\n        }\\n\\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\\n\\n        unchecked {\\n            // last timestamp can not be > current timestamp\\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\\n\\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\\n                X15;\\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\\n                return (supplyExchangePrice_, borrowExchangePrice_);\\n            }\\n\\n            // calculate new borrow exchange price.\\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\\n            borrowExchangePrice_ +=\\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\\n\\n            // FOR SUPPLY EXCHANGE PRICE:\\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\\n            //\\n            // Example:\\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\\n            // yield is 10 (so half a year must have passed).\\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 20%) = 62,5%\\n            // supplyRate = (40% * (100% - 10%)) * = 36% * 62,5% = 22.5%\\n            // increase in supplyExchangePrice, assuming 100 as previous price.\\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\\n\\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\\n\\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\\n\\n            if (temp_ == 1) {\\n                // if no raw supply: no exchange price update needed\\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\\n                return (supplyExchangePrice_, borrowExchangePrice_);\\n            }\\n\\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\\n            if (temp_ & 1 == 1) {\\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\\n                temp_ = temp_ >> 1;\\n\\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\\n                // in the if statement a little above.\\n\\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\\n                // so ratioSupplyYield must come out as 2.5 (250%).\\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\\n                temp_ =\\n                    // utilization * (100% + 100% / supplyRatio)\\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\\n                    (FOUR_DECIMALS);\\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\\n            } else {\\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\\n                temp_ = temp_ >> 1;\\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\\n\\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\\n                temp_ =\\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\\n                    (1e27 *\\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\\n                        (FOUR_DECIMALS + temp_)) /\\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\\n            }\\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\\n\\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\\n            if (borrowRatio_ & 1 == 1) {\\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\\n                borrowRatio_ = borrowRatio_ >> 1;\\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\\n\\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\\n\\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\\n            } else {\\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\\n                borrowRatio_ = borrowRatio_ >> 1;\\n\\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\\n            }\\n\\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\\n\\n            // 2. calculate supply rate\\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\\n            // but more suppliers not earning interest.\\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\\n                temp_ * // ratioSupplyYield\\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\\n\\n            // 3. calculate increase in supply exchange price\\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                     CALC REVENUE                       /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\\n    /// and the current balance of the Fluid liquidity contract for the token.\\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\\n    /// @return revenueAmount_ collectable revenue amount\\n    function calcRevenue(\\n        uint256 totalAmounts_,\\n        uint256 exchangePricesAndConfig_,\\n        uint256 liquidityTokenBalance_\\n    ) internal view returns (uint256 revenueAmount_) {\\n        // @dev no need to super-optimize this method as it is only used by admin\\n\\n        // calculate the new exchange prices based on earned interest\\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\\n\\n        // total supply = interest free + with interest converted from raw\\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\\n\\n        if (totalSupply_ > 0) {\\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\\n            // ensure there is no possible case because of rounding etc. where this would revert,\\n            // explicitly check if >\\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\\n            // can only be revenue.\\n        } else {\\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\\n            revenueAmount_ = liquidityTokenBalance_;\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                      CALC LIMITS                       /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev calculates withdrawal limit before an operate execution:\\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\\n    /// @param userSupplyData_ user supply data packed uint256 from storage\\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\\n    function calcWithdrawalLimitBeforeOperate(\\n        uint256 userSupplyData_,\\n        uint256 userSupply_\\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\\n        // a deposit anyway. Important is that it would not revert.\\n\\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\\n        // is the fully expanded limit immediately.\\n\\n        // extract last set withdrawal limit\\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\\n        lastWithdrawalLimit_ =\\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\\n        if (lastWithdrawalLimit_ == 0) {\\n            // withdrawal limit is not activated. Max withdrawal allowed\\n            return 0;\\n        }\\n\\n        uint256 maxWithdrawableLimit_;\\n        uint256 temp_;\\n        unchecked {\\n            // extract max withdrawable percent of user supply and\\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\\n\\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            maxWithdrawableLimit_ =\\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\\n                FOUR_DECIMALS;\\n\\n            // time elapsed since last withdrawal limit was set (in seconds)\\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\\n            // last timestamp can not be > current timestamp\\n            temp_ =\\n                block.timestamp -\\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\\n        }\\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\\n        temp_ =\\n            (maxWithdrawableLimit_ * temp_) /\\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\\n        unchecked {\\n            // underflow explicitly checked & handled\\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\\n            temp_ = userSupply_ - maxWithdrawableLimit_;\\n        }\\n        // if withdrawal limit is decreased below minimum then set minimum\\n        // (e.g. when more than expandDuration time has elapsed)\\n        if (temp_ > currentWithdrawalLimit_) {\\n            currentWithdrawalLimit_ = temp_;\\n        }\\n    }\\n\\n    /// @dev calculates withdrawal limit after an operate execution:\\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\\n    /// @param userSupplyData_ user supply data packed uint256 from storage\\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\\n    ///                          raw for with interest mode, normal amount for interest free mode!\\n    function calcWithdrawalLimitAfterOperate(\\n        uint256 userSupplyData_,\\n        uint256 userSupply_,\\n        uint256 newWithdrawalLimit_\\n    ) internal pure returns (uint256) {\\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        // if user supply is below base limit then max withdrawals are allowed\\n        if (userSupply_ < temp_) {\\n            return 0;\\n        }\\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\\n        unchecked {\\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\\n        }\\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\\n        // increased deposit amount outpaces withrawals.\\n        if (temp_ > newWithdrawalLimit_) {\\n            return temp_;\\n        }\\n        return newWithdrawalLimit_;\\n    }\\n\\n    /// @dev calculates borrow limit before an operate execution:\\n    /// total amount user borrow can reach (not borrowable amount in current operation).\\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\\n    ///                             raw for with interest mode, normal amount for interest free mode!\\n    function calcBorrowLimitBeforeOperate(\\n        uint256 userBorrowData_,\\n        uint256 userBorrow_\\n    ) internal view returns (uint256 currentBorrowLimit_) {\\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\\n\\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\\n\\n        uint256 maxExpansionLimit_;\\n        uint256 maxExpandedBorrowLimit_;\\n        unchecked {\\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\\n\\n            // calculate max borrow limit: Max point limit can increase to since last interaction\\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\\n        }\\n\\n        // currentBorrowLimit_ = extract base borrow limit\\n        currentBorrowLimit_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\\n        currentBorrowLimit_ =\\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\\n            return currentBorrowLimit_;\\n        }\\n        // time elapsed since last borrow limit was set (in seconds)\\n        unchecked {\\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\\n            temp_ =\\n                block.timestamp -\\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\\n        }\\n\\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\\n        currentBorrowLimit_ =\\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\\n            ((maxExpansionLimit_ * temp_) /\\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\\n            //  extract last set borrow limit\\n            BigMathMinified.fromBigNumber(\\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\\n                DEFAULT_EXPONENT_SIZE,\\n                DEFAULT_EXPONENT_MASK\\n            );\\n\\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\\n        // so set to `maxExpandedBorrowLimit_` in that case.\\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\\n        }\\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (currentBorrowLimit_ > temp_) {\\n            currentBorrowLimit_ = temp_;\\n        }\\n    }\\n\\n    /// @dev calculates borrow limit after an operate execution:\\n    /// total amount user borrow can reach (not borrowable amount in current operation).\\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\\n    function calcBorrowLimitAfterOperate(\\n        uint256 userBorrowData_,\\n        uint256 userBorrow_,\\n        uint256 newBorrowLimit_\\n    ) internal pure returns (uint256 borrowLimit_) {\\n        // temp_ = extract borrow expand percent\\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\\n\\n        unchecked {\\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\\n        }\\n\\n        // temp_ = extract base borrow limit\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (borrowLimit_ < temp_) {\\n            // below base limit, borrow limit is always base limit\\n            return temp_;\\n        }\\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        // make sure fully expanded borrow limit is not above hard max borrow limit\\n        if (borrowLimit_ > temp_) {\\n            borrowLimit_ = temp_;\\n        }\\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\\n        if (newBorrowLimit_ > borrowLimit_) {\\n            return borrowLimit_;\\n        }\\n        return newBorrowLimit_;\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                      CALC RATES                        /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev Calculates new borrow rate from utilization for a token\\n    /// @param rateData_ rate data packed uint256 from storage for the token\\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\\n        // extract rate version: 4 bits (0xF) starting from bit 0\\n        uint256 rateVersion_ = (rateData_ & 0xF);\\n\\n        if (rateVersion_ == 1) {\\n            rate_ = calcRateV1(rateData_, utilization_);\\n        } else if (rateVersion_ == 2) {\\n            rate_ = calcRateV2(rateData_, utilization_);\\n        } else {\\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\\n        }\\n\\n        if (rate_ > X16) {\\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\\n            // this is unlikely to ever happen if configs stay within expected levels.\\n            rate_ = X16;\\n            // emit event to more easily become aware\\n            emit BorrowRateMaxCap();\\n        }\\n    }\\n\\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\\n    /// @param rateData_ rate data packed uint256 from storage for the token\\n    /// @param utilization_  in 1e2 (100% = 1e4)\\n    /// @return rate_ rate in 1e2 precision\\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\\n        /// For rate v1 (one kink) ------------------------------------------------------\\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\\n\\n        // y = mx + c.\\n        // y is borrow rate\\n        // x is utilization\\n        // m = slope (m can also be negative for declining rates)\\n        // c is constant (c can be negative)\\n\\n        uint256 y1_;\\n        uint256 y2_;\\n        uint256 x1_;\\n        uint256 x2_;\\n\\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\\n        if (utilization_ < kink1_) {\\n            // if utilization is less than kink\\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\\n            x1_ = 0; // 0%\\n            x2_ = kink1_;\\n        } else {\\n            // else utilization is greater than kink\\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\\n            x1_ = kink1_;\\n            x2_ = FOUR_DECIMALS; // 100%\\n        }\\n\\n        int256 constant_;\\n        int256 slope_;\\n        unchecked {\\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\\n\\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\\n\\n            // calculating new borrow rate\\n            // - slope_ max value is 65535 * 1e12,\\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\\n            // - constant max value is 65535 * 1e12\\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\\n            // divisor TWELVE_DECIMALS can not be 0\\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\\n            if (slope_ < 0) {\\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\\n            }\\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\\n        }\\n    }\\n\\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\\n    /// @param rateData_ rate data packed uint256 from storage for the token\\n    /// @param utilization_  in 1e2 (100% = 1e4)\\n    /// @return rate_ rate in 1e4 precision\\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\\n        /// For rate v2 (two kinks) -----------------------------------------------------\\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Last 156 bits => 100-255 => blank, might come in use in future\\n\\n        // y = mx + c.\\n        // y is borrow rate\\n        // x is utilization\\n        // m = slope (m can also be negative for declining rates)\\n        // c is constant (c can be negative)\\n\\n        uint256 y1_;\\n        uint256 y2_;\\n        uint256 x1_;\\n        uint256 x2_;\\n\\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\\n        if (utilization_ < kink1_) {\\n            // if utilization is less than kink1\\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\\n            x1_ = 0; // 0%\\n            x2_ = kink1_;\\n        } else {\\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\\n            if (utilization_ < kink2_) {\\n                // if utilization is less than kink2\\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\\n                x1_ = kink1_;\\n                x2_ = kink2_;\\n            } else {\\n                // else utilization is greater than kink2\\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\\n                x1_ = kink2_;\\n                x2_ = FOUR_DECIMALS;\\n            }\\n        }\\n\\n        int256 constant_;\\n        int256 slope_;\\n        unchecked {\\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\\n\\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\\n\\n            // calculating new borrow rate\\n            // - slope_ max value is 65535 * 1e12,\\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\\n            // - constant max value is 65535 * 1e12\\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\\n            // divisor TWELVE_DECIMALS can not be 0\\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\\n            if (slope_ < 0) {\\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\\n            }\\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\\n        }\\n    }\\n\\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\\n    function getTotalSupply(\\n        uint256 totalAmounts_,\\n        uint256 supplyExchangePrice_\\n    ) internal pure returns (uint256 totalSupply_) {\\n        // totalSupply_ => supplyInterestFree\\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\\n\\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\\n\\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\\n    }\\n\\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\\n    function getTotalBorrow(\\n        uint256 totalAmounts_,\\n        uint256 borrowExchangePrice_\\n    ) internal pure returns (uint256 totalBorrow_) {\\n        // totalBorrow_ => borrowInterestFree\\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\\n\\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\\n\\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\\n    }\\n}\\n\",\"keccak256\":\"0xa65e2f84b2c33769ceb6b28fbd3221be29da2f8ac96e4d8b8cea91948d81a707\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/liquiditySlotsLink.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\\nlibrary LiquiditySlotsLink {\\n    /// @dev storage slot for status at Liquidity\\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\\n    /// @dev storage slot for auths mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\\n    /// @dev storage slot for guardians mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\\n    /// @dev storage slot for user class mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\\n    /// @dev storage slot for rateData mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\\n    /// @dev storage slot for totalAmounts mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\\n    /// @dev storage slot for user supply double mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\\n    /// @dev storage slot for user borrow double mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\\n    /// @dev storage slot for listed tokens array at Liquidity\\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\\n    /// @dev storage slot for listed tokens array at Liquidity\\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\\n\\n    // --------------------------------\\n    // @dev stacked uint256 storage slots bits position data for each:\\n\\n    // ExchangePricesAndConfig\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\\n\\n    // RateData:\\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\\n    // RateData: V1\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\\n    // RateData: V2\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\\n\\n    // TotalAmounts\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\\n\\n    // UserSupplyData\\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\\n\\n    // UserBorrowData\\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\\n\\n    // Configs2\\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\\n\\n    // --------------------------------\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\\n    function calculateDoubleMappingStorageSlot(\\n        uint256 slot_,\\n        address key1_,\\n        address key2_\\n    ) internal pure returns (bytes32) {\\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\\n        return keccak256(abi.encode(key2_, intermediateSlot_));\\n    }\\n}\\n\",\"keccak256\":\"0x0ae3e1d231bb6c14b54fc1f5ffa306edc0ac827a6a92279c77c0c09627fe08ae\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/adminModule/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Structs {\\n    struct AddressBool {\\n        address addr;\\n        bool value;\\n    }\\n\\n    struct AddressUint256 {\\n        address addr;\\n        uint256 value;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 1\\n    struct RateDataV1Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\\n        uint256 kink;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink;\\n        ///\\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 2\\n    struct RateDataV2Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\\n        uint256 kink1;\\n        ///\\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\\n        uint256 kink2;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink1;\\n        ///\\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\\n        uint256 rateAtUtilizationKink2;\\n        ///\\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set token config\\n    struct TokenConfig {\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 fee;\\n        ///\\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 threshold;\\n        ///\\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\\n        uint256 maxUtilization;\\n    }\\n\\n    /// @notice struct to set user supply & withdrawal config\\n    struct UserSupplyConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration withdrawal limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseWithdrawalLimit;\\n    }\\n\\n    /// @notice struct to set user borrow & payback config\\n    struct UserBorrowConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which debt limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration debt limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseDebtCeiling;\\n        ///\\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 maxDebtCeiling;\\n    }\\n}\\n\",\"keccak256\":\"0x10353c70015f27b880125cefab806dbed24a4458f187da66964f3ef60488f757\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/interfaces/iLiquidity.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { IProxy } from \\\"../../infiniteProxy/interfaces/iProxy.sol\\\";\\nimport { Structs as AdminModuleStructs } from \\\"../adminModule/structs.sol\\\";\\n\\ninterface IFluidLiquidityAdmin {\\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\\n    /// @param authsStatus_ array of structs setting allowed status for an address.\\n    ///                     status true => add auth, false => remove auth\\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\\n\\n    /// @notice adds/removes guardians. Only callable by Governance.\\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\\n    ///                         status true => add guardian, false => remove guardian\\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\\n\\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\\n    /// @param revenueCollector_  new revenue collector address\\n    function updateRevenueCollector(address revenueCollector_) external;\\n\\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\\n    /// @param newStatus_ new status\\n    ///        status = 2 -> pause, status = 1 -> resume.\\n    function changeStatus(uint256 newStatus_) external;\\n\\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\\n\\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\\n\\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\\n    ///         Only callable by Auths.\\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\\n\\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\\n    ///         Only callable by Auths.\\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\\n\\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\\n    ///         Only callable by Auths.\\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\\n\\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\\n    /// @param user_ user address for which to update the withdrawal limit\\n    /// @param token_ token address for which to update the withdrawal limit\\n    /// @param newLimit_ new limit until which user supply can decrease to.\\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\\n    ///                  current user supply as limit respectively.\\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\\n    ///                  below base limit then fully down to 0.\\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\\n\\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\\n    ///         Only callable by Auths.\\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\\n\\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\\n    /// Only callable by Guardians.\\n    /// @param user_          address of user to pause operations for\\n    /// @param supplyTokens_  token addresses to pause withdrawals for\\n    /// @param borrowTokens_  token addresses to pause borrowings for\\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\\n\\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\\n    /// Only callable by Guardians.\\n    /// @param user_          address of user to unpause operations for\\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\\n    /// @param borrowTokens_  token addresses to unpause borrowings for\\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\\n\\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\\n    /// @param tokens_  array of tokens to collect revenue for\\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\\n    function collectRevenue(address[] calldata tokens_) external;\\n\\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\\n    /// @param tokens_ tokens to update exchange prices for\\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\\n    function updateExchangePrices(\\n        address[] calldata tokens_\\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\\n}\\n\\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\\n    /// @notice Single function which handles supply, withdraw, borrow & payback\\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\\n    /// @param withdrawTo_ if withdrawal then to which address\\n    /// @param borrowTo_ if borrow then to which address\\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\\n    /// @return memVar3_ updated supplyExchangePrice\\n    /// @return memVar4_ updated borrowExchangePrice\\n    /// @dev to trigger skipping in / out transfers (gas optimization):\\n    /// -  ` callbackData_` MUST be encoded so that \\\"from\\\" address is the last 20 bytes in the last 32 bytes slot,\\n    ///     also for native token operations where liquidityCallback is not triggered!\\n    ///     from address must come at last position if there is more data. I.e. encode like:\\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\\n    /// -   this \\\"from\\\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\\n    ///     in the slot before (bytes 32 to 63)\\n    /// -   `msg.value` must be 0.\\n    /// -   Amounts must be either:\\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\\n    function operate(\\n        address token_,\\n        int256 supplyAmount_,\\n        int256 borrowAmount_,\\n        address withdrawTo_,\\n        address borrowTo_,\\n        bytes calldata callbackData_\\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\\n}\\n\\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\\n\",\"keccak256\":\"0x4aa83e84baa7c2f4d58b07a3eca4ab7fe7d6fc660898daaac338dc3f129c4123\",\"license\":\"MIT\"},\"contracts/periphery/resolvers/liquidity/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Structs as AdminModuleStructs } from \\\"../../../liquidity/adminModule/structs.sol\\\";\\n\\nabstract contract Structs {\\n    struct RateData {\\n        uint256 version;\\n        AdminModuleStructs.RateDataV1Params rateDataV1;\\n        AdminModuleStructs.RateDataV2Params rateDataV2;\\n    }\\n\\n    struct OverallTokenData {\\n        uint256 borrowRate;\\n        uint256 supplyRate;\\n        uint256 fee; // revenue fee\\n        uint256 lastStoredUtilization;\\n        uint256 storageUpdateThreshold;\\n        uint256 lastUpdateTimestamp;\\n        uint256 supplyExchangePrice;\\n        uint256 borrowExchangePrice;\\n        uint256 supplyRawInterest;\\n        uint256 supplyInterestFree;\\n        uint256 borrowRawInterest;\\n        uint256 borrowInterestFree;\\n        uint256 totalSupply;\\n        uint256 totalBorrow;\\n        uint256 revenue;\\n        uint256 maxUtilization; // maximum allowed utilization\\n        RateData rateData;\\n    }\\n\\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\\n    struct UserSupplyData {\\n        bool modeWithInterest; // true if mode = with interest, false = without interest\\n        uint256 supply; // user supply amount\\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\\n        uint256 withdrawalLimit;\\n        uint256 lastUpdateTimestamp;\\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\\n        uint256 baseWithdrawalLimit;\\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\\n        uint256 withdrawableUntilLimit;\\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\\n    }\\n\\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\\n    struct UserBorrowData {\\n        bool modeWithInterest; // true if mode = with interest, false = without interest\\n        uint256 borrow; // user borrow amount\\n        uint256 borrowLimit;\\n        uint256 lastUpdateTimestamp;\\n        uint256 expandPercent;\\n        uint256 expandDuration;\\n        uint256 baseBorrowLimit;\\n        uint256 maxBorrowLimit;\\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\\n    }\\n}\\n\",\"keccak256\":\"0xf8a59b6c7963d0bd43be07db0c594e278f97e6dfa498dee8436e3707dd9f574e\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vault/iVaultResolver.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { Structs } from \\\"./structs.sol\\\";\\n\\ninterface IFluidVaultResolver {\\n    function vaultByNftId(uint nftId_) external view returns (address vault_);\\n\\n    function positionByNftId(\\n        uint nftId_\\n    ) external view returns (Structs.UserPosition memory userPosition_, Structs.VaultEntireData memory vaultData_);\\n\\n    function getVaultVariablesRaw(address vault_) external view returns (uint);\\n\\n    function getVaultVariables2Raw(address vault_) external view returns (uint);\\n\\n    function getTickHasDebtRaw(address vault_, int key_) external view returns (uint);\\n\\n    function getTickDataRaw(address vault_, int tick_) external view returns (uint);\\n\\n    function getBranchDataRaw(address vault_, uint branch_) external view returns (uint);\\n\\n    function getPositionDataRaw(address vault_, uint positionId_) external view returns (uint);\\n\\n    function getAllVaultsAddresses() external view returns (address[] memory vaults_);\\n\\n    function getVaultLiquidation(\\n        address vault_,\\n        uint tokenInAmt_\\n    ) external returns (Structs.LiquidationStruct memory liquidationData_);\\n\\n    function getVaultEntireData(address vault_) external view returns (Structs.VaultEntireData memory vaultData_);\\n}\\n\",\"keccak256\":\"0x8db2ba8c10b3f2a624ad2924ec5b59dbb805b42357eb98e9df6835963fff0634\",\"license\":\"MIT\"},\"contracts/periphery/resolvers/vault/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidVault } from \\\"../../../protocols/vault/interfaces/iVault.sol\\\";\\nimport { Structs as FluidLiquidityResolverStructs } from \\\"../liquidity/structs.sol\\\";\\n\\n// @dev Amounts are always in token amount for normal col / normal debt or in\\n// shares for Dex smart col / smart debt.\\ncontract Structs {\\n    struct Configs {\\n        // can be supplyRate instead if Vault Type is smart col. in that case if 1st bit == 1 then positive else negative\\n        uint16 supplyRateMagnifier;\\n        // can be borrowRate instead if Vault Type is smart debt. in that case if 1st bit == 1 then positive else negative\\n        uint16 borrowRateMagnifier;\\n        uint16 collateralFactor;\\n        uint16 liquidationThreshold;\\n        uint16 liquidationMaxLimit;\\n        uint16 withdrawalGap;\\n        uint16 liquidationPenalty;\\n        uint16 borrowFee;\\n        address oracle;\\n        // Oracle price is always debt per col, i.e. amount of debt for 1 col.\\n        // In case of Dex this price can be used to resolve shares values w.r.t. token0 or token1:\\n        // - T2: debt token per 1 col share\\n        // - T3: debt shares per 1 col token\\n        // - T4: debt shares per 1 col share\\n        uint oraclePriceOperate;\\n        uint oraclePriceLiquidate;\\n        address rebalancer;\\n        uint lastUpdateTimestamp;\\n    }\\n\\n    struct ExchangePricesAndRates {\\n        uint lastStoredLiquiditySupplyExchangePrice; // 0 in case of smart col\\n        uint lastStoredLiquidityBorrowExchangePrice; // 0 in case of smart debt\\n        uint lastStoredVaultSupplyExchangePrice;\\n        uint lastStoredVaultBorrowExchangePrice;\\n        uint liquiditySupplyExchangePrice; // set to 1e12 in case of smart col\\n        uint liquidityBorrowExchangePrice; // set to 1e12 in case of smart debt\\n        uint vaultSupplyExchangePrice;\\n        uint vaultBorrowExchangePrice;\\n        uint supplyRateLiquidity; // set to 0 in case of smart col. Must get per token through DexEntireData\\n        uint borrowRateLiquidity; // set to 0 in case of smart debt. Must get per token through DexEntireData\\n        // supplyRateVault or borrowRateVault:\\n        // - when normal col / debt: rate at liquidity + diff rewards or fee through magnifier (rewardsOrFeeRate below)\\n        // - when smart col / debt: rewards or fee rate at the vault itself. always == rewardsOrFeeRate below.\\n        // to get the full rates for vault when smart col / debt, combine with data from DexResolver:\\n        // - rateAtLiquidity for token0 or token1 (DexResolver)\\n        // - the rewards or fee rate at the vault (VaultResolver)\\n        // - the Dex APR (currently off-chain compiled through tracking swap events at the DEX)\\n        int supplyRateVault; // can be negative in case of smart col (meaning pay to supply)\\n        int borrowRateVault; // can be negative in case of smart debt (meaning get paid to borrow)\\n        // rewardsOrFeeRateSupply: rewards or fee rate in percent 1e2 precision (1% = 100, 100% = 10000).\\n        // positive rewards, negative fee.\\n        // for smart col vaults: supplyRateVault == supplyRateLiquidity.\\n        // for normal col vaults: relative percent to supplyRateLiquidity, e.g.:\\n        // when rewards: supplyRateLiquidity = 4%, rewardsOrFeeRateSupply = 20%, supplyRateVault = 4.8%.\\n        // when fee: supplyRateLiquidity = 4%, rewardsOrFeeRateSupply = -30%, supplyRateVault = 2.8%.\\n        int rewardsOrFeeRateSupply;\\n        // rewardsOrFeeRateBorrow: rewards or fee rate in percent 1e2 precision (1% = 100, 100% = 10000).\\n        // negative rewards, positive fee.\\n        // for smart debt vaults: borrowRateVault == borrowRateLiquidity.\\n        // for normal debt vaults: relative percent to borrowRateLiquidity, e.g.:\\n        // when rewards: borrowRateLiquidity = 4%, rewardsOrFeeRateBorrow = -20%, borrowRateVault = 3.2%.\\n        // when fee: borrowRateLiquidity = 4%, rewardsOrFeeRateBorrow = 30%, borrowRateVault = 5.2%.\\n        int rewardsOrFeeRateBorrow;\\n    }\\n\\n    struct TotalSupplyAndBorrow {\\n        uint totalSupplyVault;\\n        uint totalBorrowVault;\\n        uint totalSupplyLiquidityOrDex;\\n        uint totalBorrowLiquidityOrDex;\\n        uint absorbedSupply;\\n        uint absorbedBorrow;\\n    }\\n\\n    struct LimitsAndAvailability {\\n        // in case of DEX: withdrawable / borrowable amount of vault at DEX, BUT there could be that DEX can not withdraw\\n        // that much at Liquidity! So for DEX this must be combined with returned data in DexResolver.\\n        uint withdrawLimit;\\n        uint withdrawableUntilLimit;\\n        uint withdrawable;\\n        uint borrowLimit;\\n        uint borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\\n        uint borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\\n        uint borrowLimitUtilization; // borrow limit for `maxUtilization` config at Liquidity\\n        uint minimumBorrowing;\\n    }\\n\\n    struct CurrentBranchState {\\n        uint status; // if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\\n        int minimaTick;\\n        uint debtFactor;\\n        uint partials;\\n        uint debtLiquidity;\\n        uint baseBranchId;\\n        int baseBranchMinima;\\n    }\\n\\n    struct VaultState {\\n        uint totalPositions;\\n        int topTick;\\n        uint currentBranch;\\n        uint totalBranch;\\n        uint totalBorrow;\\n        uint totalSupply;\\n        CurrentBranchState currentBranchState;\\n    }\\n\\n    struct VaultEntireData {\\n        address vault;\\n        bool isSmartCol; // true if col token is a Fluid Dex\\n        bool isSmartDebt; // true if debt token is a Fluid Dex\\n        IFluidVault.ConstantViews constantVariables;\\n        Configs configs;\\n        ExchangePricesAndRates exchangePricesAndRates;\\n        TotalSupplyAndBorrow totalSupplyAndBorrow;\\n        LimitsAndAvailability limitsAndAvailability;\\n        VaultState vaultState;\\n        // liquidity related data such as supply amount, limits, expansion etc.\\n        // Also set for Dex, limits are in shares and same things apply as noted for LimitsAndAvailability above!\\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyData;\\n        // liquidity related data such as borrow amount, limits, expansion etc.\\n        // Also set for Dex, limits are in shares and same things apply as noted for LimitsAndAvailability above!\\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowData;\\n    }\\n\\n    struct UserPosition {\\n        uint nftId;\\n        address owner;\\n        bool isLiquidated;\\n        bool isSupplyPosition; // if true that means borrowing is 0\\n        int tick;\\n        uint tickId;\\n        uint beforeSupply;\\n        uint beforeBorrow;\\n        uint beforeDustBorrow;\\n        uint supply;\\n        uint borrow;\\n        uint dustBorrow;\\n    }\\n\\n    /// @dev liquidation related data\\n    /// @param vault address of vault\\n    /// @param token0In address of token in\\n    /// @param token0Out address of token out\\n    /// @param token1In address of token in (if smart debt)\\n    /// @param token1Out address of token out (if smart col)\\n    /// @param inAmt (without absorb liquidity) minimum of available liquidation\\n    /// @param outAmt (without absorb liquidity) expected token out, collateral to withdraw\\n    /// @param inAmtWithAbsorb (absorb liquidity included) minimum of available liquidation. In most cases it'll be same as inAmt but sometimes can be bigger.\\n    /// @param outAmtWithAbsorb (absorb liquidity included) expected token out, collateral to withdraw. In most cases it'll be same as outAmt but sometimes can be bigger.\\n    /// @param absorbAvailable true if absorb is available\\n    /// @dev Liquidity in with absirb will always be >= without asborb. Sometimes without asborb can provide better swaps,\\n    ///      sometimes with absirb can provide better swaps. But available in with absirb will always be >= One\\n    struct LiquidationStruct {\\n        address vault;\\n        address token0In;\\n        address token0Out;\\n        address token1In;\\n        address token1Out;\\n        // amounts in case of smart debt are in shares, otherwise token amounts.\\n        // smart col can not be liquidated so to exchange inAmt always use DexResolver DexState.tokenPerDebtShare\\n        // and tokenPerColShare for outAmt when Vault is smart col.\\n        uint inAmt;\\n        uint outAmt;\\n        uint inAmtWithAbsorb;\\n        uint outAmtWithAbsorb;\\n        bool absorbAvailable;\\n    }\\n\\n    struct AbsorbStruct {\\n        address vault;\\n        bool absorbAvailable;\\n    }\\n}\\n\",\"keccak256\":\"0x9920604f31459ced4f0353e37f98082368c6696cc892825d07f19afb457ee108\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vaultLiquidation/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidLiquidity } from \\\"../../../liquidity/interfaces/iLiquidity.sol\\\";\\nimport { Variables } from \\\"./variables.sol\\\";\\nimport { Structs } from \\\"./structs.sol\\\";\\nimport { FluidProtocolTypes } from \\\"../../../libraries/fluidProtocolTypes.sol\\\";\\nimport { Structs as VaultResolverStructs } from \\\"../vault/structs.sol\\\";\\nimport { IFluidVaultResolver } from \\\"../vault/iVaultResolver.sol\\\";\\nimport { IFluidVaultT1 } from \\\"../../../protocols/vault/interfaces/iVaultT1.sol\\\";\\nimport { LiquiditySlotsLink } from \\\"../../../libraries/liquiditySlotsLink.sol\\\";\\nimport { LiquidityCalcs } from \\\"../../../libraries/liquidityCalcs.sol\\\";\\nimport { BigMathMinified } from \\\"../../../libraries/bigMathMinified.sol\\\";\\n\\ninterface TokenInterface {\\n    function balanceOf(address) external view returns (uint);\\n}\\n\\n/// @notice Resolver contract that helps in finding available token (liquidation) swaps available in Fluid VaultT1s.\\n/// @dev    Note that on the same protocol, if \\\"withAbsorb = true\\\" is executed, this also consumes the swap\\n///         that would be on the same protocol with \\\"withAbsorb = false\\\". So the total available swap amount\\n///         at a protocol if both a swap with and without absorb is available is not `with inAmt + without inAmt`\\n///         but rather `with inAmt`.\\n///         Sometimes with absorb can provide better swaps, sometimes without absorb can provide better swaps.\\n///         But available liquidity for \\\"withAbsorb\\\" amounts will always be >= without absorb amounts.\\n/// @dev    The \\\"Raw\\\" methods return both the with and without absorb swaps for the same Fluid Vault, the non-\\\"Raw\\\"\\n///         methods automatically filter by the better ratio swap. For same cases a better optimization of ratios\\n///         is possible with custom logic based on the \\\"Raw\\\" methods, see details in comments.\\n/// @dev    for native token, send 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE.\\n/// @dev    returned swaps Struct can be fed into `getSwapTx` to prepare the tx that executes the swaps.\\n/// @dev    non-view methods in this contract are expected to be called with callStatic,\\n///         although they would anyway not do any actual state changes.\\ncontract FluidVaultLiquidationResolver is Variables, Structs {\\n    /// @notice thrown if an input param address is zero\\n    error FluidVaultLiquidationsResolver__AddressZero();\\n    /// @notice thrown if an invalid param is given to a method\\n    error FluidVaultLiquidationsResolver__InvalidParams();\\n\\n    /// @notice constructor sets the immutable vault resolver address\\n    constructor(IFluidVaultResolver vaultResolver_, IFluidLiquidity liquidity_) Variables(vaultResolver_, liquidity_) {\\n        if (address(vaultResolver_) == address(0) || address(liquidity_) == address(0)) {\\n            revert FluidVaultLiquidationsResolver__AddressZero();\\n        }\\n    }\\n\\n    /// @notice returns all available token swap paths\\n    function getAllSwapPaths() public view returns (SwapPath[] memory paths_) {\\n        address[] memory vaultAddresses_ = _getVaultT1s();\\n        paths_ = new SwapPath[](vaultAddresses_.length);\\n\\n        address borrowToken_;\\n        address supplyToken_;\\n        for (uint256 i; i < vaultAddresses_.length; ++i) {\\n            (borrowToken_, supplyToken_) = _getVaultTokens(vaultAddresses_[i]);\\n            paths_[i] = SwapPath({ protocol: vaultAddresses_[i], tokenIn: borrowToken_, tokenOut: supplyToken_ });\\n        }\\n    }\\n\\n    /// @notice returns all swap paths for a certain `tokenIn_` swapped to a `tokenOut_`.\\n    ///         returns empty array if no swap path is available for a given pair.\\n    function getSwapPaths(address tokenIn_, address tokenOut_) public view returns (SwapPath[] memory paths_) {\\n        address[] memory vaultAddresses_ = _getVaultT1s();\\n\\n        uint256 foundVaultsCount_;\\n        address[] memory foundVaults_ = new address[](vaultAddresses_.length);\\n\\n        address borrowToken_;\\n        address supplyToken_;\\n        for (uint256 i; i < vaultAddresses_.length; ++i) {\\n            (borrowToken_, supplyToken_) = _getVaultTokens(vaultAddresses_[i]);\\n\\n            if (borrowToken_ == tokenIn_ && supplyToken_ == tokenOut_) {\\n                foundVaults_[foundVaultsCount_] = vaultAddresses_[i];\\n                ++foundVaultsCount_;\\n            }\\n        }\\n\\n        paths_ = new SwapPath[](foundVaultsCount_);\\n        for (uint256 i; i < foundVaultsCount_; ++i) {\\n            paths_[i] = SwapPath({ protocol: foundVaults_[i], tokenIn: tokenIn_, tokenOut: tokenOut_ });\\n        }\\n    }\\n\\n    /// @notice returns all available swap paths for any `tokensIn_` to any `tokensOut_`.\\n    function getAnySwapPaths(\\n        address[] calldata tokensIn_,\\n        address[] calldata tokensOut_\\n    ) public view returns (SwapPath[] memory paths_) {\\n        SwapPath[] memory maxPaths_ = new SwapPath[](tokensIn_.length * tokensOut_.length);\\n\\n        address[] memory vaultAddresses_ = _getVaultT1s();\\n\\n        uint256 matches_;\\n\\n        address borrowToken_;\\n        address supplyToken_;\\n        unchecked {\\n            for (uint256 vi; vi < vaultAddresses_.length; ++vi) {\\n                (borrowToken_, supplyToken_) = _getVaultTokens(vaultAddresses_[vi]);\\n\\n                // for each vault, iterate over all possible input params token combinations\\n                for (uint256 i; i < tokensIn_.length; ++i) {\\n                    for (uint256 j; j < tokensOut_.length; ++j) {\\n                        if (borrowToken_ == tokensIn_[i] && supplyToken_ == tokensOut_[j]) {\\n                            maxPaths_[matches_] = SwapPath({\\n                                protocol: vaultAddresses_[vi],\\n                                tokenIn: borrowToken_,\\n                                tokenOut: supplyToken_\\n                            });\\n                            ++matches_;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            paths_ = new SwapPath[](matches_);\\n            for (uint256 i; i < matches_; ++i) {\\n                paths_[i] = maxPaths_[i];\\n            }\\n        }\\n    }\\n\\n    /// @notice returns the swap data for with and without absorb for a Fluid `vault_`.\\n    function getVaultSwapData(\\n        address vault_\\n    ) public returns (SwapData memory withoutAbsorb_, SwapData memory withAbsorb_) {\\n        VaultResolverStructs.LiquidationStruct memory liquidationData_ = VAULT_RESOLVER.getVaultLiquidation(vault_, 0);\\n\\n        withoutAbsorb_ = SwapData({\\n            inAmt: liquidationData_.inAmt,\\n            outAmt: liquidationData_.outAmt,\\n            withAbsorb: false,\\n            ratio: _calcRatio(liquidationData_.inAmt, liquidationData_.outAmt)\\n        });\\n\\n        withAbsorb_ = SwapData({\\n            inAmt: liquidationData_.inAmtWithAbsorb,\\n            outAmt: liquidationData_.outAmtWithAbsorb,\\n            withAbsorb: true,\\n            ratio: _calcRatio(liquidationData_.inAmtWithAbsorb, liquidationData_.outAmtWithAbsorb)\\n        });\\n    }\\n\\n    /// @notice returns the swap data for with and without absorb for multiple Fluid `vaults_`.\\n    function getVaultsSwapData(\\n        address[] memory vaults_\\n    ) public returns (SwapData[] memory withoutAbsorb_, SwapData[] memory withAbsorb_) {\\n        withoutAbsorb_ = new SwapData[](vaults_.length);\\n        withAbsorb_ = new SwapData[](vaults_.length);\\n        for (uint256 i; i < vaults_.length; ++i) {\\n            (withoutAbsorb_[i], withAbsorb_[i]) = getVaultSwapData(vaults_[i]);\\n        }\\n    }\\n\\n    /// @notice returns the swap data for with and without absorb for all Fluid vaults.\\n    function getAllVaultsSwapData() public returns (SwapData[] memory withoutAbsorb_, SwapData[] memory withAbsorb_) {\\n        return getVaultsSwapData(_getVaultT1s());\\n    }\\n\\n    /// @notice returns the available swap amounts at a certain `protocol_`. Only returns non-zero swaps.\\n    ///         For vault protocol considering both a swap that uses liquidation with absorb and without absorb.\\n    function getSwapForProtocol(address protocol_) public returns (Swap memory swap_) {\\n        if (protocol_ == address(0)) {\\n            return swap_;\\n        }\\n\\n        (address borrowToken_, address supplyToken_) = _getVaultTokens(protocol_);\\n        (SwapData memory withoutAbsorb_, SwapData memory withAbsorb_) = getVaultSwapData(protocol_);\\n\\n        swap_ = _getSwapAccountingForWithdrawable(\\n            Swap({\\n                path: SwapPath({ protocol: protocol_, tokenIn: borrowToken_, tokenOut: supplyToken_ }),\\n                data: _getBetterRatioSwapData(withoutAbsorb_, withAbsorb_)\\n            }),\\n            withAbsorb_.outAmt == 0 ? 0 : _getVaultT1Withdrawable(protocol_, supplyToken_)\\n        );\\n    }\\n\\n    /// @notice returns all available `swaps_` for multiple Fluid `vaults_` raw. Only returns non-zero swaps.\\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\\n    function getVaultsSwapRaw(address[] memory vaults_) public returns (Swap[] memory swaps_) {\\n        unchecked {\\n            uint256 nonZeroSwaps_;\\n            Swap[] memory allSwaps_ = new Swap[](vaults_.length * 2);\\n\\n            SwapData memory withoutAbsorb_;\\n            SwapData memory withAbsorb_;\\n            address borrowToken_;\\n            address supplyToken_;\\n            uint256 withdrawable_;\\n            for (uint256 i; i < vaults_.length; ++i) {\\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(vaults_[i]);\\n                if (withAbsorb_.inAmt == 0) {\\n                    // if with absorb is 0, then without absorb can only be 0 too\\n                    continue;\\n                }\\n                (borrowToken_, supplyToken_) = _getVaultTokens(vaults_[i]);\\n                withdrawable_ = _getVaultT1Withdrawable(vaults_[i], supplyToken_);\\n                if (withdrawable_ == 0) {\\n                    continue;\\n                }\\n                ++nonZeroSwaps_;\\n                if (withAbsorb_.inAmt == withoutAbsorb_.inAmt) {\\n                    // with absorb has the same liquidity as without absorb.\\n                    // running liquidate() with absorb in that case only costs extra gas. return only without absorb swap\\n                    withAbsorb_.inAmt = 0;\\n                } else if (withoutAbsorb_.inAmt > 0) {\\n                    // both with and without absorb swaps\\n                    ++nonZeroSwaps_;\\n                }\\n\\n                allSwaps_[i * 2] = _getSwapAccountingForWithdrawable(\\n                    Swap({\\n                        path: SwapPath({ protocol: vaults_[i], tokenIn: borrowToken_, tokenOut: supplyToken_ }),\\n                        data: withoutAbsorb_\\n                    }),\\n                    withdrawable_\\n                );\\n                allSwaps_[i * 2 + 1] = _getSwapAccountingForWithdrawable(\\n                    Swap({\\n                        path: SwapPath({ protocol: vaults_[i], tokenIn: borrowToken_, tokenOut: supplyToken_ }),\\n                        data: withAbsorb_\\n                    }),\\n                    withdrawable_\\n                );\\n            }\\n\\n            return _getNonZeroSwaps(allSwaps_, nonZeroSwaps_);\\n        }\\n    }\\n\\n    /// @notice returns all available `swaps_` for all Fluid vaults raw. Only returns non-zero swaps.\\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\\n    function getAllVaultsSwapRaw() public returns (Swap[] memory swaps_) {\\n        return getVaultsSwapRaw(_getVaultT1s());\\n    }\\n\\n    /// @notice returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.\\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\\n    function getSwapsForPathsRaw(SwapPath[] memory paths_) public returns (Swap[] memory swaps_) {\\n        unchecked {\\n            Swap[] memory allSwaps_ = new Swap[](paths_.length * 2);\\n\\n            uint256 nonZeroSwaps_;\\n            SwapData memory withoutAbsorb_;\\n            SwapData memory withAbsorb_;\\n            uint256 withdrawable_;\\n            for (uint256 i; i < paths_.length; ++i) {\\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(paths_[i].protocol);\\n\\n                if (withAbsorb_.inAmt == 0) {\\n                    // if with absorb is 0, then without absorb can only be 0 too\\n                    continue;\\n                }\\n                withdrawable_ = _getVaultT1Withdrawable(paths_[i].protocol, paths_[i].tokenOut);\\n                if (withdrawable_ == 0) {\\n                    continue;\\n                }\\n                ++nonZeroSwaps_;\\n                if (withAbsorb_.inAmt == withoutAbsorb_.inAmt) {\\n                    // with absorb has the same liquidity as without absorb.\\n                    // running liquidate() with absorb in that case only costs extra gas. return only without absorb swap\\n                    withAbsorb_.inAmt = 0;\\n                } else if (withoutAbsorb_.inAmt > 0) {\\n                    // both with and without absorb swaps\\n                    ++nonZeroSwaps_;\\n                }\\n\\n                allSwaps_[i * 2] = _getSwapAccountingForWithdrawable(\\n                    Swap({ path: paths_[i], data: withoutAbsorb_ }),\\n                    withdrawable_\\n                );\\n\\n                allSwaps_[i * 2 + 1] = _getSwapAccountingForWithdrawable(\\n                    Swap({ path: paths_[i], data: withAbsorb_ }),\\n                    withdrawable_\\n                );\\n            }\\n\\n            swaps_ = new Swap[](nonZeroSwaps_);\\n            uint256 index_;\\n            for (uint256 i; i < allSwaps_.length; ++i) {\\n                if (allSwaps_[i].data.inAmt > 0) {\\n                    swaps_[index_] = allSwaps_[i];\\n                    ++index_;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice finds all available `swaps_` for `tokenIn_` to `tokenOut_`.\\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\\n    function getSwapsRaw(address tokenIn_, address tokenOut_) public returns (Swap[] memory swaps_) {\\n        return getSwapsForPathsRaw(getSwapPaths(tokenIn_, tokenOut_));\\n    }\\n\\n    /// @notice finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.\\n    ///         Token pairs that are not available or where available swap amounts are zero\\n    ///         will not be present in the returned `swaps_` array.\\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\\n    function getAnySwapsRaw(\\n        address[] calldata tokensIn_,\\n        address[] calldata tokensOut_\\n    ) public returns (Swap[] memory swaps_) {\\n        return getSwapsForPathsRaw(getAnySwapPaths(tokensIn_, tokensOut_));\\n    }\\n\\n    /// @notice returns all available `swaps_` for multiple Fluid `vaults_`. Only returns non-zero swaps.\\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\\n    ///         better ratio.\\n    function getVaultsSwap(address[] memory vaults_) public returns (Swap[] memory swaps_) {\\n        unchecked {\\n            uint256 nonZeroSwaps_;\\n            Swap[] memory allSwaps_ = new Swap[](vaults_.length);\\n\\n            SwapData memory withoutAbsorb_;\\n            SwapData memory withAbsorb_;\\n            Swap memory swap_;\\n            uint256 withdrawable_;\\n            for (uint256 i; i < vaults_.length; ++i) {\\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(vaults_[i]);\\n                swap_ = Swap({\\n                    path: SwapPath({ protocol: vaults_[i], tokenIn: address(0), tokenOut: address(0) }),\\n                    data: _getBetterRatioSwapData(withoutAbsorb_, withAbsorb_)\\n                });\\n\\n                if (swap_.data.inAmt == 0) {\\n                    // no swap available on this vault\\n                    continue;\\n                }\\n                (swap_.path.tokenIn, swap_.path.tokenOut) = _getVaultTokens(vaults_[i]);\\n                withdrawable_ = _getVaultT1Withdrawable(swap_.path.protocol, swap_.path.tokenOut);\\n                if (withdrawable_ == 0) {\\n                    continue;\\n                }\\n\\n                ++nonZeroSwaps_;\\n\\n                allSwaps_[i] = _getSwapAccountingForWithdrawable(swap_, withdrawable_);\\n            }\\n\\n            return _getNonZeroSwaps(allSwaps_, nonZeroSwaps_);\\n        }\\n    }\\n\\n    /// @notice returns all available `swaps_` for all Fluid vaults. Only returns non-zero swaps.\\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\\n    ///         better ratio.\\n    function getAllVaultsSwap() public returns (Swap[] memory swaps_) {\\n        return getVaultsSwap(_getVaultT1s());\\n    }\\n\\n    /// @notice returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.\\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\\n    ///         better ratio.\\n    function getSwapsForPaths(SwapPath[] memory paths_) public returns (Swap[] memory swaps_) {\\n        unchecked {\\n            Swap[] memory allSwaps_ = new Swap[](paths_.length);\\n\\n            uint256 nonZeroSwaps_;\\n            Swap memory swap_;\\n            SwapData memory withoutAbsorb_;\\n            SwapData memory withAbsorb_;\\n            uint256 withdrawable_;\\n            for (uint256 i; i < paths_.length; ++i) {\\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(paths_[i].protocol);\\n                swap_ = Swap({ path: paths_[i], data: _getBetterRatioSwapData(withoutAbsorb_, withAbsorb_) });\\n\\n                if (swap_.data.inAmt == 0) {\\n                    // no swap available on this vault\\n                    continue;\\n                }\\n                withdrawable_ = _getVaultT1Withdrawable(swap_.path.protocol, swap_.path.tokenOut);\\n                if (withdrawable_ == 0) {\\n                    continue;\\n                }\\n\\n                ++nonZeroSwaps_;\\n\\n                allSwaps_[i] = _getSwapAccountingForWithdrawable(swap_, withdrawable_);\\n            }\\n\\n            return _getNonZeroSwaps(allSwaps_, nonZeroSwaps_);\\n        }\\n    }\\n\\n    /// @notice finds all available `swaps_` for `tokenIn_` to `tokenOut_`.\\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\\n    ///         better ratio.\\n    function getSwaps(address tokenIn_, address tokenOut_) public returns (Swap[] memory swaps_) {\\n        return getSwapsForPaths(getSwapPaths(tokenIn_, tokenOut_));\\n    }\\n\\n    /// @notice finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.\\n    ///         Token pairs that are not available or where available swap amounts are zero\\n    ///         will not be present in the returned `swaps_` array.\\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\\n    ///         better ratio.\\n    function getAnySwaps(\\n        address[] calldata tokensIn_,\\n        address[] calldata tokensOut_\\n    ) public returns (Swap[] memory swaps_) {\\n        return getSwapsForPaths(getAnySwapPaths(tokensIn_, tokensOut_));\\n    }\\n\\n    /// @notice returns the calldata to execute a swap as returned by the other methods in this contract.\\n    ///         `swap_.data.inAmt` must come from msg.sender, `swap_.data.outAmt` goes to `receiver_`. If the input token\\n    ///         is the native token, msg.value must be sent along when triggering the actual call with the returned calldata\\n    ///         which should be `swap_.data.inAmt`.\\n    /// @param swap_ Swap struct as returned by other methods\\n    /// @param receiver_ receiver address that the output token is sent to\\n    /// @param slippage_ maximum allowed slippage for the expected output token amount. Reverts iIf received token out\\n    ///                  amount is lower than this. in 1e4 percentage, e.g. 1% = 10000, 0.3% = 3000, 0.01% = 100, 0.0001% = 1.\\n    /// @return target_ target address where `calldata_` must be executed\\n    /// @return calldata_ the calldata that can be used to trigger the liquidation call, resulting in the desired swap.\\n    function getSwapTx(\\n        Swap calldata swap_,\\n        address receiver_,\\n        uint256 slippage_\\n    ) public pure returns (address target_, bytes memory calldata_) {\\n        if (swap_.path.protocol == address(0) || receiver_ == address(0)) {\\n            revert FluidVaultLiquidationsResolver__AddressZero();\\n        }\\n        if (slippage_ >= 1e6 || swap_.data.inAmt == 0 || swap_.data.outAmt == 0) {\\n            revert FluidVaultLiquidationsResolver__InvalidParams();\\n        }\\n\\n        uint256 colPerUnitDebt_ = (swap_.data.outAmt * 1e18) / swap_.data.inAmt;\\n        colPerUnitDebt_ = (colPerUnitDebt_ * (1e6 - slippage_)) / 1e6; // e.g. 50 * 99% / 100% = 49.5\\n\\n        calldata_ = abi.encodeWithSelector(\\n            IFluidVaultT1(swap_.path.protocol).liquidate.selector,\\n            swap_.data.inAmt,\\n            colPerUnitDebt_,\\n            receiver_,\\n            swap_.data.withAbsorb\\n        );\\n        target_ = swap_.path.protocol;\\n    }\\n\\n    /// @notice returns the same data as `getSwapTx` for an array of input `swaps_` at once.\\n    function getSwapTxs(\\n        Swap[] calldata swaps_,\\n        address receiver_,\\n        uint256 slippage_\\n    ) public pure returns (address[] memory targets_, bytes[] memory calldatas_) {\\n        targets_ = new address[](swaps_.length);\\n        calldatas_ = new bytes[](swaps_.length);\\n        for (uint256 i; i < swaps_.length; ++i) {\\n            (targets_[i], calldatas_[i]) = getSwapTx(swaps_[i], receiver_, slippage_);\\n        }\\n    }\\n\\n    /// @notice finds all swaps from `tokenIn_` to `tokenOut_` for an exact input amount `inAmt_`.\\n    ///         filters the available swaps and sorts them by ratio, so the returned swaps are the best available\\n    ///         swaps to reach the target `inAmt_`.\\n    ///         If the full available amount is less than the target `inAmt_`, the available amount is returned as `actualInAmt_`.\\n    /// @dev The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better\\n    /// but the target swap amount is more than the available without absorb liquidity. For this, currently the available\\n    /// withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity.\\n    /// The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false\\n    /// to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing\\n    /// amount up to the target amount with the worse ratio with absorb liquidity.\\n    /// @param tokenIn_ input token\\n    /// @param tokenOut_ output token\\n    /// @param inAmt_ exact input token amount that should be swapped to output token\\n    /// @return swaps_ swaps to reach the target amount, sorted by ratio in descending order\\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\\n    /// @return actualInAmt_ actual input token amount. Can be less than inAmt_ if all available swaps can not cover\\n    ///                      the target amount.\\n    /// @return outAmt_ output token amount received for `actualInAmt_`\\n    function exactInput(\\n        address tokenIn_,\\n        address tokenOut_,\\n        uint256 inAmt_\\n    ) public returns (Swap[] memory swaps_, uint256 actualInAmt_, uint256 outAmt_) {\\n        return filterToTargetInAmt(getSwapsRaw(tokenIn_, tokenOut_), inAmt_);\\n    }\\n\\n    /// @notice finds all swaps from `tokenIn_` to `tokenOut_` for an APPROXIMATE output amount `outAmt_`.\\n    ///         filters the available swaps and sorts them by ratio, so the returned swaps are the best available\\n    ///         swaps to reach the target `outAmt_`.\\n    ///         If the full available amount is less than the target `outAmt_`, the available amount is returned as `actualOutAmt_`.\\n    ///         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to\\n    ///         approximately estimate the required input amounts to reach a certain output amount. This\\n    ///         will change until execution and should be controlled with a maximum slippage.\\n    ///         Recommended to use exact input methods instead.\\n    /// @dev The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better\\n    /// but the target swap amount is more than the available without absorb liquidity. For this currently the available\\n    /// withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity.\\n    /// The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false\\n    /// to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing\\n    /// amount up to the target amount with the worse ratio with absorb liquidity.\\n    /// @param tokenIn_ input token\\n    /// @param tokenOut_ output token\\n    /// @param outAmt_ exact output token amount that should be swapped to from input token\\n    /// @return swaps_ swaps to reach the target amount, sorted by ratio in descending order\\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\\n    /// @return inAmt_ input token amount needed to receive `actualOutAmt_`\\n    /// @return approxOutAmt_ approximate output token amount. Can be less than `outAmt_` if all available swaps can not cover\\n    ///                       the target amount.\\n    function approxOutput(\\n        address tokenIn_,\\n        address tokenOut_,\\n        uint256 outAmt_\\n    ) public returns (Swap[] memory swaps_, uint256 inAmt_, uint256 approxOutAmt_) {\\n        return filterToApproxOutAmt(getSwapsRaw(tokenIn_, tokenOut_), outAmt_);\\n    }\\n\\n    /// @notice filters the `swaps_` to the point where `targetInAmt_` is reached.\\n    ///         This is best used in combination with the \\\"Raw\\\" methods, as the `targetInAmt_` allows for more optimized\\n    ///         filtering than otherwise done with the non-\\\"Raw\\\" methods.\\n    /// @return filteredSwaps_ swaps to reach the target amount, sorted by ratio in descending order\\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\\n    /// @return actualInAmt_ actual input amount. Can be less than targetInAmt_ if all available swaps can not cover\\n    ///                      the target amount.\\n    /// @return approxOutAmt_ actual estimated output amount.\\n    function filterToTargetInAmt(\\n        Swap[] memory swaps_,\\n        uint256 targetInAmt_\\n    ) public returns (Swap[] memory filteredSwaps_, uint256 actualInAmt_, uint256 approxOutAmt_) {\\n        return _filterToTarget(swaps_, targetInAmt_, type(uint256).max);\\n    }\\n\\n    /// @notice filters the `swaps_` to the point where APPROXIMATELY `targetOutAmt_` is reached.\\n    ///         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to\\n    ///         approximately estimate the required input amounts to reach a certain output amount. This\\n    ///         will change until execution and should be controlled with a maximum slippage.\\n    ///         Recommended to use exact input methods instead.\\n    ///         This is best used in combination with the \\\"Raw\\\" methods, as the `targetInAmt_` allows for more optimized\\n    ///         filtering than otherwise done with the non-\\\"Raw\\\" methods.\\n    /// @return filteredSwaps_ swaps to reach the target amount, sorted by ratio in descending order\\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\\n    /// @return actualInAmt_ actual input amount.\\n    /// @return approxOutAmt_ APPROXIMATE actual output amount. Can be less than targetOutAmt_ if all available swaps\\n    ///                      can not cover the target amount.\\n    function filterToApproxOutAmt(\\n        Swap[] memory swaps_,\\n        uint256 targetApproxOutAmt_\\n    ) public returns (Swap[] memory filteredSwaps_, uint256 actualInAmt_, uint256 approxOutAmt_) {\\n        return _filterToTarget(swaps_, type(uint256).max, targetApproxOutAmt_);\\n    }\\n\\n    function _getUserSupplyData(address user_, address token_) internal view returns (uint256) {\\n        return\\n            LIQUIDITY.readFromStorage(\\n                LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\\n                    LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\\n                    user_,\\n                    token_\\n                )\\n            );\\n    }\\n\\n    function _getExchangePricesAndConfig(address token_) internal view returns (uint256) {\\n        return\\n            LIQUIDITY.readFromStorage(\\n                LiquiditySlotsLink.calculateMappingStorageSlot(\\n                    LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\\n                    token_\\n                )\\n            );\\n    }\\n\\n    /// @dev get withdrawable amount at a certain T1 vault, which limits liquidations. Incl. balance check at Liquidity\\n    function _getVaultT1Withdrawable(address vault_, address token_) internal view returns (uint256 withdrawable_) {\\n        uint256 userSupplyData_ = _getUserSupplyData(vault_, token_);\\n\\n        if (userSupplyData_ == 0) {\\n            return 0;\\n        }\\n\\n        uint256 userSupply_ = BigMathMinified.fromBigNumber(\\n            (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & LiquidityCalcs.X64,\\n            LiquidityCalcs.DEFAULT_EXPONENT_SIZE,\\n            LiquidityCalcs.DEFAULT_EXPONENT_MASK\\n        );\\n\\n        // get updated expanded withdrawal limit\\n        uint256 withdrawalLimit_ = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\\n\\n        if (userSupplyData_ & 1 == 1) {\\n            uint256 exchangePricesAndConfig_ = _getExchangePricesAndConfig(token_);\\n            if (exchangePricesAndConfig_ == 0) {\\n                return 0;\\n            }\\n            (uint256 supplyExchangePrice_, ) = LiquidityCalcs.calcExchangePrices(exchangePricesAndConfig_);\\n            // convert raw amounts to normal for withInterest mode\\n            userSupply_ = (userSupply_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION;\\n            withdrawalLimit_ = (withdrawalLimit_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION;\\n        }\\n\\n        withdrawable_ = userSupply_ > withdrawalLimit_ ? userSupply_ - withdrawalLimit_ : 0;\\n        uint256 balanceOf_ = token_ == NATIVE_TOKEN_ADDRESS\\n            ? address(LIQUIDITY).balance\\n            : TokenInterface(token_).balanceOf(address(LIQUIDITY));\\n\\n        withdrawable_ = balanceOf_ > withdrawable_ ? withdrawable_ : balanceOf_;\\n    }\\n\\n    /// @dev limits a Swap liquidatable amount according to actually col side withdrawable amount\\n    function _getSwapAccountingForWithdrawable(\\n        Swap memory swap_,\\n        uint256 withdrawable_\\n    ) internal pure returns (Swap memory) {\\n        if (swap_.data.outAmt == 0) {\\n            return swap_;\\n        }\\n\\n        if (withdrawable_ < swap_.data.outAmt) {\\n            // reduce swap in and out amount to max withdrawable\\n            swap_.data.inAmt = (swap_.data.inAmt * withdrawable_) / swap_.data.outAmt;\\n            swap_.data.outAmt = withdrawable_;\\n        }\\n\\n        return swap_;\\n    }\\n\\n    /// @dev filters the `swaps_` to the point where either `targetInAmt_` or `targetOutAmt_` is reached.\\n    ///         To filter only by in or only by out amount, send `type(uint256).max` for the other param.\\n    /// @return filteredSwaps_ swaps to reach the target amount, sorted by ratio in descending order\\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\\n    /// @return actualInAmt_ actual input amount. Can be less than targetInAmt_ if all available swaps can not cover\\n    ///                      the target amount.\\n    /// @return actualOutAmt_ actual output amount. Can be less than targetOutAmt_ if all available swaps can not cover\\n    ///                      the target amount.\\n    function _filterToTarget(\\n        Swap[] memory swaps_,\\n        uint256 targetInAmt_,\\n        uint256 targetOutAmt_\\n    ) internal returns (Swap[] memory filteredSwaps_, uint256 actualInAmt_, uint256 actualOutAmt_) {\\n        swaps_ = _sortByRatio(swaps_);\\n        (filteredSwaps_, actualInAmt_, actualOutAmt_) = _filterSwapsUntilTarget(swaps_, targetInAmt_, targetOutAmt_);\\n\\n        if (actualInAmt_ > targetInAmt_ || actualOutAmt_ > targetOutAmt_) {\\n            // reduce last swap in amt to match target in amt\\n            uint256 lastSwapIndex_ = filteredSwaps_.length - 1;\\n\\n            uint256 missingInAmt_;\\n            if (actualInAmt_ > targetInAmt_) {\\n                // swaps_[i].data.inAmt is causing that we over reach targetInAmt_\\n                // so to get missing account from here until targetInAmt_, we only want\\n                // swaps_[i].data.inAmt minus whatever is too much (actualInAmt_ - targetInAmt_)\\n                missingInAmt_ = filteredSwaps_[lastSwapIndex_].data.inAmt + 1 - (actualInAmt_ - targetInAmt_);\\n            } else {\\n                // get missing in amt to use for liquidation call input param based on missing out amt and ratio\\n                uint256 missingOutAmt_ = filteredSwaps_[lastSwapIndex_].data.outAmt - (actualOutAmt_ - targetOutAmt_);\\n\\n                // get total available liquidation and the ratios for with absorb vs without absorb\\n                VaultResolverStructs.LiquidationStruct memory liquidationDataAvailable_ = VAULT_RESOLVER\\n                    .getVaultLiquidation(filteredSwaps_[lastSwapIndex_].path.protocol, 0);\\n\\n                uint256 withoutAbsorbRatio_ = _calcRatio(\\n                    liquidationDataAvailable_.inAmt,\\n                    liquidationDataAvailable_.outAmt\\n                );\\n                // calculate the ratio of the absorb only liquidity part\\n                uint256 absorbOnlyRatio_ = _calcRatio(\\n                    liquidationDataAvailable_.inAmtWithAbsorb - liquidationDataAvailable_.inAmt,\\n                    liquidationDataAvailable_.outAmtWithAbsorb - liquidationDataAvailable_.outAmt\\n                );\\n                if (absorbOnlyRatio_ > withoutAbsorbRatio_ || liquidationDataAvailable_.outAmt < missingOutAmt_) {\\n                    // with absorb has the better ratio than without absorb or without absorb can not fully cover\\n                    // the missing out amount. So with absorb has to be run.\\n                    // Note for the case liquidationDataAvailable_.outAmt < missingOutAmt_:\\n                    // missing in amt would ideally be a combination of the whole without absorb liquidity +\\n                    // some left over which has the different (worse) with absorb ratio.\\n                    // when running withAbsorb = true, always the whole with absorb liquidity is taken first.\\n                    // so to profit of the better without absorb liquidity, this would have to be turned into 2 swaps.\\n                    // but this might not always be better because of gas usage etc., so for simplicity we just\\n                    // take the whole absorb liquidity first.\\n\\n                    // check if absorb only liquidity covers the missing out amount, if so then the swap ratio is already known\\n                    // as absorbOnlyRatio_ which can be used to derive the required inAmt\\n                    uint256 asborbOnlyLiquidity_ = liquidationDataAvailable_.outAmtWithAbsorb -\\n                        liquidationDataAvailable_.outAmt;\\n                    if (asborbOnlyLiquidity_ >= missingOutAmt_) {\\n                        missingInAmt_ = (missingOutAmt_ * 1e27) / absorbOnlyRatio_ + 1;\\n                    } else {\\n                        // missing in amt is a combination of the whole absorb liquidity + some left over\\n                        // which has the different without absorb ratio\\n                        missingInAmt_ = (asborbOnlyLiquidity_ * 1e27) / absorbOnlyRatio_ + 1;\\n                        missingInAmt_ += ((missingOutAmt_ - asborbOnlyLiquidity_) * 1e27) / withoutAbsorbRatio_ + 1;\\n                    }\\n                } else {\\n                    // without absorb has the better ratio AND missing out amount can be covered by without absorb liquidity\\n                    missingInAmt_ = (missingOutAmt_ * 1e27) / withoutAbsorbRatio_ + 1;\\n                }\\n            }\\n\\n            VaultResolverStructs.LiquidationStruct memory liquidationData_ = VAULT_RESOLVER.getVaultLiquidation(\\n                filteredSwaps_[lastSwapIndex_].path.protocol,\\n                missingInAmt_\\n            );\\n\\n            actualInAmt_ -= filteredSwaps_[lastSwapIndex_].data.inAmt;\\n            actualOutAmt_ -= filteredSwaps_[lastSwapIndex_].data.outAmt;\\n\\n            if (filteredSwaps_[lastSwapIndex_].data.withAbsorb) {\\n                filteredSwaps_[lastSwapIndex_].data.inAmt = liquidationData_.inAmtWithAbsorb;\\n                filteredSwaps_[lastSwapIndex_].data.outAmt = liquidationData_.outAmtWithAbsorb;\\n                filteredSwaps_[lastSwapIndex_].data.ratio = _calcRatio(\\n                    liquidationData_.inAmtWithAbsorb,\\n                    liquidationData_.outAmtWithAbsorb\\n                );\\n            } else {\\n                filteredSwaps_[lastSwapIndex_].data.inAmt = liquidationData_.inAmt;\\n                filteredSwaps_[lastSwapIndex_].data.outAmt = liquidationData_.outAmt;\\n                filteredSwaps_[lastSwapIndex_].data.ratio = _calcRatio(liquidationData_.inAmt, liquidationData_.outAmt);\\n            }\\n\\n            actualInAmt_ += filteredSwaps_[lastSwapIndex_].data.inAmt;\\n            actualOutAmt_ += filteredSwaps_[lastSwapIndex_].data.outAmt;\\n        }\\n    }\\n\\n    /// @dev sorts `swaps_` by ratio descending. Higher ratio is better (getting more output for input).\\n    ///      Best ratio swap will be at pos 0, second best at pos 1 and so on\\n    function _sortByRatio(Swap[] memory swaps_) internal pure returns (Swap[] memory) {\\n        bool swapped_;\\n        Swap memory helper_;\\n        for (uint256 i = 1; i < swaps_.length; i++) {\\n            swapped_ = false;\\n            for (uint256 j = 0; j < swaps_.length - i; j++) {\\n                if (swaps_[j + 1].data.ratio > swaps_[j].data.ratio) {\\n                    helper_ = swaps_[j];\\n                    swaps_[j] = swaps_[j + 1];\\n                    swaps_[j + 1] = helper_;\\n                    swapped_ = true;\\n                }\\n            }\\n            if (!swapped_) {\\n                return swaps_;\\n            }\\n        }\\n\\n        return swaps_;\\n    }\\n\\n    /// @dev filters `swaps_` to exactly reach `targetInAmt_`. Takes into consideration to filter out any swaps\\n    ///      where both the withAbsorb and withoutAbsorb swap would be present for the same protocol, only\\n    ///      leaving the withAbsorb swap (as that includes withoutAbsorb).\\n    ///      Also returns the total in `sumInAmt_` and out `sumOutAmt_` amounts, which will be less than `targetInAmt_`\\n    ///      in the case that the target amount can not be reached even with all swaps.\\n    function _filterSwapsUntilTarget(\\n        Swap[] memory swaps_,\\n        uint256 targetInAmt_,\\n        uint256 targetOutAmt_\\n    ) internal returns (Swap[] memory filteredSwaps_, uint256 sumInAmt_, uint256 sumOutAmt_) {\\n        if (swaps_.length == 0) {\\n            return (swaps_, 0, 0);\\n        }\\n        uint256 filteredCount_;\\n        // find swaps needed until target in amt\\n        while (sumInAmt_ < targetInAmt_ && sumOutAmt_ < targetOutAmt_ && filteredCount_ < swaps_.length) {\\n            sumInAmt_ += swaps_[filteredCount_].data.inAmt;\\n            sumOutAmt_ += swaps_[filteredCount_].data.outAmt;\\n            ++filteredCount_;\\n        }\\n\\n        // must not double count without absorb when with absorb is already present\\n        // until filteredCount, for any protocol where with absorb is present,\\n        // filter out the without absorb if that swap is present too.\\n        // if any is found then the while to find swaps until targetAmt must be run again\\n        // as it will be less with the filtered out element deducted.\\n        uint256 duplicatesCount_;\\n        for (uint256 i; i < filteredCount_ - 1; ++i) {\\n            for (uint256 j = i + 1; j < filteredCount_; ++j) {\\n                if (swaps_[i].path.protocol == swaps_[j].path.protocol) {\\n                    // same protocol present twice (with and without absorb).\\n                    // mark without absorb to be removed by setting the inAmt to 0\\n                    if (swaps_[i].data.withAbsorb) {\\n                        swaps_[j].data.inAmt = 0;\\n                    } else {\\n                        swaps_[i].data.inAmt = 0;\\n                    }\\n                    duplicatesCount_++;\\n                }\\n            }\\n        }\\n\\n        if (duplicatesCount_ > 0) {\\n            uint256 index_;\\n            // filter swaps that are set to 0\\n            filteredSwaps_ = new Swap[](swaps_.length - duplicatesCount_);\\n            for (uint256 i; i < swaps_.length; ++i) {\\n                if (swaps_[i].data.inAmt > 0) {\\n                    filteredSwaps_[index_] = swaps_[i];\\n                    ++index_;\\n                }\\n            }\\n\\n            // recursive call again to reach target amount as planned.\\n            return _filterSwapsUntilTarget(filteredSwaps_, targetInAmt_, targetOutAmt_);\\n        }\\n\\n        // when clean of duplicates -> finished, return filtered swaps and total sumInAmt\\n        filteredSwaps_ = new Swap[](filteredCount_);\\n        for (uint256 i; i < filteredCount_; ++i) {\\n            filteredSwaps_[i] = swaps_[i];\\n        }\\n        return (filteredSwaps_, sumInAmt_, sumOutAmt_);\\n    }\\n\\n    /// @dev gets the better swap based on ratio of with vs without absorb swap data.\\n    function _getBetterRatioSwapData(\\n        SwapData memory withoutAbsorb_,\\n        SwapData memory withAbsorb_\\n    ) internal pure returns (SwapData memory swap_) {\\n        if (withAbsorb_.inAmt == 0) {\\n            // if ratio == 0, meaning inAmt is 0, then the with absorb swap is returned.\\n            return withAbsorb_;\\n        }\\n\\n        if (withAbsorb_.ratio > withoutAbsorb_.ratio) {\\n            // If (ratio of withAbsorb > ratio of withoutAbsorb) then always absorb should be true.\\n            return withAbsorb_;\\n        }\\n\\n        if (withAbsorb_.ratio == withoutAbsorb_.ratio) {\\n            if (withAbsorb_.inAmt == withoutAbsorb_.inAmt) {\\n                // with absorb has the same liquidity as without absorb.\\n                // running liquidate() with absorb in that case only costs extra gas. return only without absorb swap\\n                return withoutAbsorb_;\\n            }\\n\\n            // with absorb has more liquidity, but same ratio -> return with absorb\\n            return withAbsorb_;\\n        }\\n\\n        // ratio of without absorb is better.\\n        // Note: case where with absorb has worse ratio. but it could have significant more liquidity -> will not be\\n        // returned here as long as there is without absorb liquidity...\\n        return withoutAbsorb_;\\n    }\\n\\n    /// @dev filters `allSwaps_` to the non zero amount `swaps_`, knowing the `nonZeroSwapsCount_`\\n    function _getNonZeroSwaps(\\n        Swap[] memory allSwaps_,\\n        uint256 nonZeroSwapsCount_\\n    ) internal pure returns (Swap[] memory swaps_) {\\n        unchecked {\\n            swaps_ = new Swap[](nonZeroSwapsCount_);\\n            uint256 index_;\\n            for (uint256 i; i < allSwaps_.length; ++i) {\\n                if (allSwaps_[i].data.inAmt > 0) {\\n                    swaps_[index_] = allSwaps_[i];\\n                    ++index_;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev gets the `vault_` token in (borrow token) and token out (supply token)\\n    function _getVaultTokens(address vault_) internal view returns (address tokenIn_, address tokenOut_) {\\n        IFluidVaultT1.ConstantViews memory constants_ = IFluidVaultT1(vault_).constantsView();\\n        return (constants_.borrowToken, constants_.supplyToken);\\n    }\\n\\n    /// @dev returns ratio for how much outAmt_ am I getting for inAmt_. scaled by 1e27\\n    function _calcRatio(uint256 inAmt_, uint256 outAmt_) internal pure returns (uint256) {\\n        if (outAmt_ == 0) {\\n            return 0;\\n        }\\n        return (outAmt_ * 1e27) / inAmt_;\\n    }\\n\\n    /// @dev returns all VaultT1 type protocols at the Fluid VaultFactory\\n    function _getVaultT1s() internal view returns (address[] memory) {\\n        return FluidProtocolTypes.filterBy(VAULT_RESOLVER.getAllVaultsAddresses(), FluidProtocolTypes.VAULT_T1_TYPE);\\n    }\\n}\\n\",\"keccak256\":\"0x3f16560c9589ff29b34d64d79e2ebd7a6b543030ce0956e6195afecc8b25e329\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vaultLiquidation/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ncontract Structs {\\n    struct SwapPath {\\n        ///\\n        /// @param protocol vault address at which the token pair is available\\n        address protocol;\\n        ///\\n        /// @param tokenIn input token, borrow token at the vault\\n        address tokenIn;\\n        ///\\n        /// @param tokenOut output token, collateral token at the vault\\n        address tokenOut;\\n    }\\n\\n    struct SwapData {\\n        ///\\n        /// @param inAmt total input token amount\\n        uint256 inAmt;\\n        ///\\n        /// @param outAmt total output token amount received\\n        uint256 outAmt;\\n        ///\\n        /// @param withAbsorb flag for using mode \\\"withAbsorb\\\" when calling liquidate() on the Vault.\\n        ///                   Is set to true if a) liquidity without absorb would not\\n        ///                   cover the desired `inAmt_` or if b) the rate of with absorb is better than without absorb.\\n        bool withAbsorb;\\n        ///\\n        /// @param ratio ratio of outAmt / inAmt scaled by 1e27\\n        uint256 ratio;\\n    }\\n\\n    struct Swap {\\n        ///\\n        /// @param path swap path struct info such as protocol where the swap is available\\n        SwapPath path;\\n        ///\\n        /// @param data swap data struct info such as amounts\\n        SwapData data;\\n    }\\n}\\n\",\"keccak256\":\"0x439f4df12cb5893807641f807551cf068275f3e027b43d56f0538c717d4c795b\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vaultLiquidation/variables.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidVaultResolver } from \\\"../vault/iVaultResolver.sol\\\";\\nimport { IFluidLiquidity } from \\\"../../../liquidity/interfaces/iLiquidity.sol\\\";\\n\\ncontract Variables {\\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\\n\\n    IFluidVaultResolver public immutable VAULT_RESOLVER;\\n\\n    /// @notice address of the liquidity contract\\n    IFluidLiquidity public immutable LIQUIDITY;\\n\\n    constructor(IFluidVaultResolver vaultResolver_, IFluidLiquidity liquidity_) {\\n        VAULT_RESOLVER = vaultResolver_;\\n        LIQUIDITY = liquidity_;\\n    }\\n}\\n\",\"keccak256\":\"0xe553263830fdee379f7dea4a1328e65edc1bbb836b334ad41d5a3d7b2495ff72\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/interfaces/iVault.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\\ninterface IFluidVault {\\n    /// @notice returns the vault id\\n    function VAULT_ID() external view returns (uint256);\\n\\n    /// @notice returns the vault id\\n    function TYPE() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct Tokens {\\n        address token0;\\n        address token1;\\n    }\\n\\n    struct ConstantViews {\\n        address liquidity;\\n        address factory;\\n        address operateImplementation;\\n        address adminImplementation;\\n        address secondaryImplementation;\\n        address deployer; // address which deploys oracle\\n        address supply; // either liquidity layer or DEX protocol\\n        address borrow; // either liquidity layer or DEX protocol\\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\\n        uint256 vaultId;\\n        uint256 vaultType;\\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n    }\\n\\n    /// @notice returns all Vault constants\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    /// @notice fetches the latest user position after a liquidation\\n    function fetchLatestPosition(\\n        int256 positionTick_,\\n        uint256 positionTickId_,\\n        uint256 positionRawDebt_,\\n        uint256 tickData_\\n    )\\n        external\\n        view\\n        returns (\\n            int256, // tick\\n            uint256, // raw debt\\n            uint256, // raw collateral\\n            uint256, // branchID_\\n            uint256 // branchData_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices\\n    function updateExchangePrices(\\n        uint256 vaultVariables2_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices and writes them to storage\\n    function updateExchangePricesOnStorage()\\n        external\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice returns the liquidity contract address\\n    function LIQUIDITY() external view returns (address);\\n\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n\\n    function rebalance(\\n        int colToken0MinMax_,\\n        int colToken1MinMax_,\\n        int debtToken0MinMax_,\\n        int debtToken1MinMax_\\n    ) external payable returns (int supplyAmt_, int borrowAmt_);\\n\\n    /// @notice reverts with FluidLiquidateResult\\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\\n}\\n\",\"keccak256\":\"0xdd764652f8451a71d2f2006b2572fccd9c21f1d64196869bfc291d10f151f0c6\",\"license\":\"MIT\"},\"contracts/protocols/vault/interfaces/iVaultT1.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IFluidVaultT1 {\\n    /// @notice returns the vault id\\n    function VAULT_ID() external view returns (uint256);\\n\\n    /// @notice returns the vault factory address\\n    function VAULT_FACTORY() external view returns (address);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct ConstantViews {\\n        address liquidity;\\n        address factory;\\n        address adminImplementation;\\n        address secondaryImplementation;\\n        address supplyToken;\\n        address borrowToken;\\n        uint8 supplyDecimals;\\n        uint8 borrowDecimals;\\n        uint vaultId;\\n        bytes32 liquiditySupplyExchangePriceSlot;\\n        bytes32 liquidityBorrowExchangePriceSlot;\\n        bytes32 liquidityUserSupplySlot;\\n        bytes32 liquidityUserBorrowSlot;\\n    }\\n\\n    /// @notice returns all Vault constants\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    /// @notice fetches the latest user position after a liquidation\\n    function fetchLatestPosition(\\n        int256 positionTick_,\\n        uint256 positionTickId_,\\n        uint256 positionRawDebt_,\\n        uint256 tickData_\\n    )\\n        external\\n        view\\n        returns (\\n            int256, // tick\\n            uint256, // raw debt\\n            uint256, // raw collateral\\n            uint256, // branchID_\\n            uint256 // branchData_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices\\n    function updateExchangePrices(\\n        uint256 vaultVariables2_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices and writes them to storage\\n    function updateExchangePricesOnStorage()\\n        external\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice returns the liquidity contract address\\n    function LIQUIDITY() external view returns (address);\\n\\n    function operate(\\n        uint256 nftId_, // if 0 then new position\\n        int256 newCol_, // if negative then withdraw\\n        int256 newDebt_, // if negative then payback\\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256, // nftId_\\n            int256, // final supply amount. if - then withdraw\\n            int256 // final borrow amount. if - then payback\\n        );\\n\\n    function liquidate(\\n        uint256 debtAmt_,\\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\\n        address to_,\\n        bool absorb_\\n    ) external payable returns (uint actualDebtAmt_, uint actualColAmt_);\\n\\n    function absorb() payable external;\\n\\n    function rebalance() external payable returns (int supplyAmt_, int borrowAmt_);\\n\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n}\\n\",\"keccak256\":\"0x1d81c36ec35f5929975a91401a3ee00d08f2a7b3d5cf3adc2a3ac1ea02facfd3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c06040523480156200001157600080fd5b50604051620044893803806200448983398101604081905262000034916200009e565b6001600160a01b03808316608081905290821660a05215806200005e57506001600160a01b038116155b156200007d576040516303c99f9d60e61b815260040160405180910390fd5b5050620000dd565b6001600160a01b03811681146200009b57600080fd5b50565b60008060408385031215620000b257600080fd5b8251620000bf8162000085565b6020840151909250620000d28162000085565b809150509250929050565b60805160a05161434e6200013b600039600081816101ec0152818161262b015281816126a50152818161302701526131d201526000818161030a0152818161148201528181611d7201528181611f8b01526121e0015261434e6000f3fe608060405234801561001057600080fd5b50600436106101a35760003560e01c80637bfb86ff116100ee5780638953b9d611610097578063c5f8b2e511610071578063c5f8b2e5146103da578063e082bca2146103ed578063e979e87414610400578063ed6bf8bc1461040857600080fd5b80638953b9d6146103865780639f5de875146103a7578063aa822df6146103c757600080fd5b8063838fef5c116100c8578063838fef5c1461033f578063861d3ac4146103525780638651d5ec1461037357600080fd5b80637bfb86ff146102f25780637f3e2b48146103055780638011ba331461032c57600080fd5b80634c6fdc1a1161015057806365eb6bd41161012a57806365eb6bd4146102b95780636c855962146102cc5780637119484a146102df57600080fd5b80634c6fdc1a146102805780635a980a9f146102935780635e47ec03146102a657600080fd5b80633c199241116101815780633c19924114610233578063404fcab2146102485780634296bdff1461026a57600080fd5b806321d3b7f4146101a8578063232306ea146101c65780632861c7d1146101e7575b600080fd5b6101b061041b565b6040516101bd91906135d3565b60405180910390f35b6101d96101d436600461360b565b61042d565b6040516101bd9291906136fb565b61020e7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101bd565b61023b610573565b6040516101bd91906137c7565b61025b610256366004613844565b6106eb565b6040516101bd93929190613885565b610272610713565b6040516101bd929190613907565b61027261028e366004613a62565b610729565b61023b6102a1366004613b42565b6108a1565b61025b6102b4366004613c32565b610bc8565b61025b6102c7366004613844565b610c05565b6101b06102da366004613b42565b610c1d565b6101b06102ed366004613a62565b610c37565b6101b0610300366004613a62565b610f18565b61020e7f000000000000000000000000000000000000000000000000000000000000000081565b6101b061033a366004613d5d565b611149565b6101b061034d366004613d5d565b611161565b610365610360366004613d96565b611170565b6040516101bd929190613ddf565b61025b610381366004613c32565b6113a9565b610399610394366004613e16565b6113d9565b6040516101bd929190613e33565b6103ba6103b5366004613e16565b61157a565b6040516101bd9190613e83565b61023b6103d5366004613d5d565b61163b565b6101b06103e8366004613b42565b6118c1565b6101b06103fb366004613e91565b6118d2565b6101b0611bd5565b6101b0610416366004613e91565b611be2565b6060610428610300611d6b565b905090565b6060808467ffffffffffffffff8111156104495761044961392c565b604051908082528060200260200182016040528015610472578160200160208202803683370190505b5091508467ffffffffffffffff81111561048e5761048e61392c565b6040519080825280602002602001820160405280156104c157816020015b60608152602001906001900390816104ac5790505b50905060005b85811015610569576104f18787838181106104e4576104e4613f2b565b905060e002018686611170565b84838151811061050357610503613f2b565b6020026020010184848151811061051c5761051c613f2b565b602002602001018290528273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681525050508061056290613f89565b90506104c7565b5094509492505050565b6060600061057f611d6b565b9050805167ffffffffffffffff81111561059b5761059b61392c565b60405190808252806020026020018201604052801561060457816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9092019101816105b95790505b50915060008060005b83518110156106e45761063884828151811061062b5761062b613f2b565b6020026020010151611e29565b8093508194505050604051806060016040528085838151811061065d5761065d613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018473ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff168152508582815181106106c8576106c8613f2b565b6020026020010181905250806106dd90613f89565b905061060d565b5050505090565b60606000806107036106fd8787611161565b85610bc8565b9250925092505b93509350939050565b60608061072161028e611d6b565b915091509091565b606080825167ffffffffffffffff8111156107465761074661392c565b6040519080825280602002602001820160405280156107a457816020015b61079160405180608001604052806000815260200160008152602001600015158152602001600081525090565b8152602001906001900390816107645790505b509150825167ffffffffffffffff8111156107c1576107c161392c565b60405190808252806020026020018201604052801561081f57816020015b61080c60405180608001604052806000815260200160008152602001600015158152602001600081525090565b8152602001906001900390816107df5790505b50905060005b835181101561089b5761085084828151811061084357610843613f2b565b60200260200101516113d9565b84838151811061086257610862613f2b565b6020026020010184848151811061087b5761087b613f2b565b6020026020010182905282905250508061089490613f89565b9050610825565b50915091565b606060006108af8386613fc1565b67ffffffffffffffff8111156108c7576108c761392c565b60405190808252806020026020018201604052801561093057816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9092019101816108e55790505b509050600061093d611d6b565b90506000806000805b8451811015610aea5761096485828151811061062b5761062b613f2b565b909350915060005b8a811015610ae15760005b89811015610ad8578c8c8381811061099157610991613f2b565b90506020020160208101906109a69190613e16565b73ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16148015610a3157508a8a828181106109ed576109ed613f2b565b9050602002016020810190610a029190613e16565b73ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16145b15610ad0576040518060600160405280888581518110610a5357610a53613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff16815250888781518110610abe57610abe613f2b565b60200260200101819052508560010195505b600101610977565b5060010161096c565b50600101610946565b508267ffffffffffffffff811115610b0457610b0461392c565b604051908082528060200260200182016040528015610b6d57816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff909201910181610b225790505b50955060005b83811015610bba57858181518110610b8d57610b8d613f2b565b6020026020010151878281518110610ba757610ba7613f2b565b6020908102919091010152600101610b73565b505050505050949350505050565b6060600080610bf885857fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff611eb4565b9250925092509250925092565b6060600080610703610c178787611161565b856113a9565b6060610c2e6103fb868686866108a1565b95945050505050565b6060600080835160020267ffffffffffffffff811115610c5957610c5961392c565b604051908082528060200260200182016040528015610c9257816020015b610c7f6134bf565b815260200190600190039081610c775790505b509050610cc260405180608001604052806000815260200160008152602001600015158152602001600081525090565b610cef60405180608001604052806000815260200160008152602001600015158152602001600081525090565b6000806000805b8951811015610f0057610d148a828151811061084357610843613f2b565b8051919750955015610ef857610d358a828151811061062b5761062b613f2b565b8094508195505050610d608a8281518110610d5257610d52613f2b565b6020026020010151846124e5565b91508115610ef8578551855160019099019803610d805760008552610d8e565b855115610d8e578760010197505b610e21604051806040016040528060405180606001604052808e8681518110610db957610db9613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018873ffffffffffffffffffffffffffffffffffffffff1681526020018773ffffffffffffffffffffffffffffffffffffffff16815250815260200188815250836126f8565b878260020281518110610e3657610e36613f2b565b6020026020010181905250610ed4604051806040016040528060405180606001604052808e8681518110610e6c57610e6c613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018873ffffffffffffffffffffffffffffffffffffffff1681526020018773ffffffffffffffffffffffffffffffffffffffff16815250815260200187815250836126f8565b878260020260010181518110610eec57610eec613f2b565b60200260200101819052505b600101610cf6565b50610f0b8688612761565b9998505050505050505050565b6060600080835167ffffffffffffffff811115610f3757610f3761392c565b604051908082528060200260200182016040528015610f7057816020015b610f5d6134bf565b815260200190600190039081610f555790505b509050610fa060405180608001604052806000815260200160008152602001600015158152602001600081525090565b610fcd60405180608001604052806000815260200160008152602001600015158152602001600081525090565b610fd56134bf565b6000805b885181101561113257610ff789828151811061084357610843613f2b565b8095508196505050604051806040016040528060405180606001604052808c858151811061102757611027613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152508152602001611091878761283d565b90526020810151519093501561112a576110b689828151811061062b5761062b613f2b565b845173ffffffffffffffffffffffffffffffffffffffff91821660408083019190915292909116602090910152835180519101516110f491906124e5565b9150811561112a5786600101965061110c83836126f8565b86828151811061111e5761111e613f2b565b60200260200101819052505b600101610fd9565b5061113d8587612761565b98975050505050505050565b6060611158610416848461163b565b90505b92915050565b60606111586103fb848461163b565b60006060816111826020870187613e16565b73ffffffffffffffffffffffffffffffffffffffff1614806111b8575073ffffffffffffffffffffffffffffffffffffffff8416155b156111ef576040517ff267e74000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b620f42408310158061120357506060850135155b8061121057506080850135155b15611247576040517fb55de08000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600060608601356112646080880135670de0b6b3a7640000613fc1565b61126e9190614007565b9050620f424061127e8582614042565b6112889083613fc1565b6112929190614007565b90506112a16020870187613e16565b507f8433ea2200000000000000000000000000000000000000000000000000000000606087013582876112da60c08b0160a08c01614055565b6040516024810194909452604484019290925273ffffffffffffffffffffffffffffffffffffffff1660648301521515608482015260a401604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052602080820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090941693909317909252925061139e90870187613e16565b925050935093915050565b6060600080610bf8857fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff86611eb4565b61140660405180608001604052806000815260200160008152602001600015158152602001600081525090565b61143360405180608001604052806000815260200160008152602001600015158152602001600081525090565b6040517f1fcd364900000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8481166004830152600060248301819052917f000000000000000000000000000000000000000000000000000000000000000090911690631fcd364990604401610140604051808303816000875af11580156114ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114f2919061408d565b905060405180608001604052808260a0015181526020018260c00151815260200160001515815260200161152e8360a001518460c001516128b7565b815250925060405180608001604052808260e001518152602001826101000151815260200160011515815260200161156f8360e001518461010001516128b7565b815250915050915091565b6115826134bf565b73ffffffffffffffffffffffffffffffffffffffff82166115a257919050565b6000806115ae84611e29565b915091506000806115be866113d9565b6040805160a08101825273ffffffffffffffffffffffffffffffffffffffff808b169282019283528881166060830152871660808201529081529193509150611631906020810161160f858561283d565b905260208301511561162a5761162588866124e5565b6126f8565b60006126f8565b9695505050505050565b60606000611647611d6b565b9050600080825167ffffffffffffffff8111156116665761166661392c565b60405190808252806020026020018201604052801561168f578160200160208202803683370190505b50905060008060005b8551811015611780576116b686828151811061062b5761062b613f2b565b909350915073ffffffffffffffffffffffffffffffffffffffff808416908a1614801561170e57508773ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b156117705785818151811061172557611725613f2b565b602002602001015184868151811061173f5761173f613f2b565b73ffffffffffffffffffffffffffffffffffffffff9092166020928302919091019091015261176d85613f89565b94505b61177981613f89565b9050611698565b508367ffffffffffffffff81111561179a5761179a61392c565b60405190808252806020026020018201604052801561180357816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9092019101816117b85790505b50955060005b848110156118b557604051806060016040528085838151811061182e5761182e613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018a73ffffffffffffffffffffffffffffffffffffffff1681526020018973ffffffffffffffffffffffffffffffffffffffff1681525087828151811061189957611899613f2b565b6020026020010181905250806118ae90613f89565b9050611809565b50505050505092915050565b6060610c2e610416868686866108a1565b60606000825160020267ffffffffffffffff8111156118f3576118f361392c565b60405190808252806020026020018201604052801561192c57816020015b6119196134bf565b8152602001906001900390816119115790505b509050600061195e60405180608001604052806000815260200160008152602001600015158152602001600081525090565b61198b60405180608001604052806000815260200160008152602001600015158152602001600081525090565b6000805b8751811015611af6576119be8882815181106119ad576119ad613f2b565b6020026020010151600001516113d9565b8051919550935015611aee57611a0e8882815181106119df576119df613f2b565b6020026020010151600001518983815181106119fd576119fd613f2b565b6020026020010151604001516124e5565b91508115611aee578351835160019096019503611a2e5760008352611a3c565b835115611a3c578460010194505b611a7360405180604001604052808a8481518110611a5c57611a5c613f2b565b6020026020010151815260200186815250836126f8565b868260020281518110611a8857611a88613f2b565b6020026020010181905250611aca60405180604001604052808a8481518110611ab357611ab3613f2b565b6020026020010151815260200185815250836126f8565b868260020260010181518110611ae257611ae2613f2b565b60200260200101819052505b60010161198f565b508367ffffffffffffffff811115611b1057611b1061392c565b604051908082528060200260200182016040528015611b4957816020015b611b366134bf565b815260200190600190039081611b2e5790505b5095506000805b8651811015611bc9576000878281518110611b6d57611b6d613f2b565b602002602001015160200151600001511115611bc157868181518110611b9557611b95613f2b565b6020026020010151888381518110611baf57611baf613f2b565b60200260200101819052508160010191505b600101611b50565b50505050505050919050565b60606104286102ed611d6b565b60606000825167ffffffffffffffff811115611c0057611c0061392c565b604051908082528060200260200182016040528015611c3957816020015b611c266134bf565b815260200190600190039081611c1e5790505b5090506000611c466134bf565b611c7360405180608001604052806000815260200160008152602001600015158152602001600081525090565b611ca060405180608001604052806000815260200160008152602001600015158152602001600081525090565b6000805b8851811015611d6057611cc28982815181106119ad576119ad613f2b565b809450819550505060405180604001604052808a8381518110611ce757611ce7613f2b565b60200260200101518152602001611cfe868661283d565b905260208101515190955015611d585784518051604090910151611d2291906124e5565b91508115611d5857856001019550611d3a85836126f8565b878281518110611d4c57611d4c613f2b565b60200260200101819052505b600101611ca4565b5061113d8686612761565b60606104287f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a8d9f4936040518163ffffffff1660e01b8152600401600060405180830381865afa158015611ddb573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052611e21919081019061413a565b6127106128ea565b60008060008373ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b81526004016101a060405180830381865afa158015611e7a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e9e91906141da565b90508060a0015181608001519250925050915091565b6060600080611ec286612b1f565b9550611ecf868686612c70565b9194509250905084821180611ee357508381115b1561070a57600060018451611ef89190614042565b9050600086841115611f4d57611f0e8785614042565b858381518110611f2057611f20613f2b565b602002602001015160200151600001516001611f3c91906142b7565b611f469190614042565b90506121dc565b6000611f598785614042565b868481518110611f6b57611f6b613f2b565b60200260200101516020015160200151611f859190614042565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631fcd3649888681518110611fd757611fd7613f2b565b602090810291909101015151516040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff909116600482015260006024820152604401610140604051808303816000875af1158015612057573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207b919061408d565b905060006120918260a001518360c001516128b7565b905060006120c68360a001518460e001516120ac9190614042565b8460c001518561010001516120c19190614042565b6128b7565b9050818111806120d95750838360c00151105b156121a85760008360c001518461010001516120f59190614042565b90508481106121315781612115866b033b2e3c9fd0803ce8000000613fc1565b61211f9190614007565b61212a9060016142b7565b95506121a2565b81612148826b033b2e3c9fd0803ce8000000613fc1565b6121529190614007565b61215d9060016142b7565b95508261216a8287614042565b612180906b033b2e3c9fd0803ce8000000613fc1565b61218a9190614007565b6121959060016142b7565b61219f90876142b7565b95505b506121d7565b816121bf856b033b2e3c9fd0803ce8000000613fc1565b6121c99190614007565b6121d49060016142b7565b94505b505050505b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631fcd364987858151811061222c5761222c613f2b565b602090810291909101015151516040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff909116600482015260248101859052604401610140604051808303816000875af11580156122ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122d0919061408d565b90508583815181106122e4576122e4613f2b565b60200260200101516020015160000151856122ff9190614042565b945085838151811061231357612313613f2b565b602002602001015160200151602001518461232e9190614042565b935085838151811061234257612342613f2b565b60200260200101516020015160400151156123ec578060e0015186848151811061236e5761236e613f2b565b602002602001015160200151600001818152505080610100015186848151811061239a5761239a613f2b565b60200260200101516020015160200181815250506123c18160e001518261010001516128b7565b8684815181106123d3576123d3613f2b565b602002602001015160200151606001818152505061247b565b8060a0015186848151811061240357612403613f2b565b60200260200101516020015160000181815250508060c0015186848151811061242e5761242e613f2b565b60200260200101516020015160200181815250506124548160a001518260c001516128b7565b86848151811061246657612466613f2b565b60200260200101516020015160600181815250505b85838151811061248d5761248d613f2b565b60200260200101516020015160000151856124a891906142b7565b94508583815181106124bc576124bc613f2b565b60200260200101516020015160200151846124d791906142b7565b935050505093509350939050565b6000806124f28484613023565b90508060000361250657600091505061115b565b600981901c66ffffffffffffff16600182901c60ff161b600061252983836130cc565b9050826001166001036125a157600061254186613160565b90508060000361255857600094505050505061115b565b60006125638261323d565b50905064e8d4a510006125768286613fc1565b6125809190614007565b935064e8d4a510006125928285613fc1565b61259c9190614007565b925050505b8082116125af5760006125b9565b6125b98183614042565b9350600073ffffffffffffffffffffffffffffffffffffffff861673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee146126a3576040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000811660048301528716906370a0823190602401602060405180830381865afa15801561267a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061269e91906142ca565b6126dc565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16315b90508481116126eb57806126ed565b845b979650505050505050565b6127006134bf565b82602001516020015160000361271757508161115b565b82602001516020015182101561275a5760208084015190810151905161273e908490613fc1565b6127489190614007565b60208085018051929092529051018290525b5090919050565b60608167ffffffffffffffff81111561277c5761277c61392c565b6040519080825280602002602001820160405280156127b557816020015b6127a26134bf565b81526020019060019003908161279a5790505b5090506000805b84518110156128355760008582815181106127d9576127d9613f2b565b60200260200101516020015160000151111561282d5784818151811061280157612801613f2b565b602002602001015183838151811061281b5761281b613f2b565b60200260200101819052508160010191505b6001016127bc565b505092915050565b61286a60405180608001604052806000815260200160008152602001600015158152602001600081525090565b815160000361287a57508061115b565b82606001518260600151111561289157508061115b565b826060015182606001510361275a5782518251036128b057508161115b565b508061115b565b6000816000036128c95750600061115b565b826128e0836b033b2e3c9fd0803ce8000000613fc1565b6111589190614007565b8151606090600090815b8551811015612a005785818151811061290f5761290f613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1663bb24fe8a6040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561299b575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612998918101906142ca565b60015b6129a95761271092506129ac565b92505b8483146129f85760008682815181106129c7576129c7613f2b565b73ffffffffffffffffffffffffffffffffffffffff909216602092830291909101909101526129f5826142e3565b91505b6001016128f4565b508067ffffffffffffffff811115612a1a57612a1a61392c565b604051908082528060200260200182016040528015612a43578160200160208202803683370190505b5092506000805b8651811015612b1557600073ffffffffffffffffffffffffffffffffffffffff16878281518110612a7d57612a7d613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1614612b0d57868181518110612ab257612ab2613f2b565b6020026020010151858381518110612acc57612acc613f2b565b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508160010191505b600101612a4a565b5050505092915050565b60606000612b2b6134bf565b60015b8451811015612c67576000925060005b818651612b4b9190614042565b811015612c4657858181518110612b6457612b64613f2b565b6020026020010151602001516060015186826001612b8291906142b7565b81518110612b9257612b92613f2b565b602002602001015160200151606001511115612c3457858181518110612bba57612bba613f2b565b6020026020010151925085816001612bd291906142b7565b81518110612be257612be2613f2b565b6020026020010151868281518110612bfc57612bfc613f2b565b60209081029190910101528286612c148360016142b7565b81518110612c2457612c24613f2b565b6020026020010181905250600193505b80612c3e81613f89565b915050612b3e565b5082612c555750929392505050565b80612c5f81613f89565b915050612b2e565b50929392505050565b60606000808551600003612c8c5750849150600090508061070a565b60005b8583108015612c9d57508482105b8015612ca95750865181105b15612d1c57868181518110612cc057612cc0613f2b565b6020026020010151602001516000015183612cdb91906142b7565b9250868181518110612cef57612cef613f2b565b6020026020010151602001516020015182612d0a91906142b7565b9150612d1581613f89565b9050612c8f565b6000805b612d2b600184614042565b811015612e61576000612d3f8260016142b7565b90505b83811015612e5057898181518110612d5c57612d5c613f2b565b6020026020010151600001516000015173ffffffffffffffffffffffffffffffffffffffff168a8381518110612d9457612d94613f2b565b6020026020010151600001516000015173ffffffffffffffffffffffffffffffffffffffff1603612e4057898281518110612dd157612dd1613f2b565b6020026020010151602001516040015115612e0e5760008a8281518110612dfa57612dfa613f2b565b602090810291909101810151015152612e32565b60008a8381518110612e2257612e22613f2b565b6020908102919091018101510151525b82612e3c81613f89565b9350505b612e4981613f89565b9050612d42565b50612e5a81613f89565b9050612d20565b508015612f6f576000818951612e779190614042565b67ffffffffffffffff811115612e8f57612e8f61392c565b604051908082528060200260200182016040528015612ec857816020015b612eb56134bf565b815260200190600190039081612ead5790505b50955060005b8951811015612f555760008a8281518110612eeb57612eeb613f2b565b602002602001015160200151600001511115612f4557898181518110612f1357612f13613f2b565b6020026020010151878381518110612f2d57612f2d613f2b565b602002602001018190525081612f4290613f89565b91505b612f4e81613f89565b9050612ece565b50612f61868989612c70565b95509550955050505061070a565b8167ffffffffffffffff811115612f8857612f8861392c565b604051908082528060200260200182016040528015612fc157816020015b612fae6134bf565b815260200190600190039081612fa65790505b50945060005b8281101561301757888181518110612fe157612fe1613f2b565b6020026020010151868281518110612ffb57612ffb613f2b565b60200260200101819052508061301090613f89565b9050612fc7565b50505093509350939050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b5c736e461306d6008868661344f565b6040518263ffffffff1660e01b815260040161308b91815260200190565b602060405180830381865afa1580156130a8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061115891906142ca565b600066ffffffffffffff604984901c1660ff604185901c161b8082036130f657600091505061115b565b612710613fff60a286901c168402046401ffffffff608186901c16420362ffffff60b087901c166131278284613fc1565b6131319190614007565b9050808311613141576000613145565b8083035b93505080840383811115613157578093505b50505092915050565b6040805173ffffffffffffffffffffffffffffffffffffffff838116602080840191909152600583850152835180840385018152606084019485905280519101207fb5c736e40000000000000000000000000000000000000000000000000000000090935260648201929092526000917f0000000000000000000000000000000000000000000000000000000000000000169063b5c736e490608401602060405180830381865afa158015613219573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061115b91906142ca565b67ffffffffffffffff605b82901c811690609b83901c1681158061325f575080155b1561329f576040517fd50d751200000000000000000000000000000000000000000000000000000000815262011171600482015260240160405180910390fd5b61ffff8316603a84901c6401ffffffff16428181039160ea87901c617fff169114806132c9575082155b806132d45750806001145b156132e157505050915091565b64496cebb80084840283020484019350617fff60db87901c1692508260010361330c57505050915091565b826001166001036133615760019290921c91826c7e37be2022c0914b26800000008161333a5761333a613fd8565b049250612710601e87901c613fff166b033b2e3c9fd0803ce800000085010204925061338e565b60019290921c916305f5e100601e87901c613fff166127108501026b033b2e3c9fd0803ce8000000020492505b806001166001036133c55760011c61271081016b033b2e3c9fd0803ce80000008202816133bd576133bd613fd8565b0490506133fb565b60011c61271081016b033b2e3c9fd0803ce80000008202816133e9576133e9613fd8565b046b033b2e3c9fd0803ce80000000390505b760a70c3c40a64e6c51999090b65f67d92400000000000008382026127100261ffff881691900402601087901c613fff16612710030292506801b5a660ea44b8000085840283020485019450505050915091565b6040805173ffffffffffffffffffffffffffffffffffffffff848116602080840191909152828401879052835180840385018152606084018552805190820120918516608084015260a0808401929092528351808403909201825260c090920190925281519101205b9392505050565b6040805160a0810182526000918101828152606082018390526080820192909252908190815260200161351560405180608001604052806000815260200160008152602001600015158152602001600081525090565b905290565b613554828251805173ffffffffffffffffffffffffffffffffffffffff908116835260208083015182169084015260409182015116910152565b602081015161358960608401828051825260208101516020830152604081015115156040830152606081015160608301525050565b505050565b600081518084526020808501945080840160005b838110156135c8576135b587835161351a565b60e09690960195908201906001016135a2565b509495945050505050565b602081526000611158602083018461358e565b73ffffffffffffffffffffffffffffffffffffffff8116811461360857600080fd5b50565b6000806000806060858703121561362157600080fd5b843567ffffffffffffffff8082111561363957600080fd5b818701915087601f83011261364d57600080fd5b81358181111561365c57600080fd5b88602060e08302850101111561367157600080fd5b60209283019650945050850135613687816135e6565b9396929550929360400135925050565b6000815180845260005b818110156136bd576020818501810151868301820152016136a1565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b604080825283519082018190526000906020906060840190828701845b8281101561374a57815173ffffffffffffffffffffffffffffffffffffffff1684529284019290840190600101613718565b50505083810382850152845180825282820190600581901b8301840187850160005b838110156137b8577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08684030185526137a6838351613697565b9487019492509086019060010161376c565b50909998505050505050505050565b6020808252825182820181905260009190848201906040850190845b8181101561383857613825838551805173ffffffffffffffffffffffffffffffffffffffff908116835260208083015182169084015260409182015116910152565b92840192606092909201916001016137e3565b50909695505050505050565b60008060006060848603121561385957600080fd5b8335613864816135e6565b92506020840135613874816135e6565b929592945050506040919091013590565b606081526000613898606083018661358e565b60208301949094525060400152919050565b600081518084526020808501945080840160005b838110156135c8576138f48783518051825260208101516020830152604081015115156040830152606081015160608301525050565b60809690960195908201906001016138be565b60408152600061391a60408301856138aa565b8281036020840152610c2e81856138aa565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff8111828210171561397e5761397e61392c565b60405290565b6040516080810167ffffffffffffffff8111828210171561397e5761397e61392c565b604051610140810167ffffffffffffffff8111828210171561397e5761397e61392c565b6040516101a0810167ffffffffffffffff8111828210171561397e5761397e61392c565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715613a3657613a3661392c565b604052919050565b600067ffffffffffffffff821115613a5857613a5861392c565b5060051b60200190565b60006020808385031215613a7557600080fd5b823567ffffffffffffffff811115613a8c57600080fd5b8301601f81018513613a9d57600080fd5b8035613ab0613aab82613a3e565b6139ef565b81815260059190911b82018301908381019087831115613acf57600080fd5b928401925b828410156126ed578335613ae7816135e6565b82529284019290840190613ad4565b60008083601f840112613b0857600080fd5b50813567ffffffffffffffff811115613b2057600080fd5b6020830191508360208260051b8501011115613b3b57600080fd5b9250929050565b60008060008060408587031215613b5857600080fd5b843567ffffffffffffffff80821115613b7057600080fd5b613b7c88838901613af6565b90965094506020870135915080821115613b9557600080fd5b50613ba287828801613af6565b95989497509550505050565b600060608284031215613bc057600080fd5b6040516060810181811067ffffffffffffffff82111715613be357613be361392c565b6040529050808235613bf4816135e6565b81526020830135613c04816135e6565b60208201526040830135613c17816135e6565b6040919091015292915050565b801515811461360857600080fd5b6000806040808486031215613c4657600080fd5b833567ffffffffffffffff811115613c5d57600080fd5b8401601f81018613613c6e57600080fd5b80356020613c7e613aab83613a3e565b82815260e0928302840182019282820191908a851115613c9d57600080fd5b948301945b84861015613d4c57858b0381811215613cbb5760008081fd5b613cc361395b565b613ccd8d89613bae565b815260606080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa085011215613d035760008081fd5b613d0b613984565b8a8301358152908a013588820152925060a0890135613d2981613c24565b838b015260c0890135908301528086019190915283529485019491830191613ca2565b509997909101359750505050505050565b60008060408385031215613d7057600080fd5b8235613d7b816135e6565b91506020830135613d8b816135e6565b809150509250929050565b6000806000838503610120811215613dad57600080fd5b60e0811215613dbb57600080fd5b5083925060e0840135613dcd816135e6565b92959294505050610100919091013590565b73ffffffffffffffffffffffffffffffffffffffff83168152604060208201526000613e0e6040830184613697565b949350505050565b600060208284031215613e2857600080fd5b81356134b8816135e6565b825181526020808401518183015260408085015115158184015260608086015181850152845160808501529184015160a0840152830151151560c083015282015160e082015261010081016134b8565b60e0810161115b828461351a565b60006020808385031215613ea457600080fd5b823567ffffffffffffffff811115613ebb57600080fd5b8301601f81018513613ecc57600080fd5b8035613eda613aab82613a3e565b81815260609182028301840191848201919088841115613ef957600080fd5b938501935b83851015613f1f57613f108986613bae565b83529384019391850191613efe565b50979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203613fba57613fba613f5a565b5060010190565b808202811582820484141761115b5761115b613f5a565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008261403d577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b8181038181111561115b5761115b613f5a565b60006020828403121561406757600080fd5b81356134b881613c24565b805161407d816135e6565b919050565b805161407d81613c24565b600061014082840312156140a057600080fd5b6140a86139a7565b6140b183614072565b81526140bf60208401614072565b60208201526140d060408401614072565b60408201526140e160608401614072565b60608201526140f260808401614072565b608082015260a083015160a082015260c083015160c082015260e083015160e082015261010080840151818301525061012061412f818501614082565b908201529392505050565b6000602080838503121561414d57600080fd5b825167ffffffffffffffff81111561416457600080fd5b8301601f8101851361417557600080fd5b8051614183613aab82613a3e565b81815260059190911b820183019083810190878311156141a257600080fd5b928401925b828410156126ed5783516141ba816135e6565b825292840192908401906141a7565b805160ff8116811461407d57600080fd5b60006101a082840312156141ed57600080fd5b6141f56139cb565b6141fe83614072565b815261420c60208401614072565b602082015261421d60408401614072565b604082015261422e60608401614072565b606082015261423f60808401614072565b608082015261425060a08401614072565b60a082015261426160c084016141c9565b60c082015261427260e084016141c9565b60e08201526101008381015190820152610120808401519082015261014080840151908201526101608084015190820152610180928301519281019290925250919050565b8082018082111561115b5761115b613f5a565b6000602082840312156142dc57600080fd5b5051919050565b6000816142f2576142f2613f5a565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019056fea2646970667358221220f4c8866585c61d242056e63f95908e646258f9a80f88a95b5db1c04ce655e06f64736f6c63430008150033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101a35760003560e01c80637bfb86ff116100ee5780638953b9d611610097578063c5f8b2e511610071578063c5f8b2e5146103da578063e082bca2146103ed578063e979e87414610400578063ed6bf8bc1461040857600080fd5b80638953b9d6146103865780639f5de875146103a7578063aa822df6146103c757600080fd5b8063838fef5c116100c8578063838fef5c1461033f578063861d3ac4146103525780638651d5ec1461037357600080fd5b80637bfb86ff146102f25780637f3e2b48146103055780638011ba331461032c57600080fd5b80634c6fdc1a1161015057806365eb6bd41161012a57806365eb6bd4146102b95780636c855962146102cc5780637119484a146102df57600080fd5b80634c6fdc1a146102805780635a980a9f146102935780635e47ec03146102a657600080fd5b80633c199241116101815780633c19924114610233578063404fcab2146102485780634296bdff1461026a57600080fd5b806321d3b7f4146101a8578063232306ea146101c65780632861c7d1146101e7575b600080fd5b6101b061041b565b6040516101bd91906135d3565b60405180910390f35b6101d96101d436600461360b565b61042d565b6040516101bd9291906136fb565b61020e7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101bd565b61023b610573565b6040516101bd91906137c7565b61025b610256366004613844565b6106eb565b6040516101bd93929190613885565b610272610713565b6040516101bd929190613907565b61027261028e366004613a62565b610729565b61023b6102a1366004613b42565b6108a1565b61025b6102b4366004613c32565b610bc8565b61025b6102c7366004613844565b610c05565b6101b06102da366004613b42565b610c1d565b6101b06102ed366004613a62565b610c37565b6101b0610300366004613a62565b610f18565b61020e7f000000000000000000000000000000000000000000000000000000000000000081565b6101b061033a366004613d5d565b611149565b6101b061034d366004613d5d565b611161565b610365610360366004613d96565b611170565b6040516101bd929190613ddf565b61025b610381366004613c32565b6113a9565b610399610394366004613e16565b6113d9565b6040516101bd929190613e33565b6103ba6103b5366004613e16565b61157a565b6040516101bd9190613e83565b61023b6103d5366004613d5d565b61163b565b6101b06103e8366004613b42565b6118c1565b6101b06103fb366004613e91565b6118d2565b6101b0611bd5565b6101b0610416366004613e91565b611be2565b6060610428610300611d6b565b905090565b6060808467ffffffffffffffff8111156104495761044961392c565b604051908082528060200260200182016040528015610472578160200160208202803683370190505b5091508467ffffffffffffffff81111561048e5761048e61392c565b6040519080825280602002602001820160405280156104c157816020015b60608152602001906001900390816104ac5790505b50905060005b85811015610569576104f18787838181106104e4576104e4613f2b565b905060e002018686611170565b84838151811061050357610503613f2b565b6020026020010184848151811061051c5761051c613f2b565b602002602001018290528273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681525050508061056290613f89565b90506104c7565b5094509492505050565b6060600061057f611d6b565b9050805167ffffffffffffffff81111561059b5761059b61392c565b60405190808252806020026020018201604052801561060457816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9092019101816105b95790505b50915060008060005b83518110156106e45761063884828151811061062b5761062b613f2b565b6020026020010151611e29565b8093508194505050604051806060016040528085838151811061065d5761065d613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018473ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff168152508582815181106106c8576106c8613f2b565b6020026020010181905250806106dd90613f89565b905061060d565b5050505090565b60606000806107036106fd8787611161565b85610bc8565b9250925092505b93509350939050565b60608061072161028e611d6b565b915091509091565b606080825167ffffffffffffffff8111156107465761074661392c565b6040519080825280602002602001820160405280156107a457816020015b61079160405180608001604052806000815260200160008152602001600015158152602001600081525090565b8152602001906001900390816107645790505b509150825167ffffffffffffffff8111156107c1576107c161392c565b60405190808252806020026020018201604052801561081f57816020015b61080c60405180608001604052806000815260200160008152602001600015158152602001600081525090565b8152602001906001900390816107df5790505b50905060005b835181101561089b5761085084828151811061084357610843613f2b565b60200260200101516113d9565b84838151811061086257610862613f2b565b6020026020010184848151811061087b5761087b613f2b565b6020026020010182905282905250508061089490613f89565b9050610825565b50915091565b606060006108af8386613fc1565b67ffffffffffffffff8111156108c7576108c761392c565b60405190808252806020026020018201604052801561093057816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9092019101816108e55790505b509050600061093d611d6b565b90506000806000805b8451811015610aea5761096485828151811061062b5761062b613f2b565b909350915060005b8a811015610ae15760005b89811015610ad8578c8c8381811061099157610991613f2b565b90506020020160208101906109a69190613e16565b73ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16148015610a3157508a8a828181106109ed576109ed613f2b565b9050602002016020810190610a029190613e16565b73ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16145b15610ad0576040518060600160405280888581518110610a5357610a53613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff16815250888781518110610abe57610abe613f2b565b60200260200101819052508560010195505b600101610977565b5060010161096c565b50600101610946565b508267ffffffffffffffff811115610b0457610b0461392c565b604051908082528060200260200182016040528015610b6d57816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff909201910181610b225790505b50955060005b83811015610bba57858181518110610b8d57610b8d613f2b565b6020026020010151878281518110610ba757610ba7613f2b565b6020908102919091010152600101610b73565b505050505050949350505050565b6060600080610bf885857fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff611eb4565b9250925092509250925092565b6060600080610703610c178787611161565b856113a9565b6060610c2e6103fb868686866108a1565b95945050505050565b6060600080835160020267ffffffffffffffff811115610c5957610c5961392c565b604051908082528060200260200182016040528015610c9257816020015b610c7f6134bf565b815260200190600190039081610c775790505b509050610cc260405180608001604052806000815260200160008152602001600015158152602001600081525090565b610cef60405180608001604052806000815260200160008152602001600015158152602001600081525090565b6000806000805b8951811015610f0057610d148a828151811061084357610843613f2b565b8051919750955015610ef857610d358a828151811061062b5761062b613f2b565b8094508195505050610d608a8281518110610d5257610d52613f2b565b6020026020010151846124e5565b91508115610ef8578551855160019099019803610d805760008552610d8e565b855115610d8e578760010197505b610e21604051806040016040528060405180606001604052808e8681518110610db957610db9613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018873ffffffffffffffffffffffffffffffffffffffff1681526020018773ffffffffffffffffffffffffffffffffffffffff16815250815260200188815250836126f8565b878260020281518110610e3657610e36613f2b565b6020026020010181905250610ed4604051806040016040528060405180606001604052808e8681518110610e6c57610e6c613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018873ffffffffffffffffffffffffffffffffffffffff1681526020018773ffffffffffffffffffffffffffffffffffffffff16815250815260200187815250836126f8565b878260020260010181518110610eec57610eec613f2b565b60200260200101819052505b600101610cf6565b50610f0b8688612761565b9998505050505050505050565b6060600080835167ffffffffffffffff811115610f3757610f3761392c565b604051908082528060200260200182016040528015610f7057816020015b610f5d6134bf565b815260200190600190039081610f555790505b509050610fa060405180608001604052806000815260200160008152602001600015158152602001600081525090565b610fcd60405180608001604052806000815260200160008152602001600015158152602001600081525090565b610fd56134bf565b6000805b885181101561113257610ff789828151811061084357610843613f2b565b8095508196505050604051806040016040528060405180606001604052808c858151811061102757611027613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152508152602001611091878761283d565b90526020810151519093501561112a576110b689828151811061062b5761062b613f2b565b845173ffffffffffffffffffffffffffffffffffffffff91821660408083019190915292909116602090910152835180519101516110f491906124e5565b9150811561112a5786600101965061110c83836126f8565b86828151811061111e5761111e613f2b565b60200260200101819052505b600101610fd9565b5061113d8587612761565b98975050505050505050565b6060611158610416848461163b565b90505b92915050565b60606111586103fb848461163b565b60006060816111826020870187613e16565b73ffffffffffffffffffffffffffffffffffffffff1614806111b8575073ffffffffffffffffffffffffffffffffffffffff8416155b156111ef576040517ff267e74000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b620f42408310158061120357506060850135155b8061121057506080850135155b15611247576040517fb55de08000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600060608601356112646080880135670de0b6b3a7640000613fc1565b61126e9190614007565b9050620f424061127e8582614042565b6112889083613fc1565b6112929190614007565b90506112a16020870187613e16565b507f8433ea2200000000000000000000000000000000000000000000000000000000606087013582876112da60c08b0160a08c01614055565b6040516024810194909452604484019290925273ffffffffffffffffffffffffffffffffffffffff1660648301521515608482015260a401604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052602080820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090941693909317909252925061139e90870187613e16565b925050935093915050565b6060600080610bf8857fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff86611eb4565b61140660405180608001604052806000815260200160008152602001600015158152602001600081525090565b61143360405180608001604052806000815260200160008152602001600015158152602001600081525090565b6040517f1fcd364900000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8481166004830152600060248301819052917f000000000000000000000000000000000000000000000000000000000000000090911690631fcd364990604401610140604051808303816000875af11580156114ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114f2919061408d565b905060405180608001604052808260a0015181526020018260c00151815260200160001515815260200161152e8360a001518460c001516128b7565b815250925060405180608001604052808260e001518152602001826101000151815260200160011515815260200161156f8360e001518461010001516128b7565b815250915050915091565b6115826134bf565b73ffffffffffffffffffffffffffffffffffffffff82166115a257919050565b6000806115ae84611e29565b915091506000806115be866113d9565b6040805160a08101825273ffffffffffffffffffffffffffffffffffffffff808b169282019283528881166060830152871660808201529081529193509150611631906020810161160f858561283d565b905260208301511561162a5761162588866124e5565b6126f8565b60006126f8565b9695505050505050565b60606000611647611d6b565b9050600080825167ffffffffffffffff8111156116665761166661392c565b60405190808252806020026020018201604052801561168f578160200160208202803683370190505b50905060008060005b8551811015611780576116b686828151811061062b5761062b613f2b565b909350915073ffffffffffffffffffffffffffffffffffffffff808416908a1614801561170e57508773ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b156117705785818151811061172557611725613f2b565b602002602001015184868151811061173f5761173f613f2b565b73ffffffffffffffffffffffffffffffffffffffff9092166020928302919091019091015261176d85613f89565b94505b61177981613f89565b9050611698565b508367ffffffffffffffff81111561179a5761179a61392c565b60405190808252806020026020018201604052801561180357816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9092019101816117b85790505b50955060005b848110156118b557604051806060016040528085838151811061182e5761182e613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018a73ffffffffffffffffffffffffffffffffffffffff1681526020018973ffffffffffffffffffffffffffffffffffffffff1681525087828151811061189957611899613f2b565b6020026020010181905250806118ae90613f89565b9050611809565b50505050505092915050565b6060610c2e610416868686866108a1565b60606000825160020267ffffffffffffffff8111156118f3576118f361392c565b60405190808252806020026020018201604052801561192c57816020015b6119196134bf565b8152602001906001900390816119115790505b509050600061195e60405180608001604052806000815260200160008152602001600015158152602001600081525090565b61198b60405180608001604052806000815260200160008152602001600015158152602001600081525090565b6000805b8751811015611af6576119be8882815181106119ad576119ad613f2b565b6020026020010151600001516113d9565b8051919550935015611aee57611a0e8882815181106119df576119df613f2b565b6020026020010151600001518983815181106119fd576119fd613f2b565b6020026020010151604001516124e5565b91508115611aee578351835160019096019503611a2e5760008352611a3c565b835115611a3c578460010194505b611a7360405180604001604052808a8481518110611a5c57611a5c613f2b565b6020026020010151815260200186815250836126f8565b868260020281518110611a8857611a88613f2b565b6020026020010181905250611aca60405180604001604052808a8481518110611ab357611ab3613f2b565b6020026020010151815260200185815250836126f8565b868260020260010181518110611ae257611ae2613f2b565b60200260200101819052505b60010161198f565b508367ffffffffffffffff811115611b1057611b1061392c565b604051908082528060200260200182016040528015611b4957816020015b611b366134bf565b815260200190600190039081611b2e5790505b5095506000805b8651811015611bc9576000878281518110611b6d57611b6d613f2b565b602002602001015160200151600001511115611bc157868181518110611b9557611b95613f2b565b6020026020010151888381518110611baf57611baf613f2b565b60200260200101819052508160010191505b600101611b50565b50505050505050919050565b60606104286102ed611d6b565b60606000825167ffffffffffffffff811115611c0057611c0061392c565b604051908082528060200260200182016040528015611c3957816020015b611c266134bf565b815260200190600190039081611c1e5790505b5090506000611c466134bf565b611c7360405180608001604052806000815260200160008152602001600015158152602001600081525090565b611ca060405180608001604052806000815260200160008152602001600015158152602001600081525090565b6000805b8851811015611d6057611cc28982815181106119ad576119ad613f2b565b809450819550505060405180604001604052808a8381518110611ce757611ce7613f2b565b60200260200101518152602001611cfe868661283d565b905260208101515190955015611d585784518051604090910151611d2291906124e5565b91508115611d5857856001019550611d3a85836126f8565b878281518110611d4c57611d4c613f2b565b60200260200101819052505b600101611ca4565b5061113d8686612761565b60606104287f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a8d9f4936040518163ffffffff1660e01b8152600401600060405180830381865afa158015611ddb573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052611e21919081019061413a565b6127106128ea565b60008060008373ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b81526004016101a060405180830381865afa158015611e7a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e9e91906141da565b90508060a0015181608001519250925050915091565b6060600080611ec286612b1f565b9550611ecf868686612c70565b9194509250905084821180611ee357508381115b1561070a57600060018451611ef89190614042565b9050600086841115611f4d57611f0e8785614042565b858381518110611f2057611f20613f2b565b602002602001015160200151600001516001611f3c91906142b7565b611f469190614042565b90506121dc565b6000611f598785614042565b868481518110611f6b57611f6b613f2b565b60200260200101516020015160200151611f859190614042565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631fcd3649888681518110611fd757611fd7613f2b565b602090810291909101015151516040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff909116600482015260006024820152604401610140604051808303816000875af1158015612057573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207b919061408d565b905060006120918260a001518360c001516128b7565b905060006120c68360a001518460e001516120ac9190614042565b8460c001518561010001516120c19190614042565b6128b7565b9050818111806120d95750838360c00151105b156121a85760008360c001518461010001516120f59190614042565b90508481106121315781612115866b033b2e3c9fd0803ce8000000613fc1565b61211f9190614007565b61212a9060016142b7565b95506121a2565b81612148826b033b2e3c9fd0803ce8000000613fc1565b6121529190614007565b61215d9060016142b7565b95508261216a8287614042565b612180906b033b2e3c9fd0803ce8000000613fc1565b61218a9190614007565b6121959060016142b7565b61219f90876142b7565b95505b506121d7565b816121bf856b033b2e3c9fd0803ce8000000613fc1565b6121c99190614007565b6121d49060016142b7565b94505b505050505b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631fcd364987858151811061222c5761222c613f2b565b602090810291909101015151516040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff909116600482015260248101859052604401610140604051808303816000875af11580156122ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122d0919061408d565b90508583815181106122e4576122e4613f2b565b60200260200101516020015160000151856122ff9190614042565b945085838151811061231357612313613f2b565b602002602001015160200151602001518461232e9190614042565b935085838151811061234257612342613f2b565b60200260200101516020015160400151156123ec578060e0015186848151811061236e5761236e613f2b565b602002602001015160200151600001818152505080610100015186848151811061239a5761239a613f2b565b60200260200101516020015160200181815250506123c18160e001518261010001516128b7565b8684815181106123d3576123d3613f2b565b602002602001015160200151606001818152505061247b565b8060a0015186848151811061240357612403613f2b565b60200260200101516020015160000181815250508060c0015186848151811061242e5761242e613f2b565b60200260200101516020015160200181815250506124548160a001518260c001516128b7565b86848151811061246657612466613f2b565b60200260200101516020015160600181815250505b85838151811061248d5761248d613f2b565b60200260200101516020015160000151856124a891906142b7565b94508583815181106124bc576124bc613f2b565b60200260200101516020015160200151846124d791906142b7565b935050505093509350939050565b6000806124f28484613023565b90508060000361250657600091505061115b565b600981901c66ffffffffffffff16600182901c60ff161b600061252983836130cc565b9050826001166001036125a157600061254186613160565b90508060000361255857600094505050505061115b565b60006125638261323d565b50905064e8d4a510006125768286613fc1565b6125809190614007565b935064e8d4a510006125928285613fc1565b61259c9190614007565b925050505b8082116125af5760006125b9565b6125b98183614042565b9350600073ffffffffffffffffffffffffffffffffffffffff861673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee146126a3576040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000811660048301528716906370a0823190602401602060405180830381865afa15801561267a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061269e91906142ca565b6126dc565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16315b90508481116126eb57806126ed565b845b979650505050505050565b6127006134bf565b82602001516020015160000361271757508161115b565b82602001516020015182101561275a5760208084015190810151905161273e908490613fc1565b6127489190614007565b60208085018051929092529051018290525b5090919050565b60608167ffffffffffffffff81111561277c5761277c61392c565b6040519080825280602002602001820160405280156127b557816020015b6127a26134bf565b81526020019060019003908161279a5790505b5090506000805b84518110156128355760008582815181106127d9576127d9613f2b565b60200260200101516020015160000151111561282d5784818151811061280157612801613f2b565b602002602001015183838151811061281b5761281b613f2b565b60200260200101819052508160010191505b6001016127bc565b505092915050565b61286a60405180608001604052806000815260200160008152602001600015158152602001600081525090565b815160000361287a57508061115b565b82606001518260600151111561289157508061115b565b826060015182606001510361275a5782518251036128b057508161115b565b508061115b565b6000816000036128c95750600061115b565b826128e0836b033b2e3c9fd0803ce8000000613fc1565b6111589190614007565b8151606090600090815b8551811015612a005785818151811061290f5761290f613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1663bb24fe8a6040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561299b575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612998918101906142ca565b60015b6129a95761271092506129ac565b92505b8483146129f85760008682815181106129c7576129c7613f2b565b73ffffffffffffffffffffffffffffffffffffffff909216602092830291909101909101526129f5826142e3565b91505b6001016128f4565b508067ffffffffffffffff811115612a1a57612a1a61392c565b604051908082528060200260200182016040528015612a43578160200160208202803683370190505b5092506000805b8651811015612b1557600073ffffffffffffffffffffffffffffffffffffffff16878281518110612a7d57612a7d613f2b565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1614612b0d57868181518110612ab257612ab2613f2b565b6020026020010151858381518110612acc57612acc613f2b565b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508160010191505b600101612a4a565b5050505092915050565b60606000612b2b6134bf565b60015b8451811015612c67576000925060005b818651612b4b9190614042565b811015612c4657858181518110612b6457612b64613f2b565b6020026020010151602001516060015186826001612b8291906142b7565b81518110612b9257612b92613f2b565b602002602001015160200151606001511115612c3457858181518110612bba57612bba613f2b565b6020026020010151925085816001612bd291906142b7565b81518110612be257612be2613f2b565b6020026020010151868281518110612bfc57612bfc613f2b565b60209081029190910101528286612c148360016142b7565b81518110612c2457612c24613f2b565b6020026020010181905250600193505b80612c3e81613f89565b915050612b3e565b5082612c555750929392505050565b80612c5f81613f89565b915050612b2e565b50929392505050565b60606000808551600003612c8c5750849150600090508061070a565b60005b8583108015612c9d57508482105b8015612ca95750865181105b15612d1c57868181518110612cc057612cc0613f2b565b6020026020010151602001516000015183612cdb91906142b7565b9250868181518110612cef57612cef613f2b565b6020026020010151602001516020015182612d0a91906142b7565b9150612d1581613f89565b9050612c8f565b6000805b612d2b600184614042565b811015612e61576000612d3f8260016142b7565b90505b83811015612e5057898181518110612d5c57612d5c613f2b565b6020026020010151600001516000015173ffffffffffffffffffffffffffffffffffffffff168a8381518110612d9457612d94613f2b565b6020026020010151600001516000015173ffffffffffffffffffffffffffffffffffffffff1603612e4057898281518110612dd157612dd1613f2b565b6020026020010151602001516040015115612e0e5760008a8281518110612dfa57612dfa613f2b565b602090810291909101810151015152612e32565b60008a8381518110612e2257612e22613f2b565b6020908102919091018101510151525b82612e3c81613f89565b9350505b612e4981613f89565b9050612d42565b50612e5a81613f89565b9050612d20565b508015612f6f576000818951612e779190614042565b67ffffffffffffffff811115612e8f57612e8f61392c565b604051908082528060200260200182016040528015612ec857816020015b612eb56134bf565b815260200190600190039081612ead5790505b50955060005b8951811015612f555760008a8281518110612eeb57612eeb613f2b565b602002602001015160200151600001511115612f4557898181518110612f1357612f13613f2b565b6020026020010151878381518110612f2d57612f2d613f2b565b602002602001018190525081612f4290613f89565b91505b612f4e81613f89565b9050612ece565b50612f61868989612c70565b95509550955050505061070a565b8167ffffffffffffffff811115612f8857612f8861392c565b604051908082528060200260200182016040528015612fc157816020015b612fae6134bf565b815260200190600190039081612fa65790505b50945060005b8281101561301757888181518110612fe157612fe1613f2b565b6020026020010151868281518110612ffb57612ffb613f2b565b60200260200101819052508061301090613f89565b9050612fc7565b50505093509350939050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b5c736e461306d6008868661344f565b6040518263ffffffff1660e01b815260040161308b91815260200190565b602060405180830381865afa1580156130a8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061115891906142ca565b600066ffffffffffffff604984901c1660ff604185901c161b8082036130f657600091505061115b565b612710613fff60a286901c168402046401ffffffff608186901c16420362ffffff60b087901c166131278284613fc1565b6131319190614007565b9050808311613141576000613145565b8083035b93505080840383811115613157578093505b50505092915050565b6040805173ffffffffffffffffffffffffffffffffffffffff838116602080840191909152600583850152835180840385018152606084019485905280519101207fb5c736e40000000000000000000000000000000000000000000000000000000090935260648201929092526000917f0000000000000000000000000000000000000000000000000000000000000000169063b5c736e490608401602060405180830381865afa158015613219573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061115b91906142ca565b67ffffffffffffffff605b82901c811690609b83901c1681158061325f575080155b1561329f576040517fd50d751200000000000000000000000000000000000000000000000000000000815262011171600482015260240160405180910390fd5b61ffff8316603a84901c6401ffffffff16428181039160ea87901c617fff169114806132c9575082155b806132d45750806001145b156132e157505050915091565b64496cebb80084840283020484019350617fff60db87901c1692508260010361330c57505050915091565b826001166001036133615760019290921c91826c7e37be2022c0914b26800000008161333a5761333a613fd8565b049250612710601e87901c613fff166b033b2e3c9fd0803ce800000085010204925061338e565b60019290921c916305f5e100601e87901c613fff166127108501026b033b2e3c9fd0803ce8000000020492505b806001166001036133c55760011c61271081016b033b2e3c9fd0803ce80000008202816133bd576133bd613fd8565b0490506133fb565b60011c61271081016b033b2e3c9fd0803ce80000008202816133e9576133e9613fd8565b046b033b2e3c9fd0803ce80000000390505b760a70c3c40a64e6c51999090b65f67d92400000000000008382026127100261ffff881691900402601087901c613fff16612710030292506801b5a660ea44b8000085840283020485019450505050915091565b6040805173ffffffffffffffffffffffffffffffffffffffff848116602080840191909152828401879052835180840385018152606084018552805190820120918516608084015260a0808401929092528351808403909201825260c090920190925281519101205b9392505050565b6040805160a0810182526000918101828152606082018390526080820192909252908190815260200161351560405180608001604052806000815260200160008152602001600015158152602001600081525090565b905290565b613554828251805173ffffffffffffffffffffffffffffffffffffffff908116835260208083015182169084015260409182015116910152565b602081015161358960608401828051825260208101516020830152604081015115156040830152606081015160608301525050565b505050565b600081518084526020808501945080840160005b838110156135c8576135b587835161351a565b60e09690960195908201906001016135a2565b509495945050505050565b602081526000611158602083018461358e565b73ffffffffffffffffffffffffffffffffffffffff8116811461360857600080fd5b50565b6000806000806060858703121561362157600080fd5b843567ffffffffffffffff8082111561363957600080fd5b818701915087601f83011261364d57600080fd5b81358181111561365c57600080fd5b88602060e08302850101111561367157600080fd5b60209283019650945050850135613687816135e6565b9396929550929360400135925050565b6000815180845260005b818110156136bd576020818501810151868301820152016136a1565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b604080825283519082018190526000906020906060840190828701845b8281101561374a57815173ffffffffffffffffffffffffffffffffffffffff1684529284019290840190600101613718565b50505083810382850152845180825282820190600581901b8301840187850160005b838110156137b8577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08684030185526137a6838351613697565b9487019492509086019060010161376c565b50909998505050505050505050565b6020808252825182820181905260009190848201906040850190845b8181101561383857613825838551805173ffffffffffffffffffffffffffffffffffffffff908116835260208083015182169084015260409182015116910152565b92840192606092909201916001016137e3565b50909695505050505050565b60008060006060848603121561385957600080fd5b8335613864816135e6565b92506020840135613874816135e6565b929592945050506040919091013590565b606081526000613898606083018661358e565b60208301949094525060400152919050565b600081518084526020808501945080840160005b838110156135c8576138f48783518051825260208101516020830152604081015115156040830152606081015160608301525050565b60809690960195908201906001016138be565b60408152600061391a60408301856138aa565b8281036020840152610c2e81856138aa565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff8111828210171561397e5761397e61392c565b60405290565b6040516080810167ffffffffffffffff8111828210171561397e5761397e61392c565b604051610140810167ffffffffffffffff8111828210171561397e5761397e61392c565b6040516101a0810167ffffffffffffffff8111828210171561397e5761397e61392c565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715613a3657613a3661392c565b604052919050565b600067ffffffffffffffff821115613a5857613a5861392c565b5060051b60200190565b60006020808385031215613a7557600080fd5b823567ffffffffffffffff811115613a8c57600080fd5b8301601f81018513613a9d57600080fd5b8035613ab0613aab82613a3e565b6139ef565b81815260059190911b82018301908381019087831115613acf57600080fd5b928401925b828410156126ed578335613ae7816135e6565b82529284019290840190613ad4565b60008083601f840112613b0857600080fd5b50813567ffffffffffffffff811115613b2057600080fd5b6020830191508360208260051b8501011115613b3b57600080fd5b9250929050565b60008060008060408587031215613b5857600080fd5b843567ffffffffffffffff80821115613b7057600080fd5b613b7c88838901613af6565b90965094506020870135915080821115613b9557600080fd5b50613ba287828801613af6565b95989497509550505050565b600060608284031215613bc057600080fd5b6040516060810181811067ffffffffffffffff82111715613be357613be361392c565b6040529050808235613bf4816135e6565b81526020830135613c04816135e6565b60208201526040830135613c17816135e6565b6040919091015292915050565b801515811461360857600080fd5b6000806040808486031215613c4657600080fd5b833567ffffffffffffffff811115613c5d57600080fd5b8401601f81018613613c6e57600080fd5b80356020613c7e613aab83613a3e565b82815260e0928302840182019282820191908a851115613c9d57600080fd5b948301945b84861015613d4c57858b0381811215613cbb5760008081fd5b613cc361395b565b613ccd8d89613bae565b815260606080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa085011215613d035760008081fd5b613d0b613984565b8a8301358152908a013588820152925060a0890135613d2981613c24565b838b015260c0890135908301528086019190915283529485019491830191613ca2565b509997909101359750505050505050565b60008060408385031215613d7057600080fd5b8235613d7b816135e6565b91506020830135613d8b816135e6565b809150509250929050565b6000806000838503610120811215613dad57600080fd5b60e0811215613dbb57600080fd5b5083925060e0840135613dcd816135e6565b92959294505050610100919091013590565b73ffffffffffffffffffffffffffffffffffffffff83168152604060208201526000613e0e6040830184613697565b949350505050565b600060208284031215613e2857600080fd5b81356134b8816135e6565b825181526020808401518183015260408085015115158184015260608086015181850152845160808501529184015160a0840152830151151560c083015282015160e082015261010081016134b8565b60e0810161115b828461351a565b60006020808385031215613ea457600080fd5b823567ffffffffffffffff811115613ebb57600080fd5b8301601f81018513613ecc57600080fd5b8035613eda613aab82613a3e565b81815260609182028301840191848201919088841115613ef957600080fd5b938501935b83851015613f1f57613f108986613bae565b83529384019391850191613efe565b50979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203613fba57613fba613f5a565b5060010190565b808202811582820484141761115b5761115b613f5a565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008261403d577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b8181038181111561115b5761115b613f5a565b60006020828403121561406757600080fd5b81356134b881613c24565b805161407d816135e6565b919050565b805161407d81613c24565b600061014082840312156140a057600080fd5b6140a86139a7565b6140b183614072565b81526140bf60208401614072565b60208201526140d060408401614072565b60408201526140e160608401614072565b60608201526140f260808401614072565b608082015260a083015160a082015260c083015160c082015260e083015160e082015261010080840151818301525061012061412f818501614082565b908201529392505050565b6000602080838503121561414d57600080fd5b825167ffffffffffffffff81111561416457600080fd5b8301601f8101851361417557600080fd5b8051614183613aab82613a3e565b81815260059190911b820183019083810190878311156141a257600080fd5b928401925b828410156126ed5783516141ba816135e6565b825292840192908401906141a7565b805160ff8116811461407d57600080fd5b60006101a082840312156141ed57600080fd5b6141f56139cb565b6141fe83614072565b815261420c60208401614072565b602082015261421d60408401614072565b604082015261422e60608401614072565b606082015261423f60808401614072565b608082015261425060a08401614072565b60a082015261426160c084016141c9565b60c082015261427260e084016141c9565b60e08201526101008381015190820152610120808401519082015261014080840151908201526101608084015190820152610180928301519281019290925250919050565b8082018082111561115b5761115b613f5a565b6000602082840312156142dc57600080fd5b5051919050565b6000816142f2576142f2613f5a565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019056fea2646970667358221220f4c8866585c61d242056e63f95908e646258f9a80f88a95b5db1c04ce655e06f64736f6c63430008150033",
  "devdoc": {
    "details": "Note that on the same protocol, if \"withAbsorb = true\" is executed, this also consumes the swap         that would be on the same protocol with \"withAbsorb = false\". So the total available swap amount         at a protocol if both a swap with and without absorb is available is not `with inAmt + without inAmt`         but rather `with inAmt`.         Sometimes with absorb can provide better swaps, sometimes without absorb can provide better swaps.         But available liquidity for \"withAbsorb\" amounts will always be >= without absorb amounts.The \"Raw\" methods return both the with and without absorb swaps for the same Fluid Vault, the non-\"Raw\"         methods automatically filter by the better ratio swap. For same cases a better optimization of ratios         is possible with custom logic based on the \"Raw\" methods, see details in comments.for native token, send 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE.returned swaps Struct can be fed into `getSwapTx` to prepare the tx that executes the swaps.non-view methods in this contract are expected to be called with callStatic,         although they would anyway not do any actual state changes.",
    "kind": "dev",
    "methods": {
      "approxOutput(address,address,uint256)": {
        "details": "The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better but the target swap amount is more than the available without absorb liquidity. For this currently the available withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity. The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing amount up to the target amount with the worse ratio with absorb liquidity.",
        "params": {
          "outAmt_": "exact output token amount that should be swapped to from input token",
          "tokenIn_": "input token",
          "tokenOut_": "output token"
        },
        "returns": {
          "approxOutAmt_": "approximate output token amount. Can be less than `outAmt_` if all available swaps can not cover                       the target amount.",
          "inAmt_": "input token amount needed to receive `actualOutAmt_`",
          "swaps_": "swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on."
        }
      },
      "exactInput(address,address,uint256)": {
        "details": "The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better but the target swap amount is more than the available without absorb liquidity. For this, currently the available withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity. The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing amount up to the target amount with the worse ratio with absorb liquidity.",
        "params": {
          "inAmt_": "exact input token amount that should be swapped to output token",
          "tokenIn_": "input token",
          "tokenOut_": "output token"
        },
        "returns": {
          "actualInAmt_": "actual input token amount. Can be less than inAmt_ if all available swaps can not cover                      the target amount.",
          "outAmt_": "output token amount received for `actualInAmt_`",
          "swaps_": "swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on."
        }
      },
      "filterToApproxOutAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)": {
        "returns": {
          "actualInAmt_": "actual input amount.",
          "approxOutAmt_": "APPROXIMATE actual output amount. Can be less than targetOutAmt_ if all available swaps                      can not cover the target amount.",
          "filteredSwaps_": "swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on."
        }
      },
      "filterToTargetInAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)": {
        "returns": {
          "actualInAmt_": "actual input amount. Can be less than targetInAmt_ if all available swaps can not cover                      the target amount.",
          "approxOutAmt_": "actual estimated output amount.",
          "filteredSwaps_": "swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on."
        }
      },
      "getSwapTx(((address,address,address),(uint256,uint256,bool,uint256)),address,uint256)": {
        "params": {
          "receiver_": "receiver address that the output token is sent to",
          "slippage_": "maximum allowed slippage for the expected output token amount. Reverts iIf received token out                  amount is lower than this. in 1e4 percentage, e.g. 1% = 10000, 0.3% = 3000, 0.01% = 100, 0.0001% = 1.",
          "swap_": "Swap struct as returned by other methods"
        },
        "returns": {
          "calldata_": "the calldata that can be used to trigger the liquidation call, resulting in the desired swap.",
          "target_": "target address where `calldata_` must be executed"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "FluidVaultLiquidationsResolver__AddressZero()": [
        {
          "notice": "thrown if an input param address is zero"
        }
      ],
      "FluidVaultLiquidationsResolver__InvalidParams()": [
        {
          "notice": "thrown if an invalid param is given to a method"
        }
      ]
    },
    "kind": "user",
    "methods": {
      "LIQUIDITY()": {
        "notice": "address of the liquidity contract"
      },
      "approxOutput(address,address,uint256)": {
        "notice": "finds all swaps from `tokenIn_` to `tokenOut_` for an APPROXIMATE output amount `outAmt_`.         filters the available swaps and sorts them by ratio, so the returned swaps are the best available         swaps to reach the target `outAmt_`.         If the full available amount is less than the target `outAmt_`, the available amount is returned as `actualOutAmt_`.         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to         approximately estimate the required input amounts to reach a certain output amount. This         will change until execution and should be controlled with a maximum slippage.         Recommended to use exact input methods instead."
      },
      "constructor": {
        "notice": "constructor sets the immutable vault resolver address"
      },
      "exactInput(address,address,uint256)": {
        "notice": "finds all swaps from `tokenIn_` to `tokenOut_` for an exact input amount `inAmt_`.         filters the available swaps and sorts them by ratio, so the returned swaps are the best available         swaps to reach the target `inAmt_`.         If the full available amount is less than the target `inAmt_`, the available amount is returned as `actualInAmt_`."
      },
      "filterToApproxOutAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)": {
        "notice": "filters the `swaps_` to the point where APPROXIMATELY `targetOutAmt_` is reached.         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to         approximately estimate the required input amounts to reach a certain output amount. This         will change until execution and should be controlled with a maximum slippage.         Recommended to use exact input methods instead.         This is best used in combination with the \"Raw\" methods, as the `targetInAmt_` allows for more optimized         filtering than otherwise done with the non-\"Raw\" methods."
      },
      "filterToTargetInAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)": {
        "notice": "filters the `swaps_` to the point where `targetInAmt_` is reached.         This is best used in combination with the \"Raw\" methods, as the `targetInAmt_` allows for more optimized         filtering than otherwise done with the non-\"Raw\" methods."
      },
      "getAllSwapPaths()": {
        "notice": "returns all available token swap paths"
      },
      "getAllVaultsSwap()": {
        "notice": "returns all available `swaps_` for all Fluid vaults. Only returns non-zero swaps.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio."
      },
      "getAllVaultsSwapData()": {
        "notice": "returns the swap data for with and without absorb for all Fluid vaults."
      },
      "getAllVaultsSwapRaw()": {
        "notice": "returns all available `swaps_` for all Fluid vaults raw. Only returns non-zero swaps.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault."
      },
      "getAnySwapPaths(address[],address[])": {
        "notice": "returns all available swap paths for any `tokensIn_` to any `tokensOut_`."
      },
      "getAnySwaps(address[],address[])": {
        "notice": "finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.         Token pairs that are not available or where available swap amounts are zero         will not be present in the returned `swaps_` array.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio."
      },
      "getAnySwapsRaw(address[],address[])": {
        "notice": "finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.         Token pairs that are not available or where available swap amounts are zero         will not be present in the returned `swaps_` array.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault."
      },
      "getSwapForProtocol(address)": {
        "notice": "returns the available swap amounts at a certain `protocol_`. Only returns non-zero swaps.         For vault protocol considering both a swap that uses liquidation with absorb and without absorb."
      },
      "getSwapPaths(address,address)": {
        "notice": "returns all swap paths for a certain `tokenIn_` swapped to a `tokenOut_`.         returns empty array if no swap path is available for a given pair."
      },
      "getSwapTx(((address,address,address),(uint256,uint256,bool,uint256)),address,uint256)": {
        "notice": "returns the calldata to execute a swap as returned by the other methods in this contract.         `swap_.data.inAmt` must come from msg.sender, `swap_.data.outAmt` goes to `receiver_`. If the input token         is the native token, msg.value must be sent along when triggering the actual call with the returned calldata         which should be `swap_.data.inAmt`."
      },
      "getSwapTxs(((address,address,address),(uint256,uint256,bool,uint256))[],address,uint256)": {
        "notice": "returns the same data as `getSwapTx` for an array of input `swaps_` at once."
      },
      "getSwaps(address,address)": {
        "notice": "finds all available `swaps_` for `tokenIn_` to `tokenOut_`.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio."
      },
      "getSwapsForPaths((address,address,address)[])": {
        "notice": "returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio."
      },
      "getSwapsForPathsRaw((address,address,address)[])": {
        "notice": "returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault."
      },
      "getSwapsRaw(address,address)": {
        "notice": "finds all available `swaps_` for `tokenIn_` to `tokenOut_`.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault."
      },
      "getVaultSwapData(address)": {
        "notice": "returns the swap data for with and without absorb for a Fluid `vault_`."
      },
      "getVaultsSwap(address[])": {
        "notice": "returns all available `swaps_` for multiple Fluid `vaults_`. Only returns non-zero swaps.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio."
      },
      "getVaultsSwapData(address[])": {
        "notice": "returns the swap data for with and without absorb for multiple Fluid `vaults_`."
      },
      "getVaultsSwapRaw(address[])": {
        "notice": "returns all available `swaps_` for multiple Fluid `vaults_` raw. Only returns non-zero swaps.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault."
      }
    },
    "notice": "Resolver contract that helps in finding available token (liquidation) swaps available in Fluid VaultT1s.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}