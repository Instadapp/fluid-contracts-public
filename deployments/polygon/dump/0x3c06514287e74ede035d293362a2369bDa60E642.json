{
  "address": "0x3c06514287e74ede035d293362a2369bDa60E642",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "errorId_",
          "type": "uint256"
        }
      ],
      "name": "FluidLiquidityCalcsError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "errorId_",
          "type": "uint256"
        }
      ],
      "name": "FluidLiquidityError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "errorId_",
          "type": "uint256"
        }
      ],
      "name": "FluidSafeTransferError",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [],
      "name": "BorrowRateMaxCap",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "supplyAmount",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "borrowAmount",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "withdrawTo",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrowTo",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalAmounts",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "exchangePricesAndConfig",
          "type": "uint256"
        }
      ],
      "name": "LogOperate",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token_",
          "type": "address"
        },
        {
          "internalType": "int256",
          "name": "supplyAmount_",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "borrowAmount_",
          "type": "int256"
        },
        {
          "internalType": "address",
          "name": "withdrawTo_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "borrowTo_",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "callbackData_",
          "type": "bytes"
        }
      ],
      "name": "operate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "memVar3_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "memVar4_",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "transactionHash": "0x5ba9c40e6fa3ef8925b00c4cde38a4b5e05e177da4ac1f9285d95ee3c7ac787b",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x0Ed35B1609Ec45c7079E80d11149a52717e4859A",
    "contractAddress": null,
    "transactionIndex": 70,
    "gasUsed": "2621677",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000020000000400000000000000000000000000000000000000200000000000000000000000000001000000000000000000000000000000004000000000000000040001000000000000000000400000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x5a03f150dbd27e42077be3a5c0d3f67bf22fe6c8f77f30ead3ab28e0d7889825",
    "transactionHash": "0x5ba9c40e6fa3ef8925b00c4cde38a4b5e05e177da4ac1f9285d95ee3c7ac787b",
    "logs": [
      {
        "transactionIndex": 70,
        "blockNumber": 80253771,
        "transactionHash": "0x5ba9c40e6fa3ef8925b00c4cde38a4b5e05e177da4ac1f9285d95ee3c7ac787b",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x0000000000000000000000000ed35b1609ec45c7079e80d11149a52717e4859a",
          "0x0000000000000000000000007ee41d8a25641000661b1ef5e6ae8a00400466b0"
        ],
        "data": "0x000000000000000000000000000000000000000000000000012a0cd7a19f5300000000000000000000000000000000000000000000000008eb8fa473a0fd675e00000000000000000000000000000000000000000002ab32f7e80fbb4da8d7fc000000000000000000000000000000000000000000000008ea65979bff5e145e00000000000000000000000000000000000000000002ab32f9121c92ef482afc",
        "logIndex": 595,
        "blockHash": "0x5a03f150dbd27e42077be3a5c0d3f67bf22fe6c8f77f30ead3ab28e0d7889825"
      }
    ],
    "blockNumber": 80253771,
    "cumulativeGasUsed": "14957850",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "94a392b8e7953f1c4aff210862f8aaf9",
  "metadata": "{\"compiler\":{\"version\":\"0.8.29+commit.ab55807c\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorId_\",\"type\":\"uint256\"}],\"name\":\"FluidLiquidityCalcsError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorId_\",\"type\":\"uint256\"}],\"name\":\"FluidLiquidityError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorId_\",\"type\":\"uint256\"}],\"name\":\"FluidSafeTransferError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"BorrowRateMaxCap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"supplyAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"borrowAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrowTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmounts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exchangePricesAndConfig\",\"type\":\"uint256\"}],\"name\":\"LogOperate\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"supplyAmount_\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"borrowAmount_\",\"type\":\"int256\"},{\"internalType\":\"address\",\"name\":\"withdrawTo_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrowTo_\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callbackData_\",\"type\":\"bytes\"}],\"name\":\"operate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"memVar3_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"memVar4_\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"LogOperate(address,address,int256,int256,address,address,uint256,uint256)\":{\"params\":{\"borrowAmount\":\"borrow amount for the operation. if >0 then a borrow happened, if <0 then a payback happened.                     if 0 then nothing.\",\"borrowTo\":\"address that funds where borrowed to (if borrowAmount >0)\",\"exchangePricesAndConfig\":\"updated exchange prices and configs storage slot. Contains updated supply & borrow exchange price: First 16 bits =>   0- 15 => borrow rate (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535) Next  14 bits =>  16- 29 => fee on interest from borrowers to lenders (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable. Next  14 bits =>  30- 43 => last stored utilization (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383) Next  14 bits =>  44- 57 => update on storage threshold (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable. Next  33 bits =>  58- 90 => last update timestamp (enough until 16 March 2242 -> max value 8589934591) Next  64 bits =>  91-154 => supply exchange price (1e12 -> max value 18_446_744,073709551615) Next  64 bits => 155-218 => borrow exchange price (1e12 -> max value 18_446_744,073709551615) Next   1 bit  => 219-219 => if 0 then ratio is supplyInterestFree / supplyWithInterest else ratio is supplyWithInterest / supplyInterestFree Next  14 bits => 220-233 => supplyRatio: supplyInterestFree / supplyWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383) Next   1 bit  => 234-234 => if 0 then ratio is borrowInterestFree / borrowWithInterest else ratio is borrowWithInterest / borrowInterestFree Next  14 bits => 235-248 => borrowRatio: borrowInterestFree / borrowWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\",\"supplyAmount\":\"supply amount for the operation. if >0 then a deposit happened, if <0 then a withdrawal happened.                     if 0 then nothing.\",\"token\":\"token address for which this operation was executed\",\"totalAmounts\":\"updated total amounts, stacked uint256 as written to storage: First  64 bits =>   0- 63 => total supply with interest in raw (totalSupply = totalSupplyRaw * supplyExchangePrice); BigMath: 56 | 8 Next   64 bits =>  64-127 => total interest free supply in normal token amount (totalSupply = totalSupply); BigMath: 56 | 8 Next   64 bits => 128-191 => total borrow with interest in raw (totalBorrow = totalBorrowRaw * borrowExchangePrice); BigMath: 56 | 8 Next   64 bits => 192-255 => total interest free borrow in normal token amount (totalBorrow = totalBorrow); BigMath: 56 | 8\",\"user\":\"protocol that triggered this operation (e.g. via an fToken or via Vault protocol)\",\"withdrawTo\":\"address that funds where withdrawn to (if supplyAmount <0)\"}}},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"events\":{\"BorrowRateMaxCap()\":{\"notice\":\"emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\"},\"LogOperate(address,address,int256,int256,address,address,uint256,uint256)\":{\"notice\":\"emitted on any `operate()` execution: deposit / supply / withdraw / borrow. includes info related to the executed operation, new total amounts (packed uint256 of BigMath numbers as in storage) and exchange prices (packed uint256 as in storage).\"}},\"kind\":\"user\",\"methods\":{\"operate(address,int256,int256,address,address,bytes)\":{\"notice\":\"inheritdoc IFluidLiquidity\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/liquidity/userModule/mainOthers.sol\":\"FluidLiquidityUserModuleOthers\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\",\"keccak256\":\"0x6ebf1944ab804b8660eb6fc52f9fe84588cee01c2566a69023e59497e7d27f45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"contracts/libraries/bigMathMinified.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\\n/// result in significant gas cost reduction due to storage space reduction.\\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\\nlibrary BigMathMinified {\\n    /// @dev constants to use for `roundUp` input param to increase readability\\n    bool internal constant ROUND_DOWN = false;\\n    bool internal constant ROUND_UP = true;\\n\\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\\n    /// e.g.:\\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\\n    /// exponent =                                            0011,0011     (51)\\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\\n    ///\\n    /// @param normal number which needs to be converted into Big Number\\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\\n    /// @param roundUp signals if result should be rounded down or up\\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\\n    function toBigNumber(\\n        uint256 normal,\\n        uint256 coefficientSize,\\n        uint256 exponentSize,\\n        bool roundUp\\n    ) internal pure returns (uint256 bigNumber) {\\n        assembly {\\n            let lastBit_\\n            let number_ := normal\\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x80, number_)\\n                lastBit_ := 0x80\\n            }\\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x40, number_)\\n                lastBit_ := add(lastBit_, 0x40)\\n            }\\n            if gt(number_, 0xFFFFFFFF) {\\n                number_ := shr(0x20, number_)\\n                lastBit_ := add(lastBit_, 0x20)\\n            }\\n            if gt(number_, 0xFFFF) {\\n                number_ := shr(0x10, number_)\\n                lastBit_ := add(lastBit_, 0x10)\\n            }\\n            if gt(number_, 0xFF) {\\n                number_ := shr(0x8, number_)\\n                lastBit_ := add(lastBit_, 0x8)\\n            }\\n            if gt(number_, 0xF) {\\n                number_ := shr(0x4, number_)\\n                lastBit_ := add(lastBit_, 0x4)\\n            }\\n            if gt(number_, 0x3) {\\n                number_ := shr(0x2, number_)\\n                lastBit_ := add(lastBit_, 0x2)\\n            }\\n            if gt(number_, 0x1) {\\n                lastBit_ := add(lastBit_, 1)\\n            }\\n            if gt(number_, 0) {\\n                lastBit_ := add(lastBit_, 1)\\n            }\\n            if lt(lastBit_, coefficientSize) {\\n                // for throw exception\\n                lastBit_ := coefficientSize\\n            }\\n            let exponent := sub(lastBit_, coefficientSize)\\n            let coefficient := shr(exponent, normal)\\n            if and(roundUp, gt(exponent, 0)) {\\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\\n                coefficient := add(coefficient, 1)\\n                if eq(shl(coefficientSize, 1), coefficient) {\\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\\n                    coefficient := shl(sub(coefficientSize, 1), 1)\\n                    exponent := add(exponent, 1)\\n                }\\n            }\\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\\n                // if exponent is >= exponentSize, the normal number is too big to fit within\\n                // BigNumber with too small sizes for coefficient and exponent\\n                revert(0, 0)\\n            }\\n            bigNumber := shl(exponentSize, coefficient)\\n            bigNumber := add(bigNumber, exponent)\\n        }\\n    }\\n\\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\\n    function fromBigNumber(\\n        uint256 bigNumber,\\n        uint256 exponentSize,\\n        uint256 exponentMask\\n    ) internal pure returns (uint256 normal) {\\n        assembly {\\n            let coefficient := shr(exponentSize, bigNumber)\\n            let exponent := and(bigNumber, exponentMask)\\n            normal := shl(exponent, coefficient)\\n        }\\n    }\\n\\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\\n    /// e.g.\\n    /// 5035703444687813576399584 = 10000101010010110100000011111011110010100110100000000011100101001101001101011100000\\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\\n        assembly {\\n            let number_ := normal\\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x80, number_)\\n                lastBit := 0x80\\n            }\\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x40, number_)\\n                lastBit := add(lastBit, 0x40)\\n            }\\n            if gt(number_, 0xFFFFFFFF) {\\n                number_ := shr(0x20, number_)\\n                lastBit := add(lastBit, 0x20)\\n            }\\n            if gt(number_, 0xFFFF) {\\n                number_ := shr(0x10, number_)\\n                lastBit := add(lastBit, 0x10)\\n            }\\n            if gt(number_, 0xFF) {\\n                number_ := shr(0x8, number_)\\n                lastBit := add(lastBit, 0x8)\\n            }\\n            if gt(number_, 0xF) {\\n                number_ := shr(0x4, number_)\\n                lastBit := add(lastBit, 0x4)\\n            }\\n            if gt(number_, 0x3) {\\n                number_ := shr(0x2, number_)\\n                lastBit := add(lastBit, 0x2)\\n            }\\n            if gt(number_, 0x1) {\\n                lastBit := add(lastBit, 1)\\n            }\\n            if gt(number_, 0) {\\n                lastBit := add(lastBit, 1)\\n            }\\n        }\\n    }\\n\\n    /// @dev gets the least significant bit `firstBit` of a `normal` number (position of rightmost 1 in binary format).\\n    /// e.g.\\n    /// 5035703444687813576399584 = 10000101010010110100000011111011110010100110100000000011100101001101001101011100000\\n    /// firstBit =                                                                                               ^-6--^\\n    function leastSignificantBit(uint256 normal) internal pure returns (uint firstBit) {\\n        assembly {\\n            // If number is 0, revert as there is no least significant bit\\n            if iszero(normal) {\\n                revert(0, 0)\\n            }\\n\\n            // Find first set bit using binary search\\n            let number_ := normal\\n            firstBit := 0\\n\\n            // Check if lower 128 bits are all zero\\n            if iszero(and(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) {\\n                number_ := shr(0x80, number_)\\n                firstBit := 0x80\\n            }\\n            // Check if lower 64 bits are all zero\\n            if iszero(and(number_, 0xFFFFFFFFFFFFFFFF)) {\\n                number_ := shr(0x40, number_)\\n                firstBit := add(firstBit, 0x40)\\n            }\\n            // Check if lower 32 bits are all zero\\n            if iszero(and(number_, 0xFFFFFFFF)) {\\n                number_ := shr(0x20, number_)\\n                firstBit := add(firstBit, 0x20)\\n            }\\n            // Check if lower 16 bits are all zero\\n            if iszero(and(number_, 0xFFFF)) {\\n                number_ := shr(0x10, number_)\\n                firstBit := add(firstBit, 0x10)\\n            }\\n            // Check if lower 8 bits are all zero\\n            if iszero(and(number_, 0xFF)) {\\n                number_ := shr(0x8, number_)\\n                firstBit := add(firstBit, 0x8)\\n            }\\n            // Check if lower 4 bits are all zero\\n            if iszero(and(number_, 0xF)) {\\n                number_ := shr(0x4, number_)\\n                firstBit := add(firstBit, 0x4)\\n            }\\n            // Check if lower 2 bits are all zero\\n            if iszero(and(number_, 0x3)) {\\n                number_ := shr(0x2, number_)\\n                firstBit := add(firstBit, 0x2)\\n            }\\n            // Check if lowest bit is zero\\n            if iszero(and(number_, 0x1)) {\\n                firstBit := add(firstBit, 1)\\n            }\\n            // Add 1 to match the 1-based position counting\\n            firstBit := add(firstBit, 1)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa3a52426cd052e70cdfe2e69d40430a26073971b8defaa9a6f31112b4f03600e\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\nlibrary LibsErrorTypes {\\n    /***********************************|\\n    |         LiquidityCalcs            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\\n\\n    /// @notice thrown when rate data is set to a version that is not implemented\\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\\n\\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\\n\\n    /***********************************|\\n    |           SafeTransfer            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when safe transfer from for an ERC20 fails\\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\\n\\n    /// @notice thrown when safe transfer for an ERC20 fails\\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\\n\\n    /***********************************|\\n    |           SafeApprove             | \\n    |__________________________________*/\\n\\n    /// @notice thrown when safe approve from for an ERC20 fails\\n    uint256 internal constant SafeApprove__ApproveFailed = 81001;\\n}\\n\",\"keccak256\":\"0x4ae8d510a4119e20698381f323270ba219e66c03872e23073afff841e9b93a52\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/liquidityCalcs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\nimport { LibsErrorTypes as ErrorTypes } from \\\"./errorTypes.sol\\\";\\nimport { LiquiditySlotsLink } from \\\"./liquiditySlotsLink.sol\\\";\\nimport { BigMathMinified } from \\\"./bigMathMinified.sol\\\";\\n\\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\\n/// borrow rate, withdrawal / borrow limits, revenue amount.\\nlibrary LiquidityCalcs {\\n    error FluidLiquidityCalcsError(uint256 errorId_);\\n\\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\\n    event BorrowRateMaxCap();\\n\\n    /// @dev constants as from Liquidity variables.sol\\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\\n\\n    /// @dev Ignoring leap years\\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\\n    // constants used for BigMath conversion from and to storage\\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\\n\\n    uint256 internal constant FOUR_DECIMALS = 1e4;\\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\\n    uint256 internal constant X14 = 0x3fff;\\n    uint256 internal constant X15 = 0x7fff;\\n    uint256 internal constant X16 = 0xffff;\\n    uint256 internal constant X18 = 0x3ffff;\\n    uint256 internal constant X24 = 0xffffff;\\n    uint256 internal constant X33 = 0x1ffffffff;\\n    uint256 internal constant X64 = 0xffffffffffffffff;\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                  CALC EXCHANGE PRICES                  /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\\n    function calcExchangePrices(\\n        uint256 exchangePricesAndConfig_\\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\\n        // Extracting exchange prices\\n        supplyExchangePrice_ =\\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\\n            X64;\\n        borrowExchangePrice_ =\\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\\n            X64;\\n\\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\\n        }\\n\\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\\n\\n        unchecked {\\n            // last timestamp can not be > current timestamp\\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\\n\\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\\n                X15;\\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\\n                return (supplyExchangePrice_, borrowExchangePrice_);\\n            }\\n\\n            // calculate new borrow exchange price.\\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\\n            borrowExchangePrice_ +=\\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\\n\\n            // FOR SUPPLY EXCHANGE PRICE:\\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\\n            //\\n            // Example:\\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\\n            // yield is 10 (so half a year must have passed).\\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 25%) = 62,5%\\n            // supplyRate = (40% * (100% - 10%)) * 62,5% = 36% * 62,5% = 22.5%\\n            // increase in supplyExchangePrice, assuming 100 as previous price.\\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\\n\\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\\n\\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\\n\\n            if (temp_ == 1) {\\n                // if no raw supply: no exchange price update needed\\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\\n                return (supplyExchangePrice_, borrowExchangePrice_);\\n            }\\n\\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\\n            if (temp_ & 1 == 1) {\\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\\n                temp_ = temp_ >> 1;\\n\\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\\n                // in the if statement a little above.\\n\\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\\n                // so ratioSupplyYield must come out as 2.5 (250%).\\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\\n                temp_ =\\n                    // utilization * (100% + 100% / supplyRatio)\\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\\n                    (FOUR_DECIMALS);\\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\\n            } else {\\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\\n                temp_ = temp_ >> 1;\\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\\n\\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\\n                temp_ =\\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\\n                    (1e27 *\\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\\n                        (FOUR_DECIMALS + temp_)) /\\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\\n            }\\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\\n\\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\\n            if (borrowRatio_ & 1 == 1) {\\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\\n                borrowRatio_ = borrowRatio_ >> 1;\\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\\n\\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\\n\\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\\n            } else {\\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\\n                borrowRatio_ = borrowRatio_ >> 1;\\n\\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\\n            }\\n\\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\\n\\n            // 2. calculate supply rate\\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\\n            // but more suppliers not earning interest.\\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\\n                temp_ * // ratioSupplyYield\\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\\n\\n            // 3. calculate increase in supply exchange price\\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                     CALC REVENUE                       /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\\n    /// and the current balance of the Fluid liquidity contract for the token.\\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\\n    /// @return revenueAmount_ collectable revenue amount\\n    function calcRevenue(\\n        uint256 totalAmounts_,\\n        uint256 exchangePricesAndConfig_,\\n        uint256 liquidityTokenBalance_\\n    ) internal view returns (uint256 revenueAmount_) {\\n        // @dev no need to super-optimize this method as it is only used by admin\\n\\n        // calculate the new exchange prices based on earned interest\\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\\n\\n        // total supply = interest free + with interest converted from raw\\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\\n\\n        if (totalSupply_ > 0) {\\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\\n            // ensure there is no possible case because of rounding etc. where this would revert,\\n            // explicitly check if >\\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\\n            // can only be revenue.\\n        } else {\\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\\n            revenueAmount_ = liquidityTokenBalance_;\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                      CALC LIMITS                       /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev calculates withdrawal limit before an operate execution:\\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\\n    /// @param userSupplyData_ user supply data packed uint256 from storage\\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\\n    function calcWithdrawalLimitBeforeOperate(\\n        uint256 userSupplyData_,\\n        uint256 userSupply_\\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\\n        // a deposit anyway. Important is that it would not revert.\\n\\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\\n        // is the fully expanded limit immediately.\\n\\n        // extract last set withdrawal limit\\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\\n        lastWithdrawalLimit_ =\\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\\n        if (lastWithdrawalLimit_ == 0) {\\n            // withdrawal limit is not activated. Max withdrawal allowed\\n            return 0;\\n        }\\n\\n        uint256 maxWithdrawableLimit_;\\n        uint256 temp_;\\n        unchecked {\\n            // extract max withdrawable percent of user supply and\\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\\n\\n            // userSupply_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            maxWithdrawableLimit_ =\\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\\n                FOUR_DECIMALS;\\n\\n            // time elapsed since last withdrawal limit was set (in seconds)\\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\\n            // last timestamp can not be > current timestamp\\n            temp_ =\\n                block.timestamp -\\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\\n        }\\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\\n        temp_ =\\n            (maxWithdrawableLimit_ * temp_) /\\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\\n        unchecked {\\n            // underflow explicitly checked & handled\\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\\n            temp_ = userSupply_ - maxWithdrawableLimit_;\\n        }\\n        // if withdrawal limit is decreased below minimum then set minimum\\n        // (e.g. when more than expandDuration time has elapsed)\\n        if (temp_ > currentWithdrawalLimit_) {\\n            currentWithdrawalLimit_ = temp_;\\n        }\\n    }\\n\\n    /// @dev calculates withdrawal limit after an operate execution:\\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\\n    /// @param userSupplyData_ user supply data packed uint256 from storage\\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\\n    ///                          raw for with interest mode, normal amount for interest free mode!\\n    function calcWithdrawalLimitAfterOperate(\\n        uint256 userSupplyData_,\\n        uint256 userSupply_,\\n        uint256 newWithdrawalLimit_\\n    ) internal pure returns (uint256) {\\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        // if user supply is below base limit then max withdrawals are allowed\\n        if (userSupply_ < temp_) {\\n            return 0;\\n        }\\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\\n        unchecked {\\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\\n            // userSupply_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\\n        }\\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\\n        // increased deposit amount outpaces withrawals.\\n        if (temp_ > newWithdrawalLimit_) {\\n            return temp_;\\n        }\\n        return newWithdrawalLimit_;\\n    }\\n\\n    /// @dev calculates borrow limit before an operate execution:\\n    /// total amount user borrow can reach (not borrowable amount in current operation).\\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\\n    ///                             raw for with interest mode, normal amount for interest free mode!\\n    function calcBorrowLimitBeforeOperate(\\n        uint256 userBorrowData_,\\n        uint256 userBorrow_\\n    ) internal view returns (uint256 currentBorrowLimit_) {\\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\\n        // first tx where timestamp is 0 will end up with maxExpansionLimit_ = 0 because userBorrow = 0, so maxExpandedBorrowLimit_ = 0,\\n        // so currentBorrowLimit_ = 0, so it will enter currentBorrowLimit_ < temp_ when checking against base limit as expected.\\n\\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\\n\\n        uint256 maxExpansionLimit_;\\n        uint256 maxExpandedBorrowLimit_;\\n        unchecked {\\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\\n\\n            // calculate max borrow limit: Max point limit can increase to since last interaction\\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\\n        }\\n\\n        // time elapsed since last borrow limit was set (in seconds)\\n        unchecked {\\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\\n            temp_ =\\n                block.timestamp -\\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\\n        }\\n\\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\\n        currentBorrowLimit_ =\\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\\n            ((maxExpansionLimit_ * temp_) /\\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\\n            //  extract last set borrow limit\\n            BigMathMinified.fromBigNumber(\\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\\n                DEFAULT_EXPONENT_SIZE,\\n                DEFAULT_EXPONENT_MASK\\n            );\\n\\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\\n        // so set to `maxExpandedBorrowLimit_` in that case.\\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\\n        }\\n\\n        // temp_ = extract base borrow limit, if current limit is below this, then set base limit as current limit\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n        if (currentBorrowLimit_ < temp_) {\\n            return temp_;\\n        }\\n\\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n        if (currentBorrowLimit_ > temp_) {\\n            return temp_;\\n        }\\n    }\\n\\n    /// @dev calculates borrow limit after an operate execution:\\n    /// total amount user borrow can reach (not borrowable amount in current operation).\\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\\n    function calcBorrowLimitAfterOperate(\\n        uint256 userBorrowData_,\\n        uint256 userBorrow_,\\n        uint256 newBorrowLimit_\\n    ) internal pure returns (uint256 borrowLimit_) {\\n        // temp_ = extract borrow expand percent\\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\\n\\n        unchecked {\\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\\n        }\\n\\n        // temp_ = extract base borrow limit\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (borrowLimit_ < temp_) {\\n            // below base limit, borrow limit is always base limit\\n            return temp_;\\n        }\\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        // make sure fully expanded borrow limit is not above hard max borrow limit\\n        if (borrowLimit_ > temp_) {\\n            borrowLimit_ = temp_;\\n        }\\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\\n        if (newBorrowLimit_ > borrowLimit_) {\\n            return borrowLimit_;\\n        }\\n        return newBorrowLimit_;\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                      CALC RATES                        /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev Calculates new borrow rate from utilization for a token\\n    /// @param rateData_ rate data packed uint256 from storage for the token\\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\\n        // extract rate version: 4 bits (0xF) starting from bit 0\\n        uint256 rateVersion_ = (rateData_ & 0xF);\\n\\n        if (rateVersion_ == 1) {\\n            rate_ = calcRateV1(rateData_, utilization_);\\n        } else if (rateVersion_ == 2) {\\n            rate_ = calcRateV2(rateData_, utilization_);\\n        } else {\\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\\n        }\\n\\n        if (rate_ > X16) {\\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\\n            // this is unlikely to ever happen if configs stay within expected levels.\\n            rate_ = X16;\\n            // emit event to more easily become aware\\n            emit BorrowRateMaxCap();\\n        }\\n    }\\n\\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\\n    /// @param rateData_ rate data packed uint256 from storage for the token\\n    /// @param utilization_  in 1e2 (100% = 1e4)\\n    /// @return rate_ rate in 1e2 precision\\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\\n        /// For rate v1 (one kink) ------------------------------------------------------\\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\\n\\n        // y = mx + c.\\n        // y is borrow rate\\n        // x is utilization\\n        // m = slope (m can also be negative for declining rates)\\n        // c is constant (c can be negative)\\n\\n        uint256 y1_;\\n        uint256 y2_;\\n        uint256 x1_;\\n        uint256 x2_;\\n\\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\\n        if (utilization_ < kink1_) {\\n            // if utilization is less than kink\\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\\n            x1_ = 0; // 0%\\n            x2_ = kink1_;\\n        } else {\\n            // else utilization is greater than kink\\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\\n            x1_ = kink1_;\\n            x2_ = FOUR_DECIMALS; // 100%\\n        }\\n\\n        int256 constant_;\\n        int256 slope_;\\n        unchecked {\\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\\n            slope_ = ((int256(y2_) - int256(y1_)) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\\n\\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\\n\\n            // calculating new borrow rate\\n            // - slope_ max value is 65535 * 1e12,\\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\\n            // - constant max value is 65535 * 1e12\\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\\n            // divisor TWELVE_DECIMALS can not be 0\\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\\n            if (slope_ < 0) {\\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\\n            }\\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\\n        }\\n    }\\n\\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\\n    /// @param rateData_ rate data packed uint256 from storage for the token\\n    /// @param utilization_  in 1e2 (100% = 1e4)\\n    /// @return rate_ rate in 1e4 precision\\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\\n        /// For rate v2 (two kinks) -----------------------------------------------------\\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Last 156 bits => 100-255 => blank, might come in use in future\\n\\n        // y = mx + c.\\n        // y is borrow rate\\n        // x is utilization\\n        // m = slope (m can also be negative for declining rates)\\n        // c is constant (c can be negative)\\n\\n        uint256 y1_;\\n        uint256 y2_;\\n        uint256 x1_;\\n        uint256 x2_;\\n\\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\\n        if (utilization_ < kink1_) {\\n            // if utilization is less than kink1\\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\\n            x1_ = 0; // 0%\\n            x2_ = kink1_;\\n        } else {\\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\\n            if (utilization_ < kink2_) {\\n                // if utilization is less than kink2\\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\\n                x1_ = kink1_;\\n                x2_ = kink2_;\\n            } else {\\n                // else utilization is greater than kink2\\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\\n                x1_ = kink2_;\\n                x2_ = FOUR_DECIMALS;\\n            }\\n        }\\n\\n        int256 constant_;\\n        int256 slope_;\\n        unchecked {\\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\\n            slope_ = ((int256(y2_) - int256(y1_)) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\\n\\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\\n\\n            // calculating new borrow rate\\n            // - slope_ max value is 65535 * 1e12,\\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\\n            // - constant max value is 65535 * 1e12\\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\\n            // divisor TWELVE_DECIMALS can not be 0\\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\\n            if (slope_ < 0) {\\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\\n            }\\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\\n        }\\n    }\\n\\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\\n    function getTotalSupply(\\n        uint256 totalAmounts_,\\n        uint256 supplyExchangePrice_\\n    ) internal pure returns (uint256 totalSupply_) {\\n        // totalSupply_ => supplyInterestFree\\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\\n\\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\\n\\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\\n    }\\n\\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\\n    function getTotalBorrow(\\n        uint256 totalAmounts_,\\n        uint256 borrowExchangePrice_\\n    ) internal pure returns (uint256 totalBorrow_) {\\n        // totalBorrow_ => borrowInterestFree\\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\\n\\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\\n\\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\\n    }\\n}\\n\",\"keccak256\":\"0x0bc0a822ddcf21bacd2513d19fc1fc5f8b48cbedfb83dfd7229c18b1c0a481dc\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/liquiditySlotsLink.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\\nlibrary LiquiditySlotsLink {\\n    /// @dev storage slot for status at Liquidity\\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\\n    /// @dev storage slot for auths mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\\n    /// @dev storage slot for guardians mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\\n    /// @dev storage slot for user class mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\\n    /// @dev storage slot for rateData mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\\n    /// @dev storage slot for totalAmounts mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\\n    /// @dev storage slot for user supply double mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\\n    /// @dev storage slot for user borrow double mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\\n    /// @dev storage slot for listed tokens array at Liquidity\\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\\n    /// @dev storage slot for configs2 at Liquidity\\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\\n\\n    // --------------------------------\\n    // @dev stacked uint256 storage slots bits position data for each:\\n\\n    // ExchangePricesAndConfig\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\\n\\n    // RateData:\\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\\n    // RateData: V1\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\\n    // RateData: V2\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\\n\\n    // TotalAmounts\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\\n\\n    // UserSupplyData\\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\\n    uint256 internal constant BITS_USER_SUPPLY_DECAY_AMOUNT = 218;\\n    uint256 internal constant BITS_USER_SUPPLY_DECAY_DURATION_CHECKPOINTS = 244;\\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\\n\\n    // UserBorrowData\\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\\n\\n    // Configs2\\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\\n\\n    // --------------------------------\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\\n    function calculateDoubleMappingStorageSlot(\\n        uint256 slot_,\\n        address key1_,\\n        address key2_\\n    ) internal pure returns (bytes32) {\\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\\n        return keccak256(abi.encode(key2_, intermediateSlot_));\\n    }\\n}\\n\",\"keccak256\":\"0x125e3f657b046a237decb9416f6ec377a506fd0059a252320f14531cb252b3ea\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/safeTransfer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.8.21 <=0.8.29;\\n\\nimport { LibsErrorTypes as ErrorTypes } from \\\"./errorTypes.sol\\\";\\n\\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\\nlibrary SafeTransfer {\\n    // pass max. 50k gas for native transfers. This ensures support for some realistic\\n    // scenarios like WETH deposits in receive() but as restrictive as possible.\\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 50000;\\n\\n    error FluidSafeTransferError(uint256 errorId_);\\n\\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\\n        bool success_;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from_\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to_\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \\\"amount_\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success_ := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        if (!success_) {\\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\\n        }\\n    }\\n\\n    /// @dev Transfer `amount_` of `token_` to `to_`.\\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\\n        bool success_;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to_\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \\\"amount_\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success_ := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        if (!success_) {\\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\\n        }\\n    }\\n\\n    /// @dev Transfer `amount_` of ` native token to `to_`.\\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\\n    function safeTransferNative(address to_, uint256 amount_) internal {\\n        bool success_;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\\n        }\\n\\n        if (!success_) {\\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdba6aa835daaf0de7d87d0ca8bd464f818d5cb820c701e511c224bfa70f7dc33\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/liquidity/common/helpers.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\nimport { Variables } from \\\"./variables.sol\\\";\\nimport { ErrorTypes } from \\\"../errorTypes.sol\\\";\\nimport { Error } from \\\"../error.sol\\\";\\n\\n/// @dev ReentrancyGuard based on OpenZeppelin implementation.\\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.8/contracts/security/ReentrancyGuard.sol\\nabstract contract ReentrancyGuard is Variables, Error {\\n    uint8 internal constant REENTRANCY_NOT_ENTERED = 1;\\n    uint8 internal constant REENTRANCY_ENTERED = 2;\\n\\n    constructor() {\\n        // on logic contracts, switch reentrancy to entered so no call is possible (forces delegatecall)\\n        _status = REENTRANCY_ENTERED;\\n    }\\n\\n    /// @dev Prevents a contract from calling itself, directly or indirectly.\\n    /// See OpenZeppelin implementation for more info\\n    modifier reentrancy() {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == REENTRANCY_ENTERED) {\\n            revert FluidLiquidityError(ErrorTypes.LiquidityHelpers__Reentrancy);\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = REENTRANCY_ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = REENTRANCY_NOT_ENTERED;\\n    }\\n}\\n\\nabstract contract CommonHelpers is ReentrancyGuard {\\n    /// @dev Returns the current admin (governance).\\n    function _getGovernanceAddr() internal view returns (address governance_) {\\n        assembly {\\n            governance_ := sload(GOVERNANCE_SLOT)\\n        }\\n    }\\n\\n    /// @notice Hook invoked after assets are transferred into the contract. Must be implemented for chain specific implementation version.\\n    /// @dev ATTENTION: THIS IS NOT CALLED FOR NATIVE TOKEN (e.g. ETH).\\n    /// @param token_ The address of the transferred-in token.\\n    /// @param amount_ The amount of tokens transferred in.\\n    function _afterTransferIn(address token_, uint256 amount_) internal virtual;\\n\\n    /// @notice Hook invoked before assets are transferred out of the contract. Must be implemented for chain specific implementation version.\\n    /// @dev ATTENTION: THIS IS NOT CALLED FOR NATIVE TOKEN (e.g. ETH).\\n    /// @param token_ The address of the token to be transferred out.\\n    /// @param amount_ The amount of tokens to be transferred out.\\n    function _preTransferOut(address token_, uint256 amount_) internal virtual;\\n\\n    /// @notice Returns the contract's own balance of the given token currently re-hypothecated or otherwise sitting externally.\\n    /// @param token_ The address of the token to check.\\n    /// @return The total balance of the contract re-hypothecated assets.\\n    function _getExternalBalances(address token_) internal view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0x085c08b031e1b65caf7c28074a701da549708aacc517fb0993ddccf90ad40b53\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/common/helpersOthers.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\nimport { CommonHelpers } from \\\"./helpers.sol\\\";\\n\\n/// @notice NON-mainnet (others) specific implementation of CommonHelpers.\\n/// @dev This contract contains chain-specific logic. It overrides the virtual methods defined in CommonHelpers (see helpers.sol).\\nabstract contract CommonHelpersOthers is CommonHelpers {\\n    function _afterTransferIn(address token_, uint256 amount_) internal override {}\\n\\n    function _preTransferOut(address token_, uint256 amount_) internal override {}\\n\\n    function _getExternalBalances(address /** token_ **/) internal pure override returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x81ca7ac813846ad1241a271a12e503297b2e0e8081bea932f2da33570f15807b\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/common/variables.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\nabstract contract ConstantVariables {\\n    /// @dev Storage slot with the admin of the contract. Logic from \\\"proxy.sol\\\".\\n    /// This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is validated in the constructor.\\n    bytes32 internal constant GOVERNANCE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\\n\\n    /// @dev address that is mapped to the chain native token\\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    /// @dev decimals for native token\\n    // !! Double check compatibility with all code if this ever changes for a deployment !!\\n    uint8 internal constant NATIVE_TOKEN_DECIMALS = 18;\\n\\n    /// @dev Minimum token decimals for any token that can be listed at Liquidity (inclusive)\\n    uint8 internal constant MIN_TOKEN_DECIMALS = 6;\\n    /// @dev Maximum token decimals for any token that can be listed at Liquidity (inclusive)\\n    uint8 internal constant MAX_TOKEN_DECIMALS = 18;\\n\\n    /// @dev Ignoring leap years\\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\\n\\n    /// @dev limit any total amount to be half of type(uint128).max (~3.4e38) at type(int128).max (~1.7e38) as safety\\n    /// measure for any potential overflows / unexpected outcomes. This is checked for total borrow / supply.\\n    uint256 internal constant MAX_TOKEN_AMOUNT_CAP = uint256(uint128(type(int128).max));\\n\\n    /// @dev limit for triggering a revert if sent along excess input amount diff is bigger than this percentage (in 1e2)\\n    uint256 internal constant MAX_INPUT_AMOUNT_EXCESS = 100; // 1%\\n\\n    /// @dev if this bytes32 is set in the calldata, then token transfers are skipped as long as Liquidity layer is on the winning side.\\n    bytes32 internal constant SKIP_TRANSFERS = keccak256(bytes(\\\"SKIP_TRANSFERS\\\"));\\n\\n    /// @dev if this bytes32 is set in the calldata, then token transfers are only done for net input - output.\\n    bytes32 internal constant NET_TRANSFERS = keccak256(bytes(\\\"NET_TRANSFERS\\\"));\\n    int256 internal constant SKIP_TRANSFER_OUT_BELOW_VALUE_SIGNAL = -1;\\n\\n    /// @dev time after which a write to storage of exchangePricesAndConfig will happen always.\\n    uint256 internal constant FORCE_STORAGE_WRITE_AFTER_TIME = 1 days;\\n\\n    /// @dev target duration for new decays on deposit amounts that push the withdrawal limit up. effective duration depends on\\n    ///      existing decay amount ratio to new decay amount.\\n    uint256 internal constant TOTAL_DECAY_CHECKPOINTS = 1e3;\\n    uint256 internal constant MIN_DECAY_DURATION_CHECKPOINTS = 80; // 80 checkpoints =4m 48s: minimum decay duration after a new deposit, depending on ratio.\\n    uint256 internal constant DECAY_CHECKPOINT_DURATION_SCALEDX10 = 36; // 3.6s * 10\\n\\n    /// @dev when a new operate amount is > 10_000 * existing total amount AND the amount is bigger than 2 ** 80 -> revert.\\n    ///      extra input validation safety check.\\n    uint256 internal constant MAX_NEW_VS_EXISTING_TOTAL_AMOUNT_RATIO_DEPOSIT_BORROW = 10_000;\\n    uint256 internal constant MAX_NEW_VS_EXISTING_TOTAL_AMOUNT_RATIO_WITHDRAW_PAYBACK = 2; // effectively 50% in one go\\n    uint256 internal constant MAX_NEW_AMOUNT_WHEN_RATIO_CHECK = 2 ** 80; // 1.208.925,819614629174706176\\n\\n    /// @dev constants used for BigMath conversion from and to storage\\n    uint256 internal constant DECAY_COEFFICIENT_SIZE = 18;\\n    uint256 internal constant SMALL_COEFFICIENT_SIZE = 10;\\n    uint256 internal constant DEFAULT_COEFFICIENT_SIZE = 56;\\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\\n\\n    /// @dev constants to increase readability for using bit masks\\n    uint256 internal constant FOUR_DECIMALS = 1e4;\\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\\n\\n    uint256 internal constant X8 = 0xff;\\n    uint256 internal constant X10 = 0x3ff;\\n    uint256 internal constant X14 = 0x3fff;\\n    uint256 internal constant X15 = 0x7fff;\\n    uint256 internal constant X16 = 0xffff;\\n    uint256 internal constant X18 = 0x3ffff;\\n    uint256 internal constant X24 = 0xffffff;\\n    uint256 internal constant X26 = 0x3ffffff;\\n    uint256 internal constant X33 = 0x1ffffffff;\\n    uint256 internal constant X64 = 0xffffffffffffffff;\\n\\n    // protocol identifier for dexV2\\n    bytes32 internal constant DEXV2_IDENTIFIER = keccak256(bytes(\\\"DEXV2\\\"));\\n}\\n\\nabstract contract Variables is ConstantVariables {\\n    /// @dev address of contract that gets sent the revenue. Configurable by governance\\n    address internal _revenueCollector;\\n\\n    // 12 bytes empty\\n\\n    // ----- storage slot 1 ------\\n\\n    /// @dev paused status: status = 1 -> normal. status = 2 -> paused.\\n    /// not tightly packed with revenueCollector address to allow for potential changes later that improve gas more\\n    /// (revenueCollector is only rarely used by admin methods, where optimization is not as important).\\n    /// to be replaced with transient storage once EIP-1153 Transient storage becomes available with dencun upgrade.\\n    uint256 internal _status;\\n\\n    // ----- storage slot 2 ------\\n\\n    /// @dev Auths can set most config values. E.g. contracts that automate certain flows like e.g. adding a new fToken.\\n    /// Governance can add/remove auths.\\n    /// Governance is auth by default\\n    mapping(address => uint256) internal _isAuth;\\n\\n    // ----- storage slot 3 ------\\n\\n    /// @dev Guardians can pause lower class users\\n    /// Governance can add/remove guardians\\n    /// Governance is guardian by default\\n    mapping(address => uint256) internal _isGuardian;\\n\\n    // ----- storage slot 4 ------\\n\\n    /// @dev class defines which protocols can be paused by guardians\\n    /// Currently there are 2 classes: 0 can be paused by guardians. 1 cannot be paused by guardians.\\n    /// New protocols are added as class 0 and will be upgraded to 1 over time.\\n    mapping(address => uint256) internal _userClass;\\n\\n    // ----- storage slot 5 ------\\n\\n    /// @dev exchange prices and token config per token: token -> exchange prices & config\\n    /// First 16 bits =>   0- 15 => borrow rate (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n    /// Next  14 bits =>  16- 29 => fee on interest from borrowers to lenders (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\\n    /// Next  14 bits =>  30- 43 => last stored utilization (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\\n    /// Next  14 bits =>  44- 57 => update on storage threshold (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\\n    /// Next  33 bits =>  58- 90 => last update timestamp (enough until 16 March 2242 -> max value 8589934591)\\n    /// Next  64 bits =>  91-154 => supply exchange price (1e12 -> max value 18_446_744,073709551615)\\n    /// Next  64 bits => 155-218 => borrow exchange price (1e12 -> max value 18_446_744,073709551615)\\n    /// Next   1 bit  => 219-219 => if 0 then ratio is supplyInterestFree / supplyWithInterest else ratio is supplyWithInterest / supplyInterestFree\\n    /// Next  14 bits => 220-233 => supplyRatio: supplyInterestFree / supplyWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\\n    /// Next   1 bit  => 234-234 => if 0 then ratio is borrowInterestFree / borrowWithInterest else ratio is borrowWithInterest / borrowInterestFree\\n    /// Next  14 bits => 235-248 => borrowRatio: borrowInterestFree / borrowWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\\n    /// Next   1 bit  => 249-249 => flag for token uses config storage slot 2. (signals SLOAD for additional config slot is needed during execution)\\n    /// Last   6 bits => 250-255 => empty for future use\\n    ///                             if more free bits are needed in the future, update on storage threshold bits could be reduced to 7 bits\\n    ///                             (can plan to add `MAX_TOKEN_CONFIG_UPDATE_THRESHOLD` but need to adjust more bits)\\n    ///                             if more bits absolutely needed then we can convert fee, utilization, update on storage threshold,\\n    ///                             supplyRatio & borrowRatio from 14 bits to 10bits (1023 max number) where 1000 = 100% & 1 = 0.1%\\n    mapping(address => uint256) internal _exchangePricesAndConfig;\\n\\n    // ----- storage slot 6 ------\\n\\n    /// @dev Rate related data per token: token -> rate data\\n    /// READ (SLOAD): all actions; WRITE (SSTORE): only on set config admin actions\\n    /// token => rate related data\\n    /// First 4 bits  =>     0-3 => rate version\\n    /// rest of the bits are rate dependent:\\n\\n    /// For rate v1 (one kink) ------------------------------------------------------\\n    /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n    /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n    /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n    /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n    /// Last 188 bits =>  68-255 => empty for future use\\n\\n    /// For rate v2 (two kinks) -----------------------------------------------------\\n    /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n    /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n    /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n    /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n    /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n    /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n    /// Last 156 bits => 100-255 => empty for future use\\n    mapping(address => uint256) internal _rateData;\\n\\n    // ----- storage slot 7 ------\\n\\n    /// @dev total supply / borrow amounts for with / without interest per token: token -> amounts\\n    /// First  64 bits =>   0- 63 => total supply with interest in raw (totalSupply = totalSupplyRaw * supplyExchangePrice); BigMath: 56 | 8\\n    /// Next   64 bits =>  64-127 => total interest free supply in normal token amount (totalSupply = totalSupply); BigMath: 56 | 8\\n    /// Next   64 bits => 128-191 => total borrow with interest in raw (totalBorrow = totalBorrowRaw * borrowExchangePrice); BigMath: 56 | 8\\n    /// Next   64 bits => 192-255 => total interest free borrow in normal token amount (totalBorrow = totalBorrow); BigMath: 56 | 8\\n    mapping(address => uint256) internal _totalAmounts;\\n\\n    // ----- storage slot 8 ------\\n\\n    /// @dev user supply data per token: user -> token -> data\\n    /// First  1 bit  =>       0 => mode: user supply with or without interest\\n    ///                             0 = without, amounts are in normal (i.e. no need to multiply with exchange price)\\n    ///                             1 = with interest, amounts are in raw (i.e. must multiply with exchange price to get actual token amounts)\\n    /// Next  64 bits =>   1- 64 => user supply amount (normal or raw depends on 1st bit); BigMath: 56 | 8\\n    /// Next  64 bits =>  65-128 => previous user withdrawal limit (normal or raw depends on 1st bit); BigMath: 56 | 8\\n    /// Next  33 bits => 129-161 => last triggered process timestamp (enough until 16 March 2242 -> max value 8589934591)\\n    /// Next  14 bits => 162-175 => expand withdrawal limit percentage (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\\n    ///                             @dev shrinking is instant, available decay is taken first\\n    /// Next  24 bits => 176-199 => withdrawal limit expand duration in seconds.(Max value 16_777_215; ~4_660 hours, ~194 days)\\n    /// Next  18 bits => 200-217 => base withdrawal limit: below this, 100% withdrawals can be done (normal or raw depends on 1st bit); BigMath: 10 | 8\\n    /// Next  26 bits => 218-243 => decay amount per second; BigMath 18 | 8\\n    /// Next  10 bits => 244-253 => decay duration checkpoints, max 1023. precision = 0.1% so down to 0.1% of 60 minutes = 0.06 minutes = ~3.6 seconds (1 checkpoint)\\n    /// Next   1 bit  => 254-254 => empty for future use\\n    /// Last     bit  => 255-255 => is user paused (1 = paused, 0 = not paused)\\n    mapping(address => mapping(address => uint256)) internal _userSupplyData;\\n\\n    // ----- storage slot 9 ------\\n\\n    /// @dev user borrow data per token: user -> token -> data\\n    /// First  1 bit  =>       0 => mode: user borrow with or without interest\\n    ///                             0 = without, amounts are in normal (i.e. no need to multiply with exchange price)\\n    ///                             1 = with interest, amounts are in raw (i.e. must multiply with exchange price to get actual token amounts)\\n    /// Next  64 bits =>   1- 64 => user borrow amount (normal or raw depends on 1st bit); BigMath: 56 | 8\\n    /// Next  64 bits =>  65-128 => previous user debt ceiling (normal or raw depends on 1st bit); BigMath: 56 | 8\\n    /// Next  33 bits => 129-161 => last triggered process timestamp (enough until 16 March 2242 -> max value 8589934591)\\n    /// Next  14 bits => 162-175 => expand debt ceiling percentage (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\\n    ///                             @dev shrinking is instant\\n    /// Next  24 bits => 176-199 => debt ceiling expand duration in seconds (Max value 16_777_215; ~4_660 hours, ~194 days)\\n    /// Next  18 bits => 200-217 => base debt ceiling: below this, there's no debt ceiling limits (normal or raw depends on 1st bit); BigMath: 10 | 8\\n    /// Next  18 bits => 218-235 => max debt ceiling: absolute maximum debt ceiling can expand to (normal or raw depends on 1st bit); BigMath: 10 | 8\\n    /// Next  19 bits => 236-254 => empty for future use\\n    /// Last     bit  => 255-255 => is user paused (1 = paused, 0 = not paused)\\n    mapping(address => mapping(address => uint256)) internal _userBorrowData;\\n\\n    // ----- storage slot 10 ------\\n\\n    /// @dev list of allowed tokens at Liquidity. tokens that are once configured can never be completely removed. so this\\n    ///      array is append-only.\\n    address[] internal _listedTokens;\\n\\n    // ----- storage slot 11 ------\\n\\n    /// @dev expanded token configs per token: token -> config data slot 2.\\n    ///      Use of this is signaled by `_exchangePricesAndConfig` bit 249.\\n    /// First 14 bits =>   0- 13 => max allowed utilization (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\\n    /// Last 242 bits =>  14-255 => empty for future use\\n    mapping(address => uint256) internal _configs2;\\n}\\n\",\"keccak256\":\"0xab9d5b41a62d08c0311bfaafef8d751d9bfa5976958ed6ab614274dbe084dda9\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/error.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\ncontract Error {\\n    error FluidLiquidityError(uint256 errorId_);\\n}\\n\",\"keccak256\":\"0x14e62a7adb4b699027ccb287dd1a999607164a309e7bc757018003f7414650bf\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\nlibrary ErrorTypes {\\n    /***********************************|\\n    |         Admin Module              | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an input address is zero\\n    uint256 internal constant AdminModule__AddressZero = 10001;\\n\\n    /// @notice thrown when msg.sender is not governance\\n    uint256 internal constant AdminModule__OnlyGovernance = 10002;\\n\\n    /// @notice thrown when msg.sender is not auth\\n    uint256 internal constant AdminModule__OnlyAuths = 10003;\\n\\n    /// @notice thrown when msg.sender is not guardian\\n    uint256 internal constant AdminModule__OnlyGuardians = 10004;\\n\\n    /// @notice thrown when base withdrawal limit, base debt limit or max withdrawal limit is sent as 0\\n    uint256 internal constant AdminModule__LimitZero = 10005;\\n\\n    /// @notice thrown whenever an invalid input param is given\\n    uint256 internal constant AdminModule__InvalidParams = 10006;\\n\\n    /// @notice thrown if user class 1 is paused (can not be paused)\\n    uint256 internal constant AdminModule__UserNotPausable = 10007;\\n\\n    /// @notice thrown if user is tried to be unpaused but is not paused in the first place\\n    uint256 internal constant AdminModule__UserNotPaused = 10008;\\n\\n    /// @notice thrown if user is not defined yet: Governance didn't yet set any config for this user on a particular token\\n    uint256 internal constant AdminModule__UserNotDefined = 10009;\\n\\n    /// @notice thrown if a token is configured in an invalid order:  1. Set rate config for token 2. Set token config 3. allow any user.\\n    uint256 internal constant AdminModule__InvalidConfigOrder = 10010;\\n\\n    /// @notice thrown if revenue is collected when revenue collector address is not set\\n    uint256 internal constant AdminModule__RevenueCollectorNotSet = 10011;\\n\\n    /// @notice all ValueOverflow errors below are thrown if a certain input param overflows the allowed storage size\\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_ZERO = 10012;\\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_KINK = 10013;\\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_MAX = 10014;\\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_KINK1 = 10015;\\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_KINK2 = 10016;\\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_MAX_V2 = 10017;\\n    uint256 internal constant AdminModule__ValueOverflow__FEE = 10018;\\n    uint256 internal constant AdminModule__ValueOverflow__THRESHOLD = 10019;\\n    uint256 internal constant AdminModule__ValueOverflow__EXPAND_PERCENT = 10020;\\n    uint256 internal constant AdminModule__ValueOverflow__EXPAND_DURATION = 10021;\\n    uint256 internal constant AdminModule__ValueOverflow__EXPAND_PERCENT_BORROW = 10022;\\n    uint256 internal constant AdminModule__ValueOverflow__EXPAND_DURATION_BORROW = 10023;\\n    uint256 internal constant AdminModule__ValueOverflow__EXCHANGE_PRICES = 10024;\\n    uint256 internal constant AdminModule__ValueOverflow__UTILIZATION = 10025;\\n\\n    /// @notice thrown when an address is not a contract\\n    uint256 internal constant AdminModule__AddressNotAContract = 10026;\\n\\n    uint256 internal constant AdminModule__ValueOverflow__MAX_UTILIZATION = 10027;\\n\\n    /// @notice thrown if a token that is being listed has not between 6 and 18 decimals\\n    uint256 internal constant AdminModule__TokenInvalidDecimalsRange = 10028;\\n\\n    /***********************************|\\n    |          User Module              | \\n    |__________________________________*/\\n\\n    /// @notice thrown when user operations are paused for an interacted token\\n    uint256 internal constant UserModule__UserNotDefined = 11001;\\n\\n    /// @notice thrown when user operations are paused for an interacted token\\n    uint256 internal constant UserModule__UserPaused = 11002;\\n\\n    /// @notice thrown when user's try to withdraw below withdrawal limit\\n    uint256 internal constant UserModule__WithdrawalLimitReached = 11003;\\n\\n    /// @notice thrown when user's try to borrow above borrow limit\\n    uint256 internal constant UserModule__BorrowLimitReached = 11004;\\n\\n    /// @notice thrown when user sent supply/withdraw and borrow/payback both as 0\\n    uint256 internal constant UserModule__OperateAmountsZero = 11005;\\n\\n    /// @notice thrown when user sent supply/withdraw or borrow/payback both as bigger than 2**128\\n    uint256 internal constant UserModule__OperateAmountOutOfBounds = 11006;\\n\\n    /// @notice thrown when the operate amount for supply / withdraw / borrow / payback is below the minimum amount\\n    /// that would cause a storage difference after BigMath & rounding imprecision. Extremely unlikely to ever happen\\n    /// for all normal use-cases.\\n    uint256 internal constant UserModule__OperateAmountInsufficient = 11007;\\n\\n    /// @notice thrown when withdraw or borrow is executed but withdrawTo or borrowTo is the zero address\\n    uint256 internal constant UserModule__ReceiverNotDefined = 11008;\\n\\n    /// @notice thrown when user did send excess or insufficient amount (beyond rounding issues)\\n    uint256 internal constant UserModule__TransferAmountOutOfBounds = 11009;\\n\\n    /// @notice thrown when user sent msg.value along for an operation not for the native token\\n    uint256 internal constant UserModule__MsgValueForNonNativeToken = 11010;\\n\\n    /// @notice thrown when a borrow operation is done when utilization is above 100%\\n    uint256 internal constant UserModule__MaxUtilizationReached = 11011;\\n\\n    /// @notice all ValueOverflow errors below are thrown if a certain input param or calc result overflows the allowed storage size\\n    uint256 internal constant UserModule__ValueOverflow__EXCHANGE_PRICES = 11012;\\n    uint256 internal constant UserModule__ValueOverflow__UTILIZATION = 11013;\\n    uint256 internal constant UserModule__ValueOverflow__TOTAL_SUPPLY = 11014;\\n    uint256 internal constant UserModule__ValueOverflow__TOTAL_BORROW = 11015;\\n\\n    /// @notice thrown when SKIP_TRANSFERS is set but the input params are invalid for skipping transfers\\n    uint256 internal constant UserModule__SkipTransfersInvalid = 11016;\\n\\n    /// @notice thrown when a new operate amount is > 10_000 * existing total amount AND the amount is bigger than 2 ** 80\\n    uint256 internal constant UserModule__OperateAmountRatioExcess = 11017;\\n\\n    /// @notice thrown when NET_TRANSFERS is set but the input params are invalid for net transfers\\n    uint256 internal constant UserModule__NetTransfersInvalid = 11018;\\n\\n    /***********************************|\\n    |         LiquidityHelpers          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when a reentrancy happens\\n    uint256 internal constant LiquidityHelpers__Reentrancy = 12001;\\n}\\n\",\"keccak256\":\"0xa5e6ec6504826494fda9ca4ee27939a5d3293ac39c9c349573fca4eb1ddc2cb6\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/userModule/events.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\ncontract Events {\\n    /// @notice emitted on any `operate()` execution: deposit / supply / withdraw / borrow.\\n    /// includes info related to the executed operation, new total amounts (packed uint256 of BigMath numbers as in storage)\\n    /// and exchange prices (packed uint256 as in storage).\\n    /// @param user protocol that triggered this operation (e.g. via an fToken or via Vault protocol)\\n    /// @param token token address for which this operation was executed\\n    /// @param supplyAmount supply amount for the operation. if >0 then a deposit happened, if <0 then a withdrawal happened.\\n    ///                     if 0 then nothing.\\n    /// @param borrowAmount borrow amount for the operation. if >0 then a borrow happened, if <0 then a payback happened.\\n    ///                     if 0 then nothing.\\n    /// @param withdrawTo   address that funds where withdrawn to (if supplyAmount <0)\\n    /// @param borrowTo     address that funds where borrowed to (if borrowAmount >0)\\n    /// @param totalAmounts updated total amounts, stacked uint256 as written to storage:\\n    /// First  64 bits =>   0- 63 => total supply with interest in raw (totalSupply = totalSupplyRaw * supplyExchangePrice); BigMath: 56 | 8\\n    /// Next   64 bits =>  64-127 => total interest free supply in normal token amount (totalSupply = totalSupply); BigMath: 56 | 8\\n    /// Next   64 bits => 128-191 => total borrow with interest in raw (totalBorrow = totalBorrowRaw * borrowExchangePrice); BigMath: 56 | 8\\n    /// Next   64 bits => 192-255 => total interest free borrow in normal token amount (totalBorrow = totalBorrow); BigMath: 56 | 8\\n    /// @param exchangePricesAndConfig updated exchange prices and configs storage slot. Contains updated supply & borrow exchange price:\\n    /// First 16 bits =>   0- 15 => borrow rate (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n    /// Next  14 bits =>  16- 29 => fee on interest from borrowers to lenders (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\\n    /// Next  14 bits =>  30- 43 => last stored utilization (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\\n    /// Next  14 bits =>  44- 57 => update on storage threshold (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\\n    /// Next  33 bits =>  58- 90 => last update timestamp (enough until 16 March 2242 -> max value 8589934591)\\n    /// Next  64 bits =>  91-154 => supply exchange price (1e12 -> max value 18_446_744,073709551615)\\n    /// Next  64 bits => 155-218 => borrow exchange price (1e12 -> max value 18_446_744,073709551615)\\n    /// Next   1 bit  => 219-219 => if 0 then ratio is supplyInterestFree / supplyWithInterest else ratio is supplyWithInterest / supplyInterestFree\\n    /// Next  14 bits => 220-233 => supplyRatio: supplyInterestFree / supplyWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\\n    /// Next   1 bit  => 234-234 => if 0 then ratio is borrowInterestFree / borrowWithInterest else ratio is borrowWithInterest / borrowInterestFree\\n    /// Next  14 bits => 235-248 => borrowRatio: borrowInterestFree / borrowWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\\n    event LogOperate(\\n        address indexed user,\\n        address indexed token,\\n        int256 supplyAmount,\\n        int256 borrowAmount,\\n        address withdrawTo,\\n        address borrowTo,\\n        uint256 totalAmounts,\\n        uint256 exchangePricesAndConfig\\n    );\\n}\\n\",\"keccak256\":\"0xf272b1e4bbde000105f9b96349af3938977c12e099c879322ad6df7ab5854559\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/userModule/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\nimport { FixedPointMathLib } from \\\"solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\nimport { BigMathMinified } from \\\"../../libraries/bigMathMinified.sol\\\";\\nimport { LiquidityCalcs } from \\\"../../libraries/liquidityCalcs.sol\\\";\\nimport { LiquiditySlotsLink } from \\\"../../libraries/liquiditySlotsLink.sol\\\";\\nimport { SafeTransfer } from \\\"../../libraries/safeTransfer.sol\\\";\\nimport { CommonHelpers } from \\\"../common/helpers.sol\\\";\\nimport { Events } from \\\"./events.sol\\\";\\nimport { ErrorTypes } from \\\"../errorTypes.sol\\\";\\nimport { Error } from \\\"../error.sol\\\";\\n\\ninterface IProtocol {\\n    function liquidityCallback(address token_, uint256 amount_, bytes calldata data_) external;\\n}\\n\\nabstract contract CoreInternals is Error, CommonHelpers, Events {\\n    using BigMathMinified for uint256;\\n\\n    /// @dev supply or withdraw for both with interest & interest free.\\n    /// positive `amount_` is deposit, negative `amount_` is withdraw.\\n    function _supplyOrWithdraw(\\n        address token_,\\n        int256 amount_,\\n        uint256 supplyExchangePrice_\\n    ) internal returns (int256 newSupplyInterestRaw_, int256 newSupplyInterestFree_) {\\n        uint256 userSupplyData_ = _userSupplyData[msg.sender][token_];\\n\\n        if (userSupplyData_ == 0) {\\n            revert FluidLiquidityError(ErrorTypes.UserModule__UserNotDefined);\\n        }\\n        if ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_IS_PAUSED) & 1 == 1) {\\n            revert FluidLiquidityError(ErrorTypes.UserModule__UserPaused);\\n        }\\n\\n        // extract user supply amount\\n        uint256 userSupply_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\\n        userSupply_ = (userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK);\\n\\n        // get current leftover decaying amount\\n        uint256 decayAmount_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_DECAY_AMOUNT) & X26;\\n        decayAmount_ = (decayAmount_ >> DEFAULT_EXPONENT_SIZE) << (decayAmount_ & DEFAULT_EXPONENT_MASK);\\n\\n        // decay duration is in checkpoints. Also decay duration related constants are in Checkpoints, not in seconds!\\n        uint256 decayDurationCPs_ = (userSupplyData_ >>\\n            LiquiditySlotsLink.BITS_USER_SUPPLY_DECAY_DURATION_CHECKPOINTS) & X10;\\n\\n        if (decayAmount_ > 0) {\\n            unchecked {\\n                // calculate decay check points passed by scaling timestamps x 10\\n                // formula: (block.timestamp * 10 / 36) - (lastUpdateTimestamp * 10 / 36)\\n                // can not underflow as last timestamp can never be > block.timestamp and divisor can not be 0\\n                uint256 decayedCPs_ = ((block.timestamp * 10) / DECAY_CHECKPOINT_DURATION_SCALEDX10) -\\n                    ((((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33) * 10) /\\n                        DECAY_CHECKPOINT_DURATION_SCALEDX10);\\n                if (decayedCPs_ < decayDurationCPs_) {\\n                    // only partial decay happened, update leftover decay amount\\n                    decayAmount_ = decayAmount_ - (decayAmount_ * decayedCPs_) / decayDurationCPs_; // decayDurationCPs_ can not be 0. can not underflow\\n                    decayDurationCPs_ = decayDurationCPs_ - decayedCPs_; // decayDurationCPs_ => decay duration checkpoints leftover\\n                } else {\\n                    // full decay happened\\n                    decayAmount_ = 0;\\n                    decayDurationCPs_ = 0;\\n                }\\n            }\\n        }\\n\\n        // calculate current, updated (expanded etc.) withdrawal limit\\n        uint256 withdrawLimitBefore_ = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\\n\\n        // calculate updated user supply amount\\n        if (userSupplyData_ & 1 == 1) {\\n            // mode: with interest\\n            if (amount_ > 0) {\\n                // convert amount from normal to raw (divide by exchange price) -> round down for deposit\\n                newSupplyInterestRaw_ = (amount_ * int256(EXCHANGE_PRICES_PRECISION)) / int256(supplyExchangePrice_);\\n                userSupply_ = userSupply_ + uint256(newSupplyInterestRaw_);\\n            } else {\\n                // convert amount from normal to raw (divide by exchange price) -> round up for withdraw\\n                newSupplyInterestRaw_ = -int256(\\n                    FixedPointMathLib.mulDivUp(uint256(-amount_), EXCHANGE_PRICES_PRECISION, supplyExchangePrice_)\\n                );\\n                // if withdrawal is more than user's supply then solidity will throw here\\n                userSupply_ = userSupply_ - uint256(-newSupplyInterestRaw_);\\n            }\\n        } else {\\n            // mode: without interest\\n            newSupplyInterestFree_ = amount_;\\n            if (newSupplyInterestFree_ > 0) {\\n                userSupply_ = userSupply_ + uint256(newSupplyInterestFree_);\\n            } else {\\n                // if withdrawal is more than user's supply then solidity will throw here\\n                userSupply_ = userSupply_ - uint256(-newSupplyInterestFree_);\\n            }\\n        }\\n\\n        bool checkDecayExpansion_;\\n        if (amount_ < 0) {\\n            // withdrawal: check withdraw limit, take from decay if available, push down limit\\n            if (userSupply_ < withdrawLimitBefore_) {\\n                // if withdraw, then check the user supply after withdrawal is above withdrawal limit.\\n                // this check is in place also in case where decay is available as protocols do expect max withdrawable amount at once\\n                // is the fully expanded withdrawal limit (which == withdrawLimitBefore_ in case of decay at last tx)\\n                revert FluidLiquidityError(ErrorTypes.UserModule__WithdrawalLimitReached);\\n            }\\n\\n            if (decayAmount_ > 0) {\\n                // subtract from decaying amount in case of withdrawal. the resulting withdrawal limit after must be pushed down by\\n                // the amount of withdraw amount that is covered by available decay amount.\\n                // withdraw limit after can end up either (see calcWithdrawalLimitAfterOperate()):\\n                // - 0 if supply below base\\n                // - withdraw limit before\\n                // - max expansion if withdraw limit before is < max expansion (can only happen in case of push down from decay or new deposits)\\n                // so, reducing withdrawLimitBefore_ makes it end up either at pushed down target or at max expansion.\\n                unchecked {\\n                    uint256 withdrawAmount_ = uint256(-(newSupplyInterestRaw_ + newSupplyInterestFree_)); // only one of either can be set\\n                    if (withdrawAmount_ > decayAmount_) {\\n                        // withdrawal case A -> push down by full available decaying amount\\n                        withdrawLimitBefore_ = withdrawLimitBefore_ > decayAmount_\\n                            ? withdrawLimitBefore_ - decayAmount_\\n                            : 0;\\n                        decayAmount_ = 0;\\n                    } else {\\n                        // withdrawal case B -> push down by withdraw amount taken fully from decaying amount\\n                        withdrawLimitBefore_ = withdrawLimitBefore_ > withdrawAmount_\\n                            ? withdrawLimitBefore_ - withdrawAmount_\\n                            : 0;\\n                        decayAmount_ = decayAmount_ - withdrawAmount_;\\n                    }\\n                }\\n\\n                // Note not full amount taken from decay might be reflected in pushed down limit because of max expansion being hit\\n                //  -> handled below Ref #43681765878\\n                checkDecayExpansion_ = true;\\n            }\\n        }\\n\\n        // calculate withdrawal limit to store as previous withdrawal limit in storage\\n        uint256 withdrawLimitAfter_ = LiquidityCalcs.calcWithdrawalLimitAfterOperate(\\n            userSupplyData_,\\n            userSupply_,\\n            withdrawLimitBefore_\\n        );\\n\\n        if (withdrawLimitAfter_ == 0) {\\n            // if after limit is 0 -> no decay needed (below base limit anyway full withdrawal possible)\\n            decayAmount_ = 0;\\n        } else {\\n            // limit after can only ever become 0, == before or > before. see calcWithdrawalLimitAfterOperate().\\n            // case 0 -> handled. case == -> nothing to do for deposit, target hit for decay withdrawal.\\n            if (withdrawLimitBefore_ != withdrawLimitAfter_) {\\n                if (amount_ > 0) {\\n                    // add new decaying amount in case of excess deposit\\n                    if (withdrawLimitBefore_ == 0) {\\n                        // special case: if before was 0 -> use base withdrawal limit as before reference\\n                        withdrawLimitBefore_ =\\n                            (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) &\\n                            X18;\\n                        withdrawLimitBefore_ =\\n                            (withdrawLimitBefore_ >> DEFAULT_EXPONENT_SIZE) <<\\n                            (withdrawLimitBefore_ & DEFAULT_EXPONENT_MASK);\\n\\n                        // in this case it is possible that after is < before! when user supply ends up slightly above base then expansion\\n                        // of the limit can reach below base withdrwal limit! Ref #412521521521\\n                    }\\n\\n                    if (withdrawLimitAfter_ > withdrawLimitBefore_) {\\n                        uint256 newDecayAmount_;\\n                        unchecked {\\n                            newDecayAmount_ = withdrawLimitAfter_ - withdrawLimitBefore_;\\n                        }\\n\\n                        // new decay duration depends on ratio of leftover decay vs new decay, to solve this case:\\n                        // current decay of 10M, 60% passed so 4M decay left. New excess deposit of 100k comes in. decay duration would restart\\n                        // for the whole amount of 4.1M, stretching out the decay. This could compound.\\n                        // With ratio duration instead:\\n                        // 4M : 0.1M, so current leftover decay duration of 40% should have a 40x bigger factor than the 100% for the new amount\\n                        // duration = (40% * 1 hour * 4M + 100% * 1 hour * 0.1M) / (4M + 0.1M) = 1492s = 24.87 minutes\\n\\n                        // decayDurationCPs_ here already is decay duration leftover (in checkpoints)\\n                        decayDurationCPs_ =\\n                            (decayDurationCPs_ * decayAmount_ + TOTAL_DECAY_CHECKPOINTS * newDecayAmount_) /\\n                            (decayAmount_ + newDecayAmount_); // new target decay duration. always <= TOTAL_DECAY_CHECKPOINTS. newDecayAmount_ can not be 0\\n\\n                        if (decayDurationCPs_ < MIN_DECAY_DURATION_CHECKPOINTS) {\\n                            // decay duration after a new deposit is always between at least 4m48s and max 1 hour\\n                            decayDurationCPs_ = MIN_DECAY_DURATION_CHECKPOINTS;\\n                        }\\n\\n                        decayAmount_ = decayAmount_ + newDecayAmount_;\\n                    } else {\\n                        // edge case because of base limit see above Ref #412521521521. no decay\\n                        decayAmount_ = 0;\\n                        decayDurationCPs_ = 0;\\n                    }\\n                } else if (checkDecayExpansion_) {\\n                    // Ref #43681765878 case of decay withdrawal: limit did not end up at target pushed down withdrawLimitBefore_.\\n                    uint256 notPushedDownAmount_;\\n                    unchecked {\\n                        notPushedDownAmount_ = withdrawLimitAfter_ > withdrawLimitBefore_\\n                            ? withdrawLimitAfter_ - withdrawLimitBefore_\\n                            : 0;\\n                    }\\n                    decayAmount_ = decayAmount_ + notPushedDownAmount_;\\n                }\\n            }\\n        }\\n\\n        if (decayAmount_ < 10) {\\n            decayAmount_ = 0;\\n            decayDurationCPs_ = 0;\\n        } else {\\n            decayAmount_ = decayAmount_.toBigNumber(\\n                DECAY_COEFFICIENT_SIZE,\\n                DEFAULT_EXPONENT_SIZE,\\n                BigMathMinified.ROUND_DOWN\\n            );\\n\\n            if (decayDurationCPs_ > TOTAL_DECAY_CHECKPOINTS) {\\n                decayDurationCPs_ = TOTAL_DECAY_CHECKPOINTS; // should not be possible but to be extra sure\\n            } else if (decayDurationCPs_ == 0) {\\n                decayDurationCPs_ = 1; // decay duration should at least always be minimum possible of 1 if decay amount exists (for checkpoints = 0.1% ~ 3.6 sec)\\n            }\\n        }\\n\\n        // Converting user's supply into BigNumber\\n        userSupply_ = userSupply_.toBigNumber(\\n            DEFAULT_COEFFICIENT_SIZE,\\n            DEFAULT_EXPONENT_SIZE,\\n            BigMathMinified.ROUND_DOWN\\n        );\\n        if (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64) == userSupply_) {\\n            // make sure that operate amount is not so small that it wouldn't affect storage update. if a difference\\n            // is present then rounding will be in the right direction to avoid any potential manipulation.\\n            revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountInsufficient);\\n        }\\n\\n        // Converting withdrawal limit into BigNumber\\n        withdrawLimitAfter_ = withdrawLimitAfter_.toBigNumber(\\n            DEFAULT_COEFFICIENT_SIZE,\\n            DEFAULT_EXPONENT_SIZE,\\n            BigMathMinified.ROUND_DOWN\\n        );\\n\\n        _userSupplyData[msg.sender][token_] =\\n            // mask to update bits 1-161 (supply amount, withdrawal limit, timestamp) and 218-253 (decay amount, decay duration percent)\\n            (userSupplyData_ & 0xC000000003FFFFFFFFFFFFFC0000000000000000000000000000000000000001) |\\n            (userSupply_ << LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) | // converted to BigNumber can not overflow\\n            (withdrawLimitAfter_ << LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) | // converted to BigNumber can not overflow\\n            (block.timestamp << LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) |\\n            (decayAmount_ << LiquiditySlotsLink.BITS_USER_SUPPLY_DECAY_AMOUNT) | // converted to BigNumber can not overflow\\n            (decayDurationCPs_ << LiquiditySlotsLink.BITS_USER_SUPPLY_DECAY_DURATION_CHECKPOINTS); // can not overflow as can never be > TOTAL_DECAY_CHECKPOINTS\\n    }\\n\\n    /// @dev borrow or payback for both with interest & interest free.\\n    /// positive `amount_` is borrow, negative `amount_` is payback.\\n    function _borrowOrPayback(\\n        address token_,\\n        int256 amount_,\\n        uint256 borrowExchangePrice_\\n    ) internal returns (int256 newBorrowInterestRaw_, int256 newBorrowInterestFree_) {\\n        uint256 userBorrowData_ = _userBorrowData[msg.sender][token_];\\n\\n        if (userBorrowData_ == 0) {\\n            revert FluidLiquidityError(ErrorTypes.UserModule__UserNotDefined);\\n        }\\n        if ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_IS_PAUSED) & 1 == 1) {\\n            revert FluidLiquidityError(ErrorTypes.UserModule__UserPaused);\\n        }\\n\\n        // extract user borrow amount\\n        uint256 userBorrow_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\\n        userBorrow_ = (userBorrow_ >> DEFAULT_EXPONENT_SIZE) << (userBorrow_ & DEFAULT_EXPONENT_MASK);\\n\\n        // calculate current, updated (expanded etc.) borrow limit\\n        uint256 newBorrowLimit_ = LiquidityCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, userBorrow_);\\n\\n        // calculate updated user borrow amount\\n        if (userBorrowData_ & 1 == 1) {\\n            // with interest\\n            if (amount_ > 0) {\\n                // convert amount normal to raw (divide by exchange price) -> round up for borrow\\n                newBorrowInterestRaw_ = int256(\\n                    FixedPointMathLib.mulDivUp(uint256(amount_), EXCHANGE_PRICES_PRECISION, borrowExchangePrice_)\\n                );\\n                userBorrow_ = userBorrow_ + uint256(newBorrowInterestRaw_);\\n            } else {\\n                // convert amount from normal to raw (divide by exchange price) -> round down for payback\\n                newBorrowInterestRaw_ = (amount_ * int256(EXCHANGE_PRICES_PRECISION)) / int256(borrowExchangePrice_);\\n                userBorrow_ = userBorrow_ - uint256(-newBorrowInterestRaw_);\\n            }\\n        } else {\\n            // without interest\\n            newBorrowInterestFree_ = amount_;\\n            if (newBorrowInterestFree_ > 0) {\\n                // borrowing\\n                userBorrow_ = userBorrow_ + uint256(newBorrowInterestFree_);\\n            } else {\\n                // payback\\n                userBorrow_ = userBorrow_ - uint256(-newBorrowInterestFree_);\\n            }\\n        }\\n\\n        if (amount_ > 0 && userBorrow_ > newBorrowLimit_) {\\n            // if borrow, then check the user borrow amount after borrowing is below borrow limit\\n            revert FluidLiquidityError(ErrorTypes.UserModule__BorrowLimitReached);\\n        }\\n\\n        // calculate borrow limit to store as previous borrow limit in storage\\n        newBorrowLimit_ = LiquidityCalcs.calcBorrowLimitAfterOperate(userBorrowData_, userBorrow_, newBorrowLimit_);\\n\\n        // Converting user's borrowings into bignumber\\n        userBorrow_ = userBorrow_.toBigNumber(\\n            DEFAULT_COEFFICIENT_SIZE,\\n            DEFAULT_EXPONENT_SIZE,\\n            BigMathMinified.ROUND_UP\\n        );\\n\\n        if (((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64) == userBorrow_) {\\n            // make sure that operate amount is not so small that it wouldn't affect storage update. if a difference\\n            // is present then rounding will be in the right direction to avoid any potential manipulation.\\n            revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountInsufficient);\\n        }\\n\\n        // Converting borrow limit into bignumber\\n        newBorrowLimit_ = newBorrowLimit_.toBigNumber(\\n            DEFAULT_COEFFICIENT_SIZE,\\n            DEFAULT_EXPONENT_SIZE,\\n            BigMathMinified.ROUND_DOWN\\n        );\\n\\n        // Updating on storage\\n        _userBorrowData[msg.sender][token_] =\\n            // mask to update bits 1-161 (borrow amount, borrow limit, timestamp)\\n            (userBorrowData_ & 0xfffffffffffffffffffffffc0000000000000000000000000000000000000001) |\\n            (userBorrow_ << LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) | // converted to BigNumber can not overflow\\n            (newBorrowLimit_ << LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) | // converted to BigNumber can not overflow\\n            (block.timestamp << LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP);\\n    }\\n\\n    /// @dev checks if `supplyAmount_` & `borrowAmount_` amounts transfers can be skipped (DEX-protocol use-case).\\n    /// -   Requirements:\\n    /// -  ` callbackData_` MUST be > 63 bytes and encoded so that \\\"from\\\" address is the last 20 bytes in the last 32 bytes slot,\\n    ///     also for native token operations where liquidityCallback is not triggered!\\n    ///     from address must come at last position if there is more data. I.e. encode like:\\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\\n    /// -   this \\\"from\\\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\\n    ///     in the slot before (bytes 32 to 63)\\n    /// -   `msg.value` must be 0.\\n    /// -   Amounts must be either:\\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\\n    function _isInOutBalancedOut(\\n        int256 supplyAmount_,\\n        int256 borrowAmount_,\\n        address withdrawTo_,\\n        address borrowTo_,\\n        bytes memory callbackData_\\n    ) internal view returns (bool) {\\n        // callbackData_ being at least > 63 in length is already verified before calling this method.\\n\\n        // 1. SKIP_TRANSFERS must be set in callbackData_ 32 bytes before last 32 bytes\\n        bytes32 skipTransfers_;\\n        assembly {\\n            skipTransfers_ := mload(\\n                add(\\n                    // add padding for length as present for dynamic arrays in memory\\n                    add(callbackData_, 32),\\n                    // Load from memory offset of 2 slots (64 bytes): 1 slot: bytes32 skipTransfers_ + 2 slot: address inFrom_\\n                    sub(mload(callbackData_), 64)\\n                )\\n            )\\n        }\\n        if (skipTransfers_ != SKIP_TRANSFERS) {\\n            return false;\\n        }\\n        // after here, if invalid, protocol intended to skip transfers, but something is invalid. so we don't just\\n        // NOT skip transfers, we actually revert because there must be something wrong on protocol side.\\n\\n        // 2. amounts must be\\n        // a) equal: supply(+) == borrow(+), withdraw(-) == payback(-) OR\\n        // b) Liquidity must be on the winning side.\\n        // EITHER:\\n        // deposit and borrow, both positive. there must be more borrow than deposit.\\n        // so supply amount must be less, e.g. 80 deposit and 100 borrow.\\n        // OR:\\n        // withdraw and payback, both negative. there must be more withdraw than payback.\\n        // so supplyAmount must be less (e.g. -100 withdraw and -80 payback )\\n        if (\\n            msg.value != 0 || // no msg.value should be sent along when trying to skip transfers.\\n            supplyAmount_ == 0 ||\\n            borrowAmount_ == 0 || // it must be a 2 actions operation, not just e.g. only deposit or only payback.\\n            supplyAmount_ > borrowAmount_ // allow case a) and b): supplyAmount must be <=\\n        ) {\\n            revert FluidLiquidityError(ErrorTypes.UserModule__SkipTransfersInvalid);\\n        }\\n\\n        // 3. inFrom_ must be in last 32 bytes and must match receiver\\n        address inFrom_;\\n        assembly {\\n            inFrom_ := mload(\\n                add(\\n                    // add padding for length as present for dynamic arrays in memory\\n                    add(callbackData_, 32),\\n                    // assembly expects address with leading zeros / left padded so need to use 32 as length here\\n                    sub(mload(callbackData_), 32)\\n                )\\n            )\\n        }\\n\\n        if (supplyAmount_ > 0) {\\n            // deposit and borrow\\n            if (!(inFrom_ == borrowTo_ && inFrom_ == msg.sender)) {\\n                revert FluidLiquidityError(ErrorTypes.UserModule__SkipTransfersInvalid);\\n            }\\n        } else {\\n            // withdraw and payback\\n            if (!(inFrom_ == withdrawTo_ && inFrom_ == msg.sender)) {\\n                revert FluidLiquidityError(ErrorTypes.UserModule__SkipTransfersInvalid);\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @dev checks if net transfers should be done only (DEX-protocol use-case).\\n    /// -   Requirements:\\n    /// -  ` callbackData_` MUST be > 63 bytes and encoded so that \\\"from\\\" address is the last 20 bytes in the last 32 bytes slot,\\n    ///     also for native token operations where liquidityCallback is not triggered!\\n    ///     from address must come at last position if there is more data. I.e. encode like:\\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\\n    /// -   this \\\"from\\\" address must match withdrawTo_ or borrowTo_ in case of net transfer out\\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 NET_TRANSFERS\\n    ///     in the slot before (second last slot)\\n    /// -   Amounts must be so that it's a 2 action operation, with some input and some output\\n    function _isNetTransfers(\\n        int256 supplyAmount_,\\n        int256 borrowAmount_,\\n        address withdrawTo_,\\n        address borrowTo_,\\n        bytes memory callbackData_\\n    ) internal pure returns (bool isNetTransfers_, uint256 operateAmountOut_) {\\n        // 1. NET_TRANSFERS must be set in callbackData_ as the second-to-last 32-byte word\\n        bytes32 netTransfers_;\\n        assembly {\\n            netTransfers_ := mload(\\n                add(\\n                    // add padding for length as present for dynamic arrays in memory\\n                    add(callbackData_, 32),\\n                    // Load from memory offset of 2 slots (64 bytes): 1 slot: bytes32 netTransfers_ + 2 slot: address inFrom_\\n                    sub(mload(callbackData_), 64)\\n                )\\n            )\\n        }\\n        if (netTransfers_ != NET_TRANSFERS) {\\n            return (false, 0);\\n        }\\n\\n        // memVar_ => operateAmountOut: borrow + withdraw\\n        operateAmountOut_ =\\n            uint256((borrowAmount_ > 0 ? borrowAmount_ : int256(0))) +\\n            uint256((supplyAmount_ < 0 ? -supplyAmount_ : int256(0)));\\n\\n        if (\\n            // it must be a 2 actions operation, not just e.g. only deposit or only payback.\\n            supplyAmount_ == 0 ||\\n            borrowAmount_ == 0 ||\\n            // must not be deposit and payback or withdraw and borrow (some in, some out)\\n            // The ^ operator is the bitwise XOR in Solidity. For signed integers, (supplyAmount_ ^ borrowAmount_) < 0 checks  if the\\n            // two values have opposite signs (one positive, one negative), because XORing numbers with different signs sets the sign bit.\\n            // i.e. equivalent to (supplyAmount_ > 0 && borrowAmount_ < 0) || (supplyAmount_ < 0 && borrowAmount_ > 0)\\n            (supplyAmount_ ^ borrowAmount_) < 0\\n        ) {\\n            revert FluidLiquidityError(ErrorTypes.UserModule__NetTransfersInvalid);\\n        }\\n\\n        // inFrom_ must be in last 32 bytes and must match receiver, and only either withdrawTo_ or borrowTo_ must be set, but not both\\n        address inFrom_;\\n        assembly {\\n            inFrom_ := mload(\\n                add(\\n                    // add padding for length as present for dynamic arrays in memory\\n                    add(callbackData_, 32),\\n                    // assembly expects address with leading zeros / left padded so need to use 32 as length here\\n                    sub(mload(callbackData_), 32)\\n                )\\n            )\\n        }\\n\\n        if (supplyAmount_ < 0) {\\n            if (inFrom_ != withdrawTo_ || borrowTo_ != address(0)) {\\n                revert FluidLiquidityError(ErrorTypes.UserModule__NetTransfersInvalid);\\n            }\\n        } else if (borrowAmount_ > 0) {\\n            if (inFrom_ != borrowTo_ || withdrawTo_ != address(0)) {\\n                revert FluidLiquidityError(ErrorTypes.UserModule__NetTransfersInvalid);\\n            }\\n        }\\n\\n        return (true, operateAmountOut_);\\n    }\\n\\n    /// @notice Checks and enforces the total input amount for a protocol callback.\\n    /// @dev Supports legacy DexV1 and new protocols (e.g., DexV2) by decoding callbackData accordingly.\\n    /// @param expectedInputAmount_ The expected input amount to be enforced.\\n    /// @param callbackData_ The callback data containing protocol-specific input information.\\n    /// @return The validated or updated input amount to be used.\\n    function _checkEnforceTotalInputAmount(\\n        uint256 expectedInputAmount_,\\n        bytes memory callbackData_\\n    ) internal pure returns (uint256) {\\n        // of all live protocols until Sep 2025, only DexV1 fulfills this case.\\n        // all new protocols after that time implement sending PROTOCOL, ACTION bytes32 in the first 2 slots of callbackData_\\n        bytes32 firstSlotBytes32_;\\n        assembly {\\n            // Read the first 32 bytes after the array length (i.e., the first word of data)\\n            firstSlotBytes32_ := mload(add(callbackData_, 32))\\n        }\\n        uint256 slotUint_ = uint256(firstSlotBytes32_);\\n        // Check if first slot value as uint is within +1% of expected input amount\\n        if (\\n            slotUint_ < expectedInputAmount_ ||\\n            slotUint_ > (expectedInputAmount_ * (FOUR_DECIMALS + MAX_INPUT_AMOUNT_EXCESS)) / FOUR_DECIMALS\\n        ) {\\n            // first slot must be bytes32. e.g. bytes32 keccak hash for \\\"DEXV2\\\" is d118e12c537365aadb8862ad8af2972cc5a1400f6c9f46f35f384925ff0a4db6\\n            // so there is ~no way this gets hit by chance to be within 1% of any realistic input amount\\n            if (firstSlotBytes32_ == DEXV2_IDENTIFIER) {\\n                // enforce the amount to send should be incl. revenue fee\\n                // DexV2 sends this structure as callbackData:\\n                // bytes32 PROTOCOL, bytes32 ACTION, uint amountToSend_, ...others\\n                // Read the third 32-byte word (slot 3) from callbackData_ and assign as uint to expectedInputAmount_\\n                assembly {\\n                    slotUint_ := mload(add(callbackData_, 96))\\n                }\\n                // make sure the value to enforce is within +1% of the current expected input amount\\n                if (\\n                    slotUint_ < expectedInputAmount_ ||\\n                    slotUint_ > (expectedInputAmount_ * (FOUR_DECIMALS + MAX_INPUT_AMOUNT_EXCESS)) / FOUR_DECIMALS\\n                ) {\\n                    revert FluidLiquidityError(ErrorTypes.UserModule__TransferAmountOutOfBounds);\\n                }\\n                expectedInputAmount_ = slotUint_;\\n            }\\n            // else -> for all other protocols enforce only the default input amount\\n        } else {\\n            // first slot is an uint and callbackData length >= 96, can only be DexV1. enforce the amount to send should be incl. revenue fee\\n            // DexV1 sends this structure: `(uint amountToSend_, bool isCallback_, address from_) = abi.decode(data_, (uint, bool, address));`\\n            expectedInputAmount_ = slotUint_;\\n        }\\n\\n        return expectedInputAmount_;\\n    }\\n\\n    /// @dev checks `newOperateAmount_` to be within an acceptable valid ratio compared to `existingTotalAmount_`\\n    ///      serves as additional input validation and operate effects check.\\n    function _checkMaxOperateAmountRatio(\\n        uint256 newOperateAmount_,\\n        uint256 existingTotalAmount_,\\n        bool isDepositBorrow_\\n    ) internal pure {\\n        unchecked {\\n            // existingTotalAmount_ -> existingTotalAmount_ adjusted with max ratio\\n            existingTotalAmount_ = isDepositBorrow_\\n                ? (MAX_NEW_VS_EXISTING_TOTAL_AMOUNT_RATIO_DEPOSIT_BORROW * existingTotalAmount_)\\n                : existingTotalAmount_ / MAX_NEW_VS_EXISTING_TOTAL_AMOUNT_RATIO_WITHDRAW_PAYBACK;\\n            if (newOperateAmount_ > MAX_NEW_AMOUNT_WHEN_RATIO_CHECK && newOperateAmount_ > existingTotalAmount_) {\\n                revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountRatioExcess);\\n            }\\n        }\\n    }\\n}\\n\\n/// @title  Fluid Liquidity UserModule\\n/// @notice Fluid Liquidity public facing endpoint logic contract that implements the `operate()` method.\\n///         operate can be used to deposit, withdraw, borrow & payback funds, given that they have the necessary\\n///         user config allowance. Interacting users must be allowed via the Fluid Liquidity AdminModule first.\\n///         Intended users are thus allow-listed protocols, e.g. the Lending protocol (fTokens), Vault protocol etc.\\n/// @dev For view methods / accessing data, use the \\\"LiquidityResolver\\\" periphery contract.\\nabstract contract FluidLiquidityUserModule is CoreInternals {\\n    using BigMathMinified for uint256;\\n\\n    /// @dev struct for vars used in operate() that would otherwise cause a Stack too deep error\\n    struct OperateMemoryVars {\\n        int256 netTransfersOut; // when 0 -> normal flow, when -1 -> skip out transfers, when > 0 -> only do net transfer out flow\\n        uint256 supplyExchangePrice;\\n        uint256 borrowExchangePrice;\\n        uint256 supplyRawInterest;\\n        uint256 supplyInterestFree;\\n        uint256 borrowRawInterest;\\n        uint256 borrowInterestFree;\\n        uint256 totalAmounts;\\n        uint256 exchangePricesAndConfig;\\n    }\\n\\n    /// @notice inheritdoc IFluidLiquidity\\n    function operate(\\n        address token_,\\n        int256 supplyAmount_,\\n        int256 borrowAmount_,\\n        address withdrawTo_,\\n        address borrowTo_,\\n        bytes calldata callbackData_\\n    ) external payable reentrancy returns (uint256 memVar3_, uint256 memVar4_) {\\n        if (supplyAmount_ == 0 && borrowAmount_ == 0) {\\n            revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountsZero);\\n        }\\n        if (\\n            supplyAmount_ < type(int128).min ||\\n            supplyAmount_ > type(int128).max ||\\n            borrowAmount_ < type(int128).min ||\\n            borrowAmount_ > type(int128).max\\n        ) {\\n            revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountOutOfBounds);\\n        }\\n        if ((supplyAmount_ < 0 && withdrawTo_ == address(0)) || (borrowAmount_ > 0 && borrowTo_ == address(0))) {\\n            revert FluidLiquidityError(ErrorTypes.UserModule__ReceiverNotDefined);\\n        }\\n        if (token_ != NATIVE_TOKEN_ADDRESS && msg.value > 0) {\\n            // revert: there should not be msg.value if the token is not the native token\\n            revert FluidLiquidityError(ErrorTypes.UserModule__MsgValueForNonNativeToken);\\n        }\\n\\n        OperateMemoryVars memory o_;\\n\\n        // @dev temporary memory variables used as helper in between to avoid assigning new memory variables\\n        uint256 memVar_;\\n        // memVar2_ => operateAmountIn: deposit + payback\\n        uint256 memVar2_ = uint256((supplyAmount_ > 0 ? supplyAmount_ : int256(0))) +\\n            uint256((borrowAmount_ < 0 ? -borrowAmount_ : int256(0)));\\n\\n        memVar3_ = MAX_INPUT_AMOUNT_EXCESS; // max input amount excess gets adjusted * 1000 for net transfers in\\n        if (callbackData_.length > 63) {\\n            // check if token transfers can be skipped. see `_isInOutBalancedOut` for details.\\n            if (_isInOutBalancedOut(supplyAmount_, borrowAmount_, withdrawTo_, borrowTo_, callbackData_)) {\\n                memVar2_ = 0; // set to 0 to skip transfers IN\\n                o_.netTransfersOut = SKIP_TRANSFER_OUT_BELOW_VALUE_SIGNAL; // set to -1 to skip transfers OUT\\n            }\\n\\n            bool isNetTransfers_;\\n            // check if token transfers can be done only for net amounts. see `_isNetTransfers` for details.\\n            (isNetTransfers_, memVar_) = _isNetTransfers(\\n                supplyAmount_,\\n                borrowAmount_,\\n                withdrawTo_,\\n                borrowTo_,\\n                callbackData_\\n            );\\n            if (isNetTransfers_) {\\n                unchecked {\\n                    if (memVar_ == memVar2_) {\\n                        // should use SKIP transfers instead\\n                        revert FluidLiquidityError(ErrorTypes.UserModule__NetTransfersInvalid);\\n                    } else if (memVar2_ > memVar_) {\\n                        // net transfer in\\n                        // total in - total out\\n                        memVar2_ = memVar2_ - memVar_;\\n                        o_.netTransfersOut = SKIP_TRANSFER_OUT_BELOW_VALUE_SIGNAL; // set to -1 to skip transfers OUT\\n                        memVar3_ = memVar3_ * 1e3;\\n                    } else {\\n                        // total out - total in\\n                        o_.netTransfersOut = int256(memVar_ - memVar2_);\\n                        // net transfer out\\n                        memVar2_ = 0; // set to 0 to skip transfers IN\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (token_ == NATIVE_TOKEN_ADDRESS) {\\n            unchecked {\\n                // check supply and payback amount is covered by available sent msg.value and\\n                // protection that msg.value is not unintentionally way more than actually used in operate()\\n                if (memVar2_ > msg.value || msg.value > (memVar2_ * (FOUR_DECIMALS + memVar3_)) / FOUR_DECIMALS) {\\n                    revert FluidLiquidityError(ErrorTypes.UserModule__TransferAmountOutOfBounds);\\n                }\\n            }\\n            memVar2_ = 0; // set to 0 to skip transfers IN more gas efficient. No need for native token.\\n        }\\n        // if supply or payback or both -> transfer token amount from sender to here.\\n        // for native token this is already covered by msg.value checks in operate(). memVar2_ is set to 0\\n        // for same amounts in same operate(): supply(+) == borrow(+), withdraw(-) == payback(-). memVar2_ is set to 0\\n        if (memVar2_ > 0) {\\n            if (callbackData_.length > 95) {\\n                // check enforce total input amount with revenue for dexV1 and dexV2\\n                memVar2_ = _checkEnforceTotalInputAmount(memVar2_, callbackData_);\\n            }\\n\\n            // memVar_ => initial token balance of this contract\\n            memVar_ = IERC20(token_).balanceOf(address(this));\\n            // trigger protocol to send token amount and pass callback data\\n            IProtocol(msg.sender).liquidityCallback(token_, memVar2_, callbackData_);\\n            // memVar_ => current token balance of this contract - initial balance\\n            memVar_ = IERC20(token_).balanceOf(address(this)) - memVar_;\\n            unchecked {\\n                if (memVar_ < memVar2_ || memVar_ > (memVar2_ * (FOUR_DECIMALS + memVar3_)) / FOUR_DECIMALS) {\\n                    // revert if protocol did not send enough to cover supply / payback\\n                    // or if protocol sent more than expected, with 1% tolerance for any potential rounding issues (and for DEX revenue cut)\\n                    revert FluidLiquidityError(ErrorTypes.UserModule__TransferAmountOutOfBounds);\\n                }\\n            }\\n\\n            _afterTransferIn(token_, memVar_);\\n        }\\n\\n        o_.exchangePricesAndConfig = _exchangePricesAndConfig[token_];\\n\\n        // calculate updated exchange prices\\n        (o_.supplyExchangePrice, o_.borrowExchangePrice) = LiquidityCalcs.calcExchangePrices(\\n            o_.exchangePricesAndConfig\\n        );\\n\\n        // Extract total supply / borrow amounts for the token\\n        o_.totalAmounts = _totalAmounts[token_];\\n        memVar_ = o_.totalAmounts & X64;\\n        o_.supplyRawInterest = (memVar_ >> DEFAULT_EXPONENT_SIZE) << (memVar_ & DEFAULT_EXPONENT_MASK);\\n        memVar_ = (o_.totalAmounts >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\\n        o_.supplyInterestFree = (memVar_ >> DEFAULT_EXPONENT_SIZE) << (memVar_ & DEFAULT_EXPONENT_MASK);\\n        memVar_ = (o_.totalAmounts >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\\n        o_.borrowRawInterest = (memVar_ >> DEFAULT_EXPONENT_SIZE) << (memVar_ & DEFAULT_EXPONENT_MASK);\\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\\n        memVar_ = (o_.totalAmounts >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\\n        o_.borrowInterestFree = (memVar_ >> DEFAULT_EXPONENT_SIZE) << (memVar_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (supplyAmount_ != 0) {\\n            // execute supply or withdraw and update total amounts\\n            {\\n                uint256 totalAmountsBefore_ = o_.totalAmounts;\\n                (int256 newSupplyInterestRaw_, int256 newSupplyInterestFree_) = _supplyOrWithdraw(\\n                    token_,\\n                    supplyAmount_,\\n                    o_.supplyExchangePrice\\n                );\\n\\n                // update total amounts. this is done here so that values are only written to storage once\\n                // if a borrow / payback also happens in the same `operate()` call\\n                if (newSupplyInterestFree_ == 0) {\\n                    // Note newSupplyInterestFree_ can ONLY be 0 if mode is with interest,\\n                    // easy to check as that variable is NOT the result of a dvision etc.\\n                    // supply or withdraw with interest -> raw amount\\n                    if (newSupplyInterestRaw_ > 0) {\\n                        _checkMaxOperateAmountRatio(uint256(newSupplyInterestRaw_), o_.supplyRawInterest, true);\\n                        o_.supplyRawInterest += uint256(newSupplyInterestRaw_);\\n                    } else {\\n                        _checkMaxOperateAmountRatio(uint256(-newSupplyInterestRaw_), o_.supplyRawInterest, false);\\n                        unchecked {\\n                            o_.supplyRawInterest = o_.supplyRawInterest > uint256(-newSupplyInterestRaw_)\\n                                ? o_.supplyRawInterest - uint256(-newSupplyInterestRaw_)\\n                                : 0; // withdraw amount is > total supply -> withdraw total supply down to 0\\n                            // Note no risk here as if the user withdraws more than supplied it would revert already\\n                            // earlier. Total amounts can end up < sum of user amounts because of rounding\\n                        }\\n                    }\\n\\n                    // Note check for revert {UserModule}__ValueOverflow__TOTAL_SUPPLY is further down when we anyway\\n                    // calculate the normal amount from raw\\n\\n                    // Converting the updated total amount into big number for storage\\n                    memVar_ = o_.supplyRawInterest.toBigNumber(\\n                        DEFAULT_COEFFICIENT_SIZE,\\n                        DEFAULT_EXPONENT_SIZE,\\n                        BigMathMinified.ROUND_DOWN\\n                    );\\n                    // update total supply with interest at total amounts in storage (only update changed values)\\n                    o_.totalAmounts =\\n                        // mask to update bits 0-63\\n                        (o_.totalAmounts & 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000) |\\n                        memVar_; // converted to BigNumber can not overflow\\n                } else {\\n                    // supply or withdraw interest free -> normal amount\\n                    if (newSupplyInterestFree_ > 0) {\\n                        _checkMaxOperateAmountRatio(uint256(newSupplyInterestFree_), o_.supplyInterestFree, true);\\n                        o_.supplyInterestFree += uint256(newSupplyInterestFree_);\\n                    } else {\\n                        _checkMaxOperateAmountRatio(uint256(-newSupplyInterestFree_), o_.supplyInterestFree, false);\\n                        unchecked {\\n                            o_.supplyInterestFree = o_.supplyInterestFree > uint256(-newSupplyInterestFree_)\\n                                ? o_.supplyInterestFree - uint256(-newSupplyInterestFree_)\\n                                : 0; // withdraw amount is > total supply -> withdraw total supply down to 0\\n                            // Note no risk here as if the user withdraws more than supplied it would revert already\\n                            // earlier. Total amounts can end up < sum of user amounts because of rounding\\n                        }\\n                    }\\n                    if (o_.supplyInterestFree > MAX_TOKEN_AMOUNT_CAP) {\\n                        // only withdrawals allowed if total supply interest free reaches MAX_TOKEN_AMOUNT_CAP\\n                        revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__TOTAL_SUPPLY);\\n                    }\\n                    // Converting the updated total amount into big number for storage\\n                    memVar_ = o_.supplyInterestFree.toBigNumber(\\n                        DEFAULT_COEFFICIENT_SIZE,\\n                        DEFAULT_EXPONENT_SIZE,\\n                        BigMathMinified.ROUND_DOWN\\n                    );\\n                    // update total supply interest free at total amounts in storage (only update changed values)\\n                    o_.totalAmounts =\\n                        // mask to update bits 64-127\\n                        (o_.totalAmounts & 0xffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff) |\\n                        (memVar_ << LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE); // converted to BigNumber can not overflow\\n                }\\n                if (totalAmountsBefore_ == o_.totalAmounts) {\\n                    // make sure that operate amount is not so small that it wouldn't affect storage update. if a difference\\n                    // is present then rounding will be in the right direction to avoid any potential manipulation.\\n                    revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountInsufficient);\\n                }\\n            }\\n        }\\n        if (borrowAmount_ != 0) {\\n            // execute borrow or payback and update total amounts\\n            {\\n                uint256 totalAmountsBefore_ = o_.totalAmounts;\\n                (int256 newBorrowInterestRaw_, int256 newBorrowInterestFree_) = _borrowOrPayback(\\n                    token_,\\n                    borrowAmount_,\\n                    o_.borrowExchangePrice\\n                );\\n                // update total amounts. this is done here so that values are only written to storage once\\n                // if a supply / withdraw also happens in the same `operate()` call\\n                if (newBorrowInterestFree_ == 0) {\\n                    // Note newBorrowInterestFree_ can ONLY be 0 if mode is with interest,\\n                    // easy to check as that variable is NOT the result of a dvision etc.\\n                    // borrow or payback with interest -> raw amount\\n                    if (newBorrowInterestRaw_ > 0) {\\n                        _checkMaxOperateAmountRatio(uint256(newBorrowInterestRaw_), o_.borrowRawInterest, true);\\n                        o_.borrowRawInterest += uint256(newBorrowInterestRaw_);\\n                    } else {\\n                        _checkMaxOperateAmountRatio(uint256(-newBorrowInterestRaw_), o_.borrowRawInterest, false);\\n                        unchecked {\\n                            o_.borrowRawInterest = o_.borrowRawInterest > uint256(-newBorrowInterestRaw_)\\n                                ? o_.borrowRawInterest - uint256(-newBorrowInterestRaw_)\\n                                : 0; // payback amount is > total borrow -> payback total borrow down to 0\\n                        }\\n                    }\\n\\n                    // Note check for revert UserModule__ValueOverflow__TOTAL_BORROW is further down when we anyway\\n                    // calculate the normal amount from raw\\n\\n                    // Converting the updated total amount into big number for storage\\n                    memVar_ = o_.borrowRawInterest.toBigNumber(\\n                        DEFAULT_COEFFICIENT_SIZE,\\n                        DEFAULT_EXPONENT_SIZE,\\n                        BigMathMinified.ROUND_UP\\n                    );\\n                    // update total borrow with interest at total amounts in storage (only update changed values)\\n                    o_.totalAmounts =\\n                        // mask to update bits 128-191\\n                        (o_.totalAmounts & 0xffffffffffffffff0000000000000000ffffffffffffffffffffffffffffffff) |\\n                        (memVar_ << LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST); // converted to BigNumber can not overflow\\n                } else {\\n                    // borrow or payback interest free -> normal amount\\n                    if (newBorrowInterestFree_ > 0) {\\n                        _checkMaxOperateAmountRatio(uint256(newBorrowInterestFree_), o_.borrowInterestFree, true);\\n                        o_.borrowInterestFree += uint256(newBorrowInterestFree_);\\n                    } else {\\n                        _checkMaxOperateAmountRatio(uint256(-newBorrowInterestFree_), o_.borrowInterestFree, false);\\n                        unchecked {\\n                            o_.borrowInterestFree = o_.borrowInterestFree > uint256(-newBorrowInterestFree_)\\n                                ? o_.borrowInterestFree - uint256(-newBorrowInterestFree_)\\n                                : 0; // payback amount is > total borrow -> payback total borrow down to 0\\n                        }\\n                    }\\n                    if (o_.borrowInterestFree > MAX_TOKEN_AMOUNT_CAP) {\\n                        // only payback allowed if total borrow interest free reaches MAX_TOKEN_AMOUNT_CAP\\n                        revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__TOTAL_BORROW);\\n                    }\\n                    // Converting the updated total amount into big number for storage\\n                    memVar_ = o_.borrowInterestFree.toBigNumber(\\n                        DEFAULT_COEFFICIENT_SIZE,\\n                        DEFAULT_EXPONENT_SIZE,\\n                        BigMathMinified.ROUND_UP\\n                    );\\n                    // update total borrow interest free at total amounts in storage (only update changed values)\\n                    o_.totalAmounts =\\n                        // mask to update bits 192-255\\n                        (o_.totalAmounts & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff) |\\n                        (memVar_ << LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE); // converted to BigNumber can not overflow\\n                }\\n                if (totalAmountsBefore_ == o_.totalAmounts) {\\n                    // make sure that operate amount is not so small that it wouldn't affect storage update. if a difference\\n                    // is present then rounding will be in the right direction to avoid any potential manipulation.\\n                    revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountInsufficient);\\n                }\\n            }\\n        }\\n        // Updating total amounts on storage\\n        _totalAmounts[token_] = o_.totalAmounts;\\n        {\\n            // update exchange prices / utilization / ratios\\n            // exchangePricesAndConfig is only written to storage if either utilization, supplyRatio or borrowRatio\\n            // change is above the required storageUpdateThreshold config value or if the last write was > 1 day ago.\\n\\n            // 1. calculate new supply ratio, borrow ratio & utilization.\\n            // 2. check if last storage write was > 1 day ago.\\n            // 3. If false -> check if utilization is above update threshold\\n            // 4. If false -> check if supply ratio is above update threshold\\n            // 5. If false -> check if borrow ratio is above update threshold\\n            // 6. If any true, then update on storage\\n\\n            // ########## calculating supply ratio ##########\\n            // supplyWithInterest in normal amount\\n            memVar3_ = ((o_.supplyRawInterest * o_.supplyExchangePrice) / EXCHANGE_PRICES_PRECISION);\\n            if (memVar3_ > MAX_TOKEN_AMOUNT_CAP && supplyAmount_ > 0) {\\n                // only withdrawals allowed if total supply raw reaches MAX_TOKEN_AMOUNT_CAP\\n                revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__TOTAL_SUPPLY);\\n            }\\n            // memVar_ => total supply. set here so supplyWithInterest (memVar3_) is only calculated once. For utilization\\n            memVar_ = o_.supplyInterestFree + memVar3_;\\n            if (memVar3_ > o_.supplyInterestFree) {\\n                // memVar3_ is ratio with 1 bit as 0 as supply interest raw is bigger\\n                memVar3_ = ((o_.supplyInterestFree * FOUR_DECIMALS) / memVar3_) << 1;\\n                // because of checking to divide by bigger amount, ratio can never be > 100%\\n            } else if (memVar3_ < o_.supplyInterestFree) {\\n                // memVar3_ is ratio with 1 bit as 1 as supply interest free is bigger\\n                memVar3_ = (((memVar3_ * FOUR_DECIMALS) / o_.supplyInterestFree) << 1) | 1;\\n                // because of checking to divide by bigger amount, ratio can never be > 100%\\n            } else if (memVar_ > 0) {\\n                // supplies match exactly (memVar3_  == o_.supplyInterestFree) and total supplies are not 0\\n                // -> set ratio to 1 (with first bit set to 0, doesn't matter)\\n                memVar3_ = FOUR_DECIMALS << 1;\\n            } // else if total supply = 0, memVar3_ (supplyRatio) is already 0.\\n\\n            // ########## calculating borrow ratio ##########\\n            // borrowWithInterest in normal amount\\n            memVar4_ = ((o_.borrowRawInterest * o_.borrowExchangePrice) / EXCHANGE_PRICES_PRECISION);\\n            if (memVar4_ > MAX_TOKEN_AMOUNT_CAP && borrowAmount_ > 0) {\\n                // only payback allowed if total borrow raw reaches MAX_TOKEN_AMOUNT_CAP\\n                revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__TOTAL_BORROW);\\n            }\\n            // memVar2_ => total borrow. set here so borrowWithInterest (memVar4_) is only calculated once. For utilization\\n            memVar2_ = o_.borrowInterestFree + memVar4_;\\n            if (memVar4_ > o_.borrowInterestFree) {\\n                // memVar4_ is ratio with 1 bit as 0 as borrow interest raw is bigger\\n                memVar4_ = ((o_.borrowInterestFree * FOUR_DECIMALS) / memVar4_) << 1;\\n                // because of checking to divide by bigger amount, ratio can never be > 100%\\n            } else if (memVar4_ < o_.borrowInterestFree) {\\n                // memVar4_ is ratio with 1 bit as 1 as borrow interest free is bigger\\n                memVar4_ = (((memVar4_ * FOUR_DECIMALS) / o_.borrowInterestFree) << 1) | 1;\\n                // because of checking to divide by bigger amount, ratio can never be > 100%\\n            } else if (memVar2_ > 0) {\\n                // borrows match exactly (memVar4_  == o_.borrowInterestFree) and total borrows are not 0\\n                // -> set ratio to 1 (with first bit set to 0, doesn't matter)\\n                memVar4_ = FOUR_DECIMALS << 1;\\n            } // else if total borrow = 0, memVar4_ (borrowRatio) is already 0.\\n\\n            // calculate utilization. If there is no supply, utilization must be 0 (avoid division by 0)\\n            uint256 utilization_;\\n            if (memVar_ > 0) {\\n                utilization_ = ((memVar2_ * FOUR_DECIMALS) / memVar_);\\n\\n                // for borrow operations, ensure max utilization is not reached\\n                if (borrowAmount_ > 0) {\\n                    // memVar_ => max utilization\\n                    // if any max utilization other than 100% is set, the flag usesConfigs2 in\\n                    // exchangePricesAndConfig is 1. (optimized to avoid SLOAD if not needed).\\n                    memVar_ = (o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_USES_CONFIGS2) &\\n                        1 ==\\n                        1\\n                        ? (_configs2[token_] & X14) // read configured max utilization\\n                        : FOUR_DECIMALS; // default max utilization = 100%\\n\\n                    if (utilization_ > memVar_) {\\n                        revert FluidLiquidityError(ErrorTypes.UserModule__MaxUtilizationReached);\\n                    }\\n                }\\n            }\\n\\n            // check if time difference is big enough (> 1 day)\\n            unchecked {\\n                if (\\n                    block.timestamp >\\n                    // extract last update timestamp + 1 day\\n                    (((o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33) +\\n                        FORCE_STORAGE_WRITE_AFTER_TIME)\\n                ) {\\n                    memVar_ = 1; // set write to storage flag\\n                } else {\\n                    memVar_ = 0;\\n                }\\n            }\\n\\n            if (memVar_ == 0) {\\n                // time difference is not big enough to cause storage write -> check utilization\\n\\n                // memVar_ => extract last utilization\\n                memVar_ = (o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14;\\n                // memVar2_ => storage update threshold in percent\\n                memVar2_ =\\n                    (o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD) &\\n                    X14;\\n                unchecked {\\n                    // set memVar_ to 1 if current utilization to previous utilization difference is > update storage threshold\\n                    memVar_ = (utilization_ > memVar_ ? utilization_ - memVar_ : memVar_ - utilization_) > memVar2_\\n                        ? 1\\n                        : 0;\\n                    if (memVar_ == 0) {\\n                        // utilization & time difference is not big enough -> check supplyRatio difference\\n                        // memVar_ => extract last supplyRatio\\n                        memVar_ =\\n                            (o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) &\\n                            X15;\\n                        // set memVar_ to 1 if current supplyRatio to previous supplyRatio difference is > update storage threshold\\n                        if ((memVar_ & 1) == (memVar3_ & 1)) {\\n                            memVar_ = memVar_ >> 1;\\n                            memVar_ = (\\n                                (memVar3_ >> 1) > memVar_ ? (memVar3_ >> 1) - memVar_ : memVar_ - (memVar3_ >> 1)\\n                            ) > memVar2_\\n                                ? 1\\n                                : 0; // memVar3_ = supplyRatio, memVar_ = previous supplyRatio, memVar2_ = update storage threshold\\n                        } else {\\n                            // if inverse bit is changing then always update on storage\\n                            memVar_ = 1;\\n                        }\\n                        if (memVar_ == 0) {\\n                            // utilization, time, and supplyRatio difference is not big enough -> check borrowRatio difference\\n                            // memVar_ => extract last borrowRatio\\n                            memVar_ =\\n                                (o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\\n                                X15;\\n                            // set memVar_ to 1 if current borrowRatio to previous borrowRatio difference is > update storage threshold\\n                            if ((memVar_ & 1) == (memVar4_ & 1)) {\\n                                memVar_ = memVar_ >> 1;\\n                                memVar_ = (\\n                                    (memVar4_ >> 1) > memVar_ ? (memVar4_ >> 1) - memVar_ : memVar_ - (memVar4_ >> 1)\\n                                ) > memVar2_\\n                                    ? 1\\n                                    : 0; // memVar4_ = borrowRatio, memVar_ = previous borrowRatio, memVar2_ = update storage threshold\\n                            } else {\\n                                // if inverse bit is changing then always update on storage\\n                                memVar_ = 1;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // memVar_ is 1 if either time diff was enough or if\\n            // utilization, supplyRatio or borrowRatio difference was > update storage threshold\\n            if (memVar_ == 1) {\\n                // memVar_ => calculate new borrow rate for utilization. includes value overflow check.\\n                memVar_ = LiquidityCalcs.calcBorrowRateFromUtilization(_rateData[token_], utilization_);\\n                // ensure values written to storage do not exceed the dedicated bit space in packed uint256 slots\\n                if (o_.supplyExchangePrice > X64 || o_.borrowExchangePrice > X64) {\\n                    revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__EXCHANGE_PRICES);\\n                }\\n                if (utilization_ > X14) {\\n                    revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__UTILIZATION);\\n                }\\n                o_.exchangePricesAndConfig =\\n                    (o_.exchangePricesAndConfig &\\n                        // mask to update bits: 0-15 (borrow rate), 30-43 (utilization), 58-248 (timestamp, exchange prices, ratios)\\n                        0xfe000000000000000000000000000000000000000000000003fff0003fff0000) |\\n                    memVar_ | // calcBorrowRateFromUtilization already includes an overflow check\\n                    (utilization_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) |\\n                    (block.timestamp << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) |\\n                    (o_.supplyExchangePrice << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) |\\n                    (o_.borrowExchangePrice << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) |\\n                    // ratios can never be > 100%, no overflow check needed\\n                    (memVar3_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) | // supplyRatio (memVar3_ holds that value)\\n                    (memVar4_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO); // borrowRatio (memVar4_ holds that value)\\n                // Updating on storage\\n                _exchangePricesAndConfig[token_] = o_.exchangePricesAndConfig;\\n            } else {\\n                // do not update in storage but update o_.exchangePricesAndConfig for updated exchange prices at\\n                // event emit of LogOperate\\n                o_.exchangePricesAndConfig =\\n                    (o_.exchangePricesAndConfig &\\n                        // mask to update bits: 91-218 (exchange prices)\\n                        0xfffffffffc00000000000000000000000000000007ffffffffffffffffffffff) |\\n                    (o_.supplyExchangePrice << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) |\\n                    (o_.borrowExchangePrice << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE);\\n            }\\n        }\\n        // sending tokens to user at the end after updating everything\\n        // only transfer to user in case of withdraw or borrow.\\n        // special flow in case of netTransfersOut < 0 -> skip transfers, e.g. when net transfer in only or when\\n        // same amounts in same operate(): supply(+) == borrow(+), withdraw(-) == payback(-). (DEX protocol use-case).\\n        // when net transfers out = 0 -> normal flow\\n        // when net transfers out > 0 -> net transfers out only flow\\n        if ((supplyAmount_ < 0 || borrowAmount_ > 0) && o_.netTransfersOut > SKIP_TRANSFER_OUT_BELOW_VALUE_SIGNAL) {\\n            // sending tokens to user at the end after updating everything\\n            if (o_.netTransfersOut > 0) {\\n                if (token_ == NATIVE_TOKEN_ADDRESS) {\\n                    SafeTransfer.safeTransferNative(\\n                        withdrawTo_ == address(0) ? borrowTo_ : withdrawTo_, // enforced in isNetTransfers_ that either one is set\\n                        uint256(o_.netTransfersOut)\\n                    );\\n                } else {\\n                    _preTransferOut(token_, uint256(o_.netTransfersOut));\\n                    SafeTransfer.safeTransfer(\\n                        token_,\\n                        withdrawTo_ == address(0) ? borrowTo_ : withdrawTo_, // enforced in isNetTransfers_ that either one is set\\n                        uint256(o_.netTransfersOut)\\n                    );\\n                }\\n            } else {\\n                // set memVar2_ to borrowAmount (if borrow) or reset memVar2_ var to 0 because\\n                // it is used with > 0 check below to transfer withdraw / borrow / both\\n                memVar2_ = borrowAmount_ > 0 ? uint256(borrowAmount_) : 0;\\n                if (supplyAmount_ < 0) {\\n                    unchecked {\\n                        memVar_ = uint256(-supplyAmount_);\\n                    }\\n                } else {\\n                    memVar_ = 0;\\n                }\\n                if (memVar_ > 0 && memVar2_ > 0 && withdrawTo_ == borrowTo_) {\\n                    // if user is doing borrow & withdraw together and address for both is the same\\n                    // then transfer tokens of borrow & withdraw together to save on gas\\n                    if (token_ == NATIVE_TOKEN_ADDRESS) {\\n                        SafeTransfer.safeTransferNative(withdrawTo_, memVar_ + memVar2_);\\n                    } else {\\n                        memVar_ = memVar_ + memVar2_;\\n                        _preTransferOut(token_, memVar_);\\n                        SafeTransfer.safeTransfer(token_, withdrawTo_, memVar_);\\n                    }\\n                } else {\\n                    if (token_ == NATIVE_TOKEN_ADDRESS) {\\n                        // if withdraw\\n                        if (memVar_ > 0) {\\n                            SafeTransfer.safeTransferNative(withdrawTo_, memVar_);\\n                        }\\n                        // if borrow\\n                        if (memVar2_ > 0) {\\n                            SafeTransfer.safeTransferNative(borrowTo_, memVar2_);\\n                        }\\n                    } else {\\n                        // if withdraw\\n                        if (memVar_ > 0) {\\n                            _preTransferOut(token_, memVar_);\\n                            SafeTransfer.safeTransfer(token_, withdrawTo_, memVar_);\\n                        }\\n                        // if borrow\\n                        if (memVar2_ > 0) {\\n                            _preTransferOut(token_, memVar2_);\\n                            SafeTransfer.safeTransfer(token_, borrowTo_, memVar2_);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        // emit Operate event\\n        emit LogOperate(\\n            msg.sender,\\n            token_,\\n            supplyAmount_,\\n            borrowAmount_,\\n            withdrawTo_,\\n            borrowTo_,\\n            o_.totalAmounts,\\n            o_.exchangePricesAndConfig\\n        );\\n        // set return values\\n        memVar3_ = o_.supplyExchangePrice;\\n        memVar4_ = o_.borrowExchangePrice;\\n    }\\n}\\n\",\"keccak256\":\"0x6e684fb1ca637c1d4c257aec194045e72fd15c072441dc405a61460c94be46a2\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/userModule/mainOthers.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\nimport { FluidLiquidityUserModule } from \\\"./main.sol\\\";\\nimport { CommonHelpersOthers } from \\\"../common/helpersOthers.sol\\\";\\n\\ncontract FluidLiquidityUserModuleOthers is FluidLiquidityUserModule, CommonHelpersOthers {}\\n\",\"keccak256\":\"0xf4e261c23be1fc99236d5b13927e87d991403131b2abf03941caaefc91f9931f\",\"license\":\"BUSL-1.1\"},\"solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1b62af9baf5b8e991ed7531bc87f45550ba9d61e8dbff5caf237ccaf3a3fd843\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x6080604052348015600e575f5ffd5b506002600155612e40806100215f395ff3fe60806040526004361061001d575f3560e01c8063ad967e1514610021575b5f5ffd5b61003461002f366004612b3f565b61004d565b6040805192835260208301919091520160405180910390f35b5f5f600260ff1660015403610097576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612ee160048201526024015b60405180910390fd5b6002600155871580156100a8575086155b156100e3576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612afd600482015260240161008e565b7fffffffffffffffffffffffffffffffff8000000000000000000000000000000088128061012057506f7fffffffffffffffffffffffffffffff88135b8061014a57507fffffffffffffffffffffffffffffffff8000000000000000000000000000000087125b8061016457506f7fffffffffffffffffffffffffffffff87135b1561019f576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612afe600482015260240161008e565b5f881280156101c2575073ffffffffffffffffffffffffffffffffffffffff8616155b806101eb57505f871380156101eb575073ffffffffffffffffffffffffffffffffffffffff8516155b15610226576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b00600482015260240161008e565b73ffffffffffffffffffffffffffffffffffffffff891673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee1480159061025f57505f34115b1561029a576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b02600482015260240161008e565b6102e06040518061012001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81525090565b5f5f5f8a126102ef575f6102f8565b6102f88a612c1e565b5f8c13610305575f610307565b8b5b6103119190612c54565b606495509050603f86111561045d576103628b8b8b8b8b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061151492505050565b1561038d57507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82525f5b5f6103d08c8c8c8c8c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061173292505050565b93509050801561045b57818303610417576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b0a600482015260240161008e565b82821115610453577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84526103e890950294908290039061045b565b90820383525f905b505b7fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff8d16016104ed57348111806104af575061271085810182020434115b156104ea576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b01600482015260240161008e565b505f5b801561072657605f86111561053e5761053b8188888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061198992505050565b90505b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff8d16906370a0823190602401602060405180830381865afa1580156105a6573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105ca9190612c94565b6040517fad207501000000000000000000000000000000000000000000000000000000008152909250339063ad2075019061060f908f9085908c908c90600401612cab565b5f604051808303815f87803b158015610626575f5ffd5b505af1158015610638573d5f5f3e3d5ffd5b50506040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015284925073ffffffffffffffffffffffffffffffffffffffff8f1691506370a0823190602401602060405180830381865afa1580156106a6573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106ca9190612c94565b6106d49190612d1b565b9150808210806106eb575061271085810182020482115b15610726576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b01600482015260240161008e565b73ffffffffffffffffffffffffffffffffffffffff8c165f90815260056020526040902054610100840181905261075c90611aa8565b60408086019190915260208086019290925273ffffffffffffffffffffffffffffffffffffffff8e165f9081526007909252908190205460e0850181905266ffffffffffffff600882901c811660ff8084169190911b6060880152604883901c82169383901c81169390931b608080880191909152608883901c9091169082901c83161b60a086015260c881901c60c091821c9283161b9085015291508a15610a1a575f8360e0015190505f5f6108188f8f8860200151611cb6565b91509150805f036108d3575f8213156108555761083b828760600151600161218c565b818660600181815161084d9190612c54565b90525061088d565b61086c61086183612c1e565b87606001515f61218c565b815f0386606001511161087f575f610887565b606086015182015b60608701525b60608601516108a090603860085f6121fb565b60e0870180517fffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000168217905294506109d5565b5f811315610905576108eb818760800151600161218c565b80866080018181516108fd9190612c54565b90525061093d565b61091c61091182612c1e565b87608001515f61218c565b805f0386608001511161092f575f610937565b608086015181015b60808701525b60808601516f7fffffffffffffffffffffffffffffff101561098f576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b06600482015260240161008e565b60808601516109a290603860085f6121fb565b60e0870180517fffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff16604083901b17905294505b8560e001518303610a16576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612aff600482015260240161008e565b5050505b8915610c39575f8360e0015190505f5f610a398f8e8860400151612321565b91509150805f03610af9575f821315610a7657610a5c828760a00151600161218c565b818660a001818151610a6e9190612c54565b905250610aae565b610a8d610a8283612c1e565b8760a001515f61218c565b815f038660a0015111610aa0575f610aa8565b60a086015182015b60a08701525b60a0860151610ac2906038600860016121fb565b60e0870180517fffffffffffffffff0000000000000000ffffffffffffffffffffffffffffffff16608083901b1790529450610bf4565b5f811315610b2b57610b11818760c00151600161218c565b808660c001818151610b239190612c54565b905250610b63565b610b42610b3782612c1e565b8760c001515f61218c565b805f038660c0015111610b55575f610b5d565b60c086015181015b60c08701525b60c08601516f7fffffffffffffffffffffffffffffff1015610bb5576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b07600482015260240161008e565b60c0860151610bc9906038600860016121fb565b60e08701805177ffffffffffffffffffffffffffffffffffffffffffffffff1660c083901b17905294505b8560e001518303610c35576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612aff600482015260240161008e565b5050505b60e083015173ffffffffffffffffffffffffffffffffffffffff8d165f90815260076020908152604090912091909155830151606084015164e8d4a5100091610c8191612d2e565b610c8b9190612d45565b94506f7fffffffffffffffffffffffffffffff85118015610cab57505f8b135b15610ce6576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b06600482015260240161008e565b848360800151610cf69190612c54565b91508260800151851115610d2c576001856127108560800151610d199190612d2e565b610d239190612d45565b901b9450610d6e565b8260800151851015610d62576080830151600190610d4c61271088612d2e565b610d569190612d45565b901b6001179450610d6e565b8115610d6e57614e2094505b64e8d4a5100083604001518460a00151610d889190612d2e565b610d929190612d45565b93506f7fffffffffffffffffffffffffffffff84118015610db257505f8a135b15610ded576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b07600482015260240161008e565b838360c00151610dfd9190612c54565b90508260c00151841115610e33576001846127108560c00151610e209190612d2e565b610e2a9190612d45565b901b9350610e75565b8260c00151841015610e695760c0830151600190610e5361271087612d2e565b610e5d9190612d45565b901b6001179350610e75565b8015610e7557614e2093505b5f8215610f235782610e8961271084612d2e565b610e939190612d45565b90505f8b1315610f235760f9846101000151901c600116600114610eb957612710610ee3565b73ffffffffffffffffffffffffffffffffffffffff8d165f908152600b6020526040902054613fff165b925082811115610f23576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b03600482015260240161008e565b610100840151603a1c6401ffffffff166201518001421115610f485760019250610f4c565b5f92505b825f0361106a57613fff601e856101000151901c169250613fff602c856101000151901c16915081838211610f8357818403610f87565b8382035b11610f92575f610f95565b60015b60ff169250825f0361106a57617fff60db856101000151901c169250856001168360011603610ffd57600183901c92508183600188901c11610fdd57600187901c8403610fe5565b83600188901c035b11610ff0575f610ff3565b60015b60ff169250611002565b600192505b825f0361106a57617fff60ea856101000151901c16925084600116836001160361106557600183901c92508183600187901c1161104557600186901c840361104d565b83600187901c035b11611058575f61105b565b60015b60ff16925061106a565b600192505b826001036111ef5773ffffffffffffffffffffffffffffffffffffffff8d165f908152600660205260409020546110a190826125c2565b925067ffffffffffffffff846020015111806110c8575067ffffffffffffffff8460400151115b15611103576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b04600482015260240161008e565b613fff811115611143576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b05600482015260240161008e565b60ea85901b60db87901b609b8660400151901b605b8760200151901b603a42901b601e86901b888a61010001517ffe000000000000000000000000000000000000000000000003fff0003fff000016171717171717178461010001818152505083610100015160055f8f73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550611236565b609b8460400151901b605b8560200151901b8561010001517ffffffffffc00000000000000000000000000000007ffffffffffffffffffffff161717846101000181815250505b505f8b128061124457505f8a135b8015611270575082517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff125b156114745782515f121561131d577fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff8d16016112ee576112e973ffffffffffffffffffffffffffffffffffffffff8a16156112e057896112e2565b885b8451612669565b611474565b6112e98c73ffffffffffffffffffffffffffffffffffffffff8b1615611314578a611316565b895b85516126b2565b5f8a1361132a575f61132c565b895b90505f8b1215611340578a5f039150611344565b5f91505b5f8211801561135257505f81115b801561138957508773ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff16145b156113f5577fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff8d16016113de576112e9896113d98385612c54565b612669565b6113e88183612c54565b91506112e98c8a846126b2565b7fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff8d1601611452578115611442576114428983612669565b80156112e9576112e98882612669565b8115611463576114638c8a846126b2565b8015611474576114748c89836126b2565b60e0830151610100840151604080518e8152602081018e905273ffffffffffffffffffffffffffffffffffffffff8d8116828401528c81166060830152608082019490945260a081019290925251918e169133917f4d93b232a24e82b284ced7461bf4deacffe66759d5c24513e6f29e571ad78d15919081900360c00190a35050602081015160409091015160018055909a909950975050505050505050565b805181017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015160408051808201909152600e81527f534b49505f5452414e53464552530000000000000000000000000000000000006020909101525f907f520f8ead5ba46586393d3a30de35560ff757e867d80fed46623eb8022af73ba381146115a2575f915050611729565b341515806115ae575086155b806115b7575085155b806115c157508587135b156115fc576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b08600482015260240161008e565b82518301515f881315611698578473ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16148015611659575073ffffffffffffffffffffffffffffffffffffffff811633145b611693576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b08600482015260240161008e565b611722565b8573ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161480156116e8575073ffffffffffffffffffffffffffffffffffffffff811633145b611722576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b08600482015260240161008e565b6001925050505b95945050505050565b805181017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015160408051808201909152600d81527f4e45545f5452414e5346455253000000000000000000000000000000000000006020909101525f9081907f1c3af6d2a9b692a8b50895d7ef6c86616579c006b3b26b878c48ef9abe2a7eab81146117c5575f5f925092505061197f565b5f88126117d2575f6117db565b6117db88612c1e565b5f88136117e8575f6117ea565b875b6117f49190612c54565b9150871580611801575086155b8061180d57505f878918125b15611848576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b0a600482015260240161008e565b83518401515f8912156118e5578673ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415806118a5575073ffffffffffffffffffffffffffffffffffffffff861615155b156118e0576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b0a600482015260240161008e565b611978565b5f881315611978578573ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614158061193d575073ffffffffffffffffffffffffffffffffffffffff871615155b15611978576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b0a600482015260240161008e565b6001935050505b9550959350505050565b60208101515f9080848110806119bf57506127106119a8606482612c54565b6119b29087612d2e565b6119bc9190612d45565b81115b15611a985760408051808201909152600581527f44455856320000000000000000000000000000000000000000000000000000006020909101527f2ee71ed3ac8c9a5524779d52750d68d33a5ebff09360b90ca0c7b6da00f5b24a8201611a935750606083015184811080611a545750612710611a3d606482612c54565b611a479087612d2e565b611a519190612d45565b81115b15611a8f576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b01600482015260240161008e565b8094505b611a9c565b8094505b84925050505b92915050565b67ffffffffffffffff605b82901c811690609b83901c16811580611aca575080155b15611b06576040517fd50d751200000000000000000000000000000000000000000000000000000000815262011171600482015260240161008e565b61ffff8316603a84901c6401ffffffff16428181039160ea87901c617fff16911480611b30575082155b80611b3b5750806001145b15611b4857505050915091565b64496cebb80084840283020484019350617fff60db87901c16925082600103611b7357505050915091565b82600116600103611bc85760019290921c91826c7e37be2022c0914b268000000081611ba157611ba1612c67565b049250612710601e87901c613fff166b033b2e3c9fd0803ce8000000850102049250611bf5565b60019290921c916305f5e100601e87901c613fff166127108501026b033b2e3c9fd0803ce8000000020492505b80600116600103611c2c5760011c61271081016b033b2e3c9fd0803ce8000000820281611c2457611c24612c67565b049050611c62565b60011c61271081016b033b2e3c9fd0803ce8000000820281611c5057611c50612c67565b046b033b2e3c9fd0803ce80000000390505b760a70c3c40a64e6c51999090b65f67d92400000000000008382026127100261ffff881691900402601087901c613fff16612710030292506801b5a660ea44b8000085840283020485019450505050915091565b335f90815260086020908152604080832073ffffffffffffffffffffffffffffffffffffffff871684529091528120548190808203611d25576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612af9600482015260240161008e565b60ff81901c600103611d67576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612afa600482015260240161008e565b66ffffffffffffff600982901c1660ff600183901c81169190911b906203ffff60e284901c1660da84901c9091161b60f483901c6103ff168115611df3575f6024600a608187901c6401ffffffff1602046024600a42020403905081811015611dea578181840281611ddb57611ddb612c67565b04830392508082039150611df1565b5f92505f91505b505b5f611dfe8585612758565b905084600116600103611e76575f891315611e405787611e2364e8d4a510008b612d58565b611e2d9190612da3565b9650611e398785612c54565b9350611ea1565b611e58611e4c8a612c1e565b64e8d4a510008a6127e9565b611e6190612c1e565b9650611e6c87612c1e565b611e399085612d1b565b8895505f861315611e8b57611e398685612c54565b611e9486612c1e565b611e9e9085612d1b565b93505b5f5f8a1215611f355781851015611ee8576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612afb600482015260240161008e565b8315611f35578787015f0384811115611f1657848311611f08575f611f0c565b8483035b92505f9450611f2f565b808311611f23575f611f27565b8083035b925080850394505b50600190505b5f611f4187878561282b565b9050805f03611f52575f9450612011565b808314612011575f8b1315611fe957825f03611f7d576103ff60d088901c1660ff60c889901c161b92505b82811115611fde57828103611f928187612c54565b611f9e826103e8612d2e565b611fa88888612d2e565b611fb29190612c54565b611fbc9190612d45565b94506050851015611fcc57605094505b611fd68187612c54565b955050612011565b5f94505f9350612011565b8115612011575f838211611ffd575f612001565b8382035b905061200d8187612c54565b9550505b600a851015612025575f94505f9350612055565b61203385601260085f6121fb565b94506103e8841115612049576103e89350612055565b835f0361205557600193505b61206386603860085f6121fb565b95508567ffffffffffffffff600189901c16036120b0576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612aff600482015260240161008e565b6120be81603860085f6121fb565b905060f484901b60da86901b608142901b604184901b60018a901b8b7fc000000003fffffffffffffc000000000000000000000000000000000000000116171717171760085f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8e73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f208190555050505050505050935093915050565b8061219a57600282046121a0565b81612710025b91506a0100000000000000000000831180156121bb57508183115b156121f6576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b09600482015260240161008e565b505050565b5f5f856fffffffffffffffffffffffffffffffff81111561221d5760809150811c5b67ffffffffffffffff811115612235576040918201911c5b63ffffffff811115612249576020918201911c5b61ffff81111561225b576010918201911c5b60ff81111561226c576008918201911c5b600f81111561227d576004918201911c5b600381111561228e576002918201911c5b600181111561229e576001820191505b80156122ab576001820191505b50848110156122b75750835b848103905085811c5f821184161561230557600181019050806001871b0361230557506001908101907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff86011b5b6001851b8210612313575f5ffd5b90931b909201949350505050565b335f90815260096020908152604080832073ffffffffffffffffffffffffffffffffffffffff871684529091528120548190808203612390576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612af9600482015260240161008e565b60ff81901c6001036123d2576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612afa600482015260240161008e565b66ffffffffffffff600982901c1660ff600183901c161b5f6123f4838361287c565b90508260011660010361245b575f87131561242c576124198764e8d4a51000886127e9565b94506124258583612c54565b9150612486565b8561243c64e8d4a5100089612d58565b6124469190612da3565b945061245185612c1e565b6124259083612d1b565b8693505f841315612470576124258483612c54565b61247984612c1e565b6124839083612d1b565b91505b5f8713801561249457508082115b156124cf576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612afc600482015260240161008e565b6124da838383612938565b90506124eb826038600860016121fb565b91508167ffffffffffffffff600185901c1603612538576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612aff600482015260240161008e565b61254681603860085f6121fb565b335f90815260096020908152604080832073ffffffffffffffffffffffffffffffffffffffff9c909c1683529a9052989098207ffffffffffffffffffffffffc000000000000000000000000000000000000000190931660019290921b9190911760419790971b969096174260811b1790559094909350915050565b5f600f831660018190036125e1576125da8484612997565b915061262a565b806002036125f3576125da8484612a72565b6040517fd50d751200000000000000000000000000000000000000000000000000000000815262011172600482015260240161008e565b61ffff8211156126625760405161ffff92507fe41708b2641eb1f7442f6a1e760ae5098fd7ba9f85e0c101513add0fbb27bcd7905f90a15b5092915050565b5f5f5f5f5f858761c350f19050806121f6576040517fdee51a8a0000000000000000000000000000000000000000000000000000000081526201155a600482015260240161008e565b5f6040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8416600482015282602482015260205f6044835f895af13d15601f3d1160015f511416171691505080612752576040517fdee51a8a0000000000000000000000000000000000000000000000000000000081526201155a600482015260240161008e565b50505050565b5f66ffffffffffffff604984901c1660ff604185901c161b808203612780575f915050611aa2565b612710613fff60a286901c168402046401ffffffff608186901c16420362ffffff60b087901c166127b18284612d2e565b6127bb9190612d45565b90508083116127ca575f6127ce565b8083035b935050808403838111156127e0578093505b50505092915050565b5f827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048411830215820261281c575f5ffd5b50910281810615159190040190565b5f6103ff60d085901c1660ff60c886901c161b8084101561284f575f915050612875565b50612710613fff60a286901c16840204830382811115612870579050612875565b829150505b9392505050565b5f608183901c6401ffffffff164203612710613fff60a286901c16840204808401604986901c66ffffffffffffff16604187901c60ff161b60b087901c62ffffff166128c88585612d2e565b6128d29190612d45565b6128dc9190612c54565b9350808411156128ea578093505b6103ff60d087901c1660ff60c888901c161b92508284101561291157829350505050611aa2565b6103ff60e287901c1660ff60da88901c161b9250828411156127e057829350505050611aa2565b612710613fff60a285901c16830204820160d084901c6103ff1660c885901c60ff161b8082101561296a579050612875565b506103ff60e285901c1660ff60da86901c161b80821115612989578091505b818311156128705750612875565b5f80808080601487901c61ffff16808710156129ce5761ffff600489901c16945061ffff602489901c1693505f92508091506129ed565b61ffff602489901c16945061ffff603489901c16935080925061271091505b5f5f84840364e8d4a510008888030281612a0957612a09612c67565b0585810264e8d4a5100089020392508902820190505f811215612a5d576040517fd50d751200000000000000000000000000000000000000000000000000000000815262011173600482015260240161008e565b64e8d4a5100090049998505050505050505050565b5f80808080601487901c61ffff1680871015612aa95761ffff600489901c16945061ffff602489901c1693505f92508091506129ed565b603488901c61ffff1680881015612adb5761ffff60248a901c16955061ffff60448a901c169450819350809250612afa565b61ffff60448a901c16955061ffff60548a901c16945080935061271092505b505f5f84840364e8d4a510008888030281612a0957612a09612c67565b803573ffffffffffffffffffffffffffffffffffffffff81168114612b3a575f5ffd5b919050565b5f5f5f5f5f5f5f60c0888a031215612b55575f5ffd5b612b5e88612b17565b96506020880135955060408801359450612b7a60608901612b17565b9350612b8860808901612b17565b925060a088013567ffffffffffffffff811115612ba3575f5ffd5b8801601f81018a13612bb3575f5ffd5b803567ffffffffffffffff811115612bc9575f5ffd5b8a6020828401011115612bda575f5ffd5b602082019350809250505092959891949750929550565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f7f80000000000000000000000000000000000000000000000000000000000000008203612c4e57612c4e612bf1565b505f0390565b80820180821115611aa257611aa2612bf1565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f60208284031215612ca4575f5ffd5b5051919050565b73ffffffffffffffffffffffffffffffffffffffff8516815283602082015260606040820152816060820152818360808301375f818301608090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01601019392505050565b81810381811115611aa257611aa2612bf1565b8082028115828204841417611aa257611aa2612bf1565b5f82612d5357612d53612c67565b500490565b8082025f82127f800000000000000000000000000000000000000000000000000000000000000084141615612d8f57612d8f612bf1565b8181058314821517611aa257611aa2612bf1565b5f82612db157612db1612c67565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83147f800000000000000000000000000000000000000000000000000000000000000083141615612e0557612e05612bf1565b50059056fea2646970667358221220d5604dbb7acaf9476dd805473a89e41ce797344f73c5380a529b4ec6132fa49b64736f6c634300081d0033",
  "deployedBytecode": "0x60806040526004361061001d575f3560e01c8063ad967e1514610021575b5f5ffd5b61003461002f366004612b3f565b61004d565b6040805192835260208301919091520160405180910390f35b5f5f600260ff1660015403610097576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612ee160048201526024015b60405180910390fd5b6002600155871580156100a8575086155b156100e3576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612afd600482015260240161008e565b7fffffffffffffffffffffffffffffffff8000000000000000000000000000000088128061012057506f7fffffffffffffffffffffffffffffff88135b8061014a57507fffffffffffffffffffffffffffffffff8000000000000000000000000000000087125b8061016457506f7fffffffffffffffffffffffffffffff87135b1561019f576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612afe600482015260240161008e565b5f881280156101c2575073ffffffffffffffffffffffffffffffffffffffff8616155b806101eb57505f871380156101eb575073ffffffffffffffffffffffffffffffffffffffff8516155b15610226576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b00600482015260240161008e565b73ffffffffffffffffffffffffffffffffffffffff891673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee1480159061025f57505f34115b1561029a576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b02600482015260240161008e565b6102e06040518061012001604052805f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81526020015f81525090565b5f5f5f8a126102ef575f6102f8565b6102f88a612c1e565b5f8c13610305575f610307565b8b5b6103119190612c54565b606495509050603f86111561045d576103628b8b8b8b8b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061151492505050565b1561038d57507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82525f5b5f6103d08c8c8c8c8c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061173292505050565b93509050801561045b57818303610417576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b0a600482015260240161008e565b82821115610453577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84526103e890950294908290039061045b565b90820383525f905b505b7fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff8d16016104ed57348111806104af575061271085810182020434115b156104ea576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b01600482015260240161008e565b505f5b801561072657605f86111561053e5761053b8188888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061198992505050565b90505b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff8d16906370a0823190602401602060405180830381865afa1580156105a6573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105ca9190612c94565b6040517fad207501000000000000000000000000000000000000000000000000000000008152909250339063ad2075019061060f908f9085908c908c90600401612cab565b5f604051808303815f87803b158015610626575f5ffd5b505af1158015610638573d5f5f3e3d5ffd5b50506040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015284925073ffffffffffffffffffffffffffffffffffffffff8f1691506370a0823190602401602060405180830381865afa1580156106a6573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106ca9190612c94565b6106d49190612d1b565b9150808210806106eb575061271085810182020482115b15610726576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b01600482015260240161008e565b73ffffffffffffffffffffffffffffffffffffffff8c165f90815260056020526040902054610100840181905261075c90611aa8565b60408086019190915260208086019290925273ffffffffffffffffffffffffffffffffffffffff8e165f9081526007909252908190205460e0850181905266ffffffffffffff600882901c811660ff8084169190911b6060880152604883901c82169383901c81169390931b608080880191909152608883901c9091169082901c83161b60a086015260c881901c60c091821c9283161b9085015291508a15610a1a575f8360e0015190505f5f6108188f8f8860200151611cb6565b91509150805f036108d3575f8213156108555761083b828760600151600161218c565b818660600181815161084d9190612c54565b90525061088d565b61086c61086183612c1e565b87606001515f61218c565b815f0386606001511161087f575f610887565b606086015182015b60608701525b60608601516108a090603860085f6121fb565b60e0870180517fffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000168217905294506109d5565b5f811315610905576108eb818760800151600161218c565b80866080018181516108fd9190612c54565b90525061093d565b61091c61091182612c1e565b87608001515f61218c565b805f0386608001511161092f575f610937565b608086015181015b60808701525b60808601516f7fffffffffffffffffffffffffffffff101561098f576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b06600482015260240161008e565b60808601516109a290603860085f6121fb565b60e0870180517fffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff16604083901b17905294505b8560e001518303610a16576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612aff600482015260240161008e565b5050505b8915610c39575f8360e0015190505f5f610a398f8e8860400151612321565b91509150805f03610af9575f821315610a7657610a5c828760a00151600161218c565b818660a001818151610a6e9190612c54565b905250610aae565b610a8d610a8283612c1e565b8760a001515f61218c565b815f038660a0015111610aa0575f610aa8565b60a086015182015b60a08701525b60a0860151610ac2906038600860016121fb565b60e0870180517fffffffffffffffff0000000000000000ffffffffffffffffffffffffffffffff16608083901b1790529450610bf4565b5f811315610b2b57610b11818760c00151600161218c565b808660c001818151610b239190612c54565b905250610b63565b610b42610b3782612c1e565b8760c001515f61218c565b805f038660c0015111610b55575f610b5d565b60c086015181015b60c08701525b60c08601516f7fffffffffffffffffffffffffffffff1015610bb5576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b07600482015260240161008e565b60c0860151610bc9906038600860016121fb565b60e08701805177ffffffffffffffffffffffffffffffffffffffffffffffff1660c083901b17905294505b8560e001518303610c35576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612aff600482015260240161008e565b5050505b60e083015173ffffffffffffffffffffffffffffffffffffffff8d165f90815260076020908152604090912091909155830151606084015164e8d4a5100091610c8191612d2e565b610c8b9190612d45565b94506f7fffffffffffffffffffffffffffffff85118015610cab57505f8b135b15610ce6576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b06600482015260240161008e565b848360800151610cf69190612c54565b91508260800151851115610d2c576001856127108560800151610d199190612d2e565b610d239190612d45565b901b9450610d6e565b8260800151851015610d62576080830151600190610d4c61271088612d2e565b610d569190612d45565b901b6001179450610d6e565b8115610d6e57614e2094505b64e8d4a5100083604001518460a00151610d889190612d2e565b610d929190612d45565b93506f7fffffffffffffffffffffffffffffff84118015610db257505f8a135b15610ded576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b07600482015260240161008e565b838360c00151610dfd9190612c54565b90508260c00151841115610e33576001846127108560c00151610e209190612d2e565b610e2a9190612d45565b901b9350610e75565b8260c00151841015610e695760c0830151600190610e5361271087612d2e565b610e5d9190612d45565b901b6001179350610e75565b8015610e7557614e2093505b5f8215610f235782610e8961271084612d2e565b610e939190612d45565b90505f8b1315610f235760f9846101000151901c600116600114610eb957612710610ee3565b73ffffffffffffffffffffffffffffffffffffffff8d165f908152600b6020526040902054613fff165b925082811115610f23576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b03600482015260240161008e565b610100840151603a1c6401ffffffff166201518001421115610f485760019250610f4c565b5f92505b825f0361106a57613fff601e856101000151901c169250613fff602c856101000151901c16915081838211610f8357818403610f87565b8382035b11610f92575f610f95565b60015b60ff169250825f0361106a57617fff60db856101000151901c169250856001168360011603610ffd57600183901c92508183600188901c11610fdd57600187901c8403610fe5565b83600188901c035b11610ff0575f610ff3565b60015b60ff169250611002565b600192505b825f0361106a57617fff60ea856101000151901c16925084600116836001160361106557600183901c92508183600187901c1161104557600186901c840361104d565b83600187901c035b11611058575f61105b565b60015b60ff16925061106a565b600192505b826001036111ef5773ffffffffffffffffffffffffffffffffffffffff8d165f908152600660205260409020546110a190826125c2565b925067ffffffffffffffff846020015111806110c8575067ffffffffffffffff8460400151115b15611103576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b04600482015260240161008e565b613fff811115611143576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b05600482015260240161008e565b60ea85901b60db87901b609b8660400151901b605b8760200151901b603a42901b601e86901b888a61010001517ffe000000000000000000000000000000000000000000000003fff0003fff000016171717171717178461010001818152505083610100015160055f8f73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081905550611236565b609b8460400151901b605b8560200151901b8561010001517ffffffffffc00000000000000000000000000000007ffffffffffffffffffffff161717846101000181815250505b505f8b128061124457505f8a135b8015611270575082517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff125b156114745782515f121561131d577fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff8d16016112ee576112e973ffffffffffffffffffffffffffffffffffffffff8a16156112e057896112e2565b885b8451612669565b611474565b6112e98c73ffffffffffffffffffffffffffffffffffffffff8b1615611314578a611316565b895b85516126b2565b5f8a1361132a575f61132c565b895b90505f8b1215611340578a5f039150611344565b5f91505b5f8211801561135257505f81115b801561138957508773ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff16145b156113f5577fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff8d16016113de576112e9896113d98385612c54565b612669565b6113e88183612c54565b91506112e98c8a846126b2565b7fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff8d1601611452578115611442576114428983612669565b80156112e9576112e98882612669565b8115611463576114638c8a846126b2565b8015611474576114748c89836126b2565b60e0830151610100840151604080518e8152602081018e905273ffffffffffffffffffffffffffffffffffffffff8d8116828401528c81166060830152608082019490945260a081019290925251918e169133917f4d93b232a24e82b284ced7461bf4deacffe66759d5c24513e6f29e571ad78d15919081900360c00190a35050602081015160409091015160018055909a909950975050505050505050565b805181017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015160408051808201909152600e81527f534b49505f5452414e53464552530000000000000000000000000000000000006020909101525f907f520f8ead5ba46586393d3a30de35560ff757e867d80fed46623eb8022af73ba381146115a2575f915050611729565b341515806115ae575086155b806115b7575085155b806115c157508587135b156115fc576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b08600482015260240161008e565b82518301515f881315611698578473ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16148015611659575073ffffffffffffffffffffffffffffffffffffffff811633145b611693576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b08600482015260240161008e565b611722565b8573ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161480156116e8575073ffffffffffffffffffffffffffffffffffffffff811633145b611722576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b08600482015260240161008e565b6001925050505b95945050505050565b805181017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015160408051808201909152600d81527f4e45545f5452414e5346455253000000000000000000000000000000000000006020909101525f9081907f1c3af6d2a9b692a8b50895d7ef6c86616579c006b3b26b878c48ef9abe2a7eab81146117c5575f5f925092505061197f565b5f88126117d2575f6117db565b6117db88612c1e565b5f88136117e8575f6117ea565b875b6117f49190612c54565b9150871580611801575086155b8061180d57505f878918125b15611848576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b0a600482015260240161008e565b83518401515f8912156118e5578673ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415806118a5575073ffffffffffffffffffffffffffffffffffffffff861615155b156118e0576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b0a600482015260240161008e565b611978565b5f881315611978578573ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614158061193d575073ffffffffffffffffffffffffffffffffffffffff871615155b15611978576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b0a600482015260240161008e565b6001935050505b9550959350505050565b60208101515f9080848110806119bf57506127106119a8606482612c54565b6119b29087612d2e565b6119bc9190612d45565b81115b15611a985760408051808201909152600581527f44455856320000000000000000000000000000000000000000000000000000006020909101527f2ee71ed3ac8c9a5524779d52750d68d33a5ebff09360b90ca0c7b6da00f5b24a8201611a935750606083015184811080611a545750612710611a3d606482612c54565b611a479087612d2e565b611a519190612d45565b81115b15611a8f576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b01600482015260240161008e565b8094505b611a9c565b8094505b84925050505b92915050565b67ffffffffffffffff605b82901c811690609b83901c16811580611aca575080155b15611b06576040517fd50d751200000000000000000000000000000000000000000000000000000000815262011171600482015260240161008e565b61ffff8316603a84901c6401ffffffff16428181039160ea87901c617fff16911480611b30575082155b80611b3b5750806001145b15611b4857505050915091565b64496cebb80084840283020484019350617fff60db87901c16925082600103611b7357505050915091565b82600116600103611bc85760019290921c91826c7e37be2022c0914b268000000081611ba157611ba1612c67565b049250612710601e87901c613fff166b033b2e3c9fd0803ce8000000850102049250611bf5565b60019290921c916305f5e100601e87901c613fff166127108501026b033b2e3c9fd0803ce8000000020492505b80600116600103611c2c5760011c61271081016b033b2e3c9fd0803ce8000000820281611c2457611c24612c67565b049050611c62565b60011c61271081016b033b2e3c9fd0803ce8000000820281611c5057611c50612c67565b046b033b2e3c9fd0803ce80000000390505b760a70c3c40a64e6c51999090b65f67d92400000000000008382026127100261ffff881691900402601087901c613fff16612710030292506801b5a660ea44b8000085840283020485019450505050915091565b335f90815260086020908152604080832073ffffffffffffffffffffffffffffffffffffffff871684529091528120548190808203611d25576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612af9600482015260240161008e565b60ff81901c600103611d67576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612afa600482015260240161008e565b66ffffffffffffff600982901c1660ff600183901c81169190911b906203ffff60e284901c1660da84901c9091161b60f483901c6103ff168115611df3575f6024600a608187901c6401ffffffff1602046024600a42020403905081811015611dea578181840281611ddb57611ddb612c67565b04830392508082039150611df1565b5f92505f91505b505b5f611dfe8585612758565b905084600116600103611e76575f891315611e405787611e2364e8d4a510008b612d58565b611e2d9190612da3565b9650611e398785612c54565b9350611ea1565b611e58611e4c8a612c1e565b64e8d4a510008a6127e9565b611e6190612c1e565b9650611e6c87612c1e565b611e399085612d1b565b8895505f861315611e8b57611e398685612c54565b611e9486612c1e565b611e9e9085612d1b565b93505b5f5f8a1215611f355781851015611ee8576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612afb600482015260240161008e565b8315611f35578787015f0384811115611f1657848311611f08575f611f0c565b8483035b92505f9450611f2f565b808311611f23575f611f27565b8083035b925080850394505b50600190505b5f611f4187878561282b565b9050805f03611f52575f9450612011565b808314612011575f8b1315611fe957825f03611f7d576103ff60d088901c1660ff60c889901c161b92505b82811115611fde57828103611f928187612c54565b611f9e826103e8612d2e565b611fa88888612d2e565b611fb29190612c54565b611fbc9190612d45565b94506050851015611fcc57605094505b611fd68187612c54565b955050612011565b5f94505f9350612011565b8115612011575f838211611ffd575f612001565b8382035b905061200d8187612c54565b9550505b600a851015612025575f94505f9350612055565b61203385601260085f6121fb565b94506103e8841115612049576103e89350612055565b835f0361205557600193505b61206386603860085f6121fb565b95508567ffffffffffffffff600189901c16036120b0576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612aff600482015260240161008e565b6120be81603860085f6121fb565b905060f484901b60da86901b608142901b604184901b60018a901b8b7fc000000003fffffffffffffc000000000000000000000000000000000000000116171717171760085f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8e73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f208190555050505050505050935093915050565b8061219a57600282046121a0565b81612710025b91506a0100000000000000000000831180156121bb57508183115b156121f6576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612b09600482015260240161008e565b505050565b5f5f856fffffffffffffffffffffffffffffffff81111561221d5760809150811c5b67ffffffffffffffff811115612235576040918201911c5b63ffffffff811115612249576020918201911c5b61ffff81111561225b576010918201911c5b60ff81111561226c576008918201911c5b600f81111561227d576004918201911c5b600381111561228e576002918201911c5b600181111561229e576001820191505b80156122ab576001820191505b50848110156122b75750835b848103905085811c5f821184161561230557600181019050806001871b0361230557506001908101907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff86011b5b6001851b8210612313575f5ffd5b90931b909201949350505050565b335f90815260096020908152604080832073ffffffffffffffffffffffffffffffffffffffff871684529091528120548190808203612390576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612af9600482015260240161008e565b60ff81901c6001036123d2576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612afa600482015260240161008e565b66ffffffffffffff600982901c1660ff600183901c161b5f6123f4838361287c565b90508260011660010361245b575f87131561242c576124198764e8d4a51000886127e9565b94506124258583612c54565b9150612486565b8561243c64e8d4a5100089612d58565b6124469190612da3565b945061245185612c1e565b6124259083612d1b565b8693505f841315612470576124258483612c54565b61247984612c1e565b6124839083612d1b565b91505b5f8713801561249457508082115b156124cf576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612afc600482015260240161008e565b6124da838383612938565b90506124eb826038600860016121fb565b91508167ffffffffffffffff600185901c1603612538576040517fdcab82e2000000000000000000000000000000000000000000000000000000008152612aff600482015260240161008e565b61254681603860085f6121fb565b335f90815260096020908152604080832073ffffffffffffffffffffffffffffffffffffffff9c909c1683529a9052989098207ffffffffffffffffffffffffc000000000000000000000000000000000000000190931660019290921b9190911760419790971b969096174260811b1790559094909350915050565b5f600f831660018190036125e1576125da8484612997565b915061262a565b806002036125f3576125da8484612a72565b6040517fd50d751200000000000000000000000000000000000000000000000000000000815262011172600482015260240161008e565b61ffff8211156126625760405161ffff92507fe41708b2641eb1f7442f6a1e760ae5098fd7ba9f85e0c101513add0fbb27bcd7905f90a15b5092915050565b5f5f5f5f5f858761c350f19050806121f6576040517fdee51a8a0000000000000000000000000000000000000000000000000000000081526201155a600482015260240161008e565b5f6040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8416600482015282602482015260205f6044835f895af13d15601f3d1160015f511416171691505080612752576040517fdee51a8a0000000000000000000000000000000000000000000000000000000081526201155a600482015260240161008e565b50505050565b5f66ffffffffffffff604984901c1660ff604185901c161b808203612780575f915050611aa2565b612710613fff60a286901c168402046401ffffffff608186901c16420362ffffff60b087901c166127b18284612d2e565b6127bb9190612d45565b90508083116127ca575f6127ce565b8083035b935050808403838111156127e0578093505b50505092915050565b5f827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048411830215820261281c575f5ffd5b50910281810615159190040190565b5f6103ff60d085901c1660ff60c886901c161b8084101561284f575f915050612875565b50612710613fff60a286901c16840204830382811115612870579050612875565b829150505b9392505050565b5f608183901c6401ffffffff164203612710613fff60a286901c16840204808401604986901c66ffffffffffffff16604187901c60ff161b60b087901c62ffffff166128c88585612d2e565b6128d29190612d45565b6128dc9190612c54565b9350808411156128ea578093505b6103ff60d087901c1660ff60c888901c161b92508284101561291157829350505050611aa2565b6103ff60e287901c1660ff60da88901c161b9250828411156127e057829350505050611aa2565b612710613fff60a285901c16830204820160d084901c6103ff1660c885901c60ff161b8082101561296a579050612875565b506103ff60e285901c1660ff60da86901c161b80821115612989578091505b818311156128705750612875565b5f80808080601487901c61ffff16808710156129ce5761ffff600489901c16945061ffff602489901c1693505f92508091506129ed565b61ffff602489901c16945061ffff603489901c16935080925061271091505b5f5f84840364e8d4a510008888030281612a0957612a09612c67565b0585810264e8d4a5100089020392508902820190505f811215612a5d576040517fd50d751200000000000000000000000000000000000000000000000000000000815262011173600482015260240161008e565b64e8d4a5100090049998505050505050505050565b5f80808080601487901c61ffff1680871015612aa95761ffff600489901c16945061ffff602489901c1693505f92508091506129ed565b603488901c61ffff1680881015612adb5761ffff60248a901c16955061ffff60448a901c169450819350809250612afa565b61ffff60448a901c16955061ffff60548a901c16945080935061271092505b505f5f84840364e8d4a510008888030281612a0957612a09612c67565b803573ffffffffffffffffffffffffffffffffffffffff81168114612b3a575f5ffd5b919050565b5f5f5f5f5f5f5f60c0888a031215612b55575f5ffd5b612b5e88612b17565b96506020880135955060408801359450612b7a60608901612b17565b9350612b8860808901612b17565b925060a088013567ffffffffffffffff811115612ba3575f5ffd5b8801601f81018a13612bb3575f5ffd5b803567ffffffffffffffff811115612bc9575f5ffd5b8a6020828401011115612bda575f5ffd5b602082019350809250505092959891949750929550565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f7f80000000000000000000000000000000000000000000000000000000000000008203612c4e57612c4e612bf1565b505f0390565b80820180821115611aa257611aa2612bf1565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f60208284031215612ca4575f5ffd5b5051919050565b73ffffffffffffffffffffffffffffffffffffffff8516815283602082015260606040820152816060820152818360808301375f818301608090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01601019392505050565b81810381811115611aa257611aa2612bf1565b8082028115828204841417611aa257611aa2612bf1565b5f82612d5357612d53612c67565b500490565b8082025f82127f800000000000000000000000000000000000000000000000000000000000000084141615612d8f57612d8f612bf1565b8181058314821517611aa257611aa2612bf1565b5f82612db157612db1612c67565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83147f800000000000000000000000000000000000000000000000000000000000000083141615612e0557612e05612bf1565b50059056fea2646970667358221220d5604dbb7acaf9476dd805473a89e41ce797344f73c5380a529b4ec6132fa49b64736f6c634300081d0033",
  "devdoc": {
    "events": {
      "LogOperate(address,address,int256,int256,address,address,uint256,uint256)": {
        "params": {
          "borrowAmount": "borrow amount for the operation. if >0 then a borrow happened, if <0 then a payback happened.                     if 0 then nothing.",
          "borrowTo": "address that funds where borrowed to (if borrowAmount >0)",
          "exchangePricesAndConfig": "updated exchange prices and configs storage slot. Contains updated supply & borrow exchange price: First 16 bits =>   0- 15 => borrow rate (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535) Next  14 bits =>  16- 29 => fee on interest from borrowers to lenders (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable. Next  14 bits =>  30- 43 => last stored utilization (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383) Next  14 bits =>  44- 57 => update on storage threshold (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable. Next  33 bits =>  58- 90 => last update timestamp (enough until 16 March 2242 -> max value 8589934591) Next  64 bits =>  91-154 => supply exchange price (1e12 -> max value 18_446_744,073709551615) Next  64 bits => 155-218 => borrow exchange price (1e12 -> max value 18_446_744,073709551615) Next   1 bit  => 219-219 => if 0 then ratio is supplyInterestFree / supplyWithInterest else ratio is supplyWithInterest / supplyInterestFree Next  14 bits => 220-233 => supplyRatio: supplyInterestFree / supplyWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383) Next   1 bit  => 234-234 => if 0 then ratio is borrowInterestFree / borrowWithInterest else ratio is borrowWithInterest / borrowInterestFree Next  14 bits => 235-248 => borrowRatio: borrowInterestFree / borrowWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)",
          "supplyAmount": "supply amount for the operation. if >0 then a deposit happened, if <0 then a withdrawal happened.                     if 0 then nothing.",
          "token": "token address for which this operation was executed",
          "totalAmounts": "updated total amounts, stacked uint256 as written to storage: First  64 bits =>   0- 63 => total supply with interest in raw (totalSupply = totalSupplyRaw * supplyExchangePrice); BigMath: 56 | 8 Next   64 bits =>  64-127 => total interest free supply in normal token amount (totalSupply = totalSupply); BigMath: 56 | 8 Next   64 bits => 128-191 => total borrow with interest in raw (totalBorrow = totalBorrowRaw * borrowExchangePrice); BigMath: 56 | 8 Next   64 bits => 192-255 => total interest free borrow in normal token amount (totalBorrow = totalBorrow); BigMath: 56 | 8",
          "user": "protocol that triggered this operation (e.g. via an fToken or via Vault protocol)",
          "withdrawTo": "address that funds where withdrawn to (if supplyAmount <0)"
        }
      }
    },
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "events": {
      "BorrowRateMaxCap()": {
        "notice": "emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535"
      },
      "LogOperate(address,address,int256,int256,address,address,uint256,uint256)": {
        "notice": "emitted on any `operate()` execution: deposit / supply / withdraw / borrow. includes info related to the executed operation, new total amounts (packed uint256 of BigMath numbers as in storage) and exchange prices (packed uint256 as in storage)."
      }
    },
    "kind": "user",
    "methods": {
      "operate(address,int256,int256,address,address,bytes)": {
        "notice": "inheritdoc IFluidLiquidity"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 9179,
        "contract": "contracts/liquidity/userModule/mainOthers.sol:FluidLiquidityUserModuleOthers",
        "label": "_revenueCollector",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 9182,
        "contract": "contracts/liquidity/userModule/mainOthers.sol:FluidLiquidityUserModuleOthers",
        "label": "_status",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 9187,
        "contract": "contracts/liquidity/userModule/mainOthers.sol:FluidLiquidityUserModuleOthers",
        "label": "_isAuth",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 9192,
        "contract": "contracts/liquidity/userModule/mainOthers.sol:FluidLiquidityUserModuleOthers",
        "label": "_isGuardian",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 9197,
        "contract": "contracts/liquidity/userModule/mainOthers.sol:FluidLiquidityUserModuleOthers",
        "label": "_userClass",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 9202,
        "contract": "contracts/liquidity/userModule/mainOthers.sol:FluidLiquidityUserModuleOthers",
        "label": "_exchangePricesAndConfig",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 9207,
        "contract": "contracts/liquidity/userModule/mainOthers.sol:FluidLiquidityUserModuleOthers",
        "label": "_rateData",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 9212,
        "contract": "contracts/liquidity/userModule/mainOthers.sol:FluidLiquidityUserModuleOthers",
        "label": "_totalAmounts",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 9219,
        "contract": "contracts/liquidity/userModule/mainOthers.sol:FluidLiquidityUserModuleOthers",
        "label": "_userSupplyData",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 9226,
        "contract": "contracts/liquidity/userModule/mainOthers.sol:FluidLiquidityUserModuleOthers",
        "label": "_userBorrowData",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 9230,
        "contract": "contracts/liquidity/userModule/mainOthers.sol:FluidLiquidityUserModuleOthers",
        "label": "_listedTokens",
        "offset": 0,
        "slot": "10",
        "type": "t_array(t_address)dyn_storage"
      },
      {
        "astId": 9235,
        "contract": "contracts/liquidity/userModule/mainOthers.sol:FluidLiquidityUserModuleOthers",
        "label": "_configs2",
        "offset": 0,
        "slot": "11",
        "type": "t_mapping(t_address,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}