{
  "address": "0x44b417959D5a96258B6bc7Aa712EBc2BfEb74CE5",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IFluidVaultResolver",
          "name": "vaultResolver_",
          "type": "address"
        },
        {
          "internalType": "contract IFluidVaultFactory",
          "name": "vaultFactory_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "FluidVaultPositionsResolver__AddressZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FACTORY",
      "outputs": [
        {
          "internalType": "contract IFluidVaultFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VAULT_RESOLVER",
      "outputs": [
        {
          "internalType": "contract IFluidVaultResolver",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getAllVaultNftIds",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "nftIds_",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getAllVaultPositions",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nftId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "supply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrow",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.UserPosition[]",
          "name": "positions_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "nftIds_",
          "type": "uint256[]"
        }
      ],
      "name": "getPositionsForNftIds",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nftId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "supply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrow",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.UserPosition[]",
          "name": "positions_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x2367b4f5f3906dc98bc2b7af2f8db01f530d4bad1ea08c8e7340de7abe1884f8",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x0Ed35B1609Ec45c7079E80d11149a52717e4859A",
    "contractAddress": null,
    "transactionIndex": 41,
    "gasUsed": "1366323",
    "logsBloom": "0x00000000000000000000000002000000000000000000000000000000000000000000000000000000200000000000010000008000000000000000000000000000000000000000000000000000000040800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000001000000000000000000000000000000004000000000000000040001000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x6a5aeecb71d788b85d0c3d8bd1c9b24460749258f124fac3f03a2f7140080895",
    "transactionHash": "0x2367b4f5f3906dc98bc2b7af2f8db01f530d4bad1ea08c8e7340de7abe1884f8",
    "logs": [
      {
        "transactionIndex": 41,
        "blockNumber": 68520293,
        "transactionHash": "0x2367b4f5f3906dc98bc2b7af2f8db01f530d4bad1ea08c8e7340de7abe1884f8",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x0000000000000000000000000ed35b1609ec45c7079e80d11149a52717e4859a",
          "0x00000000000000000000000069f5c4d08f6bc8cd29fe5f004d46fb566270868d"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000919fe7e8e17264000000000000000000000000000000000000000000000000b68172bac0300c4b00000000000000000000000000000000000000000000005cae7c0b4d1b5370dc000000000000000000000000000000000000000000000000b5efd2d2d74e99e700000000000000000000000000000000000000000000005caf0dab350434e340",
        "logIndex": 117,
        "blockHash": "0x6a5aeecb71d788b85d0c3d8bd1c9b24460749258f124fac3f03a2f7140080895"
      }
    ],
    "blockNumber": 68520293,
    "cumulativeGasUsed": "4261589",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x3c64Ec468D7f0998cB6dea05d4D8AB847573fE4D",
    "0x324c5Dc1fC42c7a4D43d92df1eBA58a54d13Bf2d"
  ],
  "numDeployments": 1,
  "solcInputHash": "4f63da12d66a256eeca1b26617ce10fe",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IFluidVaultResolver\",\"name\":\"vaultResolver_\",\"type\":\"address\"},{\"internalType\":\"contract IFluidVaultFactory\",\"name\":\"vaultFactory_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FluidVaultPositionsResolver__AddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"contract IFluidVaultFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT_RESOLVER\",\"outputs\":[{\"internalType\":\"contract IFluidVaultResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getAllVaultNftIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getAllVaultPositions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrow\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserPosition[]\",\"name\":\"positions_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds_\",\"type\":\"uint256[]\"}],\"name\":\"getPositionsForNftIds\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrow\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserPosition[]\",\"name\":\"positions_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"Fluid Vault protocol Positions Resolver for all vault types.\",\"version\":1},\"userdoc\":{\"errors\":{\"FluidVaultPositionsResolver__AddressZero()\":[{\"notice\":\"thrown if an input param address is zero\"}]},\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"constructor sets the immutable vault resolver and vault factory address\"}},\"notice\":\"This contract resolves positions for Fluid Vaults, providing functionality to retrieve NFT IDs and positions for a given vault.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/periphery/resolvers/vaultPositions/main.sol\":\"FluidVaultPositionsResolver\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xab28a56179c1db258c9bf5235b382698cb650debecb51b23d12be9e241374b68\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd1556954440b31c97a142c6ba07d5cade45f96fafd52091d33a14ebe365aecbf\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/libraries/tickMath.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @title library that calculates number \\\"tick\\\" and \\\"ratioX96\\\" from this: ratioX96 = (1.0015^tick) * 2^96\\n/// @notice this library is used in Fluid Vault protocol for optimiziation.\\n/// @dev \\\"tick\\\" supports between -32767 and 32767. \\\"ratioX96\\\" supports between 37075072 and 169307877264527972847801929085841449095838922544595\\nlibrary TickMath {\\n    /// The minimum tick that can be passed in getRatioAtTick. 1.0015**-32767\\n    int24 internal constant MIN_TICK = -32767;\\n    /// The maximum tick that can be passed in getRatioAtTick. 1.0015**32767\\n    int24 internal constant MAX_TICK = 32767;\\n\\n    uint256 internal constant FACTOR00 = 0x100000000000000000000000000000000;\\n    uint256 internal constant FACTOR01 = 0xff9dd7de423466c20352b1246ce4856f; // 2^128/1.0015**1 = 339772707859149738855091969477551883631\\n    uint256 internal constant FACTOR02 = 0xff3bd55f4488ad277531fa1c725a66d0; // 2^128/1.0015**2 = 339263812140938331358054887146831636176\\n    uint256 internal constant FACTOR03 = 0xfe78410fd6498b73cb96a6917f853259; // 2^128/1.0015**4 = 338248306163758188337119769319392490073\\n    uint256 internal constant FACTOR04 = 0xfcf2d9987c9be178ad5bfeffaa123273; // 2^128/1.0015**8 = 336226404141693512316971918999264834163\\n    uint256 internal constant FACTOR05 = 0xf9ef02c4529258b057769680fc6601b3; // 2^128/1.0015**16 = 332218786018727629051611634067491389875\\n    uint256 internal constant FACTOR06 = 0xf402d288133a85a17784a411f7aba082; // 2^128/1.0015**32 = 324346285652234375371948336458280706178\\n    uint256 internal constant FACTOR07 = 0xe895615b5beb6386553757b0352bda90; // 2^128/1.0015**64 = 309156521885964218294057947947195947664\\n    uint256 internal constant FACTOR08 = 0xd34f17a00ffa00a8309940a15930391a; // 2^128/1.0015**128 = 280877777739312896540849703637713172762 \\n    uint256 internal constant FACTOR09 = 0xae6b7961714e20548d88ea5123f9a0ff; // 2^128/1.0015**256 = 231843708922198649176471782639349113087\\n    uint256 internal constant FACTOR10 = 0x76d6461f27082d74e0feed3b388c0ca1; // 2^128/1.0015**512 = 157961477267171621126394973980180876449\\n    uint256 internal constant FACTOR11 = 0x372a3bfe0745d8b6b19d985d9a8b85bb; // 2^128/1.0015**1024 = 73326833024599564193373530205717235131\\n    uint256 internal constant FACTOR12 = 0x0be32cbee48979763cf7247dd7bb539d; // 2^128/1.0015**2048 = 15801066890623697521348224657638773661\\n    uint256 internal constant FACTOR13 = 0x8d4f70c9ff4924dac37612d1e2921e;   // 2^128/1.0015**4096 = 733725103481409245883800626999235102\\n    uint256 internal constant FACTOR14 = 0x4e009ae5519380809a02ca7aec77;     // 2^128/1.0015**8192 = 1582075887005588088019997442108535\\n    uint256 internal constant FACTOR15 = 0x17c45e641b6e95dee056ff10;         // 2^128/1.0015**16384 = 7355550435635883087458926352\\n\\n    /// The minimum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MIN_TICK). ~ Equivalent to `(1 << 96) * (1.0015**-32767)`\\n    uint256 internal constant MIN_RATIOX96 = 37075072;\\n    /// The maximum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MAX_TICK).\\n    /// ~ Equivalent to `(1 << 96) * (1.0015**32767)`, rounding etc. leading to minor difference\\n    uint256 internal constant MAX_RATIOX96 = 169307877264527972847801929085841449095838922544595;\\n\\n    uint256 internal constant ZERO_TICK_SCALED_RATIO = 0x1000000000000000000000000; // 1 << 96 // 79228162514264337593543950336\\n    uint256 internal constant _1E26 = 1e26;\\n\\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return ratioX96 ratio = (debt amount/collateral amount)\\n    function getRatioAtTick(int tick) internal pure returns (uint256 ratioX96) {\\n        assembly {\\n            let absTick_ := sub(xor(tick, sar(255, tick)), sar(255, tick))\\n\\n            if gt(absTick_, MAX_TICK) {\\n                revert(0, 0)\\n            }\\n            let factor_ := FACTOR00\\n            if and(absTick_, 0x1) {\\n                factor_ := FACTOR01\\n            }\\n            if and(absTick_, 0x2) {\\n                factor_ := shr(128, mul(factor_, FACTOR02))\\n            }\\n            if and(absTick_, 0x4) {\\n                factor_ := shr(128, mul(factor_, FACTOR03))\\n            }\\n            if and(absTick_, 0x8) {\\n                factor_ := shr(128, mul(factor_, FACTOR04))\\n            }\\n            if and(absTick_, 0x10) {\\n                factor_ := shr(128, mul(factor_, FACTOR05))\\n            }\\n            if and(absTick_, 0x20) {\\n                factor_ := shr(128, mul(factor_, FACTOR06))\\n            }\\n            if and(absTick_, 0x40) {\\n                factor_ := shr(128, mul(factor_, FACTOR07))\\n            }\\n            if and(absTick_, 0x80) {\\n                factor_ := shr(128, mul(factor_, FACTOR08))\\n            }\\n            if and(absTick_, 0x100) {\\n                factor_ := shr(128, mul(factor_, FACTOR09))\\n            }\\n            if and(absTick_, 0x200) {\\n                factor_ := shr(128, mul(factor_, FACTOR10))\\n            }\\n            if and(absTick_, 0x400) {\\n                factor_ := shr(128, mul(factor_, FACTOR11))\\n            }\\n            if and(absTick_, 0x800) {\\n                factor_ := shr(128, mul(factor_, FACTOR12))\\n            }\\n            if and(absTick_, 0x1000) {\\n                factor_ := shr(128, mul(factor_, FACTOR13))\\n            }\\n            if and(absTick_, 0x2000) {\\n                factor_ := shr(128, mul(factor_, FACTOR14))\\n            }\\n            if and(absTick_, 0x4000) {\\n                factor_ := shr(128, mul(factor_, FACTOR15))\\n            }\\n\\n            let precision_ := 0\\n            if iszero(and(tick, 0x8000000000000000000000000000000000000000000000000000000000000000)) {\\n                factor_ := div(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, factor_)\\n                // we round up in the division so getTickAtRatio of the output price is always consistent\\n                if mod(factor_, 0x100000000) {\\n                    precision_ := 1\\n                }\\n            }\\n            ratioX96 := add(shr(32, factor_), precision_)\\n        }\\n    }\\n\\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\\n    /// @dev Throws if ratioX96 > max ratio || ratioX96 < min ratio\\n    /// @param ratioX96 The input ratio; ratio = (debt amount/collateral amount)\\n    /// @return tick The output tick for the above formula. Returns in round down form. if tick is 123.23 then 123, if tick is -123.23 then returns -124\\n    /// @return perfectRatioX96 perfect ratio for the above tick\\n    function getTickAtRatio(uint256 ratioX96) internal pure returns (int tick, uint perfectRatioX96) {\\n        assembly {\\n            if or(gt(ratioX96, MAX_RATIOX96), lt(ratioX96, MIN_RATIOX96)) {\\n                revert(0, 0)\\n            }\\n\\n            let cond := lt(ratioX96, ZERO_TICK_SCALED_RATIO)\\n            let factor_\\n\\n            if iszero(cond) {\\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\\n                factor_ := div(mul(ratioX96, _1E26), ZERO_TICK_SCALED_RATIO)\\n            }\\n            if cond {\\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\\n                factor_ := div(mul(ZERO_TICK_SCALED_RATIO, _1E26), ratioX96)\\n            }\\n\\n            // put in https://www.wolframalpha.com/ whole equation: (1.0015^tick) * 2^96 * 10^26 / 79228162514264337593543950336\\n\\n            // for tick = 16384\\n            // ratioX96 = (1.0015^16384) * 2^96 = 3665252098134783297721995888537077351735\\n            // 3665252098134783297721995888537077351735 * 10^26 / 79228162514264337593543950336 =\\n            // 4626198540796508716348404308345255985.06131964639489434655721\\n            if iszero(lt(factor_, 4626198540796508716348404308345255985)) {\\n                tick := or(tick, 0x4000)\\n                factor_ := div(mul(factor_, _1E26), 4626198540796508716348404308345255985)\\n            }\\n            // for tick = 8192\\n            // ratioX96 = (1.0015^8192) * 2^96 = 17040868196391020479062776466509865\\n            // 17040868196391020479062776466509865 * 10^26 / 79228162514264337593543950336 =\\n            // 21508599537851153911767490449162.3037648642153898377655505172\\n            if iszero(lt(factor_, 21508599537851153911767490449162)) {\\n                tick := or(tick, 0x2000)\\n                factor_ := div(mul(factor_, _1E26), 21508599537851153911767490449162)\\n            }\\n            // for tick = 4096\\n            // ratioX96 = (1.0015^4096) * 2^96 = 36743933851015821532611831851150\\n            // 36743933851015821532611831851150 * 10^26 / 79228162514264337593543950336 =\\n            // 46377364670549310883002866648.9777607649742626173648716941385\\n            if iszero(lt(factor_, 46377364670549310883002866649)) {\\n                tick := or(tick, 0x1000)\\n                factor_ := div(mul(factor_, _1E26), 46377364670549310883002866649)\\n            }\\n            // for tick = 2048\\n            // ratioX96 = (1.0015^2048) * 2^96 = 1706210527034005899209104452335\\n            // 1706210527034005899209104452335 * 10^26 / 79228162514264337593543950336 =\\n            // 2153540449365864845468344760.06357108484096046743300420319322\\n            if iszero(lt(factor_, 2153540449365864845468344760)) {\\n                tick := or(tick, 0x800)\\n                factor_ := div(mul(factor_, _1E26), 2153540449365864845468344760)\\n            }\\n            // for tick = 1024\\n            // ratioX96 = (1.0015^1024) * 2^96 = 367668226692760093024536487236\\n            // 367668226692760093024536487236 * 10^26 / 79228162514264337593543950336 =\\n            // 464062544207767844008185024.950588990554136265212906454481127\\n            if iszero(lt(factor_, 464062544207767844008185025)) {\\n                tick := or(tick, 0x400)\\n                factor_ := div(mul(factor_, _1E26), 464062544207767844008185025)\\n            }\\n            // for tick = 512\\n            // ratioX96 = (1.0015^512) * 2^96 = 170674186729409605620119663668\\n            // 170674186729409605620119663668 * 10^26 / 79228162514264337593543950336 =\\n            // 215421109505955298802281577.031879604792139232258508172947569\\n            if iszero(lt(factor_, 215421109505955298802281577)) {\\n                tick := or(tick, 0x200)\\n                factor_ := div(mul(factor_, _1E26), 215421109505955298802281577)\\n            }\\n            // for tick = 256\\n            // ratioX96 = (1.0015^256) * 2^96 = 116285004205991934861656513301\\n            // 116285004205991934861656513301 * 10^26 / 79228162514264337593543950336 =\\n            // 146772309890508740607270614.667650899656438875541505058062410\\n            if iszero(lt(factor_, 146772309890508740607270615)) {\\n                tick := or(tick, 0x100)\\n                factor_ := div(mul(factor_, _1E26), 146772309890508740607270615)\\n            }\\n            // for tick = 128\\n            // ratioX96 = (1.0015^128) * 2^96 = 95984619659632141743747099590\\n            // 95984619659632141743747099590 * 10^26 / 79228162514264337593543950336 =\\n            // 121149622323187099817270416.157248837742741760456796835775887\\n            if iszero(lt(factor_, 121149622323187099817270416)) {\\n                tick := or(tick, 0x80)\\n                factor_ := div(mul(factor_, _1E26), 121149622323187099817270416)\\n            }\\n            // for tick = 64\\n            // ratioX96 = (1.0015^64) * 2^96 = 87204845308406958006717891124\\n            // 87204845308406958006717891124 * 10^26 / 79228162514264337593543950336 =\\n            // 110067989135437147685980801.568068573422377364214113968609839\\n            if iszero(lt(factor_, 110067989135437147685980801)) {\\n                tick := or(tick, 0x40)\\n                factor_ := div(mul(factor_, _1E26), 110067989135437147685980801)\\n            }\\n            // for tick = 32\\n            // ratioX96 = (1.0015^32) * 2^96 = 83120873769022354029916374475\\n            // 83120873769022354029916374475 * 10^26 / 79228162514264337593543950336 =\\n            // 104913292358707887270979599.831816586773651266562785765558183\\n            if iszero(lt(factor_, 104913292358707887270979600)) {\\n                tick := or(tick, 0x20)\\n                factor_ := div(mul(factor_, _1E26), 104913292358707887270979600)\\n            }\\n            // for tick = 16\\n            // ratioX96 = (1.0015^16) * 2^96 = 81151180492336368327184716176\\n            // 81151180492336368327184716176 * 10^26 / 79228162514264337593543950336 =\\n            // 102427189924701091191840927.762844039579442328381455567932128\\n            if iszero(lt(factor_, 102427189924701091191840928)) {\\n                tick := or(tick, 0x10)\\n                factor_ := div(mul(factor_, _1E26), 102427189924701091191840928)\\n            }\\n            // for tick = 8\\n            // ratioX96 = (1.0015^8) * 2^96 = 80183906840906820640659903620\\n            // 80183906840906820640659903620 * 10^26 / 79228162514264337593543950336 =\\n            // 101206318935480056907421312.890625\\n            if iszero(lt(factor_, 101206318935480056907421313)) {\\n                tick := or(tick, 0x8)\\n                factor_ := div(mul(factor_, _1E26), 101206318935480056907421313)\\n            }\\n            // for tick = 4\\n            // ratioX96 = (1.0015^4) * 2^96 = 79704602139525152702959747603\\n            // 79704602139525152702959747603 * 10^26 / 79228162514264337593543950336 =\\n            // 100601351350506250000000000\\n            if iszero(lt(factor_, 100601351350506250000000000)) {\\n                tick := or(tick, 0x4)\\n                factor_ := div(mul(factor_, _1E26), 100601351350506250000000000)\\n            }\\n            // for tick = 2\\n            // ratioX96 = (1.0015^2) * 2^96 = 79466025265172787701084167660\\n            // 79466025265172787701084167660 * 10^26 / 79228162514264337593543950336 =\\n            // 100300225000000000000000000\\n            if iszero(lt(factor_, 100300225000000000000000000)) {\\n                tick := or(tick, 0x2)\\n                factor_ := div(mul(factor_, _1E26), 100300225000000000000000000)\\n            }\\n            // for tick = 1\\n            // ratioX96 = (1.0015^1) * 2^96 = 79347004758035734099934266261\\n            // 79347004758035734099934266261 * 10^26 / 79228162514264337593543950336 =\\n            // 100150000000000000000000000\\n            if iszero(lt(factor_, 100150000000000000000000000)) {\\n                tick := or(tick, 0x1)\\n                factor_ := div(mul(factor_, _1E26), 100150000000000000000000000)\\n            }\\n            if iszero(cond) {\\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\\n                perfectRatioX96 := div(mul(ratioX96, _1E26), factor_)\\n            }\\n            if cond {\\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\\n                tick := not(tick)\\n                perfectRatioX96 := div(mul(ratioX96, factor_), 100150000000000000000000000)\\n            }\\n            // perfect ratio should always be <= ratioX96\\n            // not sure if it can ever be bigger but better to have extra checks\\n            if gt(perfectRatioX96, ratioX96) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc5c13deaa16bb036a4370c0e38c33445712e8e7da1c792018dd3dc4a641ea0c0\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/adminModule/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Structs {\\n    struct AddressBool {\\n        address addr;\\n        bool value;\\n    }\\n\\n    struct AddressUint256 {\\n        address addr;\\n        uint256 value;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 1\\n    struct RateDataV1Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\\n        uint256 kink;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink;\\n        ///\\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 2\\n    struct RateDataV2Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\\n        uint256 kink1;\\n        ///\\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\\n        uint256 kink2;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink1;\\n        ///\\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\\n        uint256 rateAtUtilizationKink2;\\n        ///\\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set token config\\n    struct TokenConfig {\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 fee;\\n        ///\\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 threshold;\\n        ///\\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\\n        uint256 maxUtilization;\\n    }\\n\\n    /// @notice struct to set user supply & withdrawal config\\n    struct UserSupplyConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration withdrawal limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseWithdrawalLimit;\\n    }\\n\\n    /// @notice struct to set user borrow & payback config\\n    struct UserBorrowConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which debt limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration debt limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseDebtCeiling;\\n        ///\\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 maxDebtCeiling;\\n    }\\n}\\n\",\"keccak256\":\"0x10353c70015f27b880125cefab806dbed24a4458f187da66964f3ef60488f757\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/liquidity/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Structs as AdminModuleStructs } from \\\"../../../liquidity/adminModule/structs.sol\\\";\\n\\nabstract contract Structs {\\n    struct RateData {\\n        uint256 version;\\n        AdminModuleStructs.RateDataV1Params rateDataV1;\\n        AdminModuleStructs.RateDataV2Params rateDataV2;\\n    }\\n\\n    struct OverallTokenData {\\n        uint256 borrowRate;\\n        uint256 supplyRate;\\n        uint256 fee; // revenue fee\\n        uint256 lastStoredUtilization;\\n        uint256 storageUpdateThreshold;\\n        uint256 lastUpdateTimestamp;\\n        uint256 supplyExchangePrice;\\n        uint256 borrowExchangePrice;\\n        uint256 supplyRawInterest;\\n        uint256 supplyInterestFree;\\n        uint256 borrowRawInterest;\\n        uint256 borrowInterestFree;\\n        uint256 totalSupply;\\n        uint256 totalBorrow;\\n        uint256 revenue;\\n        uint256 maxUtilization; // maximum allowed utilization\\n        RateData rateData;\\n    }\\n\\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\\n    struct UserSupplyData {\\n        bool modeWithInterest; // true if mode = with interest, false = without interest\\n        uint256 supply; // user supply amount\\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\\n        uint256 withdrawalLimit;\\n        uint256 lastUpdateTimestamp;\\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\\n        uint256 baseWithdrawalLimit;\\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\\n        uint256 withdrawableUntilLimit;\\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\\n    }\\n\\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\\n    struct UserBorrowData {\\n        bool modeWithInterest; // true if mode = with interest, false = without interest\\n        uint256 borrow; // user borrow amount\\n        uint256 borrowLimit;\\n        uint256 lastUpdateTimestamp;\\n        uint256 expandPercent;\\n        uint256 expandDuration;\\n        uint256 baseBorrowLimit;\\n        uint256 maxBorrowLimit;\\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\\n    }\\n}\\n\",\"keccak256\":\"0xf8a59b6c7963d0bd43be07db0c594e278f97e6dfa498dee8436e3707dd9f574e\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vault/iVaultResolver.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { Structs } from \\\"./structs.sol\\\";\\n\\ninterface IFluidVaultResolver {\\n    function vaultByNftId(uint nftId_) external view returns (address vault_);\\n\\n    function positionByNftId(\\n        uint nftId_\\n    ) external view returns (Structs.UserPosition memory userPosition_, Structs.VaultEntireData memory vaultData_);\\n\\n    function getVaultVariablesRaw(address vault_) external view returns (uint);\\n\\n    function getVaultVariables2Raw(address vault_) external view returns (uint);\\n\\n    function getTickHasDebtRaw(address vault_, int key_) external view returns (uint);\\n\\n    function getTickDataRaw(address vault_, int tick_) external view returns (uint);\\n\\n    function getBranchDataRaw(address vault_, uint branch_) external view returns (uint);\\n\\n    function getPositionDataRaw(address vault_, uint positionId_) external view returns (uint);\\n\\n    function getAllVaultsAddresses() external view returns (address[] memory vaults_);\\n\\n    function getVaultLiquidation(\\n        address vault_,\\n        uint tokenInAmt_\\n    ) external returns (Structs.LiquidationStruct memory liquidationData_);\\n\\n    function getVaultEntireData(address vault_) external view returns (Structs.VaultEntireData memory vaultData_);\\n}\\n\",\"keccak256\":\"0x8db2ba8c10b3f2a624ad2924ec5b59dbb805b42357eb98e9df6835963fff0634\",\"license\":\"MIT\"},\"contracts/periphery/resolvers/vault/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidVault } from \\\"../../../protocols/vault/interfaces/iVault.sol\\\";\\nimport { Structs as FluidLiquidityResolverStructs } from \\\"../liquidity/structs.sol\\\";\\n\\n// @dev Amounts are always in token amount for normal col / normal debt or in\\n// shares for Dex smart col / smart debt.\\ncontract Structs {\\n    struct Configs {\\n        // can be supplyRate instead if Vault Type is smart col. in that case if 1st bit == 1 then positive else negative\\n        uint16 supplyRateMagnifier;\\n        // can be borrowRate instead if Vault Type is smart debt. in that case if 1st bit == 1 then positive else negative\\n        uint16 borrowRateMagnifier;\\n        uint16 collateralFactor;\\n        uint16 liquidationThreshold;\\n        uint16 liquidationMaxLimit;\\n        uint16 withdrawalGap;\\n        uint16 liquidationPenalty;\\n        uint16 borrowFee;\\n        address oracle;\\n        // Oracle price is always debt per col, i.e. amount of debt for 1 col.\\n        // In case of Dex this price can be used to resolve shares values w.r.t. token0 or token1:\\n        // - T2: debt token per 1 col share\\n        // - T3: debt shares per 1 col token\\n        // - T4: debt shares per 1 col share\\n        uint oraclePriceOperate;\\n        uint oraclePriceLiquidate;\\n        address rebalancer;\\n        uint lastUpdateTimestamp;\\n    }\\n\\n    struct ExchangePricesAndRates {\\n        uint lastStoredLiquiditySupplyExchangePrice; // 0 in case of smart col\\n        uint lastStoredLiquidityBorrowExchangePrice; // 0 in case of smart debt\\n        uint lastStoredVaultSupplyExchangePrice;\\n        uint lastStoredVaultBorrowExchangePrice;\\n        uint liquiditySupplyExchangePrice; // set to 1e12 in case of smart col\\n        uint liquidityBorrowExchangePrice; // set to 1e12 in case of smart debt\\n        uint vaultSupplyExchangePrice;\\n        uint vaultBorrowExchangePrice;\\n        uint supplyRateLiquidity; // set to 0 in case of smart col. Must get per token through DexEntireData\\n        uint borrowRateLiquidity; // set to 0 in case of smart debt. Must get per token through DexEntireData\\n        // supplyRateVault or borrowRateVault:\\n        // - when normal col / debt: rate at liquidity + diff rewards or fee through magnifier (rewardsOrFeeRate below)\\n        // - when smart col / debt: rewards or fee rate at the vault itself. always == rewardsOrFeeRate below.\\n        // to get the full rates for vault when smart col / debt, combine with data from DexResolver:\\n        // - rateAtLiquidity for token0 or token1 (DexResolver)\\n        // - the rewards or fee rate at the vault (VaultResolver)\\n        // - the Dex APR (currently off-chain compiled through tracking swap events at the DEX)\\n        int supplyRateVault; // can be negative in case of smart col (meaning pay to supply)\\n        int borrowRateVault; // can be negative in case of smart debt (meaning get paid to borrow)\\n        // rewardsOrFeeRateSupply: rewards or fee rate in percent 1e2 precision (1% = 100, 100% = 10000).\\n        // positive rewards, negative fee.\\n        // for smart col vaults: supplyRateVault == supplyRateLiquidity.\\n        // for normal col vaults: relative percent to supplyRateLiquidity, e.g.:\\n        // when rewards: supplyRateLiquidity = 4%, rewardsOrFeeRateSupply = 20%, supplyRateVault = 4.8%.\\n        // when fee: supplyRateLiquidity = 4%, rewardsOrFeeRateSupply = -30%, supplyRateVault = 2.8%.\\n        int rewardsOrFeeRateSupply;\\n        // rewardsOrFeeRateBorrow: rewards or fee rate in percent 1e2 precision (1% = 100, 100% = 10000).\\n        // negative rewards, positive fee.\\n        // for smart debt vaults: borrowRateVault == borrowRateLiquidity.\\n        // for normal debt vaults: relative percent to borrowRateLiquidity, e.g.:\\n        // when rewards: borrowRateLiquidity = 4%, rewardsOrFeeRateBorrow = -20%, borrowRateVault = 3.2%.\\n        // when fee: borrowRateLiquidity = 4%, rewardsOrFeeRateBorrow = 30%, borrowRateVault = 5.2%.\\n        int rewardsOrFeeRateBorrow;\\n    }\\n\\n    struct TotalSupplyAndBorrow {\\n        uint totalSupplyVault;\\n        uint totalBorrowVault;\\n        uint totalSupplyLiquidityOrDex;\\n        uint totalBorrowLiquidityOrDex;\\n        uint absorbedSupply;\\n        uint absorbedBorrow;\\n    }\\n\\n    struct LimitsAndAvailability {\\n        // in case of DEX: withdrawable / borrowable amount of vault at DEX, BUT there could be that DEX can not withdraw\\n        // that much at Liquidity! So for DEX this must be combined with returned data in DexResolver.\\n        uint withdrawLimit;\\n        uint withdrawableUntilLimit;\\n        uint withdrawable;\\n        uint borrowLimit;\\n        uint borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\\n        uint borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\\n        uint borrowLimitUtilization; // borrow limit for `maxUtilization` config at Liquidity\\n        uint minimumBorrowing;\\n    }\\n\\n    struct CurrentBranchState {\\n        uint status; // if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\\n        int minimaTick;\\n        uint debtFactor;\\n        uint partials;\\n        uint debtLiquidity;\\n        uint baseBranchId;\\n        int baseBranchMinima;\\n    }\\n\\n    struct VaultState {\\n        uint totalPositions;\\n        int topTick;\\n        uint currentBranch;\\n        uint totalBranch;\\n        uint totalBorrow;\\n        uint totalSupply;\\n        CurrentBranchState currentBranchState;\\n    }\\n\\n    struct VaultEntireData {\\n        address vault;\\n        bool isSmartCol; // true if col token is a Fluid Dex\\n        bool isSmartDebt; // true if debt token is a Fluid Dex\\n        IFluidVault.ConstantViews constantVariables;\\n        Configs configs;\\n        ExchangePricesAndRates exchangePricesAndRates;\\n        TotalSupplyAndBorrow totalSupplyAndBorrow;\\n        LimitsAndAvailability limitsAndAvailability;\\n        VaultState vaultState;\\n        // liquidity related data such as supply amount, limits, expansion etc.\\n        // Also set for Dex, limits are in shares and same things apply as noted for LimitsAndAvailability above!\\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyData;\\n        // liquidity related data such as borrow amount, limits, expansion etc.\\n        // Also set for Dex, limits are in shares and same things apply as noted for LimitsAndAvailability above!\\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowData;\\n    }\\n\\n    struct UserPosition {\\n        uint nftId;\\n        address owner;\\n        bool isLiquidated;\\n        bool isSupplyPosition; // if true that means borrowing is 0\\n        int tick;\\n        uint tickId;\\n        uint beforeSupply;\\n        uint beforeBorrow;\\n        uint beforeDustBorrow;\\n        uint supply;\\n        uint borrow;\\n        uint dustBorrow;\\n    }\\n\\n    /// @dev liquidation related data\\n    /// @param vault address of vault\\n    /// @param token0In address of token in\\n    /// @param token0Out address of token out\\n    /// @param token1In address of token in (if smart debt)\\n    /// @param token1Out address of token out (if smart col)\\n    /// @param inAmt (without absorb liquidity) minimum of available liquidation\\n    /// @param outAmt (without absorb liquidity) expected token out, collateral to withdraw\\n    /// @param inAmtWithAbsorb (absorb liquidity included) minimum of available liquidation. In most cases it'll be same as inAmt but sometimes can be bigger.\\n    /// @param outAmtWithAbsorb (absorb liquidity included) expected token out, collateral to withdraw. In most cases it'll be same as outAmt but sometimes can be bigger.\\n    /// @param absorbAvailable true if absorb is available\\n    /// @dev Liquidity in with absirb will always be >= without asborb. Sometimes without asborb can provide better swaps,\\n    ///      sometimes with absirb can provide better swaps. But available in with absirb will always be >= One\\n    struct LiquidationStruct {\\n        address vault;\\n        address token0In;\\n        address token0Out;\\n        address token1In;\\n        address token1Out;\\n        // amounts in case of smart debt are in shares, otherwise token amounts.\\n        // smart col can not be liquidated so to exchange inAmt always use DexResolver DexState.tokenPerDebtShare\\n        // and tokenPerColShare for outAmt when Vault is smart col.\\n        uint inAmt;\\n        uint outAmt;\\n        uint inAmtWithAbsorb;\\n        uint outAmtWithAbsorb;\\n        bool absorbAvailable;\\n    }\\n\\n    struct AbsorbStruct {\\n        address vault;\\n        bool absorbAvailable;\\n    }\\n}\\n\",\"keccak256\":\"0x9920604f31459ced4f0353e37f98082368c6696cc892825d07f19afb457ee108\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vaultPositions/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Variables } from \\\"./variables.sol\\\";\\nimport { Structs } from \\\"./structs.sol\\\";\\nimport { IFluidVaultFactory } from \\\"../../../protocols/vault/interfaces/iVaultFactory.sol\\\";\\nimport { Structs as VaultResolverStructs } from \\\"../vault/structs.sol\\\";\\nimport { IFluidVaultResolver } from \\\"../vault/iVaultResolver.sol\\\";\\nimport { IFluidVault } from \\\"../../../protocols/vault/interfaces/iVault.sol\\\";\\nimport { TickMath } from \\\"../../../libraries/tickMath.sol\\\";\\n\\n/// @title Fluid Vault protocol Positions Resolver for all vault types.\\n/// @notice This contract resolves positions for Fluid Vaults, providing functionality to retrieve NFT IDs and positions for a given vault.\\ncontract FluidVaultPositionsResolver is Variables, Structs {\\n    /// @notice thrown if an input param address is zero\\n    error FluidVaultPositionsResolver__AddressZero();\\n\\n    /// @notice constructor sets the immutable vault resolver and vault factory address\\n    constructor(\\n        IFluidVaultResolver vaultResolver_,\\n        IFluidVaultFactory vaultFactory_\\n    ) Variables(vaultResolver_, vaultFactory_) {\\n        if (address(vaultResolver_) == address(0) || address(vaultFactory_) == address(0)) {\\n            revert FluidVaultPositionsResolver__AddressZero();\\n        }\\n    }\\n\\n    function getAllVaultNftIds(address vault_) public view returns (uint256[] memory nftIds_) {\\n        uint256 totalPositions_ = FACTORY.totalSupply();\\n\\n        /// get total positions for vault: Next 32 bits => 210-241 => Total positions\\n        uint256 totalVaultPositions_ = (VAULT_RESOLVER.getVaultVariablesRaw(vault_) >> 210) & 0xFFFFFFFF;\\n        nftIds_ = new uint256[](totalVaultPositions_);\\n\\n        // get nft Ids belonging to the vault_\\n        uint256 nftId_;\\n        uint256 j;\\n        for (uint256 i; i < totalPositions_; ) {\\n            nftId_ = FACTORY.tokenByIndex(i);\\n            unchecked {\\n                ++i;\\n            }\\n            if (_vaultByNftId(nftId_) == vault_) {\\n                nftIds_[j] = nftId_;\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n        }\\n    }\\n\\n    function getPositionsForNftIds(uint256[] memory nftIds_) public view returns (UserPosition[] memory positions_) {\\n        positions_ = new UserPosition[](nftIds_.length);\\n\\n        for (uint256 i; i < nftIds_.length; ++i) {\\n            address vault_ = _vaultByNftId(nftIds_[i]);\\n            if (vault_ == address(0)) {\\n                // should never happen but make sure it wouldn't lead to a revert\\n                positions_[i] = UserPosition({ nftId: nftIds_[i], owner: address(0), supply: 0, borrow: 0 });\\n            } else {\\n                (, , uint vaultSupplyExchangePrice_, uint vaultBorrowExchangePrice_) = IFluidVault(vault_)\\n                    .updateExchangePrices(VAULT_RESOLVER.getVaultVariables2Raw(vault_));\\n\\n                positions_[i] = _getVaultPosition(\\n                    vault_,\\n                    nftIds_[i],\\n                    vaultSupplyExchangePrice_,\\n                    vaultBorrowExchangePrice_\\n                );\\n            }\\n        }\\n    }\\n\\n    function getAllVaultPositions(address vault_) public view returns (UserPosition[] memory positions_) {\\n        if (vault_ != address(0)) {\\n            // exchange prices are always the same for the same vault\\n            (, , uint vaultSupplyExchangePrice_, uint vaultBorrowExchangePrice_) = IFluidVault(vault_)\\n                .updateExchangePrices(VAULT_RESOLVER.getVaultVariables2Raw(vault_));\\n\\n            uint256 totalPositions_ = FACTORY.totalSupply();\\n\\n            // get total positions for vault: Next 32 bits => 210-241 => Total positions\\n            uint256 totalVaultPositions_ = (VAULT_RESOLVER.getVaultVariablesRaw(vault_) >> 210) & 0xFFFFFFFF;\\n            positions_ = new UserPosition[](totalVaultPositions_);\\n\\n            uint256 nftId_;\\n            uint256 j;\\n            for (uint256 i; i < totalPositions_; ) {\\n                nftId_ = FACTORY.tokenByIndex(i);\\n                unchecked {\\n                    ++i;\\n                }\\n\\n                if (_vaultByNftId(nftId_) == vault_) {\\n                    positions_[j] = _getVaultPosition(\\n                        vault_,\\n                        nftId_,\\n                        vaultSupplyExchangePrice_,\\n                        vaultBorrowExchangePrice_\\n                    );\\n\\n                    unchecked {\\n                        ++j;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function _vaultByNftId(uint nftId_) internal view returns (address vault_) {\\n        uint tokenConfig_ = FACTORY.readFromStorage(keccak256(abi.encode(nftId_, 3)));\\n        vault_ = FACTORY.getVaultAddress((tokenConfig_ >> 192) & X32);\\n    }\\n\\n    function _getVaultPosition(\\n        address vault_,\\n        uint nftId_,\\n        uint vaultSupplyExchangePrice_,\\n        uint vaultBorrowExchangePrice_\\n    ) internal view returns (UserPosition memory userPosition_) {\\n        // @dev code below based on VaultResolver `positionByNftId()`\\n        userPosition_.nftId = nftId_;\\n        userPosition_.owner = FACTORY.ownerOf(nftId_);\\n\\n        uint positionData_ = VAULT_RESOLVER.getPositionDataRaw(vault_, nftId_);\\n\\n        userPosition_.supply = (positionData_ >> 45) & X64;\\n        // Converting big number into normal number\\n        userPosition_.supply = (userPosition_.supply >> 8) << (userPosition_.supply & X8);\\n\\n        if ((positionData_ & 1) != 1) {\\n            // not just a supply position\\n\\n            int tick_ = (positionData_ & 2) == 2 ? int((positionData_ >> 2) & X19) : -int((positionData_ >> 2) & X19);\\n            userPosition_.borrow = (TickMath.getRatioAtTick(int24(tick_)) * userPosition_.supply) >> 96;\\n\\n            uint tickData_ = VAULT_RESOLVER.getTickDataRaw(vault_, tick_);\\n            uint tickId_ = (positionData_ >> 21) & X24;\\n            if (((tickData_ & 1) == 1) || (((tickData_ >> 1) & X24) > tickId_)) {\\n                (tick_, userPosition_.borrow, userPosition_.supply, , ) = IFluidVault(vault_).fetchLatestPosition(\\n                    tick_,\\n                    tickId_,\\n                    userPosition_.borrow,\\n                    tickData_\\n                );\\n            }\\n\\n            uint dustBorrow_ = (positionData_ >> 109) & X64;\\n            // Converting big number into normal number\\n            dustBorrow_ = (dustBorrow_ >> 8) << (dustBorrow_ & X8);\\n\\n            if (userPosition_.borrow > dustBorrow_) {\\n                userPosition_.borrow = userPosition_.borrow - dustBorrow_;\\n            } else {\\n                userPosition_.borrow = 0;\\n            }\\n\\n            userPosition_.borrow = (userPosition_.borrow * vaultBorrowExchangePrice_) / 1e12;\\n        }\\n\\n        userPosition_.supply = (userPosition_.supply * vaultSupplyExchangePrice_) / 1e12;\\n    }\\n}\\n\",\"keccak256\":\"0x5c19f2cc12527043c345f31b4520442ec22a27d05cb35ebb042a9aef0a8831c1\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vaultPositions/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ncontract Structs {\\n    struct UserPosition {\\n        uint nftId;\\n        address owner;\\n        uint supply;\\n        uint borrow;\\n    }\\n}\\n\",\"keccak256\":\"0x7c7d70501ec27863eab620195f377c69bc08e833f8bc1a028e7d56438a27ebfa\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vaultPositions/variables.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidVaultResolver } from \\\"../vault/iVaultResolver.sol\\\";\\nimport { IFluidVaultFactory } from \\\"../../../protocols/vault/interfaces/iVaultFactory.sol\\\";\\n\\ncontract Variables {\\n    IFluidVaultResolver public immutable VAULT_RESOLVER;\\n    IFluidVaultFactory public immutable FACTORY;\\n\\n    // 30 bits (used for partials mainly)\\n    uint internal constant X8 = 0xff;\\n    uint internal constant X19 = 0x7ffff;\\n    uint internal constant X24 = 0xffffff;\\n    uint internal constant X32 = 0xffffffff;\\n    uint internal constant X64 = 0xffffffffffffffff;\\n\\n    constructor(IFluidVaultResolver vaultResolver_, IFluidVaultFactory vaultFactory_) {\\n        VAULT_RESOLVER = vaultResolver_;\\n        FACTORY = vaultFactory_;\\n    }\\n}\\n\",\"keccak256\":\"0x2676e73b184510309ae1e92e3657974e8e2739012b67d915b2683565cacf0705\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/interfaces/iVault.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\\ninterface IFluidVault {\\n    /// @notice returns the vault id\\n    function VAULT_ID() external view returns (uint256);\\n\\n    /// @notice returns the vault id\\n    function TYPE() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct Tokens {\\n        address token0;\\n        address token1;\\n    }\\n\\n    struct ConstantViews {\\n        address liquidity;\\n        address factory;\\n        address operateImplementation;\\n        address adminImplementation;\\n        address secondaryImplementation;\\n        address deployer; // address which deploys oracle\\n        address supply; // either liquidity layer or DEX protocol\\n        address borrow; // either liquidity layer or DEX protocol\\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\\n        uint256 vaultId;\\n        uint256 vaultType;\\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n    }\\n\\n    /// @notice returns all Vault constants\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    /// @notice fetches the latest user position after a liquidation\\n    function fetchLatestPosition(\\n        int256 positionTick_,\\n        uint256 positionTickId_,\\n        uint256 positionRawDebt_,\\n        uint256 tickData_\\n    )\\n        external\\n        view\\n        returns (\\n            int256, // tick\\n            uint256, // raw debt\\n            uint256, // raw collateral\\n            uint256, // branchID_\\n            uint256 // branchData_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices\\n    function updateExchangePrices(\\n        uint256 vaultVariables2_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices and writes them to storage\\n    function updateExchangePricesOnStorage()\\n        external\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice returns the liquidity contract address\\n    function LIQUIDITY() external view returns (address);\\n\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n\\n    function rebalance(\\n        int colToken0MinMax_,\\n        int colToken1MinMax_,\\n        int debtToken0MinMax_,\\n        int debtToken1MinMax_\\n    ) external payable returns (int supplyAmt_, int borrowAmt_);\\n\\n    /// @notice reverts with FluidLiquidateResult\\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\\n}\\n\",\"keccak256\":\"0xdd764652f8451a71d2f2006b2572fccd9c21f1d64196869bfc291d10f151f0c6\",\"license\":\"MIT\"},\"contracts/protocols/vault/interfaces/iVaultFactory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { IERC721Enumerable } from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\ninterface IFluidVaultFactory is IERC721Enumerable {\\n    /// @notice Minting an NFT Vault for the user\\n    function mint(uint256 vaultId_, address user_) external returns (uint256 tokenId_);\\n\\n    /// @notice returns owner of Vault which is also an NFT\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /// @notice Global auth is auth for all vaults\\n    function isGlobalAuth(address auth_) external view returns (bool);\\n\\n    /// @notice Vault auth is auth for a specific vault\\n    function isVaultAuth(address vault_, address auth_) external view returns (bool);\\n\\n    /// @notice Total vaults deployed.\\n    function totalVaults() external view returns (uint256);\\n\\n    /// @notice Compute vaultAddress\\n    function getVaultAddress(uint256 vaultId) external view returns (address);\\n\\n    /// @notice read uint256 `result_` for a storage `slot_` key\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n}\\n\",\"keccak256\":\"0xc4a0caed89a8670e1ccf159d03fa23bb29f69c579f522bb0e33b1b5cb106c40d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c06040523480156200001157600080fd5b50604051620019273803806200192783398101604081905262000034916200009e565b6001600160a01b03808316608081905290821660a05215806200005e57506001600160a01b038116155b156200007d576040516302fdcc4f60e31b815260040160405180910390fd5b5050620000dd565b6001600160a01b03811681146200009b57600080fd5b50565b60008060408385031215620000b257600080fd5b8251620000bf8162000085565b6020840151909250620000d28162000085565b809150509250929050565b60805160a0516117cb6200015c60003960008181607101528181610410015281816105e40152818161081f01528181610a3c01528181610b4301528181610c4d0152610d4701526000818160e2015281816102dc015281816104eb01528181610749015281816108fa01528181610e1e0152610f5501526117cb6000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c80637f3e2b48116100505780637f3e2b48146100dd578063bd7b630d14610104578063f752d7571461012457600080fd5b80632dd310001461006c5780635bbf0e14146100bd575b600080fd5b6100937f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b6100d06100cb3660046113d4565b610137565b6040516100b491906114b0565b6100937f000000000000000000000000000000000000000000000000000000000000000081565b61011761011236600461154f565b61040a565b6040516100b4919061156c565b6100d061013236600461154f565b6106d9565b6060815167ffffffffffffffff811115610153576101536113a5565b6040519080825280602002602001820160405280156101c557816020015b6101b2604051806080016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b8152602001906001900390816101715790505b50905060005b82518110156104045760006101f88483815181106101eb576101eb6115b0565b6020026020010151610b3e565b905073ffffffffffffffffffffffffffffffffffffffff811661028a576040518060800160405280858481518110610232576102326115b0565b60200260200101518152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525083838151811061027a5761027a6115b0565b60200260200101819052506103f3565b6040517feb1db01800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8083166004830181905260009283926309f0d8cb917f00000000000000000000000000000000000000000000000000000000000000009091169063eb1db01890602401602060405180830381865afa158015610325573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061034991906115df565b6040518263ffffffff1660e01b815260040161036791815260200190565b608060405180830381865afa158015610384573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a891906115f8565b9350935050506103d3838786815181106103c4576103c46115b0565b60200260200101518484610cd4565b8585815181106103e5576103e56115b0565b602002602001018190525050505b506103fd8161165d565b90506101cb565b50919050565b606060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610479573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061049d91906115df565b6040517f03e883e000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff858116600483015291925060009160d2917f0000000000000000000000000000000000000000000000000000000000000000909116906303e883e090602401602060405180830381865afa158015610534573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055891906115df565b901c63ffffffff1690508067ffffffffffffffff81111561057b5761057b6113a5565b6040519080825280602002602001820160405280156105a4578160200160208202803683370190505b50925060008060005b848110156106cf576040517f4f6ccce7000000000000000000000000000000000000000000000000000000008152600481018290527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690634f6ccce790602401602060405180830381865afa158015610640573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061066491906115df565b925060010173ffffffffffffffffffffffffffffffffffffffff871661068984610b3e565b73ffffffffffffffffffffffffffffffffffffffff16036106ca57828683815181106106b7576106b76115b0565b6020026020010181815250508160010191505b6105ad565b5050505050919050565b606073ffffffffffffffffffffffffffffffffffffffff821615610b39576040517feb1db01800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8084166004830181905260009283926309f0d8cb917f00000000000000000000000000000000000000000000000000000000000000009091169063eb1db01890602401602060405180830381865afa158015610792573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107b691906115df565b6040518263ffffffff1660e01b81526004016107d491815260200190565b608060405180830381865afa1580156107f1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061081591906115f8565b93509350505060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610888573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108ac91906115df565b6040517f03e883e000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff878116600483015291925060009160d2917f0000000000000000000000000000000000000000000000000000000000000000909116906303e883e090602401602060405180830381865afa158015610943573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061096791906115df565b901c63ffffffff1690508067ffffffffffffffff81111561098a5761098a6113a5565b6040519080825280602002602001820160405280156109fc57816020015b6109e9604051806080016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b8152602001906001900390816109a85790505b50945060008060005b84811015610b31576040517f4f6ccce7000000000000000000000000000000000000000000000000000000008152600481018290527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690634f6ccce790602401602060405180830381865afa158015610a98573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610abc91906115df565b925060010173ffffffffffffffffffffffffffffffffffffffff8916610ae184610b3e565b73ffffffffffffffffffffffffffffffffffffffff1603610b2c57610b0889848989610cd4565b888381518110610b1a57610b1a6115b0565b60200260200101819052508160010191505b610a05565b505050505050505b919050565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b5c736e4846003604051602001610b9d92919091825260ff16602082015260400190565b604051602081830303815290604052805190602001206040518263ffffffff1660e01b8152600401610bd191815260200190565b602060405180830381865afa158015610bee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c1291906115df565b6040517fe6bd26a200000000000000000000000000000000000000000000000000000000815263ffffffff60c083901c1660048201529091507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063e6bd26a290602401602060405180830381865afa158015610ca9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ccd9190611695565b9392505050565b610d15604051806080016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b8381526040517f6352211e000000000000000000000000000000000000000000000000000000008152600481018590527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690636352211e90602401602060405180830381865afa158015610da3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc79190611695565b73ffffffffffffffffffffffffffffffffffffffff90811660208301526040517fcbc7be650000000000000000000000000000000000000000000000000000000081528682166004820152602481018690526000917f0000000000000000000000000000000000000000000000000000000000000000169063cbc7be6590604401602060405180830381865afa158015610e65573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8991906115df565b66ffffffffffffff603582901c1660ff602d83901c161b6040840152905060018082161461111557600081600216600214610ed557610ed0600283901c6207ffff166116b2565b610ee0565b6207ffff600283901c165b905060608360400151610ef58360020b611143565b610eff91906116ea565b901c60608401526040517f168a11c200000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8881166004830152602482018390526000917f00000000000000000000000000000000000000000000000000000000000000009091169063168a11c290604401602060405180830381865afa158015610f9e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fc291906115df565b9050601583901c62ffffff1660018083161480610fe757508062ffffff600184901c16115b156110a55760608501516040517f22348cc7000000000000000000000000000000000000000000000000000000008152600481018590526024810183905260448101919091526064810183905273ffffffffffffffffffffffffffffffffffffffff8a16906322348cc79060840160a060405180830381865afa158015611072573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110969190611707565b50506040880152606087015292505b606085015166ffffffffffffff607586901c1660ff606d87901c161b908110156110e3578086606001516110d99190611747565b60608701526110eb565b600060608701525b64e8d4a5100087876060015161110191906116ea565b61110b919061175a565b6060870152505050505b64e8d4a5100084836040015161112b91906116ea565b611135919061175a565b604083015250949350505050565b600060ff82901d80831803617fff81111561115d57600080fd5b700100000000000000000000000000000000600182161561118b57506fff9dd7de423466c20352b1246ce4856f5b60028216156111aa576fff3bd55f4488ad277531fa1c725a66d00260801c5b60048216156111c9576ffe78410fd6498b73cb96a6917f8532590260801c5b60088216156111e8576ffcf2d9987c9be178ad5bfeffaa1232730260801c5b6010821615611207576ff9ef02c4529258b057769680fc6601b30260801c5b6020821615611226576ff402d288133a85a17784a411f7aba0820260801c5b6040821615611245576fe895615b5beb6386553757b0352bda900260801c5b6080821615611264576fd34f17a00ffa00a8309940a15930391a0260801c5b610100821615611284576fae6b7961714e20548d88ea5123f9a0ff0260801c5b6102008216156112a4576f76d6461f27082d74e0feed3b388c0ca10260801c5b6104008216156112c4576f372a3bfe0745d8b6b19d985d9a8b85bb0260801c5b6108008216156112e4576f0be32cbee48979763cf7247dd7bb539d0260801c5b611000821615611303576e8d4f70c9ff4924dac37612d1e2921e0260801c5b612000821615611321576d4e009ae5519380809a02ca7aec770260801c5b61400082161561133d576b17c45e641b6e95dee056ff100260801c5b600091507f8000000000000000000000000000000000000000000000000000000000000000841661139b577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0463ffffffff81161561139b57600191505b60201c0192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208083850312156113e757600080fd5b823567ffffffffffffffff808211156113ff57600080fd5b818501915085601f83011261141357600080fd5b813581811115611425576114256113a5565b8060051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f83011681018181108582111715611468576114686113a5565b60405291825284820192508381018501918883111561148657600080fd5b938501935b828510156114a45784358452938501939285019261148b565b98975050505050505050565b602080825282518282018190526000919060409081850190868401855b8281101561151d578151805185528681015173ffffffffffffffffffffffffffffffffffffffff1687860152858101518686015260609081015190850152608090930192908501906001016114cd565b5091979650505050505050565b73ffffffffffffffffffffffffffffffffffffffff8116811461154c57600080fd5b50565b60006020828403121561156157600080fd5b8135610ccd8161152a565b6020808252825182820181905260009190848201906040850190845b818110156115a457835183529284019291840191600101611588565b50909695505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000602082840312156115f157600080fd5b5051919050565b6000806000806080858703121561160e57600080fd5b505082516020840151604085015160609095015191969095509092509050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361168e5761168e61162e565b5060010190565b6000602082840312156116a757600080fd5b8151610ccd8161152a565b60007f800000000000000000000000000000000000000000000000000000000000000082036116e3576116e361162e565b5060000390565b80820281158282048414176117015761170161162e565b92915050565b600080600080600060a0868803121561171f57600080fd5b5050835160208501516040860151606087015160809097015192989197509594509092509050565b818103818111156117015761170161162e565b600082611790577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b50049056fea26469706673582212208d6722975ac3b9add038abcb221d3d75728873efae26402c653f7afcd512baf964736f6c63430008150033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100675760003560e01c80637f3e2b48116100505780637f3e2b48146100dd578063bd7b630d14610104578063f752d7571461012457600080fd5b80632dd310001461006c5780635bbf0e14146100bd575b600080fd5b6100937f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b6100d06100cb3660046113d4565b610137565b6040516100b491906114b0565b6100937f000000000000000000000000000000000000000000000000000000000000000081565b61011761011236600461154f565b61040a565b6040516100b4919061156c565b6100d061013236600461154f565b6106d9565b6060815167ffffffffffffffff811115610153576101536113a5565b6040519080825280602002602001820160405280156101c557816020015b6101b2604051806080016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b8152602001906001900390816101715790505b50905060005b82518110156104045760006101f88483815181106101eb576101eb6115b0565b6020026020010151610b3e565b905073ffffffffffffffffffffffffffffffffffffffff811661028a576040518060800160405280858481518110610232576102326115b0565b60200260200101518152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525083838151811061027a5761027a6115b0565b60200260200101819052506103f3565b6040517feb1db01800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8083166004830181905260009283926309f0d8cb917f00000000000000000000000000000000000000000000000000000000000000009091169063eb1db01890602401602060405180830381865afa158015610325573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061034991906115df565b6040518263ffffffff1660e01b815260040161036791815260200190565b608060405180830381865afa158015610384573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a891906115f8565b9350935050506103d3838786815181106103c4576103c46115b0565b60200260200101518484610cd4565b8585815181106103e5576103e56115b0565b602002602001018190525050505b506103fd8161165d565b90506101cb565b50919050565b606060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610479573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061049d91906115df565b6040517f03e883e000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff858116600483015291925060009160d2917f0000000000000000000000000000000000000000000000000000000000000000909116906303e883e090602401602060405180830381865afa158015610534573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055891906115df565b901c63ffffffff1690508067ffffffffffffffff81111561057b5761057b6113a5565b6040519080825280602002602001820160405280156105a4578160200160208202803683370190505b50925060008060005b848110156106cf576040517f4f6ccce7000000000000000000000000000000000000000000000000000000008152600481018290527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690634f6ccce790602401602060405180830381865afa158015610640573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061066491906115df565b925060010173ffffffffffffffffffffffffffffffffffffffff871661068984610b3e565b73ffffffffffffffffffffffffffffffffffffffff16036106ca57828683815181106106b7576106b76115b0565b6020026020010181815250508160010191505b6105ad565b5050505050919050565b606073ffffffffffffffffffffffffffffffffffffffff821615610b39576040517feb1db01800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8084166004830181905260009283926309f0d8cb917f00000000000000000000000000000000000000000000000000000000000000009091169063eb1db01890602401602060405180830381865afa158015610792573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107b691906115df565b6040518263ffffffff1660e01b81526004016107d491815260200190565b608060405180830381865afa1580156107f1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061081591906115f8565b93509350505060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610888573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108ac91906115df565b6040517f03e883e000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff878116600483015291925060009160d2917f0000000000000000000000000000000000000000000000000000000000000000909116906303e883e090602401602060405180830381865afa158015610943573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061096791906115df565b901c63ffffffff1690508067ffffffffffffffff81111561098a5761098a6113a5565b6040519080825280602002602001820160405280156109fc57816020015b6109e9604051806080016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b8152602001906001900390816109a85790505b50945060008060005b84811015610b31576040517f4f6ccce7000000000000000000000000000000000000000000000000000000008152600481018290527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690634f6ccce790602401602060405180830381865afa158015610a98573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610abc91906115df565b925060010173ffffffffffffffffffffffffffffffffffffffff8916610ae184610b3e565b73ffffffffffffffffffffffffffffffffffffffff1603610b2c57610b0889848989610cd4565b888381518110610b1a57610b1a6115b0565b60200260200101819052508160010191505b610a05565b505050505050505b919050565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b5c736e4846003604051602001610b9d92919091825260ff16602082015260400190565b604051602081830303815290604052805190602001206040518263ffffffff1660e01b8152600401610bd191815260200190565b602060405180830381865afa158015610bee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c1291906115df565b6040517fe6bd26a200000000000000000000000000000000000000000000000000000000815263ffffffff60c083901c1660048201529091507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063e6bd26a290602401602060405180830381865afa158015610ca9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ccd9190611695565b9392505050565b610d15604051806080016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b8381526040517f6352211e000000000000000000000000000000000000000000000000000000008152600481018590527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690636352211e90602401602060405180830381865afa158015610da3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc79190611695565b73ffffffffffffffffffffffffffffffffffffffff90811660208301526040517fcbc7be650000000000000000000000000000000000000000000000000000000081528682166004820152602481018690526000917f0000000000000000000000000000000000000000000000000000000000000000169063cbc7be6590604401602060405180830381865afa158015610e65573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8991906115df565b66ffffffffffffff603582901c1660ff602d83901c161b6040840152905060018082161461111557600081600216600214610ed557610ed0600283901c6207ffff166116b2565b610ee0565b6207ffff600283901c165b905060608360400151610ef58360020b611143565b610eff91906116ea565b901c60608401526040517f168a11c200000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8881166004830152602482018390526000917f00000000000000000000000000000000000000000000000000000000000000009091169063168a11c290604401602060405180830381865afa158015610f9e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fc291906115df565b9050601583901c62ffffff1660018083161480610fe757508062ffffff600184901c16115b156110a55760608501516040517f22348cc7000000000000000000000000000000000000000000000000000000008152600481018590526024810183905260448101919091526064810183905273ffffffffffffffffffffffffffffffffffffffff8a16906322348cc79060840160a060405180830381865afa158015611072573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110969190611707565b50506040880152606087015292505b606085015166ffffffffffffff607586901c1660ff606d87901c161b908110156110e3578086606001516110d99190611747565b60608701526110eb565b600060608701525b64e8d4a5100087876060015161110191906116ea565b61110b919061175a565b6060870152505050505b64e8d4a5100084836040015161112b91906116ea565b611135919061175a565b604083015250949350505050565b600060ff82901d80831803617fff81111561115d57600080fd5b700100000000000000000000000000000000600182161561118b57506fff9dd7de423466c20352b1246ce4856f5b60028216156111aa576fff3bd55f4488ad277531fa1c725a66d00260801c5b60048216156111c9576ffe78410fd6498b73cb96a6917f8532590260801c5b60088216156111e8576ffcf2d9987c9be178ad5bfeffaa1232730260801c5b6010821615611207576ff9ef02c4529258b057769680fc6601b30260801c5b6020821615611226576ff402d288133a85a17784a411f7aba0820260801c5b6040821615611245576fe895615b5beb6386553757b0352bda900260801c5b6080821615611264576fd34f17a00ffa00a8309940a15930391a0260801c5b610100821615611284576fae6b7961714e20548d88ea5123f9a0ff0260801c5b6102008216156112a4576f76d6461f27082d74e0feed3b388c0ca10260801c5b6104008216156112c4576f372a3bfe0745d8b6b19d985d9a8b85bb0260801c5b6108008216156112e4576f0be32cbee48979763cf7247dd7bb539d0260801c5b611000821615611303576e8d4f70c9ff4924dac37612d1e2921e0260801c5b612000821615611321576d4e009ae5519380809a02ca7aec770260801c5b61400082161561133d576b17c45e641b6e95dee056ff100260801c5b600091507f8000000000000000000000000000000000000000000000000000000000000000841661139b577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0463ffffffff81161561139b57600191505b60201c0192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208083850312156113e757600080fd5b823567ffffffffffffffff808211156113ff57600080fd5b818501915085601f83011261141357600080fd5b813581811115611425576114256113a5565b8060051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f83011681018181108582111715611468576114686113a5565b60405291825284820192508381018501918883111561148657600080fd5b938501935b828510156114a45784358452938501939285019261148b565b98975050505050505050565b602080825282518282018190526000919060409081850190868401855b8281101561151d578151805185528681015173ffffffffffffffffffffffffffffffffffffffff1687860152858101518686015260609081015190850152608090930192908501906001016114cd565b5091979650505050505050565b73ffffffffffffffffffffffffffffffffffffffff8116811461154c57600080fd5b50565b60006020828403121561156157600080fd5b8135610ccd8161152a565b6020808252825182820181905260009190848201906040850190845b818110156115a457835183529284019291840191600101611588565b50909695505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000602082840312156115f157600080fd5b5051919050565b6000806000806080858703121561160e57600080fd5b505082516020840151604085015160609095015191969095509092509050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361168e5761168e61162e565b5060010190565b6000602082840312156116a757600080fd5b8151610ccd8161152a565b60007f800000000000000000000000000000000000000000000000000000000000000082036116e3576116e361162e565b5060000390565b80820281158282048414176117015761170161162e565b92915050565b600080600080600060a0868803121561171f57600080fd5b5050835160208501516040860151606087015160809097015192989197509594509092509050565b818103818111156117015761170161162e565b600082611790577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b50049056fea26469706673582212208d6722975ac3b9add038abcb221d3d75728873efae26402c653f7afcd512baf964736f6c63430008150033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "title": "Fluid Vault protocol Positions Resolver for all vault types.",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "FluidVaultPositionsResolver__AddressZero()": [
        {
          "notice": "thrown if an input param address is zero"
        }
      ]
    },
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "constructor sets the immutable vault resolver and vault factory address"
      }
    },
    "notice": "This contract resolves positions for Fluid Vaults, providing functionality to retrieve NFT IDs and positions for a given vault.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}