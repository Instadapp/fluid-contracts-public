{
  "address": "0x00525e0332488a83119804541DA487e7CbAc40c2",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "liquidity_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vaultFactory_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "deployer_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vaultAdminImplementation_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vaultSecondaryImplementation_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vaultOperateImplementation_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vaultMainImplementation_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "colLiquidated",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "debtLiquidated",
          "type": "uint256"
        }
      ],
      "name": "FluidLiquidateResult",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "errorId_",
          "type": "uint256"
        }
      ],
      "name": "FluidVaultError",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "vaultId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "supplyToken",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "smartDebt",
          "type": "address"
        }
      ],
      "name": "VaultT3Deployed",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "ADDRESS_THIS",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ADMIN_IMPLEMENTATION",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DEPLOYER",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "LIQUIDITY",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MINI_DEPLOYER",
      "outputs": [
        {
          "internalType": "contract MiniDeployer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SECONDARY_IMPLEMENTATION",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VAULT_T3_CREATIONCODE_MAIN",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VAULT_T3_CREATIONCODE_MAIN_OPERATE",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "mainCreationCode",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "operateCreationCode",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "supplyToken_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "smartDebt_",
          "type": "address"
        }
      ],
      "name": "vaultT3",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "vaultCreationBytecode_",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x7bc433e116ffc8d41a79f7a2f39c8de6696bfc854561cab8688a038a35252f3b",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x0Ed35B1609Ec45c7079E80d11149a52717e4859A",
    "contractAddress": null,
    "transactionIndex": 98,
    "gasUsed": "1306243",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000001000000000000000000000000000000000000020000000400000000000800000000000000000000004000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000002",
    "blockHash": "0x8e793afd4374a922c18f27844cafd2745f1378a2b541c952223dd12995daf0af",
    "transactionHash": "0x7bc433e116ffc8d41a79f7a2f39c8de6696bfc854561cab8688a038a35252f3b",
    "logs": [
      {
        "transactionIndex": 98,
        "blockNumber": 25817463,
        "transactionHash": "0x7bc433e116ffc8d41a79f7a2f39c8de6696bfc854561cab8688a038a35252f3b",
        "address": "0x7DA48BEF99721483B322558B3AD02Eb07907f756",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000324c5dc1fc42c7a4d43d92df1eba58a54d13bf2d"
        ],
        "data": "0x",
        "logIndex": 203,
        "blockHash": "0x8e793afd4374a922c18f27844cafd2745f1378a2b541c952223dd12995daf0af"
      }
    ],
    "blockNumber": 25817463,
    "cumulativeGasUsed": "17292603",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x52Aa899454998Be5b000Ad077a46Bbe360F4e497",
    "0x324c5Dc1fC42c7a4D43d92df1eBA58a54d13Bf2d",
    "0x4EC7b668BAF70d4A4b0FC7941a7708A07b6d45Be",
    "0x22A6d8814F4F2B0EbbF50170f0E93e36bb11c3a4",
    "0xB6FF36e7d04e6017E0323F1f92A8184370d48907",
    "0x81Fc5FD8A6b95414D452e0Cd8658c7F71Bd7146f",
    "0xc7cd1Ca8f60e54CC0d99739fF074152c585765Fe"
  ],
  "numDeployments": 1,
  "solcInputHash": "7ded33794b695102c601d6aba03eb026",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidity_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultFactory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deployer_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultAdminImplementation_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultSecondaryImplementation_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultOperateImplementation_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultMainImplementation_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"colLiquidated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtLiquidated\",\"type\":\"uint256\"}],\"name\":\"FluidLiquidateResult\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorId_\",\"type\":\"uint256\"}],\"name\":\"FluidVaultError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplyToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"smartDebt\",\"type\":\"address\"}],\"name\":\"VaultT3Deployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADDRESS_THIS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ADMIN_IMPLEMENTATION\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPLOYER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINI_DEPLOYER\",\"outputs\":[{\"internalType\":\"contract MiniDeployer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDARY_IMPLEMENTATION\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT_T3_CREATIONCODE_MAIN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT_T3_CREATIONCODE_MAIN_OPERATE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainCreationCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operateCreationCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"supplyToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"smartDebt_\",\"type\":\"address\"}],\"name\":\"vaultT3\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"vaultCreationBytecode_\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"VaultT3Deployed(address,uint256,address,address)\":{\"params\":{\"smartDebt\":\"The address of the dex for which the smart debt is used.\",\"supplyToken\":\"The address of the supply token.\",\"vault\":\"The address of the newly deployed vault.\",\"vaultId\":\"The id of the newly deployed vault.\"}}},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"each vault type has different vaultAdminImplementation but same vaultSecondaryImplementatio\"},\"mainCreationCode()\":{\"details\":\"Retrieves the creation code for the main contract\"},\"operateCreationCode()\":{\"details\":\"Retrieves the creation code for the Operate contract\"}},\"version\":1},\"userdoc\":{\"errors\":{\"FluidLiquidateResult(uint256,uint256)\":[{\"notice\":\"used to simulate liquidation to find the maximum liquidatable amounts\"}]},\"events\":{\"VaultT3Deployed(address,uint256,address,address)\":{\"notice\":\"Emitted when a new vaultT3 is deployed.\"}},\"kind\":\"user\",\"methods\":{\"ADDRESS_THIS()\":{\"notice\":\"address of this contract\"},\"ADMIN_IMPLEMENTATION()\":{\"notice\":\"address of Admin implementation\"},\"LIQUIDITY()\":{\"notice\":\"address of liquidity contract\"},\"MINI_DEPLOYER()\":{\"notice\":\"address of MiniDeployer Contract\"},\"SECONDARY_IMPLEMENTATION()\":{\"notice\":\"address of Secondary implementation\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocols/vault/factory/deploymentLogics/vaultT3Logic.sol\":\"FluidVaultT3DeploymentLogic\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xab28a56179c1db258c9bf5235b382698cb650debecb51b23d12be9e241374b68\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd1556954440b31c97a142c6ba07d5cade45f96fafd52091d33a14ebe365aecbf\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/libraries/dexSlotsLink.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\\nlibrary DexSlotsLink {\\n    /// @dev storage slot for variables at Dex\\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\\n    /// @dev storage slot for variables2 at Dex\\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\\n    /// @dev storage slot for total supply shares at Dex\\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\\n    /// @dev storage slot for user supply mapping at Dex\\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\\n    /// @dev storage slot for total borrow shares at Dex\\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\\n    /// @dev storage slot for user borrow mapping at Dex\\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\\n    /// @dev storage slot for oracle mapping at Dex\\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\\n    /// @dev storage slot for range and threshold shifts at Dex\\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\\n    /// @dev storage slot for center price shift at Dex\\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\\n\\n    // --------------------------------\\n    // @dev stacked uint256 storage slots bits position data for each:\\n\\n    // UserSupplyData\\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\\n\\n    // UserBorrowData\\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\\n\\n    // --------------------------------\\n\\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\\n    function calculateDoubleMappingStorageSlot(\\n        uint256 slot_,\\n        address key1_,\\n        address key2_\\n    ) internal pure returns (bytes32) {\\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\\n        return keccak256(abi.encode(key2_, intermediateSlot_));\\n    }\\n}\\n\",\"keccak256\":\"0xf1d6550d83fb0155a26655234922c9bdf4a1bbcf7a3ca767e9123d367a795307\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/fluidProtocolTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ninterface IFluidProtocol {\\n    function TYPE() external view returns (uint256);\\n}\\n\\n/// @notice implements helper methods to filter Fluid protocols by a certain type\\nlibrary FluidProtocolTypes {\\n    uint256 internal constant VAULT_T1_TYPE = 10000; // VaultT1 borrow protocol type vaults\\n    uint256 internal constant VAULT_T2_SMART_COL_TYPE = 20000; // DEX protocol type vault\\n    uint256 internal constant VAULT_T3_SMART_DEBT_TYPE = 30000; // DEX protocol type vault\\n    uint256 internal constant VAULT_T4_SMART_COL_SMART_DEBT_TYPE = 40000; // DEX protocol type vault\\n\\n    /// @dev filters input `addresses_` by protocol `type_`. Input addresses must be actual Fluid protocols, otherwise\\n    ///      they would be wrongly assumed to be VaultT1 even if they are not Fluid VaultT1 smart contracts.\\n    ///      `type_` must be a listed constant type of this library.\\n    ///      Example usage is to filter all vault addresses at the Vault factory by a certain type, e.g. to not include\\n    ///      DEX protocol type vaults.\\n    function filterBy(address[] memory addresses_, uint256 type_) internal view returns (address[] memory filtered_) {\\n        uint256 curType_;\\n        uint256 filteredProtocols_ = addresses_.length;\\n        for (uint256 i; i < addresses_.length; ) {\\n            try IFluidProtocol(addresses_[i]).TYPE() returns (uint256 protocolType_) {\\n                curType_ = protocolType_;\\n            } catch {\\n                curType_ = VAULT_T1_TYPE;\\n            }\\n\\n            if (curType_ != type_) {\\n                addresses_[i] = address(0);\\n                --filteredProtocols_;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        filtered_ = new address[](filteredProtocols_);\\n        uint256 index_;\\n        unchecked {\\n            for (uint256 i; i < addresses_.length; ) {\\n                if (addresses_[i] != address(0)) {\\n                    filtered_[index_] = addresses_[i];\\n                    ++index_;\\n                }\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x98868cc272fea53dbd4504e02df4f4fcd709a4144a8b37a85513edd638bd073b\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/liquiditySlotsLink.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\\nlibrary LiquiditySlotsLink {\\n    /// @dev storage slot for status at Liquidity\\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\\n    /// @dev storage slot for auths mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\\n    /// @dev storage slot for guardians mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\\n    /// @dev storage slot for user class mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\\n    /// @dev storage slot for rateData mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\\n    /// @dev storage slot for totalAmounts mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\\n    /// @dev storage slot for user supply double mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\\n    /// @dev storage slot for user borrow double mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\\n    /// @dev storage slot for listed tokens array at Liquidity\\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\\n    /// @dev storage slot for listed tokens array at Liquidity\\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\\n\\n    // --------------------------------\\n    // @dev stacked uint256 storage slots bits position data for each:\\n\\n    // ExchangePricesAndConfig\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\\n\\n    // RateData:\\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\\n    // RateData: V1\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\\n    // RateData: V2\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\\n\\n    // TotalAmounts\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\\n\\n    // UserSupplyData\\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\\n\\n    // UserBorrowData\\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\\n\\n    // Configs2\\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\\n\\n    // --------------------------------\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\\n    function calculateDoubleMappingStorageSlot(\\n        uint256 slot_,\\n        address key1_,\\n        address key2_\\n    ) internal pure returns (bytes32) {\\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\\n        return keccak256(abi.encode(key2_, intermediateSlot_));\\n    }\\n}\\n\",\"keccak256\":\"0x0ae3e1d231bb6c14b54fc1f5ffa306edc0ac827a6a92279c77c0c09627fe08ae\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/interfaces/iDexT1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IFluidDexT1 {\\n    error FluidDexError(uint256 errorId);\\n\\n    /// @notice used to simulate swap to find the output amount\\n    error FluidDexSwapResult(uint256 amountOut);\\n\\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\\n\\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\\n\\n    error FluidDexLiquidityOutput(uint256 shares);\\n\\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\\n\\n    /// @notice returns the dex id\\n    function DEX_ID() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct Implementations {\\n        address shift;\\n        address admin;\\n        address colOperations;\\n        address debtOperations;\\n        address perfectOperationsAndOracle;\\n    }\\n\\n    struct ConstantViews {\\n        uint256 dexId;\\n        address liquidity;\\n        address factory;\\n        Implementations implementations;\\n        address deployerContract;\\n        address token0;\\n        address token1;\\n        bytes32 supplyToken0Slot;\\n        bytes32 borrowToken0Slot;\\n        bytes32 supplyToken1Slot;\\n        bytes32 borrowToken1Slot;\\n        bytes32 exchangePriceToken0Slot;\\n        bytes32 exchangePriceToken1Slot;\\n        uint256 oracleMapping;\\n    }\\n\\n    struct ConstantViews2 {\\n        uint token0NumeratorPrecision;\\n        uint token0DenominatorPrecision;\\n        uint token1NumeratorPrecision;\\n        uint token1DenominatorPrecision;\\n    }\\n\\n    struct PricesAndExchangePrice {\\n        uint lastStoredPrice; // last stored price in 1e27 decimals\\n        uint centerPrice; // last stored price in 1e27 decimals\\n        uint upperRange; // price at upper range in 1e27 decimals\\n        uint lowerRange; // price at lower range in 1e27 decimals\\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\\n        uint supplyToken0ExchangePrice;\\n        uint borrowToken0ExchangePrice;\\n        uint supplyToken1ExchangePrice;\\n        uint borrowToken1ExchangePrice;\\n    }\\n\\n    struct CollateralReserves {\\n        uint token0RealReserves;\\n        uint token1RealReserves;\\n        uint token0ImaginaryReserves;\\n        uint token1ImaginaryReserves;\\n    }\\n\\n    struct DebtReserves {\\n        uint token0Debt;\\n        uint token1Debt;\\n        uint token0RealReserves;\\n        uint token1RealReserves;\\n        uint token0ImaginaryReserves;\\n        uint token1ImaginaryReserves;\\n    }\\n\\n    function getCollateralReserves(\\n        uint geometricMean_,\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint token0SupplyExchangePrice_,\\n        uint token1SupplyExchangePrice_\\n    ) external view returns (CollateralReserves memory c_);\\n\\n    function getDebtReserves(\\n        uint geometricMean_,\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint token0BorrowExchangePrice_,\\n        uint token1BorrowExchangePrice_\\n    ) external view returns (DebtReserves memory d_);\\n\\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\\n    function getPricesAndExchangePrices() external;\\n\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\\n\\n    struct Oracle {\\n        uint twap1by0; // TWAP price\\n        uint lowestPrice1by0; // lowest price point\\n        uint highestPrice1by0; // highest price point\\n        uint twap0by1; // TWAP price\\n        uint lowestPrice0by1; // lowest price point\\n        uint highestPrice0by1; // highest price point\\n    }\\n\\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountIn_ The exact amount of input tokens to swap\\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\\n    /// @return amountOut_ The amount of output tokens received from the swap\\n    function swapIn(\\n        bool swap0to1_,\\n        uint256 amountIn_,\\n        uint256 amountOutMin_,\\n        address to_\\n    ) external payable returns (uint256 amountOut_);\\n\\n    /// @dev Swap tokens with perfect amount out\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountOut_ The exact amount of tokens to receive after swap\\n    /// @param amountInMax_ Maximum amount of tokens to swap in\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\\n    /// @return amountIn_ The amount of input tokens used for the swap\\n    function swapOut(\\n        bool swap0to1_,\\n        uint256 amountOut_,\\n        uint256 amountInMax_,\\n        address to_\\n    ) external payable returns (uint256 amountIn_);\\n\\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\\n    /// @param shares_ The number of shares to mint\\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\\n    /// @return token0Amt_ Amount of token0 deposited\\n    /// @return token1Amt_ Amount of token1 deposited\\n    function depositPerfect(\\n        uint shares_,\\n        uint maxToken0Deposit_,\\n        uint maxToken1Deposit_,\\n        bool estimate_\\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\\n    /// @param shares_ The number of shares to withdraw\\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\\n    /// @return token0Amt_ The amount of token0 withdrawn\\n    /// @return token1Amt_ The amount of token1 withdrawn\\n    function withdrawPerfect(\\n        uint shares_,\\n        uint minToken0Withdraw_,\\n        uint minToken1Withdraw_,\\n        address to_\\n    ) external returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\\n    /// @param shares_ The number of shares to borrow\\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\\n    /// @return token0Amt_ Amount of token0 borrowed\\n    /// @return token1Amt_ Amount of token1 borrowed\\n    function borrowPerfect(\\n        uint shares_,\\n        uint minToken0Borrow_,\\n        uint minToken1Borrow_,\\n        address to_\\n    ) external returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\\n    /// @param shares_ The number of shares to pay back\\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\\n    /// @return token0Amt_ Amount of token0 paid back\\n    /// @return token1Amt_ Amount of token1 paid back\\n    function paybackPerfect(\\n        uint shares_,\\n        uint maxToken0Payback_,\\n        uint maxToken1Payback_,\\n        bool estimate_\\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\\n    /// @param token0Amt_ The amount of token0 to deposit\\n    /// @param token1Amt_ The amount of token1 to deposit\\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\\n    /// @return shares_ The amount of shares minted for the deposit\\n    function deposit(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint minSharesAmt_,\\n        bool estimate_\\n    ) external payable returns (uint shares_);\\n\\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\\n    /// @param token0Amt_ The amount of token0 to withdraw\\n    /// @param token1Amt_ The amount of token1 to withdraw\\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\\n    /// @return shares_ The number of shares burned for the withdrawal\\n    function withdraw(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint maxSharesAmt_,\\n        address to_\\n    ) external returns (uint shares_);\\n\\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\\n    /// @param token0Amt_ The amount of token0 to borrow\\n    /// @param token1Amt_ The amount of token1 to borrow\\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\\n    function borrow(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint maxSharesAmt_,\\n        address to_\\n    ) external returns (uint shares_);\\n\\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\\n    /// @param token0Amt_ The amount of token0 to payback\\n    /// @param token1Amt_ The amount of token1 to payback\\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\\n    /// @return shares_ The amount of borrow shares burned for the payback\\n    function payback(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint minSharesAmt_,\\n        bool estimate_\\n    ) external payable returns (uint shares_);\\n\\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\\n    /// @param shares_ The number of shares to burn for withdrawal\\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\\n    function withdrawPerfectInOneToken(\\n        uint shares_,\\n        uint minToken0_,\\n        uint minToken1_,\\n        address to_\\n    ) external returns (\\n        uint withdrawAmt_\\n    );\\n\\n    /// @dev This function allows users to payback their debt with perfect shares in one token\\n    /// @param shares_ The number of shares to burn for payback\\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\\n    function paybackPerfectInOneToken(\\n        uint shares_,\\n        uint maxToken0_,\\n        uint maxToken1_,\\n        bool estimate_\\n    ) external payable returns (\\n        uint paybackAmt_\\n    );\\n\\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\\n    /// but the difference due to interest will be super low so this difference is ignored\\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\\n    /// @return currentPrice_ price of pool after the most recent swap\\n    function oraclePrice(\\n        uint[] memory secondsAgos_\\n    ) external view returns (\\n        Oracle[] memory twaps_,\\n        uint currentPrice_\\n    );\\n}\\n\",\"keccak256\":\"0xa405007cdd45409412ce0fe02a991cadbae17760bc15402c839375505f69d7b2\",\"license\":\"MIT\"},\"contracts/protocols/vault/error.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Error {\\n    error FluidVaultError(uint256 errorId_);\\n\\n    /// @notice used to simulate liquidation to find the maximum liquidatable amounts\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n}\\n\",\"keccak256\":\"0x3109fe35234c0428642d43e70b56bcdbbfeef1d9e5ca29f4c8b8a181d7b8d83c\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary ErrorTypes {\\n    /***********************************|\\n    |           Vault Factory           | \\n    |__________________________________*/\\n\\n    uint256 internal constant VaultFactory__InvalidOperation = 30001;\\n    uint256 internal constant VaultFactory__Unauthorized = 30002;\\n    uint256 internal constant VaultFactory__SameTokenNotAllowed = 30003;\\n    uint256 internal constant VaultFactory__InvalidParams = 30004;\\n    uint256 internal constant VaultFactory__InvalidVault = 30005;\\n    uint256 internal constant VaultFactory__InvalidVaultAddress = 30006;\\n    uint256 internal constant VaultFactory__OnlyDelegateCallAllowed = 30007;\\n\\n    /***********************************|\\n    |            Vault                  | \\n    |__________________________________*/\\n\\n    /// @notice thrown at reentrancy\\n    uint256 internal constant Vault__AlreadyEntered = 31001;\\n\\n    /// @notice thrown when user sends deposit & borrow amount as 0\\n    uint256 internal constant Vault__InvalidOperateAmount = 31002;\\n\\n    /// @notice thrown when msg.value is not in sync with native token deposit or payback\\n    uint256 internal constant Vault__InvalidMsgValueOperate = 31003;\\n\\n    /// @notice thrown when msg.sender is not the owner of the vault\\n    uint256 internal constant Vault__NotAnOwner = 31004;\\n\\n    /// @notice thrown when user's position does not exist. Sending the wrong index from the frontend\\n    uint256 internal constant Vault__TickIsEmpty = 31005;\\n\\n    /// @notice thrown when the user's position is above CF and the user tries to make it more risky by trying to withdraw or borrow\\n    uint256 internal constant Vault__PositionAboveCF = 31006;\\n\\n    /// @notice thrown when the top tick is not initialized. Happens if the vault is totally new or all the user's left\\n    uint256 internal constant Vault__TopTickDoesNotExist = 31007;\\n\\n    /// @notice thrown when msg.value in liquidate is not in sync payback\\n    uint256 internal constant Vault__InvalidMsgValueLiquidate = 31008;\\n\\n    /// @notice thrown when slippage is more on liquidation than what the liquidator sent\\n    uint256 internal constant Vault__ExcessSlippageLiquidation = 31009;\\n\\n    /// @notice thrown when msg.sender is not the rebalancer/reserve contract\\n    uint256 internal constant Vault__NotRebalancer = 31010;\\n\\n    /// @notice thrown when NFT of one vault interacts with the NFT of other vault\\n    uint256 internal constant Vault__NftNotOfThisVault = 31011;\\n\\n    /// @notice thrown when the token is not initialized on the liquidity contract\\n    uint256 internal constant Vault__TokenNotInitialized = 31012;\\n\\n    /// @notice thrown when admin updates fallback if a non-auth calls vault\\n    uint256 internal constant Vault__NotAnAuth = 31013;\\n\\n    /// @notice thrown in operate when user tries to witdhraw more collateral than deposited\\n    uint256 internal constant Vault__ExcessCollateralWithdrawal = 31014;\\n\\n    /// @notice thrown in operate when user tries to payback more debt than borrowed\\n    uint256 internal constant Vault__ExcessDebtPayback = 31015;\\n\\n    /// @notice thrown when user try to withdrawal more than operate's withdrawal limit\\n    uint256 internal constant Vault__WithdrawMoreThanOperateLimit = 31016;\\n\\n    /// @notice thrown when caller of liquidityCallback is not Liquidity\\n    uint256 internal constant Vault__InvalidLiquidityCallbackAddress = 31017;\\n\\n    /// @notice thrown when reentrancy is not already on\\n    uint256 internal constant Vault__NotEntered = 31018;\\n\\n    /// @notice thrown when someone directly calls operate or secondary implementation contract\\n    uint256 internal constant Vault__OnlyDelegateCallAllowed = 31019;\\n\\n    /// @notice thrown when the safeTransferFrom for a token amount failed\\n    uint256 internal constant Vault__TransferFromFailed = 31020;\\n\\n    /// @notice thrown when exchange price overflows while updating on storage\\n    uint256 internal constant Vault__ExchangePriceOverFlow = 31021;\\n\\n    /// @notice thrown when debt to liquidate amt is sent wrong\\n    uint256 internal constant Vault__InvalidLiquidationAmt = 31022;\\n\\n    /// @notice thrown when user debt or collateral goes above 2**128 or below -2**128\\n    uint256 internal constant Vault__UserCollateralDebtExceed = 31023;\\n\\n    /// @notice thrown if on liquidation branch debt becomes lower than 100\\n    uint256 internal constant Vault__BranchDebtTooLow = 31024;\\n\\n    /// @notice thrown when tick's debt is less than 10000\\n    uint256 internal constant Vault__TickDebtTooLow = 31025;\\n\\n    /// @notice thrown when the received new liquidity exchange price is of unexpected value (< than the old one)\\n    uint256 internal constant Vault__LiquidityExchangePriceUnexpected = 31026;\\n\\n    /// @notice thrown when user's debt is less than 10000\\n    uint256 internal constant Vault__UserDebtTooLow = 31027;\\n\\n    /// @notice thrown when on only payback and only deposit the ratio of position increases\\n    uint256 internal constant Vault__InvalidPaybackOrDeposit = 31028;\\n\\n    /// @notice thrown when liquidation just happens of a single partial or when there's nothing to liquidate\\n    uint256 internal constant Vault__InvalidLiquidation = 31029;\\n\\n    /// @notice thrown when msg.value is sent wrong in rebalance\\n    uint256 internal constant Vault__InvalidMsgValueInRebalance = 31030;\\n\\n    /// @notice thrown when nothing rebalanced\\n    uint256 internal constant Vault__NothingToRebalance = 31031;\\n\\n    /// @notice thrown on unforseen liquidation scenarios. Might never come in use.\\n    uint256 internal constant Vault__LiquidationReverts = 31032;\\n\\n    /// @notice thrown when oracle price is > 1e54\\n    uint256 internal constant Vault__InvalidOraclePrice = 31033;\\n\\n    /// @notice thrown when constants are not set properly via contructor\\n    uint256 internal constant Vault__ImproperConstantsSetup = 31034;\\n\\n    /// @notice thrown when externally calling fetchLatestPosition function\\n    uint256 internal constant Vault__FetchLatestPositionFailed = 31035;\\n\\n    /// @notice thrown when dex callback is not from dex\\n    uint256 internal constant Vault__InvalidDexCallbackAddress = 31036;\\n\\n    /// @notice thrown when dex callback is already set\\n    uint256 internal constant Vault__DexFromAddressAlreadySet = 31037;\\n\\n    /// @notice thrown when an invalid min / max amounts config is passed to rebalance()\\n    uint256 internal constant Vault__InvalidMinMaxInRebalance = 31038;\\n\\n    /***********************************|\\n    |              ERC721               | \\n    |__________________________________*/\\n\\n    uint256 internal constant ERC721__InvalidParams = 32001;\\n    uint256 internal constant ERC721__Unauthorized = 32002;\\n    uint256 internal constant ERC721__InvalidOperation = 32003;\\n    uint256 internal constant ERC721__UnsafeRecipient = 32004;\\n    uint256 internal constant ERC721__OutOfBoundsIndex = 32005;\\n\\n    /***********************************|\\n    |            Vault Admin            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when admin tries to setup invalid value which are crossing limits\\n    uint256 internal constant VaultAdmin__ValueAboveLimit = 33001;\\n\\n    /// @notice when someone directly calls admin implementation contract\\n    uint256 internal constant VaultAdmin__OnlyDelegateCallAllowed = 33002;\\n\\n    /// @notice thrown when auth sends NFT ID as 0 while collecting dust debt\\n    uint256 internal constant VaultAdmin__NftIdShouldBeNonZero = 33003;\\n\\n    /// @notice thrown when trying to collect dust debt of NFT which is not of this vault\\n    uint256 internal constant VaultAdmin__NftNotOfThisVault = 33004;\\n\\n    /// @notice thrown when dust debt of NFT is 0, meaning nothing to collect\\n    uint256 internal constant VaultAdmin__DustDebtIsZero = 33005;\\n\\n    /// @notice thrown when final debt after liquidation is not 0, meaning position 100% liquidated\\n    uint256 internal constant VaultAdmin__FinalDebtShouldBeZero = 33006;\\n\\n    /// @notice thrown when NFT is not liquidated state\\n    uint256 internal constant VaultAdmin__NftNotLiquidated = 33007;\\n\\n    /// @notice thrown when total absorbed dust debt is 0\\n    uint256 internal constant VaultAdmin__AbsorbedDustDebtIsZero = 33008;\\n\\n    /// @notice thrown when address is set as 0\\n    uint256 internal constant VaultAdmin__AddressZeroNotAllowed = 33009;\\n\\n    /***********************************|\\n    |            Vault Rewards          | \\n    |__________________________________*/\\n\\n    uint256 internal constant VaultRewards__Unauthorized = 34001;\\n    uint256 internal constant VaultRewards__AddressZero = 34002;\\n    uint256 internal constant VaultRewards__InvalidParams = 34003;\\n    uint256 internal constant VaultRewards__NewMagnifierSameAsOldMagnifier = 34004;\\n    uint256 internal constant VaultRewards__NotTheInitiator = 34005;\\n    uint256 internal constant VaultRewards__NotTheGovernance = 34006;\\n    uint256 internal constant VaultRewards__AlreadyStarted = 34007;\\n    uint256 internal constant VaultRewards__RewardsNotStartedOrEnded = 34008;\\n    uint256 internal constant VaultRewards__InvalidStartTime = 34009;\\n    uint256 internal constant VaultRewards__AlreadyEnded = 34010;\\n\\n    /***********************************|\\n    |          Vault DEX Types          | \\n    |__________________________________*/\\n\\n    uint256 internal constant VaultDex__InvalidOperateAmount = 35001;\\n    uint256 internal constant VaultDex__DebtSharesPaidMoreThanAvailableLiquidation = 35002;\\n\\n    /***********************************|\\n    |        Vault Borrow Rewards       | \\n    |__________________________________*/\\n\\n    uint256 internal constant VaultBorrowRewards__Unauthorized = 36001;\\n    uint256 internal constant VaultBorrowRewards__AddressZero = 36002;\\n    uint256 internal constant VaultBorrowRewards__InvalidParams = 36003;\\n    uint256 internal constant VaultBorrowRewards__NewMagnifierSameAsOldMagnifier = 36004;\\n    uint256 internal constant VaultBorrowRewards__NotTheInitiator = 36005;\\n    uint256 internal constant VaultBorrowRewards__NotTheGovernance = 36006;\\n    uint256 internal constant VaultBorrowRewards__AlreadyStarted = 36007;\\n    uint256 internal constant VaultBorrowRewards__RewardsNotStartedOrEnded = 36008;\\n    uint256 internal constant VaultBorrowRewards__InvalidStartTime = 36009;\\n    uint256 internal constant VaultBorrowRewards__AlreadyEnded = 36010;\\n}\\n\",\"keccak256\":\"0x60266494213793e62a94cf7989487939e4e88aeb052150c4dc17dbfb1648693d\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/factory/deploymentHelpers/miniDeployer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Owned } from \\\"solmate/src/auth/Owned.sol\\\";\\n\\n/// @title MiniDeployer\\n/// @notice A contract that allows deployers to deploy any contract by passing the contract data in bytes\\n/// @dev The main objective of this contract is to avoid storing contract addresses in our protocols which requires 160 bits of storage\\n///      Instead, we can just store the nonce & deployment of this address to calculate the address realtime using \\\"AddressCalcs\\\" library\\ncontract MiniDeployer is Owned {\\n    /// @notice Thrown when an invalid operation is attempted\\n    error MiniDeployer__InvalidOperation();\\n\\n    /// @notice Emitted when a new contract is deployed\\n    event LogContractDeployed(address indexed contractAddress);\\n\\n    /// @notice Constructor to initialize the contract\\n    /// @param owner_ The address of the contract owner\\n    constructor(address owner_) Owned(owner_) {}\\n\\n    /// @notice Internal function to deploy a contract\\n    /// @param bytecode_ The bytecode of the contract to deploy\\n    /// @return address_ The address of the deployed contract\\n    /// @dev Uses inline assembly for efficient deployment\\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\\n        if (bytecode_.length == 0) {\\n            revert MiniDeployer__InvalidOperation();\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\\n        }\\n        if (address_ == address(0)) {\\n            revert MiniDeployer__InvalidOperation();\\n        }\\n    }\\n\\n    /// @notice Deploys a new contract\\n    /// @param contractCode_ The bytecode of the contract to deploy\\n    /// @return contractAddress_ The address of the deployed contract\\n    /// @dev Decrements the deployer's allowed deployments count if not the owner\\n    function deployContract(bytes calldata contractCode_) external onlyOwner returns (address contractAddress_) {\\n        contractAddress_ = _deploy(contractCode_);\\n\\n        emit LogContractDeployed(contractAddress_);\\n    }\\n}\\n\",\"keccak256\":\"0xe2477b35f959992a710b8eb589baa5d346799e524adaeb5a03abe5ac469b1ca3\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/factory/deploymentLogics/vaultT3Logic.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { SSTORE2 } from \\\"solmate/src/utils/SSTORE2.sol\\\";\\nimport { MiniDeployer } from \\\"../deploymentHelpers/miniDeployer.sol\\\";\\nimport { ErrorTypes } from \\\"../../errorTypes.sol\\\";\\nimport { Error } from \\\"../../error.sol\\\";\\nimport { IFluidVaultFactory } from \\\"../../interfaces/iVaultFactory.sol\\\";\\nimport { LiquiditySlotsLink } from \\\"../../../../libraries/liquiditySlotsLink.sol\\\";\\nimport { DexSlotsLink } from \\\"../../../../libraries/dexSlotsLink.sol\\\";\\nimport { FluidProtocolTypes } from \\\"../../../../libraries/fluidProtocolTypes.sol\\\";\\nimport { IFluidVaultT3 } from \\\"../../interfaces/iVaultT3.sol\\\";\\nimport { IFluidDexT1 } from \\\"../../../dex/interfaces/iDexT1.sol\\\";\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n}\\n\\ncontract FluidVaultT3DeploymentLogic is Error {\\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @notice address of liquidity contract\\n    address public immutable LIQUIDITY;\\n\\n    address public immutable DEPLOYER;\\n\\n    /// @notice address of MiniDeployer Contract\\n    MiniDeployer public immutable MINI_DEPLOYER;\\n\\n    /// @notice address of Admin implementation\\n    address public immutable ADMIN_IMPLEMENTATION;\\n\\n    /// @notice address of Secondary implementation\\n    address public immutable SECONDARY_IMPLEMENTATION;\\n\\n    address public immutable VAULT_T3_CREATIONCODE_MAIN_OPERATE;\\n\\n    address public immutable VAULT_T3_CREATIONCODE_MAIN;\\n\\n    /// @notice address of this contract\\n    address public immutable ADDRESS_THIS;\\n\\n    /// @notice Emitted when a new vaultT3 is deployed.\\n    /// @param vault The address of the newly deployed vault.\\n    /// @param vaultId The id of the newly deployed vault.\\n    /// @param supplyToken The address of the supply token.\\n    /// @param smartDebt The address of the dex for which the smart debt is used.\\n    event VaultT3Deployed(\\n        address indexed vault,\\n        uint256 vaultId,\\n        address indexed supplyToken,\\n        address indexed smartDebt\\n    );\\n\\n    /// @dev each vault type has different vaultAdminImplementation but same vaultSecondaryImplementatio\\n    constructor(\\n        address liquidity_,\\n        address vaultFactory_,\\n        address deployer_,\\n        address vaultAdminImplementation_,\\n        address vaultSecondaryImplementation_,\\n        address vaultOperateImplementation_,\\n        address vaultMainImplementation_\\n    ) {\\n        LIQUIDITY = liquidity_;\\n        DEPLOYER = deployer_;\\n        ADMIN_IMPLEMENTATION = vaultAdminImplementation_;\\n        SECONDARY_IMPLEMENTATION = vaultSecondaryImplementation_;\\n\\n        // Deploy mini deployer\\n        MINI_DEPLOYER = new MiniDeployer(vaultFactory_);\\n\\n        VAULT_T3_CREATIONCODE_MAIN_OPERATE = vaultOperateImplementation_;\\n\\n        VAULT_T3_CREATIONCODE_MAIN = vaultMainImplementation_;\\n\\n        ADDRESS_THIS = address(this);\\n    }\\n\\n    function vaultT3(address supplyToken_, address smartDebt_) external returns (bytes memory vaultCreationBytecode_) {\\n        if (address(this) == ADDRESS_THIS) revert FluidVaultError(ErrorTypes.VaultFactory__OnlyDelegateCallAllowed);\\n\\n        // verifying that supply token is valid\\n        if (supplyToken_ != NATIVE_TOKEN) IERC20(supplyToken_).decimals();\\n\\n        // also verifies that dex address is valid\\n        IFluidDexT1.ConstantViews memory smartDebtConstants_ = IFluidDexT1(smartDebt_).constantsView();\\n\\n        IFluidVaultT3.ConstantViews memory constants_;\\n        constants_.liquidity = LIQUIDITY;\\n        constants_.factory = address(this);\\n        constants_.deployer = DEPLOYER;\\n        constants_.adminImplementation = ADMIN_IMPLEMENTATION;\\n        constants_.secondaryImplementation = SECONDARY_IMPLEMENTATION;\\n        constants_.supply = LIQUIDITY;\\n        constants_.supplyToken.token0 = supplyToken_;\\n        // supplyToken.token1 will remain 0\\n        constants_.borrow = smartDebt_;\\n        constants_.borrowToken.token0 = smartDebtConstants_.token0;\\n        constants_.borrowToken.token1 = smartDebtConstants_.token1;\\n        constants_.vaultId = IFluidVaultFactory(address(this)).totalVaults();\\n        constants_.vaultType = FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE;\\n\\n        address vault_ = IFluidVaultFactory(address(this)).getVaultAddress(constants_.vaultId);\\n\\n        constants_ = _calculateVaultSlots(constants_, vault_);\\n\\n        vaultCreationBytecode_ = abi.encodePacked(\\n            SSTORE2.read(VAULT_T3_CREATIONCODE_MAIN_OPERATE),\\n            abi.encode(constants_)\\n        );\\n\\n        address operateImplementation_ = MINI_DEPLOYER.deployContract(vaultCreationBytecode_);\\n\\n        constants_.operateImplementation = operateImplementation_;\\n\\n        vaultCreationBytecode_ = abi.encodePacked(SSTORE2.read(VAULT_T3_CREATIONCODE_MAIN), abi.encode(constants_));\\n\\n        emit VaultT3Deployed(vault_, constants_.vaultId, supplyToken_, smartDebt_);\\n\\n        return vaultCreationBytecode_;\\n    }\\n\\n    /// @dev Retrieves the creation code for the Operate contract\\n    function operateCreationCode() public view returns (bytes memory) {\\n        return SSTORE2.read(VAULT_T3_CREATIONCODE_MAIN_OPERATE);\\n    }\\n\\n    /// @dev Retrieves the creation code for the main contract\\n    function mainCreationCode() public view returns (bytes memory) {\\n        return SSTORE2.read(VAULT_T3_CREATIONCODE_MAIN);\\n    }\\n\\n    function _calculateVaultSlots(\\n        IFluidVaultT3.ConstantViews memory constants_,\\n        address vault_\\n    ) private pure returns (IFluidVaultT3.ConstantViews memory) {\\n        constants_.supplyExchangePriceSlot = LiquiditySlotsLink.calculateMappingStorageSlot(\\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\\n            constants_.supplyToken.token0\\n        );\\n        constants_.borrowExchangePriceSlot = bytes32(0);\\n        constants_.userSupplySlot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\\n            LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\\n            vault_,\\n            constants_.supplyToken.token0\\n        );\\n        constants_.userBorrowSlot = DexSlotsLink.calculateMappingStorageSlot(\\n            DexSlotsLink.DEX_USER_BORROW_MAPPING_SLOT,\\n            vault_\\n        );\\n        return constants_;\\n    }\\n}\\n\",\"keccak256\":\"0x985c8ee02b758dcfd1dbfa8041aeec33d61d5d5559d1a5f0090cfbf95fc94384\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/interfaces/iVault.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\\ninterface IFluidVault {\\n    /// @notice returns the vault id\\n    function VAULT_ID() external view returns (uint256);\\n\\n    /// @notice returns the vault id\\n    function TYPE() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct Tokens {\\n        address token0;\\n        address token1;\\n    }\\n\\n    struct ConstantViews {\\n        address liquidity;\\n        address factory;\\n        address operateImplementation;\\n        address adminImplementation;\\n        address secondaryImplementation;\\n        address deployer; // address which deploys oracle\\n        address supply; // either liquidity layer or DEX protocol\\n        address borrow; // either liquidity layer or DEX protocol\\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\\n        uint256 vaultId;\\n        uint256 vaultType;\\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n    }\\n\\n    /// @notice returns all Vault constants\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    /// @notice fetches the latest user position after a liquidation\\n    function fetchLatestPosition(\\n        int256 positionTick_,\\n        uint256 positionTickId_,\\n        uint256 positionRawDebt_,\\n        uint256 tickData_\\n    )\\n        external\\n        view\\n        returns (\\n            int256, // tick\\n            uint256, // raw debt\\n            uint256, // raw collateral\\n            uint256, // branchID_\\n            uint256 // branchData_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices\\n    function updateExchangePrices(\\n        uint256 vaultVariables2_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices and writes them to storage\\n    function updateExchangePricesOnStorage()\\n        external\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice returns the liquidity contract address\\n    function LIQUIDITY() external view returns (address);\\n\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n\\n    function rebalance(\\n        int colToken0MinMax_,\\n        int colToken1MinMax_,\\n        int debtToken0MinMax_,\\n        int debtToken1MinMax_\\n    ) external payable returns (int supplyAmt_, int borrowAmt_);\\n\\n    /// @notice reverts with FluidLiquidateResult\\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\\n}\\n\",\"keccak256\":\"0xdd764652f8451a71d2f2006b2572fccd9c21f1d64196869bfc291d10f151f0c6\",\"license\":\"MIT\"},\"contracts/protocols/vault/interfaces/iVaultFactory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { IERC721Enumerable } from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\ninterface IFluidVaultFactory is IERC721Enumerable {\\n    /// @notice Minting an NFT Vault for the user\\n    function mint(uint256 vaultId_, address user_) external returns (uint256 tokenId_);\\n\\n    /// @notice returns owner of Vault which is also an NFT\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /// @notice Global auth is auth for all vaults\\n    function isGlobalAuth(address auth_) external view returns (bool);\\n\\n    /// @notice Vault auth is auth for a specific vault\\n    function isVaultAuth(address vault_, address auth_) external view returns (bool);\\n\\n    /// @notice Total vaults deployed.\\n    function totalVaults() external view returns (uint256);\\n\\n    /// @notice Compute vaultAddress\\n    function getVaultAddress(uint256 vaultId) external view returns (address);\\n\\n    /// @notice read uint256 `result_` for a storage `slot_` key\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n}\\n\",\"keccak256\":\"0xc4a0caed89a8670e1ccf159d03fa23bb29f69c579f522bb0e33b1b5cb106c40d\",\"license\":\"MIT\"},\"contracts/protocols/vault/interfaces/iVaultT3.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { IFluidVault } from \\\"./iVault.sol\\\";\\n\\ninterface IFluidVaultT3 is IFluidVault {\\n    function operate(\\n        uint nftId_,\\n        int newCol_,\\n        int newDebtToken0_,\\n        int newDebtToken1_,\\n        int debtSharesMinMax_,\\n        address to_\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256, // nftId_\\n            int256, // final supply amount. if - then withdraw\\n            int256 // final borrow amount. if - then payback\\n        );\\n\\n    function operatePerfect(\\n        uint nftId_,\\n        int newCol_,\\n        int perfectDebtShares_,\\n        int debtToken0MinMax_,\\n        int debtToken1MinMax_,\\n        address to_\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256, // nftId_\\n            int256[] memory r_\\n        );\\n\\n    function liquidate(\\n        uint256 token0DebtAmt_,\\n        uint256 token1DebtAmt_,\\n        uint256 debtSharesMin_,\\n        uint256 colPerUnitDebt_,\\n        address to_,\\n        bool absorb_\\n    ) external payable returns (uint256 actualDebtShares_, uint256 actualCol_);\\n\\n    function liquidatePerfect(\\n        uint256 debtShares_,\\n        uint256 token0DebtAmtPerUnitShares_,\\n        uint256 token1DebtAmtPerUnitShares_,\\n        uint256 colPerUnitDebt_,\\n        address to_,\\n        bool absorb_\\n    )\\n        external\\n        payable\\n        returns (uint256 actualDebtShares_, uint256 token0Debt_, uint256 token1Debt_, uint256 actualCol_);\\n}\\n\",\"keccak256\":\"0xd8c96fd58640c45693f6a5baeecdf28ad7e162748342c1db1c670837d91803e6\",\"license\":\"MIT\"},\"solmate/src/auth/Owned.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xfedb27d14c508342c33eb067c9a02eabcdb0f9dcf93b04ded1001f580d12d0ea\",\"license\":\"AGPL-3.0-only\"},\"solmate/src/utils/SSTORE2.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Read and write to persistent storage at a fraction of the cost.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\\nlibrary SSTORE2 {\\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               WRITE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function write(bytes memory data) internal returns (address pointer) {\\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\\n        bytes memory runtimeCode = abi.encodePacked(hex\\\"00\\\", data);\\n\\n        bytes memory creationCode = abi.encodePacked(\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            hex\\\"60_0B_59_81_38_03_80_92_59_39_F3\\\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\\n        );\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Deploy a new contract with the generated creation code.\\n            // We start 32 bytes into the code to avoid copying the byte length.\\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\\n        }\\n\\n        require(pointer != address(0), \\\"DEPLOYMENT_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               READ LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function read(address pointer) internal view returns (bytes memory) {\\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\\n    }\\n\\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n\\n        return readBytecode(pointer, start, pointer.code.length - start);\\n    }\\n\\n    function read(\\n        address pointer,\\n        uint256 start,\\n        uint256 end\\n    ) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n        end += DATA_OFFSET;\\n\\n        require(pointer.code.length >= end, \\\"OUT_OF_BOUNDS\\\");\\n\\n        return readBytecode(pointer, start, end - start);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function readBytecode(\\n        address pointer,\\n        uint256 start,\\n        uint256 size\\n    ) private view returns (bytes memory data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            data := mload(0x40)\\n\\n            // Update the free memory pointer to prevent overriding our data.\\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\\n            // Adding 31 to size and running the result through the logic above ensures\\n            // the memory pointer remains word-aligned, following the Solidity convention.\\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\\n\\n            // Store the size of the data in the first 32 byte chunk of free memory.\\n            mstore(data, size)\\n\\n            // Copy the code into memory right after the 32 bytes we used to store the size.\\n            extcodecopy(pointer, add(data, 32), start, size)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc5359c92365c550c418725fc534a538426ea8f6e7f6c06c0a9d66647d864469d\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x6101806040523480156200001257600080fd5b506040516200186e3803806200186e8339810160408190526200003591620000e9565b6001600160a01b0380881660805285811660a05284811660e05283166101005260405186906200006590620000be565b6001600160a01b039091168152602001604051809103906000f08015801562000092573d6000803e3d6000fd5b506001600160a01b0390811660c05291821661012052166101405250503061016052506200017e915050565b6104f4806200137a83390190565b80516001600160a01b0381168114620000e457600080fd5b919050565b600080600080600080600060e0888a0312156200010557600080fd5b6200011088620000cc565b96506200012060208901620000cc565b95506200013060408901620000cc565b94506200014060608901620000cc565b93506200015060808901620000cc565b92506200016060a08901620000cc565b91506200017060c08901620000cc565b905092959891949750929550565b60805160a05160c05160e05161010051610120516101405161016051611151620002296000396000818161021b01526102ad01526000818161015001528181610853015261096a01526000818161017f0152818161026b01526106d90152600081816101cd015261055c01526000818161024201526105340152600081816101a601526107b80152600081816101f4015261050801526000818160f101526104d901526111516000f3fe608060405234801561001057600080fd5b50600436106100c95760003560e01c806378df1cca11610081578063c1b8411a1161005b578063c1b8411a146101ef578063cc025f7c14610216578063cc2fe94b1461023d57600080fd5b806378df1cca1461017a5780638cb1b071146101a1578063a07ddc17146101c857600080fd5b80632e60b486116100b25780632e60b486146101385780633463bc3e1461014b5780636b1717741461017257600080fd5b80630e09956a146100ce5780632861c7d1146100ec575b600080fd5b6100d6610264565b6040516100e39190610b9e565b60405180910390f35b6101137f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100e3565b6100d6610146366004610c14565b610294565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b6100d6610963565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b606061028f7f000000000000000000000000000000000000000000000000000000000000000061098a565b905090565b606073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016300361030d576040517f60121cca000000000000000000000000000000000000000000000000000000008152617537600482015260240160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff831673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee146103af578273ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610389573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ad9190610c4d565b505b60008273ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa1580156103fd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104219190610d9d565b90506104c2604080516102008101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905260c0830182905260e0830182905283518085018552828152808201839052610100840152835180850190945281845283015290610120820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c09091015290565b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000081168083523060208085018290527f0000000000000000000000000000000000000000000000000000000000000000841660a0808701919091527f0000000000000000000000000000000000000000000000000000000000000000851660608701527f00000000000000000000000000000000000000000000000000000000000000008516608087015260c0808701949094526101008601518a8616905288851660e0870152860151610120860180519186169091529286015192519290931691830191909152604080517f8d65402300000000000000000000000000000000000000000000000000000000815290519192638d654023926004808401938290030181865afa15801561060f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106339190610e84565b61014082018190526175306101608301526040517fe6bd26a2000000000000000000000000000000000000000000000000000000008152600091309163e6bd26a2916106859160040190815260200190565b602060405180830381865afa1580156106a2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c69190610e9d565b90506106d282826109b8565b91506106fd7f000000000000000000000000000000000000000000000000000000000000000061098a565b8260405160200161070e9190610eba565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529082905261074a92916020016110b2565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290527f798133dd000000000000000000000000000000000000000000000000000000008252945060009073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063798133dd906107ed908890600401610b9e565b6020604051808303816000875af115801561080c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108309190610e9d565b73ffffffffffffffffffffffffffffffffffffffff8116604085015290506108777f000000000000000000000000000000000000000000000000000000000000000061098a565b836040516020016108889190610eba565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290526108c492916020016110b2565b60405160208183030381529060405294508573ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f6e6ef0e482822af7114029dca9524b6e8ffee44d30247c4f9e454c1987fc72c186610140015160405161095091815260200190565b60405180910390a4505050505b92915050565b606061028f7f00000000000000000000000000000000000000000000000000000000000000005b606061095d8260016109b38173ffffffffffffffffffffffffffffffffffffffff84163b6110e1565b610b39565b610a57604080516102008101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905260c0830182905260e0830182905283518085018552828152808201839052610100840152835180850190945281845283015290610120820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c09091015290565b5061010082018051516040805173ffffffffffffffffffffffffffffffffffffffff92831660208083019190915260058284018190528351808403850181526060938401855280519083012061018089015260006101a08901529451518351968516878301819052600888860152845180890386018152888501865280519084012091909516608088015260a0808801919091528351808803909101815260c090960183528551958101959095206101c0870152815180860193909352828201939093528051808303820181529190920190915280519101206101e082015290565b60408051603f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168101909152818152818360208301863c9392505050565b60005b83811015610b95578181015183820152602001610b7d565b50506000910152565b6020815260008251806020840152610bbd816040850160208701610b7a565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b73ffffffffffffffffffffffffffffffffffffffff81168114610c1157600080fd5b50565b60008060408385031215610c2757600080fd5b8235610c3281610bef565b91506020830135610c4281610bef565b809150509250929050565b600060208284031215610c5f57600080fd5b815160ff81168114610c7057600080fd5b9392505050565b6040516101c0810167ffffffffffffffff81118282101715610cc2577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405290565b8051610cd381610bef565b919050565b600060a08284031215610cea57600080fd5b60405160a0810181811067ffffffffffffffff82111715610d34577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b80604052508091508251610d4781610bef565b81526020830151610d5781610bef565b60208201526040830151610d6a81610bef565b60408201526060830151610d7d81610bef565b60608201526080830151610d9081610bef565b6080919091015292915050565b60006102408284031215610db057600080fd5b610db8610c77565b82518152610dc860208401610cc8565b6020820152610dd960408401610cc8565b6040820152610deb8460608501610cd8565b6060820152610100610dfe818501610cc8565b6080830152610120610e11818601610cc8565b60a0840152610140610e24818701610cc8565b60c08501526101608087015160e086015261018080880151858701526101a0945084880151848701526101c0880151838701526101e088015182870152610200880151818701525050505061022084015181830152508091505092915050565b600060208284031215610e9657600080fd5b5051919050565b600060208284031215610eaf57600080fd5b8151610c7081610bef565b815173ffffffffffffffffffffffffffffffffffffffff16815261024081016020830151610f00602084018273ffffffffffffffffffffffffffffffffffffffff169052565b506040830151610f28604084018273ffffffffffffffffffffffffffffffffffffffff169052565b506060830151610f50606084018273ffffffffffffffffffffffffffffffffffffffff169052565b506080830151610f78608084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060a0830151610fa060a084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060c0830151610fc860c084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060e0830151610ff060e084018273ffffffffffffffffffffffffffffffffffffffff169052565b5061010083810151805173ffffffffffffffffffffffffffffffffffffffff90811685840152602082015116610120850152505061012083015161014061105c81850183805173ffffffffffffffffffffffffffffffffffffffff908116835260209182015116910152565b840151610180848101919091526101608501516101a080860191909152908501516101c080860191909152908501516101e080860191909152908501516102008501529093015161022090920191909152919050565b600083516110c4818460208801610b7a565b8351908301906110d8818360208801610b7a565b01949350505050565b8181038181111561095d577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fdfea264697066735822122097a67032c4d6c617731599c2526705e0a5c211a4456e512fbe6f1e3c4a5f672b64736f6c63430008150033608060405234801561001057600080fd5b506040516104f43803806104f483398101604081905261002f9161007e565b600080546001600160a01b0319166001600160a01b03831690811782556040518392907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a350506100ae565b60006020828403121561009057600080fd5b81516001600160a01b03811681146100a757600080fd5b9392505050565b610437806100bd6000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063798133dd146100465780638da5cb5b14610082578063f2fde38b146100a2575b600080fd5b610059610054366004610352565b6100b7565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b6000546100599073ffffffffffffffffffffffffffffffffffffffff1681565b6100b56100b03660046103c4565b6101c7565b005b6000805473ffffffffffffffffffffffffffffffffffffffff16331461013e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f554e415554484f52495a4544000000000000000000000000000000000000000060448201526064015b60405180910390fd5b61017d83838080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506102b892505050565b60405190915073ffffffffffffffffffffffffffffffffffffffff8216907ff40020e78c6e173ba88aa2c344ed520fab87fe67b9e5aa34626af9d86a3cd47b90600090a292915050565b60005473ffffffffffffffffffffffffffffffffffffffff163314610248576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f554e415554484f52495a454400000000000000000000000000000000000000006044820152606401610135565b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081178255604051909133917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a350565b600081516000036102f5576040517f830297c900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8151602083016000f0905073ffffffffffffffffffffffffffffffffffffffff811661034d576040517f830297c900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b919050565b6000806020838503121561036557600080fd5b823567ffffffffffffffff8082111561037d57600080fd5b818501915085601f83011261039157600080fd5b8135818111156103a057600080fd5b8660208285010111156103b257600080fd5b60209290920196919550909350505050565b6000602082840312156103d657600080fd5b813573ffffffffffffffffffffffffffffffffffffffff811681146103fa57600080fd5b939250505056fea26469706673582212201bc75243187841bf004ccfd8c2e19e986902002ceb1c8c6119f0fb68cfeed79364736f6c63430008150033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100c95760003560e01c806378df1cca11610081578063c1b8411a1161005b578063c1b8411a146101ef578063cc025f7c14610216578063cc2fe94b1461023d57600080fd5b806378df1cca1461017a5780638cb1b071146101a1578063a07ddc17146101c857600080fd5b80632e60b486116100b25780632e60b486146101385780633463bc3e1461014b5780636b1717741461017257600080fd5b80630e09956a146100ce5780632861c7d1146100ec575b600080fd5b6100d6610264565b6040516100e39190610b9e565b60405180910390f35b6101137f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100e3565b6100d6610146366004610c14565b610294565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b6100d6610963565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b6101137f000000000000000000000000000000000000000000000000000000000000000081565b606061028f7f000000000000000000000000000000000000000000000000000000000000000061098a565b905090565b606073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016300361030d576040517f60121cca000000000000000000000000000000000000000000000000000000008152617537600482015260240160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff831673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee146103af578273ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610389573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ad9190610c4d565b505b60008273ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa1580156103fd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104219190610d9d565b90506104c2604080516102008101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905260c0830182905260e0830182905283518085018552828152808201839052610100840152835180850190945281845283015290610120820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c09091015290565b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000081168083523060208085018290527f0000000000000000000000000000000000000000000000000000000000000000841660a0808701919091527f0000000000000000000000000000000000000000000000000000000000000000851660608701527f00000000000000000000000000000000000000000000000000000000000000008516608087015260c0808701949094526101008601518a8616905288851660e0870152860151610120860180519186169091529286015192519290931691830191909152604080517f8d65402300000000000000000000000000000000000000000000000000000000815290519192638d654023926004808401938290030181865afa15801561060f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106339190610e84565b61014082018190526175306101608301526040517fe6bd26a2000000000000000000000000000000000000000000000000000000008152600091309163e6bd26a2916106859160040190815260200190565b602060405180830381865afa1580156106a2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c69190610e9d565b90506106d282826109b8565b91506106fd7f000000000000000000000000000000000000000000000000000000000000000061098a565b8260405160200161070e9190610eba565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529082905261074a92916020016110b2565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290527f798133dd000000000000000000000000000000000000000000000000000000008252945060009073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063798133dd906107ed908890600401610b9e565b6020604051808303816000875af115801561080c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108309190610e9d565b73ffffffffffffffffffffffffffffffffffffffff8116604085015290506108777f000000000000000000000000000000000000000000000000000000000000000061098a565b836040516020016108889190610eba565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290526108c492916020016110b2565b60405160208183030381529060405294508573ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f6e6ef0e482822af7114029dca9524b6e8ffee44d30247c4f9e454c1987fc72c186610140015160405161095091815260200190565b60405180910390a4505050505b92915050565b606061028f7f00000000000000000000000000000000000000000000000000000000000000005b606061095d8260016109b38173ffffffffffffffffffffffffffffffffffffffff84163b6110e1565b610b39565b610a57604080516102008101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905260c0830182905260e0830182905283518085018552828152808201839052610100840152835180850190945281845283015290610120820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c09091015290565b5061010082018051516040805173ffffffffffffffffffffffffffffffffffffffff92831660208083019190915260058284018190528351808403850181526060938401855280519083012061018089015260006101a08901529451518351968516878301819052600888860152845180890386018152888501865280519084012091909516608088015260a0808801919091528351808803909101815260c090960183528551958101959095206101c0870152815180860193909352828201939093528051808303820181529190920190915280519101206101e082015290565b60408051603f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168101909152818152818360208301863c9392505050565b60005b83811015610b95578181015183820152602001610b7d565b50506000910152565b6020815260008251806020840152610bbd816040850160208701610b7a565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b73ffffffffffffffffffffffffffffffffffffffff81168114610c1157600080fd5b50565b60008060408385031215610c2757600080fd5b8235610c3281610bef565b91506020830135610c4281610bef565b809150509250929050565b600060208284031215610c5f57600080fd5b815160ff81168114610c7057600080fd5b9392505050565b6040516101c0810167ffffffffffffffff81118282101715610cc2577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405290565b8051610cd381610bef565b919050565b600060a08284031215610cea57600080fd5b60405160a0810181811067ffffffffffffffff82111715610d34577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b80604052508091508251610d4781610bef565b81526020830151610d5781610bef565b60208201526040830151610d6a81610bef565b60408201526060830151610d7d81610bef565b60608201526080830151610d9081610bef565b6080919091015292915050565b60006102408284031215610db057600080fd5b610db8610c77565b82518152610dc860208401610cc8565b6020820152610dd960408401610cc8565b6040820152610deb8460608501610cd8565b6060820152610100610dfe818501610cc8565b6080830152610120610e11818601610cc8565b60a0840152610140610e24818701610cc8565b60c08501526101608087015160e086015261018080880151858701526101a0945084880151848701526101c0880151838701526101e088015182870152610200880151818701525050505061022084015181830152508091505092915050565b600060208284031215610e9657600080fd5b5051919050565b600060208284031215610eaf57600080fd5b8151610c7081610bef565b815173ffffffffffffffffffffffffffffffffffffffff16815261024081016020830151610f00602084018273ffffffffffffffffffffffffffffffffffffffff169052565b506040830151610f28604084018273ffffffffffffffffffffffffffffffffffffffff169052565b506060830151610f50606084018273ffffffffffffffffffffffffffffffffffffffff169052565b506080830151610f78608084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060a0830151610fa060a084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060c0830151610fc860c084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060e0830151610ff060e084018273ffffffffffffffffffffffffffffffffffffffff169052565b5061010083810151805173ffffffffffffffffffffffffffffffffffffffff90811685840152602082015116610120850152505061012083015161014061105c81850183805173ffffffffffffffffffffffffffffffffffffffff908116835260209182015116910152565b840151610180848101919091526101608501516101a080860191909152908501516101c080860191909152908501516101e080860191909152908501516102008501529093015161022090920191909152919050565b600083516110c4818460208801610b7a565b8351908301906110d8818360208801610b7a565b01949350505050565b8181038181111561095d577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fdfea264697066735822122097a67032c4d6c617731599c2526705e0a5c211a4456e512fbe6f1e3c4a5f672b64736f6c63430008150033",
  "devdoc": {
    "events": {
      "VaultT3Deployed(address,uint256,address,address)": {
        "params": {
          "smartDebt": "The address of the dex for which the smart debt is used.",
          "supplyToken": "The address of the supply token.",
          "vault": "The address of the newly deployed vault.",
          "vaultId": "The id of the newly deployed vault."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "constructor": {
        "details": "each vault type has different vaultAdminImplementation but same vaultSecondaryImplementatio"
      },
      "mainCreationCode()": {
        "details": "Retrieves the creation code for the main contract"
      },
      "operateCreationCode()": {
        "details": "Retrieves the creation code for the Operate contract"
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "FluidLiquidateResult(uint256,uint256)": [
        {
          "notice": "used to simulate liquidation to find the maximum liquidatable amounts"
        }
      ]
    },
    "events": {
      "VaultT3Deployed(address,uint256,address,address)": {
        "notice": "Emitted when a new vaultT3 is deployed."
      }
    },
    "kind": "user",
    "methods": {
      "ADDRESS_THIS()": {
        "notice": "address of this contract"
      },
      "ADMIN_IMPLEMENTATION()": {
        "notice": "address of Admin implementation"
      },
      "LIQUIDITY()": {
        "notice": "address of liquidity contract"
      },
      "MINI_DEPLOYER()": {
        "notice": "address of MiniDeployer Contract"
      },
      "SECONDARY_IMPLEMENTATION()": {
        "notice": "address of Secondary implementation"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}