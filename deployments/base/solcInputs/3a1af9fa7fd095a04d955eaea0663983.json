{
  "language": "Solidity",
  "sources": {
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/bigMathMinified.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\nlibrary BigMathMinified {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/dexSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\nlibrary DexSlotsLink {\n    /// @dev storage slot for variables at Dex\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\n    /// @dev storage slot for variables2 at Dex\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\n    /// @dev storage slot for total supply shares at Dex\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\n    /// @dev storage slot for user supply mapping at Dex\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\n    /// @dev storage slot for total borrow shares at Dex\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\n    /// @dev storage slot for user borrow mapping at Dex\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\n    /// @dev storage slot for oracle mapping at Dex\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\n    /// @dev storage slot for range and threshold shifts at Dex\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\n    /// @dev storage slot for center price shift at Dex\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n\n    /***********************************|\n    |           SafeApprove             | \n    |__________________________________*/\n\n    /// @notice thrown when safe approve from for an ERC20 fails\n    uint256 internal constant SafeApprove__ApproveFailed = 81001;\n}\n"
    },
    "contracts/libraries/liquidityCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\nimport { LiquiditySlotsLink } from \"./liquiditySlotsLink.sol\";\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\n\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\n/// borrow rate, withdrawal / borrow limits, revenue amount.\nlibrary LiquidityCalcs {\n    error FluidLiquidityCalcsError(uint256 errorId_);\n\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\n    event BorrowRateMaxCap();\n\n    /// @dev constants as from Liquidity variables.sol\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X15 = 0x7fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                  CALC EXCHANGE PRICES                  /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\n    function calcExchangePrices(\n        uint256 exchangePricesAndConfig_\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\n        // Extracting exchange prices\n        supplyExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\n            X64;\n        borrowExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\n            X64;\n\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\n        }\n\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\n\n        unchecked {\n            // last timestamp can not be > current timestamp\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\n\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\n                X15;\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // calculate new borrow exchange price.\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\n            borrowExchangePrice_ +=\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\n\n            // FOR SUPPLY EXCHANGE PRICE:\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\n            //\n            // Example:\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\n            // yield is 10 (so half a year must have passed).\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 20%) = 62,5%\n            // supplyRate = (40% * (100% - 10%)) * = 36% * 62,5% = 22.5%\n            // increase in supplyExchangePrice, assuming 100 as previous price.\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\n\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\n\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\n\n            if (temp_ == 1) {\n                // if no raw supply: no exchange price update needed\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\n            if (temp_ & 1 == 1) {\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n                temp_ = temp_ >> 1;\n\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\n                // in the if statement a little above.\n\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\n                // so ratioSupplyYield must come out as 2.5 (250%).\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\n                temp_ =\n                    // utilization * (100% + 100% / supplyRatio)\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\n                    (FOUR_DECIMALS);\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\n            } else {\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n                temp_ = temp_ >> 1;\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\n\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\n                temp_ =\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\n                    (1e27 *\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\n                        (FOUR_DECIMALS + temp_)) /\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\n            }\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\n\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\n            if (borrowRatio_ & 1 == 1) {\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\n\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\n            } else {\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\n            }\n\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\n\n            // 2. calculate supply rate\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\n            // but more suppliers not earning interest.\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\n                temp_ * // ratioSupplyYield\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\n\n            // 3. calculate increase in supply exchange price\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                     CALC REVENUE                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\n    /// and the current balance of the Fluid liquidity contract for the token.\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\n    /// @return revenueAmount_ collectable revenue amount\n    function calcRevenue(\n        uint256 totalAmounts_,\n        uint256 exchangePricesAndConfig_,\n        uint256 liquidityTokenBalance_\n    ) internal view returns (uint256 revenueAmount_) {\n        // @dev no need to super-optimize this method as it is only used by admin\n\n        // calculate the new exchange prices based on earned interest\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\n\n        // total supply = interest free + with interest converted from raw\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\n\n        if (totalSupply_ > 0) {\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\n            // ensure there is no possible case because of rounding etc. where this would revert,\n            // explicitly check if >\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\n            // can only be revenue.\n        } else {\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\n            revenueAmount_ = liquidityTokenBalance_;\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ =\n                block.timestamp -\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ =\n                block.timestamp -\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC RATES                        /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev Calculates new borrow rate from utilization for a token\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\n        // extract rate version: 4 bits (0xF) starting from bit 0\n        uint256 rateVersion_ = (rateData_ & 0xF);\n\n        if (rateVersion_ == 1) {\n            rate_ = calcRateV1(rateData_, utilization_);\n        } else if (rateVersion_ == 2) {\n            rate_ = calcRateV2(rateData_, utilization_);\n        } else {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\n        }\n\n        if (rate_ > X16) {\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\n            // this is unlikely to ever happen if configs stay within expected levels.\n            rate_ = X16;\n            // emit event to more easily become aware\n            emit BorrowRateMaxCap();\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e2 precision\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v1 (one kink) ------------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // else utilization is greater than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\n            x1_ = kink1_;\n            x2_ = FOUR_DECIMALS; // 100%\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e4 precision\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v2 (two kinks) -----------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 156 bits => 100-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink1\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\n            if (utilization_ < kink2_) {\n                // if utilization is less than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                x1_ = kink1_;\n                x2_ = kink2_;\n            } else {\n                // else utilization is greater than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\n                x1_ = kink2_;\n                x2_ = FOUR_DECIMALS;\n            }\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\n    function getTotalSupply(\n        uint256 totalAmounts_,\n        uint256 supplyExchangePrice_\n    ) internal pure returns (uint256 totalSupply_) {\n        // totalSupply_ => supplyInterestFree\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\n    function getTotalBorrow(\n        uint256 totalAmounts_,\n        uint256 borrowExchangePrice_\n    ) internal pure returns (uint256 totalBorrow_) {\n        // totalBorrow_ => borrowInterestFree\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n}\n"
    },
    "contracts/libraries/liquiditySlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\nlibrary LiquiditySlotsLink {\n    /// @dev storage slot for status at Liquidity\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\n    /// @dev storage slot for auths mapping at Liquidity\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\n    /// @dev storage slot for guardians mapping at Liquidity\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\n    /// @dev storage slot for user class mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\n    /// @dev storage slot for rateData mapping at Liquidity\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\n    /// @dev storage slot for totalAmounts mapping at Liquidity\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\n    /// @dev storage slot for user supply double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\n    /// @dev storage slot for user borrow double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // ExchangePricesAndConfig\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\n\n    // RateData:\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\n    // RateData: V1\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\n    // RateData: V2\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\n\n    // TotalAmounts\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\n\n    // Configs2\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/oracle/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Error {\n    error FluidOracleError(uint256 errorId_);\n}\n"
    },
    "contracts/oracle/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |           FluidOracleL2           | \n    |__________________________________*/\n\n    /// @notice thrown when sequencer on a L2 has an outage and grace period has not yet passed.\n    uint256 internal constant FluidOracleL2__SequencerOutage = 60000;\n\n    /***********************************|\n    |     UniV3CheckCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the delta between main price source and check rate source is exceeding the allowed delta\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidPrice = 60001;\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidParams = 60002;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant UniV3CheckCLRSOracle__ExchangeRateZero = 60003;\n\n    /***********************************|\n    |           FluidOracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid info name is passed into a fluid oracle (e.g. not set or too long)\n    uint256 internal constant FluidOracle__InvalidInfoName = 60010;\n\n    /***********************************|\n    |            sUSDe Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDeOracle__InvalidParams = 60102;\n\n    /***********************************|\n    |           Pendle Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PendleOracle__InvalidParams = 60201;\n\n    /// @notice thrown when the Pendle market Oracle has not been initialized yet\n    uint256 internal constant PendleOracle__MarketNotInitialized = 60202;\n\n    /// @notice thrown when the Pendle market does not have 18 decimals\n    uint256 internal constant PendleOracle__MarketInvalidDecimals = 60203;\n\n    /// @notice thrown when the Pendle market returns an unexpected price\n    uint256 internal constant PendleOracle__InvalidPrice = 60204;\n\n    /***********************************|\n    |    CLRS2UniV3CheckCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant CLRS2UniV3CheckCLRSOracleL2__ExchangeRateZero = 60301;\n\n    /***********************************|\n    |    Ratio2xFallbackCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant Ratio2xFallbackCLRSOracleL2__ExchangeRateZero = 60311;\n\n    /***********************************|\n    |            WeETHsOracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHsOracle__InvalidParams = 60321;\n\n    /***********************************|\n    |        DexSmartColOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexSmartColOracle__InvalidParams = 60331;\n\n    /// @notice thrown when smart col is not enabled\n    uint256 internal constant DexSmartColOracle__SmartColNotEnabled = 60332;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexSmartColOracle__ExchangeRateZero = 60333;\n\n    /***********************************|\n    |        DexSmartDebtOracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexSmartDebtOracle__InvalidParams = 60341;\n\n    /// @notice thrown when smart debt is not enabled\n    uint256 internal constant DexSmartDebtOracle__SmartDebtNotEnabled = 60342;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexSmartDebtOracle__ExchangeRateZero = 60343;\n\n    /***********************************|\n    |            ContractRate           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant ContractRate__InvalidParams = 60351;\n\n    /// @notice thrown when caller is not authorized\n    uint256 internal constant ContractRate__Unauthorized = 60352;\n\n    /// @notice thrown when minimum diff for triggering update on the stared rate is not reached\n    uint256 internal constant ContractRate__MinUpdateDiffNotReached = 60353;\n\n    /// @notice thrown when the external rate source returns 0 for the new rate\n    uint256 internal constant ContractRate__NewRateZero = 60354;\n\n    /***********************************|\n    |            sUSDs Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDsOracle__InvalidParams = 60361;\n\n    /***********************************|\n    |            Peg Oracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PegOracle__InvalidParams = 60371;\n\n    /***********************************|\n    |              DexOracle            | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexOracle__InvalidParams = 60381;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexOracle__ExchangeRateZero = 60382;\n\n    /***********************************|\n    |           GenericOracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant GenericOracle__InvalidParams = 60401;\n\n    /// @notice thrown when reaching an unexepcted config state\n    uint256 internal constant GenericOracle__UnexpectedConfig = 60402;\n\n    /// @notice thrown when the exchange rate is zero\n    uint256 internal constant GenericOracle__RateZero = 60403;\n\n    /***********************************|\n    |          Chainlink Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant ChainlinkOracle__InvalidParams = 61001;\n\n    /***********************************|\n    |          UniswapV3 Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3Oracle__InvalidParams = 62001;\n\n    /// @notice thrown when constructor is called with invalid ordered seconds agos values\n    uint256 internal constant UniV3Oracle__InvalidSecondsAgos = 62002;\n\n    /// @notice thrown when constructor is called with invalid delta values > 100%\n    uint256 internal constant UniV3Oracle__InvalidDeltas = 62003;\n\n    /***********************************|\n    |            WstETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WstETHOracle__InvalidParams = 63001;\n\n    /***********************************|\n    |           Redstone Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant RedstoneOracle__InvalidParams = 64001;\n\n    /***********************************|\n    |          Fallback Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant FallbackOracle__InvalidParams = 65001;\n\n    /***********************************|\n    |       FallbackCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant FallbackCLRSOracle__ExchangeRateZero = 66001;\n\n    /***********************************|\n    |         WstETHCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant WstETHCLRSOracle__ExchangeRateZero = 67001;\n\n    /***********************************|\n    |        CLFallbackUniV3Oracle      | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant CLFallbackUniV3Oracle__ExchangeRateZero = 68001;\n\n    /***********************************|\n    |  WstETHCLRS2UniV3CheckCLRSOracle  | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant WstETHCLRS2UniV3CheckCLRSOracle__ExchangeRateZero = 69001;\n\n    /***********************************|\n    |             WeETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHOracle__InvalidParams = 70001;\n}\n"
    },
    "contracts/oracle/fluidOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"./interfaces/iFluidOracle.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { Error as OracleError } from \"./error.sol\";\n\n/// @title   FluidOracle\n/// @notice  Base contract that any Fluid Oracle must implement\nabstract contract FluidOracle is IFluidOracle, OracleError {\n    /// @dev short helper string to easily identify the oracle. E.g. token symbols\n    //\n    // using a bytes32 because string can not be immutable.\n    bytes32 private immutable _infoName;\n\n    constructor(string memory infoName_) {\n        if (bytes(infoName_).length > 32 || bytes(infoName_).length == 0) {\n            revert FluidOracleError(ErrorTypes.FluidOracle__InvalidInfoName);\n        }\n\n        // convert string to bytes32\n        bytes32 infoNameBytes32_;\n        assembly {\n            infoNameBytes32_ := mload(add(infoName_, 32))\n        }\n        _infoName = infoNameBytes32_;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function infoName() external view returns (string memory) {\n        // convert bytes32 to string\n        uint256 length_;\n        while (length_ < 32 && _infoName[length_] != 0) {\n            length_++;\n        }\n        bytes memory infoNameBytes_ = new bytes(length_);\n        for (uint256 i; i < length_; i++) {\n            infoNameBytes_[i] = _infoName[i];\n        }\n        return string(infoNameBytes_);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() external view virtual returns (uint256 exchangeRate_);\n}\n"
    },
    "contracts/oracle/fluidOracleL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"./interfaces/iFluidOracle.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { IChainlinkAggregatorV3 } from \"./interfaces/external/IChainlinkAggregatorV3.sol\";\nimport { Error as OracleError } from \"./error.sol\";\n\n/// @title   FluidOracleL2\n/// @notice  Base contract that any Fluid Oracle L2 must implement\nabstract contract FluidOracleL2 is IFluidOracle, OracleError {\n    /// @dev Chainlink L2 Sequencer Uptime feed to detect sequencer outages\n    IChainlinkAggregatorV3 internal _SEQUENCER_ORACLE;\n    /// @dev max time period until oracle assumes normal behavior after a sequencer outage.\n    uint256 internal constant _SEQUENCER_MAX_GRACE_PERIOD = 45 minutes;\n\n    /// @notice sets the L2 sequencer uptime Chainlink feed\n    constructor(address sequencerUptimeFeed_) {\n        _SEQUENCER_ORACLE = IChainlinkAggregatorV3(sequencerUptimeFeed_);\n    }\n\n    /// @notice returns all sequencer uptime feed related data\n    function sequencerL2Data()\n        public\n        view\n        returns (\n            address sequencerUptimeFeed_,\n            uint256 maxGracePeriod_,\n            bool isSequencerUp_,\n            uint256 lastUptimeStartedAt_,\n            uint256 gracePeriod_,\n            bool gracePeriodPassed_,\n            uint256 lastOutageStartedAt_,\n            bool isSequencerUpAndValid_\n        )\n    {\n        uint80 uptimeStartRoundId_;\n        (isSequencerUp_, uptimeStartRoundId_, lastUptimeStartedAt_) = _sequencerUpStatus();\n\n        if (isSequencerUp_) {\n            (gracePeriod_, gracePeriodPassed_, lastOutageStartedAt_) = _gracePeriod(\n                uptimeStartRoundId_,\n                lastUptimeStartedAt_\n            );\n        } else {\n            gracePeriod_ = _SEQUENCER_MAX_GRACE_PERIOD;\n            (uint80 roundId_, , , , ) = _SEQUENCER_ORACLE.latestRoundData();\n            lastOutageStartedAt_ = _lastSequencerOutageStart(roundId_ + 1);\n        }\n\n        return (\n            address(_SEQUENCER_ORACLE),\n            _SEQUENCER_MAX_GRACE_PERIOD,\n            isSequencerUp_,\n            lastUptimeStartedAt_,\n            gracePeriod_,\n            gracePeriodPassed_,\n            lastOutageStartedAt_,\n            isSequencerUp_ && gracePeriodPassed_\n        );\n    }\n\n    /// @dev ensures that the sequencer is up and grace period has passed\n    function _ensureSequencerUpAndValid() internal view {\n        (bool isSequencerUp_, uint80 uptimeStartRoundId_, uint256 uptimeStartedAt_) = _sequencerUpStatus();\n\n        if (!isSequencerUp_) {\n            revert FluidOracleError(ErrorTypes.FluidOracleL2__SequencerOutage);\n        }\n\n        (, bool gracePeriodPassed_, ) = _gracePeriod(uptimeStartRoundId_, uptimeStartedAt_);\n        if (!gracePeriodPassed_) {\n            revert FluidOracleError(ErrorTypes.FluidOracleL2__SequencerOutage);\n        }\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @dev finds last round before `uptimeStartRoundId_` where sequencer status was down, incl. handling cases of\n    /// consecutive rounds where status was down.\n    function _lastSequencerOutageStart(uint80 uptimeStartRoundId_) private view returns (uint256 outageStartedAt_) {\n        uint80 roundId_ = uptimeStartRoundId_;\n        int256 answer_;\n        uint256 startedAt_;\n        do {\n            (roundId_, answer_, startedAt_, , ) = _SEQUENCER_ORACLE.getRoundData(roundId_ - 1);\n            if (answer_ != 0) {\n                // sequencer was down at this round, update outage started at data\n                outageStartedAt_ = startedAt_;\n            } // else: while loop is going to break\n        } while (answer_ != 0 && startedAt_ > 0);\n    }\n\n    /// @dev finds last round where sequencer status was up, incl. handling cases of consecutive rounds where status was up.\n    function _sequencerUpStatus()\n        private\n        view\n        returns (bool isSequencerUp_, uint80 uptimeStartRoundId_, uint256 uptimeStartedAt_)\n    {\n        (uint80 roundId_, int256 answer_, uint256 startedAt_, , ) = _SEQUENCER_ORACLE.latestRoundData();\n        if (answer_ != 0) {\n            // sequencer is down currently.\n            return (false, 0, 0);\n        }\n\n        isSequencerUp_ = true;\n\n        // cover case where there were other consecutive uptime report rounds in between\n        uptimeStartRoundId_ = roundId_;\n        uptimeStartedAt_ = startedAt_;\n        if (uptimeStartedAt_ > 0) {\n            do {\n                (roundId_, answer_, startedAt_, , ) = _SEQUENCER_ORACLE.getRoundData(roundId_ - 1);\n                if (answer_ == 0) {\n                    // sequencer was up at this round, consecutive uptime so update uptime start data\n                    uptimeStartRoundId_ = roundId_;\n                    uptimeStartedAt_ = startedAt_;\n                } // else: while loop is going to break\n            } while (answer_ == 0 && startedAt_ > 0);\n        } // else if startedAt == 0, then it is the first ever round.\n    }\n\n    /// @dev returns the `gracePeriod_` duration and if the grace period has `passed_` based on\n    /// current uptime round data vs the last sequencer outage duration.\n    function _gracePeriod(\n        uint80 uptimeStartRoundId_,\n        uint256 uptimeStartedAt_\n    ) private view returns (uint256 gracePeriod_, bool passed_, uint256 outageStartedAt_) {\n        uint256 uptimeDuration_ = block.timestamp - uptimeStartedAt_;\n        if (uptimeStartedAt_ == 0 || uptimeDuration_ > _SEQUENCER_MAX_GRACE_PERIOD) {\n            return (_SEQUENCER_MAX_GRACE_PERIOD, true, 0);\n        }\n\n        outageStartedAt_ = _lastSequencerOutageStart(uptimeStartRoundId_);\n\n        // grace period is outage duration, capped at _SEQUENCER_MAX_GRACE_PERIOD\n        gracePeriod_ = uptimeStartedAt_ - outageStartedAt_; // outage duration\n        if (gracePeriod_ > _SEQUENCER_MAX_GRACE_PERIOD) {\n            gracePeriod_ = _SEQUENCER_MAX_GRACE_PERIOD;\n        }\n\n        return (gracePeriod_, uptimeDuration_ > gracePeriod_, outageStartedAt_);\n    }\n}\n"
    },
    "contracts/oracle/implementations/chainlinkOracleImpl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { IChainlinkAggregatorV3 } from \"../interfaces/external/IChainlinkAggregatorV3.sol\";\nimport { Error as OracleError } from \"../error.sol\";\nimport { OracleUtils } from \"../libraries/oracleUtils.sol\";\nimport { ChainlinkStructs } from \"./structs.sol\";\n\n/// @title   Chainlink Oracle implementation\n/// @notice  This contract is used to get the exchange rate via up to 3 hops at Chainlink price feeds.\n///          The rate is multiplied with the previous rate at each hop.\n///          E.g. to go from wBTC to USDC (assuming rates for example):\n///          1. wBTC -> BTC https://data.chain.link/ethereum/mainnet/crypto-other/wbtc-btc, rate: 0.92.\n///          2. BTC -> USD https://data.chain.link/ethereum/mainnet/crypto-usd/btc-usd rate: 30,000.\n///          3. USD -> USDC https://data.chain.link/ethereum/mainnet/stablecoins/usdc-usd rate: 0.98. Must invert feed: 1.02\n///          finale rate would be: 0.92 * 30,000 * 1.02 = 28,152\nabstract contract ChainlinkOracleImpl is OracleError, ChainlinkStructs {\n    /// @notice Chainlink price feed 1 to check for the exchange rate\n    IChainlinkAggregatorV3 internal immutable _CHAINLINK_FEED1;\n    /// @notice Chainlink price feed 2 to check for the exchange rate\n    IChainlinkAggregatorV3 internal immutable _CHAINLINK_FEED2;\n    /// @notice Chainlink price feed 3 to check for the exchange rate\n    IChainlinkAggregatorV3 internal immutable _CHAINLINK_FEED3;\n\n    /// @notice Flag to invert the price or not for feed 1 (to e.g. for WETH/USDC pool return prive of USDC per 1 WETH)\n    bool internal immutable _CHAINLINK_INVERT_RATE1;\n    /// @notice Flag to invert the price or not for feed 2 (to e.g. for WETH/USDC pool return prive of USDC per 1 WETH)\n    bool internal immutable _CHAINLINK_INVERT_RATE2;\n    /// @notice Flag to invert the price or not for feed 3 (to e.g. for WETH/USDC pool return prive of USDC per 1 WETH)\n    bool internal immutable _CHAINLINK_INVERT_RATE3;\n\n    /// @notice constant value for price scaling to reduce gas usage for feed 1\n    uint256 internal immutable _CHAINLINK_PRICE_SCALER_MULTIPLIER1;\n    /// @notice constant value for inverting price to reduce gas usage for feed 1\n    uint256 internal immutable _CHAINLINK_INVERT_PRICE_DIVIDEND1;\n\n    /// @notice constant value for price scaling to reduce gas usage for feed 2\n    uint256 internal immutable _CHAINLINK_PRICE_SCALER_MULTIPLIER2;\n    /// @notice constant value for inverting price to reduce gas usage for feed 2\n    uint256 internal immutable _CHAINLINK_INVERT_PRICE_DIVIDEND2;\n\n    /// @notice constant value for price scaling to reduce gas usage for feed 3\n    uint256 internal immutable _CHAINLINK_PRICE_SCALER_MULTIPLIER3;\n    /// @notice constant value for inverting price to reduce gas usage for feed 3\n    uint256 internal immutable _CHAINLINK_INVERT_PRICE_DIVIDEND3;\n\n    /// @notice constructor sets the Chainlink price feed and invertRate flag for each hop.\n    /// E.g. `invertRate_` should be true if for the USDC/ETH pool it's expected that the oracle returns USDC per 1 ETH\n    constructor(ChainlinkConstructorParams memory params_) {\n        if (\n            (params_.hops < 1 || params_.hops > 3) || // hops must be 1, 2 or 3\n            (address(params_.feed1.feed) == address(0) || params_.feed1.token0Decimals == 0) || // first feed must always be defined\n            (params_.hops > 1 && (address(params_.feed2.feed) == address(0) || params_.feed2.token0Decimals == 0)) || // if hops > 1, feed 2 must be defined\n            (params_.hops > 2 && (address(params_.feed3.feed) == address(0) || params_.feed3.token0Decimals == 0)) // if hops > 2, feed 3 must be defined\n        ) {\n            revert FluidOracleError(ErrorTypes.ChainlinkOracle__InvalidParams);\n        }\n\n        _CHAINLINK_FEED1 = params_.feed1.feed;\n        _CHAINLINK_FEED2 = params_.feed2.feed;\n        _CHAINLINK_FEED3 = params_.feed3.feed;\n\n        _CHAINLINK_INVERT_RATE1 = params_.feed1.invertRate;\n        _CHAINLINK_INVERT_RATE2 = params_.feed2.invertRate;\n        _CHAINLINK_INVERT_RATE3 = params_.feed3.invertRate;\n\n        // Actual desired output rate example USDC/ETH (6 decimals / 18 decimals).\n        // Note ETH has 12 decimals more than USDC.\n        //    0.000515525322211842331991619857165357691 // 39 decimals.  ETH for 1 USDC\n        // 1954.190000000000433             // 15 decimals. USDC for 1 ETH\n\n        // to get to PRICE_SCLAER_MULTIPLIER and INVERT_PRICE_DIVIDEND:\n        // fetched Chainlink price is in token1Decimals per 1 token0Decimals.\n        // E.g. for an USDC/ETH price feed it's in ETH 18 decimals.\n        //      for an  BTC/USD price feed it's in USD  8 decimals.\n        // So to scale to 1e27 we need to multiply by 1e27 - token0Decimals.\n        // E.g. for USDC/ETH it would be: fetchedPrice * 1e21\n        //\n        // or for inverted (x token0 per 1 token1), formula would be:\n        //    = 1e27 * 10**token0Decimals / fetchedPrice\n        // E.g. for USDC/ETH it would be: 1e33 / fetchedPrice\n\n        // no support for token1Decimals with more than OracleUtils.RATE_OUTPUT_DECIMALS decimals for now as extremely unlikely case\n        _CHAINLINK_PRICE_SCALER_MULTIPLIER1 = 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS - params_.feed1.token0Decimals);\n        _CHAINLINK_INVERT_PRICE_DIVIDEND1 = 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS + params_.feed1.token0Decimals);\n\n        _CHAINLINK_PRICE_SCALER_MULTIPLIER2 = params_.hops > 1\n            ? 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS - params_.feed2.token0Decimals)\n            : 1;\n        _CHAINLINK_INVERT_PRICE_DIVIDEND2 = params_.hops > 1\n            ? 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS + params_.feed2.token0Decimals)\n            : 1;\n\n        _CHAINLINK_PRICE_SCALER_MULTIPLIER3 = params_.hops > 2\n            ? 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS - params_.feed3.token0Decimals)\n            : 1;\n        _CHAINLINK_INVERT_PRICE_DIVIDEND3 = params_.hops > 2\n            ? 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS + params_.feed3.token0Decimals)\n            : 1;\n    }\n\n    /// @dev            Get the exchange rate from Chainlike oracle price feed(s)\n    /// @return rate_   The exchange rate in `OracleUtils.RATE_OUTPUT_DECIMALS`\n    function _getChainlinkExchangeRate() internal view returns (uint256 rate_) {\n        rate_ = _readFeedRate(\n            _CHAINLINK_FEED1,\n            _CHAINLINK_INVERT_RATE1,\n            _CHAINLINK_PRICE_SCALER_MULTIPLIER1,\n            _CHAINLINK_INVERT_PRICE_DIVIDEND1\n        );\n        if (rate_ == 0 || address(_CHAINLINK_FEED2) == address(0)) {\n            // rate 0 or only 1 hop -> return rate of price feed 1\n            return rate_;\n        }\n        rate_ =\n            (rate_ *\n                _readFeedRate(\n                    _CHAINLINK_FEED2,\n                    _CHAINLINK_INVERT_RATE2,\n                    _CHAINLINK_PRICE_SCALER_MULTIPLIER2,\n                    _CHAINLINK_INVERT_PRICE_DIVIDEND2\n                )) /\n            (10 ** OracleUtils.RATE_OUTPUT_DECIMALS);\n\n        if (rate_ == 0 || address(_CHAINLINK_FEED3) == address(0)) {\n            // rate 0 or 2 hops -> return rate of feed 1 combined with feed 2\n            return rate_;\n        }\n\n        // 3 hops -> return rate of feed 1 combined with feed 2 & feed 3\n        rate_ =\n            (rate_ *\n                _readFeedRate(\n                    _CHAINLINK_FEED3,\n                    _CHAINLINK_INVERT_RATE3,\n                    _CHAINLINK_PRICE_SCALER_MULTIPLIER3,\n                    _CHAINLINK_INVERT_PRICE_DIVIDEND3\n                )) /\n            (10 ** OracleUtils.RATE_OUTPUT_DECIMALS);\n    }\n\n    /// @dev reads the exchange `rate_` from a Chainlink price `feed_` taking into account scaling and `invertRate_`\n    function _readFeedRate(\n        IChainlinkAggregatorV3 feed_,\n        bool invertRate_,\n        uint256 priceMultiplier_,\n        uint256 invertDividend_\n    ) private view returns (uint256 rate_) {\n        try feed_.latestRoundData() returns (uint80, int256 exchangeRate_, uint256, uint256, uint80) {\n            // Return the price in `OracleUtils.RATE_OUTPUT_DECIMALS`\n            if (invertRate_) {\n                return invertDividend_ / uint256(exchangeRate_);\n            } else {\n                return uint256(exchangeRate_) * priceMultiplier_;\n            }\n        } catch {\n            return 0;\n        }\n    }\n\n    /// @notice returns all Chainlink oracle related data as utility for easy off-chain use / block explorer in a single view method\n    function chainlinkOracleData()\n        public\n        view\n        returns (\n            uint256 chainlinkExchangeRate_,\n            IChainlinkAggregatorV3 chainlinkFeed1_,\n            bool chainlinkInvertRate1_,\n            uint256 chainlinkExchangeRate1_,\n            IChainlinkAggregatorV3 chainlinkFeed2_,\n            bool chainlinkInvertRate2_,\n            uint256 chainlinkExchangeRate2_,\n            IChainlinkAggregatorV3 chainlinkFeed3_,\n            bool chainlinkInvertRate3_,\n            uint256 chainlinkExchangeRate3_\n        )\n    {\n        return (\n            _getChainlinkExchangeRate(),\n            _CHAINLINK_FEED1,\n            _CHAINLINK_INVERT_RATE1,\n            _readFeedRate(\n                _CHAINLINK_FEED1,\n                _CHAINLINK_INVERT_RATE1,\n                _CHAINLINK_PRICE_SCALER_MULTIPLIER1,\n                _CHAINLINK_INVERT_PRICE_DIVIDEND1\n            ),\n            _CHAINLINK_FEED2,\n            _CHAINLINK_INVERT_RATE2,\n            address(_CHAINLINK_FEED2) == address(0)\n                ? 0\n                : _readFeedRate(\n                    _CHAINLINK_FEED2,\n                    _CHAINLINK_INVERT_RATE2,\n                    _CHAINLINK_PRICE_SCALER_MULTIPLIER2,\n                    _CHAINLINK_INVERT_PRICE_DIVIDEND2\n                ),\n            _CHAINLINK_FEED3,\n            _CHAINLINK_INVERT_RATE3,\n            address(_CHAINLINK_FEED3) == address(0)\n                ? 0\n                : _readFeedRate(\n                    _CHAINLINK_FEED3,\n                    _CHAINLINK_INVERT_RATE3,\n                    _CHAINLINK_PRICE_SCALER_MULTIPLIER3,\n                    _CHAINLINK_INVERT_PRICE_DIVIDEND3\n                )\n        );\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/colDebtPrices/colDebtPriceFluidOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"../../../interfaces/iFluidOracle.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { OracleUtils } from \"../../../libraries/oracleUtils.sol\";\nimport { DexColDebtPriceGetter } from \"./dexColDebtPriceGetter.sol\";\n\n/// @notice reads the col debt Oracle Price from a separately deployed FluidOracle\n/// @dev used to plug result of DexSmartColOracleImpl into any existing FluidOracle.\n/// result of DexSmartColOracleImpl is e.g. for WSTETH/ETH smart col, WSTETH amount per 1 share.\n/// we need 1 share in relation to debt. so e.g. wstETH/ETH smart col w.r.t. USDC debt.\n/// so plug result into wstETH/USDC oracle then we get USDC per 1 share.\nabstract contract DexColDebtPriceFluidOracle is DexColDebtPriceGetter {\n    /// @dev external IFluidOracle used to convert from col or debt shares to a Fluid vault debt token.\n    /// can be address zero if no conversion needed.\n    /// IFluidOracle always returns 1e27 scaled price (DEX_COL_DEBT_ORACLE_PRECISION).\n    IFluidOracle internal immutable COL_DEBT_ORACLE;\n    bool internal immutable COL_DEBT_INVERT;\n\n    constructor(IFluidOracle colDebtOracle_, bool colDebtInvert_) {\n        COL_DEBT_ORACLE = colDebtOracle_;\n        COL_DEBT_INVERT = colDebtInvert_;\n    }\n\n    function _getDexColDebtPriceOperate() internal view override returns (uint256 colDebtPrice_) {\n        if (address(COL_DEBT_ORACLE) == address(0)) {\n            return DEX_COL_DEBT_ORACLE_PRECISION;\n        }\n        colDebtPrice_ = COL_DEBT_ORACLE.getExchangeRateOperate();\n        if (COL_DEBT_INVERT) {\n            colDebtPrice_ = 1e54 / colDebtPrice_;\n        }\n    }\n\n    function _getDexColDebtPriceLiquidate() internal view override returns (uint256 colDebtPrice_) {\n        if (address(COL_DEBT_ORACLE) == address(0)) {\n            return DEX_COL_DEBT_ORACLE_PRECISION;\n        }\n        colDebtPrice_ = COL_DEBT_ORACLE.getExchangeRateLiquidate();\n        if (COL_DEBT_INVERT) {\n            colDebtPrice_ = 1e54 / colDebtPrice_;\n        }\n    }\n\n    /// @notice Returns Col/Debt Oracle data\n    function getDexColDebtOracleData() public view returns (address colDebtOracle_, bool colDebtInvert_) {\n        return (address(COL_DEBT_ORACLE), COL_DEBT_INVERT);\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/colDebtPrices/dexColDebtPriceGetter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @dev abstract contract that any Dex Oracle ColDebtPriceGetter should implement\nabstract contract DexColDebtPriceGetter {\n    uint256 internal constant DEX_COL_DEBT_ORACLE_PRECISION = 1e27;\n\n    function _getDexColDebtPriceOperate() internal view virtual returns (uint256 colDebtPrice_);\n\n    function _getDexColDebtPriceLiquidate() internal view virtual returns (uint256 colDebtPrice_);\n}\n"
    },
    "contracts/oracle/implementations/dex/conversionPriceGetters/conversionPriceCL.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { DexConversionPriceGetter } from \"./dexConversionPriceGetter.sol\";\nimport { ChainlinkOracleImpl } from \"../../../implementations/chainlinkOracleImpl.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @notice returns the reserves conversion price fetched from Chainlink feeds\nabstract contract DexConversionPriceCL is DexConversionPriceGetter, ChainlinkOracleImpl {\n    uint256 internal immutable RESERVES_CONVERSION_PRICE_MULTIPLIER;\n    uint256 internal immutable RESERVES_CONVERSION_PRICE_DIVISOR;\n\n    /// @dev for multiplier and divisor: a Fluid ChainlinkOracle returns the price in token decimals scaled to 1e27 e.g. for USDC per ETH\n    ///      it would be 3400e15 USDC if price is 3400$ per ETH. But the Dex internally would have a price of 3400e27. So for that example\n    ///      the multiplier would have to be 1e12 and the divisor 1.\n    /// @param reservesConversionPriceMultiplier_ The multiplier to bring the fetched price to token1/token0 form as used internally in Dex.\n    /// @param reservesConversionPriceDivisor_ The divisor to bring the fetched price to token1/token0 form as used internally in Dex.\n    constructor(\n        ChainlinkOracleImpl.ChainlinkConstructorParams memory reservesConversion_,\n        uint256 reservesConversionPriceMultiplier_,\n        uint256 reservesConversionPriceDivisor_\n    ) ChainlinkOracleImpl(reservesConversion_) {\n        if (reservesConversionPriceMultiplier_ == 0 || reservesConversionPriceDivisor_ == 0) {\n            revert FluidOracleError(ErrorTypes.DexOracle__InvalidParams);\n        }\n        RESERVES_CONVERSION_PRICE_MULTIPLIER = reservesConversionPriceMultiplier_;\n        RESERVES_CONVERSION_PRICE_DIVISOR = reservesConversionPriceDivisor_;\n    }\n\n    function _getDexReservesConversionPriceOperate() internal view override returns (uint256 conversionPrice_) {\n        // bring conversion price to form as used internally in Dex\n        conversionPrice_ =\n            (_getChainlinkExchangeRate() * RESERVES_CONVERSION_PRICE_MULTIPLIER) /\n            RESERVES_CONVERSION_PRICE_DIVISOR;\n\n        if (conversionPrice_ == 0) {\n            revert FluidOracleError(ErrorTypes.DexOracle__ExchangeRateZero);\n        }\n    }\n\n    function _getDexReservesConversionPriceLiquidate() internal view override returns (uint256 conversionPrice_) {\n        // bring conversion price to form as used internally in Dex\n        conversionPrice_ =\n            (_getChainlinkExchangeRate() * RESERVES_CONVERSION_PRICE_MULTIPLIER) /\n            RESERVES_CONVERSION_PRICE_DIVISOR;\n\n        if (conversionPrice_ == 0) {\n            revert FluidOracleError(ErrorTypes.DexOracle__ExchangeRateZero);\n        }\n    }\n\n    /// @notice Returns the configuration data of the DexConversionPriceFluidOracle.\n    ///\n    /// @return reservesConversionPriceMultiplier_ The multiplier for the reserves conversion price.\n    /// @return reservesConversionPriceDivisor_ The divisor for the reserves conversion price.\n    function getDexConversionPriceFluidOracleData()\n        public\n        view\n        returns (uint256 reservesConversionPriceMultiplier_, uint256 reservesConversionPriceDivisor_)\n    {\n        reservesConversionPriceMultiplier_ = RESERVES_CONVERSION_PRICE_MULTIPLIER;\n        reservesConversionPriceDivisor_ = RESERVES_CONVERSION_PRICE_DIVISOR;\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/conversionPriceGetters/conversionPriceFluidOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { DexConversionPriceGetter } from \"./dexConversionPriceGetter.sol\";\nimport { IFluidOracle } from \"../../../interfaces/iFluidOracle.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @notice returns the reserves conversion price fetched from a separately deployed FluidOracle\nabstract contract DexConversionPriceFluidOracle is DexConversionPriceGetter {\n    /// @dev external IFluidOracle used to convert token0 into token1 or the other way\n    /// around depending on _QUOTE_IN_TOKEN0.\n    IFluidOracle internal immutable RESERVES_CONVERSION_ORACLE;\n    bool internal immutable RESERVES_CONVERSION_INVERT;\n    uint256 internal immutable RESERVES_CONVERSION_PRICE_MULTIPLIER;\n    uint256 internal immutable RESERVES_CONVERSION_PRICE_DIVISOR;\n\n    struct DexConversionPriceFluidOracleParams {\n        address reservesConversionOracle;\n        bool reservesConversionInvert;\n        uint256 reservesConversionPriceMultiplier;\n        uint256 reservesConversionPriceDivisor;\n    }\n\n    /// @dev for multiplier and divisor: a FluidOracle returns the price in token decimals scaled to 1e27 e.g. for USDC per ETH\n    ///      it would be 3400e15 USDC if price is 3400$ per ETH. But the Dex internally would have a price of 3400e27. So for that example\n    ///      the multiplier would have to be 1e12 and the divisor 1.\n    /// @param conversionPriceParams_:\n    ///  - reservesConversionOracle The oracle used to convert reserves. Set to address zero if not needed.\n    ///  - reservesConversionInvert Whether to invert the reserves conversion. Can be skipped if no reservesConversionOracle is configured.\n    ///  - reservesConversionPriceMultiplier The multiplier to bring the fetched price to token1/token0 form as used internally in Dex.\n    ///  - reservesConversionPriceDivisor The divisor to bring the fetched price to token1/token0 form as used internally in Dex.\n    constructor(DexConversionPriceFluidOracleParams memory conversionPriceParams_) {\n        if (\n            conversionPriceParams_.reservesConversionPriceMultiplier == 0 ||\n            conversionPriceParams_.reservesConversionPriceDivisor == 0\n        ) {\n            revert FluidOracleError(ErrorTypes.DexOracle__InvalidParams);\n        }\n        RESERVES_CONVERSION_ORACLE = IFluidOracle(conversionPriceParams_.reservesConversionOracle);\n        RESERVES_CONVERSION_INVERT = conversionPriceParams_.reservesConversionInvert;\n        RESERVES_CONVERSION_PRICE_MULTIPLIER = conversionPriceParams_.reservesConversionPriceMultiplier;\n        RESERVES_CONVERSION_PRICE_DIVISOR = conversionPriceParams_.reservesConversionPriceDivisor;\n    }\n\n    function _getDexReservesConversionPriceOperate() internal view override returns (uint256 conversionPrice_) {\n        if (address(RESERVES_CONVERSION_ORACLE) == address(0)) {\n            return 1e27;\n        }\n\n        // bring conversion price to form as used internally in Dex\n        conversionPrice_ =\n            (RESERVES_CONVERSION_ORACLE.getExchangeRateOperate() * RESERVES_CONVERSION_PRICE_MULTIPLIER) /\n            RESERVES_CONVERSION_PRICE_DIVISOR;\n\n        if (RESERVES_CONVERSION_INVERT) {\n            conversionPrice_ = 1e54 / conversionPrice_;\n        }\n    }\n\n    function _getDexReservesConversionPriceLiquidate() internal view override returns (uint256 conversionPrice_) {\n        if (address(RESERVES_CONVERSION_ORACLE) == address(0)) {\n            return 1e27;\n        }\n\n        // bring conversion price to form as used internally in Dex\n        conversionPrice_ =\n            (RESERVES_CONVERSION_ORACLE.getExchangeRateLiquidate() * RESERVES_CONVERSION_PRICE_MULTIPLIER) /\n            RESERVES_CONVERSION_PRICE_DIVISOR;\n        if (RESERVES_CONVERSION_INVERT) {\n            conversionPrice_ = 1e54 / conversionPrice_;\n        }\n    }\n\n    /// @notice Returns the configuration data of the DexConversionPriceFluidOracle.\n    ///\n    /// @return reservesConversionOracle_ The address of the reserves conversion oracle.\n    /// @return reservesConversionInvert_ A boolean indicating if reserves conversion should be inverted.\n    /// @return reservesConversionPriceMultiplier_ The multiplier for the reserves conversion price.\n    /// @return reservesConversionPriceDivisor_ The divisor for the reserves conversion price.\n    function getDexConversionPriceFluidOracleData()\n        public\n        view\n        returns (\n            address reservesConversionOracle_,\n            bool reservesConversionInvert_,\n            uint256 reservesConversionPriceMultiplier_,\n            uint256 reservesConversionPriceDivisor_\n        )\n    {\n        reservesConversionOracle_ = address(RESERVES_CONVERSION_ORACLE);\n        reservesConversionInvert_ = RESERVES_CONVERSION_INVERT;\n        reservesConversionPriceMultiplier_ = RESERVES_CONVERSION_PRICE_MULTIPLIER;\n        reservesConversionPriceDivisor_ = RESERVES_CONVERSION_PRICE_DIVISOR;\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/conversionPriceGetters/dexConversionPriceGetter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { DexOracleBase } from \"../dexOracleBase.sol\";\n\n/// @dev abstract contract that any Dex Oracle ConversionPriceGetter should implement\nabstract contract DexConversionPriceGetter is DexOracleBase {\n    function _getDexReservesConversionPriceOperate() internal view virtual returns (uint256 conversionPrice_);\n\n    function _getDexReservesConversionPriceLiquidate() internal view virtual returns (uint256 conversionPrice_);\n}\n"
    },
    "contracts/oracle/implementations/dex/dexOracleBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error as OracleError } from \"../../error.sol\";\n\ninterface IFluidStorageReadable {\n    function readFromStorage(bytes32 slot_) external view returns (uint result_);\n}\n\nabstract contract DexOracleAdjustResult {\n    uint256 internal immutable RESULT_MULTIPLIER;\n    uint256 internal immutable RESULT_DIVISOR;\n\n    constructor(uint256 resultMultiplier_, uint256 resultDivisor_) {\n        RESULT_MULTIPLIER = resultMultiplier_ == 0 ? 1 : resultMultiplier_;\n        RESULT_DIVISOR = resultDivisor_ == 0 ? 1 : resultDivisor_;\n    }\n}\n\nabstract contract DexOracleBase is DexOracleAdjustResult, OracleError {\n    IFluidDexT1 internal immutable DEX_;\n\n    IFluidStorageReadable internal constant LIQUIDITY =\n        IFluidStorageReadable(0x52Aa899454998Be5b000Ad077a46Bbe360F4e497);\n\n    /// @dev if true, convert all reserves token1 into token0. otherwise all token0 into token1.\n    bool internal immutable QUOTE_IN_TOKEN0;\n\n    /// @dev internal immutables read from DEX at time of deployment\n    bytes32 internal immutable SUPPLY_TOKEN_0_SLOT;\n    bytes32 internal immutable SUPPLY_TOKEN_1_SLOT;\n    bytes32 internal immutable BORROW_TOKEN_0_SLOT;\n    bytes32 internal immutable BORROW_TOKEN_1_SLOT;\n    bytes32 internal immutable EXCHANGE_PRICE_TOKEN_0_SLOT;\n    bytes32 internal immutable EXCHANGE_PRICE_TOKEN_1_SLOT;\n\n    uint256 internal immutable TOKEN_0_NUMERATOR_PRECISION;\n    uint256 internal immutable TOKEN_0_DENOMINATOR_PRECISION;\n    uint256 internal immutable TOKEN_1_NUMERATOR_PRECISION;\n    uint256 internal immutable TOKEN_1_DENOMINATOR_PRECISION;\n\n    constructor(address dexPool_, bool quoteInToken0_) {\n        if (dexPool_ == address(0)) {\n            revert FluidOracleError(ErrorTypes.DexOracle__InvalidParams);\n        }\n\n        DEX_ = IFluidDexT1(dexPool_);\n        QUOTE_IN_TOKEN0 = quoteInToken0_;\n\n        IFluidDexT1.ConstantViews memory constantViews_ = DEX_.constantsView();\n        EXCHANGE_PRICE_TOKEN_0_SLOT = constantViews_.exchangePriceToken0Slot;\n        EXCHANGE_PRICE_TOKEN_1_SLOT = constantViews_.exchangePriceToken1Slot;\n        SUPPLY_TOKEN_0_SLOT = constantViews_.supplyToken0Slot;\n        SUPPLY_TOKEN_1_SLOT = constantViews_.supplyToken1Slot;\n        BORROW_TOKEN_0_SLOT = constantViews_.borrowToken0Slot;\n        BORROW_TOKEN_1_SLOT = constantViews_.borrowToken1Slot;\n\n        IFluidDexT1.ConstantViews2 memory constantViews2_ = DEX_.constantsView2();\n        TOKEN_0_NUMERATOR_PRECISION = constantViews2_.token0NumeratorPrecision;\n        TOKEN_0_DENOMINATOR_PRECISION = constantViews2_.token0DenominatorPrecision;\n        TOKEN_1_NUMERATOR_PRECISION = constantViews2_.token1NumeratorPrecision;\n        TOKEN_1_DENOMINATOR_PRECISION = constantViews2_.token1DenominatorPrecision;\n    }\n\n    /// @dev returns combined Dex debt reserves in quote token, scaled to quote token decimals\n    function _getDexReservesCombinedInQuoteToken(\n        uint256 conversionPrice_,\n        uint256 token0Reserves_,\n        uint256 token1Reserves_\n    ) internal view virtual returns (uint256 reserves_) {\n        if (QUOTE_IN_TOKEN0) {\n            // e.g. for USDC / ETH DEX when:\n            // \"token0RealReserves\": \"6534_060871000000\", // USDC\n            // \"token1RealReserves\": \"1_330669697660\", // ETH\n            // \"lastStoredPrice\": \"0_000293732487359446271393792\",\n            // 6534_060871000000 + (1_330669697660 * (1e54 / 0_000293732487359446271393792)) / 1e27 = 11064_270347051701 USDC\n\n            // Conversion price must be inverted to be token0/token1\n            conversionPrice_ = 1e54 / conversionPrice_;\n\n            reserves_ = token0Reserves_ + (token1Reserves_ * conversionPrice_) / (1e27);\n\n            // bring reserves to token0 decimals\n            reserves_ = ((reserves_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\n        } else {\n            // e.g. for USDC / ETH DEX when:\n            // \"token0RealReserves\": \"6534_060871000000\", // USDC\n            // \"token1RealReserves\": \"1_330669697660\", // ETH\n            // \"lastStoredPrice\": \"0_000293732487359446271393792\",\n            // 1_330669697660 + (6534_060871000000 * 0_000293732487359446271393792) / 1e27 = 3_249935649856 ETH\n\n            reserves_ = token1Reserves_ + (token0Reserves_ * conversionPrice_) / (1e27);\n\n            // bring reserves to token1 decimals\n            reserves_ = ((reserves_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n        }\n    }\n\n    /// @notice Returns the base configuration data of the FluidDexOracle.\n    ///\n    /// @return dexPool_ The address of the Dex pool.\n    /// @return quoteInToken0_ A boolean indicating if the quote is in token0.\n    /// @return liquidity_ The address of liquidity layer.\n    /// @return resultMultiplier_ The result multiplier.\n    /// @return resultDivisor_ The result divisor.\n    function dexOracleData()\n        public\n        view\n        returns (\n            address dexPool_,\n            bool quoteInToken0_,\n            address liquidity_,\n            uint256 resultMultiplier_,\n            uint256 resultDivisor_\n        )\n    {\n        return (address(DEX_), QUOTE_IN_TOKEN0, address(LIQUIDITY), RESULT_MULTIPLIER, RESULT_DIVISOR);\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/dexPricesAndExchangePrices.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { LiquidityCalcs } from \"../../../libraries/liquidityCalcs.sol\";\nimport { LiquiditySlotsLink } from \"../../../libraries/liquiditySlotsLink.sol\";\nimport { DexSlotsLink } from \"../../../libraries/dexSlotsLink.sol\";\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { DexOracleBase } from \"./dexOracleBase.sol\";\n\ninterface ICenterPrice {\n    function centerPrice() external view returns (uint256);\n}\n\nabstract contract DexPricesAndExchangePrices is DexOracleBase {\n    uint256 private constant X8 = 0xff;\n    uint256 private constant X10 = 0x3ff;\n    uint256 private constant X20 = 0xfffff;\n    uint256 private constant X24 = 0xffffff;\n    uint256 private constant X28 = 0xfffffff;\n    uint256 private constant X30 = 0x3fffffff;\n    uint256 private constant X33 = 0x1ffffffff;\n    uint256 private constant X40 = 0xffffffffff;\n    uint256 private constant X64 = 0xffffffffffffffff;\n    uint256 private constant X128 = 0xffffffffffffffffffffffffffffffff;\n\n    uint256 private constant THREE_DECIMALS = 1e3;\n    uint256 private constant SIX_DECIMALS = 1e6;\n\n    uint256 private constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 private constant DEFAULT_EXPONENT_MASK = 0xff;\n\n    /// @dev This function calculates the new value of a parameter after a shifting process.\n    /// @param current_ The current value is the final value where the shift ends\n    /// @param old_ The old value from where shifting started.\n    /// @param timePassed_ The time passed since shifting started.\n    /// @param shiftDuration_ The total duration of the shift when old_ reaches current_\n    /// @return The new value of the parameter after the shift.\n    function _calcShiftingDone(\n        uint current_,\n        uint old_,\n        uint timePassed_,\n        uint shiftDuration_\n    ) internal pure returns (uint) {\n        if (current_ > old_) {\n            uint diff_ = current_ - old_;\n            current_ = old_ + ((diff_ * timePassed_) / shiftDuration_);\n        } else {\n            uint diff_ = old_ - current_;\n            current_ = old_ - ((diff_ * timePassed_) / shiftDuration_);\n        }\n        return current_;\n    }\n\n    /// @dev Calculates the new upper and lower range values during an active range shift\n    /// @param upperRange_ The target upper range value\n    /// @param lowerRange_ The target lower range value\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\n    /// @return The updated upper range, lower range, and dexVariables2\n    /// @notice This function handles the gradual shifting of range values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcRangeShifting(\n        uint upperRange_,\n        uint lowerRange_,\n        uint dexVariables2_\n    ) internal view returns (uint, uint, uint) {\n        uint rangeShift_ = DEX_.readFromStorage(bytes32(DexSlotsLink.DEX_RANGE_THRESHOLD_SHIFTS_SLOT)) & X128;\n        uint oldUpperRange_ = rangeShift_ & X20;\n        uint oldLowerRange_ = (rangeShift_ >> 20) & X20;\n        uint shiftDuration_ = (rangeShift_ >> 40) & X20;\n        uint startTimeStamp_ = ((rangeShift_ >> 60) & X33);\n        if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n            // shifting fully done\n            // note: not deleting from storage as this is oracle address\n            // delete _rangeShift;\n\n            // making active shift as 0 because shift is over\n            // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates from this function and _calcThresholdShifting.\n            // Note: not fetching & updating on storage because this is oracle address\n            dexVariables2_ = dexVariables2_ & ~uint(1 << 26);\n            // dexVariables2 = dexVariables2_;\n            return (upperRange_, lowerRange_, dexVariables2_);\n        }\n        uint timePassed_ = block.timestamp - startTimeStamp_;\n        return (\n            _calcShiftingDone(upperRange_, oldUpperRange_, timePassed_, shiftDuration_),\n            _calcShiftingDone(lowerRange_, oldLowerRange_, timePassed_, shiftDuration_),\n            dexVariables2_\n        );\n    }\n\n    /// @dev Calculates the new upper and lower threshold values during an active threshold shift\n    /// @param upperThreshold_ The target upper threshold value\n    /// @param lowerThreshold_ The target lower threshold value\n    /// @param thresholdTime_ The time passed since shifting started\n    /// @return The updated upper threshold, lower threshold, and threshold time\n    /// @notice This function handles the gradual shifting of threshold values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcThresholdShifting(\n        uint upperThreshold_,\n        uint lowerThreshold_,\n        uint thresholdTime_\n    ) internal view returns (uint, uint, uint) {\n        uint thresholdShift_ = (DEX_.readFromStorage(bytes32(DexSlotsLink.DEX_RANGE_THRESHOLD_SHIFTS_SLOT)) >> 128) &\n            X128;\n        uint oldUpperThreshold_ = thresholdShift_ & X20;\n        uint oldLowerThreshold_ = (thresholdShift_ >> 20) & X20;\n        uint shiftDuration_ = (thresholdShift_ >> 40) & X20;\n        uint startTimeStamp_ = ((thresholdShift_ >> 60) & X33);\n        uint oldThresholdTime_ = (thresholdShift_ >> 93) & X24;\n        if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n            // shifting fully done\n            // note: not deleting from storage as this is oracle address\n            // delete _thresholdShift;\n\n            // making active shift as 0 because shift is over\n            // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates from this function and _calcRangeShifting.\n            // note: not updating on storage because this is oracle address\n            // dexVariables2 = dexVariables2 & ~uint(1 << 67);\n            return (upperThreshold_, lowerThreshold_, thresholdTime_);\n        }\n        uint timePassed_ = block.timestamp - startTimeStamp_;\n        return (\n            _calcShiftingDone(upperThreshold_, oldUpperThreshold_, timePassed_, shiftDuration_),\n            _calcShiftingDone(lowerThreshold_, oldLowerThreshold_, timePassed_, shiftDuration_),\n            _calcShiftingDone(thresholdTime_, oldThresholdTime_, timePassed_, shiftDuration_)\n        );\n    }\n\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    /// @notice Calculates and returns the current prices and exchange prices for the pool\n    /// @return pex_ A struct containing the calculated prices and exchange prices:\n    ///         - pex_.lastStoredPrice: The last stored price in 1e27 decimals\n    ///         - pex_.centerPrice: The calculated or fetched center price in 1e27 decimals\n    ///         - pex_.upperRange: The upper range price limit in 1e27 decimals\n    ///         - pex_.lowerRange: The lower range price limit in 1e27 decimals\n    ///         - pex_.geometricMean: The geometric mean of upper range & lower range in 1e27 decimals\n    ///         - pex_.supplyToken0ExchangePrice: The current exchange price for supplying token0\n    ///         - pex_.borrowToken0ExchangePrice: The current exchange price for borrowing token0\n    ///         - pex_.supplyToken1ExchangePrice: The current exchange price for supplying token1\n    ///         - pex_.borrowToken1ExchangePrice: The current exchange price for borrowing token1\n    /// @dev This function performs the following operations:\n    ///      1. Determines the center price (either from storage, external source, or calculated)\n    ///      2. Retrieves the last stored price from dexVariables_\n    ///      3. Calculates the upper and lower range prices based on the center price and range percentages\n    ///      4. Checks if rebalancing is needed based on threshold settings\n    ///      5. Adjusts prices if necessary based on the time elapsed and threshold conditions\n    ///      6. Update the dexVariables2_ if changes were made\n    ///      7. Returns the calculated prices and exchange prices in the PricesAndExchangePrice struct\n    function _getPricesAndExchangePrices() internal view returns (PricesAndExchangePrice memory pex_) {\n        uint dexVariables_ = DEX_.readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES_SLOT));\n        uint dexVariables2_ = DEX_.readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        uint centerPrice_;\n\n        if (((dexVariables2_ >> 248) & 1) == 0) {\n            // centerPrice_ => center price hook\n            centerPrice_ = (dexVariables2_ >> 112) & X30;\n            if (centerPrice_ == 0) {\n                centerPrice_ = (dexVariables_ >> 81) & X40;\n                centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n            } else {\n                // center price should be fetched from external source. For exmaple, in case of wstETH <> ETH pool,\n                // we would want the center price to be pegged to wstETH exchange rate into ETH\n\n                // Note: commenting ICenterPrice call as oracle should be used for non peg pools so center price should not be pegged to external source\n                // centerPrice_ = ICenterPrice(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, centerPrice_)).centerPrice();\n                revert(\"PricesAndExchangePrices: center price should not be pegged to external source\");\n            }\n        } else {\n            // an active centerPrice_ shift is going on\n\n            // @Samyak please verify below. I removed the _calcCenterPrice() method completely. The reverts here are very risky if we ever add\n            // a center price for any reason to an existing non-peg pool as oracle would start reverting. That should never happen but\n            // very critical to remember this.\n\n            // Note: commenting _calcCenterPrice call as oracle should be used for non peg pools so center price should not be shifting,\n            // as the shift uses an external source.\n            // centerPrice_ = _calcCenterPrice(dexVariables_, dexVariables2_);\n            revert(\"PricesAndExchangePrices: center price should not be pegged to external source\");\n        }\n\n        uint lastStoredPrice_ = (dexVariables_ >> 41) & X40;\n        lastStoredPrice_ = (lastStoredPrice_ >> DEFAULT_EXPONENT_SIZE) << (lastStoredPrice_ & DEFAULT_EXPONENT_MASK);\n\n        uint upperRange_ = ((dexVariables2_ >> 27) & X20);\n        uint lowerRange_ = ((dexVariables2_ >> 47) & X20);\n        if (((dexVariables2_ >> 26) & 1) == 1) {\n            // an active range shift is going on\n            (upperRange_, lowerRange_, dexVariables2_) = _calcRangeShifting(upperRange_, lowerRange_, dexVariables2_);\n        }\n\n        unchecked {\n            // adding into unchecked because upperRange_ & lowerRange_ can only be > 0 & < SIX_DECIMALS\n            // 1% = 1e4, 100% = 1e6\n            upperRange_ = (centerPrice_ * SIX_DECIMALS) / (SIX_DECIMALS - upperRange_);\n            // 1% = 1e4, 100% = 1e6\n            lowerRange_ = (centerPrice_ * (SIX_DECIMALS - lowerRange_)) / SIX_DECIMALS;\n        }\n\n        bool changed_;\n        {\n            // goal will be to keep threshold percents 0 if center price is fetched from external source\n            // checking if threshold are set non 0 then only rebalancing is on\n            if (((dexVariables2_ >> 68) & X20) > 0) {\n                uint upperThreshold_ = (dexVariables2_ >> 68) & X10;\n                uint lowerThreshold_ = (dexVariables2_ >> 78) & X10;\n                uint shiftingTime_ = (dexVariables2_ >> 88) & X24;\n                if (((dexVariables2_ >> 67) & 1) == 1) {\n                    // if active shift is going on for threshold then calculate threshold real time\n                    (upperThreshold_, lowerThreshold_, shiftingTime_) = _calcThresholdShifting(\n                        upperThreshold_,\n                        lowerThreshold_,\n                        shiftingTime_\n                    );\n                }\n\n                unchecked {\n                    if (\n                        lastStoredPrice_ >\n                        (centerPrice_ +\n                            ((upperRange_ - centerPrice_) * (THREE_DECIMALS - upperThreshold_)) /\n                            THREE_DECIMALS)\n                    ) {\n                        uint timeElapsed_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n                        // price shifting towards upper range\n                        if (timeElapsed_ < shiftingTime_) {\n                            centerPrice_ = centerPrice_ + ((upperRange_ - centerPrice_) * timeElapsed_) / shiftingTime_;\n                        } else {\n                            // 100% price shifted\n                            centerPrice_ = upperRange_;\n                        }\n                        changed_ = true;\n                    } else if (\n                        lastStoredPrice_ <\n                        (centerPrice_ -\n                            ((centerPrice_ - lowerRange_) * (THREE_DECIMALS - lowerThreshold_)) /\n                            THREE_DECIMALS)\n                    ) {\n                        uint timeElapsed_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n                        // price shifting towards lower range\n                        if (timeElapsed_ < shiftingTime_) {\n                            centerPrice_ = centerPrice_ - ((centerPrice_ - lowerRange_) * timeElapsed_) / shiftingTime_;\n                        } else {\n                            // 100% price shifted\n                            centerPrice_ = lowerRange_;\n                        }\n                        changed_ = true;\n                    }\n                }\n            }\n        }\n\n        // temp_ => max center price\n        uint temp_ = (dexVariables2_ >> 172) & X28;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n        if (centerPrice_ > temp_) {\n            // if center price is greater than max center price\n            centerPrice_ = temp_;\n            changed_ = true;\n        } else {\n            // check if center price is less than min center price\n            // temp_ => min center price\n            temp_ = (dexVariables2_ >> 200) & X28;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n            if (centerPrice_ < temp_) {\n                centerPrice_ = temp_;\n                changed_ = true;\n            }\n        }\n\n        // if centerPrice_ is changed then calculating upper and lower range again\n        if (changed_) {\n            upperRange_ = ((dexVariables2_ >> 27) & X20);\n            lowerRange_ = ((dexVariables2_ >> 47) & X20);\n            if (((dexVariables2_ >> 26) & 1) == 1) {\n                (upperRange_, lowerRange_, dexVariables2_) = _calcRangeShifting(\n                    upperRange_,\n                    lowerRange_,\n                    dexVariables2_\n                );\n            }\n\n            unchecked {\n                // adding into unchecked because upperRange_ & lowerRange_ can only be > 0 & < SIX_DECIMALS\n                // 1% = 1e4, 100% = 1e6\n                upperRange_ = (centerPrice_ * SIX_DECIMALS) / (SIX_DECIMALS - upperRange_);\n                // 1% = 1e4, 100% = 1e6\n                lowerRange_ = (centerPrice_ * (SIX_DECIMALS - lowerRange_)) / SIX_DECIMALS;\n            }\n        }\n\n        pex_.lastStoredPrice = lastStoredPrice_;\n        pex_.centerPrice = centerPrice_;\n        pex_.upperRange = upperRange_;\n        pex_.lowerRange = lowerRange_;\n\n        unchecked {\n            if (upperRange_ < 1e38) {\n                // 1e38 * 1e38 = 1e76 which is less than max uint limit\n                pex_.geometricMean = FixedPointMathLib.sqrt(upperRange_ * lowerRange_);\n            } else {\n                // upperRange_ price is pretty large hence lowerRange_ will also be pretty large\n                pex_.geometricMean = FixedPointMathLib.sqrt((upperRange_ / 1e18) * (lowerRange_ / 1e18)) * 1e18;\n            }\n        }\n\n        // Exchange price will remain same as Liquidity Layer\n        (pex_.supplyToken0ExchangePrice, pex_.borrowToken0ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_0_SLOT)\n        );\n\n        (pex_.supplyToken1ExchangePrice, pex_.borrowToken1ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_1_SLOT)\n        );\n    }\n\n    /// @dev getting reserves outside range.\n    /// @param gp_ is geometric mean pricing of upper percent & lower percent\n    /// @param pa_ price of upper range or lower range\n    /// @param rx_ real reserves of token0 or token1\n    /// @param ry_ whatever is rx_ the other will be ry_\n    function _calculateReservesOutsideRange(\n        uint gp_,\n        uint pa_,\n        uint rx_,\n        uint ry_\n    ) internal pure returns (uint xa_, uint yb_) {\n        // equations we have:\n        // 1. x*y = k\n        // 2. xa*ya = k\n        // 3. xb*yb = k\n        // 4. Pa = ya / xa = upperRange_ (known)\n        // 5. Pb = yb / xb = lowerRange_ (known)\n        // 6. x - xa = rx = real reserve of x (known)\n        // 7. y - yb = ry = real reserve of y (known)\n        // With solving we get:\n        // ((Pa*Pb)^(1/2) - Pa)*xa^2 + (rx * (Pa*Pb)^(1/2) + ry)*xa + rx*ry = 0\n        // yb = yb = xa * (Pa * Pb)^(1/2)\n\n        // xa = (GPrx + ry + (-rxry4(GP - Pa) + (GPrx + ry)^2)^0.5) / (2Pa - 2GP)\n        // multiply entire equation by 1e27 to remove the price decimals precision of 1e27\n        // xa = (GPrx + ry1e27 + (rxry4(Pa - GP)1e27 + (GPrx + ry1e27)^2)^0.5) / 2*(Pa - GP)\n        // dividing the equation with 2*(Pa - GP). Pa is always > GP so answer will be positive.\n        // xa = (((GPrx + ry1e27) / 2*(Pa - GP)) + (((rxry4(Pa - GP)1e27) / 4*(Pa - GP)^2) + ((GPrx + ry1e27) / 2*(Pa - GP))^2)^0.5)\n        // xa = (((GPrx + ry1e27) / 2*(Pa - GP)) + (((rxry1e27) / (Pa - GP)) + ((GPrx + ry1e27) / 2*(Pa - GP))^2)^0.5)\n\n        // dividing in 3 parts for simplification:\n        // part1 = (Pa - GP)\n        // part2 = (GPrx + ry1e27) / (2*part1)\n        // part3 = rxry\n        // note: part1 will almost always be < 1e28 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e29\n        uint p1_ = pa_ - gp_;\n        uint p2_ = ((gp_ * rx_) + (ry_ * 1e27)) / (2 * p1_);\n        uint p3_ = rx_ * ry_;\n        // to avoid overflowing\n        p3_ = (p3_ < 1e50) ? ((p3_ * 1e27) / p1_) : (p3_ / p1_) * 1e27;\n\n        // xa = part2 + (part3 + (part2 * part2))^(1/2)\n        // yb = xa_ * gp_\n        xa_ = p2_ + FixedPointMathLib.sqrt((p3_ + (p2_ * p2_)));\n        yb_ = (xa_ * gp_) / 1e27;\n    }\n\n    /// @dev Retrieves collateral amount from liquidity layer for a given token\n    /// @param supplyTokenSlot_ The storage slot for the supply token data\n    /// @param tokenExchangePrice_ The exchange price of the token\n    /// @param isToken0_ Boolean indicating if the token is token0 (true) or token1 (false)\n    /// @return tokenSupply_ The calculated liquidity collateral amount\n    function _getLiquidityCollateral(\n        bytes32 supplyTokenSlot_,\n        uint tokenExchangePrice_,\n        bool isToken0_\n    ) internal view returns (uint tokenSupply_) {\n        uint tokenSupplyData_ = LIQUIDITY.readFromStorage(supplyTokenSlot_);\n        tokenSupply_ = (tokenSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n        tokenSupply_ = (tokenSupply_ >> DEFAULT_EXPONENT_SIZE) << (tokenSupply_ & DEFAULT_EXPONENT_MASK);\n\n        if (tokenSupplyData_ & 1 == 1) {\n            // supply with interest is on\n            unchecked {\n                tokenSupply_ = (tokenSupply_ * tokenExchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n            }\n        }\n\n        unchecked {\n            tokenSupply_ = isToken0_\n                ? ((tokenSupply_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\n                : ((tokenSupply_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\n        }\n    }\n\n    /// @notice Calculates the real and imaginary reserves for collateral tokens\n    /// @dev This function retrieves the supply of both tokens from the liquidity layer,\n    ///      adjusts them based on exchange prices, and calculates imaginary reserves\n    ///      based on the geometric mean and price range\n    /// @param geometricMean_ The geometric mean of the token prices\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0SupplyExchangePrice_ The exchange price for token0 from liquidity layer\n    /// @param token1SupplyExchangePrice_ The exchange price for token1 from liquidity layer\n    /// @return c_ A struct containing the calculated real and imaginary reserves for both tokens:\n    ///         - token0RealReserves: The real reserves of token0\n    ///         - token1RealReserves: The real reserves of token1\n    ///         - token0ImaginaryReserves: The imaginary reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary reserves of token1\n    function _getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) internal view returns (CollateralReserves memory c_) {\n        uint token0Supply_ = _getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, token0SupplyExchangePrice_, true);\n        uint token1Supply_ = _getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, token1SupplyExchangePrice_, false);\n\n        if (geometricMean_ < 1e27) {\n            (c_.token0ImaginaryReserves, c_.token1ImaginaryReserves) = _calculateReservesOutsideRange(\n                geometricMean_,\n                upperRange_,\n                token0Supply_,\n                token1Supply_\n            );\n        } else {\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n            // 1 / geometricMean for new geometricMean\n            // 1 / lowerRange will become upper range\n            // 1 / upperRange will become lower range\n            (c_.token1ImaginaryReserves, c_.token0ImaginaryReserves) = _calculateReservesOutsideRange(\n                (1e54 / geometricMean_),\n                (1e54 / lowerRange_),\n                token1Supply_,\n                token0Supply_\n            );\n        }\n\n        c_.token0RealReserves = token0Supply_;\n        c_.token1RealReserves = token1Supply_;\n        unchecked {\n            c_.token0ImaginaryReserves += token0Supply_;\n            c_.token1ImaginaryReserves += token1Supply_;\n        }\n    }\n\n    /// @notice Calculates the real and imaginary debt reserves for both tokens\n    /// @dev This function uses a quadratic equation to determine the debt reserves\n    ///      based on the geometric mean price and the current debt amounts\n    /// @param gp_ The geometric mean price of upper range & lower range\n    /// @param pb_ The price of lower range\n    /// @param dx_ The debt amount of one token\n    /// @param dy_ The debt amount of the other token\n    /// @return rx_ The real debt reserve of the first token\n    /// @return ry_ The real debt reserve of the second token\n    /// @return irx_ The imaginary debt reserve of the first token\n    /// @return iry_ The imaginary debt reserve of the second token\n    function _calculateDebtReserves(\n        uint gp_,\n        uint pb_,\n        uint dx_,\n        uint dy_\n    ) internal pure returns (uint rx_, uint ry_, uint irx_, uint iry_) {\n        // Assigning letter to knowns:\n        // c = debtA\n        // d = debtB\n        // e = upperPrice\n        // f = lowerPrice\n        // g = upperPrice^1/2\n        // h = lowerPrice^1/2\n\n        // c = 1\n        // d = 2000\n        // e = 2222.222222\n        // f = 1800\n        // g = 2222.222222^1/2\n        // h = 1800^1/2\n\n        // Assigning letter to unknowns:\n        // w = realDebtReserveA\n        // x = realDebtReserveB\n        // y = imaginaryDebtReserveA\n        // z = imaginaryDebtReserveB\n        // k = k\n\n        // below quadratic will give answer of realDebtReserveB\n        // A, B, C of quadratic equation:\n        // A = h\n        // B = dh - cfg\n        // C = -cfdh\n\n        // A = lowerPrice^1/2\n        // B = debtBlowerPrice^1/2 - debtAlowerPriceupperPrice^1/2\n        // C = -(debtAlowerPricedebtBlowerPrice^1/2)\n\n        // x = (cfg  dh + (4cdf(h^2)+(cfgdh)^2))^(1/2)) / 2h\n        // simplifying dividing by h, note h = f^1/2\n        // x = ((cg(f^1/2)  d) / 2 + ((4cdff) / (4h^2) + ((cfg) / 2h  (dh) / 2h)^2))^(1/2))\n        // x = ((cg(f^1/2)  d) / 2 + ((cdf) + ((cg(f^1/2)  d) / 2)^2))^(1/2))\n\n        // dividing in 3 parts for simplification:\n        // part1 = (cg(f^1/2)  d) / 2\n        // part2 = (cdf)\n        // x = (part1 + (part2 + part1^2)^(1/2))\n        // note: part1 will almost always be < 1e27 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e28\n\n        // part1 = ((debtA * upperPrice^1/2 * lowerPrice^1/2) - debtB) / 2\n        // note: upperPrice^1/2 * lowerPrice^1/2 = geometric mean\n        // part1 = ((debtA * geometricMean) - debtB) / 2\n        // part2 = debtA * debtB * lowerPrice\n\n        // converting decimals properly as price is in 1e27 decimals\n        // part1 = ((debtA * geometricMean) - (debtB * 1e27)) / (2 * 1e27)\n        // part2 = (debtA * debtB * lowerPrice) / 1e27\n        // final x equals:\n        // x = (part1 + (part2 + part1^2)^(1/2))\n        int p1_ = (int(dx_ * gp_) - int(dy_ * 1e27)) / (2 * 1e27);\n        uint p2_ = (dx_ * dy_);\n        p2_ = p2_ < 1e50 ? (p2_ * pb_) / 1e27 : (p2_ / 1e27) * pb_;\n        ry_ = uint(p1_ + int(FixedPointMathLib.sqrt((p2_ + uint(p1_ * p1_)))));\n\n        // finding z:\n        // x^2 - zx + cfz = 0\n        // z*(x - cf) = x^2\n        // z = x^2 / (x - cf)\n        // z = x^2 / (x - debtA * lowerPrice)\n        // converting decimals properly as price is in 1e27 decimals\n        // z = (x^2 * 1e27) / ((x * 1e27) - (debtA * lowerPrice))\n\n        iry_ = ((ry_ * 1e27) - (dx_ * pb_));\n        if (iry_ < SIX_DECIMALS) {\n            // almost impossible situation to ever get here\n            revert(\"Debt reserves too low\");\n        }\n        if (ry_ < 1e25) {\n            iry_ = (ry_ * ry_ * 1e27) / iry_;\n        } else {\n            // note: it can never result in negative as final result will always be in positive\n            iry_ = (ry_ * ry_) / (iry_ / 1e27);\n        }\n\n        // finding y\n        // x = z * c / (y + c)\n        // y + c = z * c / x\n        // y = (z * c / x) - c\n        // y = (z * debtA / x) - debtA\n        irx_ = ((iry_ * dx_) / ry_) - dx_;\n\n        // finding w\n        // w = y * d / (z + d)\n        // w = (y * debtB) / (z + debtB)\n        rx_ = (irx_ * dy_) / (iry_ + dy_);\n    }\n\n    /// @notice Calculates the debt amount for a given token from liquidity layer\n    /// @param borrowTokenSlot_ The storage slot for the token's borrow data\n    /// @param tokenExchangePrice_ The current exchange price of the token\n    /// @param isToken0_ Boolean indicating if this is for token0 (true) or token1 (false)\n    /// @return tokenDebt_ The calculated debt amount for the token\n    function _getLiquidityDebt(\n        bytes32 borrowTokenSlot_,\n        uint tokenExchangePrice_,\n        bool isToken0_\n    ) internal view returns (uint tokenDebt_) {\n        uint tokenBorrowData_ = LIQUIDITY.readFromStorage(borrowTokenSlot_);\n\n        tokenDebt_ = (tokenBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n        tokenDebt_ = (tokenDebt_ >> 8) << (tokenDebt_ & X8);\n\n        if (tokenBorrowData_ & 1 == 1) {\n            // borrow with interest is on\n            unchecked {\n                tokenDebt_ = (tokenDebt_ * tokenExchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n            }\n        }\n\n        unchecked {\n            tokenDebt_ = isToken0_\n                ? ((tokenDebt_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\n                : ((tokenDebt_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\n        }\n    }\n\n    /// @notice Calculates the debt reserves for both tokens\n    /// @param geometricMean_ The geometric mean of the upper and lower price ranges\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0BorrowExchangePrice_ The exchange price of token0 from liquidity layer\n    /// @param token1BorrowExchangePrice_ The exchange price of token1 from liquidity layer\n    /// @return d_ The calculated debt reserves for both tokens, containing:\n    ///         - token0Debt: The debt amount of token0\n    ///         - token1Debt: The debt amount of token1\n    ///         - token0RealReserves: The real reserves of token0 derived from token1 debt\n    ///         - token1RealReserves: The real reserves of token1 derived from token0 debt\n    ///         - token0ImaginaryReserves: The imaginary debt reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary debt reserves of token1\n    function _getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) internal view returns (DebtReserves memory d_) {\n        uint token0Debt_ = _getLiquidityDebt(BORROW_TOKEN_0_SLOT, token0BorrowExchangePrice_, true);\n        uint token1Debt_ = _getLiquidityDebt(BORROW_TOKEN_1_SLOT, token1BorrowExchangePrice_, false);\n\n        d_.token0Debt = token0Debt_;\n        d_.token1Debt = token1Debt_;\n\n        if (geometricMean_ < 1e27) {\n            (\n                d_.token0RealReserves,\n                d_.token1RealReserves,\n                d_.token0ImaginaryReserves,\n                d_.token1ImaginaryReserves\n            ) = _calculateDebtReserves(geometricMean_, lowerRange_, token0Debt_, token1Debt_);\n        } else {\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n            // 1 / geometricMean for new geometricMean\n            // 1 / lowerRange will become upper range\n            // 1 / upperRange will become lower range\n            (\n                d_.token1RealReserves,\n                d_.token0RealReserves,\n                d_.token1ImaginaryReserves,\n                d_.token0ImaginaryReserves\n            ) = _calculateDebtReserves((1e54 / geometricMean_), (1e54 / upperRange_), token1Debt_, token0Debt_);\n        }\n    }\n\n    function _calculateNewColReserves(\n        PricesAndExchangePrice memory pex_,\n        CollateralReserves memory currentCollateralReserves_,\n        uint newPrice_\n    ) internal pure returns (CollateralReserves memory newCollateralReserves_) {\n        uint k_ = currentCollateralReserves_.token0ImaginaryReserves *\n            currentCollateralReserves_.token1ImaginaryReserves;\n\n        uint token0OutsideRange_ = currentCollateralReserves_.token0ImaginaryReserves -\n            currentCollateralReserves_.token0RealReserves;\n        uint token1OutsideRange_ = currentCollateralReserves_.token1ImaginaryReserves -\n            currentCollateralReserves_.token1RealReserves;\n\n        uint x_;\n        uint y_;\n\n        if (pex_.upperRange < newPrice_) {\n            x_ = token0OutsideRange_;\n            y_ = k_ / x_;\n        } else if (pex_.lowerRange > newPrice_) {\n            y_ = token1OutsideRange_;\n            x_ = k_ / y_;\n        } else {\n            // y_/x_ = newPrice_\n            // y_ = newPrice_* x_\n            // y_ * x_ = k_\n            // (newPrice_* x_) * x_ = k_\n            // x_^2 = k_ / newPrice_\n            // x_ = sqrt(k_ / newPrice_)\n            if (k_ < 1e50) {\n                x_ = FixedPointMathLib.sqrt((k_ * 1e27) / newPrice_);\n            } else {\n                x_ = FixedPointMathLib.sqrt((k_ / newPrice_) * 1e27);\n            }\n            y_ = (newPrice_ * x_) / 1e27;\n        }\n\n        newCollateralReserves_.token0RealReserves = x_ - token0OutsideRange_;\n        newCollateralReserves_.token1RealReserves = y_ - token1OutsideRange_;\n        newCollateralReserves_.token0ImaginaryReserves = x_;\n        newCollateralReserves_.token1ImaginaryReserves = y_;\n    }\n\n    function _calculateNewDebtReserves(\n        PricesAndExchangePrice memory pex_,\n        DebtReserves memory currentDebtReserves_,\n        uint newPrice_\n    ) internal pure returns (DebtReserves memory newDebtReserves_) {\n        uint k_ = currentDebtReserves_.token0ImaginaryReserves * currentDebtReserves_.token1ImaginaryReserves;\n        uint token0OutsideRange_ = currentDebtReserves_.token0ImaginaryReserves -\n            currentDebtReserves_.token0RealReserves;\n        uint token1OutsideRange_ = currentDebtReserves_.token1ImaginaryReserves -\n            currentDebtReserves_.token1RealReserves;\n\n        uint x_;\n        uint y_;\n        if (pex_.upperRange < newPrice_) {\n            x_ = token0OutsideRange_;\n            y_ = k_ / x_;\n        } else if (pex_.lowerRange > newPrice_) {\n            y_ = token1OutsideRange_;\n            x_ = k_ / y_;\n        } else {\n            // y_/x_ = newPrice_\n            // y_ = newPrice_* x_\n            // y_ * x_ = k_\n            // (newPrice_* x_) * x_ = k_\n            // x_^2 = k_ / newPrice_\n            // x_ = sqrt(k_ / newPrice_)\n            if (k_ < 1e50) {\n                x_ = FixedPointMathLib.sqrt((k_ * 1e27) / newPrice_);\n            } else {\n                x_ = FixedPointMathLib.sqrt((k_ / newPrice_) * 1e27);\n            }\n            y_ = (newPrice_ * x_) / 1e27;\n        }\n\n        newDebtReserves_.token0RealReserves = x_ - token0OutsideRange_;\n        newDebtReserves_.token1RealReserves = y_ - token1OutsideRange_;\n        newDebtReserves_.token0ImaginaryReserves = x_;\n        newDebtReserves_.token1ImaginaryReserves = y_;\n\n        // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\n        uint256 numerator_ = newDebtReserves_.token0RealReserves * currentDebtReserves_.token1ImaginaryReserves;\n        uint256 denominator_ = currentDebtReserves_.token0ImaginaryReserves - newDebtReserves_.token0RealReserves;\n\n        // Using the swap formula: (AmountOut * iReserveX) / (iReserveY - AmountOut)\n        newDebtReserves_.token1Debt = numerator_ / denominator_;\n\n        numerator_ = newDebtReserves_.token1RealReserves * currentDebtReserves_.token0ImaginaryReserves;\n        denominator_ = currentDebtReserves_.token1ImaginaryReserves - newDebtReserves_.token1RealReserves;\n\n        // Using the swap formula: (AmountOut * iReserveX) / (iReserveY - AmountOut)\n        newDebtReserves_.token0Debt = numerator_ / denominator_;\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/dexSmartColOracleImpl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { DexSlotsLink } from \"../../../libraries/dexSlotsLink.sol\";\nimport { DexOracleBase } from \"./dexOracleBase.sol\";\n\nabstract contract DexSmartColOracleImpl is DexOracleBase {\n    uint256 private constant X128 = 0xffffffffffffffffffffffffffffffff;\n\n    uint256 private immutable RESERVES_SCALER;\n\n    constructor() {\n        // need to invert decimals from reserves / shares to shares / reserves.\n        // Can derive from token scaler consts targeting 1e12 + knowing shares decimals = 1e18:\n        // e.g. for USDC 1e6 / 1e18 shares: 1e18 / (1e12 * 1 / 1e6) = 1e12\n        // e.g. for WBTC 1e8 / 1e18 shares: 1e18 / (1e12 * 1 / 1e4) = 1e10\n        RESERVES_SCALER = QUOTE_IN_TOKEN0\n            ? 1e18 / ((1e12 * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION)\n            : 1e18 / ((1e12 * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n    }\n\n    /// @dev returns price per 1 col share (quoteToken / colShare) in token decimals scaled to 1e27\n    function _getDexSmartColExchangeRate(\n        uint256 conversionPrice_,\n        uint256 token0Reserves_,\n        uint256 token1Reserves_\n    ) internal view returns (uint256 rate_) {\n        uint256 totalSupplyShares_ = IFluidDexT1(DEX_).readFromStorage(\n            bytes32(DexSlotsLink.DEX_TOTAL_SUPPLY_SHARES_SLOT)\n        ) & X128;\n\n        if (totalSupplyShares_ == 0) {\n            // should never happen after Dex is initialized. until then -> revert\n            revert FluidOracleError(ErrorTypes.DexSmartColOracle__SmartColNotEnabled);\n        }\n\n        uint256 reserves_ = _getDexReservesCombinedInQuoteToken(conversionPrice_, token0Reserves_, token1Reserves_);\n\n        // here: all reserves_ are in either token0 or token1 in token decimals, and we have total shares.\n        // so we know token0 or token1 per 1e18 share. => return price per 1 share (1e18), scaled to 1e27.\n        // shares are in 1e18\n        return (reserves_ * RESERVES_SCALER * 1e27) / totalSupplyShares_;\n    }\n\n    /// @notice Returns the rates of shares (totalReserves/totalShares)\n    function dexSmartColSharesRates() public view virtual returns (uint256 operate_, uint256 liquidate_);\n}\n"
    },
    "contracts/oracle/implementations/dex/dexSmartDebtOracleImpl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { DexSlotsLink } from \"../../../libraries/dexSlotsLink.sol\";\nimport { DexOracleBase } from \"./dexOracleBase.sol\";\n\nabstract contract DexSmartDebtOracleImpl is DexOracleBase {\n    uint256 private constant X128 = 0xffffffffffffffffffffffffffffffff;\n\n    uint256 private immutable RESERVES_SCALER;\n\n    constructor() {\n        // need to invert decimals from reserves / shares to shares / reserves.\n        // Can derive from token scaler consts targeting 1e12 + knowing shares decimals = 1e18:\n        // e.g. for USDC 1e6 / 1e18 shares: 1e18 / (1e12 * 1 / 1e6) = 1e12\n        // e.g. for WBTC 1e8 / 1e18 shares: 1e18 / (1e12 * 1 / 1e4) = 1e10\n        RESERVES_SCALER = QUOTE_IN_TOKEN0\n            ? 1e18 / ((1e12 * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION)\n            : 1e18 / ((1e12 * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n    }\n\n    /// @dev returns price per 1 quoteToken (debtShares / quoteToken) in token decimals scaled to 1e27\n    function _getDexSmartDebtExchangeRate(\n        uint256 conversionPrice_,\n        uint256 token0Reserves_,\n        uint256 token1Reserves_\n    ) internal view returns (uint256 rate_) {\n        uint256 totalBorrowShares_ = IFluidDexT1(DEX_).readFromStorage(\n            bytes32(DexSlotsLink.DEX_TOTAL_BORROW_SHARES_SLOT)\n        ) & X128;\n\n        if (totalBorrowShares_ == 0) {\n            // should never happen after Dex is initialized. until then -> revert\n            revert FluidOracleError(ErrorTypes.DexSmartDebtOracle__SmartDebtNotEnabled);\n        }\n\n        uint256 reserves_ = _getDexReservesCombinedInQuoteToken(conversionPrice_, token0Reserves_, token1Reserves_);\n\n        // here: all reserves_ are in either token0 or token1 in token decimals, and we have total shares.\n        // so we know token0 or token1 per 1e18 share. => return shares per 1 quote token, scaled to 1e27.\n\n        return (totalBorrowShares_ * 1e27) / (reserves_ * RESERVES_SCALER);\n    }\n\n    /// @notice Returns the rates of shares (totalShares/totalReserves)\n    function dexSmartDebtSharesRates() public view virtual returns (uint256 operate_, uint256 liquidate_);\n}\n"
    },
    "contracts/oracle/implementations/dex/reserveGetters/reservesFromLiquidity.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\nimport { LiquidityCalcs } from \"../../../../libraries/liquidityCalcs.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { DexOracleBase } from \"../dexOracleBase.sol\";\n\n/// @notice reads the dex reserves directly from Liquidity (user supply / user debt)\nabstract contract DexReservesFromLiquidity is DexOracleBase {\n    constructor(address dexPool_, bool quoteInToken0_) DexOracleBase(dexPool_, quoteInToken0_) {}\n\n    /// @dev Retrieves collateral amount from liquidity layer for a given token\n    /// @param supplyTokenSlot_ The storage slot for the supply token data\n    /// @param exchangePriceSlot_ The storage slot for the exchange price of the token\n    /// @param isToken0_ Boolean indicating if the token is token0 (true) or token1 (false)\n    /// @return tokenSupply_ The calculated liquidity collateral amount\n    function _getLiquidityCollateral(\n        bytes32 supplyTokenSlot_,\n        bytes32 exchangePriceSlot_,\n        bool isToken0_\n    ) private view returns (uint tokenSupply_) {\n        uint tokenSupplyData_ = LIQUIDITY.readFromStorage(supplyTokenSlot_);\n        tokenSupply_ = (tokenSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & LiquidityCalcs.X64;\n        tokenSupply_ =\n            (tokenSupply_ >> LiquidityCalcs.DEFAULT_EXPONENT_SIZE) <<\n            (tokenSupply_ & LiquidityCalcs.DEFAULT_EXPONENT_MASK);\n\n        (uint256 exchangePrice_, ) = LiquidityCalcs.calcExchangePrices(LIQUIDITY.readFromStorage(exchangePriceSlot_));\n\n        if (tokenSupplyData_ & 1 == 1) {\n            // supply with interest is on\n            unchecked {\n                tokenSupply_ = (tokenSupply_ * exchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n            }\n        }\n\n        // bring to 1e12 decimals\n        unchecked {\n            tokenSupply_ = isToken0_\n                ? ((tokenSupply_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\n                : ((tokenSupply_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\n        }\n    }\n\n    /// @dev Retrieves debt amount from liquidity layer for a given token\n    /// @param borrowTokenSlot_ The storage slot for the borrow token data\n    /// @param exchangePriceSlot_ The storage slot for the exchange price of the token\n    /// @param isToken0_ Boolean indicating if the token is token0 (true) or token1 (false)\n    /// @return debtAmount_ The calculated liquidity debt amount adjusted to 1e12 decimals\n    function _getLiquidityDebt(\n        bytes32 borrowTokenSlot_,\n        bytes32 exchangePriceSlot_,\n        bool isToken0_\n    ) private view returns (uint debtAmount_) {\n        uint debtAmountData_ = LIQUIDITY.readFromStorage(borrowTokenSlot_);\n        debtAmount_ = (debtAmountData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & LiquidityCalcs.X64;\n        debtAmount_ =\n            (debtAmount_ >> LiquidityCalcs.DEFAULT_EXPONENT_SIZE) <<\n            (debtAmount_ & LiquidityCalcs.DEFAULT_EXPONENT_MASK);\n\n        (, uint256 exchangePrice_) = LiquidityCalcs.calcExchangePrices(LIQUIDITY.readFromStorage(exchangePriceSlot_));\n\n        if (debtAmountData_ & 1 == 1) {\n            // debt with interest is on\n            unchecked {\n                debtAmount_ = (debtAmount_ * exchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n            }\n        }\n\n        unchecked {\n            debtAmount_ = isToken0_\n                ? ((debtAmount_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\n                : ((debtAmount_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\n        }\n    }\n\n    /// @dev Get the col reserves at the Dex adjusted to 1e12 decimals\n    function _getDexCollateralReserves()\n        internal\n        view\n        virtual\n        returns (uint256 token0Reserves_, uint256 token1Reserves_)\n    {\n        // Note check if smart col is enabled is done already via checking if total supply shares == 0\n        token0Reserves_ = _getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, EXCHANGE_PRICE_TOKEN_0_SLOT, true);\n        token1Reserves_ = _getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, EXCHANGE_PRICE_TOKEN_1_SLOT, false);\n    }\n\n    /// @dev Get the debt reserves at the Dex adjusted to 1e12 decimals\n    function _getDexDebtReserves() internal view virtual returns (uint256 token0Reserves_, uint256 token1Reserves_) {\n        // Note check if smart debt is enabled is done already via checking if total borrow shares == 0\n\n        token0Reserves_ = _getLiquidityDebt(BORROW_TOKEN_0_SLOT, EXCHANGE_PRICE_TOKEN_0_SLOT, true);\n        token1Reserves_ = _getLiquidityDebt(BORROW_TOKEN_1_SLOT, EXCHANGE_PRICE_TOKEN_1_SLOT, false);\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/reserveGetters/reservesFromLiquidityPeg.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { DexReservesFromLiquidity } from \"./reservesFromLiquidity.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @notice reads the dex reserves directly from Liquidity (user supply / user debt) and adds a certain % buffer.\nabstract contract DexReservesFromLiquidityPeg is DexReservesFromLiquidity {\n    /// @dev if Dex is e.g. USDC / USDT a peg can be assumed instead of fetching the price\n    /// at the Dex Oracle (which might not even be active in such a case). If so, this var\n    /// defines the peg buffer to reduce collateral value (and increase debt value) by some\n    /// defined percentage for safety handling of price ranges.\n    /// in 1e4: 10000 = 1%, 1000000 = 100%\n    uint256 public immutable RESERVES_PEG_BUFFER_PERCENT;\n\n    constructor(\n        address dexPool_,\n        bool quoteInToken0_,\n        uint256 reservesPegBufferPercent_\n    ) DexReservesFromLiquidity(dexPool_, quoteInToken0_) {\n        if (reservesPegBufferPercent_ == 0) {\n            revert FluidOracleError(ErrorTypes.DexOracle__InvalidParams);\n        }\n        RESERVES_PEG_BUFFER_PERCENT = reservesPegBufferPercent_;\n    }\n\n    /// @inheritdoc DexReservesFromLiquidity\n    function _getDexCollateralReserves()\n        internal\n        view\n        override\n        returns (uint256 token0Reserves_, uint256 token1Reserves_)\n    {\n        (token0Reserves_, token1Reserves_) = super._getDexCollateralReserves();\n\n        // reduce col value by peg buffer percent\n        token0Reserves_ = (token0Reserves_ * (1e6 - RESERVES_PEG_BUFFER_PERCENT)) / 1e6;\n        token1Reserves_ = (token1Reserves_ * (1e6 - RESERVES_PEG_BUFFER_PERCENT)) / 1e6;\n    }\n\n    /// @inheritdoc DexReservesFromLiquidity\n    function _getDexDebtReserves() internal view override returns (uint256 token0Reserves_, uint256 token1Reserves_) {\n        (token0Reserves_, token1Reserves_) = super._getDexDebtReserves();\n\n        // increase debt value by peg buffer percent\n        token0Reserves_ = (token0Reserves_ * (1e6 + RESERVES_PEG_BUFFER_PERCENT)) / 1e6;\n        token1Reserves_ = (token1Reserves_ * (1e6 + RESERVES_PEG_BUFFER_PERCENT)) / 1e6;\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/reserveGetters/reservesFromPEX.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { DexPricesAndExchangePrices } from \"../dexPricesAndExchangePrices.sol\";\nimport { DexOracleBase } from \"../dexOracleBase.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @notice reads the dex reserves directly from Liquidity (user supply / user debt) but adjusts them for a certain\n///         price, incl. adjusted PEX.\nabstract contract DexReservesFromPEX is DexOracleBase, DexPricesAndExchangePrices {\n    constructor(address dexPool_, bool quoteInToken0_) DexOracleBase(dexPool_, quoteInToken0_) {}\n\n    /// @dev Get the col reserves at the Dex adjusted to 1e12 decimals.\n    /// Pass in the conversion price and PEX fetched via `_getPricesAndExchangePrices()`.\n    function _getDexCollateralReserves(\n        uint256 price_,\n        PricesAndExchangePrice memory pex_\n    ) internal view returns (uint256 token0Reserves_, uint256 token1Reserves_) {\n        CollateralReserves memory collateralReserves_ = _getCollateralReserves(\n            pex_.geometricMean,\n            pex_.upperRange,\n            pex_.lowerRange,\n            pex_.supplyToken0ExchangePrice,\n            pex_.supplyToken1ExchangePrice\n        );\n\n        CollateralReserves memory newCollateralReserves_ = _calculateNewColReserves(pex_, collateralReserves_, price_);\n\n        token0Reserves_ = newCollateralReserves_.token0RealReserves;\n        token1Reserves_ = newCollateralReserves_.token1RealReserves;\n    }\n\n    /// @dev Get the debt reserves at the Dex adjusted to 1e12 decimals.\n    /// Pass in the conversion price and PEX fetched via `_getPricesAndExchangePrices()`.\n    function _getDexDebtReserves(\n        uint256 price_,\n        PricesAndExchangePrice memory pex_\n    ) internal view returns (uint256 token0Debt_, uint256 token1Debt_) {\n        DebtReserves memory debtReserves_ = _getDebtReserves(\n            pex_.geometricMean,\n            pex_.upperRange,\n            pex_.lowerRange,\n            pex_.borrowToken0ExchangePrice,\n            pex_.borrowToken1ExchangePrice\n        );\n\n        DebtReserves memory newDebtReserves_ = _calculateNewDebtReserves(pex_, debtReserves_, price_);\n\n        token0Debt_ = newDebtReserves_.token0Debt;\n        token1Debt_ = newDebtReserves_.token1Debt;\n    }\n}\n"
    },
    "contracts/oracle/implementations/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IChainlinkAggregatorV3 } from \"../interfaces/external/IChainlinkAggregatorV3.sol\";\nimport { IRedstoneOracle } from \"../interfaces/external/IRedstoneOracle.sol\";\n\nabstract contract ChainlinkStructs {\n    struct ChainlinkFeedData {\n        /// @param feed           address of Chainlink feed.\n        IChainlinkAggregatorV3 feed;\n        /// @param invertRate     true if rate read from price feed must be inverted.\n        bool invertRate;\n        /// @param token0Decimals decimals of asset 0. E.g. for a USDC/ETH feed, USDC is token0 and has 6 decimals.\n        ///                       (token1Decimals are available directly via Chainlink `FEED.decimals()`)\n        uint256 token0Decimals;\n    }\n\n    struct ChainlinkConstructorParams {\n        /// @param param        hops count of hops, used for sanity checks. Must be 1, 2 or 3.\n        uint8 hops;\n        /// @param feed1        Chainlink feed 1 data. Required.\n        ChainlinkFeedData feed1;\n        /// @param feed2        Chainlink feed 2 data. Required if hops > 1.\n        ChainlinkFeedData feed2;\n        /// @param feed3        Chainlink feed 3 data. Required if hops > 2.\n        ChainlinkFeedData feed3;\n    }\n}\n\nabstract contract RedstoneStructs {\n    struct RedstoneOracleData {\n        /// @param oracle         address of Redstone oracle.\n        IRedstoneOracle oracle;\n        /// @param invertRate     true if rate read from price feed must be inverted.\n        bool invertRate;\n        /// @param token0Decimals decimals of asset 0. E.g. for a USDC/ETH feed, USDC is token0 and has 6 decimals.\n        ///                       (token1Decimals are available directly via Redstone `Oracle.decimals()`)\n        uint256 token0Decimals;\n    }\n}\n"
    },
    "contracts/oracle/interfaces/external/IChainlinkAggregatorV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// from https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\n/// Copyright (c) 2018 SmartContract ChainLink, Ltd.\n\ninterface IChainlinkAggregatorV3 {\n    /// @notice represents the number of decimals the aggregator responses represent.\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/oracle/interfaces/external/IRedstoneOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IRedstoneOracle {\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset\n    // @dev custom Redstone adapter for Instadapp implementation\n    function getExchangeRate() external view returns (uint256 exchangeRate_);\n\n    /**\n     * @notice Returns the number of decimals for the price feed\n     * @dev By default, RedStone uses 8 decimals for data feeds\n     * @return decimals The number of decimals in the price feed values\n     */\n    // see https://github.com/redstone-finance/redstone-oracles-monorepo/blob/main/packages/on-chain-relayer/contracts/price-feeds/PriceFeedBase.sol#L51C12-L51C20\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/oracle/interfaces/iFluidOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidOracle {\n    /// @dev Deprecated. Use `getExchangeRateOperate()` and `getExchangeRateLiquidate()` instead. Only implemented for\n    ///      backwards compatibility.\n    function getExchangeRate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for operates\n    function getExchangeRateOperate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for liquidations\n    function getExchangeRateLiquidate() external view returns (uint256 exchangeRate_);\n\n    /// @notice helper string to easily identify the oracle. E.g. token symbols\n    function infoName() external view returns (string memory);\n}\n"
    },
    "contracts/oracle/libraries/oracleUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title Oracle utils library\n/// @notice implements common utility methods for Fluid Oracles\nlibrary OracleUtils {\n    /// @dev The scaler for max delta point math (100%)\n    uint256 internal constant HUNDRED_PERCENT_DELTA_SCALER = 10_000;\n    /// @dev output precision of rates\n    uint256 internal constant RATE_OUTPUT_DECIMALS = 27;\n\n    /// @dev checks if `mainSourceRate_` is within a `maxDeltaPercent_` of `checkSourceRate_`. Returns true if so.\n    function isRateOutsideDelta(\n        uint256 mainSourceRate_,\n        uint256 checkSourceRate_,\n        uint256 maxDeltaPercent_\n    ) internal pure returns (bool) {\n        uint256 offset_ = (checkSourceRate_ * maxDeltaPercent_) / HUNDRED_PERCENT_DELTA_SCALER;\n        return (mainSourceRate_ > (checkSourceRate_ + offset_) || mainSourceRate_ < (checkSourceRate_ - offset_));\n    }\n}\n"
    },
    "contracts/oracle/oracles/dex/dexSmartColPegOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracle, IFluidOracle } from \"../../fluidOracle.sol\";\nimport { DexOracleAdjustResult } from \"../../implementations/dex/dexOracleBase.sol\";\nimport { DexSmartColOracleImpl } from \"../../implementations/dex/dexSmartColOracleImpl.sol\";\n\nimport { DexColDebtPriceFluidOracle } from \"../../implementations/dex/colDebtPrices/colDebtPriceFluidOracle.sol\";\nimport { DexConversionPriceFluidOracle } from \"../../implementations/dex/conversionPriceGetters/conversionPriceFluidOracle.sol\";\nimport { DexReservesFromLiquidityPeg } from \"../../implementations/dex/reserveGetters/reservesFromLiquidityPeg.sol\";\n\n/// @title   Fluid Dex Smart Col Pegged Oracle for assets ~1=~1\n/// @notice  Gets the exchange rate between a Fluid Dex smart collateral shares and normal debt.\n/// @dev -> Reserves from Liquidity with Peg buffer percent.\n///      -> Reserves conversion price from separately deployed FluidOracle (optional e.g. needed for wstETH-ETH).\n///      -> colDebt Price Oracle is an IFluidOracle.\ncontract DexSmartColPegOracle is\n    FluidOracle,\n    DexSmartColOracleImpl,\n    DexColDebtPriceFluidOracle,\n    DexConversionPriceFluidOracle,\n    DexReservesFromLiquidityPeg\n{\n    struct DexSmartColPegOracleParams {\n        string infoName;\n        address dexPool;\n        bool quoteInToken0;\n        IFluidOracle colDebtOracle;\n        bool colDebtInvert;\n        uint256 pegBufferPercent;\n        DexConversionPriceFluidOracleParams reservesConversionParams;\n        uint256 resultMultiplier;\n        uint256 resultDivisor;\n    }\n\n    constructor(\n        DexSmartColPegOracleParams memory params_\n    )\n        FluidOracle(params_.infoName)\n        DexOracleAdjustResult(params_.resultMultiplier, params_.resultDivisor)\n        DexReservesFromLiquidityPeg(params_.dexPool, params_.quoteInToken0, params_.pegBufferPercent)\n        DexColDebtPriceFluidOracle(params_.colDebtOracle, params_.colDebtInvert)\n        DexConversionPriceFluidOracle(params_.reservesConversionParams)\n    {}\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateOperate() public view virtual override returns (uint256 exchangeRate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves();\n\n        uint256 quoteTokensPer1ColShare_ = _getDexSmartColExchangeRate(\n            _getDexReservesConversionPriceOperate(),\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return\n            (quoteTokensPer1ColShare_ * _getDexColDebtPriceOperate() * RESULT_MULTIPLIER) /\n            (DEX_COL_DEBT_ORACLE_PRECISION * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateLiquidate() public view virtual override returns (uint256 exchangeRate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves();\n\n        uint256 quoteTokensPer1ColShare_ = _getDexSmartColExchangeRate(\n            _getDexReservesConversionPriceLiquidate(),\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return\n            (quoteTokensPer1ColShare_ * _getDexColDebtPriceLiquidate() * RESULT_MULTIPLIER) /\n            (DEX_COL_DEBT_ORACLE_PRECISION * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() public view virtual override returns (uint256 exchangeRate_) {\n        return getExchangeRateOperate();\n    }\n\n    /// @inheritdoc DexSmartColOracleImpl\n    function dexSmartColSharesRates() public view override returns (uint256 operate_, uint256 liquidate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves();\n\n        return (\n            _getDexSmartColExchangeRate(_getDexReservesConversionPriceOperate(), token0Reserves_, token1Reserves_),\n            _getDexSmartColExchangeRate(_getDexReservesConversionPriceLiquidate(), token0Reserves_, token1Reserves_)\n        );\n    }\n}\n"
    },
    "contracts/oracle/oracles/dex/dexSmartDebtPegOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracle, IFluidOracle } from \"../../fluidOracle.sol\";\nimport { DexOracleAdjustResult } from \"../../implementations/dex/dexOracleBase.sol\";\nimport { DexSmartDebtOracleImpl } from \"../../implementations/dex/dexSmartDebtOracleImpl.sol\";\n\nimport { DexColDebtPriceFluidOracle } from \"../../implementations/dex/colDebtPrices/colDebtPriceFluidOracle.sol\";\nimport { DexConversionPriceFluidOracle } from \"../../implementations/dex/conversionPriceGetters/conversionPriceFluidOracle.sol\";\nimport { DexReservesFromLiquidityPeg } from \"../../implementations/dex/reserveGetters/reservesFromLiquidityPeg.sol\";\n\n/// @title   Fluid Dex Smart Debt Pegged Oracle for assets ~1=~1\n/// @notice  Gets the exchange rate between a Fluid Dex normal collateral and smart debt shares.\n/// @dev -> Reserves from Liquidity with Peg buffer percent.\n///      -> Reserves conversion price from separately deployed FluidOracle (optional e.g. needed for wstETH-ETH).\n///      -> colDebt Price Oracle is an IFluidOracle.\ncontract DexSmartDebtPegOracle is\n    FluidOracle,\n    DexSmartDebtOracleImpl,\n    DexColDebtPriceFluidOracle,\n    DexConversionPriceFluidOracle,\n    DexReservesFromLiquidityPeg\n{\n    struct DexSmartDebtPegOracleParams {\n        string infoName;\n        address dexPool;\n        bool quoteInToken0;\n        IFluidOracle colDebtOracle;\n        bool colDebtInvert;\n        uint256 pegBufferPercent;\n        DexConversionPriceFluidOracleParams reservesConversionParams;\n        uint256 resultMultiplier;\n        uint256 resultDivisor;\n    }\n\n    constructor(\n        DexSmartDebtPegOracleParams memory params_\n    )\n        FluidOracle(params_.infoName)\n        DexOracleAdjustResult(params_.resultMultiplier, params_.resultDivisor)\n        DexReservesFromLiquidityPeg(params_.dexPool, params_.quoteInToken0, params_.pegBufferPercent)\n        DexColDebtPriceFluidOracle(params_.colDebtOracle, params_.colDebtInvert)\n        DexConversionPriceFluidOracle(params_.reservesConversionParams)\n    {}\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateOperate() public view virtual override returns (uint256 exchangeRate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexDebtReserves();\n\n        uint256 debtSharesPer1QuoteToken_ = _getDexSmartDebtExchangeRate(\n            _getDexReservesConversionPriceOperate(),\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return\n            (debtSharesPer1QuoteToken_ * _getDexColDebtPriceOperate() * RESULT_MULTIPLIER) /\n            (DEX_COL_DEBT_ORACLE_PRECISION * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateLiquidate() public view virtual override returns (uint256 exchangeRate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexDebtReserves();\n\n        uint256 debtSharesPer1QuoteToken_ = _getDexSmartDebtExchangeRate(\n            _getDexReservesConversionPriceLiquidate(),\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return\n            (debtSharesPer1QuoteToken_ * _getDexColDebtPriceLiquidate() * RESULT_MULTIPLIER) /\n            (DEX_COL_DEBT_ORACLE_PRECISION * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() public view virtual override returns (uint256 exchangeRate_) {\n        return getExchangeRateOperate();\n    }\n\n    /// @inheritdoc DexSmartDebtOracleImpl\n    function dexSmartDebtSharesRates() public view override returns (uint256 operate_, uint256 liquidate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexDebtReserves();\n\n        return (\n            _getDexSmartDebtExchangeRate(_getDexReservesConversionPriceOperate(), token0Reserves_, token1Reserves_),\n            _getDexSmartDebtExchangeRate(_getDexReservesConversionPriceLiquidate(), token0Reserves_, token1Reserves_)\n        );\n    }\n}\n"
    },
    "contracts/oracle/oracles/dex/dexSmartT4CLOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracle, IFluidOracle } from \"../../fluidOracle.sol\";\nimport { DexOracleAdjustResult } from \"../../implementations/dex/dexOracleBase.sol\";\nimport { DexSmartColOracleImpl } from \"../../implementations/dex/dexSmartColOracleImpl.sol\";\nimport { DexSmartDebtOracleImpl } from \"../../implementations/dex/dexSmartDebtOracleImpl.sol\";\n\nimport { DexReservesFromPEX } from \"../../implementations/dex/reserveGetters/reservesFromPEX.sol\";\nimport { DexConversionPriceCL, ChainlinkOracleImpl } from \"../../implementations/dex/conversionPriceGetters/conversionPriceCL.sol\";\n\n/// @title   Fluid Dex Smart Col Debt VaultT4 Oracle\n/// @notice  Gets the exchange rate between a Fluid Dex smart collateral and smart debt for a T4 vault.\n///          returns amount of debt shares per 1 col share.\n/// @dev -> Reserves from Liquidity, adjusted for conversion price.\n///      -> Reserves conversion price from Chainlink feeds.\ncontract DexSmartT4CLOracle is\n    FluidOracle,\n    DexSmartColOracleImpl,\n    DexSmartDebtOracleImpl,\n    DexConversionPriceCL,\n    DexReservesFromPEX\n{\n    struct DexSmartT4CLOracleParams {\n        string infoName;\n        address dexPool;\n        bool quoteInToken0;\n        ChainlinkOracleImpl.ChainlinkConstructorParams reservesConversion;\n        uint256 reservesConversionPriceMultiplier;\n        uint256 reservesConversionPriceDivisor;\n        uint256 resultMultiplier;\n        uint256 resultDivisor;\n    }\n\n    constructor(\n        DexSmartT4CLOracleParams memory params_\n    )\n        FluidOracle(params_.infoName)\n        DexOracleAdjustResult(params_.resultMultiplier, params_.resultDivisor)\n        DexReservesFromPEX(params_.dexPool, params_.quoteInToken0)\n        DexConversionPriceCL(\n            params_.reservesConversion,\n            params_.reservesConversionPriceMultiplier,\n            params_.reservesConversionPriceDivisor\n        )\n    {}\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateOperate() public view virtual override returns (uint256 exchangeRate_) {\n        uint256 conversionPrice_ = _getDexReservesConversionPriceOperate();\n        PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices();\n\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves(conversionPrice_, pex_);\n\n        uint256 quoteTokensPer1ColShare_ = _getDexSmartColExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        (token0Reserves_, token1Reserves_) = _getDexDebtReserves(conversionPrice_, pex_);\n        uint256 debtSharesPer1QuoteToken_ = _getDexSmartDebtExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return (debtSharesPer1QuoteToken_ * quoteTokensPer1ColShare_ * RESULT_MULTIPLIER) / (1e27 * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateLiquidate() public view virtual override returns (uint256 exchangeRate_) {\n        uint256 conversionPrice_ = _getDexReservesConversionPriceLiquidate();\n        PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices();\n\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves(conversionPrice_, pex_);\n\n        uint256 quoteTokensPer1ColShare_ = _getDexSmartColExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        (token0Reserves_, token1Reserves_) = _getDexDebtReserves(conversionPrice_, pex_);\n        uint256 debtSharesPer1QuoteToken_ = _getDexSmartDebtExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return (debtSharesPer1QuoteToken_ * quoteTokensPer1ColShare_ * RESULT_MULTIPLIER) / (1e27 * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() public view virtual override returns (uint256 exchangeRate_) {\n        return getExchangeRateOperate();\n    }\n\n    /// @inheritdoc DexSmartColOracleImpl\n    function dexSmartColSharesRates() public view override returns (uint256 operate_, uint256 liquidate_) {\n        {\n            uint256 conversionPrice_ = _getDexReservesConversionPriceOperate();\n\n            (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves(\n                conversionPrice_,\n                _getPricesAndExchangePrices()\n            );\n\n            operate_ = _getDexSmartColExchangeRate(conversionPrice_, token0Reserves_, token1Reserves_);\n        }\n\n        {\n            uint256 conversionPrice_ = _getDexReservesConversionPriceLiquidate();\n\n            (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves(\n                conversionPrice_,\n                _getPricesAndExchangePrices()\n            );\n\n            liquidate_ = _getDexSmartColExchangeRate(conversionPrice_, token0Reserves_, token1Reserves_);\n        }\n    }\n\n    /// @inheritdoc DexSmartDebtOracleImpl\n    function dexSmartDebtSharesRates() public view override returns (uint256 operate_, uint256 liquidate_) {\n        {\n            uint256 conversionPrice_ = _getDexReservesConversionPriceOperate();\n\n            (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexDebtReserves(\n                conversionPrice_,\n                _getPricesAndExchangePrices()\n            );\n\n            operate_ = _getDexSmartDebtExchangeRate(conversionPrice_, token0Reserves_, token1Reserves_);\n        }\n\n        {\n            uint256 conversionPrice_ = _getDexReservesConversionPriceLiquidate();\n\n            (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexDebtReserves(\n                conversionPrice_,\n                _getPricesAndExchangePrices()\n            );\n\n            liquidate_ = _getDexSmartDebtExchangeRate(conversionPrice_, token0Reserves_, token1Reserves_);\n        }\n    }\n}\n"
    },
    "contracts/oracle/oracles/dex/dexSmartT4PegOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracle, IFluidOracle } from \"../../fluidOracle.sol\";\nimport { DexOracleAdjustResult } from \"../../implementations/dex/dexOracleBase.sol\";\nimport { DexSmartColOracleImpl } from \"../../implementations/dex/dexSmartColOracleImpl.sol\";\nimport { DexSmartDebtOracleImpl } from \"../../implementations/dex/dexSmartDebtOracleImpl.sol\";\n\nimport { DexReservesFromLiquidityPeg } from \"../../implementations/dex/reserveGetters/reservesFromLiquidityPeg.sol\";\nimport { DexConversionPriceFluidOracle } from \"../../implementations/dex/conversionPriceGetters/conversionPriceFluidOracle.sol\";\n\n/// @title   Fluid Dex Smart Col Debt Pegged Oracle for assets ~1=~1\n/// @notice  Gets the exchange rate between a Fluid Dex smart collateral shares and smart debt shares.\n/// @dev -> Reserves from Liquidity with Peg buffer percent.\n///      -> Reserves conversion price from separately deployed FluidOracle (optional e.g. needed for wstETH-ETH).\ncontract DexSmartT4PegOracle is\n    FluidOracle,\n    DexSmartColOracleImpl,\n    DexSmartDebtOracleImpl,\n    DexConversionPriceFluidOracle,\n    DexReservesFromLiquidityPeg\n{\n    struct DexSmartT4PegOracleParams {\n        string infoName;\n        address dexPool;\n        bool quoteInToken0;\n        uint256 pegBufferPercent;\n        // conversion oracle is optional, set to address zero if not used. See DexConversionPriceFluidOracle\n        DexConversionPriceFluidOracleParams reservesConversionParams;\n        uint256 resultMultiplier;\n        uint256 resultDivisor;\n    }\n\n    constructor(\n        DexSmartT4PegOracleParams memory params_\n    )\n        FluidOracle(params_.infoName)\n        DexOracleAdjustResult(params_.resultMultiplier, params_.resultDivisor)\n        DexReservesFromLiquidityPeg(params_.dexPool, params_.quoteInToken0, params_.pegBufferPercent)\n        DexConversionPriceFluidOracle(params_.reservesConversionParams)\n    {}\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateOperate() public view virtual override returns (uint256 exchangeRate_) {\n        uint256 conversionPrice_ = _getDexReservesConversionPriceOperate();\n\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves();\n        uint256 quoteTokensPer1ColShare_ = _getDexSmartColExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        (token0Reserves_, token1Reserves_) = _getDexDebtReserves();\n        uint256 debtSharesPer1QuoteToken_ = _getDexSmartDebtExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return (debtSharesPer1QuoteToken_ * quoteTokensPer1ColShare_ * RESULT_MULTIPLIER) / (1e27 * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateLiquidate() public view virtual override returns (uint256 exchangeRate_) {\n        uint256 conversionPrice_ = _getDexReservesConversionPriceLiquidate();\n\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves();\n        uint256 quoteTokensPer1ColShare_ = _getDexSmartColExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        (token0Reserves_, token1Reserves_) = _getDexDebtReserves();\n        uint256 debtSharesPer1QuoteToken_ = _getDexSmartDebtExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return (debtSharesPer1QuoteToken_ * quoteTokensPer1ColShare_ * RESULT_MULTIPLIER) / (1e27 * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() public view virtual override returns (uint256 exchangeRate_) {\n        return getExchangeRateOperate();\n    }\n\n    /// @inheritdoc DexSmartColOracleImpl\n    function dexSmartColSharesRates() public view override returns (uint256 operate_, uint256 liquidate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves();\n\n        return (\n            _getDexSmartColExchangeRate(_getDexReservesConversionPriceOperate(), token0Reserves_, token1Reserves_),\n            _getDexSmartColExchangeRate(_getDexReservesConversionPriceLiquidate(), token0Reserves_, token1Reserves_)\n        );\n    }\n\n    /// @inheritdoc DexSmartDebtOracleImpl\n    function dexSmartDebtSharesRates() public view override returns (uint256 operate_, uint256 liquidate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexDebtReserves();\n\n        return (\n            _getDexSmartDebtExchangeRate(_getDexReservesConversionPriceOperate(), token0Reserves_, token1Reserves_),\n            _getDexSmartDebtExchangeRate(_getDexReservesConversionPriceLiquidate(), token0Reserves_, token1Reserves_)\n        );\n    }\n}\n"
    },
    "contracts/oracle/oracles/genericOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracle } from \"../fluidOracle.sol\";\nimport { FluidGenericOracleBase } from \"./genericOracleBase.sol\";\n\n/// @notice generic configurable Oracle\n/// combines up to 4 hops from sources such as\n///  - an existing IFluidOracle (e.g. ContractRate)\n///  - Redstone\n///  - Chainlink\ncontract FluidGenericOracle is FluidOracle, FluidGenericOracleBase {\n    constructor(\n        string memory infoName_,\n        OracleHopSource[] memory sources_\n    ) FluidOracle(infoName_) FluidGenericOracleBase(sources_) {}\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateOperate() public view virtual override returns (uint256 exchangeRate_) {\n        exchangeRate_ = _getHopsExchangeRate(true);\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateLiquidate() public view virtual override returns (uint256 exchangeRate_) {\n        exchangeRate_ = _getHopsExchangeRate(false);\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRate() public view virtual override returns (uint256 exchangeRate_) {\n        exchangeRate_ = _getHopsExchangeRate(false);\n    }\n}\n"
    },
    "contracts/oracle/oracles/genericOracleBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error as OracleError } from \"../error.sol\";\nimport { ChainlinkSourceReader } from \"../sourceReaders/chainlinkSourceReader.sol\";\nimport { FluidSourceReader } from \"../sourceReaders/fluidSourceReader.sol\";\nimport { OracleUtils } from \"../libraries/oracleUtils.sol\";\n\nabstract contract GenericOracleStructs {\n    enum SourceType {\n        Fluid, // 0, e.g. ContractRate or some other IFluidOracle\n        Redstone, // 1\n        Chainlink, // 2\n        UniV3Checked // 3\n    }\n\n    struct OracleHopSource {\n        address source;\n        bool invertRate;\n        uint256 multiplier;\n        uint256 divisor;\n        SourceType sourceType; // e.g. FLUID, REDSTONE, UNIV3CHECKED, CHAINLINK\n    }\n}\n\n/// @notice generic configurable Oracle Base\n/// combines up to 4 hops from sources such as\n///  - an existing IFluidOracle (e.g. ContractRate)\n///  - Redstone\n///  - Chainlink\nabstract contract FluidGenericOracleBase is\n    OracleError,\n    GenericOracleStructs,\n    ChainlinkSourceReader,\n    FluidSourceReader\n{\n    address internal immutable _SOURCE1;\n    bool internal immutable _SOURCE1_INVERT;\n    uint256 internal immutable _SOURCE1_MULTIPLIER;\n    uint256 internal immutable _SOURCE1_DIVISOR;\n    SourceType internal immutable _SOURCE1_TYPE;\n\n    address internal immutable _SOURCE2;\n    bool internal immutable _SOURCE2_INVERT;\n    uint256 internal immutable _SOURCE2_MULTIPLIER;\n    uint256 internal immutable _SOURCE2_DIVISOR;\n    SourceType internal immutable _SOURCE2_TYPE;\n\n    address internal immutable _SOURCE3;\n    bool internal immutable _SOURCE3_INVERT;\n    uint256 internal immutable _SOURCE3_MULTIPLIER;\n    uint256 internal immutable _SOURCE3_DIVISOR;\n    SourceType internal immutable _SOURCE3_TYPE;\n\n    address internal immutable _SOURCE4;\n    bool internal immutable _SOURCE4_INVERT;\n    uint256 internal immutable _SOURCE4_MULTIPLIER;\n    uint256 internal immutable _SOURCE4_DIVISOR;\n    SourceType internal immutable _SOURCE4_TYPE;\n\n    address internal immutable _SOURCE5;\n    bool internal immutable _SOURCE5_INVERT;\n    uint256 internal immutable _SOURCE5_MULTIPLIER;\n    uint256 internal immutable _SOURCE5_DIVISOR;\n    SourceType internal immutable _SOURCE5_TYPE;\n\n    constructor(OracleHopSource[] memory sources_) {\n        if (sources_.length == 0 || sources_.length > 5) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__InvalidParams);\n        }\n\n        _verifyOracleHopSource(sources_[0]);\n        _SOURCE1 = sources_[0].source;\n        _SOURCE1_INVERT = sources_[0].invertRate;\n        _SOURCE1_MULTIPLIER = sources_[0].multiplier;\n        _SOURCE1_DIVISOR = sources_[0].divisor;\n        _SOURCE1_TYPE = sources_[0].sourceType;\n\n        if (sources_.length > 1) {\n            _verifyOracleHopSource(sources_[1]);\n            _SOURCE2 = sources_[1].source;\n            _SOURCE2_INVERT = sources_[1].invertRate;\n            _SOURCE2_MULTIPLIER = sources_[1].multiplier;\n            _SOURCE2_DIVISOR = sources_[1].divisor;\n            _SOURCE2_TYPE = sources_[1].sourceType;\n        }\n\n        if (sources_.length > 2) {\n            _verifyOracleHopSource(sources_[2]);\n            _SOURCE3 = sources_[2].source;\n            _SOURCE3_INVERT = sources_[2].invertRate;\n            _SOURCE3_MULTIPLIER = sources_[2].multiplier;\n            _SOURCE3_DIVISOR = sources_[2].divisor;\n            _SOURCE3_TYPE = sources_[2].sourceType;\n        }\n\n        if (sources_.length > 3) {\n            _verifyOracleHopSource(sources_[3]);\n            _SOURCE4 = sources_[3].source;\n            _SOURCE4_INVERT = sources_[3].invertRate;\n            _SOURCE4_MULTIPLIER = sources_[3].multiplier;\n            _SOURCE4_DIVISOR = sources_[3].divisor;\n            _SOURCE4_TYPE = sources_[3].sourceType;\n        }\n\n        if (sources_.length > 4) {\n            _verifyOracleHopSource(sources_[4]);\n            _SOURCE5 = sources_[4].source;\n            _SOURCE5_INVERT = sources_[4].invertRate;\n            _SOURCE5_MULTIPLIER = sources_[4].multiplier;\n            _SOURCE5_DIVISOR = sources_[4].divisor;\n            _SOURCE5_TYPE = sources_[4].sourceType;\n        }\n    }\n\n    /// @dev verifies a hop source config\n    function _verifyOracleHopSource(OracleHopSource memory source_) internal view virtual {\n        if (\n            address(source_.source) == address(0) ||\n            source_.sourceType == SourceType.UniV3Checked ||\n            source_.divisor == 0 ||\n            source_.multiplier == 0 ||\n            source_.divisor > 1e40 ||\n            source_.multiplier > 1e40\n        ) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__InvalidParams);\n        }\n    }\n\n    /// @dev reads the exchange rate for a hop source\n    function _readSource(\n        address source_,\n        SourceType sourceType_,\n        bool isOperate_\n    ) internal view virtual returns (uint256 rate_) {\n        if (sourceType_ == SourceType.Redstone || sourceType_ == SourceType.Chainlink) {\n            rate_ = _readChainlinkSource(source_);\n        } else if (sourceType_ == SourceType.Fluid) {\n            rate_ = _readFluidSource(source_, isOperate_);\n        } else {\n            // should never happen because of config checks in constructor\n            revert FluidOracleError(ErrorTypes.GenericOracle__UnexpectedConfig);\n        }\n    }\n\n    /// @dev gets the exchange rate for a single configured hop\n    function _getExchangeRateForHop(\n        uint256 curHopsRate_,\n        bool isOperate_,\n        OracleHopSource memory source_\n    ) internal view virtual returns (uint256 rate_) {\n        rate_ = _readSource(source_.source, source_.sourceType, isOperate_);\n\n        // scale to 1e27\n        rate_ = (rate_ * source_.multiplier) / source_.divisor;\n\n        if (source_.invertRate && rate_ > 0) {\n            rate_ = (10 ** (OracleUtils.RATE_OUTPUT_DECIMALS * 2)) / uint256(rate_);\n        }\n\n        rate_ = (curHopsRate_ * rate_) / (10 ** OracleUtils.RATE_OUTPUT_DECIMALS); // combine with current hops rate\n    }\n\n    /// @dev gets the exchange rate combined for all configured hops\n    function _getHopsExchangeRate(bool isOperate_) internal view returns (uint256 rate_) {\n        rate_ = _getExchangeRateForHop(\n            (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n            isOperate_,\n            OracleHopSource(_SOURCE1, _SOURCE1_INVERT, _SOURCE1_MULTIPLIER, _SOURCE1_DIVISOR, _SOURCE1_TYPE)\n        );\n        if (rate_ == 0) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__RateZero);\n        }\n        if (address(_SOURCE2) == address(0) && _SOURCE2_TYPE != SourceType.UniV3Checked) {\n            return rate_;\n        }\n\n        // 2 hops -> return rate of hop 1 combined with hop 2\n        rate_ = _getExchangeRateForHop(\n            rate_,\n            isOperate_,\n            OracleHopSource(_SOURCE2, _SOURCE2_INVERT, _SOURCE2_MULTIPLIER, _SOURCE2_DIVISOR, _SOURCE2_TYPE)\n        );\n        if (rate_ == 0) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__RateZero);\n        }\n        if (address(_SOURCE3) == address(0) && _SOURCE3_TYPE != SourceType.UniV3Checked) {\n            return rate_;\n        }\n\n        // 3 hops -> return rate of hop 1 combined with hop 2 & hop 3\n        rate_ = _getExchangeRateForHop(\n            rate_,\n            isOperate_,\n            OracleHopSource(_SOURCE3, _SOURCE3_INVERT, _SOURCE3_MULTIPLIER, _SOURCE3_DIVISOR, _SOURCE3_TYPE)\n        );\n        if (rate_ == 0) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__RateZero);\n        }\n        if (address(_SOURCE4) == address(0) && _SOURCE4_TYPE != SourceType.UniV3Checked) {\n            return rate_;\n        }\n\n        // 4 hops -> return rate of hop 1 combined with hop 2, hop 3 & hop 4\n        rate_ = _getExchangeRateForHop(\n            rate_,\n            isOperate_,\n            OracleHopSource(_SOURCE4, _SOURCE4_INVERT, _SOURCE4_MULTIPLIER, _SOURCE4_DIVISOR, _SOURCE4_TYPE)\n        );\n        if (rate_ == 0) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__RateZero);\n        }\n        if (address(_SOURCE5) == address(0) && _SOURCE5_TYPE != SourceType.UniV3Checked) {\n            return rate_;\n        }\n\n        // 5 hops -> return rate of hop 1 combined with hop 2, hop 3, hop 4 & hop 5\n        rate_ = _getExchangeRateForHop(\n            rate_,\n            isOperate_,\n            OracleHopSource(_SOURCE5, _SOURCE5_INVERT, _SOURCE5_MULTIPLIER, _SOURCE5_DIVISOR, _SOURCE5_TYPE)\n        );\n        if (rate_ == 0) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__RateZero);\n        }\n    }\n\n    /// @notice Returns the exchange rate for each hop.\n    /// @return rateSource1Operate_ The exchange rate for hop 1 during operate.\n    /// @return rateSource1Liquidate_ The exchange rate for hop 1 during liquidate.\n    /// @return rateSource2Operate_ The exchange rate for hop 2 during operate.\n    /// @return rateSource2Liquidate_ The exchange rate for hop 2 during liquidate.\n    /// @return rateSource3Operate_ The exchange rate for hop 3 during operate.\n    /// @return rateSource3Liquidate_ The exchange rate for hop 3 during liquidate.\n    /// @return rateSource4Operate_ The exchange rate for hop 4 during operate.\n    /// @return rateSource4Liquidate_ The exchange rate for hop 4 during liquidate.\n    /// @return rateSource5Operate_ The exchange rate for hop 5 during operate.\n    /// @return rateSource5Liquidate_ The exchange rate for hop 5 during liquidate.\n    function getHopExchangeRates()\n        public\n        view\n        returns (\n            uint256 rateSource1Operate_,\n            uint256 rateSource1Liquidate_,\n            uint256 rateSource2Operate_,\n            uint256 rateSource2Liquidate_,\n            uint256 rateSource3Operate_,\n            uint256 rateSource3Liquidate_,\n            uint256 rateSource4Operate_,\n            uint256 rateSource4Liquidate_,\n            uint256 rateSource5Operate_,\n            uint256 rateSource5Liquidate_\n        )\n    {\n        rateSource1Operate_ = _getExchangeRateForHop(\n            (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n            true,\n            OracleHopSource(_SOURCE1, _SOURCE1_INVERT, _SOURCE1_MULTIPLIER, _SOURCE1_DIVISOR, _SOURCE1_TYPE)\n        );\n        rateSource1Liquidate_ = _getExchangeRateForHop(\n            (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n            false,\n            OracleHopSource(_SOURCE1, _SOURCE1_INVERT, _SOURCE1_MULTIPLIER, _SOURCE1_DIVISOR, _SOURCE1_TYPE)\n        );\n\n        if (address(_SOURCE2) != address(0) || _SOURCE2_TYPE == SourceType.UniV3Checked) {\n            rateSource2Operate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                true,\n                OracleHopSource(_SOURCE2, _SOURCE2_INVERT, _SOURCE2_MULTIPLIER, _SOURCE2_DIVISOR, _SOURCE2_TYPE)\n            );\n            rateSource2Liquidate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                false,\n                OracleHopSource(_SOURCE2, _SOURCE2_INVERT, _SOURCE2_MULTIPLIER, _SOURCE2_DIVISOR, _SOURCE2_TYPE)\n            );\n        }\n\n        if (address(_SOURCE3) != address(0) || _SOURCE3_TYPE == SourceType.UniV3Checked) {\n            rateSource3Operate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                true,\n                OracleHopSource(_SOURCE3, _SOURCE3_INVERT, _SOURCE3_MULTIPLIER, _SOURCE3_DIVISOR, _SOURCE3_TYPE)\n            );\n            rateSource3Liquidate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                false,\n                OracleHopSource(_SOURCE3, _SOURCE3_INVERT, _SOURCE3_MULTIPLIER, _SOURCE3_DIVISOR, _SOURCE3_TYPE)\n            );\n        }\n\n        if (address(_SOURCE4) != address(0) || _SOURCE4_TYPE == SourceType.UniV3Checked) {\n            rateSource4Operate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                true,\n                OracleHopSource(_SOURCE4, _SOURCE4_INVERT, _SOURCE4_MULTIPLIER, _SOURCE4_DIVISOR, _SOURCE4_TYPE)\n            );\n            rateSource4Liquidate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                false,\n                OracleHopSource(_SOURCE4, _SOURCE4_INVERT, _SOURCE4_MULTIPLIER, _SOURCE4_DIVISOR, _SOURCE4_TYPE)\n            );\n        }\n\n        if (address(_SOURCE5) != address(0) || _SOURCE5_TYPE == SourceType.UniV3Checked) {\n            rateSource5Operate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                true,\n                OracleHopSource(_SOURCE5, _SOURCE5_INVERT, _SOURCE5_MULTIPLIER, _SOURCE5_DIVISOR, _SOURCE5_TYPE)\n            );\n            rateSource5Liquidate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                false,\n                OracleHopSource(_SOURCE5, _SOURCE5_INVERT, _SOURCE5_MULTIPLIER, _SOURCE5_DIVISOR, _SOURCE5_TYPE)\n            );\n        }\n    }\n\n    /// @notice Returns the configured OracleHopSources\n    function getOracleHopSources() public view returns (OracleHopSource[] memory sources_) {\n        sources_ = new OracleHopSource[](5);\n        sources_[0] = OracleHopSource(_SOURCE1, _SOURCE1_INVERT, _SOURCE1_MULTIPLIER, _SOURCE1_DIVISOR, _SOURCE1_TYPE);\n        sources_[1] = OracleHopSource(_SOURCE2, _SOURCE2_INVERT, _SOURCE2_MULTIPLIER, _SOURCE2_DIVISOR, _SOURCE2_TYPE);\n        sources_[2] = OracleHopSource(_SOURCE3, _SOURCE3_INVERT, _SOURCE3_MULTIPLIER, _SOURCE3_DIVISOR, _SOURCE3_TYPE);\n        sources_[3] = OracleHopSource(_SOURCE4, _SOURCE4_INVERT, _SOURCE4_MULTIPLIER, _SOURCE4_DIVISOR, _SOURCE4_TYPE);\n        sources_[4] = OracleHopSource(_SOURCE5, _SOURCE5_INVERT, _SOURCE5_MULTIPLIER, _SOURCE5_DIVISOR, _SOURCE5_TYPE);\n    }\n}\n"
    },
    "contracts/oracle/oraclesL2/dex/dexSmartColPegOracleL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracleL2 } from \"../../fluidOracleL2.sol\";\nimport { DexSmartColPegOracle } from \"../../oracles/dex/dexSmartColPegOracle.sol\";\n\n/// @title   Fluid Dex Smart Col Pegged Oracle for assets ~1=~1 on L2s\n/// @notice  Gets the exchange rate between a Fluid Dex smart collateral shares and normal debt.\n/// @dev -> Reserves from Liquidity with Peg buffer percent.\n///      -> Reserves conversion price from separately deployed FluidOracle (optional e.g. needed for wstETH-ETH).\n///      -> colDebt Price Oracle is an IFluidOracle.\ncontract DexSmartColPegOracleL2 is FluidOracleL2, DexSmartColPegOracle {\n    constructor(\n        DexSmartColPegOracle.DexSmartColPegOracleParams memory params_,\n        address sequencerUptimeFeed_\n    ) DexSmartColPegOracle(params_) FluidOracleL2(sequencerUptimeFeed_) {}\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateOperate()\n        public\n        view\n        \n        override(DexSmartColPegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateOperate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateLiquidate()\n        public\n        view\n        \n        override(DexSmartColPegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateLiquidate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRate()\n        public\n        view\n        \n        override(DexSmartColPegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        return getExchangeRateOperate();\n    }\n}\n"
    },
    "contracts/oracle/oraclesL2/dex/dexSmartDebtPegOracleL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracleL2 } from \"../../fluidOracleL2.sol\";\nimport { DexSmartDebtPegOracle } from \"../../oracles/dex/dexSmartDebtPegOracle.sol\";\n\n/// @title   Fluid Dex Smart Debt Pegged Oracle for assets ~1=~1 on L2s\n/// @notice  Gets the exchange rate between a Fluid Dex normal collateral and smart debt shares.\n/// @dev -> Reserves from Liquidity with Peg buffer percent.\n///      -> Reserves conversion price from separately deployed FluidOracle (optional e.g. needed for wstETH-ETH).\n///      -> colDebt Price Oracle is an IFluidOracle.\ncontract DexSmartDebtPegOracleL2 is FluidOracleL2, DexSmartDebtPegOracle {\n    constructor(\n        DexSmartDebtPegOracle.DexSmartDebtPegOracleParams memory params_,\n        address sequencerUptimeFeed_\n    ) DexSmartDebtPegOracle(params_) FluidOracleL2(sequencerUptimeFeed_) {}\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateOperate()\n        public\n        view\n        override(DexSmartDebtPegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateOperate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateLiquidate()\n        public\n        view\n        override(DexSmartDebtPegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateLiquidate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRate()\n        public\n        view\n        override(DexSmartDebtPegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        return getExchangeRateOperate();\n    }\n}\n"
    },
    "contracts/oracle/oraclesL2/dex/dexSmartT4CLOracleL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracleL2 } from \"../../fluidOracleL2.sol\";\nimport { DexSmartT4CLOracle } from \"../../oracles/dex/dexSmartT4CLOracle.sol\";\n\n/// @title   Fluid Dex Smart Col Debt VaultT4 Oracle on L2s\n/// @notice  Gets the exchange rate between a Fluid Dex smart collateral and smart debt for a T4 vault.\n///          returns amount of debt shares per 1 col share.\n/// @dev -> Reserves from Liquidity, adjusted for conversion price.\n///      -> Reserves conversion price from Chainlink feeds.\ncontract DexSmartT4CLOracleL2 is FluidOracleL2, DexSmartT4CLOracle {\n    constructor(\n        DexSmartT4CLOracle.DexSmartT4CLOracleParams memory params_,\n        address sequencerUptimeFeed_\n    ) DexSmartT4CLOracle(params_) FluidOracleL2(sequencerUptimeFeed_) {}\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateOperate()\n        public\n        view\n        override(DexSmartT4CLOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateOperate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateLiquidate()\n        public\n        view\n        override(DexSmartT4CLOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateLiquidate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRate() public view override(DexSmartT4CLOracle, FluidOracleL2) returns (uint256 exchangeRate_) {\n        return getExchangeRateOperate();\n    }\n}\n"
    },
    "contracts/oracle/oraclesL2/dex/dexSmartT4PegOracleL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracleL2 } from \"../../fluidOracleL2.sol\";\nimport { DexSmartT4PegOracle } from \"../../oracles/dex/dexSmartT4PegOracle.sol\";\n\n/// @title   Fluid Dex Smart Col Debt Pegged Oracle for assets ~1=~1 on L2s\n/// @notice  Gets the exchange rate between a Fluid Dex smart collateral shares and smart debt shares.\n/// @dev -> Reserves from Liquidity with Peg buffer percent.\n///      -> Reserves conversion price from separately deployed FluidOracle (optional e.g. needed for wstETH-ETH).\ncontract DexSmartT4PegOracleL2 is FluidOracleL2, DexSmartT4PegOracle {\n    constructor(\n        DexSmartT4PegOracle.DexSmartT4PegOracleParams memory params_,\n        address sequencerUptimeFeed_\n    ) DexSmartT4PegOracle(params_) FluidOracleL2(sequencerUptimeFeed_) {}\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateOperate()\n        public\n        view\n        override(DexSmartT4PegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateOperate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateLiquidate()\n        public\n        view\n        override(DexSmartT4PegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateLiquidate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRate()\n        public\n        view\n        override(DexSmartT4PegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        return getExchangeRateOperate();\n    }\n}\n"
    },
    "contracts/oracle/oraclesL2/genericOracleL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracleL2 } from \"../fluidOracleL2.sol\";\nimport { FluidGenericOracle } from \"../oracles/genericOracle.sol\";\n\n/// @notice generic configurable Oracle for Layer 2 (with sequencer outage detection)\n/// combines up to 4 hops from sources such as\n///  - an existing IFluidOracle (e.g. ContractRate)\n///  - Redstone\n///  - Chainlink\ncontract FluidGenericOracleL2 is FluidOracleL2, FluidGenericOracle {\n    constructor(\n        string memory infoName_,\n        OracleHopSource[] memory sources_,\n        address sequencerUptimeFeed_\n    ) FluidGenericOracle(infoName_, sources_) FluidOracleL2(sequencerUptimeFeed_) {}\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateOperate()\n        public\n        view\n        override(FluidGenericOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateOperate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateLiquidate()\n        public\n        view\n        override(FluidGenericOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateLiquidate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRate() public view override(FluidGenericOracle, FluidOracleL2) returns (uint256 exchangeRate_) {\n        return getExchangeRateOperate();\n    }\n}\n"
    },
    "contracts/oracle/sourceReaders/chainlinkSourceReader.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IChainlinkAggregatorV3 } from \"../interfaces/external/IChainlinkAggregatorV3.sol\";\n\nabstract contract ChainlinkSourceReader {\n    function _readChainlinkSource(address feed_) internal view returns (uint256 rate_) {\n        try IChainlinkAggregatorV3(feed_).latestRoundData() returns (\n            uint80,\n            int256 exchangeRate_,\n            uint256,\n            uint256,\n            uint80\n        ) {\n            // Return the price in `OracleUtils.RATE_OUTPUT_DECIMALS`\n            return uint256(exchangeRate_);\n        } catch {}\n    }\n}\n"
    },
    "contracts/oracle/sourceReaders/fluidSourceReader.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"../interfaces/iFluidOracle.sol\";\n\nabstract contract FluidSourceReader {\n    function _readFluidSource(address oracle_, bool isOperate_) internal view returns (uint256 rate_) {\n        if (isOperate_) {\n            try IFluidOracle(oracle_).getExchangeRateOperate() returns (uint256 exchangeRate_) {\n                return exchangeRate_;\n            } catch {}\n        } else {\n            try IFluidOracle(oracle_).getExchangeRateLiquidate() returns (uint256 exchangeRate_) {\n                return exchangeRate_;\n            } catch {}\n        }\n    }\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexT1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexT1 {\n    error FluidDexError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares);\n\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\n\n    /// @notice returns the dex id\n    function DEX_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndOracle;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) external view returns (CollateralReserves memory c_);\n\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) external view returns (DebtReserves memory d_);\n\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\n    function getPricesAndExchangePrices() external;\n\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) external returns (\n        uint withdrawAmt_\n    );\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) external payable returns (\n        uint paybackAmt_\n    );\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(\n        uint[] memory secondsAgos_\n    ) external view returns (\n        Oracle[] memory twaps_,\n        uint currentPrice_\n    );\n}\n"
    },
    "solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}