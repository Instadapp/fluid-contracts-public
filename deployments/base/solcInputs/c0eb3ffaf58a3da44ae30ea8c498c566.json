{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/config/bufferRateHandler/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { Structs as AdminModuleStructs } from \"../../liquidity/adminModule/structs.sol\";\n\nabstract contract Constants {\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n    IFluidLiquidity public immutable LIQUIDITY;\n\n    /// @notice supply token at Liquidity which borrow rate is based on\n    address public immutable SUPPLY_TOKEN;\n    /// @notice borrow token at Liquidity for which the borrow rate is managed\n    address public immutable BORROW_TOKEN;\n\n    /// @notice buffer at kink1 for the rate. borrow rate = supply rate + buffer. In percent (100 = 1%, 1 = 0.01%)\n    int256 public immutable RATE_BUFFER_KINK1;\n    /// @notice buffer at kink2 for the rate. borrow rate = supply rate + buffer. In percent (100 = 1%, 1 = 0.01%)\n    /// @dev only used if CURRENT borrow rate mode at Liquidity is V2 (with 2 kinks).\n    int256 public immutable RATE_BUFFER_KINK2;\n\n    /// @dev minimum percent difference to trigger an update. In percent (100 = 1%, 1 = 0.01%)\n    uint256 public immutable MIN_UPDATE_DIFF;\n\n    bytes32 internal immutable _LIQUDITY_SUPPLY_TOTAL_AMOUNTS_SLOT;\n    bytes32 internal immutable _LIQUDITY_SUPPLY_EXCHANGE_PRICES_AND_CONFIG_SLOT;\n\n    bytes32 internal immutable _LIQUDITY_BORROW_RATE_DATA_SLOT;\n\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xff;\n\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n    uint256 internal constant FOUR_DECIMALS = 10000;\n}\n\nabstract contract Events {\n    /// @notice emitted when borrow rate for `BORROW_TOKEN` is updated based on\n    ///          supply rate of `SUPPLY_TOKEN` + buffer.\n    event LogUpdateRate(\n        uint256 supplyRate,\n        uint256 oldRateKink1,\n        uint256 newRateKink1,\n        uint256 oldRateKink2,\n        uint256 newRateKink2\n    );\n}\n\n/// @notice Sets borrow rate for `BORROW_TOKEN` at Liquidaty based on supply rate of `SUPPLY_TOKEN` + buffer.\ncontract FluidBufferRateHandler is Constants, Error, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.BufferRateConfigHandler__AddressZero);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract)\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.BufferRateConfigHandler__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(\n        IFluidReserveContract reserveContract_,\n        IFluidLiquidity liquidity_,\n        address supplyToken_,\n        address borrowToken_,\n        int256 rateBufferKink1_,\n        int256 rateBufferKink2_,\n        uint256 minUpdateDiff_\n    )\n        validAddress(address(reserveContract_))\n        validAddress(address(liquidity_))\n        validAddress(supplyToken_)\n        validAddress(borrowToken_)\n    {\n        if (\n            minUpdateDiff_ == 0 ||\n            // rate buffer should be within +100% to - 100%\n            rateBufferKink1_ > 1e4 ||\n            rateBufferKink1_ < -int256(1e4) ||\n            rateBufferKink2_ > 1e4 ||\n            rateBufferKink2_ < -int256(1e4)\n        ) {\n            revert FluidConfigError(ErrorTypes.BufferRateConfigHandler__InvalidParams);\n        }\n\n        RESERVE_CONTRACT = reserveContract_;\n        LIQUIDITY = liquidity_;\n        SUPPLY_TOKEN = supplyToken_;\n        BORROW_TOKEN = borrowToken_;\n        MIN_UPDATE_DIFF = minUpdateDiff_;\n\n        RATE_BUFFER_KINK1 = rateBufferKink1_;\n        RATE_BUFFER_KINK2 = rateBufferKink2_;\n\n        _LIQUDITY_SUPPLY_TOTAL_AMOUNTS_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT,\n            supplyToken_\n        );\n        _LIQUDITY_SUPPLY_EXCHANGE_PRICES_AND_CONFIG_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            supplyToken_\n        );\n\n        _LIQUDITY_BORROW_RATE_DATA_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_RATE_DATA_MAPPING_SLOT,\n            borrowToken_\n        );\n    }\n\n    function configPercentDiff() public view returns (uint256 configPercentDiff_) {\n        uint256 rateConfig_ = LIQUIDITY.readFromStorage(_LIQUDITY_BORROW_RATE_DATA_SLOT);\n\n        (uint256 newRateKink1_, uint256 newRateKink2_) = _calcBorrowRates(supplyTokenLendingRate(), rateConfig_);\n\n        uint256 rateVersion_ = rateConfig_ & 0xF;\n        if (rateVersion_ == 1) {\n            uint256 oldRateKink1_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) &\n                X16;\n            configPercentDiff_ = _percentDiffForValue(oldRateKink1_, newRateKink1_);\n        } else if (rateVersion_ == 2) {\n            uint256 oldRateKink1_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) &\n                X16;\n            uint256 oldRateKink2_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) &\n                X16;\n\n            configPercentDiff_ = _percentDiffForValue(oldRateKink1_, newRateKink1_);\n            uint256 rateKink2Diff_ = _percentDiffForValue(oldRateKink2_, newRateKink2_);\n            // final diff = biggest diff between all config values\n            configPercentDiff_ = configPercentDiff_ > rateKink2Diff_ ? configPercentDiff_ : rateKink2Diff_;\n        } else {\n            revert FluidConfigError(ErrorTypes.BufferRateConfigHandler__RateVersionUnsupported);\n        }\n    }\n\n    function rebalance() external onlyRebalancer {\n        uint256 supplyLendingRate_ = supplyTokenLendingRate();\n        uint256 rateConfig_ = LIQUIDITY.readFromStorage(_LIQUDITY_BORROW_RATE_DATA_SLOT);\n\n        uint256 rateVersion_ = rateConfig_ & 0xF;\n        if (rateVersion_ == 1) {\n            _rebalanceRateV1(supplyLendingRate_, rateConfig_);\n        } else if (rateVersion_ == 2) {\n            _rebalanceRateV2(supplyLendingRate_, rateConfig_);\n        } else {\n            revert FluidConfigError(ErrorTypes.BufferRateConfigHandler__RateVersionUnsupported);\n        }\n    }\n\n    /// @notice returns the current calculcated borrow rates at kink1 and kink 2 (for rate data v2).\n    function calcBorrowRates() public view returns (uint256 rateKink1_, uint256 rateKink2_) {\n        return _calcBorrowRates(supplyTokenLendingRate(), LIQUIDITY.readFromStorage(_LIQUDITY_BORROW_RATE_DATA_SLOT));\n    }\n\n    /// @notice  get current `SUPPLY_TOKEN` lending `rate_` at Liquidity\n    function supplyTokenLendingRate() public view returns (uint256 rate_) {\n        // @dev logic here based on Liquidity Resolver .getOverallTokenData()\n        uint256 totalAmounts_ = LIQUIDITY.readFromStorage(_LIQUDITY_SUPPLY_TOTAL_AMOUNTS_SLOT);\n\n        // Extract supply & borrow amounts\n        uint256 supplyRawInterest_ = totalAmounts_ & X64;\n        supplyRawInterest_ =\n            (supplyRawInterest_ >> DEFAULT_EXPONENT_SIZE) <<\n            (supplyRawInterest_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 borrowRawInterest_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) &\n            X64;\n        borrowRawInterest_ =\n            (borrowRawInterest_ >> DEFAULT_EXPONENT_SIZE) <<\n            (borrowRawInterest_ & DEFAULT_EXPONENT_MASK);\n\n        if (supplyRawInterest_ > 0) {\n            uint256 exchangePriceAndConfig_ = LIQUIDITY.readFromStorage(\n                _LIQUDITY_SUPPLY_EXCHANGE_PRICES_AND_CONFIG_SLOT\n            );\n\n            // use old exchange prices for supply rate to be at same level as borrow rate from storage.\n            // Note the rate here can be a tiny bit with higher precision because we use borrowWithInterest_ / supplyWithInterest_\n            // which has higher precision than the utilization used from storage in LiquidityCalcs\n            uint256 supplyWithInterest_ = (supplyRawInterest_ *\n                ((exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) & X64)) /\n                EXCHANGE_PRICES_PRECISION; // normalized from raw\n            uint256 borrowWithInterest_ = (borrowRawInterest_ *\n                ((exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) & X64)) /\n                EXCHANGE_PRICES_PRECISION; // normalized from raw\n\n            uint256 borrowRate_ = exchangePriceAndConfig_ & X16;\n            uint256 fee_ = (exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14;\n\n            rate_ =\n                (borrowRate_ * (FOUR_DECIMALS - fee_) * borrowWithInterest_) /\n                (supplyWithInterest_ * FOUR_DECIMALS);\n        }\n    }\n\n    /// @dev calculates current borrow rates at kinks for supply rate and current rate data\n    function _calcBorrowRates(\n        uint256 supplyRate_,\n        uint256 rateConfig_\n    ) internal view returns (uint256 rateKink1_, uint256 rateKink2_) {\n        // rate can never be <0, > X16.\n        rateKink1_ = (int256(supplyRate_) + RATE_BUFFER_KINK1) > 0\n            ? uint256((int256(supplyRate_) + RATE_BUFFER_KINK1))\n            : 0;\n        // rate can never be > X16\n        rateKink1_ = rateKink1_ > X16 ? X16 : rateKink1_;\n        if ((rateConfig_ & 0xF) == 1) {\n            // v1: only 1 kink\n            // rate at last kink must always be <= rate at 100% utilization\n            uint256 rateAtUtilizationMax_ = (rateConfig_ >>\n                LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\n            if (rateKink1_ > rateAtUtilizationMax_) {\n                rateKink1_ = rateAtUtilizationMax_;\n            }\n        } else {\n            // v2: 2 kinks\n            // rate can never be <0, > X16.\n            rateKink2_ = (int256(supplyRate_) + RATE_BUFFER_KINK2) > 0\n                ? uint256(int256(supplyRate_) + RATE_BUFFER_KINK2)\n                : 0;\n            // rate can never be > X16\n            rateKink2_ = rateKink2_ > X16 ? X16 : rateKink2_;\n            // rate at kink must always be <= rate at 100% utilization\n            uint256 rateAtUtilizationMax_ = (rateConfig_ >>\n                LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\n            if (rateKink1_ > rateAtUtilizationMax_) {\n                rateKink1_ = rateAtUtilizationMax_;\n            }\n            if (rateKink2_ > rateAtUtilizationMax_) {\n                rateKink2_ = rateAtUtilizationMax_;\n            }\n        }\n    }\n\n    /// @dev gets the percentage difference between `oldValue_` and `newValue_` in relation to `oldValue_`\n    function _percentDiffForValue(\n        uint256 oldValue_,\n        uint256 newValue_\n    ) internal pure returns (uint256 configPercentDiff_) {\n        if (oldValue_ == newValue_) {\n            return 0;\n        }\n\n        if (oldValue_ > newValue_) {\n            // % of how much new value would be smaller\n            configPercentDiff_ = oldValue_ - newValue_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 10 -> 2000 (20%)\n        } else {\n            // % of how much new value would be bigger\n            configPercentDiff_ = newValue_ - oldValue_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 8 -> 2500 (25%)\n        }\n\n        configPercentDiff_ = (configPercentDiff_ * 1e4) / oldValue_;\n    }\n\n    /// @dev rebalances for a RateV1 config\n    function _rebalanceRateV1(uint256 supplyRate_, uint256 rateConfig_) internal {\n        AdminModuleStructs.RateDataV1Params memory rateData_;\n\n        uint256 oldRateKink1_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n        (rateData_.rateAtUtilizationKink, ) = _calcBorrowRates(supplyRate_, rateConfig_);\n\n        // check if diff is enough to trigger update\n        if (_percentDiffForValue(oldRateKink1_, rateData_.rateAtUtilizationKink) < MIN_UPDATE_DIFF) {\n            revert FluidConfigError(ErrorTypes.BufferRateConfigHandler__NoUpdate);\n        }\n\n        rateData_.token = BORROW_TOKEN;\n        // values that stay the same: kink, rate at 0%, rate at 100%\n        rateData_.rateAtUtilizationZero =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) &\n            X16;\n        rateData_.kink = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n        rateData_.rateAtUtilizationMax =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) &\n            X16;\n\n        // trigger update\n        AdminModuleStructs.RateDataV1Params[] memory params_ = new AdminModuleStructs.RateDataV1Params[](1);\n        params_[0] = rateData_;\n        LIQUIDITY.updateRateDataV1s(params_);\n\n        // emit event\n        emit LogUpdateRate(supplyRate_, oldRateKink1_, rateData_.rateAtUtilizationKink, 0, 0);\n    }\n\n    /// @dev rebalances for a RateV2 config\n    function _rebalanceRateV2(uint256 supplyRate_, uint256 rateConfig_) internal {\n        AdminModuleStructs.RateDataV2Params memory rateData_;\n\n        uint256 oldRateKink1_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n        uint256 oldRateKink2_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n        (rateData_.rateAtUtilizationKink1, rateData_.rateAtUtilizationKink2) = _calcBorrowRates(\n            supplyRate_,\n            rateConfig_\n        );\n\n        // check if diff is enough to trigger update\n        if (\n            _percentDiffForValue(oldRateKink1_, rateData_.rateAtUtilizationKink1) < MIN_UPDATE_DIFF &&\n            _percentDiffForValue(oldRateKink2_, rateData_.rateAtUtilizationKink2) < MIN_UPDATE_DIFF\n        ) {\n            revert FluidConfigError(ErrorTypes.BufferRateConfigHandler__NoUpdate);\n        }\n\n        rateData_.token = BORROW_TOKEN;\n        // values that stay the same: kink1, kink2, rate at 0%, rate at 100%\n        rateData_.rateAtUtilizationZero =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) &\n            X16;\n        rateData_.kink1 = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\n        rateData_.kink2 = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\n        rateData_.rateAtUtilizationMax =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) &\n            X16;\n\n        // trigger update\n        AdminModuleStructs.RateDataV2Params[] memory params_ = new AdminModuleStructs.RateDataV2Params[](1);\n        params_[0] = rateData_;\n        LIQUIDITY.updateRateDataV2s(params_);\n\n        // emit event\n        emit LogUpdateRate(\n            supplyRate_,\n            oldRateKink1_,\n            rateData_.rateAtUtilizationKink1,\n            oldRateKink2_,\n            rateData_.rateAtUtilizationKink2\n        );\n    }\n}\n"
    },
    "contracts/config/collectRevenueAuth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nabstract contract Constants {\n    /// @notice Fluid liquidity address\n    IFluidLiquidity public immutable LIQUIDITY;\n\n    /// @notice Team multisig allowed to trigger collecting revenue\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n\n    /// @notice Fluid reserve contract, allowed rebalancers there are allowed to trigger collecting revenue\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n}\n\nabstract contract Events {\n    /// @notice emitted when revenue is collected\n    event LogCollectRevenue(address[]);\n}\n\n/// @notice Collects the revenue from the Fluid Liquidity layer to the configured revenue collector\ncontract FluidCollectRevenueAuth is Constants, Error, Events {\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract) or team multisig\n    modifier onlyRebalancerOrMultisig() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender) && msg.sender != TEAM_MULTISIG) {\n            revert FluidConfigError(ErrorTypes.CollectRevenueAuth__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(address liquidity_, address reserveContract_) {\n        if (liquidity_ == address(0) || reserveContract_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.CollectRevenueAuth__InvalidParams);\n        }\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        RESERVE_CONTRACT = IFluidReserveContract(reserveContract_);\n    }\n\n    /// @notice calls the collectRevenue method in the liquidity layer for `tokens_`\n    function collectRevenue(address[] calldata tokens_) external onlyRebalancerOrMultisig {\n        LIQUIDITY.collectRevenue(tokens_);\n\n        emit LogCollectRevenue(tokens_);\n    }\n}\n"
    },
    "contracts/config/dexFeeAuth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nimport { DexSlotsLink } from \"../../libraries/dexSlotsLink.sol\";\nimport { IFluidDexT1 } from \"../../protocols/dex/interfaces/iDexT1.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\n\ninterface IFluidDexT1Admin {\n    /// @notice sets a new fee and revenue cut for a certain dex\n    /// @param fee_ new fee (scaled so that 1% = 10000)\n    /// @param revenueCut_ new revenue cut\n    function updateFeeAndRevenueCut(uint fee_, uint revenueCut_) external;\n}\n\nabstract contract Events {\n    /// @notice emitted when the fee is updated\n    event LogSetFee(address dex, uint oldFee, uint newFee);\n\n    /// @notice emitted when the revenue cut is updated\n    event LogSetRevenueCut(address dex, uint oldRevenueCut, uint newRevenueCut);\n}\n\nabstract contract Constants {\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X17 = 0x1ffff;\n\n    /// @notice Team multisigs allowed to trigger methods\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n    address public constant TEAM_MULTISIG2 = 0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\n}\n\ncontract FluidDexFeeAuth is Constants, Error, Events {\n    /// @dev Validates that an address is team multisig\n    modifier onlyMultisig() {\n        if (TEAM_MULTISIG != msg.sender && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.DexFeeAuth__Unauthorized);\n        }\n        _;\n    }\n\n    function getDexFeeAndRevenueCut(address dex_) public view returns (uint256 fee_, uint256 revenueCut_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        fee_ = (dexVariables2_ >> 2) & X17;\n        revenueCut_ = (dexVariables2_ >> 19) & X7;\n    }\n\n    /// @notice Sets the fee for a given DEX.\n    /// @dev Only callable by team multisig addresses.\n    /// @param dex_ The address of the DEX contract.\n    /// @param newFee_ in 4 decimals, 10000 = 1%\n    function setDexFee(address dex_, uint256 newFee_) external onlyMultisig {\n        (uint256 currentFee_, uint256 currentRevenueCut_) = getDexFeeAndRevenueCut(dex_);\n\n        IFluidDexT1Admin(dex_).updateFeeAndRevenueCut(newFee_, currentRevenueCut_ * FOUR_DECIMALS);\n\n        emit LogSetFee(dex_, currentFee_, newFee_);\n    }\n\n    /// @notice Sets the revenue cut for a given DEX.\n    /// @dev Only callable by team multisig addresses.\n    /// @param dex_ The address of the DEX contract.\n    /// @param newRevenueCut_ in 4 decimals, 100000 = 10%, 10% cut on fee_, so if fee is 1% and cut is 10% then cut in swap amount will be 10% of 1% = 0.1%\n    function setDexRevenueCut(address dex_, uint256 newRevenueCut_) external onlyMultisig {\n        (uint256 currentFee_, uint256 currentRevenueCut_) = getDexFeeAndRevenueCut(dex_);\n\n        IFluidDexT1Admin(dex_).updateFeeAndRevenueCut(currentFee_, newRevenueCut_);\n\n        emit LogSetRevenueCut(dex_, currentRevenueCut_, newRevenueCut_);\n    }\n}\n"
    },
    "contracts/config/dexFeeHandler/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { AddressCalcs } from \"../../libraries/addressCalcs.sol\";\nimport { DexSlotsLink } from \"../../libraries/dexSlotsLink.sol\";\nimport { IFluidDexT1 } from \"../../protocols/dex/interfaces/iDexT1.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\n\ninterface IFluidDexT1Admin {\n    /// @notice sets a new fee and revenue cut for a certain dex\n    /// @param fee_ new fee (scaled so that 1% = 10000)\n    /// @param revenueCut_ new revenue cut\n    function updateFeeAndRevenueCut(uint fee_, uint revenueCut_) external;\n}\n\ninterface ICenterPrice {\n    /// @notice Retrieves the center price for the pool\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\n    /// @return price The current price ratio of token1 to token0, expressed with 27 decimal places\n    function centerPrice() external returns (uint price);\n}\n\nabstract contract Events is Error {\n    /// @notice emitted when rebalancer successfully changes the fee and revenue cut\n    event LogRebalanceFeeAndRevenueCut(address dex, uint fee, uint revenueCut);\n}\n\nabstract contract Constants is Events {\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant SIX_DECIMALS = 1e6;\n\n    uint256 internal constant SCALE = 1e27;\n\n    /// @notice Whether the center price is active\n    bool public immutable CENTER_PRICE_ACTIVE;\n\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X17 = 0x1ffff;\n    uint256 internal constant X20 = 0xfffff;\n    uint256 internal constant X28 = 0xfffffff;\n    uint256 internal constant X30 = 0x3fffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X40 = 0xffffffffff;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    /// @dev Address of contract used for deploying center price & hook related contract\n    address internal immutable DEPLOYER_CONTRACT;\n\n    uint256 public immutable MIN_FEE; // e.g. 10 -> 0.001%\n    uint256 public immutable MAX_FEE; // e.g. 100 -> 0.01%\n    uint256 public immutable MIN_DEVIATION; // in 1e27 scale, e.g. 3e23 -> 0.003\n    uint256 public immutable MAX_DEVIATION; // in 1e27 scale, e.g. 1e24 -> 0.01\n\n    uint256 public immutable UPDATE_FEE_TRIGGER_BUFFER = 10; // e.g. 1e4 -> 1%\n\n    address public immutable DEX;\n\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n}\n\nabstract contract DexHelpers is Constants {\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\n        }\n        _;\n    }\n\n    constructor(\n        address dex_,\n        address deployerContract_,\n        bool isCenterPriceActive_\n    ) validAddress(dex_) validAddress(deployerContract_) {\n        DEX = dex_;\n        DEPLOYER_CONTRACT = deployerContract_;\n        CENTER_PRICE_ACTIVE = isCenterPriceActive_;\n    }\n\n    function _getCenterPriceShift() internal view returns (uint256) {\n        return IFluidDexT1(DEX).readFromStorage(bytes32(DexSlotsLink.DEX_CENTER_PRICE_SHIFT_SLOT));\n    }\n\n    function _getDexVariables() internal view returns (uint256) {\n        return IFluidDexT1(DEX).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES_SLOT));\n    }\n\n    function _getDexVariables2() internal view returns (uint256) {\n        return IFluidDexT1(DEX).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n    }\n\n    function _getCenterPriceFromCenterPriceAddress(uint256 centerPriceNonce_) internal view returns (uint256) {\n        address centerPriceAddress_ = AddressCalcs.addressCalc(DEPLOYER_CONTRACT, centerPriceNonce_);\n        (bool success_, bytes memory data_) = centerPriceAddress_.staticcall(\n            abi.encodeWithSelector(ICenterPrice.centerPrice.selector)\n        );\n        require(success_, \"Static call failed\");\n        return abi.decode(data_, (uint256));\n    }\n\n    function _calcCenterPrice(uint dexVariables_, uint centerPriceNonce_) internal view returns (uint newCenterPrice_) {\n        uint oldCenterPrice_ = (dexVariables_ >> 81) & X40;\n        oldCenterPrice_ = (oldCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (oldCenterPrice_ & DEFAULT_EXPONENT_MASK);\n\n        uint centerPriceShift_ = _getCenterPriceShift();\n\n        uint startTimeStamp_ = centerPriceShift_ & X33;\n        uint percent_ = (centerPriceShift_ >> 33) & X20;\n        uint time_ = (centerPriceShift_ >> 53) & X20;\n\n        uint fromTimeStamp_ = (dexVariables_ >> 121) & X33;\n        fromTimeStamp_ = fromTimeStamp_ > startTimeStamp_ ? fromTimeStamp_ : startTimeStamp_;\n\n        newCenterPrice_ = _getCenterPriceFromCenterPriceAddress(centerPriceNonce_);\n        uint priceShift_ = (oldCenterPrice_ * percent_ * (block.timestamp - fromTimeStamp_)) / (time_ * SIX_DECIMALS);\n\n        if (newCenterPrice_ > oldCenterPrice_) {\n            // shift on positive side\n            oldCenterPrice_ += priceShift_;\n            if (newCenterPrice_ > oldCenterPrice_) {\n                newCenterPrice_ = oldCenterPrice_;\n            }\n        } else {\n            unchecked {\n                oldCenterPrice_ = oldCenterPrice_ > priceShift_ ? oldCenterPrice_ - priceShift_ : 0;\n                // In case of oldCenterPrice_ ending up 0, which could happen when a lot of time has passed (pool has no swaps for many days or weeks)\n                // then below we get into the else logic which will fully conclude shifting and return newCenterPrice_\n                // as it was fetched from the external center price source.\n                // not ideal that this would ever happen unless the pool is not in use and all/most users have left leaving not enough liquidity to trade on\n            }\n            if (newCenterPrice_ < oldCenterPrice_) {\n                newCenterPrice_ = oldCenterPrice_;\n            }\n        }\n    }\n\n    function _fetchCenterPrice() internal view returns (uint256 centerPrice_) {\n        (uint256 dexVariables_, uint256 dexVariables2_) = (_getDexVariables(), _getDexVariables2());\n\n        // centerPrice_ => center price hook\n        centerPrice_ = (dexVariables2_ >> 112) & X30;\n\n        // whether centerPrice shift is active or not\n        if (((dexVariables2_ >> 248) & 1) == 0) {\n            if (centerPrice_ == 0) {\n                centerPrice_ = (dexVariables_ >> 81) & X40;\n                centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n            } else {\n                // center price should be fetched from external source. For exmaple, in case of wstETH <> ETH pool,\n                // we would want the center price to be pegged to wstETH exchange rate into ETH\n                centerPrice_ = _getCenterPriceFromCenterPriceAddress(centerPrice_);\n            }\n        } else {\n            // an active centerPrice_ shift is going on\n            centerPrice_ = _calcCenterPrice(dexVariables_, centerPrice_);\n        }\n\n        {\n            uint maxCenterPrice_ = (dexVariables2_ >> 172) & X28;\n            maxCenterPrice_ = (maxCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (maxCenterPrice_ & DEFAULT_EXPONENT_MASK);\n\n            if (centerPrice_ > maxCenterPrice_) {\n                // if center price is greater than max center price\n                centerPrice_ = maxCenterPrice_;\n            } else {\n                // check if center price is less than min center price\n                uint minCenterPrice_ = (dexVariables2_ >> 200) & X28;\n                minCenterPrice_ =\n                    (minCenterPrice_ >> DEFAULT_EXPONENT_SIZE) <<\n                    (minCenterPrice_ & DEFAULT_EXPONENT_MASK);\n                if (centerPrice_ < minCenterPrice_) {\n                    centerPrice_ = minCenterPrice_;\n                }\n            }\n        }\n    }\n\n    function _getDexFee() internal view returns (uint256 fee_) {\n        return (_getDexVariables2() >> 2) & X17;\n    }\n\n    function getDexCenterPrice() public view returns (uint256) {\n        return _fetchCenterPrice();\n    }\n\n    /// @notice returns the revenue cut for the dex\n    function getDexRevenueCut() public view returns (uint256 revenueCut_) {\n        return (_getDexVariables2() >> 19) & X7;\n    }\n\n    /// @notice returns the fee and revenue cut for the dex\n    function getDexFeeAndRevenueCut() public view returns (uint256 fee_, uint256 revenueCut_) {\n        uint256 dexVariables2_ = _getDexVariables2();\n\n        fee_ = (dexVariables2_ >> 2) & X17;\n        revenueCut_ = (dexVariables2_ >> 19) & X7;\n    }\n\n    /// @notice returns the last stored prices of the pool and the last interaction time stamp\n    function getDexVariables()\n        public\n        view\n        returns (uint256 lastToLastStoredPrice_, uint256 lastStoredPriceOfPool_, uint256 lastInteractionTimeStamp_)\n    {\n        uint256 dexVariables_ = _getDexVariables();\n\n        lastToLastStoredPrice_ = (dexVariables_ >> 1) & X40;\n        lastToLastStoredPrice_ =\n            (lastToLastStoredPrice_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastToLastStoredPrice_ & DEFAULT_EXPONENT_MASK);\n\n        lastStoredPriceOfPool_ = (dexVariables_ >> 41) & X40;\n        lastStoredPriceOfPool_ =\n            (lastStoredPriceOfPool_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastStoredPriceOfPool_ & DEFAULT_EXPONENT_MASK);\n\n        lastInteractionTimeStamp_ = (dexVariables_ >> 121) & X33;\n    }\n}\n\nabstract contract DynamicFee is DexHelpers {\n    constructor(uint256 _minFee, uint256 _maxFee, uint256 _minDeviation, uint256 _maxDeviation) {\n        // check for zero values\n        if (_minFee == 0 || _maxFee == 0 || _minDeviation == 0 || _maxDeviation == 0)\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\n\n        // check that max fee is not greater or equal to 1%\n        if (_maxFee >= 1e4) revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\n\n        // check that min deviation is not greater than max deviation\n        if (_minDeviation > _maxDeviation) revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\n\n        // check that min fee is not greater than max fee\n        if (_minFee > _maxFee) revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\n\n        MIN_FEE = _minFee;\n        MAX_FEE = _maxFee;\n        MIN_DEVIATION = _minDeviation;\n        MAX_DEVIATION = _maxDeviation;\n    }\n\n    /// @notice Calculates the deviation from the given price.\n    function getDeviationFromPrice(uint256 price_) public view returns (uint256) {\n        if (CENTER_PRICE_ACTIVE) {\n            uint256 centerPrice_ = _fetchCenterPrice();\n            uint256 deviation_ = price_ > centerPrice_ ? price_ - centerPrice_ : centerPrice_ - price_;\n            return (deviation_ * SCALE) / centerPrice_;\n        } else {\n            return price_ > SCALE ? price_ - SCALE : SCALE - price_;\n        }\n    }\n\n    /// @notice Calculates the dynamic fee based on the given price.\n    function dynamicFeeFromPrice(uint256 price) external view returns (uint256) {\n        return _computeDynamicFee(getDeviationFromPrice(price));\n    }\n\n    /// @notice Calculates the dynamic fee based on the given deviation.\n    function dynamicFeeFromDeviation(uint256 deviation) external view returns (uint256) {\n        return _computeDynamicFee(deviation);\n    }\n\n    /**\n     * @dev Internal helper that implements a smooth-step curve for fee calculation\n     * @param deviation Deviation from the target price in SCALE (1e27)\n     * @return Fee in basis points (1e4 = 1%)\n     */\n    function _computeDynamicFee(uint256 deviation) internal view returns (uint256) {\n        if (deviation <= MIN_DEVIATION) {\n            return MIN_FEE;\n        } else if (deviation >= MAX_DEVIATION) {\n            return MAX_FEE;\n        } else {\n            // Calculate normalized position between min and max deviation (0 to 1 in SCALE)\n            uint256 alpha = ((deviation - MIN_DEVIATION) * SCALE) / (MAX_DEVIATION - MIN_DEVIATION);\n\n            // Smooth step formula: 3x² - 2x³\n            // https://en.wikipedia.org/wiki/Smoothstep\n            uint256 alpha2 = _scaleMul(alpha, alpha);\n            uint256 alpha3 = _scaleMul(alpha2, alpha);\n\n            uint256 smooth = _scaleMul(3 * SCALE, alpha2) - _scaleMul(2 * SCALE, alpha3);\n\n            uint256 feeDelta = MAX_FEE - MIN_FEE;\n            uint256 interpolatedFee = MIN_FEE + (_scaleMul(smooth, feeDelta));\n\n            return interpolatedFee;\n        }\n    }\n\n    function _scaleMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * b) / SCALE;\n    }\n}\n\nabstract contract FluidDexFeeHandlerHelpers is DynamicFee {\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(\n        uint256 minFee_,\n        uint256 maxFee_,\n        uint256 minDeviation_,\n        uint256 maxDeviation_,\n        address dex_,\n        address deployerContract_,\n        IFluidReserveContract reserveContract_,\n        bool centerPriceActive_\n    )\n        validAddress(address(reserveContract_))\n        DexHelpers(dex_, deployerContract_, centerPriceActive_)\n        DynamicFee(minFee_, maxFee_, minDeviation_, maxDeviation_)\n    {\n        RESERVE_CONTRACT = reserveContract_;\n    }\n\n    /// @notice returns the dynamic fee for the dex based on the last stored price of the pool\n    function getDexDynamicFee() public view returns (uint256) {\n        (\n            uint256 lastToLastStoredPrice_,\n            uint256 lastStoredPriceOfPool_,\n            uint256 lastInteractionTimeStamp_\n        ) = getDexVariables();\n\n        if (lastInteractionTimeStamp_ == block.timestamp) lastStoredPriceOfPool_ = lastToLastStoredPrice_;\n\n        return _computeDynamicFee(getDeviationFromPrice(lastStoredPriceOfPool_));\n    }\n\n    function _configPercentDiff(\n        uint256 currentFee_,\n        uint256 newFee_\n    ) internal pure returns (uint256 configPercentDiff_) {\n        if (currentFee_ == newFee_) {\n            return 0;\n        }\n\n        if (currentFee_ > newFee_) configPercentDiff_ = currentFee_ - newFee_;\n        else configPercentDiff_ = newFee_ - currentFee_;\n\n        return (configPercentDiff_ * FOUR_DECIMALS) / currentFee_;\n    }\n}\n\ncontract FluidDexFeeHandler is FluidDexFeeHandlerHelpers {\n    constructor(\n        uint256 minFee_,\n        uint256 maxFee_,\n        uint256 minDeviation_,\n        uint256 maxDeviation_,\n        address dex_,\n        address deployerContract_,\n        IFluidReserveContract reserveContract_,\n        bool centerPriceActive_\n    )\n        FluidDexFeeHandlerHelpers(\n            minFee_,\n            maxFee_,\n            minDeviation_,\n            maxDeviation_,\n            dex_,\n            deployerContract_,\n            reserveContract_,\n            centerPriceActive_\n        )\n    {}\n\n    /// @notice rebalances the fee\n    function rebalance() external onlyRebalancer {\n        uint256 newFee_ = getDexDynamicFee();\n\n        (uint256 currentFee_, uint256 currentRevenueCut_) = getDexFeeAndRevenueCut();\n\n        uint256 feePercentageChange_ = _configPercentDiff(currentFee_, newFee_);\n\n        // should be more than 0.001% to update\n        if (feePercentageChange_ > UPDATE_FEE_TRIGGER_BUFFER) {\n            IFluidDexT1Admin(DEX).updateFeeAndRevenueCut(newFee_, currentRevenueCut_ * FOUR_DECIMALS);\n            emit LogRebalanceFeeAndRevenueCut(DEX, newFee_, currentRevenueCut_ * FOUR_DECIMALS);\n        } else {\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__FeeUpdateNotRequired);\n        }\n    }\n\n    /// @notice returns how much new config would be different from current config in percent (100 = 1%, 1 = 0.01%).\n    function relativeConfigPercentDiff() public view returns (uint256) {\n        return _configPercentDiff(_getDexFee(), getDexDynamicFee());\n    }\n\n    /// @notice returns how much new config would be different from current config.\n    function absoluteConfigDiff() public view returns (uint256) {\n        uint256 newFee_ = getDexDynamicFee();\n        uint256 oldFee_ = _getDexFee();\n\n        return newFee_ > oldFee_ ? newFee_ - oldFee_ : oldFee_ - newFee_;\n    }\n\n    /// @notice returns the new calculated fee\n    function newConfig() public view returns (uint256) {\n        return getDexDynamicFee();\n    }\n\n    /// @notice returns the currently configured fee\n    function currentConfig() public view returns (uint256) {\n        return _getDexFee();\n    }\n}\n"
    },
    "contracts/config/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Error {\n    error FluidConfigError(uint256 errorId_);\n}\n"
    },
    "contracts/config/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |    ExpandPercentConfigHandler     | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant ExpandPercentConfigHandler__AddressZero = 100001;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant ExpandPercentConfigHandler__Unauthorized = 100002;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant ExpandPercentConfigHandler__InvalidParams = 100003;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant ExpandPercentConfigHandler__NoUpdate = 100004;\n\n    /// @notice thrown when slot is not used, e.g. when borrow token is 0 there is no borrow data\n    uint256 internal constant ExpandPercentConfigHandler__SlotDoesNotExist = 100005;\n\n    /***********************************|\n    |      EthenaRateConfigHandler      | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant EthenaRateConfigHandler__AddressZero = 100011;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant EthenaRateConfigHandler__Unauthorized = 100012;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant EthenaRateConfigHandler__InvalidParams = 100013;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant EthenaRateConfigHandler__NoUpdate = 100014;\n\n    /***********************************|\n    |       MaxBorrowConfigHandler      | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant MaxBorrowConfigHandler__AddressZero = 100021;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant MaxBorrowConfigHandler__Unauthorized = 100022;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant MaxBorrowConfigHandler__InvalidParams = 100023;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant MaxBorrowConfigHandler__NoUpdate = 100024;\n\n    /***********************************|\n    |       BufferRateConfigHandler     | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant BufferRateConfigHandler__AddressZero = 100031;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant BufferRateConfigHandler__Unauthorized = 100032;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant BufferRateConfigHandler__InvalidParams = 100033;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant BufferRateConfigHandler__NoUpdate = 100034;\n\n    /// @notice thrown when rate data version is not supported\n    uint256 internal constant BufferRateConfigHandler__RateVersionUnsupported = 100035;\n\n    /***********************************|\n    |          FluidRatesAuth           | \n    |__________________________________*/\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant RatesAuth__NoUpdate = 100041;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant RatesAuth__Unauthorized = 100042;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant RatesAuth__InvalidParams = 100043;\n\n    /// @notice thrown when cooldown is not yet expired\n    uint256 internal constant RatesAuth__CooldownLeft = 100044;\n\n    /// @notice thrown when version is invalid\n    uint256 internal constant RatesAuth__InvalidVersion = 100045;\n\n    /***********************************|\n    |       LiquidityTokenAuth          | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant LiquidityTokenAuth__Unauthorized = 100051;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant LiquidityTokenAuth_AlreadyInitialized = 100052;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant LiquidityTokenAuth__InvalidParams = 100053;\n\n    /***********************************|\n    |       CollectRevenueAuth          | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant CollectRevenueAuth__Unauthorized = 100061;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant CollectRevenueAuth__InvalidParams = 100062;\n\n    /***********************************|\n    |       FluidWithdrawLimitAuth      | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant WithdrawLimitAuth__NoUserSupply = 100071;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant WithdrawLimitAuth__Unauthorized = 100072;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant WithdrawLimitAuth__InvalidParams = 100073;\n\n    /// @notice thrown when no more withdrawal limit can be set for the day\n    uint256 internal constant WithdrawLimitAuth__DailyLimitReached = 100074;\n\n    /// @notice thrown when no more withdrawal limit can be set for the hour\n    uint256 internal constant WithdrawLimitAuth__HourlyLimitReached = 100075;\n\n    /// @notice thrown when the withdrawal limit and userSupply difference exceeds 5%\n    uint256 internal constant WithdrawLimitAuth__ExcessPercentageDifference = 100076;\n\n    /***********************************|\n    |       DexFeeHandler               | \n    |__________________________________*/\n\n    /// @notice thrown when fee update is not required\n    uint256 internal constant DexFeeHandler__FeeUpdateNotRequired = 100081;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant DexFeeHandler__InvalidParams = 100082;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls\n    uint256 internal constant DexFeeHandler__Unauthorized = 100083;\n\n    /***********************************|\n    |           RangeAuthDex            | \n    |__________________________________*/\n\n    uint256 internal constant RangeAuthDex__InvalidParams = 100091;\n    uint256 internal constant RangeAuthDex__CooldownLeft = 100092;\n    uint256 internal constant RangeAuthDex__Unauthorized = 100093;\n    uint256 internal constant RangeAuthDex__ExceedAllowedPercentageChange = 100094;\n    uint256 internal constant RangeAuthDex__InvalidShiftTime = 100095;\n\n    /***********************************|\n    |           FluidLimitsAuth         | \n    |__________________________________*/\n\n    uint256 internal constant LimitsAuth__InvalidParams = 100101;\n    uint256 internal constant LimitsAuth__Unauthorized = 100102;\n    uint256 internal constant LimitsAuth__UserNotDefinedYet = 100103;\n    uint256 internal constant LimitsAuth__ExceedAllowedPercentageChange = 100104;\n    uint256 internal constant LimitsAuth__CoolDownPending = 100105;\n\n    /***********************************|\n    |          DexFeeAuth               | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls\n    uint256 internal constant DexFeeAuth__Unauthorized = 100111;\n\n    /***********************************|\n    |       VaultFeeRewardsAuth         | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls\n    uint256 internal constant VaultFeeRewardsAuth__Unauthorized = 100121;\n    /// @notice thrown when magnifier or rate is being updated for a non matching vault type\n    uint256 internal constant VaultFeeRewardsAuth__InvalidVaultType = 100122;\n}\n"
    },
    "contracts/config/ethenaRateHandler/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Events {\n    /// @notice emitted when borrow magnifier is updated at vault\n    event LogUpdateBorrowRateMagnifier(uint256 oldMagnifier, uint256 newMagnifier);\n}\n"
    },
    "contracts/config/ethenaRateHandler/interfaces/iStakedUSDe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\ninterface IStakedUSDe is IERC4626 {\n    /// @notice The amount of the last asset distribution from the controller contract into this\n    /// contract + any unvested remainder at that time\n    function vestingAmount() external view returns (uint256);\n\n    /// @notice The timestamp of the last asset distribution from the controller contract into this contract\n    function lastDistributionTimestamp() external view returns (uint256);\n\n    /// @notice Returns the amount of USDe tokens that are vested in the contract.\n    function totalAssets() external view returns (uint256);\n}\n"
    },
    "contracts/config/ethenaRateHandler/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { IFluidVaultT1 } from \"../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { FluidVaultT1Admin } from \"../../protocols/vault/vaultT1/adminModule/main.sol\";\nimport { IStakedUSDe } from \"./interfaces/iStakedUSDe.sol\";\nimport { Variables } from \"./variables.sol\";\nimport { Events } from \"./events.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\n/// @notice Sets borrow rate for sUSDe/debtToken vaults based on sUSDe yield rate, by adjusting the borrowRateMagnifier\ncontract FluidEthenaRateConfigHandler is Variables, Error, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.EthenaRateConfigHandler__AddressZero);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract)\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.EthenaRateConfigHandler__Unauthorized);\n        }\n        _;\n    }\n\n    // vault2 is optional, set to address zero if only triggering on one vault. borrow token must be vault1 == vault2!\n    constructor(\n        IFluidReserveContract reserveContract_,\n        IFluidLiquidity liquidity_,\n        IFluidVaultT1 vault_,\n        IFluidVaultT1 vault2_,\n        IStakedUSDe stakedUSDe_,\n        address borrowToken_,\n        uint256 ratePercentMargin_,\n        uint256 maxRewardsDelay_,\n        uint256 utilizationPenaltyStart_,\n        uint256 utilization100PenaltyPercent_\n    )\n        validAddress(address(reserveContract_))\n        validAddress(address(liquidity_))\n        validAddress(address(vault_))\n        validAddress(address(stakedUSDe_))\n        validAddress(borrowToken_)\n    {\n        if (\n            ratePercentMargin_ == 0 ||\n            ratePercentMargin_ >= 1e4 ||\n            maxRewardsDelay_ == 0 ||\n            utilizationPenaltyStart_ >= 1e4 ||\n            utilization100PenaltyPercent_ == 0\n        ) {\n            revert FluidConfigError(ErrorTypes.EthenaRateConfigHandler__InvalidParams);\n        }\n\n        RESERVE_CONTRACT = reserveContract_;\n        LIQUIDITY = liquidity_;\n        SUSDE = stakedUSDe_;\n        VAULT = vault_;\n        VAULT2 = vault2_;\n        BORROW_TOKEN = borrowToken_;\n\n        _LIQUDITY_BORROW_TOKEN_EXCHANGE_PRICES_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            borrowToken_\n        );\n\n        RATE_PERCENT_MARGIN = ratePercentMargin_;\n        MAX_REWARDS_DELAY = maxRewardsDelay_;\n\n        UTILIZATION_PENALTY_START = utilizationPenaltyStart_;\n        UTILIZATION100_PENALTY_PERCENT = utilization100PenaltyPercent_;\n    }\n\n    /// @notice Rebalances the borrow rate magnifier for `VAULT` (and `VAULT2`) based on borrow rate at Liquidity in\n    /// relation to sUSDe yield rate (`getSUSDEYieldRate()`).\n    /// Emits `LogUpdateBorrowRateMagnifier` in case of update. Reverts if no update is needed.\n    /// Can only be called by an authorized rebalancer.\n    function rebalance() external onlyRebalancer {\n        uint256 targetMagnifier_ = calculateMagnifier();\n        uint256 currentMagnifier_ = currentMagnifier();\n\n        // execute update on vault if necessary\n        if (targetMagnifier_ == currentMagnifier_) {\n            revert FluidConfigError(ErrorTypes.EthenaRateConfigHandler__NoUpdate);\n        }\n\n        FluidVaultT1Admin(address(VAULT)).updateBorrowRateMagnifier(targetMagnifier_);\n        if (address(VAULT2) != address(0)) {\n            FluidVaultT1Admin(address(VAULT2)).updateBorrowRateMagnifier(targetMagnifier_);\n        }\n\n        emit LogUpdateBorrowRateMagnifier(currentMagnifier_, targetMagnifier_);\n    }\n\n    /// @notice Calculates the new borrow rate magnifier based on sUSDe yield rate and utilization\n    /// @return magnifier_ the calculated magnifier value.\n    function calculateMagnifier() public view returns (uint256 magnifier_) {\n        uint256 sUSDeYieldRate_ = getSUSDeYieldRate();\n        uint256 exchangePriceAndConfig_ = LIQUIDITY.readFromStorage(_LIQUDITY_BORROW_TOKEN_EXCHANGE_PRICES_SLOT);\n\n        uint256 utilization_ = (exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14;\n\n        // calculate target borrow rate. scaled by 1e18.\n        // borrow rate is based on sUSDeYieldRate_ and a margin that goes to lenders\n        // e.g. when RATE_PERCENT_MARGIN = 1000 (10%), then borrow rate will be 90% of the sUSDe yield rate\n        // e.g. when sUSDe yield is 60%, borrow rate would be 54%\n        uint256 targetBorrowRate_ = (sUSDeYieldRate_ * (1e4 - RATE_PERCENT_MARGIN)) / 1e4;\n\n        if (utilization_ > UTILIZATION_PENALTY_START) {\n            // above UTILIZATION_PENALTY_START (e.g. 90%), penalty should rise linearly according to UTILIZATION100_PENALTY_PERCENT\n            // e.g. from 10% margin at 90% utilization to 10% - penalty margin at 100% utilization\n            // so from +RATE_PERCENT_MARGIN at UTILIZATION_PENALTY_START to +RATE_PERCENT_MARGIN - UTILIZATION100_PENALTY_PERCENT at 100%\n            if (utilization_ < 1e4) {\n                uint256 utilizationAbovePenaltyStart_ = utilization_ - UTILIZATION_PENALTY_START; // e.g. 95 - 90 = 5%\n                uint256 penaltyUtilizationDiff_ = 1e4 - UTILIZATION_PENALTY_START; // e.g. 100 - 90 = 10%\n\n                // e.g. when current utilization = 96%, start penalty utilization = 90%, penalty at 100 = 12%, rate margin = 15%:\n                // utilizationAbovePenaltyStart_ = 600 (6%)\n                // penaltyUtilizationDiff_ = 1000 (10%)\n                // UTILIZATION100_PENALTY_PERCENT = 1200 (12%)\n                // marginAfterPenalty_ = 1200 * 600 / 1000 = 720 (7.2%)\n                uint256 marginAfterPenalty_ = (UTILIZATION100_PENALTY_PERCENT * utilizationAbovePenaltyStart_) /\n                    penaltyUtilizationDiff_;\n\n                // for above example, when sUSDe yield is 60%, borrow rate would become 57.89% (from 60% * (90% + 7.2%) / 100% )\n                targetBorrowRate_ = (sUSDeYieldRate_ * ((1e4 - RATE_PERCENT_MARGIN) + marginAfterPenalty_)) / 1e4;\n            } else {\n                // above 100% utilization, cap at RATE_PERCENT_MARGIN - UTILIZATION100_PENALTY_PERCENT penalty\n                targetBorrowRate_ =\n                    (sUSDeYieldRate_ * (1e4 - RATE_PERCENT_MARGIN + UTILIZATION100_PENALTY_PERCENT)) /\n                    1e4;\n            }\n        }\n\n        // get current neutral borrow rate at Liquidity (without any magnifier).\n        // exchangePriceAndConfig slot at Liquidity, first 16 bits\n        uint256 liquidityBorrowRate_ = exchangePriceAndConfig_ & X16;\n\n        if (liquidityBorrowRate_ == 0) {\n            return 1e4;\n        }\n\n        // calculate magnifier needed to reach target borrow rate.\n        // liquidityBorrowRate_ * x = targetBorrowRate_. so x = targetBorrowRate_ / liquidityBorrowRate_.\n        // must scale liquidityBorrowRate_ from 1e2 to 1e18 as targetBorrowRate_ is in 1e18. magnifier itself is scaled\n        // by 1e4 (1x = 10000)\n        magnifier_ = (1e4 * targetBorrowRate_) / (liquidityBorrowRate_ * 1e16);\n\n        // make sure magnifier is within allowed limits\n        if (magnifier_ < _MIN_MAGNIFIER) {\n            return _MIN_MAGNIFIER;\n        }\n        if (magnifier_ > _MAX_MAGNIFIER) {\n            return _MAX_MAGNIFIER;\n        }\n    }\n\n    /// @notice returns the currently configured borrow magnifier at the `VAULT` (and `VAULT2`).\n    function currentMagnifier() public view returns (uint256) {\n        // read borrow rate magnifier from Vault `vaultVariables2` located in storage slot 1, 16 bits from 16-31\n        return (VAULT.readFromStorage(bytes32(uint256(1))) >> 16) & X16;\n    }\n\n    /// @notice calculates updated vesting yield rate based on `vestingAmount` and `totalAssets` of StakedUSDe contract\n    /// @return rate_ sUSDe yearly yield rate scaled by 1e18 (1e18 = 1%, 1e20 = 100%)\n    function getSUSDeYieldRate() public view returns (uint256 rate_) {\n        if (block.timestamp > SUSDE.lastDistributionTimestamp() + _SUSDE_VESTING_PERIOD + MAX_REWARDS_DELAY) {\n            // if rewards update on StakedUSDe contract is delayed by more than `MAX_REWARDS_DELAY`, we use rate as 0\n            // as we can't know if e.g. funding would have gone negative and there are indeed no rewards.\n            return 0;\n        }\n\n        // vestingAmount is yield per 8 hours (`SUSDE_VESTING_PERIOD`)\n        rate_ = (SUSDE.vestingAmount() * 1e20) / SUSDE.totalAssets(); // 8 hours rate\n        // turn into yearly yield\n        rate_ = (rate_ * 365 * 24 hours) / _SUSDE_VESTING_PERIOD; // 365 days * 24 hours / 8 hours -> rate_ * 1095\n    }\n}\n"
    },
    "contracts/config/ethenaRateHandler/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { IFluidVaultT1 } from \"../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { IStakedUSDe } from \"./interfaces/iStakedUSDe.sol\";\n\nabstract contract Constants {\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n    IFluidLiquidity public immutable LIQUIDITY;\n    IFluidVaultT1 public immutable VAULT;\n    IFluidVaultT1 public immutable VAULT2;\n    IStakedUSDe public immutable SUSDE;\n    address public immutable BORROW_TOKEN;\n\n    /// @notice sUSDe vesting yield reward rate percent margin that goes to lenders\n    /// e.g. RATE_PERCENT_MARGIN = 10% then borrow rate for debt token ends up as 90% of the sUSDe yield.\n    /// (in 1e2: 100% = 10_000; 1% = 100)\n    uint256 public immutable RATE_PERCENT_MARGIN;\n\n    /// @notice max delay in seconds for rewards update after vesting period ended, after which we assume rate is 0.\n    /// e.g. 15 min\n    uint256 public immutable MAX_REWARDS_DELAY;\n\n    /// @notice utilization penalty start point (in 1e2: 100% = 10_000; 1% = 100). above this, a penalty percent\n    ///         is applied, to incentivize deleveraging.\n    uint256 public immutable UTILIZATION_PENALTY_START;\n    /// @notice penalty percent target at 100%, on top of sUSDe yield rate if utilization is above UTILIZATION_PENALTY_START\n    ///         (in 1e2: 100% = 10_000; 1% = 100)\n    uint256 public immutable UTILIZATION100_PENALTY_PERCENT;\n\n    bytes32 internal immutable _LIQUDITY_BORROW_TOKEN_EXCHANGE_PRICES_SLOT;\n\n    /// @dev vesting period defined as private constant on StakedUSDe contract\n    uint256 internal constant _SUSDE_VESTING_PERIOD = 8 hours;\n\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant _MIN_MAGNIFIER = 1e4; // min magnifier is always at least 1x (10000)\n    uint256 internal constant _MAX_MAGNIFIER = 65535; // max magnifier to fit in storage slot is 65535 (16 bits)\n}\n\nabstract contract Variables is Constants {}\n"
    },
    "contracts/config/expandPercentHandler/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { Structs as AdminModuleStructs } from \"../../liquidity/adminModule/structs.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nabstract contract Constants {\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n    IFluidLiquidity public immutable LIQUIDITY;\n    address public immutable PROTOCOL;\n    address public immutable WITHDRAW_TOKEN;\n    address public immutable BORROW_TOKEN;\n\n    uint256 public immutable BORROW_CHECKPOINT1;\n    uint256 public immutable BORROW_CHECKPOINT2;\n    uint256 public immutable BORROW_CHECKPOINT3;\n    uint256 public immutable BORROW_EXPAND_UNTIL_CHECKPOINT1;\n    uint256 public immutable BORROW_EXPAND_UNTIL_CHECKPOINT2;\n    uint256 public immutable BORROW_EXPAND_UNTIL_CHECKPOINT3;\n    uint256 public immutable BORROW_EXPAND_ABOVE_CHECKPOINT3;\n\n    uint256 public immutable WITHDRAW_CHECKPOINT1;\n    uint256 public immutable WITHDRAW_CHECKPOINT2;\n    uint256 public immutable WITHDRAW_CHECKPOINT3;\n    uint256 public immutable WITHDRAW_EXPAND_UNTIL_CHECKPOINT1;\n    uint256 public immutable WITHDRAW_EXPAND_UNTIL_CHECKPOINT2;\n    uint256 public immutable WITHDRAW_EXPAND_UNTIL_CHECKPOINT3;\n    uint256 public immutable WITHDRAW_EXPAND_ABOVE_CHECKPOINT3;\n\n    bytes32 internal immutable _LIQUDITY_WITHDRAW_TOKEN_EXCHANGE_PRICES_SLOT;\n    bytes32 internal immutable _LIQUDITY_BORROW_TOKEN_EXCHANGE_PRICES_SLOT;\n\n    bytes32 internal immutable _LIQUDITY_PROTOCOL_SUPPLY_SLOT;\n    bytes32 internal immutable _LIQUDITY_PROTOCOL_BORROW_SLOT;\n\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xff;\n\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n}\n\nabstract contract Events {\n    /// @notice emitted when withdraw limit expand percent is updated\n    event LogUpdateWithdrawLimitExpansion(uint256 supply, uint256 oldExpandPercent, uint256 newExpandPercent);\n\n    /// @notice emitted when borrow limit expand percent is updated\n    event LogUpdateBorrowLimitExpansion(uint256 borrow, uint256 oldExpandPercent, uint256 newExpandPercent);\n}\n\nabstract contract Structs {\n    struct LimitCheckPoints {\n        uint256 tvlCheckPoint1; // e.g. 20M\n        uint256 expandPercentUntilCheckPoint1; // e.g. 25%\n        uint256 tvlCheckPoint2; // e.g. 30M\n        uint256 expandPercentUntilCheckPoint2; // e.g. 20%\n        uint256 tvlCheckPoint3; // e.g. 40M\n        uint256 expandPercentUntilCheckPoint3; // e.g. 15%\n        uint256 expandPercentAboveCheckPoint3; // e.g. 10%\n    }\n}\n\n/// @notice Sets limits on Liquidity for a protocol based on TVL checkpoints.\ncontract FluidExpandPercentConfigHandler is Constants, Error, Events, Structs {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.ExpandPercentConfigHandler__AddressZero);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract)\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.ExpandPercentConfigHandler__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(\n        IFluidReserveContract reserveContract_,\n        IFluidLiquidity liquidity_,\n        address protocol_,\n        address withdrawToken_, // can be unused in some cases (e.g. StETH)\n        address borrowToken_, // can be unused in some cases (e.g. Lending)\n        LimitCheckPoints memory withdrawCheckPoints_, // can be skipped if withdrawToken is not set.\n        LimitCheckPoints memory borrowCheckPoints_ // can be skipped if borrowToken_ is not set.\n    ) validAddress(address(reserveContract_)) validAddress(address(liquidity_)) validAddress(protocol_) {\n        RESERVE_CONTRACT = reserveContract_;\n        LIQUIDITY = liquidity_;\n        PROTOCOL = protocol_;\n        WITHDRAW_TOKEN = withdrawToken_;\n        BORROW_TOKEN = borrowToken_;\n\n        // set withdraw limit values\n        if (withdrawToken_ == address(0)) {\n            if (borrowToken_ == address(0)) {\n                revert FluidConfigError(ErrorTypes.ExpandPercentConfigHandler__InvalidParams);\n            }\n\n            _LIQUDITY_PROTOCOL_SUPPLY_SLOT = bytes32(0);\n        } else {\n            _LIQUDITY_PROTOCOL_SUPPLY_SLOT = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n                protocol_,\n                withdrawToken_\n            );\n            _LIQUDITY_WITHDRAW_TOKEN_EXCHANGE_PRICES_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n                withdrawToken_\n            );\n\n            _validateLimitCheckPoints(withdrawCheckPoints_);\n\n            WITHDRAW_CHECKPOINT1 = withdrawCheckPoints_.tvlCheckPoint1;\n            WITHDRAW_CHECKPOINT2 = withdrawCheckPoints_.tvlCheckPoint2;\n            WITHDRAW_CHECKPOINT3 = withdrawCheckPoints_.tvlCheckPoint3;\n            WITHDRAW_EXPAND_UNTIL_CHECKPOINT1 = withdrawCheckPoints_.expandPercentUntilCheckPoint1;\n            WITHDRAW_EXPAND_UNTIL_CHECKPOINT2 = withdrawCheckPoints_.expandPercentUntilCheckPoint2;\n            WITHDRAW_EXPAND_UNTIL_CHECKPOINT3 = withdrawCheckPoints_.expandPercentUntilCheckPoint3;\n            WITHDRAW_EXPAND_ABOVE_CHECKPOINT3 = withdrawCheckPoints_.expandPercentAboveCheckPoint3;\n        }\n\n        // set borrow limit values\n        if (borrowToken_ == address(0)) {\n            _LIQUDITY_PROTOCOL_BORROW_SLOT = bytes32(0);\n        } else {\n            _validateLimitCheckPoints(borrowCheckPoints_);\n\n            _LIQUDITY_PROTOCOL_BORROW_SLOT = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n                protocol_,\n                borrowToken_\n            );\n            _LIQUDITY_BORROW_TOKEN_EXCHANGE_PRICES_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n                borrowToken_\n            );\n\n            BORROW_CHECKPOINT1 = borrowCheckPoints_.tvlCheckPoint1;\n            BORROW_CHECKPOINT2 = borrowCheckPoints_.tvlCheckPoint2;\n            BORROW_CHECKPOINT3 = borrowCheckPoints_.tvlCheckPoint3;\n            BORROW_EXPAND_UNTIL_CHECKPOINT1 = borrowCheckPoints_.expandPercentUntilCheckPoint1;\n            BORROW_EXPAND_UNTIL_CHECKPOINT2 = borrowCheckPoints_.expandPercentUntilCheckPoint2;\n            BORROW_EXPAND_UNTIL_CHECKPOINT3 = borrowCheckPoints_.expandPercentUntilCheckPoint3;\n            BORROW_EXPAND_ABOVE_CHECKPOINT3 = borrowCheckPoints_.expandPercentAboveCheckPoint3;\n        }\n    }\n\n    /// @notice returns `PROTOCOL` total supply at Liquidity\n    function getProtocolSupplyData()\n        public\n        view\n        returns (uint256 supply_, uint256 oldExpandPercent_, uint256 userSupplyData_)\n    {\n        if (_LIQUDITY_PROTOCOL_SUPPLY_SLOT == bytes32(0)) {\n            revert FluidConfigError(ErrorTypes.ExpandPercentConfigHandler__SlotDoesNotExist);\n        }\n        userSupplyData_ = LIQUIDITY.readFromStorage(_LIQUDITY_PROTOCOL_SUPPLY_SLOT); // total storage slot\n\n        oldExpandPercent_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n\n        // get supply in raw converted from BigNumber\n        supply_ = BigMathMinified.fromBigNumber(\n            (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64,\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        );\n\n        if (userSupplyData_ & 1 == 1) {\n            uint256 exchangePrice_ = ((LIQUIDITY.readFromStorage(_LIQUDITY_WITHDRAW_TOKEN_EXCHANGE_PRICES_SLOT) >>\n                LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) & X64);\n\n            supply_ = (supply_ * exchangePrice_) / 1e12; // convert raw to normal amount\n        }\n    }\n\n    /// @notice returns `PROTOCOL` total borrow at Liquidity\n    function getProtocolBorrowData()\n        public\n        view\n        returns (uint256 borrow_, uint256 oldExpandPercent_, uint256 userBorrowData_)\n    {\n        if (_LIQUDITY_PROTOCOL_BORROW_SLOT == bytes32(0)) {\n            revert FluidConfigError(ErrorTypes.ExpandPercentConfigHandler__SlotDoesNotExist);\n        }\n        userBorrowData_ = LIQUIDITY.readFromStorage(_LIQUDITY_PROTOCOL_BORROW_SLOT); // total storage slot\n\n        oldExpandPercent_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        // get borrow in raw converted from BigNumber\n        borrow_ = BigMathMinified.fromBigNumber(\n            (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64,\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        );\n\n        if (userBorrowData_ & 1 == 1) {\n            uint256 exchangePrice_ = ((LIQUIDITY.readFromStorage(_LIQUDITY_BORROW_TOKEN_EXCHANGE_PRICES_SLOT) >>\n                LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) & X64);\n\n            borrow_ = (borrow_ * exchangePrice_) / 1e12; // convert raw to normal amount\n        }\n    }\n\n    /// @notice Rebalances the configs for `PROTOCOL` at Fluid Liquidity based on protocol total supply & total borrow.\n    /// Emits `LogUpdateWithdrawLimitExpansion` or `LogUpdateBorrowLimitExpansion` if any update is executed.\n    /// Reverts if no update is needed.\n    /// Can only be called by an authorized rebalancer.\n    function rebalance() external onlyRebalancer {\n        bool anyUpdateDone_;\n        if (WITHDRAW_TOKEN != address(0)) {\n            // check update withdrawal limits based on protocol supply\n            anyUpdateDone_ = _updateWithdrawLimits();\n        }\n\n        if (BORROW_TOKEN != address(0)) {\n            // check update borrow limits based on protocol borrow\n            anyUpdateDone_ = _updateBorrowLimits() || anyUpdateDone_;\n        }\n\n        if (!anyUpdateDone_) {\n            revert FluidConfigError(ErrorTypes.ExpandPercentConfigHandler__NoUpdate);\n        }\n    }\n\n    /***********************************|\n    |            INTERNALS              | \n    |__________________________________*/\n\n    function _updateWithdrawLimits() internal returns (bool updated_) {\n        (uint256 supply_, uint256 oldExpandPercent_, uint256 userSupplyData_) = getProtocolSupplyData();\n\n        // get current expand percent for supply_\n        uint256 newExpandPercent_;\n        if (supply_ < WITHDRAW_CHECKPOINT1) {\n            newExpandPercent_ = WITHDRAW_EXPAND_UNTIL_CHECKPOINT1;\n        } else if (supply_ < WITHDRAW_CHECKPOINT2) {\n            newExpandPercent_ = WITHDRAW_EXPAND_UNTIL_CHECKPOINT2;\n        } else if (supply_ < WITHDRAW_CHECKPOINT3) {\n            newExpandPercent_ = WITHDRAW_EXPAND_UNTIL_CHECKPOINT3;\n        } else {\n            newExpandPercent_ = WITHDRAW_EXPAND_ABOVE_CHECKPOINT3;\n        }\n\n        // check if not already set to that value\n        if (oldExpandPercent_ == newExpandPercent_) {\n            return false;\n        }\n\n        // execute update at Liquidity\n        AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_ = new AdminModuleStructs.UserSupplyConfig[](1);\n        userSupplyConfigs_[0] = AdminModuleStructs.UserSupplyConfig({\n            user: PROTOCOL,\n            token: WITHDRAW_TOKEN,\n            mode: uint8(userSupplyData_ & 1), // first bit\n            expandPercent: newExpandPercent_,\n            expandDuration: (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24, // set same as old\n            baseWithdrawalLimit: BigMathMinified.fromBigNumber(\n                (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            ) // set same as old\n        });\n        LIQUIDITY.updateUserSupplyConfigs(userSupplyConfigs_);\n\n        emit LogUpdateWithdrawLimitExpansion(supply_, oldExpandPercent_, newExpandPercent_);\n\n        return true;\n    }\n\n    function _updateBorrowLimits() internal returns (bool updated_) {\n        (uint256 borrow_, uint256 oldExpandPercent_, uint256 userBorrowData_) = getProtocolBorrowData();\n\n        // get current expand percent for borrow_\n        uint256 newExpandPercent_;\n        if (borrow_ < BORROW_CHECKPOINT1) {\n            newExpandPercent_ = BORROW_EXPAND_UNTIL_CHECKPOINT1;\n        } else if (borrow_ < BORROW_CHECKPOINT2) {\n            newExpandPercent_ = BORROW_EXPAND_UNTIL_CHECKPOINT2;\n        } else if (borrow_ < BORROW_CHECKPOINT3) {\n            newExpandPercent_ = BORROW_EXPAND_UNTIL_CHECKPOINT3;\n        } else {\n            newExpandPercent_ = BORROW_EXPAND_ABOVE_CHECKPOINT3;\n        }\n\n        // check if not already set to that value\n        if (oldExpandPercent_ == newExpandPercent_) {\n            return false;\n        }\n\n        // execute update at Liquidity\n        AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_ = new AdminModuleStructs.UserBorrowConfig[](1);\n        userBorrowConfigs_[0] = AdminModuleStructs.UserBorrowConfig({\n            user: PROTOCOL,\n            token: BORROW_TOKEN,\n            mode: uint8(userBorrowData_ & 1), // first bit\n            expandPercent: newExpandPercent_,\n            expandDuration: (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24, // set same as old\n            baseDebtCeiling: BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            ), // set same as old\n            maxDebtCeiling: BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            ) // set same as old\n        });\n        LIQUIDITY.updateUserBorrowConfigs(userBorrowConfigs_);\n\n        emit LogUpdateBorrowLimitExpansion(borrow_, oldExpandPercent_, newExpandPercent_);\n\n        return true;\n    }\n\n    function _validateLimitCheckPoints(LimitCheckPoints memory checkPoints_) internal pure {\n        if (\n            checkPoints_.tvlCheckPoint1 == 0 ||\n            checkPoints_.expandPercentUntilCheckPoint1 == 0 ||\n            checkPoints_.tvlCheckPoint2 == 0 ||\n            checkPoints_.expandPercentUntilCheckPoint2 == 0 ||\n            checkPoints_.tvlCheckPoint3 == 0 ||\n            checkPoints_.expandPercentUntilCheckPoint3 == 0 ||\n            checkPoints_.expandPercentAboveCheckPoint3 == 0\n        ) {\n            revert FluidConfigError(ErrorTypes.ExpandPercentConfigHandler__InvalidParams);\n        }\n    }\n}\n"
    },
    "contracts/config/limitsAuth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { Structs as AdminModuleStructs } from \"../../liquidity/adminModule/structs.sol\";\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\n\nabstract contract Events {\n    /// @notice emitted when multisig successfully changes the withdrawal limit\n    event LogSetWithdrawalLimit(address user, address token, uint256 newLimit);\n\n    /// @notice emitted when multisig changes the withdrawal limit config\n    event LogSetUserWithdrawLimit(address user, address token, uint256 baseLimit);\n\n    /// @notice emitted when multisig changes the borrow limit config\n    event LogSetUserBorrowLimits(address user, address token, uint256 baseLimit, uint256 maxLimit);\n}\n\nabstract contract Constants {\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    /// @dev This represents 20%.\n    uint256 internal constant MAX_PERCENT_CHANGE = 20;\n\n    IFluidLiquidity public immutable LIQUIDITY;\n    /// @notice Team multisigs allowed to trigger methods\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n    address public constant TEAM_MULTISIG2 = 0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\n\n    uint256 internal constant COOLDOWN_PERIOD = 4 days;\n}\n\nabstract contract Variables is Constants {\n    // user => token => lastUpdateTime for cooldown checks\n    mapping(address => mapping(address => uint256)) public lastUpdateTime;\n}\n\ncontract FluidLimitsAuth is Variables, Events, Error {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__InvalidParams);\n        }\n        _;\n    }\n\n    modifier onlyMultisig() {\n        if (TEAM_MULTISIG != msg.sender && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(address liquidity_) validAddress(liquidity_) {\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n    }\n\n    /// @notice Sets the withdrawal limit for a specific token of a user in the liquidity\n    /// @dev This function can only be called by team multisig\n    /// @param user_ The address of the user for which to set the withdrawal limit\n    /// @param token_ The address of the token for which to set the withdrawal limit\n    /// @param newLimit_ The new withdrawal limit to be set\n    function setWithdrawalLimit(address user_, address token_, uint256 newLimit_) external onlyMultisig {\n        LIQUIDITY.updateUserWithdrawalLimit(user_, token_, newLimit_);\n        emit LogSetWithdrawalLimit(user_, token_, newLimit_);\n    }\n\n    /// @notice sets withdraw base limit without restrictions. Can only be called by team multisig.\n    /// @param user_ The address of the user for which to set the user withdraw limit\n    /// @param token_ The address of the token for which to set the user withdraw limit\n    /// @param baseLimit_ The base limit for the user supply. Set to 0 to keep current value.\n    /// @param skipMaxPercentChangeCheck_ allow full range of limit check. Keep to false by default to have additional human error check.\n    function setUserWithdrawLimit(\n        address user_,\n        address token_,\n        uint256 baseLimit_,\n        bool skipMaxPercentChangeCheck_\n    ) external onlyMultisig {\n        if (baseLimit_ == 0) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__InvalidParams);\n        }\n\n        AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs = new AdminModuleStructs.UserSupplyConfig[](1);\n        userSupplyConfigs[0] = getUserSupplyConfig(user_, token_);\n\n        if (userSupplyConfigs[0].user == address(0)) {\n            // user is not defined yet\n            revert FluidConfigError(ErrorTypes.LimitsAuth__UserNotDefinedYet);\n        }\n\n        if (!skipMaxPercentChangeCheck_) {\n            _validateWithinMaxPercentChange(userSupplyConfigs[0].baseWithdrawalLimit, baseLimit_);\n        }\n\n        userSupplyConfigs[0].baseWithdrawalLimit = baseLimit_;\n\n        LIQUIDITY.updateUserSupplyConfigs(userSupplyConfigs);\n\n        emit LogSetUserWithdrawLimit(user_, token_, userSupplyConfigs[0].baseWithdrawalLimit);\n    }\n\n    /// @notice Sets the user borrow limits for a specific token of a user, with time and max percent change restrictions.\n    ///         Can only be called by team multisig.\n    /// @dev This function can only be called by team multisig\n    /// @param user_ The address of the user for which to set the user borrow limit\n    /// @param token_ The address of the token for which to set the user borrow limit\n    /// @param baseLimit_ The base limit for the user borrow. Set to 0 to keep current value.\n    /// @param maxLimit_ The max limit for the user borrow. Set to 0 to keep current value.\n    function setUserBorrowLimits(\n        address user_,\n        address token_,\n        uint256 baseLimit_,\n        uint256 maxLimit_\n    ) external onlyMultisig {\n        if (baseLimit_ == 0 && maxLimit_ == 0) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__InvalidParams);\n        }\n\n        AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs = new AdminModuleStructs.UserBorrowConfig[](1);\n        userBorrowConfigs[0] = getUserBorrowConfig(user_, token_);\n\n        if (userBorrowConfigs[0].user == address(0)) {\n            // user is not defined yet\n            revert FluidConfigError(ErrorTypes.LimitsAuth__UserNotDefinedYet);\n        }\n\n        _validateLastUpdateTime(lastUpdateTime[user_][token_]);\n\n        if (baseLimit_ != 0) {\n            _validateWithinMaxPercentChange(userBorrowConfigs[0].baseDebtCeiling, baseLimit_);\n            userBorrowConfigs[0].baseDebtCeiling = baseLimit_;\n        }\n\n        if (maxLimit_ != 0) {\n            _validateWithinMaxPercentChange(userBorrowConfigs[0].maxDebtCeiling, maxLimit_);\n            userBorrowConfigs[0].maxDebtCeiling = maxLimit_;\n        }\n\n        lastUpdateTime[user_][token_] = block.timestamp;\n\n        LIQUIDITY.updateUserBorrowConfigs(userBorrowConfigs);\n\n        emit LogSetUserBorrowLimits(\n            user_,\n            token_,\n            userBorrowConfigs[0].baseDebtCeiling,\n            userBorrowConfigs[0].maxDebtCeiling\n        );\n    }\n\n    /// @notice Returns the user supply config for a given user and token.\n    function getUserSupplyConfig(\n        address user_,\n        address token_\n    ) public view returns (AdminModuleStructs.UserSupplyConfig memory userSupplyConfigs_) {\n        uint256 userSupply_ = LIQUIDITY.readFromStorage(\n            LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n                user_,\n                token_\n            )\n        );\n\n        if (userSupply_ > 0) {\n            userSupplyConfigs_ = AdminModuleStructs.UserSupplyConfig({\n                user: user_,\n                token: token_,\n                mode: uint8(userSupply_ & 1),\n                baseWithdrawalLimit: BigMathMinified.fromBigNumber(\n                    (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18,\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                ),\n                expandPercent: (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14,\n                expandDuration: (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24\n            });\n        }\n    }\n\n    /// @notice Returns the user borrow config for a given user and token.\n    function getUserBorrowConfig(\n        address user_,\n        address token_\n    ) public view returns (AdminModuleStructs.UserBorrowConfig memory userBorrowConfigs_) {\n        uint256 userBorrow_ = LIQUIDITY.readFromStorage(\n            LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n                user_,\n                token_\n            )\n        );\n\n        if (userBorrow_ > 0) {\n            userBorrowConfigs_ = AdminModuleStructs.UserBorrowConfig({\n                user: user_,\n                token: token_,\n                mode: uint8(userBorrow_ & 1),\n                baseDebtCeiling: BigMathMinified.fromBigNumber(\n                    (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18,\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                ),\n                maxDebtCeiling: BigMathMinified.fromBigNumber(\n                    (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18,\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                ),\n                expandPercent: (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14,\n                expandDuration: (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24\n            });\n        }\n    }\n\n    /// @dev Validates that the new limit is within the allowed max percent change.\n    function _validateWithinMaxPercentChange(uint256 oldLimit_, uint256 newLimit_) internal pure {\n        uint256 maxDelta = (oldLimit_ * MAX_PERCENT_CHANGE) / 100; // 20% of oldLimit_\n\n        if (newLimit_ > oldLimit_ && (newLimit_ - oldLimit_) > maxDelta) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__ExceedAllowedPercentageChange);\n        } else if (newLimit_ < oldLimit_ && (oldLimit_ - newLimit_) > maxDelta) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__ExceedAllowedPercentageChange);\n        }\n    }\n\n    /// @dev Validates that the cooldown period has passed since the last update.\n    function _validateLastUpdateTime(uint256 lastUpdateTime_) internal view {\n        if (block.timestamp - lastUpdateTime_ < COOLDOWN_PERIOD) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__CoolDownPending);\n        }\n    }\n}\n"
    },
    "contracts/config/limitsAuthDex/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { DexSlotsLink } from \"../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../libraries/dexCalcs.sol\";\nimport { IFluidDexT1 } from \"../../protocols/dex/interfaces/iDexT1.sol\";\nimport { Structs as AdminModuleStructs } from \"../../protocols/dex/poolT1/adminModule/structs.sol\";\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\ninterface IFluidDexT1Admin {\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\n\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\n\n    function updateMaxBorrowShares(uint maxBorrowShares_) external;\n\n    function updateMaxSupplyShares(uint maxSupplyShares_) external;\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, uint256 newLimit_) external;\n}\n\nabstract contract Events {\n    /// @notice emitted when multisig successfully changes the withdrawal limit\n    event LogSetWithdrawalLimit(address dex, address user, uint256 newLimit);\n\n    /// @notice emitted when multisig changes the withdrawal limit config\n    event LogSetUserWithdrawLimit(address dex, address user, uint256 baseLimit);\n\n    /// @notice emitted when multisig changes the borrow limit config\n    event LogSetUserBorrowLimits(address dex, address user, uint256 baseLimit, uint256 maxLimit);\n\n    /// @notice emitted when multisig changes the max borrow shares\n    event LogSetMaxBorrowShares(address dex, uint256 maxBorrowShares);\n\n    /// @notice emitted when multisig changes the max supply shares\n    event LogSetMaxSupplyShares(address dex, uint256 maxSupplyShares);\n}\n\nabstract contract Constants {\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    /// @dev Set this to 20 for a +/-20% limit\n    uint256 internal constant MAX_PERCENT_CHANGE = 20;\n\n    /// @notice Team multisigs allowed to trigger methods\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n    address public constant TEAM_MULTISIG2 = 0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\n\n    uint256 internal constant COOLDOWN_PERIOD = 4 days;\n}\n\nabstract contract Variables is Constants {\n    // dex => user => lastUpdateTime for cooldown checks\n    mapping(address => mapping(address => uint256)) public lastUpdateTime;\n}\n\ncontract FluidLimitsAuthDex is Variables, Error, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__InvalidParams);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is the team multisig\n    modifier onlyMultisig() {\n        if (TEAM_MULTISIG != msg.sender && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__Unauthorized);\n        }\n        _;\n    }\n\n    /// @notice Sets the withdrawal limit for a specific user at a dex\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex\n    /// @param user_ The address of the user for which to set the withdrawal limit\n    /// @param newLimit_ The new withdrawal limit to be set\n    function setWithdrawalLimit(address dex_, address user_, uint256 newLimit_) external onlyMultisig {\n        IFluidDexT1Admin(dex_).updateUserWithdrawalLimit(user_, newLimit_);\n        emit LogSetWithdrawalLimit(dex_, user_, newLimit_);\n    }\n\n    /// @notice Sets the user withdraw base limit at a specific dex for a user (vault) without restrictions. Can only be called by team multisig.\n    /// @param dex_ The address of the dex at which to set the user withdraw limit\n    /// @param user_ The address of the user for which to set the user withdraw limit\n    /// @param baseLimit_ The base limit for the user supply. Set to 0 to keep current value.\n    /// @param skipMaxPercentChangeCheck_ allow full range of limit check. Keep to false by default to have additional human error check.\n    function setUserWithdrawLimit(\n        address dex_,\n        address user_,\n        uint256 baseLimit_,\n        bool skipMaxPercentChangeCheck_\n    ) external onlyMultisig {\n        if (baseLimit_ == 0) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__InvalidParams);\n        }\n\n        AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs = new AdminModuleStructs.UserSupplyConfig[](1);\n        userSupplyConfigs[0] = getUserSupplyConfig(dex_, user_);\n\n        if (userSupplyConfigs[0].user == address(0)) {\n            // user is not defined yet\n            revert FluidConfigError(ErrorTypes.LimitsAuth__UserNotDefinedYet);\n        }\n\n        if (!skipMaxPercentChangeCheck_) {\n            _validateWithinMaxPercentChange(userSupplyConfigs[0].baseWithdrawalLimit, baseLimit_);\n        }\n\n        userSupplyConfigs[0].baseWithdrawalLimit = baseLimit_;\n\n        IFluidDexT1Admin(dex_).updateUserSupplyConfigs(userSupplyConfigs);\n\n        emit LogSetUserWithdrawLimit(dex_, user_, userSupplyConfigs[0].baseWithdrawalLimit);\n    }\n\n    /// @notice Sets the user borrow limits at a specific dex for a user (vault), with time and max percent change restrictions.\n    ///         Can only be called by team multisig.\n    /// @param dex_ The address of the dex at which to set the user borrow limit\n    /// @param user_ The address of the user for which to set the user borrow limit\n    /// @param baseLimit_ The base limit for the user borrow. Set to 0 to keep current value.\n    /// @param maxLimit_ The max limit for the user borrow. Set to 0 to keep current value.\n    function setUserBorrowLimits(\n        address dex_,\n        address user_,\n        uint256 baseLimit_,\n        uint256 maxLimit_\n    ) external onlyMultisig {\n        if (baseLimit_ == 0 && maxLimit_ == 0) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__InvalidParams);\n        }\n\n        AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs = new AdminModuleStructs.UserBorrowConfig[](1);\n        userBorrowConfigs[0] = getUserBorrowConfig(dex_, user_);\n\n        if (userBorrowConfigs[0].user == address(0)) {\n            // user is not defined yet\n            revert FluidConfigError(ErrorTypes.LimitsAuth__UserNotDefinedYet);\n        }\n\n        _validateLastUpdateTime(lastUpdateTime[dex_][user_]);\n\n        if (baseLimit_ != 0) {\n            _validateWithinMaxPercentChange(userBorrowConfigs[0].baseDebtCeiling, baseLimit_);\n            userBorrowConfigs[0].baseDebtCeiling = baseLimit_;\n        }\n\n        if (maxLimit_ != 0) {\n            _validateWithinMaxPercentChange(userBorrowConfigs[0].maxDebtCeiling, maxLimit_);\n            userBorrowConfigs[0].maxDebtCeiling = maxLimit_;\n        }\n\n        lastUpdateTime[dex_][user_] = block.timestamp;\n\n        IFluidDexT1Admin(dex_).updateUserBorrowConfigs(userBorrowConfigs);\n\n        emit LogSetUserBorrowLimits(\n            dex_,\n            user_,\n            userBorrowConfigs[0].baseDebtCeiling,\n            userBorrowConfigs[0].maxDebtCeiling\n        );\n    }\n\n    /// @notice Sets the max borrow shares of a DEX. To update max supply and max borrow shares at once within same coolDown, use setMaxShares.\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex at which to set the max borrow shares\n    /// @param maxBorrowShares_ The max borrow shares.\n    /// @param confirmLiquidityLimitsCoverCap_  Reminder to manually confirm that the limits for the dex at liquidity layer cover the cap.\n    function setMaxBorrowShares(\n        address dex_,\n        uint256 maxBorrowShares_,\n        bool confirmLiquidityLimitsCoverCap_\n    ) external onlyMultisig {\n        _validateSetDexShares(dex_, confirmLiquidityLimitsCoverCap_);\n        _setMaxBorrowShares(dex_, maxBorrowShares_);\n    }\n\n    /// @notice Sets the max supply shares of a DEX. To update max supply and max borrow shares at once within same coolDown, use setMaxShares.\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex at which to set the max supply shares\n    /// @param maxSupplyShares_ The max supply shares.\n    /// @param confirmLiquidityLimitsCoverCap_  Reminder to manually confirm that the limits for the dex at liquidity layer cover the cap.\n    function setMaxSupplyShares(\n        address dex_,\n        uint256 maxSupplyShares_,\n        bool confirmLiquidityLimitsCoverCap_\n    ) external onlyMultisig {\n        _validateSetDexShares(dex_, confirmLiquidityLimitsCoverCap_);\n        _setMaxSupplyShares(dex_, maxSupplyShares_);\n    }\n\n    /// @notice Sets both max borrow shares and max supply shares of a DEX at once.\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex at which to set the max shares\n    /// @param maxSupplyShares_ The max supply shares.\n    /// @param maxBorrowShares_ The max borrow shares.\n    /// @param confirmLiquidityLimitsCoverCap_  Reminder to manually confirm that the limits for the dex at liquidity layer cover the cap.\n    function setMaxShares(\n        address dex_,\n        uint256 maxSupplyShares_,\n        uint256 maxBorrowShares_,\n        bool confirmLiquidityLimitsCoverCap_\n    ) external onlyMultisig {\n        _validateSetDexShares(dex_, confirmLiquidityLimitsCoverCap_);\n        _setMaxSupplyShares(dex_, maxSupplyShares_);\n        _setMaxBorrowShares(dex_, maxBorrowShares_);\n    }\n\n    ////////////////////////////////// INTERNAL HELPERS ////////////////////////////////////////////////////////\n\n    /// @dev Validates parameters for setting DEX shares.\n    function _validateSetDexShares(address dex_, bool confirmLiquidityLimitsCoverCap_) internal {\n        if (!confirmLiquidityLimitsCoverCap_) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__InvalidParams);\n        }\n\n        _validateLastUpdateTime(lastUpdateTime[dex_][dex_]);\n        lastUpdateTime[dex_][dex_] = block.timestamp;\n    }\n\n    /// @dev Sets the max borrow shares for a DEX.\n    function _setMaxBorrowShares(address dex_, uint256 maxBorrowShares_) internal {\n        uint256 currentMaxBorrowShares_ = getMaxBorrowShares(dex_);\n        _validateWithinMaxPercentChange(currentMaxBorrowShares_, maxBorrowShares_);\n\n        IFluidDexT1Admin(dex_).updateMaxBorrowShares(maxBorrowShares_);\n\n        emit LogSetMaxBorrowShares(dex_, maxBorrowShares_);\n    }\n\n    /// @dev Sets the max supply shares for a DEX.\n    function _setMaxSupplyShares(address dex_, uint256 maxSupplyShares_) internal {\n        uint256 currentMaxSupplyShares_ = getMaxSupplyShares(dex_);\n        _validateWithinMaxPercentChange(currentMaxSupplyShares_, maxSupplyShares_);\n\n        IFluidDexT1Admin(dex_).updateMaxSupplyShares(maxSupplyShares_);\n\n        emit LogSetMaxSupplyShares(dex_, maxSupplyShares_);\n    }\n\n    /// @dev Validates that the new limit is within the allowed max percent change.\n    function _validateWithinMaxPercentChange(uint256 oldLimit_, uint256 newLimit_) internal pure {\n        uint256 maxDelta = (oldLimit_ * MAX_PERCENT_CHANGE) / 100; // 20% of oldLimit_\n\n        if (newLimit_ > oldLimit_ && (newLimit_ - oldLimit_) > maxDelta) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__ExceedAllowedPercentageChange);\n        } else if (newLimit_ < oldLimit_ && (oldLimit_ - newLimit_) > maxDelta) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__ExceedAllowedPercentageChange);\n        }\n    }\n\n    /// @dev Validates that the cooldown period has passed since the last update.\n    function _validateLastUpdateTime(uint256 lastUpdateTime_) internal view {\n        if (block.timestamp - lastUpdateTime_ < COOLDOWN_PERIOD) {\n            revert FluidConfigError(ErrorTypes.LimitsAuth__CoolDownPending);\n        }\n    }\n\n    ////////////////////////////////// GETTERS ////////////////////////////////////////////////////////\n\n    /// @notice Get the max borrow shares of a DEX\n    /// @param dex_ The address of the DEX\n    /// @return The max borrow shares\n    function getMaxBorrowShares(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_TOTAL_BORROW_SHARES_SLOT)) >> 128;\n    }\n\n    /// @notice Get the max supply shares of a DEX\n    /// @param dex_ The address of the DEX\n    /// @return The max supply shares\n    function getMaxSupplyShares(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_TOTAL_SUPPLY_SHARES_SLOT)) >> 128;\n    }\n\n    /// @notice Returns the user supply config for a given dex and user.\n    function getUserSupplyConfig(\n        address dex_,\n        address user_\n    ) public view returns (AdminModuleStructs.UserSupplyConfig memory userSupplyConfigs_) {\n        uint256 userSupply_ = IFluidDexT1(dex_).readFromStorage(\n            DexSlotsLink.calculateMappingStorageSlot(DexSlotsLink.DEX_USER_SUPPLY_MAPPING_SLOT, user_)\n        );\n\n        if (userSupply_ > 0) {\n            userSupplyConfigs_ = AdminModuleStructs.UserSupplyConfig({\n                user: user_,\n                baseWithdrawalLimit: BigMathMinified.fromBigNumber(\n                    (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18,\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                ),\n                expandPercent: (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14,\n                expandDuration: (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24\n            });\n        }\n    }\n\n    /// @notice Returns the user borrow config for a given dex and user.\n    function getUserBorrowConfig(\n        address dex_,\n        address user_\n    ) public view returns (AdminModuleStructs.UserBorrowConfig memory userBorrowConfigs_) {\n        uint256 userBorrow_ = IFluidDexT1(dex_).readFromStorage(\n            DexSlotsLink.calculateMappingStorageSlot(DexSlotsLink.DEX_USER_BORROW_MAPPING_SLOT, user_)\n        );\n\n        if (userBorrow_ > 0) {\n            userBorrowConfigs_ = AdminModuleStructs.UserBorrowConfig({\n                user: user_,\n                baseDebtCeiling: BigMathMinified.fromBigNumber(\n                    (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18,\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                ),\n                maxDebtCeiling: BigMathMinified.fromBigNumber(\n                    (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18,\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                ),\n                expandPercent: (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14,\n                expandDuration: (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24\n            });\n        }\n    }\n}\n"
    },
    "contracts/config/liquidityTokenAuth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Structs as AdminModuleStructs } from \"../../liquidity/adminModule/structs.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\n\nabstract contract Constants {\n    /// @notice Fluid liquidity address\n    IFluidLiquidity public immutable LIQUIDITY;\n\n    /// @notice Team multisig allowed to trigger collecting revenue\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n    address public constant TEAM_MULTISIG2 = 0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\n\n    /// @notice reserve contract for fetching allowed rebalancers\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n\n    uint256 internal constant FOUR_DECIMALS = 10000;\n    uint256 internal constant X14 = 0x3fff;\n}\n\nabstract contract Events {\n    /// @notice emitted when RateDataV2Params is initiated\n    event LogInitiateRateDateV2Params(address token);\n\n    /// @notice emitted when TokenConfig is initiated\n    event LogInitiateTokenConfig(address token);\n\n    /// @notice emitted when the reserve factor for a token is updated\n    event LogUpdateReserveFactor(address token, uint256 oldReserveFactor, uint256 newReserveFactor);\n}\n\n/// @notice Initializes a token at Liquidity Layer if token is not already initialized and update token reserve factor\ncontract FluidLiquidityTokenAuth is Constants, Error, Events {\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract) or team multisig\n    modifier onlyRebalancerOrMultisig() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender) && msg.sender != TEAM_MULTISIG && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.LiquidityTokenAuth__Unauthorized);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract) or team multisig\n    modifier onlyMultisig() {\n        if (msg.sender != TEAM_MULTISIG && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.LiquidityTokenAuth__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(address liquidity_, IFluidReserveContract reserveContract_) {\n        if (liquidity_ == address(0) || address(reserveContract_) == address(0)) {\n            revert FluidConfigError(ErrorTypes.LiquidityTokenAuth__InvalidParams);\n        }\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        RESERVE_CONTRACT = reserveContract_;\n    }\n\n    /// @notice Initializes rateDataV2 for a token at Liquidity Layer if token is not initialized and sets default token config\n    function listToken(address token_) external onlyRebalancerOrMultisig {\n        _initializeRateDataV2(token_);\n        _initializeTokenConfig(token_);\n    }\n\n    /// @notice Updates the reserve factor for a token at Liquidity Layer\n    /// @param token_ The address of the token to update\n    /// @param newReserveFactor_ The new reserve factor to set (in 1e2: 100% = 10_000; 1% = 100)\n    function updateReserveFactor(address token_, uint256 newReserveFactor_) external onlyMultisig {\n        uint256 exchangePricesAndConfig_ = LIQUIDITY.readFromStorage(\n            LiquiditySlotsLink.calculateMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n                token_\n            )\n        );\n        if (exchangePricesAndConfig_ == 0) {\n            revert FluidConfigError(ErrorTypes.LiquidityTokenAuth__InvalidParams);\n        }\n\n        /// Next  14 bits =>  44- 57 => update on storage threshold (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n        uint256 storageUpdateThreshold_ = (exchangePricesAndConfig_ >>\n            LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD) & X14;\n\n        /// First 14 bits =>   0- 13 => max allowed utilization (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n        uint256 maxUtilization_ = FOUR_DECIMALS;\n\n        /// Next  14 bits =>  16- 29 => fee on interest from borrowers to lenders (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n        uint256 oldReserveFactor_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14;\n\n        if ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_USES_CONFIGS2) & 1 == 1) {\n            uint256 configs2_ = LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_CONFIGS2_MAPPING_SLOT,\n                    token_\n                )\n            );\n            maxUtilization_ = configs2_ & X14;\n        }\n\n        AdminModuleStructs.TokenConfig[] memory tokenConfigs_ = new AdminModuleStructs.TokenConfig[](1);\n        tokenConfigs_[0] = AdminModuleStructs.TokenConfig({\n            token: token_,\n            fee: newReserveFactor_,\n            threshold: storageUpdateThreshold_,\n            maxUtilization: maxUtilization_\n        });\n\n        LIQUIDITY.updateTokenConfigs(tokenConfigs_);\n\n        emit LogUpdateReserveFactor(token_, oldReserveFactor_, newReserveFactor_);\n    }\n\n    /// @notice Initializes rateDataV2 for a token at Liquidity Layer if token is not initialized\n    function _initializeRateDataV2(address token_) internal {\n        bytes32 borrowRateDataSlot = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_RATE_DATA_MAPPING_SLOT,\n            token_\n        );\n        uint256 rateConfig_ = LIQUIDITY.readFromStorage(borrowRateDataSlot);\n        if (rateConfig_ > 0) {\n            revert FluidConfigError(ErrorTypes.LiquidityTokenAuth_AlreadyInitialized);\n        }\n\n        AdminModuleStructs.RateDataV2Params[] memory params_ = new AdminModuleStructs.RateDataV2Params[](1);\n        params_[0] = AdminModuleStructs.RateDataV2Params({\n            token: token_,\n            kink1: 5000,\n            kink2: 8000,\n            rateAtUtilizationZero: 0,\n            rateAtUtilizationKink1: 2000,\n            rateAtUtilizationKink2: 4000,\n            rateAtUtilizationMax: 10000\n        });\n        LIQUIDITY.updateRateDataV2s(params_);\n\n        emit LogInitiateRateDateV2Params(token_);\n    }\n\n    /// @notice Initializes token at Liquidity Layer if not already initialized\n    function _initializeTokenConfig(address token_) internal {\n        uint256 exchangePricesAndConfig_ = LIQUIDITY.readFromStorage(\n            LiquiditySlotsLink.calculateMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n                token_\n            )\n        );\n\n        if (exchangePricesAndConfig_ > 0) {\n            revert FluidConfigError(ErrorTypes.LiquidityTokenAuth_AlreadyInitialized);\n        }\n\n        AdminModuleStructs.TokenConfig[] memory tokenConfigs_ = new AdminModuleStructs.TokenConfig[](1);\n        tokenConfigs_[0] = AdminModuleStructs.TokenConfig({\n            token: token_,\n            fee: 1000,\n            threshold: 30,\n            maxUtilization: 10000\n        });\n\n        LIQUIDITY.updateTokenConfigs(tokenConfigs_);\n\n        emit LogInitiateTokenConfig(token_);\n    }\n}\n"
    },
    "contracts/config/maxBorrowHandler/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { IFluidLiquidityResolver } from \"../../periphery/resolvers/liquidity/iLiquidityResolver.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { LiquidityCalcs } from \"../../libraries/liquidityCalcs.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { Structs as AdminModuleStructs } from \"../../liquidity/adminModule/structs.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nabstract contract Constants {\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n    IFluidLiquidity public immutable LIQUIDITY;\n    IFluidLiquidityResolver public immutable LIQUIDITY_RESOLVER;\n    address public immutable PROTOCOL;\n    address public immutable BORROW_TOKEN;\n\n    /// @dev max utilization of total supply that will be set as max borrow limit. In percent (100 = 1%, 1 = 0.01%)\n    uint256 public immutable MAX_UTILIZATION;\n\n    /// @dev minimum percent difference to trigger an update. In percent (100 = 1%, 1 = 0.01%)\n    uint256 public immutable MIN_UPDATE_DIFF;\n\n    bytes32 internal immutable _LIQUDITY_PROTOCOL_BORROW_SLOT;\n\n    uint256 internal constant MAX_UTILIZATION_PRECISION = 1e4;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xff;\n\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n}\n\nabstract contract Events {\n    /// @notice emitted when borrow max limit is updated\n    event LogUpdateBorrowMaxDebtCeiling(\n        uint256 totalSupplyNormal,\n        uint256 oldMaxDebtCeilingRaw,\n        uint256 maxDebtCeilingRaw,\n        uint256 borrowExchangePrice\n    );\n}\n\n/// @notice Sets max borrow limit for a protocol on Liquidity based on utilization of total supply of the same borrow token\ncontract FluidMaxBorrowConfigHandler is Constants, Error, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.MaxBorrowConfigHandler__AddressZero);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract)\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.MaxBorrowConfigHandler__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(\n        IFluidReserveContract reserveContract_,\n        IFluidLiquidity liquidity_,\n        IFluidLiquidityResolver liquidityResolver_,\n        address protocol_,\n        address borrowToken_,\n        uint256 maxUtilization_,\n        uint256 minUpdateDiff_\n    )\n        validAddress(address(reserveContract_))\n        validAddress(address(liquidity_))\n        validAddress(address(liquidityResolver_))\n        validAddress(protocol_)\n        validAddress(borrowToken_)\n    {\n        RESERVE_CONTRACT = reserveContract_;\n        LIQUIDITY = liquidity_;\n        LIQUIDITY_RESOLVER = liquidityResolver_;\n        PROTOCOL = protocol_;\n        BORROW_TOKEN = borrowToken_;\n\n        if (maxUtilization_ > MAX_UTILIZATION_PRECISION || minUpdateDiff_ == 0) {\n            revert FluidConfigError(ErrorTypes.MaxBorrowConfigHandler__InvalidParams);\n        }\n\n        _LIQUDITY_PROTOCOL_BORROW_SLOT = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n            protocol_,\n            borrowToken_\n        );\n\n        MAX_UTILIZATION = maxUtilization_;\n        MIN_UPDATE_DIFF = minUpdateDiff_;\n    }\n\n    /// @notice returns `BORROW_TOKEN` total supply at Liquidity (in normal).\n    function getTotalSupply() public view returns (uint256 totalSupplyNormal_) {\n        (totalSupplyNormal_, ) = _getTotalSupply();\n    }\n\n    /// @notice returns the currently set max debt ceiling (in raw for mode with interest!).\n    function currentMaxDebtCeiling() public view returns (uint256 maxDebtCeiling_) {\n        return\n            BigMathMinified.fromBigNumber(\n                (LIQUIDITY.readFromStorage(_LIQUDITY_PROTOCOL_BORROW_SLOT) >>\n                    LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n    }\n\n    /// @notice returns the max debt ceiling that should be set according to current state (in normal).\n    function calcMaxDebtCeilingNormal() public view returns (uint256 maxDebtCeilingNormal_) {\n        (uint256 maxDebtCeilingRaw_, , uint256 borrowExchangePrice_, , ) = _calcMaxDebtCeiling();\n        // convert to normal\n        maxDebtCeilingNormal_ = (maxDebtCeilingRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION;\n    }\n\n    /// @notice returns the max debt ceiling that should be set according to current state (in raw for mode with interest!).\n    function calcMaxDebtCeiling() public view returns (uint256 maxDebtCeiling_) {\n        (maxDebtCeiling_, , , , ) = _calcMaxDebtCeiling();\n    }\n\n    /// @notice returns how much new config would be different from current config in percent (100 = 1%, 1 = 0.01%).\n    function configPercentDiff() public view returns (uint256 configPercentDiff_) {\n        (uint256 maxDebtCeilingRaw_, , , uint256 userBorrowData_, ) = _calcMaxDebtCeiling();\n\n        (configPercentDiff_, ) = _configPercentDiff(userBorrowData_, maxDebtCeilingRaw_);\n    }\n\n    /// @notice Rebalances the configs for `PROTOCOL` at Fluid Liquidity based on protocol total supply & total borrow.\n    /// Emits `LogUpdateBorrowMaxDebtCeiling` if update is executed.\n    /// Reverts if no update is needed.\n    /// Can only be called by an authorized rebalancer.\n    function rebalance() external onlyRebalancer {\n        if (!_updateBorrowLimits()) {\n            revert FluidConfigError(ErrorTypes.MaxBorrowConfigHandler__NoUpdate);\n        }\n    }\n\n    /***********************************|\n    |            INTERNALS              | \n    |__________________________________*/\n\n    function _getTotalSupply() internal view returns (uint256 totalSupplyNormal_, uint256 borrowExchangePrice_) {\n        uint256 supplyExchangePrice_;\n\n        (supplyExchangePrice_, borrowExchangePrice_) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY_RESOLVER.getExchangePricesAndConfig(BORROW_TOKEN)\n        );\n\n        totalSupplyNormal_ = LiquidityCalcs.getTotalSupply(\n            LIQUIDITY_RESOLVER.getTotalAmounts(BORROW_TOKEN),\n            supplyExchangePrice_\n        );\n    }\n\n    function _calcMaxDebtCeiling()\n        internal\n        view\n        returns (\n            uint256 maxDebtCeilingRaw_,\n            uint256 totalSupplyNormal_,\n            uint256 borrowExchangePrice_,\n            uint256 userBorrowData_,\n            uint256 baseDebtCeilingRaw_\n        )\n    {\n        (totalSupplyNormal_, borrowExchangePrice_) = _getTotalSupply();\n\n        uint256 maxDebtCeilingNormal_ = (MAX_UTILIZATION * totalSupplyNormal_) / MAX_UTILIZATION_PRECISION;\n\n        // turn into maxDebtCeiling Raw\n        maxDebtCeilingRaw_ = (maxDebtCeilingNormal_ * EXCHANGE_PRICES_PRECISION) / borrowExchangePrice_;\n\n        userBorrowData_ = LIQUIDITY.readFromStorage(_LIQUDITY_PROTOCOL_BORROW_SLOT); // total storage slot\n\n        baseDebtCeilingRaw_ = BigMathMinified.fromBigNumber(\n            (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18,\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        );\n\n        if (baseDebtCeilingRaw_ > maxDebtCeilingRaw_) {\n            // max debt ceiling can never be < base debt ceiling\n            maxDebtCeilingRaw_ = baseDebtCeilingRaw_;\n        }\n    }\n\n    function _configPercentDiff(\n        uint256 userBorrowData_,\n        uint256 maxDebtCeilingRaw_\n    ) internal pure returns (uint256 configPercentDiff_, uint256 oldMaxDebtCeilingRaw_) {\n        oldMaxDebtCeilingRaw_ = BigMathMinified.fromBigNumber(\n            (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18,\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        );\n\n        if (oldMaxDebtCeilingRaw_ == maxDebtCeilingRaw_) {\n            return (0, oldMaxDebtCeilingRaw_);\n        }\n\n        if (oldMaxDebtCeilingRaw_ > maxDebtCeilingRaw_) {\n            // % of how much new max debt ceiling would be smaller\n            configPercentDiff_ = oldMaxDebtCeilingRaw_ - maxDebtCeilingRaw_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 10 -> 2000 (20%)\n        } else {\n            // % of how much new max debt ceiling would be bigger\n            configPercentDiff_ = maxDebtCeilingRaw_ - oldMaxDebtCeilingRaw_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 8 -> 2500 (25%)\n        }\n\n        configPercentDiff_ = (configPercentDiff_ * 1e4) / oldMaxDebtCeilingRaw_;\n    }\n\n    function _updateBorrowLimits() internal returns (bool updated_) {\n        (\n            uint256 maxDebtCeilingRaw_,\n            uint256 totalSupplyNormal_,\n            uint256 borrowExchangePrice_,\n            uint256 userBorrowData_,\n            uint256 baseDebtCeilingRaw_\n        ) = _calcMaxDebtCeiling();\n\n        (uint256 configPercentDiff_, uint256 oldMaxDebtCeilingRaw_) = _configPercentDiff(\n            userBorrowData_,\n            maxDebtCeilingRaw_\n        );\n\n        // check if min config deviation is reached\n        if (configPercentDiff_ < MIN_UPDATE_DIFF) {\n            return false;\n        }\n\n        // execute update at Liquidity\n        AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_ = new AdminModuleStructs.UserBorrowConfig[](1);\n        userBorrowConfigs_[0] = AdminModuleStructs.UserBorrowConfig({\n            user: PROTOCOL,\n            token: BORROW_TOKEN,\n            mode: uint8(userBorrowData_ & 1), // first bit\n            expandPercent: (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14, // set same as old\n            expandDuration: (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24, // set same as old\n            baseDebtCeiling: baseDebtCeilingRaw_, // set same as old\n            maxDebtCeiling: maxDebtCeilingRaw_\n        });\n        LIQUIDITY.updateUserBorrowConfigs(userBorrowConfigs_);\n\n        emit LogUpdateBorrowMaxDebtCeiling(\n            totalSupplyNormal_,\n            oldMaxDebtCeilingRaw_,\n            maxDebtCeilingRaw_,\n            borrowExchangePrice_\n        );\n\n        return true;\n    }\n}\n"
    },
    "contracts/config/rangeAuthDex/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { DexSlotsLink } from \"../../libraries/dexSlotsLink.sol\";\nimport { IFluidDexT1 } from \"../../protocols/dex/interfaces/iDexT1.sol\";\n\ninterface IFluidDexT1Admin {\n    /// @notice updates the upper and lower percent configs for a dex\n    /// @param upperPercent_ in 4 decimals, 10000 = 1%\n    /// @param lowerPercent_ in 4 decimals, 10000 = 1%\n    /// @param shiftTime_ in secs, in how much time the upper percent configs change should be fully done\n    function updateRangePercents(uint upperPercent_, uint lowerPercent_, uint shiftTime_) external;\n\n    /// @param upperThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param lowerThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param thresholdShiftTime_ in secs, in how much time the threshold percent should take to shift the ranges\n    /// @param shiftTime_ in secs, in how much time the upper config changes should be fully done.\n    function updateThresholdPercent(\n        uint upperThresholdPercent_,\n        uint lowerThresholdPercent_,\n        uint thresholdShiftTime_,\n        uint shiftTime_\n    ) external;\n}\n\nabstract contract Events {\n    /// @notice emitted when multisig successfully changes the upper and lower range percent configs\n    event LogSetRanges(address dex, uint upperPercent, uint lowerPercent, uint shiftTime);\n\n    /// @notice emitted when multisig successfully changes threshold configs\n    event LogSetThresholdConfig(\n        address dex,\n        uint upperPercent,\n        uint lowerPercent,\n        uint thresholdShiftTime,\n        uint shiftTime\n    );\n}\n\nabstract contract Constants {\n    uint256 internal constant X10 = 0x3ff;\n    uint256 internal constant X20 = 0xfffff;\n    uint256 internal constant X24 = 0xffffff;\n\n    uint256 internal constant THREE_DECIMALS = 1e3;\n\n    /// @dev cooldown for config updates is 4 days\n    uint256 public constant COOLDOWN = 4 days;\n\n    /// @dev max percent range change allowed is 20%\n    uint256 public constant MAX_PERCENT_RANGE_CHANGE_ALLOWED = 20 * 1e4;\n\n    /// @dev shift time must be >= 2 days <= 12 days (except for wsteth and weeth eth dexes)\n    uint256 public constant MIN_SHIFT_TIME = 2 days;\n    uint256 public constant MAX_SHIFT_TIME = 12 days;\n\n    /// @notice Team multisigs allowed to trigger methods\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n    address public constant TEAM_MULTISIG2 = 0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\n\n    /// @dev wsteth eth dex, must shift instantly (only on mainnet)\n    address public immutable WSTETH_ETH_DEX;\n\n    /// @dev weeth eth dex, must shift instantly (only on mainnet)\n    address public immutable WEETH_ETH_DEX;\n}\n\nabstract contract Variables is Constants {\n    enum UpdateType {\n        RANGES, // 0\n        THRESHOLD // 1\n    }\n\n    /// @notice dex => UpdateType => last update time when a Dex config was updated\n    mapping(address => mapping(UpdateType => uint256)) public dexLastUpdateTimestamp;\n}\n\ncontract FluidRangeAuthDex is Variables, Error, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.RangeAuthDex__InvalidParams);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is the team multisig\n    modifier onlyMultisig() {\n        if (TEAM_MULTISIG != msg.sender && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.RangeAuthDex__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(address wstethEthDex_, address weethEthDex_) {\n        if ((block.chainid == 1) && (wstethEthDex_ == address(0) || weethEthDex_ == address(0))) {\n            revert FluidConfigError(ErrorTypes.RangeAuthDex__InvalidParams);\n        }\n        WSTETH_ETH_DEX = wstethEthDex_;\n        WEETH_ETH_DEX = weethEthDex_;\n    }\n\n    function getRanges(address dex_) public view returns (uint256 upperRangePercent_, uint256 lowerRangePercent_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n\n        upperRangePercent_ = (dexVariables2_ >> 27) & X20;\n        lowerRangePercent_ = (dexVariables2_ >> 47) & X20;\n    }\n\n    function getThresholdConfig(\n        address dex_\n    )\n        public\n        view\n        returns (uint256 upperThresholdPercent_, uint256 lowerThresholdPercent_, uint256 thresholdShiftTime_)\n    {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n\n        upperThresholdPercent_ = ((dexVariables2_ >> 68) & X10) * THREE_DECIMALS;\n        lowerThresholdPercent_ = ((dexVariables2_ >> 78) & X10) * THREE_DECIMALS;\n        thresholdShiftTime_ = (dexVariables2_ >> 88) & X24;\n    }\n\n    /// @notice Sets the upper and lower range for a dex\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex\n    /// @param upperRangePercent_ The new upper range to be set\n    /// @param lowerRangePercent_ The new lower range to be set\n    function setRanges(\n        address dex_,\n        uint256 upperRangePercent_,\n        uint256 lowerRangePercent_,\n        uint256 shiftTime_\n    ) external onlyMultisig {\n        _validateLastUpdateTime(dex_, UpdateType.RANGES);\n        _validateShiftTime(dex_, shiftTime_);\n\n        (uint256 currentUpperRangePercent_, uint256 currentLowerRangePercent_) = getRanges(dex_);\n\n        _validateChange(currentUpperRangePercent_, upperRangePercent_);\n        _validateChange(currentLowerRangePercent_, lowerRangePercent_);\n\n        dexLastUpdateTimestamp[dex_][UpdateType.RANGES] = block.timestamp;\n\n        IFluidDexT1Admin(dex_).updateRangePercents(upperRangePercent_, lowerRangePercent_, shiftTime_);\n\n        emit LogSetRanges(dex_, upperRangePercent_, lowerRangePercent_, shiftTime_);\n    }\n\n    /// @notice Sets the upper and lower range for a dex by percentage to change from current config\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex\n    /// @param newUpperRangePercentage_ The new upper range percentage change, 10000 = 1%. Positive to increase, negative to decrease\n    /// @param newLowerRangePercentage_ The new lower range percentage change, 10000 = 1%. Positive to increase, negative to decrease\n    function setRangesByPercentage(\n        address dex_,\n        int256 newUpperRangePercentage_,\n        int256 newLowerRangePercentage_,\n        uint256 shiftTime_\n    ) external onlyMultisig {\n        _validateLastUpdateTime(dex_, UpdateType.RANGES);\n        _validateShiftTime(dex_, shiftTime_);\n\n        _validatePercentChange(_abs(newUpperRangePercentage_));\n        _validatePercentChange(_abs(newLowerRangePercentage_));\n\n        (uint256 currentUpperRangePercent_, uint256 currentLowerRangePercent_) = getRanges(dex_);\n\n        uint256 newUpperRangePercent_ = _getNewRange(currentUpperRangePercent_, newUpperRangePercentage_);\n        uint256 newLowerRangePercent_ = _getNewRange(currentLowerRangePercent_, newLowerRangePercentage_);\n\n        dexLastUpdateTimestamp[dex_][UpdateType.RANGES] = block.timestamp;\n\n        IFluidDexT1Admin(dex_).updateRangePercents(newUpperRangePercent_, newLowerRangePercent_, shiftTime_);\n\n        emit LogSetRanges(dex_, newUpperRangePercent_, newLowerRangePercent_, shiftTime_);\n    }\n\n    /// @notice Sets the upper and lower threshold percent for a dex\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex\n    /// @param upperThresholdPercent_ The new upper threshold percent, 10000 = 1%\n    /// @param lowerThresholdPercent_ The new lower threshold percent, 10000 = 1%\n    /// @param thresholdShiftTime_ The new threshold shift time\n    function setThresholdConfig(\n        address dex_,\n        uint256 upperThresholdPercent_,\n        uint256 lowerThresholdPercent_,\n        uint256 thresholdShiftTime_,\n        uint256 shiftTime_\n    ) external onlyMultisig {\n        _validateLastUpdateTime(dex_, UpdateType.THRESHOLD);\n        _validateShiftTime(dex_, shiftTime_);\n\n        (\n            uint256 currentUpperThresholdPercent_,\n            uint256 currentLowerThresholdPercent_,\n            uint256 currentThresholdShiftTime_\n        ) = getThresholdConfig(dex_);\n\n        _validateChange(currentUpperThresholdPercent_, upperThresholdPercent_);\n        _validateChange(currentLowerThresholdPercent_, lowerThresholdPercent_);\n        _validateChange(currentThresholdShiftTime_, thresholdShiftTime_);\n\n        dexLastUpdateTimestamp[dex_][UpdateType.THRESHOLD] = block.timestamp;\n\n        IFluidDexT1Admin(dex_).updateThresholdPercent(\n            upperThresholdPercent_,\n            lowerThresholdPercent_,\n            thresholdShiftTime_,\n            shiftTime_\n        );\n\n        emit LogSetThresholdConfig(\n            dex_,\n            upperThresholdPercent_,\n            lowerThresholdPercent_,\n            thresholdShiftTime_,\n            shiftTime_\n        );\n    }\n\n    function _percentDiffForValue(\n        uint256 oldValue_,\n        uint256 newValue_\n    ) internal pure returns (uint256 configPercentDiff_) {\n        if (oldValue_ == 0 || oldValue_ == newValue_) {\n            return 0;\n        }\n\n        if (oldValue_ > newValue_) {\n            // % of how much new value would be smaller\n            configPercentDiff_ = oldValue_ - newValue_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 10 -> 2000 (20%)\n        } else {\n            // % of how much new value would be bigger\n            configPercentDiff_ = newValue_ - oldValue_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 8 -> 2500 (25%)\n        }\n\n        configPercentDiff_ = (configPercentDiff_ * 1e6) / oldValue_;\n    }\n\n    function _getNewRange(uint256 currentRange_, int256 newRangePercentage_) internal pure returns (uint256 newRange_) {\n        if (newRangePercentage_ > 0) {\n            /// @dev newRangePercentage_ is 10000 = 1%\n            newRange_ = currentRange_ + (currentRange_ * uint256(newRangePercentage_)) / 1e6;\n        } else {\n            newRange_ = currentRange_ - (currentRange_ * uint256(-newRangePercentage_)) / 1e6;\n        }\n    }\n\n    function _validatePercentChange(uint256 percent_) internal pure {\n        if (percent_ > MAX_PERCENT_RANGE_CHANGE_ALLOWED) {\n            revert FluidConfigError(ErrorTypes.RangeAuthDex__ExceedAllowedPercentageChange);\n        }\n    }\n\n    function _validateChange(uint256 oldConfig_, uint256 newConfig_) internal pure {\n        uint256 configPercentage_ = _percentDiffForValue(oldConfig_, newConfig_);\n        _validatePercentChange(configPercentage_);\n    }\n\n    function _validateShiftTime(address dex_, uint256 shiftTime_) internal view {\n        if ((block.chainid == 1) && (dex_ == WSTETH_ETH_DEX || dex_ == WEETH_ETH_DEX)) {\n            /// @dev wsteth eth and weeth dex has zero shift time\n            if (shiftTime_ != 0) {\n                revert FluidConfigError(ErrorTypes.RangeAuthDex__InvalidShiftTime);\n            }\n        } else {\n            if (shiftTime_ < MIN_SHIFT_TIME || shiftTime_ > MAX_SHIFT_TIME) {\n                revert FluidConfigError(ErrorTypes.RangeAuthDex__InvalidShiftTime);\n            }\n        }\n    }\n\n    function _validateLastUpdateTime(address dex_, UpdateType updateType_) internal view {\n        if (block.timestamp - dexLastUpdateTimestamp[dex_][updateType_] < COOLDOWN) {\n            revert FluidConfigError(ErrorTypes.RangeAuthDex__CooldownLeft);\n        }\n    }\n\n    function _abs(int256 value_) internal pure returns (uint256) {\n        return value_ > 0 ? uint256(value_) : uint256(-value_);\n    }\n}\n"
    },
    "contracts/config/ratesAuth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Structs as AdminModuleStructs } from \"../../liquidity/adminModule/structs.sol\";\n\nabstract contract Constants {\n    IFluidLiquidity public immutable LIQUIDITY;\n    /// @notice Team multisigs allowed to trigger methods\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n    address public constant TEAM_MULTISIG2 = 0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\n\n    uint256 internal constant X16 = 0xffff;\n\n    uint256 public immutable PERCENT_RATE_CHANGE_ALLOWED;\n    uint256 public immutable COOLDOWN;\n}\n\nabstract contract Events {\n    /// @notice emitted when borrow rate for specified borrow token is updated based on\n    ///         team multisig input of rate at kinks\n    event LogUpdateRateAtKink(\n        address borrowToken,\n        uint256 oldRateKink1,\n        uint256 newRateKink1,\n        uint256 oldRateKink2,\n        uint256 newRateKink2\n    );\n}\n\nabstract contract Structs {\n    struct RateAtKinkV1 {\n        address token;\n        uint256 rateAtUtilizationKink;\n    }\n\n    struct RateAtKinkV2 {\n        address token;\n        uint256 rateAtUtilizationKink1;\n        uint256 rateAtUtilizationKink2;\n    }\n}\n\nabstract contract Variables {\n    /// @notice  last timestamp when a token's rate was updated\n    mapping(address => uint256) public tokenLastUpdateTimestamp;\n}\n\n/// @notice Sets borrow rate for specified borrow token at Liquidity based on team multisig input.\ncontract FluidRatesAuth is Constants, Error, Events, Structs, Variables {\n    /// @dev Validates that an address is a multisig (taken from reserve auth)\n    modifier onlyMultisig() {\n        if (TEAM_MULTISIG != msg.sender && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(address liquidity_, uint256 percentRateChangeAllowed_, uint256 cooldown_) {\n        if (liquidity_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__InvalidParams);\n        }\n        if (percentRateChangeAllowed_ == 0 || cooldown_ == 0) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__InvalidParams);\n        }\n        if (percentRateChangeAllowed_ > 1e4) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__InvalidParams);\n        }\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        PERCENT_RATE_CHANGE_ALLOWED = percentRateChangeAllowed_;\n        COOLDOWN = cooldown_;\n    }\n\n    function updateRateDataV1(RateAtKinkV1 calldata rateStruct_) external onlyMultisig {\n        bytes32 borrowRateDataSlot_ = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_RATE_DATA_MAPPING_SLOT,\n            rateStruct_.token\n        );\n        uint256 rateConfig_ = LIQUIDITY.readFromStorage(borrowRateDataSlot_);\n        if (rateConfig_ & 0xF != 1) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__InvalidVersion);\n        }\n\n        if (block.timestamp - tokenLastUpdateTimestamp[rateStruct_.token] < COOLDOWN) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__CooldownLeft);\n        }\n\n        AdminModuleStructs.RateDataV1Params memory rateData_;\n        rateData_.token = rateStruct_.token;\n\n        uint256 oldRateKink1_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n\n        // checks the diff to be lesser than allowed\n        if (_percentDiffForValue(oldRateKink1_, rateStruct_.rateAtUtilizationKink) > PERCENT_RATE_CHANGE_ALLOWED) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__NoUpdate);\n        }\n\n        // setting up the rateData_ struct\n        rateData_.token = rateStruct_.token;\n        rateData_.kink = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n        rateData_.rateAtUtilizationZero =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) &\n            X16;\n        rateData_.rateAtUtilizationKink = rateStruct_.rateAtUtilizationKink;\n        rateData_.rateAtUtilizationMax =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) &\n            X16;\n\n        AdminModuleStructs.RateDataV1Params[] memory liquidityParams_ = new AdminModuleStructs.RateDataV1Params[](1);\n        liquidityParams_[0] = rateData_;\n        LIQUIDITY.updateRateDataV1s(liquidityParams_);\n\n        tokenLastUpdateTimestamp[rateData_.token] = block.timestamp;\n\n        emit LogUpdateRateAtKink(rateData_.token, oldRateKink1_, rateStruct_.rateAtUtilizationKink, 0, 0);\n    }\n\n    function updateRateDataV2(RateAtKinkV2 calldata rateStruct_) external onlyMultisig {\n        bytes32 borrowRateDataSlot_ = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_RATE_DATA_MAPPING_SLOT,\n            rateStruct_.token\n        );\n        uint256 rateConfig_ = LIQUIDITY.readFromStorage(borrowRateDataSlot_);\n        if (rateConfig_ & 0xF != 2) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__InvalidVersion);\n        }\n\n        if (block.timestamp - tokenLastUpdateTimestamp[rateStruct_.token] < COOLDOWN) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__CooldownLeft);\n        }\n\n        AdminModuleStructs.RateDataV2Params memory rateData_;\n\n        uint256 oldRateKink1_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n        uint256 oldRateKink2_ = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n\n        if (\n            _percentDiffForValue(oldRateKink1_, rateStruct_.rateAtUtilizationKink1) > PERCENT_RATE_CHANGE_ALLOWED ||\n            _percentDiffForValue(oldRateKink2_, rateStruct_.rateAtUtilizationKink2) > PERCENT_RATE_CHANGE_ALLOWED\n        ) {\n            revert FluidConfigError(ErrorTypes.RatesAuth__NoUpdate);\n        }\n\n        // setting up the rateData_ struct\n        rateData_.token = rateStruct_.token;\n        rateData_.kink1 = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\n        rateData_.kink2 = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\n        rateData_.rateAtUtilizationZero =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) &\n            X16;\n        rateData_.rateAtUtilizationKink1 = rateStruct_.rateAtUtilizationKink1;\n        rateData_.rateAtUtilizationKink2 = rateStruct_.rateAtUtilizationKink2;\n        rateData_.rateAtUtilizationMax =\n            (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) &\n            X16;\n\n        AdminModuleStructs.RateDataV2Params[] memory params_ = new AdminModuleStructs.RateDataV2Params[](1);\n        params_[0] = rateData_;\n        LIQUIDITY.updateRateDataV2s(params_);\n        tokenLastUpdateTimestamp[rateStruct_.token] = block.timestamp;\n\n        emit LogUpdateRateAtKink(\n            rateStruct_.token,\n            oldRateKink1_,\n            rateStruct_.rateAtUtilizationKink1,\n            oldRateKink2_,\n            rateStruct_.rateAtUtilizationKink2\n        );\n    }\n\n    /// @dev gets the percentage difference between `oldValue_` and `newValue_` in relation to `oldValue_`\n    function _percentDiffForValue(\n        uint256 oldValue_,\n        uint256 newValue_\n    ) internal pure returns (uint256 configPercentDiff_) {\n        if (oldValue_ == newValue_) {\n            return 0;\n        }\n\n        if (oldValue_ > newValue_) {\n            // % of how much new value would be smaller\n            configPercentDiff_ = oldValue_ - newValue_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 10 -> 2000 (20%)\n        } else {\n            // % of how much new value would be bigger\n            configPercentDiff_ = newValue_ - oldValue_;\n            // e.g. 10 - 8 = 2. 2 * 10000 / 8 -> 2500 (25%)\n        }\n\n        configPercentDiff_ = (configPercentDiff_ * 1e4) / oldValue_;\n    }\n}\n"
    },
    "contracts/config/vaultFeeRewardsAuth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidVaultT1Admin } from \"../../protocols/vault/vaultT1/adminModule/main.sol\";\nimport { FluidVaultT2Admin } from \"../../protocols/vault/vaultT2/adminModule/main.sol\";\nimport { FluidVaultT3Admin } from \"../../protocols/vault/vaultT3/adminModule/main.sol\";\nimport { IFluidVault } from \"../../protocols/vault/interfaces/iVault.sol\";\nimport { FluidProtocolTypes } from \"../../libraries/fluidProtocolTypes.sol\";\n\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nabstract contract Constants {\n    /// @notice Team multisig allowed to trigger collecting revenue\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n    address public constant TEAM_MULTISIG2 = 0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\n\n    uint internal constant X15 = 0x7fff;\n    uint internal constant X16 = 0xffff;\n}\n\nabstract contract Events {\n    /// @notice emitted when supply rate magnifier is updated at a vault\n    /// @param vault The address of the vault\n    /// @param oldSupplyRateMagnifier The previous supply rate magnifier value\n    /// @param newSupplyRateMagnifier The new supply rate magnifier value\n    event LogUpdateSupplyRateMagnifier(address vault, uint256 oldSupplyRateMagnifier, uint256 newSupplyRateMagnifier);\n\n    /// @notice emitted when borrow rate magnifier is updated at a vault\n    /// @param vault The address of the vault\n    /// @param oldBorrowRateMagnifier The previous borrow rate magnifier value\n    /// @param newBorrowRateMagnifier The new borrow rate magnifier value\n    event LogUpdateBorrowRateMagnifier(address vault, uint256 oldBorrowRateMagnifier, uint256 newBorrowRateMagnifier);\n\n    /// @notice emitted when supply rate is updated at a vault\n    /// @param vault The address of the vault\n    /// @param oldSupplyRate The previous supply rate value\n    /// @param newSupplyRate The new supply rate value\n    event LogUpdateSupplyRate(address vault, int256 oldSupplyRate, int256 newSupplyRate);\n\n    /// @notice emitted when borrow rate is updated at a vault\n    /// @param vault The address of the vault\n    /// @param oldBorrowRate The previous borrow rate value\n    /// @param newBorrowRate The new borrow rate value\n    event LogUpdateBorrowRate(address vault, int256 oldBorrowRate, int256 newBorrowRate);\n}\n\ncontract FluidVaultFeeRewardsAuth is Constants, Error, Events {\n    /// @dev Validates that an address is the team multisig\n    modifier onlyMultisig() {\n        if (msg.sender != TEAM_MULTISIG && TEAM_MULTISIG2 != msg.sender) {\n            revert FluidConfigError(ErrorTypes.VaultFeeRewardsAuth__Unauthorized);\n        }\n        _;\n    }\n\n    /// @notice updates the supply rate for a given SMART COL vault.\n    /// @param smartColVault_ The address of the SMART COL vault to update\n    /// @param newSupplyRate_ The new supply rate to set. Input in 1e2 (1% = 100, 100% = 10_000). If positive then incentives else charging\n    function updateSupplyRate(address smartColVault_, int newSupplyRate_) external onlyMultisig {\n        int256 oldSupplyRate_ = currentSupplyRate(smartColVault_);\n\n        FluidVaultT2Admin(address(smartColVault_)).updateSupplyRate(newSupplyRate_);\n\n        emit LogUpdateSupplyRate(smartColVault_, oldSupplyRate_, newSupplyRate_);\n    }\n\n    /// @notice updates the borrow rate for a given SMART DEBT vault.\n    /// @param smartDebtVault_ The address of the SMART DEBT vault to update\n    /// @param newBorrowRate_ The new borrow rate to set. Input in 1e2 (1% = 100, 100% = 10_000). If positive then charging else incentives\n    function updateBorrowRate(address smartDebtVault_, int newBorrowRate_) external onlyMultisig {\n        int256 oldBorrowRate_ = currentBorrowRate(smartDebtVault_);\n\n        FluidVaultT3Admin(address(smartDebtVault_)).updateBorrowRate(newBorrowRate_);\n\n        emit LogUpdateBorrowRate(smartDebtVault_, oldBorrowRate_, newBorrowRate_);\n    }\n\n    /// @notice Sets the supply rate magnifier for a given NORMAL COL vault.\n    /// @param normalColVault_ The address of the NORMAL COL vault to update.\n    /// @param newMagnifier_ The new supply rate magnifier value to set.\n    function updateSupplyRateMagnifier(address normalColVault_, uint256 newMagnifier_) external onlyMultisig {\n        uint256 oldMagnifier_ = currentSupplyRateMagnifier(normalColVault_);\n\n        FluidVaultT1Admin(address(normalColVault_)).updateSupplyRateMagnifier(newMagnifier_);\n\n        emit LogUpdateSupplyRateMagnifier(normalColVault_, oldMagnifier_, newMagnifier_);\n    }\n\n    /// @notice Sets the borrow rate magnifier for a given NORMAL DEBT vault.\n    /// @param normalDebtVault_ The address of the NORMAL DEBT vault to update.\n    /// @param newMagnifier_ The new borrow rate magnifier value to set.\n    function updateBorrowRateMagnifier(address normalDebtVault_, uint256 newMagnifier_) external onlyMultisig {\n        uint256 oldMagnifier_ = currentBorrowRateMagnifier(normalDebtVault_);\n\n        FluidVaultT1Admin(address(normalDebtVault_)).updateBorrowRateMagnifier(newMagnifier_);\n\n        emit LogUpdateBorrowRateMagnifier(normalDebtVault_, oldMagnifier_, newMagnifier_);\n    }\n\n    /// @notice Get the type of a vault (assumes valid Fluid vault address is passed in)\n    /// @param vault_ The address of the vault.\n    /// @return isSmartCol_ True if the vault is a SMART COL vault, false otherwise.\n    /// @return isSmartDebt_ True if the vault is a SMART DEBT vault, false otherwise.\n    function getVaultType(address vault_) public view returns (bool isSmartCol_, bool isSmartDebt_) {\n        try IFluidVault(vault_).TYPE() returns (uint type_) {\n            if (type_ == FluidProtocolTypes.VAULT_T1_TYPE) {\n                return (false, false);\n            }\n            if (type_ == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE) {\n                return (true, false);\n            }\n            if (type_ == FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE) {\n                return (false, true);\n            }\n            if (type_ == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE) {\n                return (true, true);\n            }\n        } catch {\n            // if TYPE() is not available but address is valid vault id, it must be vault T1\n            return (false, false);\n        }\n    }\n\n    /// @notice returns the currently configured supply rate magnifier at the `vault_`\n    /// @param normalColVault_ The address of the NORMAL COL vault to query.\n    /// @return The current supply rate magnifier value.\n    function currentSupplyRateMagnifier(address normalColVault_) public view returns (uint256) {\n        (bool isSmartCol_, ) = getVaultType(normalColVault_);\n        if (isSmartCol_) {\n            revert FluidConfigError(ErrorTypes.VaultFeeRewardsAuth__InvalidVaultType);\n        }\n\n        // read supply rate magnifier from Vault `vaultVariables2` located in storage slot 1, 16 bits from 0-15\n        return (IFluidVault(normalColVault_).readFromStorage(bytes32(uint256(1)))) & X16;\n    }\n\n    /// @notice returns the currently configured borrow rate magnifier at the `vault_`\n    /// @param normalDebtVault_ The address of the NORMAL DEBT vault to query.\n    /// @return The current borrow rate magnifier value.\n    function currentBorrowRateMagnifier(address normalDebtVault_) public view returns (uint256) {\n        (, bool isSmartDebt_) = getVaultType(normalDebtVault_);\n        if (isSmartDebt_) {\n            revert FluidConfigError(ErrorTypes.VaultFeeRewardsAuth__InvalidVaultType);\n        }\n\n        // read borrow rate magnifier from Vault `vaultVariables2` located in storage slot 1, 16 bits from 16-31\n        return (IFluidVault(normalDebtVault_).readFromStorage(bytes32(uint256(1))) >> 16) & X16;\n    }\n\n    /// @notice returns the currently configured supply rate at the `vault_`\n    /// @param smartColVault_ The address of the SMART COL vault to query.\n    /// @return supplyRate_ The current supply rate value.\n    function currentSupplyRate(address smartColVault_) public view returns (int256 supplyRate_) {\n        (bool isSmartCol_, ) = getVaultType(smartColVault_);\n        if (!isSmartCol_) {\n            revert FluidConfigError(ErrorTypes.VaultFeeRewardsAuth__InvalidVaultType);\n        }\n        uint256 supplyRateMagnifier_ = (IFluidVault(smartColVault_).readFromStorage(bytes32(uint256(1)))) & X16;\n\n        // in case of smart collateral supply magnifier bits stores supply interest rate positive or negative\n        // negative meaning charging users, positive means incentivizing users\n        supplyRate_ = int256((supplyRateMagnifier_ >> 1) & X15);\n        // if first bit == 1 then positive else negative\n        if ((supplyRateMagnifier_ & 1) == 0) {\n            supplyRate_ = -supplyRate_;\n        }\n    }\n\n    /// @notice returns the currently configured borrow rate at the `vault_`\n    /// @param smartDebtVault_ The address of the SMART DEBT vault to query.\n    /// @return borrowRate_ The current borrow rate value.\n    function currentBorrowRate(address smartDebtVault_) public view returns (int256 borrowRate_) {\n        (, bool isSmartDebt_) = getVaultType(smartDebtVault_);\n        if (!isSmartDebt_) {\n            revert FluidConfigError(ErrorTypes.VaultFeeRewardsAuth__InvalidVaultType);\n        }\n\n        uint256 borrowRateMagnifier_ = (IFluidVault(smartDebtVault_).readFromStorage(bytes32(uint256(1))) >> 16) & X16;\n\n        // in case of smart debt borrow magnifier bits stores borrow interest rate positive or negative\n        // negative meaning incentivizing users, positive means charging users\n        borrowRate_ = int256((borrowRateMagnifier_ >> 1) & X15);\n        // if first bit == 1 then positive else negative\n        if ((borrowRateMagnifier_ & 1) == 0) {\n            borrowRate_ = -borrowRate_;\n        }\n    }\n}\n"
    },
    "contracts/config/withdrawLimitAuth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { LiquidityCalcs } from \"../../libraries/liquidityCalcs.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nabstract contract Structs {\n    struct UserSupplyHistory {\n        uint40 initialDailyTimestamp;\n        uint40 initialHourlyTimestamp;\n        uint8 rebalancesIn1Hour;\n        uint8 rebalancesIn24Hours;\n        uint160 leastDailyUserSupply;\n    }\n}\n\nabstract contract Events {\n    /// @notice emitted when rebalancer successfully changes the withdrawal limit\n    event LogRebalanceWithdrawalLimit(address user, address token, uint256 newLimit);\n\n    /// @notice emitted when multisig successfully changes the withdrawal limit\n    event LogSetWithdrawalLimit(address user, address token, uint256 newLimit);\n}\n\nabstract contract Constants {\n    uint256 internal constant X64 = 0xffffffffffffffff;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    address public immutable TEAM_MULTISIG;\n\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n\n    IFluidLiquidity public immutable LIQUIDITY;\n\n    uint256 internal constant MAX_PERCENT_CHANGE = 5; // 5% max percent change at once\n}\n\nabstract contract Variables is Structs, Constants {\n    mapping(address => mapping(address => UserSupplyHistory)) public userData;\n}\n\ncontract FluidWithdrawLimitAuth is Variables, Error, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__InvalidParams);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract)\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__Unauthorized);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is the team multisig\n    modifier onlyMultisig() {\n        if (msg.sender != TEAM_MULTISIG) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(\n        IFluidReserveContract reserveContract_,\n        address liquidity_,\n        address multisig_\n    ) validAddress(address(reserveContract_)) validAddress(liquidity_) validAddress(multisig_) {\n        RESERVE_CONTRACT = reserveContract_;\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        TEAM_MULTISIG = multisig_;\n    }\n\n    /// @notice updates the withdrawal limit for a specific token of a user in the liquidity\n    /// @dev This function can only be called by the rebalancer\n    /// @param user_ The address of the user for which to set the withdrawal limit\n    /// @param token_ The address of the token for which to set the withdrawal limit\n    /// @param newLimit_ The new withdrawal limit to be set\n    function rebalanceWithdrawalLimit(address user_, address token_, uint256 newLimit_) external onlyRebalancer {\n        // getting the user supply data from liquidity\n        uint256 userSupplyData_ = LIQUIDITY.readFromStorage(\n            LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n                user_,\n                token_\n            )\n        );\n\n        uint256 initialUserSupply_ = BigMathMinified.fromBigNumber(\n            (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64,\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        );\n\n        uint256 initialWithdrawLimit_ = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(\n            userSupplyData_,\n            initialUserSupply_\n        );\n\n        if (initialUserSupply_ == 0) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__NoUserSupply);\n        }\n\n        uint256 maxPercentOfCurrentLimit_ = (initialWithdrawLimit_ * (100 - MAX_PERCENT_CHANGE)) / 100;\n\n        if (newLimit_ < maxPercentOfCurrentLimit_) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__ExcessPercentageDifference);\n        }\n\n        // getting the limit history from the contract\n        UserSupplyHistory memory userSupplyHistory_ = userData[user_][token_];\n\n        // if one day is crossed\n        if (block.timestamp - uint256(userSupplyHistory_.initialDailyTimestamp) > 1 days) {\n            userSupplyHistory_.leastDailyUserSupply = uint128(newLimit_);\n            userSupplyHistory_.rebalancesIn24Hours = 1;\n            userSupplyHistory_.rebalancesIn1Hour = 1;\n            userSupplyHistory_.initialDailyTimestamp = uint40(block.timestamp);\n            userSupplyHistory_.initialHourlyTimestamp = uint40(block.timestamp);\n        } else {\n            // if one day is not crossed\n            if (newLimit_ < userSupplyHistory_.leastDailyUserSupply) {\n                if (userSupplyHistory_.rebalancesIn24Hours == 4) {\n                    revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__DailyLimitReached);\n                }\n                if (block.timestamp - uint256(userSupplyHistory_.initialHourlyTimestamp) > 1 hours) {\n                    userSupplyHistory_.rebalancesIn1Hour = 1;\n                    userSupplyHistory_.rebalancesIn24Hours += 1;\n                    userSupplyHistory_.initialHourlyTimestamp = uint40(block.timestamp);\n                } else {\n                    if (userSupplyHistory_.rebalancesIn1Hour == 2) {\n                        revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__HourlyLimitReached);\n                    }\n                    userSupplyHistory_.rebalancesIn1Hour += 1;\n                    userSupplyHistory_.rebalancesIn24Hours += 1;\n                }\n                userSupplyHistory_.leastDailyUserSupply = uint128(newLimit_);\n            }\n        }\n        userData[user_][token_] = userSupplyHistory_;\n        LIQUIDITY.updateUserWithdrawalLimit(user_, token_, newLimit_);\n        emit LogRebalanceWithdrawalLimit(user_, token_, newLimit_);\n    }\n\n    /// @notice Sets the withdrawal limit for a specific token of a user in the liquidity\n    /// @dev This function can only be called by team multisig\n    /// @param user_ The address of the user for which to set the withdrawal limit\n    /// @param token_ The address of the token for which to set the withdrawal limit\n    /// @param newLimit_ The new withdrawal limit to be set\n    function setWithdrawalLimit(address user_, address token_, uint256 newLimit_) external onlyMultisig {\n        LIQUIDITY.updateUserWithdrawalLimit(user_, token_, newLimit_);\n        emit LogSetWithdrawalLimit(user_, token_, newLimit_);\n    }\n\n    function getUsersData(\n        address[] memory users_,\n        address[] memory tokens_\n    ) public view returns (uint256[] memory initialUsersSupply_, uint256[] memory initialWithdrawLimit_) {\n        if (users_.length != tokens_.length) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__InvalidParams);\n        }\n\n        initialUsersSupply_ = new uint256[](users_.length);\n        initialWithdrawLimit_ = new uint256[](users_.length);\n\n        for (uint i; i < tokens_.length; i++) {\n            uint256 userSupplyData_ = LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n                    users_[i],\n                    tokens_[i]\n                )\n            );\n\n            initialUsersSupply_[i] = BigMathMinified.fromBigNumber(\n                (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n            initialWithdrawLimit_[i] = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(\n                userSupplyData_,\n                initialUsersSupply_[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/config/withdrawLimitAuthDex/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { DexSlotsLink } from \"../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../libraries/dexCalcs.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { IFluidDexT1 } from \"../../protocols/dex/interfaces/iDexT1.sol\";\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\ninterface IFluidDexT1Admin {\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, uint256 newLimit_) external;\n}\n\nabstract contract Structs {\n    struct UserSupplyHistory {\n        uint40 initialDailyTimestamp;\n        uint40 initialHourlyTimestamp;\n        uint8 rebalancesIn1Hour;\n        uint8 rebalancesIn24Hours;\n        uint160 leastDailyUserSupply;\n    }\n}\n\nabstract contract Events {\n    /// @notice emitted when rebalancer successfully changes the withdrawal limit\n    event LogRebalanceWithdrawalLimit(address dex, address user, uint256 newLimit);\n\n    /// @notice emitted when multisig successfully changes the withdrawal limit\n    event LogSetWithdrawalLimit(address dex, address user, uint256 newLimit);\n}\n\nabstract contract Constants {\n    uint256 internal constant X64 = 0xffffffffffffffff;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    address public immutable TEAM_MULTISIG;\n\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n\n    uint256 internal constant MAX_PERCENT_CHANGE = 5; // 5% max percent change at once\n}\n\nabstract contract Variables is Structs, Constants {\n    mapping(address => UserSupplyHistory) public userData;\n}\n\ncontract FluidWithdrawLimitAuthDex is Variables, Error, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__InvalidParams);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract)\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__Unauthorized);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is the team multisig\n    modifier onlyMultisig() {\n        if (msg.sender != TEAM_MULTISIG) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(\n        IFluidReserveContract reserveContract_,\n        address multisig_\n    ) validAddress(address(reserveContract_)) validAddress(multisig_) {\n        RESERVE_CONTRACT = reserveContract_;\n        TEAM_MULTISIG = multisig_;\n    }\n\n    /// @notice updates the withdrawal limit for a specific user at a dex\n    /// @dev This function can only be called by the rebalancer\n    /// @param dex_ The address of the dex\n    /// @param user_ The address of the user for which to set the withdrawal limit\n    /// @param newLimit_ The new withdrawal limit to be set\n    function rebalanceWithdrawalLimit(address dex_, address user_, uint256 newLimit_) external onlyRebalancer {\n        // getting the user supply data from the dex\n        uint256 userSupplyData_ = IFluidDexT1(dex_).readFromStorage(\n            DexSlotsLink.calculateMappingStorageSlot(DexSlotsLink.DEX_USER_SUPPLY_MAPPING_SLOT, user_)\n        );\n\n        uint256 initialUserSupply_ = BigMathMinified.fromBigNumber(\n            (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64,\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        );\n\n        uint256 initialWithdrawLimit_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, initialUserSupply_);\n\n        if (initialUserSupply_ == 0) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__NoUserSupply);\n        }\n\n        uint256 maxPercentOfCurrentLimit_ = (initialWithdrawLimit_ * (100 - MAX_PERCENT_CHANGE)) / 100;\n\n        if (newLimit_ < maxPercentOfCurrentLimit_) {\n            revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__ExcessPercentageDifference);\n        }\n\n        // getting the limit history from the contract\n        UserSupplyHistory memory userSupplyHistory_ = userData[user_];\n\n        // if one day is crossed\n        if (block.timestamp - uint256(userSupplyHistory_.initialDailyTimestamp) > 1 days) {\n            userSupplyHistory_.leastDailyUserSupply = uint128(newLimit_);\n            userSupplyHistory_.rebalancesIn24Hours = 1;\n            userSupplyHistory_.rebalancesIn1Hour = 1;\n            userSupplyHistory_.initialDailyTimestamp = uint40(block.timestamp);\n            userSupplyHistory_.initialHourlyTimestamp = uint40(block.timestamp);\n        } else {\n            // if one day is not crossed\n            if (newLimit_ < userSupplyHistory_.leastDailyUserSupply) {\n                if (userSupplyHistory_.rebalancesIn24Hours == 4) {\n                    revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__DailyLimitReached);\n                }\n                if (block.timestamp - uint256(userSupplyHistory_.initialHourlyTimestamp) > 1 hours) {\n                    userSupplyHistory_.rebalancesIn1Hour = 1;\n                    userSupplyHistory_.rebalancesIn24Hours += 1;\n                    userSupplyHistory_.initialHourlyTimestamp = uint40(block.timestamp);\n                } else {\n                    if (userSupplyHistory_.rebalancesIn1Hour == 2) {\n                        revert FluidConfigError(ErrorTypes.WithdrawLimitAuth__HourlyLimitReached);\n                    }\n                    userSupplyHistory_.rebalancesIn1Hour += 1;\n                    userSupplyHistory_.rebalancesIn24Hours += 1;\n                }\n                userSupplyHistory_.leastDailyUserSupply = uint128(newLimit_);\n            }\n        }\n        userData[user_] = userSupplyHistory_;\n        IFluidDexT1Admin(dex_).updateUserWithdrawalLimit(user_, newLimit_);\n        emit LogRebalanceWithdrawalLimit(dex_, user_, newLimit_);\n    }\n\n    /// @notice Sets the withdrawal limit for a specific user at a dex\n    /// @dev This function can only be called by team multisig\n    /// @param dex_ The address of the dex\n    /// @param user_ The address of the user for which to set the withdrawal limit\n    /// @param newLimit_ The new withdrawal limit to be set\n    function setWithdrawalLimit(address dex_, address user_, uint256 newLimit_) external onlyMultisig {\n        IFluidDexT1Admin(dex_).updateUserWithdrawalLimit(user_, newLimit_);\n        emit LogSetWithdrawalLimit(dex_, user_, newLimit_);\n    }\n\n    function getUsersData(\n        address dex_,\n        address[] memory users_\n    ) public view returns (uint256[] memory initialUsersSupply_, uint256[] memory initialWithdrawLimit_) {\n        initialUsersSupply_ = new uint256[](users_.length);\n        initialWithdrawLimit_ = new uint256[](users_.length);\n\n        for (uint i; i < users_.length; i++) {\n            uint256 userSupplyData_ = IFluidDexT1(dex_).readFromStorage(\n                DexSlotsLink.calculateMappingStorageSlot(DexSlotsLink.DEX_USER_SUPPLY_MAPPING_SLOT, users_[i])\n            );\n\n            initialUsersSupply_[i] = BigMathMinified.fromBigNumber(\n                (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n            initialWithdrawLimit_[i] = DexCalcs.calcWithdrawalLimitBeforeOperate(\n                userSupplyData_,\n                initialUsersSupply_[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/infiniteProxy/interfaces/iProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IProxy {\n    function setAdmin(address newAdmin_) external;\n\n    function setDummyImplementation(address newDummyImplementation_) external;\n\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\n\n    function removeImplementation(address implementation_) external;\n\n    function getAdmin() external view returns (address);\n\n    function getDummyImplementation() external view returns (address);\n\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\n\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/bigMathMinified.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\nlibrary BigMathMinified {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/bytesSliceAndConcat.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary BytesSliceAndConcat {\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesConcat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    ) internal pure returns (bytes memory tempBytes) {\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesSlice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory tempBytes) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/libraries/dexCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\nimport { DexSlotsLink } from \"./dexSlotsLink.sol\";\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// @DEV ATTENTION: ON ANY CHANGES HERE, MAKE SURE THAT LOGIC IN VAULTS WILL STILL BE VALID.\n// SOME CODE THERE ASSUMES DEXCALCS == LIQUIDITYCALCS.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n/// @notice implements calculation methods used for Fluid Dex such as updated withdrawal / borrow limits.\nlibrary DexCalcs {\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) &\n            X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ = block.timestamp - ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ = block.timestamp - ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n}\n"
    },
    "contracts/libraries/dexSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\nlibrary DexSlotsLink {\n    /// @dev storage slot for variables at Dex\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\n    /// @dev storage slot for variables2 at Dex\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\n    /// @dev storage slot for total supply shares at Dex\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\n    /// @dev storage slot for user supply mapping at Dex\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\n    /// @dev storage slot for total borrow shares at Dex\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\n    /// @dev storage slot for user borrow mapping at Dex\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\n    /// @dev storage slot for oracle mapping at Dex\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\n    /// @dev storage slot for range and threshold shifts at Dex\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\n    /// @dev storage slot for center price shift at Dex\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n\n    /***********************************|\n    |           SafeApprove             | \n    |__________________________________*/\n\n    /// @notice thrown when safe approve from for an ERC20 fails\n    uint256 internal constant SafeApprove__ApproveFailed = 81001;\n}\n"
    },
    "contracts/libraries/fluidProtocolTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ninterface IFluidProtocol {\n    function TYPE() external view returns (uint256);\n}\n\n/// @notice implements helper methods to filter Fluid protocols by a certain type\nlibrary FluidProtocolTypes {\n    uint256 internal constant VAULT_T1_TYPE = 10000; // VaultT1 borrow protocol type vaults\n    uint256 internal constant VAULT_T2_SMART_COL_TYPE = 20000; // DEX protocol type vault\n    uint256 internal constant VAULT_T3_SMART_DEBT_TYPE = 30000; // DEX protocol type vault\n    uint256 internal constant VAULT_T4_SMART_COL_SMART_DEBT_TYPE = 40000; // DEX protocol type vault\n\n    /// @dev filters input `addresses_` by protocol `type_`. Input addresses must be actual Fluid protocols, otherwise\n    ///      they would be wrongly assumed to be VaultT1 even if they are not Fluid VaultT1 smart contracts.\n    ///      `type_` must be a listed constant type of this library.\n    ///      Example usage is to filter all vault addresses at the Vault factory by a certain type, e.g. to not include\n    ///      DEX protocol type vaults.\n    function filterBy(address[] memory addresses_, uint256 type_) internal view returns (address[] memory filtered_) {\n        uint256 curType_;\n        uint256 filteredProtocols_ = addresses_.length;\n        for (uint256 i; i < addresses_.length; ) {\n            try IFluidProtocol(addresses_[i]).TYPE() returns (uint256 protocolType_) {\n                curType_ = protocolType_;\n            } catch {\n                curType_ = VAULT_T1_TYPE;\n            }\n\n            if (curType_ != type_) {\n                addresses_[i] = address(0);\n                --filteredProtocols_;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        filtered_ = new address[](filteredProtocols_);\n        uint256 index_;\n        unchecked {\n            for (uint256 i; i < addresses_.length; ) {\n                if (addresses_[i] != address(0)) {\n                    filtered_[index_] = addresses_[i];\n                    ++index_;\n                }\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/liquidityCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\nimport { LiquiditySlotsLink } from \"./liquiditySlotsLink.sol\";\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\n\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\n/// borrow rate, withdrawal / borrow limits, revenue amount.\nlibrary LiquidityCalcs {\n    error FluidLiquidityCalcsError(uint256 errorId_);\n\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\n    event BorrowRateMaxCap();\n\n    /// @dev constants as from Liquidity variables.sol\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X15 = 0x7fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                  CALC EXCHANGE PRICES                  /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\n    function calcExchangePrices(\n        uint256 exchangePricesAndConfig_\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\n        // Extracting exchange prices\n        supplyExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\n            X64;\n        borrowExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\n            X64;\n\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\n        }\n\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\n\n        unchecked {\n            // last timestamp can not be > current timestamp\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\n\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\n                X15;\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // calculate new borrow exchange price.\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\n            borrowExchangePrice_ +=\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\n\n            // FOR SUPPLY EXCHANGE PRICE:\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\n            //\n            // Example:\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\n            // yield is 10 (so half a year must have passed).\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 20%) = 62,5%\n            // supplyRate = (40% * (100% - 10%)) * = 36% * 62,5% = 22.5%\n            // increase in supplyExchangePrice, assuming 100 as previous price.\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\n\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\n\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\n\n            if (temp_ == 1) {\n                // if no raw supply: no exchange price update needed\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\n            if (temp_ & 1 == 1) {\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n                temp_ = temp_ >> 1;\n\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\n                // in the if statement a little above.\n\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\n                // so ratioSupplyYield must come out as 2.5 (250%).\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\n                temp_ =\n                    // utilization * (100% + 100% / supplyRatio)\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\n                    (FOUR_DECIMALS);\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\n            } else {\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n                temp_ = temp_ >> 1;\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\n\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\n                temp_ =\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\n                    (1e27 *\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\n                        (FOUR_DECIMALS + temp_)) /\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\n            }\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\n\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\n            if (borrowRatio_ & 1 == 1) {\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\n\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\n            } else {\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\n            }\n\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\n\n            // 2. calculate supply rate\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\n            // but more suppliers not earning interest.\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\n                temp_ * // ratioSupplyYield\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\n\n            // 3. calculate increase in supply exchange price\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                     CALC REVENUE                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\n    /// and the current balance of the Fluid liquidity contract for the token.\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\n    /// @return revenueAmount_ collectable revenue amount\n    function calcRevenue(\n        uint256 totalAmounts_,\n        uint256 exchangePricesAndConfig_,\n        uint256 liquidityTokenBalance_\n    ) internal view returns (uint256 revenueAmount_) {\n        // @dev no need to super-optimize this method as it is only used by admin\n\n        // calculate the new exchange prices based on earned interest\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\n\n        // total supply = interest free + with interest converted from raw\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\n\n        if (totalSupply_ > 0) {\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\n            // ensure there is no possible case because of rounding etc. where this would revert,\n            // explicitly check if >\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\n            // can only be revenue.\n        } else {\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\n            revenueAmount_ = liquidityTokenBalance_;\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ =\n                block.timestamp -\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ =\n                block.timestamp -\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC RATES                        /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev Calculates new borrow rate from utilization for a token\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\n        // extract rate version: 4 bits (0xF) starting from bit 0\n        uint256 rateVersion_ = (rateData_ & 0xF);\n\n        if (rateVersion_ == 1) {\n            rate_ = calcRateV1(rateData_, utilization_);\n        } else if (rateVersion_ == 2) {\n            rate_ = calcRateV2(rateData_, utilization_);\n        } else {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\n        }\n\n        if (rate_ > X16) {\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\n            // this is unlikely to ever happen if configs stay within expected levels.\n            rate_ = X16;\n            // emit event to more easily become aware\n            emit BorrowRateMaxCap();\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e2 precision\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v1 (one kink) ------------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // else utilization is greater than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\n            x1_ = kink1_;\n            x2_ = FOUR_DECIMALS; // 100%\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e4 precision\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v2 (two kinks) -----------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 156 bits => 100-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink1\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\n            if (utilization_ < kink2_) {\n                // if utilization is less than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                x1_ = kink1_;\n                x2_ = kink2_;\n            } else {\n                // else utilization is greater than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\n                x1_ = kink2_;\n                x2_ = FOUR_DECIMALS;\n            }\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\n    function getTotalSupply(\n        uint256 totalAmounts_,\n        uint256 supplyExchangePrice_\n    ) internal pure returns (uint256 totalSupply_) {\n        // totalSupply_ => supplyInterestFree\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\n    function getTotalBorrow(\n        uint256 totalAmounts_,\n        uint256 borrowExchangePrice_\n    ) internal pure returns (uint256 totalBorrow_) {\n        // totalBorrow_ => borrowInterestFree\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n}\n"
    },
    "contracts/libraries/liquiditySlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\nlibrary LiquiditySlotsLink {\n    /// @dev storage slot for status at Liquidity\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\n    /// @dev storage slot for auths mapping at Liquidity\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\n    /// @dev storage slot for guardians mapping at Liquidity\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\n    /// @dev storage slot for user class mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\n    /// @dev storage slot for rateData mapping at Liquidity\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\n    /// @dev storage slot for totalAmounts mapping at Liquidity\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\n    /// @dev storage slot for user supply double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\n    /// @dev storage slot for user borrow double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // ExchangePricesAndConfig\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\n\n    // RateData:\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\n    // RateData: V1\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\n    // RateData: V2\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\n\n    // TotalAmounts\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\n\n    // Configs2\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/safeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\n\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\nlibrary SafeTransfer {\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 20000; // pass max. 20k gas for native transfers\n\n    error FluidSafeTransferError(uint256 errorId_);\n\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from_\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of `token_` to `to_`.\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of ` native token to `to_`.\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\n    function safeTransferNative(address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n}\n"
    },
    "contracts/libraries/storageRead.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements a method to read uint256 data from storage at a bytes32 storage slot key.\ncontract StorageRead {\n    function readFromStorage(bytes32 slot_) public view returns (uint256 result_) {\n        assembly {\n            result_ := sload(slot_) // read value from the storage slot\n        }\n    }\n}\n"
    },
    "contracts/libraries/tickMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that calculates number \"tick\" and \"ratioX96\" from this: ratioX96 = (1.0015^tick) * 2^96\n/// @notice this library is used in Fluid Vault protocol for optimiziation.\n/// @dev \"tick\" supports between -32767 and 32767. \"ratioX96\" supports between 37075072 and 169307877264527972847801929085841449095838922544595\nlibrary TickMath {\n    /// The minimum tick that can be passed in getRatioAtTick. 1.0015**-32767\n    int24 internal constant MIN_TICK = -32767;\n    /// The maximum tick that can be passed in getRatioAtTick. 1.0015**32767\n    int24 internal constant MAX_TICK = 32767;\n\n    uint256 internal constant FACTOR00 = 0x100000000000000000000000000000000;\n    uint256 internal constant FACTOR01 = 0xff9dd7de423466c20352b1246ce4856f; // 2^128/1.0015**1 = 339772707859149738855091969477551883631\n    uint256 internal constant FACTOR02 = 0xff3bd55f4488ad277531fa1c725a66d0; // 2^128/1.0015**2 = 339263812140938331358054887146831636176\n    uint256 internal constant FACTOR03 = 0xfe78410fd6498b73cb96a6917f853259; // 2^128/1.0015**4 = 338248306163758188337119769319392490073\n    uint256 internal constant FACTOR04 = 0xfcf2d9987c9be178ad5bfeffaa123273; // 2^128/1.0015**8 = 336226404141693512316971918999264834163\n    uint256 internal constant FACTOR05 = 0xf9ef02c4529258b057769680fc6601b3; // 2^128/1.0015**16 = 332218786018727629051611634067491389875\n    uint256 internal constant FACTOR06 = 0xf402d288133a85a17784a411f7aba082; // 2^128/1.0015**32 = 324346285652234375371948336458280706178\n    uint256 internal constant FACTOR07 = 0xe895615b5beb6386553757b0352bda90; // 2^128/1.0015**64 = 309156521885964218294057947947195947664\n    uint256 internal constant FACTOR08 = 0xd34f17a00ffa00a8309940a15930391a; // 2^128/1.0015**128 = 280877777739312896540849703637713172762 \n    uint256 internal constant FACTOR09 = 0xae6b7961714e20548d88ea5123f9a0ff; // 2^128/1.0015**256 = 231843708922198649176471782639349113087\n    uint256 internal constant FACTOR10 = 0x76d6461f27082d74e0feed3b388c0ca1; // 2^128/1.0015**512 = 157961477267171621126394973980180876449\n    uint256 internal constant FACTOR11 = 0x372a3bfe0745d8b6b19d985d9a8b85bb; // 2^128/1.0015**1024 = 73326833024599564193373530205717235131\n    uint256 internal constant FACTOR12 = 0x0be32cbee48979763cf7247dd7bb539d; // 2^128/1.0015**2048 = 15801066890623697521348224657638773661\n    uint256 internal constant FACTOR13 = 0x8d4f70c9ff4924dac37612d1e2921e;   // 2^128/1.0015**4096 = 733725103481409245883800626999235102\n    uint256 internal constant FACTOR14 = 0x4e009ae5519380809a02ca7aec77;     // 2^128/1.0015**8192 = 1582075887005588088019997442108535\n    uint256 internal constant FACTOR15 = 0x17c45e641b6e95dee056ff10;         // 2^128/1.0015**16384 = 7355550435635883087458926352\n\n    /// The minimum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MIN_TICK). ~ Equivalent to `(1 << 96) * (1.0015**-32767)`\n    uint256 internal constant MIN_RATIOX96 = 37075072;\n    /// The maximum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MAX_TICK).\n    /// ~ Equivalent to `(1 << 96) * (1.0015**32767)`, rounding etc. leading to minor difference\n    uint256 internal constant MAX_RATIOX96 = 169307877264527972847801929085841449095838922544595;\n\n    uint256 internal constant ZERO_TICK_SCALED_RATIO = 0x1000000000000000000000000; // 1 << 96 // 79228162514264337593543950336\n    uint256 internal constant _1E26 = 1e26;\n\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return ratioX96 ratio = (debt amount/collateral amount)\n    function getRatioAtTick(int tick) internal pure returns (uint256 ratioX96) {\n        assembly {\n            let absTick_ := sub(xor(tick, sar(255, tick)), sar(255, tick))\n\n            if gt(absTick_, MAX_TICK) {\n                revert(0, 0)\n            }\n            let factor_ := FACTOR00\n            if and(absTick_, 0x1) {\n                factor_ := FACTOR01\n            }\n            if and(absTick_, 0x2) {\n                factor_ := shr(128, mul(factor_, FACTOR02))\n            }\n            if and(absTick_, 0x4) {\n                factor_ := shr(128, mul(factor_, FACTOR03))\n            }\n            if and(absTick_, 0x8) {\n                factor_ := shr(128, mul(factor_, FACTOR04))\n            }\n            if and(absTick_, 0x10) {\n                factor_ := shr(128, mul(factor_, FACTOR05))\n            }\n            if and(absTick_, 0x20) {\n                factor_ := shr(128, mul(factor_, FACTOR06))\n            }\n            if and(absTick_, 0x40) {\n                factor_ := shr(128, mul(factor_, FACTOR07))\n            }\n            if and(absTick_, 0x80) {\n                factor_ := shr(128, mul(factor_, FACTOR08))\n            }\n            if and(absTick_, 0x100) {\n                factor_ := shr(128, mul(factor_, FACTOR09))\n            }\n            if and(absTick_, 0x200) {\n                factor_ := shr(128, mul(factor_, FACTOR10))\n            }\n            if and(absTick_, 0x400) {\n                factor_ := shr(128, mul(factor_, FACTOR11))\n            }\n            if and(absTick_, 0x800) {\n                factor_ := shr(128, mul(factor_, FACTOR12))\n            }\n            if and(absTick_, 0x1000) {\n                factor_ := shr(128, mul(factor_, FACTOR13))\n            }\n            if and(absTick_, 0x2000) {\n                factor_ := shr(128, mul(factor_, FACTOR14))\n            }\n            if and(absTick_, 0x4000) {\n                factor_ := shr(128, mul(factor_, FACTOR15))\n            }\n\n            let precision_ := 0\n            if iszero(and(tick, 0x8000000000000000000000000000000000000000000000000000000000000000)) {\n                factor_ := div(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, factor_)\n                // we round up in the division so getTickAtRatio of the output price is always consistent\n                if mod(factor_, 0x100000000) {\n                    precision_ := 1\n                }\n            }\n            ratioX96 := add(shr(32, factor_), precision_)\n        }\n    }\n\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\n    /// @dev Throws if ratioX96 > max ratio || ratioX96 < min ratio\n    /// @param ratioX96 The input ratio; ratio = (debt amount/collateral amount)\n    /// @return tick The output tick for the above formula. Returns in round down form. if tick is 123.23 then 123, if tick is -123.23 then returns -124\n    /// @return perfectRatioX96 perfect ratio for the above tick\n    function getTickAtRatio(uint256 ratioX96) internal pure returns (int tick, uint perfectRatioX96) {\n        assembly {\n            if or(gt(ratioX96, MAX_RATIOX96), lt(ratioX96, MIN_RATIOX96)) {\n                revert(0, 0)\n            }\n\n            let cond := lt(ratioX96, ZERO_TICK_SCALED_RATIO)\n            let factor_\n\n            if iszero(cond) {\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\n                factor_ := div(mul(ratioX96, _1E26), ZERO_TICK_SCALED_RATIO)\n            }\n            if cond {\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\n                factor_ := div(mul(ZERO_TICK_SCALED_RATIO, _1E26), ratioX96)\n            }\n\n            // put in https://www.wolframalpha.com/ whole equation: (1.0015^tick) * 2^96 * 10^26 / 79228162514264337593543950336\n\n            // for tick = 16384\n            // ratioX96 = (1.0015^16384) * 2^96 = 3665252098134783297721995888537077351735\n            // 3665252098134783297721995888537077351735 * 10^26 / 79228162514264337593543950336 =\n            // 4626198540796508716348404308345255985.06131964639489434655721\n            if iszero(lt(factor_, 4626198540796508716348404308345255985)) {\n                tick := or(tick, 0x4000)\n                factor_ := div(mul(factor_, _1E26), 4626198540796508716348404308345255985)\n            }\n            // for tick = 8192\n            // ratioX96 = (1.0015^8192) * 2^96 = 17040868196391020479062776466509865\n            // 17040868196391020479062776466509865 * 10^26 / 79228162514264337593543950336 =\n            // 21508599537851153911767490449162.3037648642153898377655505172\n            if iszero(lt(factor_, 21508599537851153911767490449162)) {\n                tick := or(tick, 0x2000)\n                factor_ := div(mul(factor_, _1E26), 21508599537851153911767490449162)\n            }\n            // for tick = 4096\n            // ratioX96 = (1.0015^4096) * 2^96 = 36743933851015821532611831851150\n            // 36743933851015821532611831851150 * 10^26 / 79228162514264337593543950336 =\n            // 46377364670549310883002866648.9777607649742626173648716941385\n            if iszero(lt(factor_, 46377364670549310883002866649)) {\n                tick := or(tick, 0x1000)\n                factor_ := div(mul(factor_, _1E26), 46377364670549310883002866649)\n            }\n            // for tick = 2048\n            // ratioX96 = (1.0015^2048) * 2^96 = 1706210527034005899209104452335\n            // 1706210527034005899209104452335 * 10^26 / 79228162514264337593543950336 =\n            // 2153540449365864845468344760.06357108484096046743300420319322\n            if iszero(lt(factor_, 2153540449365864845468344760)) {\n                tick := or(tick, 0x800)\n                factor_ := div(mul(factor_, _1E26), 2153540449365864845468344760)\n            }\n            // for tick = 1024\n            // ratioX96 = (1.0015^1024) * 2^96 = 367668226692760093024536487236\n            // 367668226692760093024536487236 * 10^26 / 79228162514264337593543950336 =\n            // 464062544207767844008185024.950588990554136265212906454481127\n            if iszero(lt(factor_, 464062544207767844008185025)) {\n                tick := or(tick, 0x400)\n                factor_ := div(mul(factor_, _1E26), 464062544207767844008185025)\n            }\n            // for tick = 512\n            // ratioX96 = (1.0015^512) * 2^96 = 170674186729409605620119663668\n            // 170674186729409605620119663668 * 10^26 / 79228162514264337593543950336 =\n            // 215421109505955298802281577.031879604792139232258508172947569\n            if iszero(lt(factor_, 215421109505955298802281577)) {\n                tick := or(tick, 0x200)\n                factor_ := div(mul(factor_, _1E26), 215421109505955298802281577)\n            }\n            // for tick = 256\n            // ratioX96 = (1.0015^256) * 2^96 = 116285004205991934861656513301\n            // 116285004205991934861656513301 * 10^26 / 79228162514264337593543950336 =\n            // 146772309890508740607270614.667650899656438875541505058062410\n            if iszero(lt(factor_, 146772309890508740607270615)) {\n                tick := or(tick, 0x100)\n                factor_ := div(mul(factor_, _1E26), 146772309890508740607270615)\n            }\n            // for tick = 128\n            // ratioX96 = (1.0015^128) * 2^96 = 95984619659632141743747099590\n            // 95984619659632141743747099590 * 10^26 / 79228162514264337593543950336 =\n            // 121149622323187099817270416.157248837742741760456796835775887\n            if iszero(lt(factor_, 121149622323187099817270416)) {\n                tick := or(tick, 0x80)\n                factor_ := div(mul(factor_, _1E26), 121149622323187099817270416)\n            }\n            // for tick = 64\n            // ratioX96 = (1.0015^64) * 2^96 = 87204845308406958006717891124\n            // 87204845308406958006717891124 * 10^26 / 79228162514264337593543950336 =\n            // 110067989135437147685980801.568068573422377364214113968609839\n            if iszero(lt(factor_, 110067989135437147685980801)) {\n                tick := or(tick, 0x40)\n                factor_ := div(mul(factor_, _1E26), 110067989135437147685980801)\n            }\n            // for tick = 32\n            // ratioX96 = (1.0015^32) * 2^96 = 83120873769022354029916374475\n            // 83120873769022354029916374475 * 10^26 / 79228162514264337593543950336 =\n            // 104913292358707887270979599.831816586773651266562785765558183\n            if iszero(lt(factor_, 104913292358707887270979600)) {\n                tick := or(tick, 0x20)\n                factor_ := div(mul(factor_, _1E26), 104913292358707887270979600)\n            }\n            // for tick = 16\n            // ratioX96 = (1.0015^16) * 2^96 = 81151180492336368327184716176\n            // 81151180492336368327184716176 * 10^26 / 79228162514264337593543950336 =\n            // 102427189924701091191840927.762844039579442328381455567932128\n            if iszero(lt(factor_, 102427189924701091191840928)) {\n                tick := or(tick, 0x10)\n                factor_ := div(mul(factor_, _1E26), 102427189924701091191840928)\n            }\n            // for tick = 8\n            // ratioX96 = (1.0015^8) * 2^96 = 80183906840906820640659903620\n            // 80183906840906820640659903620 * 10^26 / 79228162514264337593543950336 =\n            // 101206318935480056907421312.890625\n            if iszero(lt(factor_, 101206318935480056907421313)) {\n                tick := or(tick, 0x8)\n                factor_ := div(mul(factor_, _1E26), 101206318935480056907421313)\n            }\n            // for tick = 4\n            // ratioX96 = (1.0015^4) * 2^96 = 79704602139525152702959747603\n            // 79704602139525152702959747603 * 10^26 / 79228162514264337593543950336 =\n            // 100601351350506250000000000\n            if iszero(lt(factor_, 100601351350506250000000000)) {\n                tick := or(tick, 0x4)\n                factor_ := div(mul(factor_, _1E26), 100601351350506250000000000)\n            }\n            // for tick = 2\n            // ratioX96 = (1.0015^2) * 2^96 = 79466025265172787701084167660\n            // 79466025265172787701084167660 * 10^26 / 79228162514264337593543950336 =\n            // 100300225000000000000000000\n            if iszero(lt(factor_, 100300225000000000000000000)) {\n                tick := or(tick, 0x2)\n                factor_ := div(mul(factor_, _1E26), 100300225000000000000000000)\n            }\n            // for tick = 1\n            // ratioX96 = (1.0015^1) * 2^96 = 79347004758035734099934266261\n            // 79347004758035734099934266261 * 10^26 / 79228162514264337593543950336 =\n            // 100150000000000000000000000\n            if iszero(lt(factor_, 100150000000000000000000000)) {\n                tick := or(tick, 0x1)\n                factor_ := div(mul(factor_, _1E26), 100150000000000000000000000)\n            }\n            if iszero(cond) {\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\n                perfectRatioX96 := div(mul(ratioX96, _1E26), factor_)\n            }\n            if cond {\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\n                tick := not(tick)\n                perfectRatioX96 := div(mul(ratioX96, factor_), 100150000000000000000000000)\n            }\n            // perfect ratio should always be <= ratioX96\n            // not sure if it can ever be bigger but better to have extra checks\n            if gt(perfectRatioX96, ratioX96) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "contracts/liquidity/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    /// @notice struct to set borrow rate data for version 1\n    struct RateDataV1Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\n        uint256 kink;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink;\n        ///\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set borrow rate data for version 2\n    struct RateDataV2Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\n        uint256 kink1;\n        ///\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\n        uint256 kink2;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink1;\n        ///\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\n        uint256 rateAtUtilizationKink2;\n        ///\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set token config\n    struct TokenConfig {\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\n        uint256 fee;\n        ///\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\n        uint256 threshold;\n        ///\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\n        uint256 maxUtilization;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/liquidity/interfaces/iLiquidity.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IProxy } from \"../../infiniteProxy/interfaces/iProxy.sol\";\nimport { Structs as AdminModuleStructs } from \"../adminModule/structs.sol\";\n\ninterface IFluidLiquidityAdmin {\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\n    /// @param authsStatus_ array of structs setting allowed status for an address.\n    ///                     status true => add auth, false => remove auth\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\n\n    /// @notice adds/removes guardians. Only callable by Governance.\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\n    ///                         status true => add guardian, false => remove guardian\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\n\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\n    /// @param revenueCollector_  new revenue collector address\n    function updateRevenueCollector(address revenueCollector_) external;\n\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\n    /// @param newStatus_ new status\n    ///        status = 2 -> pause, status = 1 -> resume.\n    function changeStatus(uint256 newStatus_) external;\n\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\n\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\n\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\n    ///         Only callable by Auths.\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\n\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\n    ///         Only callable by Auths.\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\n\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param token_ token address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\n\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\n\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to pause operations for\n    /// @param supplyTokens_  token addresses to pause withdrawals for\n    /// @param borrowTokens_  token addresses to pause borrowings for\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to unpause operations for\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\n    /// @param borrowTokens_  token addresses to unpause borrowings for\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\n    /// @param tokens_  array of tokens to collect revenue for\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\n    function collectRevenue(address[] calldata tokens_) external;\n\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\n    /// @param tokens_ tokens to update exchange prices for\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\n    function updateExchangePrices(\n        address[] calldata tokens_\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\n}\n\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\n    /// @notice Single function which handles supply, withdraw, borrow & payback\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\n    /// @param withdrawTo_ if withdrawal then to which address\n    /// @param borrowTo_ if borrow then to which address\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\n    /// @return memVar3_ updated supplyExchangePrice\n    /// @return memVar4_ updated borrowExchangePrice\n    /// @dev to trigger skipping in / out transfers (gas optimization):\n    /// -  ` callbackData_` MUST be encoded so that \"from\" address is the last 20 bytes in the last 32 bytes slot,\n    ///     also for native token operations where liquidityCallback is not triggered!\n    ///     from address must come at last position if there is more data. I.e. encode like:\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\n    /// -   this \"from\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\n    ///     in the slot before (bytes 32 to 63)\n    /// -   `msg.value` must be 0.\n    /// -   Amounts must be either:\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\n}\n\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\n"
    },
    "contracts/oracle/cappedRates/balancerCappedRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IBalancerRateProvider } from \"../interfaces/external/IBalancerRateProvider.sol\";\nimport { FluidCappedRate } from \"../fluidCappedRate.sol\";\n\n/// @notice Stores gas optimized and safety up and/or down capped exchange rate for a BalancerRateProvider, e.g. ezETH / ETH rate.\n///\n/// @dev e.g. EZETH BalancerRateProvider contract; 0x387dbc0fb00b26fb085aa658527d5be98302c84c\ncontract FluidBalancerCappedRate is IBalancerRateProvider, FluidCappedRate {\n    constructor(FluidCappedRate.CappedRateConstructorParams memory params_) FluidCappedRate(params_) {}\n\n    function _getNewRateRaw() internal view virtual override returns (uint256 exchangeRate_) {\n        return IBalancerRateProvider(_RATE_SOURCE).getRate();\n    }\n\n    /// @inheritdoc IBalancerRateProvider\n    function getRate() external view override returns (uint256) {\n        return uint256(_slot0.rate) / _RATE_MULTIPLIER; // scale to 1e18\n    }\n}\n"
    },
    "contracts/oracle/cappedRates/chainlinkCappedRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IChainlinkAggregatorV3 } from \"../interfaces/external/IChainlinkAggregatorV3.sol\";\nimport { FluidCappedRate } from \"../fluidCappedRate.sol\";\n\n/// @notice Stores gas optimized and safety up and/or down capped exchange rate for a Chainlink Feed source\ncontract FluidChainlinkCappedRate is FluidCappedRate {\n    constructor(FluidCappedRate.CappedRateConstructorParams memory params_) FluidCappedRate(params_) {}\n\n    function _getNewRateRaw() internal view virtual override returns (uint256 exchangeRate_) {\n        (, int256 rate_, , , ) = IChainlinkAggregatorV3(_RATE_SOURCE).latestRoundData();\n        return uint256(rate_);\n    }\n}\n"
    },
    "contracts/oracle/cappedRates/erc46262xCappedRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { FluidCappedRate } from \"../fluidCappedRate.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nabstract contract ERC46262xCappedRateVariables {\n    /// @notice external exchange rate source contract 2\n    address public immutable RATE_SOURCE2;\n    constructor(address rateSource2_) {\n        RATE_SOURCE2 = rateSource2_;\n    }\n}\n\n/// @notice Stores gas optimized and safety up and/or down capped exchange rate for 2 ERC4626 sources, e.g. CSUSDL / USDL rate\n///\n/// @dev e.g. CSUSDL 0xbEeFc011e94f43b8B7b455eBaB290C7Ab4E216f1 + WUSDL 0x7751e2f4b8ae93ef6b79d86419d42fe3295a4559\ncontract FluidERC46262xCappedRate is ERC46262xCappedRateVariables, FluidCappedRate {\n    constructor(\n        FluidCappedRate.CappedRateConstructorParams memory params_,\n        address rateSource2_\n    ) validAddress(rateSource2_) ERC46262xCappedRateVariables(rateSource2_) FluidCappedRate(params_) {\n        if (_RATE_MULTIPLIER != 1) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n    }\n\n    function _getNewRateRaw() internal view virtual override returns (uint256 exchangeRate_) {\n        return (IERC4626(_RATE_SOURCE).convertToAssets(1e27) * IERC4626(RATE_SOURCE2).convertToAssets(1e27)) / 1e27;\n    }\n\n    /// @notice Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n    /// scenario where all the conditions are met. see IERC4626\n    function convertToShares(uint256 assets) external view returns (uint256 shares) {\n        return (uint256(_slot0.rate) * assets) / 1e27;\n    }\n\n    /// @notice Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n    /// scenario where all the conditions are met. see IERC4626\n    function convertToAssets(uint256 shares) external view returns (uint256 assets) {\n        return (shares * 1e27) / uint256(_slot0.rate);\n    }\n}\n"
    },
    "contracts/oracle/cappedRates/erc4626CappedRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { FluidCappedRate } from \"../fluidCappedRate.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\n/// @notice Stores gas optimized and safety up and/or down capped exchange rate for a ERC4626 source, e.g. SUSDE / USDE rate.\n///\n/// @dev e.g. SUSDE contract; on mainnet 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497\n/// @dev e.g. SUSDS contract; on mainnet 0xa3931d71877C0E7a3148CB7Eb4463524FEc27fbD\ncontract FluidERC4626CappedRate is FluidCappedRate {\n    constructor(FluidCappedRate.CappedRateConstructorParams memory params_) FluidCappedRate(params_) {\n        if (_RATE_MULTIPLIER != 1) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n    }\n\n    function _getNewRateRaw() internal view virtual override returns (uint256 exchangeRate_) {\n        return IERC4626(_RATE_SOURCE).convertToAssets(1e27);\n    }\n\n    /// @notice Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n    /// scenario where all the conditions are met. see IERC4626\n    function convertToShares(uint256 assets) external view returns (uint256 shares) {\n        return (uint256(_slot0.rate) * assets) / 1e27;\n    }\n\n    /// @notice Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n    /// scenario where all the conditions are met. see IERC4626\n    function convertToAssets(uint256 shares) external view returns (uint256 assets) {\n        return (shares * 1e27) / uint256(_slot0.rate);\n    }\n}\n"
    },
    "contracts/oracle/cappedRates/maticXCappedRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IMaticXChildPool } from \"../interfaces/external/IMaticXChildPool.sol\";\nimport { FluidCappedRate } from \"../fluidCappedRate.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\n/// @notice Stores gas optimized and safety up and/or down capped exchange rate for MATICX / MATIC Oracle.\n///\n/// @dev MaticX Child pool contract on Polygon 0xfd225c9e6601c9d38d8f98d8731bf59efcf8c0e3\ncontract FluidMaticXCappedRate is FluidCappedRate {\n    constructor(FluidCappedRate.CappedRateConstructorParams memory params_) FluidCappedRate(params_) {\n        if (_RATE_MULTIPLIER != 1) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n    }\n\n    function _getNewRateRaw() internal view virtual override returns (uint256 exchangeRate_) {\n        (exchangeRate_, , ) = IMaticXChildPool(_RATE_SOURCE).convertMaticXToMatic(1e27);\n    }\n}\n"
    },
    "contracts/oracle/cappedRates/rlpCappedRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IRLPPrice } from \"../interfaces/external/IRLPPrice.sol\";\nimport { FluidCappedRate } from \"../fluidCappedRate.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\n/// @notice Stores gas optimized and safety up and/or down capped exchange rate for RLP / USD Oracle.\n///\n/// @dev RLP price contract; 0xaE2364579D6cB4Bbd6695846C1D595cA9AF3574d\ncontract FluidRLPCappedRate is FluidCappedRate {\n    constructor(FluidCappedRate.CappedRateConstructorParams memory params_) FluidCappedRate(params_) {\n        if (_RATE_MULTIPLIER != 1e9) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n    }\n\n    function _getNewRateRaw() internal view virtual override returns (uint256 exchangeRate_) {\n        IRLPPrice.Price memory price_ = IRLPPrice(_RATE_SOURCE).lastPrice();\n        return price_.price;\n    }\n}\n"
    },
    "contracts/oracle/cappedRates/rsethCappedRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IRsETHLRTOracle } from \"../interfaces/external/IRsETHLRTOracle.sol\";\nimport { FluidCappedRate } from \"../fluidCappedRate.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\n/// @notice Stores gas optimized and safety up and/or down capped exchange rate for RSETH / ETH LRT Oracle.\n///\n/// @dev RSETH LRT oracle contract; 0x349A73444b1a310BAe67ef67973022020d70020d\ncontract FluidRSETHCappedRate is IRsETHLRTOracle, FluidCappedRate {\n    constructor(FluidCappedRate.CappedRateConstructorParams memory params_) FluidCappedRate(params_) {\n        if (_RATE_MULTIPLIER != 1e9) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n    }\n\n    function _getNewRateRaw() internal view virtual override returns (uint256 exchangeRate_) {\n        return IRsETHLRTOracle(_RATE_SOURCE).rsETHPrice();\n    }\n\n    /// @inheritdoc IRsETHLRTOracle\n    function rsETHPrice() external view override returns (uint256) {\n        return uint256(_slot0.rate) / _RATE_MULTIPLIER; // scale to 1e18\n    }\n}\n"
    },
    "contracts/oracle/cappedRates/vedaCappedRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IVedaAccountant } from \"../interfaces/external/IVedaAccountant.sol\";\nimport { FluidCappedRate } from \"../fluidCappedRate.sol\";\n\n/// @notice Stores gas optimized and safety up and/or down capped exchange rate for a VedaAccountant, e.g. WEETHS / ETH or EBTC / BTC rate.\n///\n/// @dev e.g. EBTC accountant contract; 0x1b293DC39F94157fA0D1D36d7e0090C8B8B8c13F\n/// @dev e.g. WEETHS accountant contract; 0xbe16605B22a7faCEf247363312121670DFe5afBE\ncontract FluidVedaCappedRate is IVedaAccountant, FluidCappedRate {\n    constructor(FluidCappedRate.CappedRateConstructorParams memory params_) FluidCappedRate(params_) {}\n\n    function _getNewRateRaw() internal view virtual override returns (uint256 exchangeRate_) {\n        // rate for EBTC is in 1e8 e.g. 100000000, for WEETHS in 1e18\n        return IVedaAccountant(_RATE_SOURCE).getRate();\n    }\n\n    /// @inheritdoc IVedaAccountant\n    function vault() external view override returns (address) {\n        return IVedaAccountant(_RATE_SOURCE).vault();\n    }\n\n    /// @inheritdoc IVedaAccountant\n    function getRate() external view override returns (uint256) {\n        return uint256(_slot0.rate) / _RATE_MULTIPLIER; // scale to 1e8\n    }\n\n    /// @inheritdoc IVedaAccountant\n    function getRateSafe() external view override returns (uint256) {\n        IVedaAccountant(_RATE_SOURCE).getRateSafe(); // will revert if paused\n        // return actual rate of this contract to keep equivalency with getRate() and other methods.\n        return uint256(_slot0.rate) / _RATE_MULTIPLIER; // scale to 1e8\n    }\n}\n"
    },
    "contracts/oracle/cappedRates/weethCappedRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IWeETH } from \"../interfaces/external/IWeETH.sol\";\nimport { FluidCappedRate } from \"../fluidCappedRate.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\n/// @notice Stores gas optimized and safety up and/or down capped exchange rate for WEETH / ETH contract.\n///\n/// @dev WEETH contract; on mainnet 0xcd5fe23c85820f7b72d0926fc9b05b43e359b7ee\ncontract FluidWEETHCappedRate is IWeETH, FluidCappedRate {\n    constructor(FluidCappedRate.CappedRateConstructorParams memory params_) FluidCappedRate(params_) {\n        if (_RATE_MULTIPLIER != 1) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n    }\n\n    function _getNewRateRaw() internal view virtual override returns (uint256 exchangeRate_) {\n        return IWeETH(_RATE_SOURCE).getEETHByWeETH(1e27);\n    }\n\n    /// @inheritdoc IWeETH\n    function getEETHByWeETH(uint256 _weETHAmount) external view override returns (uint256) {\n        return (uint256(_slot0.rate) * _weETHAmount) / 1e27;\n    }\n\n    /// @inheritdoc IWeETH\n    function getWeETHByeETH(uint256 _eETHAmount) external view override returns (uint256) {\n        return (1e27 * _eETHAmount) / uint256(_slot0.rate);\n    }\n}\n"
    },
    "contracts/oracle/cappedRates/wstethCappedRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IWstETH } from \"../interfaces/external/IWstETH.sol\";\nimport { FluidCappedRate } from \"../fluidCappedRate.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\n/// @notice Stores gas optimized and safety up and/or down capped exchange rate for WSTETH / ETH contract.\n///\n/// @dev WSTETH contract; on mainnet 0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0\ncontract FluidWSTETHCappedRate is IWstETH, FluidCappedRate {\n    constructor(FluidCappedRate.CappedRateConstructorParams memory params_) FluidCappedRate(params_) {\n        if (_RATE_MULTIPLIER != 1e9) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n    }\n\n    function _getNewRateRaw() internal view virtual override returns (uint256 exchangeRate_) {\n        return IWstETH(_RATE_SOURCE).stEthPerToken();\n    }\n\n    /// @inheritdoc IWstETH\n    function stEthPerToken() external view override returns (uint256) {\n        return uint256(_slot0.rate) / _RATE_MULTIPLIER; // scale to 1e18\n    }\n\n    /// @inheritdoc IWstETH\n    function tokensPerStEth() external view override returns (uint256) {\n        return 1e45 / uint256(_slot0.rate); // scale to 1e18\n    }\n}\n"
    },
    "contracts/oracle/cappedRatesL2/chainlinkCappedRateL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IChainlinkAggregatorV3 } from \"../interfaces/external/IChainlinkAggregatorV3.sol\";\nimport { FluidCappedRateL2 } from \"../fluidCappedRateL2.sol\";\n\n/// @notice Stores gas optimized and safety up and/or down capped exchange rate for a Chainlink Feed source\n/// for L2 with sequencer uptime feed.\ncontract FluidChainlinkCappedRateL2 is FluidCappedRateL2 {\n    constructor(\n        FluidCappedRateL2.CappedRateConstructorParams memory params_,\n        address sequencerUptimeFeed_\n    ) FluidCappedRateL2(params_, sequencerUptimeFeed_) {}\n\n    function _getNewRateRaw() internal view virtual override returns (uint256 exchangeRate_) {\n        (, int256 rate_, , , ) = IChainlinkAggregatorV3(_RATE_SOURCE).latestRoundData();\n        return uint256(rate_);\n    }\n}\n"
    },
    "contracts/oracle/cappedRatesL2/erc4626CappedRateL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { FluidCappedRateL2 } from \"../fluidCappedRateL2.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\n/// @notice Stores gas optimized and safety up and/or down capped exchange rate for a ERC4626 source, e.g. SUSDE / USDE rate.\n/// for L2 with sequencer uptime feed.\ncontract FluidERC4626CappedRateL2 is FluidCappedRateL2 {\n    constructor(\n        FluidCappedRateL2.CappedRateConstructorParams memory params_,\n        address sequencerUptimeFeed_\n    ) FluidCappedRateL2(params_, sequencerUptimeFeed_) {\n        if (_RATE_MULTIPLIER != 1) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n    }\n\n    function _getNewRateRaw() internal view virtual override returns (uint256 exchangeRate_) {\n        return IERC4626(_RATE_SOURCE).convertToAssets(1e27);\n    }\n\n    /// @notice Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n    /// scenario where all the conditions are met. see IERC4626\n    function convertToShares(uint256 assets) external view returns (uint256 shares) {\n        return (uint256(_slot0.rate) * assets) / 1e27;\n    }\n\n    /// @notice Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n    /// scenario where all the conditions are met. see IERC4626\n    function convertToAssets(uint256 shares) external view returns (uint256 assets) {\n        return (shares * 1e27) / uint256(_slot0.rate);\n    }\n}\n"
    },
    "contracts/oracle/centerPrices/chainlinkCenterPriceL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidCenterPriceL2 } from \"../fluidCenterPriceL2.sol\";\nimport { ChainlinkOracleImpl } from \"../implementations/chainlinkOracleImpl.sol\";\nimport { IFluidOracle } from \"../interfaces/iFluidOracle.sol\";\n\n/// @title   ChainlinkCenterPriceL2\n/// @notice  Gets the exchange rate between 2 tokens via Chainlink feeds for Layer 2 (with sequencer uptime feed check)\n/// @dev     Also implements IFluidOracle interface\ncontract ChainlinkCenterPriceL2 is FluidCenterPriceL2, IFluidOracle, ChainlinkOracleImpl {\n    /// @notice constructor sets the chainlink feeds config & L2 sequencer uptime feed\n    constructor(\n        string memory infoName_,\n        ChainlinkOracleImpl.ChainlinkConstructorParams memory clParams_,\n        address sequencerUptimeFeed_\n    ) ChainlinkOracleImpl(clParams_) FluidCenterPriceL2(infoName_, sequencerUptimeFeed_) {}\n\n    /// @inheritdoc FluidCenterPriceL2\n    function centerPrice() external view override returns (uint256 price_) {\n        _ensureSequencerUpAndValid();\n        return _getChainlinkExchangeRate();\n    }\n\n    /// @inheritdoc FluidCenterPriceL2\n    function infoName() public view override(IFluidOracle, FluidCenterPriceL2) returns (string memory) {\n        return super.infoName();\n    }\n\n    /// @inheritdoc FluidCenterPriceL2\n    function targetDecimals() public pure override(IFluidOracle, FluidCenterPriceL2) returns (uint8) {\n        return super.targetDecimals();\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_) {\n        _ensureSequencerUpAndValid();\n        return _getChainlinkExchangeRate();\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() external view virtual returns (uint256 exchangeRate_) {\n        _ensureSequencerUpAndValid();\n        return _getChainlinkExchangeRate();\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() external view virtual returns (uint256 exchangeRate_) {\n        _ensureSequencerUpAndValid();\n        return _getChainlinkExchangeRate();\n    }\n}\n"
    },
    "contracts/oracle/centerPrices/genericCenterPriceL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidCenterPriceL2 } from \"../fluidCenterPriceL2.sol\";\nimport { FluidGenericOracleBase } from \"../oracles/genericOracleBase.sol\";\nimport { IFluidOracle } from \"../interfaces/iFluidOracle.sol\";\n\n/// @title   FluidGenericCenterPriceL2\n/// @notice  Gets the exchange rate between 2 tokens via GenericOracle feeds for a Dex center price for Layer 2 (with sequencer uptime feed check)\n/// @dev     Also implements IFluidOracle interface\ncontract FluidGenericCenterPriceL2 is FluidCenterPriceL2, IFluidOracle, FluidGenericOracleBase {\n    constructor(\n        string memory infoName_,\n        OracleHopSource[] memory sources_,\n        address sequencerUptimeFeed_\n    ) FluidCenterPriceL2(infoName_, sequencerUptimeFeed_) FluidGenericOracleBase(sources_) {}\n\n    /// @inheritdoc FluidCenterPriceL2\n    function centerPrice() external view override returns (uint256 price_) {\n        price_ = _getHopsExchangeRate(true);\n    }\n\n    /// @inheritdoc FluidCenterPriceL2\n    function infoName() public view override(IFluidOracle, FluidCenterPriceL2) returns (string memory) {\n        return super.infoName();\n    }\n\n    /// @inheritdoc FluidCenterPriceL2\n    function targetDecimals() public pure override(IFluidOracle, FluidCenterPriceL2) returns (uint8) {\n        return super.targetDecimals();\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() public view virtual override returns (uint256 exchangeRate_) {\n        exchangeRate_ = _getHopsExchangeRate(true);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() public view virtual override returns (uint256 exchangeRate_) {\n        exchangeRate_ = _getHopsExchangeRate(false);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() public view virtual override returns (uint256 exchangeRate_) {\n        exchangeRate_ = _getHopsExchangeRate(false);\n    }\n}\n"
    },
    "contracts/oracle/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Error {\n    error FluidOracleError(uint256 errorId_);\n}\n"
    },
    "contracts/oracle/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |           FluidOracleL2           | \n    |__________________________________*/\n\n    /// @notice thrown when sequencer on a L2 has an outage and grace period has not yet passed.\n    uint256 internal constant FluidOracleL2__SequencerOutage = 60000;\n\n    /***********************************|\n    |     UniV3CheckCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the delta between main price source and check rate source is exceeding the allowed delta\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidPrice = 60001;\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidParams = 60002;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant UniV3CheckCLRSOracle__ExchangeRateZero = 60003;\n\n    /***********************************|\n    |           FluidOracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid info name is passed into a fluid oracle (e.g. not set or too long)\n    uint256 internal constant FluidOracle__InvalidInfoName = 60010;\n\n    /***********************************|\n    |            sUSDe Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDeOracle__InvalidParams = 60102;\n\n    /***********************************|\n    |           Pendle Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PendleOracle__InvalidParams = 60201;\n\n    /// @notice thrown when the Pendle market Oracle has not been initialized yet\n    uint256 internal constant PendleOracle__MarketNotInitialized = 60202;\n\n    /// @notice thrown when the Pendle market does not have 18 decimals\n    uint256 internal constant PendleOracle__MarketInvalidDecimals = 60203;\n\n    /// @notice thrown when the Pendle market returns an unexpected price\n    uint256 internal constant PendleOracle__InvalidPrice = 60204;\n\n    /***********************************|\n    |    CLRS2UniV3CheckCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant CLRS2UniV3CheckCLRSOracleL2__ExchangeRateZero = 60301;\n\n    /***********************************|\n    |    Ratio2xFallbackCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant Ratio2xFallbackCLRSOracleL2__ExchangeRateZero = 60311;\n\n    /***********************************|\n    |            WeETHsOracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHsOracle__InvalidParams = 60321;\n\n    /***********************************|\n    |        DexSmartColOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexSmartColOracle__InvalidParams = 60331;\n\n    /// @notice thrown when smart col is not enabled\n    uint256 internal constant DexSmartColOracle__SmartColNotEnabled = 60332;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexSmartColOracle__ExchangeRateZero = 60333;\n\n    /***********************************|\n    |        DexSmartDebtOracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexSmartDebtOracle__InvalidParams = 60341;\n\n    /// @notice thrown when smart debt is not enabled\n    uint256 internal constant DexSmartDebtOracle__SmartDebtNotEnabled = 60342;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexSmartDebtOracle__ExchangeRateZero = 60343;\n\n    /***********************************|\n    |            CappedRate           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant CappedRate__InvalidParams = 60351;\n\n    /// @notice thrown when caller is not authorized\n    uint256 internal constant CappedRate__Unauthorized = 60352;\n\n    /// @notice thrown when minimum diff for triggering update on the stared rate is not reached\n    uint256 internal constant CappedRate__MinUpdateDiffNotReached = 60353;\n\n    /// @notice thrown when the external rate source returns 0 for the new rate\n    uint256 internal constant CappedRate__NewRateZero = 60354;\n\n    /// @notice thrown when the new rate source does not fit in 192 bit storage uint, should never happen.\n    uint256 internal constant CappedRate__StorageOverflow = 60355;\n\n    /***********************************|\n    |            sUSDs Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDsOracle__InvalidParams = 60361;\n\n    /***********************************|\n    |            Peg Oracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PegOracle__InvalidParams = 60371;\n\n    /***********************************|\n    |              DexOracle            | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexOracle__InvalidParams = 60381;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexOracle__ExchangeRateZero = 60382;\n\n    /***********************************|\n    |           GenericOracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant GenericOracle__InvalidParams = 60401;\n\n    /// @notice thrown when reaching an unexepcted config state\n    uint256 internal constant GenericOracle__UnexpectedConfig = 60402;\n\n    /// @notice thrown when the exchange rate is zero\n    uint256 internal constant GenericOracle__RateZero = 60403;\n\n    /***********************************|\n    |          Chainlink Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant ChainlinkOracle__InvalidParams = 61001;\n\n    /***********************************|\n    |          UniswapV3 Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3Oracle__InvalidParams = 62001;\n\n    /// @notice thrown when constructor is called with invalid ordered seconds agos values\n    uint256 internal constant UniV3Oracle__InvalidSecondsAgos = 62002;\n\n    /// @notice thrown when constructor is called with invalid delta values > 100%\n    uint256 internal constant UniV3Oracle__InvalidDeltas = 62003;\n\n    /***********************************|\n    |            WstETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WstETHOracle__InvalidParams = 63001;\n\n    /***********************************|\n    |           Redstone Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant RedstoneOracle__InvalidParams = 64001;\n\n    /***********************************|\n    |          Fallback Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant FallbackOracle__InvalidParams = 65001;\n\n    /***********************************|\n    |       FallbackCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant FallbackCLRSOracle__ExchangeRateZero = 66001;\n\n    /***********************************|\n    |         WstETHCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant WstETHCLRSOracle__ExchangeRateZero = 67001;\n\n    /***********************************|\n    |        CLFallbackUniV3Oracle      | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant CLFallbackUniV3Oracle__ExchangeRateZero = 68001;\n\n    /***********************************|\n    |  WstETHCLRS2UniV3CheckCLRSOracle  | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant WstETHCLRS2UniV3CheckCLRSOracle__ExchangeRateZero = 69001;\n\n    /***********************************|\n    |             WeETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHOracle__InvalidParams = 70001;\n}\n"
    },
    "contracts/oracle/fluidCappedRate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"./interfaces/iFluidOracle.sol\";\nimport { IFluidCappedRate } from \"./interfaces/iFluidCappedRate.sol\";\nimport { FluidCenterPrice } from \"./fluidCenterPrice.sol\";\n\nimport { LiquiditySlotsLink } from \"../libraries/liquiditySlotsLink.sol\";\n\nimport { Error as OracleError } from \"./error.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\n\ninterface IFluidLiquidity {\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n\nabstract contract Events {\n    /// @notice emitted when rebalancer successfully changes the contract rate\n    event LogRebalanceRate(uint256 oldRate, uint256 newRate, uint256 oldMaxRate, uint256 newMaxRate);\n\n    /// @notice emitted when the external rate is currently lower than the previous maximum rate by at least `_maxDownFromMaxReachedPercent`\n    event LogRateBelowMaxReached();\n\n    /// @notice emitted when the external rate increased faster than `_maxAPRPercent` allows\n    event LogRateMaxAPRCapped();\n\n    /// @notice Emitted when avoidForcedLiquidations col is updated\n    event LogUpdateAvoidForcedLiquidationsCol(bool oldAvoidForcedLiquidations, bool newAvoidForcedLiquidations);\n\n    /// @notice Emitted when avoidForcedLiquidations debt is updated\n    event LogUpdateAvoidForcedLiquidationsDebt(bool oldAvoidForcedLiquidations, bool newAvoidForcedLiquidations);\n\n    /// @notice Emitted when maxAPRPercent is updated\n    event LogUpdateMaxAPRPercent(uint256 oldMaxAPRPercent, uint256 newMaxAPRPercent);\n\n    /// @notice Emitted when _maxDownFromMaxReachedPercentCol is updated\n    event LogUpdateMaxDownFromMaxReachedPercentCol(\n        uint256 oldMaxDownFromMaxReachedPercent,\n        uint256 newMaxDownFromMaxReachedPercent\n    );\n\n    /// @notice Emitted when _maxDownFromMaxReachedPercentDebt is updated\n    event LogUpdateMaxDownFromMaxReachedPercentDebt(\n        uint256 oldMaxDownFromMaxReachedPercent,\n        uint256 newMaxDownFromMaxReachedPercent\n    );\n\n    /// @notice Emitted when max reached rate is reset to `_rate`\n    event LogForceResetMaxRate(uint256 oldMaxRate, uint256 newMaxRate);\n\n    /// @notice Emitted when _maxDebtUpCapPercent is updated\n    event LogUpdateMaxDebtUpCapPercent(uint256 oldMaxDebtUpCapPercent, uint256 newMaxDebtUpCapPercent);\n\n    /// @notice Emitted when _minHeartbeat is updated\n    event LogUpdateMinHeartbeat(uint256 oldMinHeartbeat, uint256 newMinHeartbeat);\n\n    /// @notice Emitted when _minUpdateDiffPercent is updated\n    event LogUpdateMinUpdateDiffPercent(uint256 oldMinUpdateDiffPercent, uint256 newMinUpdateDiffPercent);\n}\n\nabstract contract Constants {\n    /// @dev Ignoring leap years\n    uint256 internal constant _SECONDS_PER_YEAR = 365 days;\n\n    /// @dev 100% precision\n    uint256 internal constant _SIX_DECIMALS = 1e6;\n\n    uint256 internal constant _X3 = 7;\n\n    /// @dev liquidity layer address\n    address internal immutable _LIQUIDITY;\n\n    /// @dev external exchange rate source contract\n    address internal immutable _RATE_SOURCE;\n\n    /// @dev flag if fetched rate should be inverted\n    bool internal immutable _INVERT_CENTER_PRICE;\n\n    /// @dev external exchange rate source multiplier to get to 1e27 decimals\n    uint256 internal immutable _RATE_MULTIPLIER;\n}\n\nabstract contract Variables is Constants {\n    // slot 0 flag bitmasks\n    uint8 internal constant _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED = 1;\n    uint8 internal constant _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED = 2;\n    uint8 internal constant _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL = 4;\n    uint8 internal constant _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT = 8;\n    uint8 internal constant _FLAG_BITMASK_ALLOW_MAX_YIELD_JUMPS = 0xE0; // 1110 0000\n\n    struct Slot0 {\n        /// @dev exchange rate as fetched from external rate source in 1e27 decimals. max value 3.74e50\n        uint168 rate;\n        /// @dev time when last update for rate happened\n        uint40 lastUpdateTime;\n        /// @dev flags bitmap:\n        /// Bit 1: true if the `_rate` value is currently < _maxReachedAPRCappedRate\n        ///        bool internal _isRateBelowMaxReached;\n\n        /// Bit 2: true if the `_rate` value is currently > _maxReachedAPRCappedRate, so capped because of the maxAPR limit\n        ///        bool internal _isUpMaxAPRCapped;\n\n        /// Bit 3: Col side: config flag to signal whether to protect users vs protect protocol depending on asset reliability (accept temporary bad debt if trusting peg).\n        ///        flag should only be active for trusted assets where we assume any peg can only be temporary as when this flag is on\n        ///        it can lead to bad debt until asset repeg is reached. For not 100% trusted assets better to liquidate on depeg and avoid any bad debt\n        ///        Configurable by Governance and Liquidity guardians\n        ///        bool internal _avoidForcedLiquidationsCol;\n\n        /// Bit 4: same as Bit 3, but for debt side\n        ///        bool internal _avoidForcedLiquidationsDebt;\n\n        /// Bit 5: ----- empty -------\n\n        /// Bits 6,7,8: uint3 -> allowed max yield jumps. each heartbeat update where minUpdateDiff is not reached increases this by 1,\n        ///                      up to a maximum of 7. Reset to 0 for any update that is > min update diff.\n        ///                      For any price update, the maximum price increase is:\n        ///                      normal max yield increase since lastUpdateTime + maxYieldJumps * maxYield / HeartBeatDuration\n        uint8 flags;\n        /// @dev Minimum time after which an update can trigger, even if it does not reach `_minUpdateDiffPercent`. Max value = 16_777_215 -> ~194 days\n        ///      Configurable by Governance.\n        uint24 minHeartbeat;\n        /// @dev Minimum difference to trigger update in percent 1e4 decimals, 10000 = 1%. Max value = 6,5535%\n        ///      Configurable by Governance.\n        uint16 minUpdateDiffPercent;\n    }\n\n    struct Slot1 {\n        /// @dev tracks the maximum ever reached rate with respect of maxAPR percent (a temporary 100x spike does not increase this value beyond max apr increase).\n        /// this is only updated IF `_rate` is not == `_maxReachedAPRCappedRate`, i.e. if `_isRateBelowMaxReached || _isUpMaxAPRCapped`. max value 3.74e50\n        ///\n        /// Can be reset synced to match `_rate` by Govnernance and Liquidity guardians, when wanting to force skip max APR or forcing reset after rate reduced\n        uint168 maxReachedAPRCappedRate;\n        /// @dev maximum yield APR that exchange rate can increase in each update\n        /// in 1e2 precision, 1% = 100. max value-> 167_772,15%, can be set to 0 to force no rate increase possible for upwards cap\n        ///\n        /// Configurable by Governance and Liquidity guardians.\n        uint24 maxAPRPercent;\n        /// @dev Col side: maximum down percent reduction of `_maxReachedAPRCappedRate` for rates with downward cap protection.\n        /// in 1e4 precision, 1% = 1e4. max value-> 1_677,7215 % (so max configurable value = _SIX_DECIMALS which is 100% -> removing downward cap entirely)\n        ///\n        /// Configurable by Governance and Liquidity guardians\n        uint24 maxDownFromMaxReachedPercentCol;\n        /// @dev same as above but for debt\n        uint24 maxDownFromMaxReachedPercentDebt;\n        /// @dev Debt side: maximum up percent cap on top of `_maxReachedAPRCappedRate`, only relevant when avoid forced liquidations attack for debt side is active,\n        /// when _avoidForcedLiquidationsDebt flag is true. in 1e2 precision, 1% = 100. max value-> 655,35%, can be set to 0 to have same cap as on col side.\n        ///\n        /// Configurable by Governance and Liquidity guardians.\n        uint16 maxDebtUpCapPercent;\n    }\n\n    Slot0 internal _slot0; // Used in default view methods\n\n    Slot1 internal _slot1; // Used only in special cases, storage updates or admin related\n}\n\nabstract contract CappedRateInternals is Variables, Events, OracleError {\n    /// @dev read the exchange rate from the external contract e.g. wstETH or rsETH exchange rate, yet to be scaled to 1e27\n    /// To be implemented by inheriting contract\n    function _getNewRateRaw() internal view virtual returns (uint256 exchangeRate_);\n\n    /// @dev gets the percentage difference between `oldValue_` and `newValue_` in relation to `oldValue_` in percent (10000 = 1%, 1 = 0.0001%).\n    function _percentDiffForValue(\n        uint256 oldValue_,\n        uint256 newValue_\n    ) internal pure returns (uint256 configPercentDiff_) {\n        unchecked {\n            if (oldValue_ > newValue_) {\n                configPercentDiff_ = ((oldValue_ - newValue_) * _SIX_DECIMALS) / oldValue_;\n            } else if (newValue_ > oldValue_) {\n                configPercentDiff_ = ((newValue_ - oldValue_) * _SIX_DECIMALS) / oldValue_;\n            }\n        }\n    }\n\n    /// @dev get new rate from external source and return updated related parameters.\n    function _getUpdateRates(\n        uint256 maxReachedRate_,\n        Slot0 memory slot0_,\n        uint256 maxAPRPercent_\n    )\n        internal\n        view\n        virtual\n        returns (uint256 newRate_, uint256 maxRate_, bool isUpMaxAPRCapped_, bool isRateBelowMaxReached_)\n    {\n        newRate_ = _getNewRateRaw() * _RATE_MULTIPLIER;\n        if (newRate_ == 0) {\n            revert FluidOracleError(ErrorTypes.CappedRate__NewRateZero);\n        }\n\n        maxRate_ = _calcMaxAPRCappedRate(newRate_, maxReachedRate_, slot0_, maxAPRPercent_);\n        isUpMaxAPRCapped_ = newRate_ > maxRate_;\n        isRateBelowMaxReached_ = newRate_ < maxRate_;\n    }\n\n    /// @dev updates the values in storage according to the newly fetched rate from external source.\n    function _updateRates(bool forceUpdate_) internal virtual returns (uint256 newRate_) {\n        Slot0 memory slot0_ = _slot0;\n        Slot1 memory slot1_ = _slot1;\n\n        uint256 newMaxReachedRate_;\n        bool isUpMaxAPRCapped_;\n        bool isRateBelowMaxReached_;\n\n        uint256 maxReachedAPRCappedRate_ = uint256(slot1_.maxReachedAPRCappedRate);\n\n        (newRate_, newMaxReachedRate_, isUpMaxAPRCapped_, isRateBelowMaxReached_) = _getUpdateRates(\n            maxReachedAPRCappedRate_,\n            slot0_,\n            uint256(slot1_.maxAPRPercent)\n        );\n\n        if (newRate_ > type(uint168).max || newMaxReachedRate_ > type(uint168).max) {\n            revert FluidOracleError(ErrorTypes.CappedRate__StorageOverflow);\n        }\n\n        uint256 curRate_ = uint256(slot0_.rate);\n\n        uint256 allowedMaxYieldJumps_ = 0;\n        if (\n            _percentDiffForValue(curRate_, newRate_) < uint256(slot0_.minUpdateDiffPercent) &&\n            _percentDiffForValue(maxReachedAPRCappedRate_, newMaxReachedRate_) < uint256(slot0_.minUpdateDiffPercent)\n        ) {\n            if (forceUpdate_) {\n                // min update diff not reached but update is forced anyway via heartbeat -> increase allowed max yield jumps\n                allowedMaxYieldJumps_ = (uint256(slot0_.flags & _FLAG_BITMASK_ALLOW_MAX_YIELD_JUMPS) + 1) & _X3; // force max value possible 7\n            } else {\n                revert FluidOracleError(ErrorTypes.CappedRate__MinUpdateDiffNotReached);\n            }\n        }\n\n        if (isUpMaxAPRCapped_) {\n            // if this flag is true then the rate is always effectively upwards capped\n            emit LogRateMaxAPRCapped();\n        }\n        if (isRateBelowMaxReached_) {\n            uint256 downPercent_ = ((newMaxReachedRate_ - newRate_) * _SIX_DECIMALS) / newMaxReachedRate_;\n            if (\n                downPercent_ > slot1_.maxDownFromMaxReachedPercentCol ||\n                downPercent_ > slot1_.maxDownFromMaxReachedPercentDebt\n            ) {\n                // only log this if the decrease is by more than `_maxDownFromMaxReachedPercent` so if the returned rate actually ends up getting\n                // downwards capped (for either col or debt)\n                emit LogRateBelowMaxReached();\n            }\n        }\n\n        // storage slot 1 ALWAYS gets updated because of timestamp so no need to optimize much here\n        slot0_.lastUpdateTime = uint40(block.timestamp);\n        slot0_.rate = uint168(newRate_);\n        slot0_.flags =\n            (slot0_.flags & 0x1C) | // 0001 1100\n            (isRateBelowMaxReached_ ? _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED : 0) |\n            (isUpMaxAPRCapped_ ? _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED : 0) |\n            (uint8(allowedMaxYieldJumps_) << 5);\n        _slot0 = slot0_; // write to storage\n\n        // storage slot 2 might not always change, only if max rate changes, which could be not needed e.g. if rate decreased\n        if (maxReachedAPRCappedRate_ < newMaxReachedRate_) {\n            _slot1.maxReachedAPRCappedRate = uint168(newMaxReachedRate_);\n        }\n\n        emit LogRebalanceRate(curRate_, newRate_, maxReachedAPRCappedRate_, newMaxReachedRate_);\n    }\n\n    /// @dev returns the downwards capped rate max(downCappedRate_, rate_), where downCappedRate_ is capped at maxReachedAPRCappedRate_ - _maxDownFromMaxReachedPercent %.\n    function _calcDownCappedRate(\n        uint256 rate_,\n        uint256 maxReachedRate_,\n        uint256 maxDownPercent_\n    ) internal pure returns (uint256 downCappedRate_) {\n        unchecked {\n            downCappedRate_ = (maxReachedRate_ * (_SIX_DECIMALS - maxDownPercent_)) / _SIX_DECIMALS;\n        }\n\n        if (rate_ > downCappedRate_) {\n            downCappedRate_ = rate_;\n        }\n    }\n\n    /// @dev returns the upwards capped rate min(upCappedRate_, rate_), where upCappedRate_ is capped at maxReachedAPRCappedRate_ + _maxAPRPercent %\n    /// adjusted for passed time since last update time.\n    function _calcMaxAPRCappedRate(\n        uint256 rate_,\n        uint256 maxReachedRate_,\n        Slot0 memory slot0_,\n        uint256 maxAPRPercent_\n    ) internal view returns (uint256 maxRate_) {\n        unchecked {\n            maxRate_ =\n                (maxAPRPercent_ * uint256(100) * (block.timestamp - uint256(slot0_.lastUpdateTime))) /\n                _SECONDS_PER_YEAR; // maxRate_ = max APR for passed time since last update time\n            maxRate_ = (maxReachedRate_ * (_SIX_DECIMALS + maxRate_)) / _SIX_DECIMALS;\n\n            // add allowed max yield jumps from any heartbeat update that did not marginally increase the rate but increased the timestamp\n            uint256 allowedMaxYieldJumps_ = (slot0_.flags & _FLAG_BITMASK_ALLOW_MAX_YIELD_JUMPS);\n            if (allowedMaxYieldJumps_ > 0) {\n                uint256 maxAPRPerHeartbeat_ = (maxAPRPercent_ * uint256(100) * slot0_.minHeartbeat) / _SECONDS_PER_YEAR;\n                maxRate_ = (maxRate_ * (_SIX_DECIMALS + allowedMaxYieldJumps_ * maxAPRPerHeartbeat_)) / _SIX_DECIMALS;\n            }\n        }\n\n        if (rate_ > maxRate_) {\n            // rate increase is capped at max rate\n            return maxRate_;\n        }\n        if (rate_ < maxReachedRate_) {\n            // if rate is lower than previous max reached rate, then previous max reached rate is the max rate\n            return maxReachedRate_;\n        }\n\n        // rate is > maxReachedRate and < max allowed rate\n        return rate_;\n    }\n\n    /// @dev returns true if last update timestamp is too long ago so heartbeat update should trigger\n    function _isHeartbeatTrigger(Slot0 memory slot0_) internal view returns (bool) {\n        unchecked {\n            return ((uint256(slot0_.lastUpdateTime) + slot0_.minHeartbeat) < block.timestamp);\n        }\n    }\n\n    /// @dev returns inverted rate if needed (when _INVERT_CENTER_PRICE flag is set to true)\n    function _invertRateIfNeeded(uint256 exchangeRate_) internal view returns (uint256) {\n        if (exchangeRate_ == 0) {\n            return 0;\n        }\n        unchecked {\n            return _INVERT_CENTER_PRICE ? 1e54 / exchangeRate_ : exchangeRate_;\n        }\n    }\n}\n\nabstract contract CappedRateAdmin is Variables, Events, OracleError {\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1 where current liquidity owner on proxy is stored\n    bytes32 internal constant GOVERNANCE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /// @dev only Liquidity Layer owner (governance) and guardians access modifier\n    modifier onlyGuardians() {\n        bool isGuardian_ = (IFluidLiquidity(_LIQUIDITY).readFromStorage(\n            LiquiditySlotsLink.calculateMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_GUARDIANS_MAPPING_SLOT,\n                msg.sender\n            )\n        ) & 1) == 1;\n\n        bool isGovernance_ = address(uint160(IFluidLiquidity(_LIQUIDITY).readFromStorage(GOVERNANCE_SLOT))) ==\n            msg.sender;\n\n        if (!isGuardian_ && !isGovernance_) {\n            revert FluidOracleError(ErrorTypes.CappedRate__Unauthorized);\n        }\n        _;\n    }\n\n    /// @dev only Liquidity Layer owner (governance) access modifier\n    modifier onlyGovernance() {\n        if (address(uint160(IFluidLiquidity(_LIQUIDITY).readFromStorage(GOVERNANCE_SLOT))) != msg.sender) {\n            revert FluidOracleError(ErrorTypes.CappedRate__Unauthorized);\n        }\n        _;\n    }\n\n    /// @notice Updates the avoidForcedLiquidations_ col side config flag. Only callable by Liquidity Layer guardians\n    function updateAvoidForcedLiquidationsCol(bool avoid_) external onlyGuardians {\n        bool oldAvoidForcedLiquidations_ = _slot0.flags & _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL ==\n            _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL;\n        _slot0.flags = (_slot0.flags & 0xFB) | (avoid_ ? _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL : 0); // mask F1011\n        emit LogUpdateAvoidForcedLiquidationsCol(oldAvoidForcedLiquidations_, avoid_);\n    }\n\n    /// @notice Updates the avoidForcedLiquidations_ debt side config flag. Only callable by Liquidity Layer guardians\n    function updateAvoidForcedLiquidationsDebt(bool avoid_) external onlyGuardians {\n        bool oldAvoidForcedLiquidations_ = _slot0.flags & _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT ==\n            _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT;\n        _slot0.flags = (_slot0.flags & 0xF7) | (avoid_ ? _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT : 0); // mask F0111\n        emit LogUpdateAvoidForcedLiquidationsDebt(oldAvoidForcedLiquidations_, avoid_);\n    }\n\n    /// @notice resets max reached rate to current `_rate` value. Only callable by Liquidity Layer guardians\n    function forceResetMaxRate() external onlyGuardians {\n        uint256 oldMaxRate_ = uint256(_slot1.maxReachedAPRCappedRate);\n        _slot1.maxReachedAPRCappedRate = _slot0.rate;\n        emit LogForceResetMaxRate(oldMaxRate_, uint256(_slot1.maxReachedAPRCappedRate));\n    }\n\n    /// @notice Updates the maxAPRPercent_ config, in 1e4 percent (1% = 1e4). Only callable by Governance\n    function updateMaxAPRPercent(uint256 newMaxAPRPercent_) external onlyGuardians {\n        if (newMaxAPRPercent_ > type(uint24).max * uint256(100)) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        uint256 oldMaxAPRPercent_ = uint256(_slot1.maxAPRPercent) * uint256(100);\n        _slot1.maxAPRPercent = uint24(newMaxAPRPercent_ / uint256(100));\n        emit LogUpdateMaxAPRPercent(oldMaxAPRPercent_, newMaxAPRPercent_);\n    }\n\n    /// @notice Updates the _maxDownFromMaxReachedPercentCol config. Only callable by Liquidity Layer guardians.\n    ///         Set to 100% (1e6) to completely remove down peg (same as updateAvoidForcedLiquidationsCol = false)\n    function updateMaxDownFromMaxReachedPercentCol(uint256 newMaxDownFromMaxReachedPercent_) external onlyGuardians {\n        if (newMaxDownFromMaxReachedPercent_ > _SIX_DECIMALS) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        uint256 oldMaxDownFromMaxReachedPercent_ = uint256(_slot1.maxDownFromMaxReachedPercentCol);\n        _slot1.maxDownFromMaxReachedPercentCol = uint24(newMaxDownFromMaxReachedPercent_);\n        emit LogUpdateMaxDownFromMaxReachedPercentCol(\n            oldMaxDownFromMaxReachedPercent_,\n            newMaxDownFromMaxReachedPercent_\n        );\n    }\n\n    /// @notice Updates the _maxDownFromMaxReachedPercentDebt config. Only callable by Liquidity Layer guardians.\n    ///         Set to 100% (1e6) to completely remove down peg.\n    function updateMaxDownFromMaxReachedPercentDebt(uint256 newMaxDownFromMaxReachedPercent_) external onlyGuardians {\n        if (newMaxDownFromMaxReachedPercent_ > _SIX_DECIMALS) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        uint256 oldMaxDownFromMaxReachedPercent_ = uint256(_slot1.maxDownFromMaxReachedPercentDebt);\n        _slot1.maxDownFromMaxReachedPercentDebt = uint24(newMaxDownFromMaxReachedPercent_);\n        emit LogUpdateMaxDownFromMaxReachedPercentDebt(\n            oldMaxDownFromMaxReachedPercent_,\n            newMaxDownFromMaxReachedPercent_\n        );\n    }\n\n    /// @notice Updates the _maxDebtUpCapPercent config. Only callable by Liquidity Layer guardians.\n    function updateMaxDebtUpCapPercent(uint256 newMaxDebtUpCapPercent_) external onlyGuardians {\n        if (newMaxDebtUpCapPercent_ > type(uint16).max * uint256(100)) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        uint256 oldMaxDebtUpCapPercent_ = uint256(_slot1.maxDebtUpCapPercent) * uint256(100);\n        _slot1.maxDebtUpCapPercent = uint16(newMaxDebtUpCapPercent_ / uint256(100));\n        emit LogUpdateMaxDebtUpCapPercent(oldMaxDebtUpCapPercent_, newMaxDebtUpCapPercent_);\n    }\n\n    /// @notice Updates the _minHeartbeat config. Only callable by Governance.\n    function updateMinHeartbeat(uint256 newMinHeartbeat_) external onlyGovernance {\n        if (newMinHeartbeat_ > type(uint24).max || newMinHeartbeat_ == 0) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        uint256 oldMinHeartbeat_ = uint256(_slot0.minHeartbeat);\n        _slot0.minHeartbeat = uint24(newMinHeartbeat_);\n        emit LogUpdateMinHeartbeat(oldMinHeartbeat_, newMinHeartbeat_);\n    }\n\n    /// @notice Updates the _minUpdateDiffPercent config. Only callable by Governance.\n    function updateMinUpdateDiffPercent(uint256 newMinUpdateDiffPercent_) external onlyGovernance {\n        if (newMinUpdateDiffPercent_ > type(uint16).max || newMinUpdateDiffPercent_ == 0) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        uint256 oldMinUpdateDiffPercent_ = uint256(_slot0.minUpdateDiffPercent);\n        _slot0.minUpdateDiffPercent = uint16(newMinUpdateDiffPercent_);\n        emit LogUpdateMinUpdateDiffPercent(oldMinUpdateDiffPercent_, newMinUpdateDiffPercent_);\n    }\n}\n\n/// @notice This contract stores an exchange rate with caps in intervals to optimize gas cost.\n/// @notice Properly implements all interfaces for use as IFluidCenterPrice and IFluidOracle.\nabstract contract FluidCappedRateBase is CappedRateInternals, CappedRateAdmin, IFluidCappedRate {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        _;\n    }\n\n    struct CappedRateConstructorParams {\n        string infoName;\n        address liquidity;\n        address rateSource;\n        uint256 rateMultiplier;\n        bool invertCenterPrice;\n        uint256 minUpdateDiffPercent;\n        uint256 minHeartbeat;\n        bool avoidForcedLiquidationsCol;\n        bool avoidForcedLiquidationsDebt;\n        uint256 maxAPRPercent;\n        uint256 maxDownFromMaxReachedPercentCol;\n        uint256 maxDownFromMaxReachedPercentDebt;\n        uint256 maxDebtUpCapPercent;\n    }\n\n    constructor(\n        CappedRateConstructorParams memory params_\n    ) validAddress(params_.liquidity) validAddress(params_.rateSource) {\n        if (\n            params_.rateMultiplier == 0 ||\n            params_.rateMultiplier > 1e21 ||\n            params_.minUpdateDiffPercent == 0 ||\n            params_.minUpdateDiffPercent > type(uint16).max ||\n            params_.minHeartbeat == 0 ||\n            params_.minHeartbeat > type(uint24).max ||\n            params_.maxDownFromMaxReachedPercentCol > _SIX_DECIMALS ||\n            params_.maxDownFromMaxReachedPercentDebt > _SIX_DECIMALS ||\n            params_.maxAPRPercent > type(uint24).max * uint256(100) ||\n            params_.maxDebtUpCapPercent > type(uint16).max * uint256(100)\n        ) {\n            revert FluidOracleError(ErrorTypes.CappedRate__InvalidParams);\n        }\n        _LIQUIDITY = params_.liquidity;\n        _RATE_SOURCE = params_.rateSource;\n        _RATE_MULTIPLIER = params_.rateMultiplier;\n        _INVERT_CENTER_PRICE = params_.invertCenterPrice;\n\n        _slot0.rate = uint168(_getNewRateRaw() * _RATE_MULTIPLIER);\n        _slot0.lastUpdateTime = uint40(block.timestamp);\n\n        _slot0.minUpdateDiffPercent = uint16(params_.minUpdateDiffPercent);\n        _slot0.minHeartbeat = uint24(params_.minHeartbeat);\n\n        _slot0.flags =\n            (params_.avoidForcedLiquidationsCol ? _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL : 0) |\n            (params_.avoidForcedLiquidationsDebt ? _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT : 0);\n\n        _slot1.maxAPRPercent = uint24(params_.maxAPRPercent / uint256(100));\n        _slot1.maxDownFromMaxReachedPercentCol = (params_.maxDownFromMaxReachedPercentCol == 0 &&\n            !params_.avoidForcedLiquidationsCol)\n            ? uint24(_SIX_DECIMALS) // set to 100% by default when this config is not active\n            : uint24(params_.maxDownFromMaxReachedPercentCol);\n        _slot1.maxDownFromMaxReachedPercentDebt = uint24(params_.maxDownFromMaxReachedPercentDebt);\n        _slot1.maxDebtUpCapPercent = uint16(params_.maxDebtUpCapPercent / uint256(100));\n        _slot1.maxReachedAPRCappedRate = _slot0.rate;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() public view virtual returns (uint256 exchangeRate_) {\n        // deprecated legacy support method -> Should not be used anywhere anymore.\n        Slot0 memory slot0_ = _slot0;\n\n        if (_isHeartbeatTrigger(slot0_)) {\n            Slot1 memory slot1_ = _slot1;\n            (exchangeRate_, , , ) = _getUpdateRates(\n                uint256(slot1_.maxReachedAPRCappedRate),\n                slot0_,\n                uint256(slot1_.maxAPRPercent)\n            );\n            return exchangeRate_;\n        }\n        return uint256(slot0_.rate);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() public view virtual returns (uint256 exchangeRate_) {\n        // for col -> up APR capped (avoid overpricing exploit), down no cap\n        Slot0 memory slot0_ = _slot0;\n\n        if (_isHeartbeatTrigger(slot0_)) {\n            Slot1 memory slot1_ = _slot1;\n            uint256 maxReachedRate_;\n            bool isUpMaxAPRCapped_;\n            (exchangeRate_, maxReachedRate_, isUpMaxAPRCapped_, ) = _getUpdateRates(\n                uint256(slot1_.maxReachedAPRCappedRate),\n                slot0_,\n                uint256(slot1_.maxAPRPercent)\n            );\n            return isUpMaxAPRCapped_ ? maxReachedRate_ : exchangeRate_;\n        }\n\n        return\n            (slot0_.flags & _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED == _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED) // is _isUpMaxAPRCapped\n                ? uint256(_slot1.maxReachedAPRCappedRate)\n                : uint256(slot0_.rate);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() public view virtual returns (uint256 exchangeRate_) {\n        // for col -> up max APR cap, down capped (avoid forced liquidations attack)\n        Slot0 memory slot0_ = _slot0;\n\n        Slot1 memory slot1_; // only read if needed\n\n        uint256 maxReachedRate_;\n        bool isUpMaxAPRCapped_;\n        bool isRateBelowMaxReached_;\n\n        if (_isHeartbeatTrigger(slot0_)) {\n            slot1_ = _slot1;\n            (exchangeRate_, maxReachedRate_, isUpMaxAPRCapped_, isRateBelowMaxReached_) = _getUpdateRates(\n                uint256(slot1_.maxReachedAPRCappedRate),\n                slot0_,\n                uint256(slot1_.maxAPRPercent)\n            );\n        } else {\n            isUpMaxAPRCapped_ = slot0_.flags & _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED == _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED;\n            isRateBelowMaxReached_ =\n                slot0_.flags & _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED == _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED;\n            exchangeRate_ = uint256(slot0_.rate);\n        }\n\n        if (isUpMaxAPRCapped_) {\n            return maxReachedRate_ > 0 ? maxReachedRate_ : uint256(_slot1.maxReachedAPRCappedRate);\n        }\n\n        if (\n            isRateBelowMaxReached_ &&\n            (slot0_.flags & _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL == _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL)\n        ) {\n            // is _avoidForcedLiquidationsCol\n            if (slot1_.maxReachedAPRCappedRate == 0) {\n                slot1_ = _slot1;\n            }\n\n            return\n                _calcDownCappedRate(\n                    exchangeRate_,\n                    maxReachedRate_ > 0 ? maxReachedRate_ : uint256(slot1_.maxReachedAPRCappedRate),\n                    uint256(slot1_.maxDownFromMaxReachedPercentCol)\n                );\n        }\n\n        return exchangeRate_;\n    }\n\n    /// @inheritdoc IFluidCappedRate\n    function getExchangeRateOperateDebt() public view virtual returns (uint256 exchangeRate_) {\n        // for debt -> up no cap, down capped (avoid underpricing exploit)\n        Slot0 memory slot0_ = _slot0;\n\n        Slot1 memory slot1_; // only read if needed\n\n        uint256 maxReachedRate_;\n        bool isRateBelowMaxReached_;\n\n        if (_isHeartbeatTrigger(slot0_)) {\n            slot1_ = _slot1;\n            (exchangeRate_, maxReachedRate_, , isRateBelowMaxReached_) = _getUpdateRates(\n                uint256(slot1_.maxReachedAPRCappedRate),\n                slot0_,\n                uint256(slot1_.maxAPRPercent)\n            );\n        } else {\n            exchangeRate_ = uint256(slot0_.rate);\n            isRateBelowMaxReached_ =\n                slot0_.flags & _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED == _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED;\n        }\n\n        if (!isRateBelowMaxReached_) {\n            return exchangeRate_;\n        }\n\n        if (slot1_.maxReachedAPRCappedRate == 0) {\n            slot1_ = _slot1;\n        }\n\n        return\n            _calcDownCappedRate(\n                exchangeRate_,\n                maxReachedRate_ > 0 ? maxReachedRate_ : uint256(slot1_.maxReachedAPRCappedRate),\n                uint256(slot1_.maxDownFromMaxReachedPercentDebt)\n            );\n    }\n\n    /// @inheritdoc IFluidCappedRate\n    function getExchangeRateLiquidateDebt() public view virtual returns (uint256 exchangeRate_) {\n        // for debt -> up max APR capped (avoid forced liquidations attack), down capped\n        Slot0 memory slot0_ = _slot0;\n        Slot1 memory slot1_; // only read if needed\n\n        uint256 maxReachedRate_;\n        bool isRateBelowMaxReached_;\n        bool isUpMaxAPRCapped_;\n\n        if (_isHeartbeatTrigger(slot0_)) {\n            slot1_ = _slot1;\n            (exchangeRate_, maxReachedRate_, isUpMaxAPRCapped_, isRateBelowMaxReached_) = _getUpdateRates(\n                uint256(slot1_.maxReachedAPRCappedRate),\n                slot0_,\n                uint256(slot1_.maxAPRPercent)\n            );\n        } else {\n            exchangeRate_ = uint256(slot0_.rate);\n            isRateBelowMaxReached_ =\n                slot0_.flags & _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED == _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED;\n            isUpMaxAPRCapped_ = slot0_.flags & _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED == _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED;\n        }\n\n        if (\n            isUpMaxAPRCapped_ &&\n            (slot0_.flags & _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT ==\n                _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT)\n        ) {\n            // is _avoidForcedLiquidationsDebt\n            // case _rate > _maxReachedAPRCappedRate\n            if (maxReachedRate_ == 0) {\n                slot1_ = _slot1;\n                maxReachedRate_ = uint256(slot1_.maxReachedAPRCappedRate);\n            }\n            // add max up cap percent on top\n            maxReachedRate_ =\n                (maxReachedRate_ * (_SIX_DECIMALS + uint256(slot1_.maxDebtUpCapPercent) * uint256(100))) /\n                _SIX_DECIMALS;\n\n            // return max(exchangeRate_, maxReachedRate_) where maxReachedRate_ is maxAPRReachedRate + maxDebtUpCapPercent on top\n            return exchangeRate_ > maxReachedRate_ ? maxReachedRate_ : exchangeRate_;\n        }\n\n        if (!isRateBelowMaxReached_) {\n            return exchangeRate_;\n        }\n\n        if (slot1_.maxReachedAPRCappedRate == 0) {\n            slot1_ = _slot1;\n        }\n\n        return\n            _calcDownCappedRate(\n                exchangeRate_,\n                maxReachedRate_ > 0 ? maxReachedRate_ : uint256(slot1_.maxReachedAPRCappedRate),\n                uint256(slot1_.maxDownFromMaxReachedPercentDebt)\n            );\n    }\n\n    /// @notice Rebalance the stored rates according to the newly fetched rate from the external source.\n    /// @dev The rate is only updated if the difference between the current rate and the new rate is greater than or\n    ///      equal to the minimum update difference percentage for either rate or maxRate OR if the heartbeat is reached\n    function rebalance() external {\n        _updateRates(_isHeartbeatTrigger(_slot0));\n    }\n\n    /// @notice Returns rates: capped and uncapped, and current cap status\n    /// @return rate_ The rate_ value: last fetched value from external source with no cap up and no cap down as in storage\n    /// @return maxReachedRate_ The maximum reached upward capped rate for col: within APR percent limit as in storage\n    /// @return maxUpCappedRateDebt_ The maximum reached upward capped rate for debt: up to `maxReachedRate_` + `maxDebtUpCapPercent` on top\n    /// @return isRateBelowMaxReached_ Indicates if the rate is currently below the maximum reached APR capped rate flag as in storage\n    /// @return isUpMaxAPRCapped_ Indicates if the rate is currently capped due to exceeding the maximum APR limit flag as in storage\n    /// @return downCappedRateCol_ The capped downward rate on col side\n    /// @return downCappedRateDebt_ The capped downward rate on debt side\n    /// @return isDownCappedCol_ Indicates if the rate is currently getting downward capped on col side\n    /// @return isDownCappedDebt_ Indicates if the rate is currently getting downward capped on debt side\n    /// @return isUpCapped_ Indicates if the rate is currently getting upward capped\n    function getRatesAndCaps()\n        public\n        view\n        returns (\n            uint256 rate_,\n            uint256 maxReachedRate_,\n            uint256 maxUpCappedRateDebt_,\n            bool isRateBelowMaxReached_,\n            bool isUpMaxAPRCapped_,\n            uint256 downCappedRateCol_,\n            uint256 downCappedRateDebt_,\n            bool isDownCappedCol_,\n            bool isDownCappedDebt_,\n            bool isUpCapped_\n        )\n    {\n        Slot0 memory slot0_ = _slot0;\n        Slot1 memory slot1_ = _slot1;\n\n        if (_isHeartbeatTrigger(slot0_)) {\n            (rate_, maxReachedRate_, isUpMaxAPRCapped_, isRateBelowMaxReached_) = _getUpdateRates(\n                uint256(slot1_.maxReachedAPRCappedRate),\n                slot0_,\n                uint256(slot1_.maxAPRPercent)\n            );\n        } else {\n            rate_ = uint256(slot0_.rate);\n            maxReachedRate_ = uint256(slot1_.maxReachedAPRCappedRate);\n            isRateBelowMaxReached_ =\n                slot0_.flags & _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED == _FLAG_BITMASK_IS_RATE_BELOW_MAX_REACHED;\n            isUpMaxAPRCapped_ = slot0_.flags & _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED == _FLAG_BITMASK_IS_UP_MAX_APR_CAPPED;\n        }\n\n        downCappedRateCol_ = _calcDownCappedRate(0, maxReachedRate_, uint256(slot1_.maxDownFromMaxReachedPercentCol));\n        downCappedRateDebt_ = _calcDownCappedRate(0, maxReachedRate_, uint256(slot1_.maxDownFromMaxReachedPercentDebt));\n\n        maxUpCappedRateDebt_ =\n            (maxReachedRate_ * (_SIX_DECIMALS + uint256(slot1_.maxDebtUpCapPercent) * uint256(100))) /\n            _SIX_DECIMALS;\n        if (rate_ > maxReachedRate_ && rate_ < maxUpCappedRateDebt_) {\n            // maxUpCappedRateDebt_ capped at + maxDebtUpCapPercent, but less if rate is less\n            maxUpCappedRateDebt_ = rate_;\n        }\n\n        isDownCappedCol_ = rate_ < downCappedRateCol_;\n        isDownCappedDebt_ = rate_ < downCappedRateDebt_;\n        isUpCapped_ = rate_ > maxReachedRate_;\n    }\n\n    /// @notice returns how much the new rate OR new max rate would be different from current value in storage in percent (10000 = 1%, 1 = 0.0001%).\n    function configPercentDiff() public view virtual returns (uint256 configPercentDiff_) {\n        Slot0 memory slot0_ = _slot0;\n        Slot1 memory slot1_ = _slot1;\n\n        (uint256 newRate_, uint256 newMaxReachedRate_, , ) = _getUpdateRates(\n            uint256(slot1_.maxReachedAPRCappedRate),\n            slot0_,\n            uint256(slot1_.maxAPRPercent)\n        );\n\n        uint256 rateDiff_ = _percentDiffForValue(uint256(slot0_.rate), newRate_);\n        uint256 maxRateDiff_ = _percentDiffForValue(uint256(slot1_.maxReachedAPRCappedRate), newMaxReachedRate_);\n\n        return rateDiff_ > maxRateDiff_ ? rateDiff_ : maxRateDiff_;\n    }\n\n    /// @notice returns all config vars, last update timestamp, and external rate source oracle address\n    function configData()\n        external\n        view\n        returns (\n            address liquidity_,\n            uint16 minUpdateDiffPercent_,\n            uint24 minHeartbeat_,\n            uint40 lastUpdateTime_,\n            address rateSource_,\n            bool invertCenterPrice_,\n            bool avoidForcedLiquidationsCol_,\n            bool avoidForcedLiquidationsDebt_,\n            uint256 maxAPRPercent_,\n            uint24 maxDownFromMaxReachedPercentCol_,\n            uint24 maxDownFromMaxReachedPercentDebt_,\n            uint256 maxDebtUpCapPercent_\n        )\n    {\n        Slot0 memory slot0_ = _slot0;\n        Slot1 memory slot1_ = _slot1;\n        return (\n            _LIQUIDITY,\n            slot0_.minUpdateDiffPercent,\n            slot0_.minHeartbeat,\n            slot0_.lastUpdateTime,\n            _RATE_SOURCE,\n            _INVERT_CENTER_PRICE,\n            (slot0_.flags & _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL) == _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_COL,\n            (slot0_.flags & _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT) ==\n                _FLAG_BITMASK_AVOID_FORCED_LIQUIDATIONS_DEBT,\n            uint256(slot1_.maxAPRPercent) * uint256(100),\n            slot1_.maxDownFromMaxReachedPercentCol,\n            slot1_.maxDownFromMaxReachedPercentDebt,\n            uint256(slot1_.maxDebtUpCapPercent) * uint256(100)\n        );\n    }\n\n    /// @notice returns true if last update timestamp is > min heart time update time ago so heartbeat update should trigger\n    function isHeartbeatTrigger() public view returns (bool) {\n        return _isHeartbeatTrigger(_slot0);\n    }\n}\n\n/// @notice This contract stores an exchange rate in intervals to optimize gas cost.\n/// @notice Properly implements all interfaces for use as IFluidCenterPrice and IFluidOracle.\nabstract contract FluidCappedRate is FluidCappedRateBase, FluidCenterPrice {\n    constructor(\n        CappedRateConstructorParams memory params_\n    ) FluidCappedRateBase(params_) FluidCenterPrice(params_.infoName) {}\n\n    /// @inheritdoc FluidCenterPrice\n    function centerPrice() external override(IFluidCappedRate, FluidCenterPrice) returns (uint256 price_) {\n        // for centerPrice -> no up cap, no down cap\n        Slot0 memory slot0_ = _slot0;\n        if (_isHeartbeatTrigger(slot0_)) {\n            return _invertRateIfNeeded(_updateRates(true));\n        }\n\n        return _invertRateIfNeeded(uint256(slot0_.rate));\n    }\n\n    /// @inheritdoc FluidCenterPrice\n    function infoName() public view override(IFluidOracle, FluidCenterPrice) returns (string memory) {\n        return super.infoName();\n    }\n\n    /// @inheritdoc IFluidOracle\n    function targetDecimals() public pure override(IFluidOracle, FluidCenterPrice) returns (uint8) {\n        return _TARGET_DECIMALS;\n    }\n}\n"
    },
    "contracts/oracle/fluidCappedRateL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidCappedRateBase } from \"./fluidCappedRate.sol\";\nimport { IFluidOracle } from \"./interfaces/iFluidOracle.sol\";\nimport { IFluidCappedRate } from \"./interfaces/iFluidCappedRate.sol\";\nimport { FluidCenterPriceL2 } from \"./fluidCenterPriceL2.sol\";\n\n/// @notice This contract stores an exchange rate in intervals to optimize gas cost for an L2\n/// @notice Properly implements all interfaces for use as IFluidCenterPrice and IFluidOracle.\nabstract contract FluidCappedRateL2 is FluidCappedRateBase, FluidCenterPriceL2 {\n    constructor(\n        CappedRateConstructorParams memory params_,\n        address sequencerUptimeFeed_\n    ) FluidCappedRateBase(params_) FluidCenterPriceL2(params_.infoName, sequencerUptimeFeed_) {}\n\n    /// @inheritdoc FluidCenterPriceL2\n    function centerPrice() external override(IFluidCappedRate, FluidCenterPriceL2) returns (uint256 price_) {\n        _ensureSequencerUpAndValid();\n\n        // for centerPrice -> no up cap, no down cap\n        Slot0 memory slot0_ = _slot0;\n        if (_isHeartbeatTrigger(slot0_)) {\n            return _updateRates(true);\n        }\n\n        return uint256(slot0_.rate);\n    }\n\n    /// @inheritdoc FluidCenterPriceL2\n    function infoName() public view override(IFluidOracle, FluidCenterPriceL2) returns (string memory) {\n        return super.infoName();\n    }\n\n    /// @inheritdoc IFluidOracle\n    function targetDecimals() public pure override(IFluidOracle, FluidCenterPriceL2) returns (uint8) {\n        return _TARGET_DECIMALS;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() public view virtual override returns (uint256 exchangeRate_) {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRate();\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() public view virtual override returns (uint256 exchangeRate_) {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateOperate();\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() public view virtual override returns (uint256 exchangeRate_) {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateLiquidate();\n    }\n\n    /// @inheritdoc IFluidCappedRate\n    function getExchangeRateOperateDebt() public view virtual override returns (uint256 exchangeRate_) {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateOperateDebt();\n    }\n\n    /// @inheritdoc IFluidCappedRate\n    function getExchangeRateLiquidateDebt() public view virtual override returns (uint256 exchangeRate_) {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateLiquidateDebt();\n    }\n}\n"
    },
    "contracts/oracle/fluidCenterPrice.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidCenterPrice } from \"./interfaces/iFluidCenterPrice.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { Error as OracleError } from \"./error.sol\";\n\n/// @title   FluidCenterPrice\n/// @notice  Base contract that any Fluid Center Price must implement\nabstract contract FluidCenterPrice is IFluidCenterPrice, OracleError {\n    /// @dev short helper string to easily identify the center price oracle. E.g. token symbols\n    //\n    // using a bytes32 because string can not be immutable.\n    bytes32 private immutable _infoName;\n\n    uint8 internal constant _TARGET_DECIMALS = 27; // target decimals for center price and contract rates is always 27\n\n    constructor(string memory infoName_) {\n        if (bytes(infoName_).length > 32 || bytes(infoName_).length == 0) {\n            revert FluidOracleError(ErrorTypes.FluidOracle__InvalidInfoName);\n        }\n\n        // convert string to bytes32\n        bytes32 infoNameBytes32_;\n        assembly {\n            infoNameBytes32_ := mload(add(infoName_, 32))\n        }\n        _infoName = infoNameBytes32_;\n    }\n\n    /// @inheritdoc IFluidCenterPrice\n    function targetDecimals() public pure virtual returns (uint8) {\n        return _TARGET_DECIMALS;\n    }\n\n    /// @inheritdoc IFluidCenterPrice\n    function infoName() public view virtual returns (string memory) {\n        // convert bytes32 to string\n        uint256 length_;\n        while (length_ < 32 && _infoName[length_] != 0) {\n            length_++;\n        }\n        bytes memory infoNameBytes_ = new bytes(length_);\n        for (uint256 i; i < length_; i++) {\n            infoNameBytes_[i] = _infoName[i];\n        }\n        return string(infoNameBytes_);\n    }\n\n    /// @inheritdoc IFluidCenterPrice\n    function centerPrice() external virtual returns (uint256 price_);\n}\n"
    },
    "contracts/oracle/fluidCenterPriceL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidCenterPrice } from \"./interfaces/iFluidCenterPrice.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { Error as OracleError } from \"./error.sol\";\nimport { IChainlinkAggregatorV3 } from \"./interfaces/external/IChainlinkAggregatorV3.sol\";\n\n/// @title   FluidCenterPriceL2\n/// @notice  Base contract that any Fluid Center Price L2 must implement\nabstract contract FluidCenterPriceL2 is IFluidCenterPrice, OracleError {\n    /// @dev short helper string to easily identify the center price oracle. E.g. token symbols\n    //\n    // using a bytes32 because string can not be immutable.\n    bytes32 private immutable _infoName;\n\n    uint8 internal constant _TARGET_DECIMALS = 27; // target decimals for center price and contract rates is always 27\n\n    /// @dev Chainlink L2 Sequencer Uptime feed to detect sequencer outages\n    IChainlinkAggregatorV3 internal immutable _SEQUENCER_ORACLE;\n    /// @dev max time period until oracle assumes normal behavior after a sequencer outage.\n    uint256 internal constant _SEQUENCER_MAX_GRACE_PERIOD = 45 minutes;\n\n    constructor(string memory infoName_, address sequencerUptimeFeed_) {\n        if (bytes(infoName_).length > 32 || bytes(infoName_).length == 0) {\n            revert FluidOracleError(ErrorTypes.FluidOracle__InvalidInfoName);\n        }\n\n        // convert string to bytes32\n        bytes32 infoNameBytes32_;\n        assembly {\n            infoNameBytes32_ := mload(add(infoName_, 32))\n        }\n        _infoName = infoNameBytes32_;\n\n        _SEQUENCER_ORACLE = IChainlinkAggregatorV3(sequencerUptimeFeed_);\n    }\n\n    /// @notice returns all sequencer uptime feed related data\n    function sequencerL2Data()\n        public\n        view\n        returns (\n            address sequencerUptimeFeed_,\n            uint256 maxGracePeriod_,\n            bool isSequencerUp_,\n            uint256 lastUptimeStartedAt_,\n            uint256 gracePeriod_,\n            bool gracePeriodPassed_,\n            uint256 lastOutageStartedAt_,\n            bool isSequencerUpAndValid_\n        )\n    {\n        uint80 uptimeStartRoundId_;\n        (isSequencerUp_, uptimeStartRoundId_, lastUptimeStartedAt_) = _sequencerUpStatus();\n\n        if (isSequencerUp_) {\n            (gracePeriod_, gracePeriodPassed_, lastOutageStartedAt_) = _gracePeriod(\n                uptimeStartRoundId_,\n                lastUptimeStartedAt_\n            );\n        } else {\n            gracePeriod_ = _SEQUENCER_MAX_GRACE_PERIOD;\n            (uint80 roundId_, , , , ) = _SEQUENCER_ORACLE.latestRoundData();\n            lastOutageStartedAt_ = _lastSequencerOutageStart(roundId_ + 1);\n        }\n\n        return (\n            address(_SEQUENCER_ORACLE),\n            _SEQUENCER_MAX_GRACE_PERIOD,\n            isSequencerUp_,\n            lastUptimeStartedAt_,\n            gracePeriod_,\n            gracePeriodPassed_,\n            lastOutageStartedAt_,\n            isSequencerUp_ && gracePeriodPassed_\n        );\n    }\n\n    /// @dev ensures that the sequencer is up and grace period has passed\n    function _ensureSequencerUpAndValid() internal view {\n        (bool isSequencerUp_, uint80 uptimeStartRoundId_, uint256 uptimeStartedAt_) = _sequencerUpStatus();\n\n        if (!isSequencerUp_) {\n            revert FluidOracleError(ErrorTypes.FluidOracleL2__SequencerOutage);\n        }\n\n        (, bool gracePeriodPassed_, ) = _gracePeriod(uptimeStartRoundId_, uptimeStartedAt_);\n        if (!gracePeriodPassed_) {\n            revert FluidOracleError(ErrorTypes.FluidOracleL2__SequencerOutage);\n        }\n    }\n\n    /// @inheritdoc IFluidCenterPrice\n    function targetDecimals() public pure virtual returns (uint8) {\n        return _TARGET_DECIMALS;\n    }\n\n    /// @inheritdoc IFluidCenterPrice\n    function infoName() public view virtual returns (string memory) {\n        // convert bytes32 to string\n        uint256 length_;\n        while (length_ < 32 && _infoName[length_] != 0) {\n            length_++;\n        }\n        bytes memory infoNameBytes_ = new bytes(length_);\n        for (uint256 i; i < length_; i++) {\n            infoNameBytes_[i] = _infoName[i];\n        }\n        return string(infoNameBytes_);\n    }\n\n    /// @inheritdoc IFluidCenterPrice\n    function centerPrice() external virtual returns (uint256 price_);\n\n    /// @dev finds last round before `uptimeStartRoundId_` where sequencer status was down, incl. handling cases of\n    /// consecutive rounds where status was down.\n    function _lastSequencerOutageStart(uint80 uptimeStartRoundId_) private view returns (uint256 outageStartedAt_) {\n        uint80 roundId_ = uptimeStartRoundId_;\n        int256 answer_;\n        uint256 startedAt_;\n        do {\n            (roundId_, answer_, startedAt_, , ) = _SEQUENCER_ORACLE.getRoundData(roundId_ - 1);\n            if (answer_ != 0) {\n                // sequencer was down at this round, update outage started at data\n                outageStartedAt_ = startedAt_;\n            } // else: while loop is going to break\n        } while (answer_ != 0 && startedAt_ > 0);\n    }\n\n    /// @dev finds last round where sequencer status was up, incl. handling cases of consecutive rounds where status was up.\n    function _sequencerUpStatus()\n        private\n        view\n        returns (bool isSequencerUp_, uint80 uptimeStartRoundId_, uint256 uptimeStartedAt_)\n    {\n        (uint80 roundId_, int256 answer_, uint256 startedAt_, , ) = _SEQUENCER_ORACLE.latestRoundData();\n        if (answer_ != 0) {\n            // sequencer is down currently.\n            return (false, 0, 0);\n        }\n\n        isSequencerUp_ = true;\n\n        // cover case where there were other consecutive uptime report rounds in between\n        uptimeStartRoundId_ = roundId_;\n        uptimeStartedAt_ = startedAt_;\n        if (uptimeStartedAt_ > 0) {\n            do {\n                (roundId_, answer_, startedAt_, , ) = _SEQUENCER_ORACLE.getRoundData(roundId_ - 1);\n                if (answer_ == 0) {\n                    // sequencer was up at this round, consecutive uptime so update uptime start data\n                    uptimeStartRoundId_ = roundId_;\n                    uptimeStartedAt_ = startedAt_;\n                } // else: while loop is going to break\n            } while (answer_ == 0 && startedAt_ > 0);\n        } // else if startedAt == 0, then it is the first ever round.\n    }\n\n    /// @dev returns the `gracePeriod_` duration and if the grace period has `passed_` based on\n    /// current uptime round data vs the last sequencer outage duration.\n    function _gracePeriod(\n        uint80 uptimeStartRoundId_,\n        uint256 uptimeStartedAt_\n    ) private view returns (uint256 gracePeriod_, bool passed_, uint256 outageStartedAt_) {\n        uint256 uptimeDuration_ = block.timestamp - uptimeStartedAt_;\n        if (uptimeStartedAt_ == 0 || uptimeDuration_ > _SEQUENCER_MAX_GRACE_PERIOD) {\n            return (_SEQUENCER_MAX_GRACE_PERIOD, true, 0);\n        }\n\n        outageStartedAt_ = _lastSequencerOutageStart(uptimeStartRoundId_);\n\n        // grace period is outage duration, capped at _SEQUENCER_MAX_GRACE_PERIOD\n        gracePeriod_ = uptimeStartedAt_ - outageStartedAt_; // outage duration\n        if (gracePeriod_ > _SEQUENCER_MAX_GRACE_PERIOD) {\n            gracePeriod_ = _SEQUENCER_MAX_GRACE_PERIOD;\n        }\n\n        return (gracePeriod_, uptimeDuration_ > gracePeriod_, outageStartedAt_);\n    }\n}\n"
    },
    "contracts/oracle/fluidOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"./interfaces/iFluidOracle.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { Error as OracleError } from \"./error.sol\";\n\n/// @title   FluidOracle\n/// @notice  Base contract that any Fluid Oracle must implement\nabstract contract FluidOracle is IFluidOracle, OracleError {\n    /// @dev short helper string to easily identify the oracle. E.g. token symbols\n    //\n    // using a bytes32 because string can not be immutable.\n    bytes32 private immutable _infoName;\n\n    /// @dev target decimals of the oracle when scaling to 1e27. E.g. for ETH / USDC it would be 15\n    /// because diff of ETH decimals to 1e27 is 9, and USDC has 6 decimals, so 6+9 = 15, e.g. 2029,047772120364926\n    /// For USDC / ETH: 21 + 18 = 39, e.g. 0,000492842018675092636829357843847601646\n    uint8 private immutable _targetDecimals;\n\n    constructor(string memory infoName_, uint8 targetDecimals_) {\n        if (bytes(infoName_).length > 32 || bytes(infoName_).length == 0) {\n            revert FluidOracleError(ErrorTypes.FluidOracle__InvalidInfoName);\n        }\n\n        if (targetDecimals_ < 15 || targetDecimals_ > 39) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__InvalidParams);\n        }\n        _targetDecimals = targetDecimals_;\n\n        // convert string to bytes32\n        bytes32 infoNameBytes32_;\n        assembly {\n            infoNameBytes32_ := mload(add(infoName_, 32))\n        }\n        _infoName = infoNameBytes32_;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function targetDecimals() external view returns (uint8) {\n        return _targetDecimals;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function infoName() external view returns (string memory) {\n        // convert bytes32 to string\n        uint256 length_;\n        while (length_ < 32 && _infoName[length_] != 0) {\n            length_++;\n        }\n        bytes memory infoNameBytes_ = new bytes(length_);\n        for (uint256 i; i < length_; i++) {\n            infoNameBytes_[i] = _infoName[i];\n        }\n        return string(infoNameBytes_);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() external view virtual returns (uint256 exchangeRate_);\n}\n"
    },
    "contracts/oracle/fluidOracleL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"./interfaces/iFluidOracle.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { IChainlinkAggregatorV3 } from \"./interfaces/external/IChainlinkAggregatorV3.sol\";\nimport { Error as OracleError } from \"./error.sol\";\n\n/// @title   FluidOracleL2\n/// @notice  Base contract that any Fluid Oracle L2 must implement\nabstract contract FluidOracleL2 is IFluidOracle, OracleError {\n    /// @dev Chainlink L2 Sequencer Uptime feed to detect sequencer outages\n    IChainlinkAggregatorV3 internal immutable _SEQUENCER_ORACLE;\n    /// @dev max time period until oracle assumes normal behavior after a sequencer outage.\n    uint256 internal constant _SEQUENCER_MAX_GRACE_PERIOD = 45 minutes;\n\n    /// @notice sets the L2 sequencer uptime Chainlink feed\n    constructor(address sequencerUptimeFeed_) {\n        _SEQUENCER_ORACLE = IChainlinkAggregatorV3(sequencerUptimeFeed_);\n    }\n\n    /// @notice returns all sequencer uptime feed related data\n    function sequencerL2Data()\n        public\n        view\n        returns (\n            address sequencerUptimeFeed_,\n            uint256 maxGracePeriod_,\n            bool isSequencerUp_,\n            uint256 lastUptimeStartedAt_,\n            uint256 gracePeriod_,\n            bool gracePeriodPassed_,\n            uint256 lastOutageStartedAt_,\n            bool isSequencerUpAndValid_\n        )\n    {\n        uint80 uptimeStartRoundId_;\n        (isSequencerUp_, uptimeStartRoundId_, lastUptimeStartedAt_) = _sequencerUpStatus();\n\n        if (isSequencerUp_) {\n            (gracePeriod_, gracePeriodPassed_, lastOutageStartedAt_) = _gracePeriod(\n                uptimeStartRoundId_,\n                lastUptimeStartedAt_\n            );\n        } else {\n            gracePeriod_ = _SEQUENCER_MAX_GRACE_PERIOD;\n            (uint80 roundId_, , , , ) = _SEQUENCER_ORACLE.latestRoundData();\n            lastOutageStartedAt_ = _lastSequencerOutageStart(roundId_ + 1);\n        }\n\n        return (\n            address(_SEQUENCER_ORACLE),\n            _SEQUENCER_MAX_GRACE_PERIOD,\n            isSequencerUp_,\n            lastUptimeStartedAt_,\n            gracePeriod_,\n            gracePeriodPassed_,\n            lastOutageStartedAt_,\n            isSequencerUp_ && gracePeriodPassed_\n        );\n    }\n\n    /// @dev ensures that the sequencer is up and grace period has passed\n    function _ensureSequencerUpAndValid() internal view {\n        (bool isSequencerUp_, uint80 uptimeStartRoundId_, uint256 uptimeStartedAt_) = _sequencerUpStatus();\n\n        if (!isSequencerUp_) {\n            revert FluidOracleError(ErrorTypes.FluidOracleL2__SequencerOutage);\n        }\n\n        (, bool gracePeriodPassed_, ) = _gracePeriod(uptimeStartRoundId_, uptimeStartedAt_);\n        if (!gracePeriodPassed_) {\n            revert FluidOracleError(ErrorTypes.FluidOracleL2__SequencerOutage);\n        }\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @dev finds last round before `uptimeStartRoundId_` where sequencer status was down, incl. handling cases of\n    /// consecutive rounds where status was down.\n    function _lastSequencerOutageStart(uint80 uptimeStartRoundId_) private view returns (uint256 outageStartedAt_) {\n        uint80 roundId_ = uptimeStartRoundId_;\n        int256 answer_;\n        uint256 startedAt_;\n        do {\n            (roundId_, answer_, startedAt_, , ) = _SEQUENCER_ORACLE.getRoundData(roundId_ - 1);\n            if (answer_ != 0) {\n                // sequencer was down at this round, update outage started at data\n                outageStartedAt_ = startedAt_;\n            } // else: while loop is going to break\n        } while (answer_ != 0 && startedAt_ > 0);\n    }\n\n    /// @dev finds last round where sequencer status was up, incl. handling cases of consecutive rounds where status was up.\n    function _sequencerUpStatus()\n        private\n        view\n        returns (bool isSequencerUp_, uint80 uptimeStartRoundId_, uint256 uptimeStartedAt_)\n    {\n        (uint80 roundId_, int256 answer_, uint256 startedAt_, , ) = _SEQUENCER_ORACLE.latestRoundData();\n        if (answer_ != 0) {\n            // sequencer is down currently.\n            return (false, 0, 0);\n        }\n\n        isSequencerUp_ = true;\n\n        // cover case where there were other consecutive uptime report rounds in between\n        uptimeStartRoundId_ = roundId_;\n        uptimeStartedAt_ = startedAt_;\n        if (uptimeStartedAt_ > 0) {\n            do {\n                (roundId_, answer_, startedAt_, , ) = _SEQUENCER_ORACLE.getRoundData(roundId_ - 1);\n                if (answer_ == 0) {\n                    // sequencer was up at this round, consecutive uptime so update uptime start data\n                    uptimeStartRoundId_ = roundId_;\n                    uptimeStartedAt_ = startedAt_;\n                } // else: while loop is going to break\n            } while (answer_ == 0 && startedAt_ > 0);\n        } // else if startedAt == 0, then it is the first ever round.\n    }\n\n    /// @dev returns the `gracePeriod_` duration and if the grace period has `passed_` based on\n    /// current uptime round data vs the last sequencer outage duration.\n    function _gracePeriod(\n        uint80 uptimeStartRoundId_,\n        uint256 uptimeStartedAt_\n    ) private view returns (uint256 gracePeriod_, bool passed_, uint256 outageStartedAt_) {\n        uint256 uptimeDuration_ = block.timestamp - uptimeStartedAt_;\n        if (uptimeStartedAt_ == 0 || uptimeDuration_ > _SEQUENCER_MAX_GRACE_PERIOD) {\n            return (_SEQUENCER_MAX_GRACE_PERIOD, true, 0);\n        }\n\n        outageStartedAt_ = _lastSequencerOutageStart(uptimeStartRoundId_);\n\n        // grace period is outage duration, capped at _SEQUENCER_MAX_GRACE_PERIOD\n        gracePeriod_ = uptimeStartedAt_ - outageStartedAt_; // outage duration\n        if (gracePeriod_ > _SEQUENCER_MAX_GRACE_PERIOD) {\n            gracePeriod_ = _SEQUENCER_MAX_GRACE_PERIOD;\n        }\n\n        return (gracePeriod_, uptimeDuration_ > gracePeriod_, outageStartedAt_);\n    }\n}\n"
    },
    "contracts/oracle/implementations/chainlinkOracleImpl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { IChainlinkAggregatorV3 } from \"../interfaces/external/IChainlinkAggregatorV3.sol\";\nimport { Error as OracleError } from \"../error.sol\";\nimport { OracleUtils } from \"../libraries/oracleUtils.sol\";\nimport { ChainlinkStructs } from \"./structs.sol\";\n\n/// @title   Chainlink Oracle implementation\n/// @notice  This contract is used to get the exchange rate via up to 3 hops at Chainlink price feeds.\n///          The rate is multiplied with the previous rate at each hop.\n///          E.g. to go from wBTC to USDC (assuming rates for example):\n///          1. wBTC -> BTC https://data.chain.link/ethereum/mainnet/crypto-other/wbtc-btc, rate: 0.92.\n///          2. BTC -> USD https://data.chain.link/ethereum/mainnet/crypto-usd/btc-usd rate: 30,000.\n///          3. USD -> USDC https://data.chain.link/ethereum/mainnet/stablecoins/usdc-usd rate: 0.98. Must invert feed: 1.02\n///          finale rate would be: 0.92 * 30,000 * 1.02 = 28,152\nabstract contract ChainlinkOracleImpl is OracleError, ChainlinkStructs {\n    /// @notice Chainlink price feed 1 to check for the exchange rate\n    IChainlinkAggregatorV3 internal immutable _CHAINLINK_FEED1;\n    /// @notice Chainlink price feed 2 to check for the exchange rate\n    IChainlinkAggregatorV3 internal immutable _CHAINLINK_FEED2;\n    /// @notice Chainlink price feed 3 to check for the exchange rate\n    IChainlinkAggregatorV3 internal immutable _CHAINLINK_FEED3;\n\n    /// @notice Flag to invert the price or not for feed 1 (to e.g. for WETH/USDC pool return prive of USDC per 1 WETH)\n    bool internal immutable _CHAINLINK_INVERT_RATE1;\n    /// @notice Flag to invert the price or not for feed 2 (to e.g. for WETH/USDC pool return prive of USDC per 1 WETH)\n    bool internal immutable _CHAINLINK_INVERT_RATE2;\n    /// @notice Flag to invert the price or not for feed 3 (to e.g. for WETH/USDC pool return prive of USDC per 1 WETH)\n    bool internal immutable _CHAINLINK_INVERT_RATE3;\n\n    /// @notice constant value for price scaling to reduce gas usage for feed 1\n    uint256 internal immutable _CHAINLINK_PRICE_SCALER_MULTIPLIER1;\n    /// @notice constant value for inverting price to reduce gas usage for feed 1\n    uint256 internal immutable _CHAINLINK_INVERT_PRICE_DIVIDEND1;\n\n    /// @notice constant value for price scaling to reduce gas usage for feed 2\n    uint256 internal immutable _CHAINLINK_PRICE_SCALER_MULTIPLIER2;\n    /// @notice constant value for inverting price to reduce gas usage for feed 2\n    uint256 internal immutable _CHAINLINK_INVERT_PRICE_DIVIDEND2;\n\n    /// @notice constant value for price scaling to reduce gas usage for feed 3\n    uint256 internal immutable _CHAINLINK_PRICE_SCALER_MULTIPLIER3;\n    /// @notice constant value for inverting price to reduce gas usage for feed 3\n    uint256 internal immutable _CHAINLINK_INVERT_PRICE_DIVIDEND3;\n\n    /// @notice constructor sets the Chainlink price feed and invertRate flag for each hop.\n    /// E.g. `invertRate_` should be true if for the USDC/ETH pool it's expected that the oracle returns USDC per 1 ETH\n    constructor(ChainlinkConstructorParams memory params_) {\n        if (\n            (params_.hops < 1 || params_.hops > 3) || // hops must be 1, 2 or 3\n            (address(params_.feed1.feed) == address(0) || params_.feed1.token0Decimals == 0) || // first feed must always be defined\n            (params_.hops > 1 && (address(params_.feed2.feed) == address(0) || params_.feed2.token0Decimals == 0)) || // if hops > 1, feed 2 must be defined\n            (params_.hops > 2 && (address(params_.feed3.feed) == address(0) || params_.feed3.token0Decimals == 0)) // if hops > 2, feed 3 must be defined\n        ) {\n            revert FluidOracleError(ErrorTypes.ChainlinkOracle__InvalidParams);\n        }\n\n        _CHAINLINK_FEED1 = params_.feed1.feed;\n        _CHAINLINK_FEED2 = params_.feed2.feed;\n        _CHAINLINK_FEED3 = params_.feed3.feed;\n\n        _CHAINLINK_INVERT_RATE1 = params_.feed1.invertRate;\n        _CHAINLINK_INVERT_RATE2 = params_.feed2.invertRate;\n        _CHAINLINK_INVERT_RATE3 = params_.feed3.invertRate;\n\n        // Actual desired output rate example USDC/ETH (6 decimals / 18 decimals).\n        // Note ETH has 12 decimals more than USDC.\n        //    0.000515525322211842331991619857165357691 // 39 decimals.  ETH for 1 USDC\n        // 1954.190000000000433             // 15 decimals. USDC for 1 ETH\n\n        // to get to PRICE_SCLAER_MULTIPLIER and INVERT_PRICE_DIVIDEND:\n        // fetched Chainlink price is in token1Decimals per 1 token0Decimals.\n        // E.g. for an USDC/ETH price feed it's in ETH 18 decimals.\n        //      for an  BTC/USD price feed it's in USD  8 decimals.\n        // So to scale to 1e27 we need to multiply by 1e27 - token0Decimals.\n        // E.g. for USDC/ETH it would be: fetchedPrice * 1e21\n        //\n        // or for inverted (x token0 per 1 token1), formula would be:\n        //    = 1e27 * 10**token0Decimals / fetchedPrice\n        // E.g. for USDC/ETH it would be: 1e33 / fetchedPrice\n\n        // no support for token1Decimals with more than OracleUtils.RATE_OUTPUT_DECIMALS decimals for now as extremely unlikely case\n        _CHAINLINK_PRICE_SCALER_MULTIPLIER1 = 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS - params_.feed1.token0Decimals);\n        _CHAINLINK_INVERT_PRICE_DIVIDEND1 = 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS + params_.feed1.token0Decimals);\n\n        _CHAINLINK_PRICE_SCALER_MULTIPLIER2 = params_.hops > 1\n            ? 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS - params_.feed2.token0Decimals)\n            : 1;\n        _CHAINLINK_INVERT_PRICE_DIVIDEND2 = params_.hops > 1\n            ? 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS + params_.feed2.token0Decimals)\n            : 1;\n\n        _CHAINLINK_PRICE_SCALER_MULTIPLIER3 = params_.hops > 2\n            ? 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS - params_.feed3.token0Decimals)\n            : 1;\n        _CHAINLINK_INVERT_PRICE_DIVIDEND3 = params_.hops > 2\n            ? 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS + params_.feed3.token0Decimals)\n            : 1;\n    }\n\n    /// @dev            Get the exchange rate from Chainlike oracle price feed(s)\n    /// @return rate_   The exchange rate in `OracleUtils.RATE_OUTPUT_DECIMALS`\n    function _getChainlinkExchangeRate() internal view returns (uint256 rate_) {\n        rate_ = _readFeedRate(\n            _CHAINLINK_FEED1,\n            _CHAINLINK_INVERT_RATE1,\n            _CHAINLINK_PRICE_SCALER_MULTIPLIER1,\n            _CHAINLINK_INVERT_PRICE_DIVIDEND1\n        );\n        if (rate_ == 0 || address(_CHAINLINK_FEED2) == address(0)) {\n            // rate 0 or only 1 hop -> return rate of price feed 1\n            return rate_;\n        }\n        rate_ =\n            (rate_ *\n                _readFeedRate(\n                    _CHAINLINK_FEED2,\n                    _CHAINLINK_INVERT_RATE2,\n                    _CHAINLINK_PRICE_SCALER_MULTIPLIER2,\n                    _CHAINLINK_INVERT_PRICE_DIVIDEND2\n                )) /\n            (10 ** OracleUtils.RATE_OUTPUT_DECIMALS);\n\n        if (rate_ == 0 || address(_CHAINLINK_FEED3) == address(0)) {\n            // rate 0 or 2 hops -> return rate of feed 1 combined with feed 2\n            return rate_;\n        }\n\n        // 3 hops -> return rate of feed 1 combined with feed 2 & feed 3\n        rate_ =\n            (rate_ *\n                _readFeedRate(\n                    _CHAINLINK_FEED3,\n                    _CHAINLINK_INVERT_RATE3,\n                    _CHAINLINK_PRICE_SCALER_MULTIPLIER3,\n                    _CHAINLINK_INVERT_PRICE_DIVIDEND3\n                )) /\n            (10 ** OracleUtils.RATE_OUTPUT_DECIMALS);\n    }\n\n    /// @dev reads the exchange `rate_` from a Chainlink price `feed_` taking into account scaling and `invertRate_`\n    function _readFeedRate(\n        IChainlinkAggregatorV3 feed_,\n        bool invertRate_,\n        uint256 priceMultiplier_,\n        uint256 invertDividend_\n    ) private view returns (uint256 rate_) {\n        try feed_.latestRoundData() returns (uint80, int256 exchangeRate_, uint256, uint256, uint80) {\n            // Return the price in `OracleUtils.RATE_OUTPUT_DECIMALS`\n            if (invertRate_) {\n                return invertDividend_ / uint256(exchangeRate_);\n            } else {\n                return uint256(exchangeRate_) * priceMultiplier_;\n            }\n        } catch {\n            return 0;\n        }\n    }\n\n    /// @notice returns all Chainlink oracle related data as utility for easy off-chain use / block explorer in a single view method\n    function chainlinkOracleData()\n        public\n        view\n        returns (\n            uint256 chainlinkExchangeRate_,\n            IChainlinkAggregatorV3 chainlinkFeed1_,\n            bool chainlinkInvertRate1_,\n            uint256 chainlinkExchangeRate1_,\n            IChainlinkAggregatorV3 chainlinkFeed2_,\n            bool chainlinkInvertRate2_,\n            uint256 chainlinkExchangeRate2_,\n            IChainlinkAggregatorV3 chainlinkFeed3_,\n            bool chainlinkInvertRate3_,\n            uint256 chainlinkExchangeRate3_\n        )\n    {\n        return (\n            _getChainlinkExchangeRate(),\n            _CHAINLINK_FEED1,\n            _CHAINLINK_INVERT_RATE1,\n            _readFeedRate(\n                _CHAINLINK_FEED1,\n                _CHAINLINK_INVERT_RATE1,\n                _CHAINLINK_PRICE_SCALER_MULTIPLIER1,\n                _CHAINLINK_INVERT_PRICE_DIVIDEND1\n            ),\n            _CHAINLINK_FEED2,\n            _CHAINLINK_INVERT_RATE2,\n            address(_CHAINLINK_FEED2) == address(0)\n                ? 0\n                : _readFeedRate(\n                    _CHAINLINK_FEED2,\n                    _CHAINLINK_INVERT_RATE2,\n                    _CHAINLINK_PRICE_SCALER_MULTIPLIER2,\n                    _CHAINLINK_INVERT_PRICE_DIVIDEND2\n                ),\n            _CHAINLINK_FEED3,\n            _CHAINLINK_INVERT_RATE3,\n            address(_CHAINLINK_FEED3) == address(0)\n                ? 0\n                : _readFeedRate(\n                    _CHAINLINK_FEED3,\n                    _CHAINLINK_INVERT_RATE3,\n                    _CHAINLINK_PRICE_SCALER_MULTIPLIER3,\n                    _CHAINLINK_INVERT_PRICE_DIVIDEND3\n                )\n        );\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/colDebtPrices/colDebtPriceFluidOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"../../../interfaces/iFluidOracle.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { OracleUtils } from \"../../../libraries/oracleUtils.sol\";\nimport { DexColDebtPriceGetter } from \"./dexColDebtPriceGetter.sol\";\n\n/// @notice reads the col debt Oracle Price from a separately deployed FluidOracle\n/// @dev used to plug result of DexSmartColOracleImpl into any existing FluidOracle.\n/// result of DexSmartColOracleImpl is e.g. for WSTETH/ETH smart col, WSTETH amount per 1 share.\n/// we need 1 share in relation to debt. so e.g. wstETH/ETH smart col w.r.t. USDC debt.\n/// so plug result into wstETH/USDC oracle then we get USDC per 1 share.\nabstract contract DexColDebtPriceFluidOracle is DexColDebtPriceGetter {\n    /// @dev external IFluidOracle used to convert from col or debt shares to a Fluid vault debt token.\n    /// can be address zero if no conversion needed.\n    /// IFluidOracle always returns 1e27 scaled price (DEX_COL_DEBT_ORACLE_PRECISION).\n    IFluidOracle internal immutable COL_DEBT_ORACLE;\n    bool internal immutable COL_DEBT_INVERT;\n\n    constructor(IFluidOracle colDebtOracle_, bool colDebtInvert_) {\n        COL_DEBT_ORACLE = colDebtOracle_;\n        COL_DEBT_INVERT = colDebtInvert_;\n    }\n\n    function _getDexColDebtPriceOperate() internal view override returns (uint256 colDebtPrice_) {\n        if (address(COL_DEBT_ORACLE) == address(0)) {\n            return DEX_COL_DEBT_ORACLE_PRECISION;\n        }\n        colDebtPrice_ = COL_DEBT_ORACLE.getExchangeRateOperate();\n        if (COL_DEBT_INVERT) {\n            colDebtPrice_ = 1e54 / colDebtPrice_;\n        }\n    }\n\n    function _getDexColDebtPriceLiquidate() internal view override returns (uint256 colDebtPrice_) {\n        if (address(COL_DEBT_ORACLE) == address(0)) {\n            return DEX_COL_DEBT_ORACLE_PRECISION;\n        }\n        colDebtPrice_ = COL_DEBT_ORACLE.getExchangeRateLiquidate();\n        if (COL_DEBT_INVERT) {\n            colDebtPrice_ = 1e54 / colDebtPrice_;\n        }\n    }\n\n    /// @notice Returns Col/Debt Oracle data\n    function getDexColDebtOracleData() public view returns (address colDebtOracle_, bool colDebtInvert_) {\n        return (address(COL_DEBT_ORACLE), COL_DEBT_INVERT);\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/colDebtPrices/dexColDebtPriceGetter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @dev abstract contract that any Dex Oracle ColDebtPriceGetter should implement\nabstract contract DexColDebtPriceGetter {\n    uint256 internal constant DEX_COL_DEBT_ORACLE_PRECISION = 1e27;\n\n    function _getDexColDebtPriceOperate() internal view virtual returns (uint256 colDebtPrice_);\n\n    function _getDexColDebtPriceLiquidate() internal view virtual returns (uint256 colDebtPrice_);\n}\n"
    },
    "contracts/oracle/implementations/dex/conversionPriceGetters/conversionPriceCL.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { DexConversionPriceGetter } from \"./dexConversionPriceGetter.sol\";\nimport { ChainlinkOracleImpl } from \"../../../implementations/chainlinkOracleImpl.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @notice returns the reserves conversion price fetched from Chainlink feeds\nabstract contract DexConversionPriceCL is DexConversionPriceGetter, ChainlinkOracleImpl {\n    uint256 internal immutable RESERVES_CONVERSION_PRICE_MULTIPLIER;\n    uint256 internal immutable RESERVES_CONVERSION_PRICE_DIVISOR;\n\n    /// @dev for multiplier and divisor: a Fluid ChainlinkOracle returns the price in token decimals scaled to 1e27 e.g. for USDC per ETH\n    ///      it would be 3400e15 USDC if price is 3400$ per ETH. But the Dex internally would have a price of 3400e27. So for that example\n    ///      the multiplier would have to be 1e12 and the divisor 1.\n    /// @param reservesConversionPriceMultiplier_ The multiplier to bring the fetched price to token1/token0 form as used internally in Dex.\n    /// @param reservesConversionPriceDivisor_ The divisor to bring the fetched price to token1/token0 form as used internally in Dex.\n    constructor(\n        ChainlinkOracleImpl.ChainlinkConstructorParams memory reservesConversion_,\n        uint256 reservesConversionPriceMultiplier_,\n        uint256 reservesConversionPriceDivisor_\n    ) ChainlinkOracleImpl(reservesConversion_) {\n        if (reservesConversionPriceMultiplier_ == 0 || reservesConversionPriceDivisor_ == 0) {\n            revert FluidOracleError(ErrorTypes.DexOracle__InvalidParams);\n        }\n        RESERVES_CONVERSION_PRICE_MULTIPLIER = reservesConversionPriceMultiplier_;\n        RESERVES_CONVERSION_PRICE_DIVISOR = reservesConversionPriceDivisor_;\n    }\n\n    function _getDexReservesConversionPriceOperate() internal view override returns (uint256 conversionPrice_) {\n        // bring conversion price to form as used internally in Dex\n        conversionPrice_ =\n            (_getChainlinkExchangeRate() * RESERVES_CONVERSION_PRICE_MULTIPLIER) /\n            RESERVES_CONVERSION_PRICE_DIVISOR;\n\n        if (conversionPrice_ == 0) {\n            revert FluidOracleError(ErrorTypes.DexOracle__ExchangeRateZero);\n        }\n    }\n\n    function _getDexReservesConversionPriceLiquidate() internal view override returns (uint256 conversionPrice_) {\n        // bring conversion price to form as used internally in Dex\n        conversionPrice_ =\n            (_getChainlinkExchangeRate() * RESERVES_CONVERSION_PRICE_MULTIPLIER) /\n            RESERVES_CONVERSION_PRICE_DIVISOR;\n\n        if (conversionPrice_ == 0) {\n            revert FluidOracleError(ErrorTypes.DexOracle__ExchangeRateZero);\n        }\n    }\n\n    /// @notice Returns the configuration data of the DexConversionPriceFluidOracle.\n    ///\n    /// @return reservesConversionPriceMultiplier_ The multiplier for the reserves conversion price.\n    /// @return reservesConversionPriceDivisor_ The divisor for the reserves conversion price.\n    function getDexConversionPriceFluidOracleData()\n        public\n        view\n        returns (uint256 reservesConversionPriceMultiplier_, uint256 reservesConversionPriceDivisor_)\n    {\n        reservesConversionPriceMultiplier_ = RESERVES_CONVERSION_PRICE_MULTIPLIER;\n        reservesConversionPriceDivisor_ = RESERVES_CONVERSION_PRICE_DIVISOR;\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/conversionPriceGetters/conversionPriceFluidOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { DexConversionPriceGetter } from \"./dexConversionPriceGetter.sol\";\nimport { IFluidOracle } from \"../../../interfaces/iFluidOracle.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @notice returns the reserves conversion price fetched from a separately deployed FluidOracle\nabstract contract DexConversionPriceFluidOracle is DexConversionPriceGetter {\n    /// @dev external IFluidOracle used to convert token0 into token1 or the other way\n    /// around depending on _QUOTE_IN_TOKEN0.\n    IFluidOracle internal immutable RESERVES_CONVERSION_ORACLE;\n    bool internal immutable RESERVES_CONVERSION_INVERT;\n    uint256 internal immutable RESERVES_CONVERSION_PRICE_MULTIPLIER;\n    uint256 internal immutable RESERVES_CONVERSION_PRICE_DIVISOR;\n\n    struct DexConversionPriceFluidOracleParams {\n        address reservesConversionOracle;\n        bool reservesConversionInvert;\n        uint256 reservesConversionPriceMultiplier;\n        uint256 reservesConversionPriceDivisor;\n    }\n\n    /// @dev for multiplier and divisor: a FluidOracle returns the price in token decimals scaled to 1e27 e.g. for USDC per ETH\n    ///      it would be 3400e15 USDC if price is 3400$ per ETH. But the Dex internally would have a price of 3400e27. So for that example\n    ///      the multiplier would have to be 1e12 and the divisor 1.\n    /// @param conversionPriceParams_:\n    ///  - reservesConversionOracle The oracle used to convert reserves. Set to address zero if not needed.\n    ///  - reservesConversionInvert Whether to invert the reserves conversion. Can be skipped if no reservesConversionOracle is configured.\n    ///  - reservesConversionPriceMultiplier The multiplier to bring the fetched price to token1/token0 form as used internally in Dex.\n    ///  - reservesConversionPriceDivisor The divisor to bring the fetched price to token1/token0 form as used internally in Dex.\n    constructor(DexConversionPriceFluidOracleParams memory conversionPriceParams_) {\n        if (\n            conversionPriceParams_.reservesConversionPriceMultiplier == 0 ||\n            conversionPriceParams_.reservesConversionPriceDivisor == 0\n        ) {\n            revert FluidOracleError(ErrorTypes.DexOracle__InvalidParams);\n        }\n        RESERVES_CONVERSION_ORACLE = IFluidOracle(conversionPriceParams_.reservesConversionOracle);\n        RESERVES_CONVERSION_INVERT = conversionPriceParams_.reservesConversionInvert;\n        RESERVES_CONVERSION_PRICE_MULTIPLIER = conversionPriceParams_.reservesConversionPriceMultiplier;\n        RESERVES_CONVERSION_PRICE_DIVISOR = conversionPriceParams_.reservesConversionPriceDivisor;\n    }\n\n    function _getDexReservesConversionPriceOperate() internal view override returns (uint256 conversionPrice_) {\n        if (address(RESERVES_CONVERSION_ORACLE) == address(0)) {\n            return 1e27;\n        }\n\n        // bring conversion price to form as used internally in Dex\n        conversionPrice_ =\n            (RESERVES_CONVERSION_ORACLE.getExchangeRateOperate() * RESERVES_CONVERSION_PRICE_MULTIPLIER) /\n            RESERVES_CONVERSION_PRICE_DIVISOR;\n\n        if (RESERVES_CONVERSION_INVERT) {\n            conversionPrice_ = 1e54 / conversionPrice_;\n        }\n    }\n\n    function _getDexReservesConversionPriceLiquidate() internal view override returns (uint256 conversionPrice_) {\n        if (address(RESERVES_CONVERSION_ORACLE) == address(0)) {\n            return 1e27;\n        }\n\n        // bring conversion price to form as used internally in Dex\n        conversionPrice_ =\n            (RESERVES_CONVERSION_ORACLE.getExchangeRateLiquidate() * RESERVES_CONVERSION_PRICE_MULTIPLIER) /\n            RESERVES_CONVERSION_PRICE_DIVISOR;\n        if (RESERVES_CONVERSION_INVERT) {\n            conversionPrice_ = 1e54 / conversionPrice_;\n        }\n    }\n\n    /// @notice Returns the configuration data of the DexConversionPriceFluidOracle.\n    ///\n    /// @return reservesConversionOracle_ The address of the reserves conversion oracle.\n    /// @return reservesConversionInvert_ A boolean indicating if reserves conversion should be inverted.\n    /// @return reservesConversionPriceMultiplier_ The multiplier for the reserves conversion price.\n    /// @return reservesConversionPriceDivisor_ The divisor for the reserves conversion price.\n    function getDexConversionPriceFluidOracleData()\n        public\n        view\n        returns (\n            address reservesConversionOracle_,\n            bool reservesConversionInvert_,\n            uint256 reservesConversionPriceMultiplier_,\n            uint256 reservesConversionPriceDivisor_\n        )\n    {\n        reservesConversionOracle_ = address(RESERVES_CONVERSION_ORACLE);\n        reservesConversionInvert_ = RESERVES_CONVERSION_INVERT;\n        reservesConversionPriceMultiplier_ = RESERVES_CONVERSION_PRICE_MULTIPLIER;\n        reservesConversionPriceDivisor_ = RESERVES_CONVERSION_PRICE_DIVISOR;\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/conversionPriceGetters/dexConversionPriceGetter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { DexOracleBase } from \"../dexOracleBase.sol\";\n\n/// @dev abstract contract that any Dex Oracle ConversionPriceGetter should implement\nabstract contract DexConversionPriceGetter is DexOracleBase {\n    function _getDexReservesConversionPriceOperate() internal view virtual returns (uint256 conversionPrice_);\n\n    function _getDexReservesConversionPriceLiquidate() internal view virtual returns (uint256 conversionPrice_);\n}\n"
    },
    "contracts/oracle/implementations/dex/dexOracleBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error as OracleError } from \"../../error.sol\";\n\ninterface IFluidStorageReadable {\n    function readFromStorage(bytes32 slot_) external view returns (uint result_);\n}\n\nabstract contract DexOracleAdjustResult {\n    uint256 internal immutable RESULT_MULTIPLIER;\n    uint256 internal immutable RESULT_DIVISOR;\n\n    constructor(uint256 resultMultiplier_, uint256 resultDivisor_) {\n        RESULT_MULTIPLIER = resultMultiplier_ == 0 ? 1 : resultMultiplier_;\n        RESULT_DIVISOR = resultDivisor_ == 0 ? 1 : resultDivisor_;\n    }\n}\n\nabstract contract DexOracleBase is DexOracleAdjustResult, OracleError {\n    IFluidDexT1 internal immutable DEX_;\n\n    IFluidStorageReadable internal constant LIQUIDITY =\n        IFluidStorageReadable(0x52Aa899454998Be5b000Ad077a46Bbe360F4e497);\n\n    /// @dev if true, convert all reserves token1 into token0. otherwise all token0 into token1.\n    bool internal immutable QUOTE_IN_TOKEN0;\n\n    /// @dev internal immutables read from DEX at time of deployment\n    bytes32 internal immutable SUPPLY_TOKEN_0_SLOT;\n    bytes32 internal immutable SUPPLY_TOKEN_1_SLOT;\n    bytes32 internal immutable BORROW_TOKEN_0_SLOT;\n    bytes32 internal immutable BORROW_TOKEN_1_SLOT;\n    bytes32 internal immutable EXCHANGE_PRICE_TOKEN_0_SLOT;\n    bytes32 internal immutable EXCHANGE_PRICE_TOKEN_1_SLOT;\n\n    uint256 internal immutable TOKEN_0_NUMERATOR_PRECISION;\n    uint256 internal immutable TOKEN_0_DENOMINATOR_PRECISION;\n    uint256 internal immutable TOKEN_1_NUMERATOR_PRECISION;\n    uint256 internal immutable TOKEN_1_DENOMINATOR_PRECISION;\n\n    constructor(address dexPool_, bool quoteInToken0_) {\n        if (dexPool_ == address(0)) {\n            revert FluidOracleError(ErrorTypes.DexOracle__InvalidParams);\n        }\n\n        DEX_ = IFluidDexT1(dexPool_);\n        QUOTE_IN_TOKEN0 = quoteInToken0_;\n\n        IFluidDexT1.ConstantViews memory constantViews_ = DEX_.constantsView();\n        EXCHANGE_PRICE_TOKEN_0_SLOT = constantViews_.exchangePriceToken0Slot;\n        EXCHANGE_PRICE_TOKEN_1_SLOT = constantViews_.exchangePriceToken1Slot;\n        SUPPLY_TOKEN_0_SLOT = constantViews_.supplyToken0Slot;\n        SUPPLY_TOKEN_1_SLOT = constantViews_.supplyToken1Slot;\n        BORROW_TOKEN_0_SLOT = constantViews_.borrowToken0Slot;\n        BORROW_TOKEN_1_SLOT = constantViews_.borrowToken1Slot;\n\n        IFluidDexT1.ConstantViews2 memory constantViews2_ = DEX_.constantsView2();\n        TOKEN_0_NUMERATOR_PRECISION = constantViews2_.token0NumeratorPrecision;\n        TOKEN_0_DENOMINATOR_PRECISION = constantViews2_.token0DenominatorPrecision;\n        TOKEN_1_NUMERATOR_PRECISION = constantViews2_.token1NumeratorPrecision;\n        TOKEN_1_DENOMINATOR_PRECISION = constantViews2_.token1DenominatorPrecision;\n    }\n\n    /// @dev returns combined Dex debt reserves in quote token, scaled to quote token decimals\n    function _getDexReservesCombinedInQuoteToken(\n        uint256 conversionPrice_,\n        uint256 token0Reserves_,\n        uint256 token1Reserves_\n    ) internal view virtual returns (uint256 reserves_) {\n        if (QUOTE_IN_TOKEN0) {\n            // e.g. for USDC / ETH DEX when:\n            // \"token0RealReserves\": \"6534_060871000000\", // USDC\n            // \"token1RealReserves\": \"1_330669697660\", // ETH\n            // \"lastStoredPrice\": \"0_000293732487359446271393792\",\n            // 6534_060871000000 + (1_330669697660 * (1e54 / 0_000293732487359446271393792)) / 1e27 = 11064_270347051701 USDC\n\n            // Conversion price must be inverted to be token0/token1\n            conversionPrice_ = 1e54 / conversionPrice_;\n\n            reserves_ = token0Reserves_ + (token1Reserves_ * conversionPrice_) / (1e27);\n\n            // bring reserves to token0 decimals\n            reserves_ = ((reserves_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\n        } else {\n            // e.g. for USDC / ETH DEX when:\n            // \"token0RealReserves\": \"6534_060871000000\", // USDC\n            // \"token1RealReserves\": \"1_330669697660\", // ETH\n            // \"lastStoredPrice\": \"0_000293732487359446271393792\",\n            // 1_330669697660 + (6534_060871000000 * 0_000293732487359446271393792) / 1e27 = 3_249935649856 ETH\n\n            reserves_ = token1Reserves_ + (token0Reserves_ * conversionPrice_) / (1e27);\n\n            // bring reserves to token1 decimals\n            reserves_ = ((reserves_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n        }\n    }\n\n    /// @notice Returns the base configuration data of the FluidDexOracle.\n    ///\n    /// @return dexPool_ The address of the Dex pool.\n    /// @return quoteInToken0_ A boolean indicating if the quote is in token0.\n    /// @return liquidity_ The address of liquidity layer.\n    /// @return resultMultiplier_ The result multiplier.\n    /// @return resultDivisor_ The result divisor.\n    function dexOracleData()\n        public\n        view\n        returns (\n            address dexPool_,\n            bool quoteInToken0_,\n            address liquidity_,\n            uint256 resultMultiplier_,\n            uint256 resultDivisor_\n        )\n    {\n        return (address(DEX_), QUOTE_IN_TOKEN0, address(LIQUIDITY), RESULT_MULTIPLIER, RESULT_DIVISOR);\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/dexPricesAndExchangePrices.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { LiquidityCalcs } from \"../../../libraries/liquidityCalcs.sol\";\nimport { LiquiditySlotsLink } from \"../../../libraries/liquiditySlotsLink.sol\";\nimport { DexSlotsLink } from \"../../../libraries/dexSlotsLink.sol\";\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { DexOracleBase } from \"./dexOracleBase.sol\";\n\ninterface ICenterPrice {\n    function centerPrice() external view returns (uint256);\n}\n\nabstract contract DexPricesAndExchangePrices is DexOracleBase {\n    uint256 private constant X8 = 0xff;\n    uint256 private constant X10 = 0x3ff;\n    uint256 private constant X20 = 0xfffff;\n    uint256 private constant X24 = 0xffffff;\n    uint256 private constant X28 = 0xfffffff;\n    uint256 private constant X30 = 0x3fffffff;\n    uint256 private constant X33 = 0x1ffffffff;\n    uint256 private constant X40 = 0xffffffffff;\n    uint256 private constant X64 = 0xffffffffffffffff;\n    uint256 private constant X128 = 0xffffffffffffffffffffffffffffffff;\n\n    uint256 private constant THREE_DECIMALS = 1e3;\n    uint256 private constant SIX_DECIMALS = 1e6;\n\n    uint256 private constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 private constant DEFAULT_EXPONENT_MASK = 0xff;\n\n    /// @dev This function calculates the new value of a parameter after a shifting process.\n    /// @param current_ The current value is the final value where the shift ends\n    /// @param old_ The old value from where shifting started.\n    /// @param timePassed_ The time passed since shifting started.\n    /// @param shiftDuration_ The total duration of the shift when old_ reaches current_\n    /// @return The new value of the parameter after the shift.\n    function _calcShiftingDone(\n        uint current_,\n        uint old_,\n        uint timePassed_,\n        uint shiftDuration_\n    ) internal pure returns (uint) {\n        if (current_ > old_) {\n            uint diff_ = current_ - old_;\n            current_ = old_ + ((diff_ * timePassed_) / shiftDuration_);\n        } else {\n            uint diff_ = old_ - current_;\n            current_ = old_ - ((diff_ * timePassed_) / shiftDuration_);\n        }\n        return current_;\n    }\n\n    /// @dev Calculates the new upper and lower range values during an active range shift\n    /// @param upperRange_ The target upper range value\n    /// @param lowerRange_ The target lower range value\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\n    /// @return The updated upper range, lower range, and dexVariables2\n    /// @notice This function handles the gradual shifting of range values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcRangeShifting(\n        uint upperRange_,\n        uint lowerRange_,\n        uint dexVariables2_\n    ) internal view returns (uint, uint, uint) {\n        uint rangeShift_ = DEX_.readFromStorage(bytes32(DexSlotsLink.DEX_RANGE_THRESHOLD_SHIFTS_SLOT)) & X128;\n        uint oldUpperRange_ = rangeShift_ & X20;\n        uint oldLowerRange_ = (rangeShift_ >> 20) & X20;\n        uint shiftDuration_ = (rangeShift_ >> 40) & X20;\n        uint startTimeStamp_ = ((rangeShift_ >> 60) & X33);\n        if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n            // shifting fully done\n            // note: not deleting from storage as this is oracle address\n            // delete _rangeShift;\n\n            // making active shift as 0 because shift is over\n            // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates from this function and _calcThresholdShifting.\n            // Note: not fetching & updating on storage because this is oracle address\n            dexVariables2_ = dexVariables2_ & ~uint(1 << 26);\n            // dexVariables2 = dexVariables2_;\n            return (upperRange_, lowerRange_, dexVariables2_);\n        }\n        uint timePassed_ = block.timestamp - startTimeStamp_;\n        return (\n            _calcShiftingDone(upperRange_, oldUpperRange_, timePassed_, shiftDuration_),\n            _calcShiftingDone(lowerRange_, oldLowerRange_, timePassed_, shiftDuration_),\n            dexVariables2_\n        );\n    }\n\n    /// @dev Calculates the new upper and lower threshold values during an active threshold shift\n    /// @param upperThreshold_ The target upper threshold value\n    /// @param lowerThreshold_ The target lower threshold value\n    /// @param thresholdTime_ The time passed since shifting started\n    /// @return The updated upper threshold, lower threshold, and threshold time\n    /// @notice This function handles the gradual shifting of threshold values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcThresholdShifting(\n        uint upperThreshold_,\n        uint lowerThreshold_,\n        uint thresholdTime_\n    ) internal view returns (uint, uint, uint) {\n        uint thresholdShift_ = (DEX_.readFromStorage(bytes32(DexSlotsLink.DEX_RANGE_THRESHOLD_SHIFTS_SLOT)) >> 128) &\n            X128;\n        uint oldUpperThreshold_ = thresholdShift_ & X20;\n        uint oldLowerThreshold_ = (thresholdShift_ >> 20) & X20;\n        uint shiftDuration_ = (thresholdShift_ >> 40) & X20;\n        uint startTimeStamp_ = ((thresholdShift_ >> 60) & X33);\n        uint oldThresholdTime_ = (thresholdShift_ >> 93) & X24;\n        if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n            // shifting fully done\n            // note: not deleting from storage as this is oracle address\n            // delete _thresholdShift;\n\n            // making active shift as 0 because shift is over\n            // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates from this function and _calcRangeShifting.\n            // note: not updating on storage because this is oracle address\n            // dexVariables2 = dexVariables2 & ~uint(1 << 67);\n            return (upperThreshold_, lowerThreshold_, thresholdTime_);\n        }\n        uint timePassed_ = block.timestamp - startTimeStamp_;\n        return (\n            _calcShiftingDone(upperThreshold_, oldUpperThreshold_, timePassed_, shiftDuration_),\n            _calcShiftingDone(lowerThreshold_, oldLowerThreshold_, timePassed_, shiftDuration_),\n            _calcShiftingDone(thresholdTime_, oldThresholdTime_, timePassed_, shiftDuration_)\n        );\n    }\n\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    /// @notice Calculates and returns the current prices and exchange prices for the pool\n    /// @return pex_ A struct containing the calculated prices and exchange prices:\n    ///         - pex_.lastStoredPrice: The last stored price in 1e27 decimals\n    ///         - pex_.centerPrice: The calculated or fetched center price in 1e27 decimals\n    ///         - pex_.upperRange: The upper range price limit in 1e27 decimals\n    ///         - pex_.lowerRange: The lower range price limit in 1e27 decimals\n    ///         - pex_.geometricMean: The geometric mean of upper range & lower range in 1e27 decimals\n    ///         - pex_.supplyToken0ExchangePrice: The current exchange price for supplying token0\n    ///         - pex_.borrowToken0ExchangePrice: The current exchange price for borrowing token0\n    ///         - pex_.supplyToken1ExchangePrice: The current exchange price for supplying token1\n    ///         - pex_.borrowToken1ExchangePrice: The current exchange price for borrowing token1\n    /// @dev This function performs the following operations:\n    ///      1. Determines the center price (either from storage, external source, or calculated)\n    ///      2. Retrieves the last stored price from dexVariables_\n    ///      3. Calculates the upper and lower range prices based on the center price and range percentages\n    ///      4. Checks if rebalancing is needed based on threshold settings\n    ///      5. Adjusts prices if necessary based on the time elapsed and threshold conditions\n    ///      6. Update the dexVariables2_ if changes were made\n    ///      7. Returns the calculated prices and exchange prices in the PricesAndExchangePrice struct\n    function _getPricesAndExchangePrices() internal view returns (PricesAndExchangePrice memory pex_) {\n        uint dexVariables_ = DEX_.readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES_SLOT));\n        uint dexVariables2_ = DEX_.readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        uint centerPrice_;\n\n        if (((dexVariables2_ >> 248) & 1) == 0) {\n            // centerPrice_ => center price hook\n            centerPrice_ = (dexVariables2_ >> 112) & X30;\n            if (centerPrice_ == 0) {\n                centerPrice_ = (dexVariables_ >> 81) & X40;\n                centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n            } else {\n                // center price should be fetched from external source. For exmaple, in case of wstETH <> ETH pool,\n                // we would want the center price to be pegged to wstETH exchange rate into ETH\n\n                // Note: commenting ICenterPrice call as oracle should be used for non peg pools so center price should not be pegged to external source\n                // centerPrice_ = ICenterPrice(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, centerPrice_)).centerPrice();\n                revert(\"PricesAndExchangePrices: center price should not be pegged to external source\");\n            }\n        } else {\n            // an active centerPrice_ shift is going on\n\n            // @Samyak please verify below. I removed the _calcCenterPrice() method completely. The reverts here are very risky if we ever add\n            // a center price for any reason to an existing non-peg pool as oracle would start reverting. That should never happen but\n            // very critical to remember this.\n\n            // Note: commenting _calcCenterPrice call as oracle should be used for non peg pools so center price should not be shifting,\n            // as the shift uses an external source.\n            // centerPrice_ = _calcCenterPrice(dexVariables_, dexVariables2_);\n            revert(\"PricesAndExchangePrices: center price should not be pegged to external source\");\n        }\n\n        uint lastStoredPrice_ = (dexVariables_ >> 41) & X40;\n        lastStoredPrice_ = (lastStoredPrice_ >> DEFAULT_EXPONENT_SIZE) << (lastStoredPrice_ & DEFAULT_EXPONENT_MASK);\n\n        uint upperRange_ = ((dexVariables2_ >> 27) & X20);\n        uint lowerRange_ = ((dexVariables2_ >> 47) & X20);\n        if (((dexVariables2_ >> 26) & 1) == 1) {\n            // an active range shift is going on\n            (upperRange_, lowerRange_, dexVariables2_) = _calcRangeShifting(upperRange_, lowerRange_, dexVariables2_);\n        }\n\n        unchecked {\n            // adding into unchecked because upperRange_ & lowerRange_ can only be > 0 & < SIX_DECIMALS\n            // 1% = 1e4, 100% = 1e6\n            upperRange_ = (centerPrice_ * SIX_DECIMALS) / (SIX_DECIMALS - upperRange_);\n            // 1% = 1e4, 100% = 1e6\n            lowerRange_ = (centerPrice_ * (SIX_DECIMALS - lowerRange_)) / SIX_DECIMALS;\n        }\n\n        bool changed_;\n        {\n            // goal will be to keep threshold percents 0 if center price is fetched from external source\n            // checking if threshold are set non 0 then only rebalancing is on\n            if (((dexVariables2_ >> 68) & X20) > 0) {\n                uint upperThreshold_ = (dexVariables2_ >> 68) & X10;\n                uint lowerThreshold_ = (dexVariables2_ >> 78) & X10;\n                uint shiftingTime_ = (dexVariables2_ >> 88) & X24;\n                if (((dexVariables2_ >> 67) & 1) == 1) {\n                    // if active shift is going on for threshold then calculate threshold real time\n                    (upperThreshold_, lowerThreshold_, shiftingTime_) = _calcThresholdShifting(\n                        upperThreshold_,\n                        lowerThreshold_,\n                        shiftingTime_\n                    );\n                }\n\n                unchecked {\n                    if (\n                        lastStoredPrice_ >\n                        (centerPrice_ +\n                            ((upperRange_ - centerPrice_) * (THREE_DECIMALS - upperThreshold_)) /\n                            THREE_DECIMALS)\n                    ) {\n                        uint timeElapsed_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n                        // price shifting towards upper range\n                        if (timeElapsed_ < shiftingTime_) {\n                            centerPrice_ = centerPrice_ + ((upperRange_ - centerPrice_) * timeElapsed_) / shiftingTime_;\n                        } else {\n                            // 100% price shifted\n                            centerPrice_ = upperRange_;\n                        }\n                        changed_ = true;\n                    } else if (\n                        lastStoredPrice_ <\n                        (centerPrice_ -\n                            ((centerPrice_ - lowerRange_) * (THREE_DECIMALS - lowerThreshold_)) /\n                            THREE_DECIMALS)\n                    ) {\n                        uint timeElapsed_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n                        // price shifting towards lower range\n                        if (timeElapsed_ < shiftingTime_) {\n                            centerPrice_ = centerPrice_ - ((centerPrice_ - lowerRange_) * timeElapsed_) / shiftingTime_;\n                        } else {\n                            // 100% price shifted\n                            centerPrice_ = lowerRange_;\n                        }\n                        changed_ = true;\n                    }\n                }\n            }\n        }\n\n        // temp_ => max center price\n        uint temp_ = (dexVariables2_ >> 172) & X28;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n        if (centerPrice_ > temp_) {\n            // if center price is greater than max center price\n            centerPrice_ = temp_;\n            changed_ = true;\n        } else {\n            // check if center price is less than min center price\n            // temp_ => min center price\n            temp_ = (dexVariables2_ >> 200) & X28;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n            if (centerPrice_ < temp_) {\n                centerPrice_ = temp_;\n                changed_ = true;\n            }\n        }\n\n        // if centerPrice_ is changed then calculating upper and lower range again\n        if (changed_) {\n            upperRange_ = ((dexVariables2_ >> 27) & X20);\n            lowerRange_ = ((dexVariables2_ >> 47) & X20);\n            if (((dexVariables2_ >> 26) & 1) == 1) {\n                (upperRange_, lowerRange_, dexVariables2_) = _calcRangeShifting(\n                    upperRange_,\n                    lowerRange_,\n                    dexVariables2_\n                );\n            }\n\n            unchecked {\n                // adding into unchecked because upperRange_ & lowerRange_ can only be > 0 & < SIX_DECIMALS\n                // 1% = 1e4, 100% = 1e6\n                upperRange_ = (centerPrice_ * SIX_DECIMALS) / (SIX_DECIMALS - upperRange_);\n                // 1% = 1e4, 100% = 1e6\n                lowerRange_ = (centerPrice_ * (SIX_DECIMALS - lowerRange_)) / SIX_DECIMALS;\n            }\n        }\n\n        pex_.lastStoredPrice = lastStoredPrice_;\n        pex_.centerPrice = centerPrice_;\n        pex_.upperRange = upperRange_;\n        pex_.lowerRange = lowerRange_;\n\n        unchecked {\n            if (upperRange_ < 1e38) {\n                // 1e38 * 1e38 = 1e76 which is less than max uint limit\n                pex_.geometricMean = FixedPointMathLib.sqrt(upperRange_ * lowerRange_);\n            } else {\n                // upperRange_ price is pretty large hence lowerRange_ will also be pretty large\n                pex_.geometricMean = FixedPointMathLib.sqrt((upperRange_ / 1e18) * (lowerRange_ / 1e18)) * 1e18;\n            }\n        }\n\n        // Exchange price will remain same as Liquidity Layer\n        (pex_.supplyToken0ExchangePrice, pex_.borrowToken0ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_0_SLOT)\n        );\n\n        (pex_.supplyToken1ExchangePrice, pex_.borrowToken1ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_1_SLOT)\n        );\n    }\n\n    /// @dev getting reserves outside range.\n    /// @param gp_ is geometric mean pricing of upper percent & lower percent\n    /// @param pa_ price of upper range or lower range\n    /// @param rx_ real reserves of token0 or token1\n    /// @param ry_ whatever is rx_ the other will be ry_\n    function _calculateReservesOutsideRange(\n        uint gp_,\n        uint pa_,\n        uint rx_,\n        uint ry_\n    ) internal pure returns (uint xa_, uint yb_) {\n        // equations we have:\n        // 1. x*y = k\n        // 2. xa*ya = k\n        // 3. xb*yb = k\n        // 4. Pa = ya / xa = upperRange_ (known)\n        // 5. Pb = yb / xb = lowerRange_ (known)\n        // 6. x - xa = rx = real reserve of x (known)\n        // 7. y - yb = ry = real reserve of y (known)\n        // With solving we get:\n        // ((Pa*Pb)^(1/2) - Pa)*xa^2 + (rx * (Pa*Pb)^(1/2) + ry)*xa + rx*ry = 0\n        // yb = yb = xa * (Pa * Pb)^(1/2)\n\n        // xa = (GP⋅rx + ry + (-rx⋅ry⋅4⋅(GP - Pa) + (GP⋅rx + ry)^2)^0.5) / (2Pa - 2GP)\n        // multiply entire equation by 1e27 to remove the price decimals precision of 1e27\n        // xa = (GP⋅rx + ry⋅1e27 + (rx⋅ry⋅4⋅(Pa - GP)⋅1e27 + (GP⋅rx + ry⋅1e27)^2)^0.5) / 2*(Pa - GP)\n        // dividing the equation with 2*(Pa - GP). Pa is always > GP so answer will be positive.\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅4⋅(Pa - GP)⋅1e27) / 4*(Pa - GP)^2) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅1e27) / (Pa - GP)) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n\n        // dividing in 3 parts for simplification:\n        // part1 = (Pa - GP)\n        // part2 = (GP⋅rx + ry⋅1e27) / (2*part1)\n        // part3 = rx⋅ry\n        // note: part1 will almost always be < 1e28 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e29\n        uint p1_ = pa_ - gp_;\n        uint p2_ = ((gp_ * rx_) + (ry_ * 1e27)) / (2 * p1_);\n        uint p3_ = rx_ * ry_;\n        // to avoid overflowing\n        p3_ = (p3_ < 1e50) ? ((p3_ * 1e27) / p1_) : (p3_ / p1_) * 1e27;\n\n        // xa = part2 + (part3 + (part2 * part2))^(1/2)\n        // yb = xa_ * gp_\n        xa_ = p2_ + FixedPointMathLib.sqrt((p3_ + (p2_ * p2_)));\n        yb_ = (xa_ * gp_) / 1e27;\n    }\n\n    /// @dev Retrieves collateral amount from liquidity layer for a given token\n    /// @param supplyTokenSlot_ The storage slot for the supply token data\n    /// @param tokenExchangePrice_ The exchange price of the token\n    /// @param isToken0_ Boolean indicating if the token is token0 (true) or token1 (false)\n    /// @return tokenSupply_ The calculated liquidity collateral amount\n    function _getLiquidityCollateral(\n        bytes32 supplyTokenSlot_,\n        uint tokenExchangePrice_,\n        bool isToken0_\n    ) internal view returns (uint tokenSupply_) {\n        uint tokenSupplyData_ = LIQUIDITY.readFromStorage(supplyTokenSlot_);\n        tokenSupply_ = (tokenSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n        tokenSupply_ = (tokenSupply_ >> DEFAULT_EXPONENT_SIZE) << (tokenSupply_ & DEFAULT_EXPONENT_MASK);\n\n        if (tokenSupplyData_ & 1 == 1) {\n            // supply with interest is on\n            unchecked {\n                tokenSupply_ = (tokenSupply_ * tokenExchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n            }\n        }\n\n        unchecked {\n            tokenSupply_ = isToken0_\n                ? ((tokenSupply_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\n                : ((tokenSupply_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\n        }\n    }\n\n    /// @notice Calculates the real and imaginary reserves for collateral tokens\n    /// @dev This function retrieves the supply of both tokens from the liquidity layer,\n    ///      adjusts them based on exchange prices, and calculates imaginary reserves\n    ///      based on the geometric mean and price range\n    /// @param geometricMean_ The geometric mean of the token prices\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0SupplyExchangePrice_ The exchange price for token0 from liquidity layer\n    /// @param token1SupplyExchangePrice_ The exchange price for token1 from liquidity layer\n    /// @return c_ A struct containing the calculated real and imaginary reserves for both tokens:\n    ///         - token0RealReserves: The real reserves of token0\n    ///         - token1RealReserves: The real reserves of token1\n    ///         - token0ImaginaryReserves: The imaginary reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary reserves of token1\n    function _getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) internal view returns (CollateralReserves memory c_) {\n        uint token0Supply_ = _getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, token0SupplyExchangePrice_, true);\n        uint token1Supply_ = _getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, token1SupplyExchangePrice_, false);\n\n        if (geometricMean_ < 1e27) {\n            (c_.token0ImaginaryReserves, c_.token1ImaginaryReserves) = _calculateReservesOutsideRange(\n                geometricMean_,\n                upperRange_,\n                token0Supply_,\n                token1Supply_\n            );\n        } else {\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n            // 1 / geometricMean for new geometricMean\n            // 1 / lowerRange will become upper range\n            // 1 / upperRange will become lower range\n            (c_.token1ImaginaryReserves, c_.token0ImaginaryReserves) = _calculateReservesOutsideRange(\n                (1e54 / geometricMean_),\n                (1e54 / lowerRange_),\n                token1Supply_,\n                token0Supply_\n            );\n        }\n\n        c_.token0RealReserves = token0Supply_;\n        c_.token1RealReserves = token1Supply_;\n        unchecked {\n            c_.token0ImaginaryReserves += token0Supply_;\n            c_.token1ImaginaryReserves += token1Supply_;\n        }\n    }\n\n    /// @notice Calculates the real and imaginary debt reserves for both tokens\n    /// @dev This function uses a quadratic equation to determine the debt reserves\n    ///      based on the geometric mean price and the current debt amounts\n    /// @param gp_ The geometric mean price of upper range & lower range\n    /// @param pb_ The price of lower range\n    /// @param dx_ The debt amount of one token\n    /// @param dy_ The debt amount of the other token\n    /// @return rx_ The real debt reserve of the first token\n    /// @return ry_ The real debt reserve of the second token\n    /// @return irx_ The imaginary debt reserve of the first token\n    /// @return iry_ The imaginary debt reserve of the second token\n    function _calculateDebtReserves(\n        uint gp_,\n        uint pb_,\n        uint dx_,\n        uint dy_\n    ) internal pure returns (uint rx_, uint ry_, uint irx_, uint iry_) {\n        // Assigning letter to knowns:\n        // c = debtA\n        // d = debtB\n        // e = upperPrice\n        // f = lowerPrice\n        // g = upperPrice^1/2\n        // h = lowerPrice^1/2\n\n        // c = 1\n        // d = 2000\n        // e = 2222.222222\n        // f = 1800\n        // g = 2222.222222^1/2\n        // h = 1800^1/2\n\n        // Assigning letter to unknowns:\n        // w = realDebtReserveA\n        // x = realDebtReserveB\n        // y = imaginaryDebtReserveA\n        // z = imaginaryDebtReserveB\n        // k = k\n\n        // below quadratic will give answer of realDebtReserveB\n        // A, B, C of quadratic equation:\n        // A = h\n        // B = dh - cfg\n        // C = -cfdh\n\n        // A = lowerPrice^1/2\n        // B = debtB⋅lowerPrice^1/2 - debtA⋅lowerPrice⋅upperPrice^1/2\n        // C = -(debtA⋅lowerPrice⋅debtB⋅lowerPrice^1/2)\n\n        // x = (cfg − dh + (4cdf(h^2)+(cfg−dh)^2))^(1/2)) / 2h\n        // simplifying dividing by h, note h = f^1/2\n        // x = ((c⋅g⋅(f^1/2) − d) / 2 + ((4⋅c⋅d⋅f⋅f) / (4h^2) + ((c⋅f⋅g) / 2h − (d⋅h) / 2h)^2))^(1/2))\n        // x = ((c⋅g⋅(f^1/2) − d) / 2 + ((c⋅d⋅f) + ((c⋅g⋅(f^1/2) − d) / 2)^2))^(1/2))\n\n        // dividing in 3 parts for simplification:\n        // part1 = (c⋅g⋅(f^1/2) − d) / 2\n        // part2 = (c⋅d⋅f)\n        // x = (part1 + (part2 + part1^2)^(1/2))\n        // note: part1 will almost always be < 1e27 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e28\n\n        // part1 = ((debtA * upperPrice^1/2 * lowerPrice^1/2) - debtB) / 2\n        // note: upperPrice^1/2 * lowerPrice^1/2 = geometric mean\n        // part1 = ((debtA * geometricMean) - debtB) / 2\n        // part2 = debtA * debtB * lowerPrice\n\n        // converting decimals properly as price is in 1e27 decimals\n        // part1 = ((debtA * geometricMean) - (debtB * 1e27)) / (2 * 1e27)\n        // part2 = (debtA * debtB * lowerPrice) / 1e27\n        // final x equals:\n        // x = (part1 + (part2 + part1^2)^(1/2))\n        int p1_ = (int(dx_ * gp_) - int(dy_ * 1e27)) / (2 * 1e27);\n        uint p2_ = (dx_ * dy_);\n        p2_ = p2_ < 1e50 ? (p2_ * pb_) / 1e27 : (p2_ / 1e27) * pb_;\n        ry_ = uint(p1_ + int(FixedPointMathLib.sqrt((p2_ + uint(p1_ * p1_)))));\n\n        // finding z:\n        // x^2 - zx + cfz = 0\n        // z*(x - cf) = x^2\n        // z = x^2 / (x - cf)\n        // z = x^2 / (x - debtA * lowerPrice)\n        // converting decimals properly as price is in 1e27 decimals\n        // z = (x^2 * 1e27) / ((x * 1e27) - (debtA * lowerPrice))\n\n        iry_ = ((ry_ * 1e27) - (dx_ * pb_));\n        if (iry_ < SIX_DECIMALS) {\n            // almost impossible situation to ever get here\n            revert(\"Debt reserves too low\");\n        }\n        if (ry_ < 1e25) {\n            iry_ = (ry_ * ry_ * 1e27) / iry_;\n        } else {\n            // note: it can never result in negative as final result will always be in positive\n            iry_ = (ry_ * ry_) / (iry_ / 1e27);\n        }\n\n        // finding y\n        // x = z * c / (y + c)\n        // y + c = z * c / x\n        // y = (z * c / x) - c\n        // y = (z * debtA / x) - debtA\n        irx_ = ((iry_ * dx_) / ry_) - dx_;\n\n        // finding w\n        // w = y * d / (z + d)\n        // w = (y * debtB) / (z + debtB)\n        rx_ = (irx_ * dy_) / (iry_ + dy_);\n    }\n\n    /// @notice Calculates the debt amount for a given token from liquidity layer\n    /// @param borrowTokenSlot_ The storage slot for the token's borrow data\n    /// @param tokenExchangePrice_ The current exchange price of the token\n    /// @param isToken0_ Boolean indicating if this is for token0 (true) or token1 (false)\n    /// @return tokenDebt_ The calculated debt amount for the token\n    function _getLiquidityDebt(\n        bytes32 borrowTokenSlot_,\n        uint tokenExchangePrice_,\n        bool isToken0_\n    ) internal view returns (uint tokenDebt_) {\n        uint tokenBorrowData_ = LIQUIDITY.readFromStorage(borrowTokenSlot_);\n\n        tokenDebt_ = (tokenBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n        tokenDebt_ = (tokenDebt_ >> 8) << (tokenDebt_ & X8);\n\n        if (tokenBorrowData_ & 1 == 1) {\n            // borrow with interest is on\n            unchecked {\n                tokenDebt_ = (tokenDebt_ * tokenExchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n            }\n        }\n\n        unchecked {\n            tokenDebt_ = isToken0_\n                ? ((tokenDebt_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\n                : ((tokenDebt_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\n        }\n    }\n\n    /// @notice Calculates the debt reserves for both tokens\n    /// @param geometricMean_ The geometric mean of the upper and lower price ranges\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0BorrowExchangePrice_ The exchange price of token0 from liquidity layer\n    /// @param token1BorrowExchangePrice_ The exchange price of token1 from liquidity layer\n    /// @return d_ The calculated debt reserves for both tokens, containing:\n    ///         - token0Debt: The debt amount of token0\n    ///         - token1Debt: The debt amount of token1\n    ///         - token0RealReserves: The real reserves of token0 derived from token1 debt\n    ///         - token1RealReserves: The real reserves of token1 derived from token0 debt\n    ///         - token0ImaginaryReserves: The imaginary debt reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary debt reserves of token1\n    function _getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) internal view returns (DebtReserves memory d_) {\n        uint token0Debt_ = _getLiquidityDebt(BORROW_TOKEN_0_SLOT, token0BorrowExchangePrice_, true);\n        uint token1Debt_ = _getLiquidityDebt(BORROW_TOKEN_1_SLOT, token1BorrowExchangePrice_, false);\n\n        d_.token0Debt = token0Debt_;\n        d_.token1Debt = token1Debt_;\n\n        if (geometricMean_ < 1e27) {\n            (\n                d_.token0RealReserves,\n                d_.token1RealReserves,\n                d_.token0ImaginaryReserves,\n                d_.token1ImaginaryReserves\n            ) = _calculateDebtReserves(geometricMean_, lowerRange_, token0Debt_, token1Debt_);\n        } else {\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n            // 1 / geometricMean for new geometricMean\n            // 1 / lowerRange will become upper range\n            // 1 / upperRange will become lower range\n            (\n                d_.token1RealReserves,\n                d_.token0RealReserves,\n                d_.token1ImaginaryReserves,\n                d_.token0ImaginaryReserves\n            ) = _calculateDebtReserves((1e54 / geometricMean_), (1e54 / upperRange_), token1Debt_, token0Debt_);\n        }\n    }\n\n    function _calculateNewColReserves(\n        PricesAndExchangePrice memory pex_,\n        CollateralReserves memory currentCollateralReserves_,\n        uint newPrice_\n    ) internal pure returns (CollateralReserves memory newCollateralReserves_) {\n        uint k_ = currentCollateralReserves_.token0ImaginaryReserves *\n            currentCollateralReserves_.token1ImaginaryReserves;\n\n        uint token0OutsideRange_ = currentCollateralReserves_.token0ImaginaryReserves -\n            currentCollateralReserves_.token0RealReserves;\n        uint token1OutsideRange_ = currentCollateralReserves_.token1ImaginaryReserves -\n            currentCollateralReserves_.token1RealReserves;\n\n        uint x_;\n        uint y_;\n\n        if (pex_.upperRange < newPrice_) {\n            x_ = token0OutsideRange_;\n            y_ = k_ / x_;\n        } else if (pex_.lowerRange > newPrice_) {\n            y_ = token1OutsideRange_;\n            x_ = k_ / y_;\n        } else {\n            // y_/x_ = newPrice_\n            // y_ = newPrice_* x_\n            // y_ * x_ = k_\n            // (newPrice_* x_) * x_ = k_\n            // x_^2 = k_ / newPrice_\n            // x_ = sqrt(k_ / newPrice_)\n            if (k_ < 1e50) {\n                x_ = FixedPointMathLib.sqrt((k_ * 1e27) / newPrice_);\n            } else {\n                x_ = FixedPointMathLib.sqrt((k_ / newPrice_) * 1e27);\n            }\n            y_ = (newPrice_ * x_) / 1e27;\n        }\n\n        newCollateralReserves_.token0RealReserves = x_ - token0OutsideRange_;\n        newCollateralReserves_.token1RealReserves = y_ - token1OutsideRange_;\n        newCollateralReserves_.token0ImaginaryReserves = x_;\n        newCollateralReserves_.token1ImaginaryReserves = y_;\n    }\n\n    function _calculateNewDebtReserves(\n        PricesAndExchangePrice memory pex_,\n        DebtReserves memory currentDebtReserves_,\n        uint newPrice_\n    ) internal pure returns (DebtReserves memory newDebtReserves_) {\n        uint k_ = currentDebtReserves_.token0ImaginaryReserves * currentDebtReserves_.token1ImaginaryReserves;\n        uint token0OutsideRange_ = currentDebtReserves_.token0ImaginaryReserves -\n            currentDebtReserves_.token0RealReserves;\n        uint token1OutsideRange_ = currentDebtReserves_.token1ImaginaryReserves -\n            currentDebtReserves_.token1RealReserves;\n\n        uint x_;\n        uint y_;\n        if (pex_.upperRange < newPrice_) {\n            x_ = token0OutsideRange_;\n            y_ = k_ / x_;\n        } else if (pex_.lowerRange > newPrice_) {\n            y_ = token1OutsideRange_;\n            x_ = k_ / y_;\n        } else {\n            // y_/x_ = newPrice_\n            // y_ = newPrice_* x_\n            // y_ * x_ = k_\n            // (newPrice_* x_) * x_ = k_\n            // x_^2 = k_ / newPrice_\n            // x_ = sqrt(k_ / newPrice_)\n            if (k_ < 1e50) {\n                x_ = FixedPointMathLib.sqrt((k_ * 1e27) / newPrice_);\n            } else {\n                x_ = FixedPointMathLib.sqrt((k_ / newPrice_) * 1e27);\n            }\n            y_ = (newPrice_ * x_) / 1e27;\n        }\n\n        newDebtReserves_.token0RealReserves = x_ - token0OutsideRange_;\n        newDebtReserves_.token1RealReserves = y_ - token1OutsideRange_;\n        newDebtReserves_.token0ImaginaryReserves = x_;\n        newDebtReserves_.token1ImaginaryReserves = y_;\n\n        // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\n        uint256 numerator_ = newDebtReserves_.token0RealReserves * currentDebtReserves_.token1ImaginaryReserves;\n        uint256 denominator_ = currentDebtReserves_.token0ImaginaryReserves - newDebtReserves_.token0RealReserves;\n\n        // Using the swap formula: (AmountOut * iReserveX) / (iReserveY - AmountOut)\n        newDebtReserves_.token1Debt = numerator_ / denominator_;\n\n        numerator_ = newDebtReserves_.token1RealReserves * currentDebtReserves_.token0ImaginaryReserves;\n        denominator_ = currentDebtReserves_.token1ImaginaryReserves - newDebtReserves_.token1RealReserves;\n\n        // Using the swap formula: (AmountOut * iReserveX) / (iReserveY - AmountOut)\n        newDebtReserves_.token0Debt = numerator_ / denominator_;\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/dexSmartColOracleImpl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { DexSlotsLink } from \"../../../libraries/dexSlotsLink.sol\";\nimport { DexOracleBase } from \"./dexOracleBase.sol\";\n\nabstract contract DexSmartColOracleImpl is DexOracleBase {\n    uint256 private constant X128 = 0xffffffffffffffffffffffffffffffff;\n\n    uint256 private immutable RESERVES_SCALER;\n\n    constructor() {\n        // need to invert decimals from reserves / shares to shares / reserves.\n        // Can derive from token scaler consts targeting 1e12 + knowing shares decimals = 1e18:\n        // e.g. for USDC 1e6 / 1e18 shares: 1e18 / (1e12 * 1 / 1e6) = 1e12\n        // e.g. for WBTC 1e8 / 1e18 shares: 1e18 / (1e12 * 1 / 1e4) = 1e10\n        RESERVES_SCALER = QUOTE_IN_TOKEN0\n            ? 1e18 / ((1e12 * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION)\n            : 1e18 / ((1e12 * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n    }\n\n    /// @dev returns price per 1 col share (quoteToken / colShare) in token decimals scaled to 1e27\n    function _getDexSmartColExchangeRate(\n        uint256 conversionPrice_,\n        uint256 token0Reserves_,\n        uint256 token1Reserves_\n    ) internal view returns (uint256 rate_) {\n        uint256 totalSupplyShares_ = IFluidDexT1(DEX_).readFromStorage(\n            bytes32(DexSlotsLink.DEX_TOTAL_SUPPLY_SHARES_SLOT)\n        ) & X128;\n\n        if (totalSupplyShares_ == 0) {\n            // should never happen after Dex is initialized. until then -> revert\n            revert FluidOracleError(ErrorTypes.DexSmartColOracle__SmartColNotEnabled);\n        }\n\n        uint256 reserves_ = _getDexReservesCombinedInQuoteToken(conversionPrice_, token0Reserves_, token1Reserves_);\n\n        // here: all reserves_ are in either token0 or token1 in token decimals, and we have total shares.\n        // so we know token0 or token1 per 1e18 share. => return price per 1 share (1e18), scaled to 1e27.\n        // shares are in 1e18\n        return (reserves_ * RESERVES_SCALER * 1e27) / totalSupplyShares_;\n    }\n\n    /// @notice Returns the rates of shares (totalReserves/totalShares)\n    function dexSmartColSharesRates() public view virtual returns (uint256 operate_, uint256 liquidate_);\n}\n"
    },
    "contracts/oracle/implementations/dex/dexSmartDebtOracleImpl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { DexSlotsLink } from \"../../../libraries/dexSlotsLink.sol\";\nimport { DexOracleBase } from \"./dexOracleBase.sol\";\n\nabstract contract DexSmartDebtOracleImpl is DexOracleBase {\n    uint256 private constant X128 = 0xffffffffffffffffffffffffffffffff;\n\n    uint256 private immutable RESERVES_SCALER;\n\n    constructor() {\n        // need to invert decimals from reserves / shares to shares / reserves.\n        // Can derive from token scaler consts targeting 1e12 + knowing shares decimals = 1e18:\n        // e.g. for USDC 1e6 / 1e18 shares: 1e18 / (1e12 * 1 / 1e6) = 1e12\n        // e.g. for WBTC 1e8 / 1e18 shares: 1e18 / (1e12 * 1 / 1e4) = 1e10\n        RESERVES_SCALER = QUOTE_IN_TOKEN0\n            ? 1e18 / ((1e12 * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION)\n            : 1e18 / ((1e12 * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n    }\n\n    /// @dev returns price per 1 quoteToken (debtShares / quoteToken) in token decimals scaled to 1e27\n    function _getDexSmartDebtExchangeRate(\n        uint256 conversionPrice_,\n        uint256 token0Reserves_,\n        uint256 token1Reserves_\n    ) internal view returns (uint256 rate_) {\n        uint256 totalBorrowShares_ = IFluidDexT1(DEX_).readFromStorage(\n            bytes32(DexSlotsLink.DEX_TOTAL_BORROW_SHARES_SLOT)\n        ) & X128;\n\n        if (totalBorrowShares_ == 0) {\n            // should never happen after Dex is initialized. until then -> revert\n            revert FluidOracleError(ErrorTypes.DexSmartDebtOracle__SmartDebtNotEnabled);\n        }\n\n        uint256 reserves_ = _getDexReservesCombinedInQuoteToken(conversionPrice_, token0Reserves_, token1Reserves_);\n\n        // here: all reserves_ are in either token0 or token1 in token decimals, and we have total shares.\n        // so we know token0 or token1 per 1e18 share. => return shares per 1 quote token, scaled to 1e27.\n\n        return (totalBorrowShares_ * 1e27) / (reserves_ * RESERVES_SCALER);\n    }\n\n    /// @notice Returns the rates of shares (totalShares/totalReserves)\n    function dexSmartDebtSharesRates() public view virtual returns (uint256 operate_, uint256 liquidate_);\n}\n"
    },
    "contracts/oracle/implementations/dex/reserveGetters/reservesFromLiquidity.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\nimport { LiquidityCalcs } from \"../../../../libraries/liquidityCalcs.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { DexOracleBase } from \"../dexOracleBase.sol\";\n\n/// @notice reads the dex reserves directly from Liquidity (user supply / user debt)\nabstract contract DexReservesFromLiquidity is DexOracleBase {\n    constructor(address dexPool_, bool quoteInToken0_) DexOracleBase(dexPool_, quoteInToken0_) {}\n\n    /// @dev Retrieves collateral amount from liquidity layer for a given token\n    /// @param supplyTokenSlot_ The storage slot for the supply token data\n    /// @param exchangePriceSlot_ The storage slot for the exchange price of the token\n    /// @param isToken0_ Boolean indicating if the token is token0 (true) or token1 (false)\n    /// @return tokenSupply_ The calculated liquidity collateral amount\n    function _getLiquidityCollateral(\n        bytes32 supplyTokenSlot_,\n        bytes32 exchangePriceSlot_,\n        bool isToken0_\n    ) private view returns (uint tokenSupply_) {\n        uint tokenSupplyData_ = LIQUIDITY.readFromStorage(supplyTokenSlot_);\n        tokenSupply_ = (tokenSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & LiquidityCalcs.X64;\n        tokenSupply_ =\n            (tokenSupply_ >> LiquidityCalcs.DEFAULT_EXPONENT_SIZE) <<\n            (tokenSupply_ & LiquidityCalcs.DEFAULT_EXPONENT_MASK);\n\n        (uint256 exchangePrice_, ) = LiquidityCalcs.calcExchangePrices(LIQUIDITY.readFromStorage(exchangePriceSlot_));\n\n        if (tokenSupplyData_ & 1 == 1) {\n            // supply with interest is on\n            unchecked {\n                tokenSupply_ = (tokenSupply_ * exchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n            }\n        }\n\n        // bring to 1e12 decimals\n        unchecked {\n            tokenSupply_ = isToken0_\n                ? ((tokenSupply_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\n                : ((tokenSupply_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\n        }\n    }\n\n    /// @dev Retrieves debt amount from liquidity layer for a given token\n    /// @param borrowTokenSlot_ The storage slot for the borrow token data\n    /// @param exchangePriceSlot_ The storage slot for the exchange price of the token\n    /// @param isToken0_ Boolean indicating if the token is token0 (true) or token1 (false)\n    /// @return debtAmount_ The calculated liquidity debt amount adjusted to 1e12 decimals\n    function _getLiquidityDebt(\n        bytes32 borrowTokenSlot_,\n        bytes32 exchangePriceSlot_,\n        bool isToken0_\n    ) private view returns (uint debtAmount_) {\n        uint debtAmountData_ = LIQUIDITY.readFromStorage(borrowTokenSlot_);\n        debtAmount_ = (debtAmountData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & LiquidityCalcs.X64;\n        debtAmount_ =\n            (debtAmount_ >> LiquidityCalcs.DEFAULT_EXPONENT_SIZE) <<\n            (debtAmount_ & LiquidityCalcs.DEFAULT_EXPONENT_MASK);\n\n        (, uint256 exchangePrice_) = LiquidityCalcs.calcExchangePrices(LIQUIDITY.readFromStorage(exchangePriceSlot_));\n\n        if (debtAmountData_ & 1 == 1) {\n            // debt with interest is on\n            unchecked {\n                debtAmount_ = (debtAmount_ * exchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n            }\n        }\n\n        unchecked {\n            debtAmount_ = isToken0_\n                ? ((debtAmount_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\n                : ((debtAmount_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\n        }\n    }\n\n    /// @dev Get the col reserves at the Dex adjusted to 1e12 decimals\n    function _getDexCollateralReserves()\n        internal\n        view\n        virtual\n        returns (uint256 token0Reserves_, uint256 token1Reserves_)\n    {\n        // Note check if smart col is enabled is done already via checking if total supply shares == 0\n        token0Reserves_ = _getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, EXCHANGE_PRICE_TOKEN_0_SLOT, true);\n        token1Reserves_ = _getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, EXCHANGE_PRICE_TOKEN_1_SLOT, false);\n    }\n\n    /// @dev Get the debt reserves at the Dex adjusted to 1e12 decimals\n    function _getDexDebtReserves() internal view virtual returns (uint256 token0Reserves_, uint256 token1Reserves_) {\n        // Note check if smart debt is enabled is done already via checking if total borrow shares == 0\n\n        token0Reserves_ = _getLiquidityDebt(BORROW_TOKEN_0_SLOT, EXCHANGE_PRICE_TOKEN_0_SLOT, true);\n        token1Reserves_ = _getLiquidityDebt(BORROW_TOKEN_1_SLOT, EXCHANGE_PRICE_TOKEN_1_SLOT, false);\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/reserveGetters/reservesFromLiquidityPeg.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { DexReservesFromLiquidity } from \"./reservesFromLiquidity.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @notice reads the dex reserves directly from Liquidity (user supply / user debt) and adds a certain % buffer.\nabstract contract DexReservesFromLiquidityPeg is DexReservesFromLiquidity {\n    /// @dev if Dex is e.g. USDC / USDT a peg can be assumed instead of fetching the price\n    /// at the Dex Oracle (which might not even be active in such a case). If so, this var\n    /// defines the peg buffer to reduce collateral value (and increase debt value) by some\n    /// defined percentage for safety handling of price ranges.\n    /// in 1e4: 10000 = 1%, 1000000 = 100%\n    uint256 public immutable RESERVES_PEG_BUFFER_PERCENT;\n\n    constructor(\n        address dexPool_,\n        bool quoteInToken0_,\n        uint256 reservesPegBufferPercent_\n    ) DexReservesFromLiquidity(dexPool_, quoteInToken0_) {\n        if (reservesPegBufferPercent_ == 0) {\n            revert FluidOracleError(ErrorTypes.DexOracle__InvalidParams);\n        }\n        RESERVES_PEG_BUFFER_PERCENT = reservesPegBufferPercent_;\n    }\n\n    /// @inheritdoc DexReservesFromLiquidity\n    function _getDexCollateralReserves()\n        internal\n        view\n        override\n        returns (uint256 token0Reserves_, uint256 token1Reserves_)\n    {\n        (token0Reserves_, token1Reserves_) = super._getDexCollateralReserves();\n\n        // reduce col value by peg buffer percent\n        token0Reserves_ = (token0Reserves_ * (1e6 - RESERVES_PEG_BUFFER_PERCENT)) / 1e6;\n        token1Reserves_ = (token1Reserves_ * (1e6 - RESERVES_PEG_BUFFER_PERCENT)) / 1e6;\n    }\n\n    /// @inheritdoc DexReservesFromLiquidity\n    function _getDexDebtReserves() internal view override returns (uint256 token0Reserves_, uint256 token1Reserves_) {\n        (token0Reserves_, token1Reserves_) = super._getDexDebtReserves();\n\n        // increase debt value by peg buffer percent\n        token0Reserves_ = (token0Reserves_ * (1e6 + RESERVES_PEG_BUFFER_PERCENT)) / 1e6;\n        token1Reserves_ = (token1Reserves_ * (1e6 + RESERVES_PEG_BUFFER_PERCENT)) / 1e6;\n    }\n}\n"
    },
    "contracts/oracle/implementations/dex/reserveGetters/reservesFromPEX.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { DexPricesAndExchangePrices } from \"../dexPricesAndExchangePrices.sol\";\nimport { DexOracleBase } from \"../dexOracleBase.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @notice reads the dex reserves directly from Liquidity (user supply / user debt) but adjusts them for a certain\n///         price, incl. adjusted PEX.\nabstract contract DexReservesFromPEX is DexOracleBase, DexPricesAndExchangePrices {\n    constructor(address dexPool_, bool quoteInToken0_) DexOracleBase(dexPool_, quoteInToken0_) {}\n\n    /// @dev Get the col reserves at the Dex adjusted to 1e12 decimals.\n    /// Pass in the conversion price and PEX fetched via `_getPricesAndExchangePrices()`.\n    function _getDexCollateralReserves(\n        uint256 price_,\n        PricesAndExchangePrice memory pex_\n    ) internal view returns (uint256 token0Reserves_, uint256 token1Reserves_) {\n        CollateralReserves memory collateralReserves_ = _getCollateralReserves(\n            pex_.geometricMean,\n            pex_.upperRange,\n            pex_.lowerRange,\n            pex_.supplyToken0ExchangePrice,\n            pex_.supplyToken1ExchangePrice\n        );\n\n        CollateralReserves memory newCollateralReserves_ = _calculateNewColReserves(pex_, collateralReserves_, price_);\n\n        token0Reserves_ = newCollateralReserves_.token0RealReserves;\n        token1Reserves_ = newCollateralReserves_.token1RealReserves;\n    }\n\n    /// @dev Get the debt reserves at the Dex adjusted to 1e12 decimals.\n    /// Pass in the conversion price and PEX fetched via `_getPricesAndExchangePrices()`.\n    function _getDexDebtReserves(\n        uint256 price_,\n        PricesAndExchangePrice memory pex_\n    ) internal view returns (uint256 token0Debt_, uint256 token1Debt_) {\n        DebtReserves memory debtReserves_ = _getDebtReserves(\n            pex_.geometricMean,\n            pex_.upperRange,\n            pex_.lowerRange,\n            pex_.borrowToken0ExchangePrice,\n            pex_.borrowToken1ExchangePrice\n        );\n\n        DebtReserves memory newDebtReserves_ = _calculateNewDebtReserves(pex_, debtReserves_, price_);\n\n        token0Debt_ = newDebtReserves_.token0Debt;\n        token1Debt_ = newDebtReserves_.token1Debt;\n    }\n}\n"
    },
    "contracts/oracle/implementations/fallbackOracleImpl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { IRedstoneOracle } from \"../interfaces/external/IRedstoneOracle.sol\";\nimport { Error as OracleError } from \"../error.sol\";\nimport { ChainlinkOracleImpl } from \"./chainlinkOracleImpl.sol\";\nimport { RedstoneOracleImpl } from \"./redstoneOracleImpl.sol\";\n\n/// @title   Fallback Oracle implementation\n/// @notice  This contract is used to get the exchange rate from a main oracle feed and a fallback oracle feed.\n//\n// @dev     inheriting contracts should implement a view method to expose `_FALLBACK_ORACLE_MAIN_SOURCE`\nabstract contract FallbackOracleImpl is OracleError, RedstoneOracleImpl, ChainlinkOracleImpl {\n    /// @dev which oracle to use as main source:\n    /// - 1 = Chainlink ONLY (no fallback)\n    /// - 2 = Chainlink with Redstone Fallback\n    /// - 3 = Redstone with Chainlink Fallback\n    uint8 internal immutable _FALLBACK_ORACLE_MAIN_SOURCE;\n\n    /// @notice                     sets the main source, Chainlink Oracle and Redstone Oracle data.\n    /// @param mainSource_          which oracle to use as main source:\n    ///                                  - 1 = Chainlink ONLY (no fallback)\n    ///                                  - 2 = Chainlink with Redstone Fallback\n    ///                                  - 3 = Redstone with Chainlink Fallback\n    /// @param chainlinkParams_     chainlink Oracle constructor params struct.\n    /// @param redstoneOracle_      Redstone Oracle data. (address can be set to zero address if using Chainlink only)\n    constructor(\n        uint8 mainSource_,\n        ChainlinkConstructorParams memory chainlinkParams_,\n        RedstoneOracleData memory redstoneOracle_\n    )\n        ChainlinkOracleImpl(chainlinkParams_)\n        RedstoneOracleImpl(\n            address(redstoneOracle_.oracle) == address(0)\n                ? RedstoneOracleData(IRedstoneOracle(_REDSTONE_ORACLE_NOT_SET_ADDRESS), false, 1)\n                : redstoneOracle_\n        )\n    {\n        if (mainSource_ < 1 || mainSource_ > 3) {\n            revert FluidOracleError(ErrorTypes.FallbackOracle__InvalidParams);\n        }\n        _FALLBACK_ORACLE_MAIN_SOURCE = mainSource_;\n    }\n\n    /// @dev returns the exchange rate for the main oracle source, or the fallback source (if configured) if the main exchange rate\n    /// fails to be fetched. If returned rate is 0, fetching rate failed or something went wrong.\n    /// @return exchangeRate_ exchange rate\n    /// @return fallback_ whether fallback was necessary or not\n    function _getRateWithFallback() internal view returns (uint256 exchangeRate_, bool fallback_) {\n        if (_FALLBACK_ORACLE_MAIN_SOURCE == 1) {\n            // 1 = Chainlink ONLY (no fallback)\n            exchangeRate_ = _getChainlinkExchangeRate();\n        } else if (_FALLBACK_ORACLE_MAIN_SOURCE == 2) {\n            // 2 = Chainlink with Redstone Fallback\n            exchangeRate_ = _getChainlinkExchangeRate();\n            if (exchangeRate_ == 0) {\n                fallback_ = true;\n                exchangeRate_ = _getRedstoneExchangeRate();\n            }\n        } else {\n            // 3 = Redstone with Chainlink Fallback\n            exchangeRate_ = _getRedstoneExchangeRate();\n            if (exchangeRate_ == 0) {\n                fallback_ = true;\n                exchangeRate_ = _getChainlinkExchangeRate();\n            }\n        }\n    }\n\n    /// @dev returns the exchange rate for Chainlink, or Redstone if configured & Chainlink fails.\n    function _getChainlinkOrRedstoneAsFallback() internal view returns (uint256 exchangeRate_) {\n        exchangeRate_ = _getChainlinkExchangeRate();\n\n        if (exchangeRate_ == 0 && _FALLBACK_ORACLE_MAIN_SOURCE != 1) {\n            // Chainlink failed but Redstone is configured too -> try Redstone\n            exchangeRate_ = _getRedstoneExchangeRate();\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/redstoneOracleImpl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { IRedstoneOracle } from \"../interfaces/external/IRedstoneOracle.sol\";\nimport { Error as OracleError } from \"../error.sol\";\nimport { OracleUtils } from \"../libraries/oracleUtils.sol\";\nimport { RedstoneStructs } from \"./structs.sol\";\n\n/// @title   Redstone Oracle implementation\n/// @notice  This contract is used to get the exchange rate from a Redstone Oracle\nabstract contract RedstoneOracleImpl is OracleError, RedstoneStructs {\n    /// @notice Redstone price oracle to check for the exchange rate\n    IRedstoneOracle internal immutable _REDSTONE_ORACLE;\n    /// @notice Flag to invert the price or not (to e.g. for WETH/USDC pool return prive of USDC per 1 WETH)\n    bool internal immutable _REDSTONE_INVERT_RATE;\n\n    /// @notice constant value for price scaling to reduce gas usage\n    uint256 internal immutable _REDSTONE_PRICE_SCALER_MULTIPLIER;\n    /// @notice constant value for inverting price to reduce gas usage\n    uint256 internal immutable _REDSTONE_INVERT_PRICE_DIVIDEND;\n\n    address internal immutable _REDSTONE_ORACLE_NOT_SET_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n\n    /// @notice constructor sets the Redstone oracle data\n    constructor(RedstoneOracleData memory oracleData_) {\n        if (address(oracleData_.oracle) == address(0) || oracleData_.token0Decimals == 0) {\n            revert FluidOracleError(ErrorTypes.RedstoneOracle__InvalidParams);\n        }\n\n        _REDSTONE_ORACLE = oracleData_.oracle;\n        _REDSTONE_INVERT_RATE = oracleData_.invertRate;\n\n        // for explanation on how to get to scaler multiplier and dividend see `chainlinkOracleImpl.sol`.\n        // no support for token1Decimals with more than OracleUtils.RATE_OUTPUT_DECIMALS decimals for now as extremely unlikely case\n        _REDSTONE_PRICE_SCALER_MULTIPLIER = address(oracleData_.oracle) == _REDSTONE_ORACLE_NOT_SET_ADDRESS\n            ? 1\n            : 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS - oracleData_.token0Decimals);\n        _REDSTONE_INVERT_PRICE_DIVIDEND = address(oracleData_.oracle) == _REDSTONE_ORACLE_NOT_SET_ADDRESS\n            ? 1\n            : 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS + oracleData_.token0Decimals);\n    }\n\n    /// @dev           Get the exchange rate from Redstone oracle\n    /// @param rate_   The exchange rate in `OracleUtils.RATE_OUTPUT_DECIMALS`\n    function _getRedstoneExchangeRate() internal view returns (uint256 rate_) {\n        try _REDSTONE_ORACLE.getExchangeRate() returns (uint256 exchangeRate_) {\n            if (_REDSTONE_INVERT_RATE) {\n                // invert the price\n                return _REDSTONE_INVERT_PRICE_DIVIDEND / exchangeRate_;\n            } else {\n                return exchangeRate_ * _REDSTONE_PRICE_SCALER_MULTIPLIER;\n            }\n        } catch {\n            return 0;\n        }\n    }\n\n    /// @notice returns all Redstone oracle related data as utility for easy off-chain use / block explorer in a single view method\n    function redstoneOracleData()\n        public\n        view\n        returns (uint256 redstoneExchangeRate_, IRedstoneOracle redstoneOracle_, bool redstoneInvertRate_)\n    {\n        return (\n            address(_REDSTONE_ORACLE) == _REDSTONE_ORACLE_NOT_SET_ADDRESS ? 0 : _getRedstoneExchangeRate(),\n            _REDSTONE_ORACLE,\n            _REDSTONE_INVERT_RATE\n        );\n    }\n}\n"
    },
    "contracts/oracle/implementations/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IChainlinkAggregatorV3 } from \"../interfaces/external/IChainlinkAggregatorV3.sol\";\nimport { IRedstoneOracle } from \"../interfaces/external/IRedstoneOracle.sol\";\n\nabstract contract ChainlinkStructs {\n    struct ChainlinkFeedData {\n        /// @param feed           address of Chainlink feed.\n        IChainlinkAggregatorV3 feed;\n        /// @param invertRate     true if rate read from price feed must be inverted.\n        bool invertRate;\n        /// @param token0Decimals decimals of asset 0. E.g. for a USDC/ETH feed, USDC is token0 and has 6 decimals.\n        ///                       (token1Decimals are available directly via Chainlink `FEED.decimals()`)\n        uint256 token0Decimals;\n    }\n\n    struct ChainlinkConstructorParams {\n        /// @param param        hops count of hops, used for sanity checks. Must be 1, 2 or 3.\n        uint8 hops;\n        /// @param feed1        Chainlink feed 1 data. Required.\n        ChainlinkFeedData feed1;\n        /// @param feed2        Chainlink feed 2 data. Required if hops > 1.\n        ChainlinkFeedData feed2;\n        /// @param feed3        Chainlink feed 3 data. Required if hops > 2.\n        ChainlinkFeedData feed3;\n    }\n}\n\nabstract contract RedstoneStructs {\n    struct RedstoneOracleData {\n        /// @param oracle         address of Redstone oracle.\n        IRedstoneOracle oracle;\n        /// @param invertRate     true if rate read from price feed must be inverted.\n        bool invertRate;\n        /// @param token0Decimals decimals of asset 0. E.g. for a USDC/ETH feed, USDC is token0 and has 6 decimals.\n        ///                       (token1Decimals are available directly via Redstone `Oracle.decimals()`)\n        uint256 token0Decimals;\n    }\n}\n"
    },
    "contracts/oracle/implementations/uniV3OracleImpl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { TickMath } from \"../libraries/TickMath.sol\";\nimport { OracleUtils } from \"../libraries/oracleUtils.sol\";\nimport { IUniswapV3Pool } from \"../interfaces/external/IUniswapV3Pool.sol\";\nimport { Error as OracleError } from \"../error.sol\";\n\n/// @title   Uniswap V3 Oracle implementation\n/// @notice  This contract is used to get the exchange rate from from a Uniswap V3 Pool,\n///          including logic to check against TWAP max deltas.\n/// @dev     Uses 5 secondsAgos[] values and 3 TWAP maxDeltas:\n///          e.g. [240, 60, 15, 1, 0] -> [price240to60, price60to15, price 15to1, currentPrice]\n///          delta checks: price240to60 vs currentPrice, price60to15 vs currentPrice and 15to1 vs currentPrice.\nabstract contract UniV3OracleImpl is OracleError {\n    /// @dev Uniswap V3 Pool to check for the exchange rate\n    IUniswapV3Pool internal immutable _POOL;\n\n    /// @dev Flag to invert the price or not (to e.g. for WETH/USDC pool return prive of USDC per 1 WETH)\n    bool internal immutable _UNIV3_INVERT_RATE;\n\n    /// @dev Uniswap oracle delta for TWAP1 in 1e2 percent. If uniswap price TWAP1 is out of this delta,\n    /// current price fetching reverts. E.g. for delta of TWAP 240 -> 60 vs current price\n    uint256 internal immutable _UNI_TWAP1_MAX_DELTA_PERCENT;\n    /// @dev Uniswap oracle delta for TWAP2 in 1e2 percent. If uniswap price TWAP2 is out of this delta,\n    /// current price fetching reverts. E.g. for delta of TWAP 60 -> 15 vs current price\n    uint256 internal immutable _UNI_TWAP2_MAX_DELTA_PERCENT;\n    /// @dev Uniswap oracle delta for TWAP3 in 1e2 percent. If uniswap price TWAP3 is out of this delta,\n    /// current price fetching reverts. E.g. for delta of TWAP 15 -> 1 vs current price\n    uint256 internal immutable _UNI_TWAP3_MAX_DELTA_PERCENT;\n\n    /// @dev Uniswap oracle seconds ago for twap, 1. value, e.g. 240\n    uint256 internal immutable _UNI_SECONDS_AGO_1;\n    /// @dev Uniswap oracle seconds ago for twap, 2. value, e.g. 60\n    uint256 internal immutable _UNI_SECONDS_AGO_2;\n    /// @dev Uniswap oracle seconds ago for twap, 3. value, e.g. 15\n    uint256 internal immutable _UNI_SECONDS_AGO_3;\n    /// @dev Uniswap oracle seconds ago for twap, 4. value, e.g. 1\n    uint256 internal immutable _UNI_SECONDS_AGO_4;\n    /// @dev Uniswap oracle seconds ago for twap, 5. value, e.g. 0\n    uint256 internal immutable _UNI_SECONDS_AGO_5;\n\n    /// @dev Uniswap TWAP1 interval duration.\n    int256 internal immutable _UNI_TWAP1_INTERVAL;\n    /// @dev Uniswap TWAP2 interval duration.\n    int256 internal immutable _UNI_TWAP2_INTERVAL;\n    /// @dev Uniswap TWAP3 interval duration.\n    int256 internal immutable _UNI_TWAP3_INTERVAL;\n    /// @dev Uniswap TWAP4 interval duration.\n    int256 internal immutable _UNI_TWAP4_INTERVAL;\n\n    /// @dev stored array lengths to optimize gas\n    uint256 internal constant _SECONDS_AGOS_LENGTH = 5;\n    uint256 internal constant _TWAP_DELTAS_LENGTH = 3;\n\n    /// @dev constant value for price scaling to reduce gas usage\n    uint256 internal immutable _UNIV3_PRICE_SCALER_MULTIPLIER;\n    /// @dev constant value for inverting price to reduce gas usage\n    uint256 internal immutable _UNIV3_INVERT_PRICE_DIVIDEND;\n\n    struct UniV3ConstructorParams {\n        /// @param pool                   Uniswap V3 Pool to check for the exchange rate\n        IUniswapV3Pool pool;\n        /// @param invertRate             Flag to invert the Uniswap price or not\n        bool invertRate;\n        /// @param tWAPMaxDeltaPercents Uniswap oracle delta for TWAP1-2-3 in 1e2 percent\n        uint256[_TWAP_DELTAS_LENGTH] tWAPMaxDeltaPercents;\n        /// @param secondsAgos          Uniswap oracle seconds ago for the 3 TWAP values, from oldest to newest, e.g. [240, 60, 15, 1, 0]\n        uint32[_SECONDS_AGOS_LENGTH] secondsAgos;\n    }\n\n    /// @notice constructor sets the  Uniswap V3 `pool_` to check for the exchange rate and the `invertRate_` flag.\n    /// E.g. `invertRate_` should be true if for the WETH/USDC pool it's expected that the oracle returns USDC per 1 WETH\n    constructor(UniV3ConstructorParams memory params_) {\n        if (address(params_.pool) == address(0)) {\n            revert FluidOracleError(ErrorTypes.UniV3Oracle__InvalidParams);\n        }\n        // sanity check that seconds agos values are ordered ascending, e.g. [240, 60, 15, 1, 0]\n        if (\n            params_.secondsAgos[0] <= params_.secondsAgos[1] ||\n            params_.secondsAgos[1] <= params_.secondsAgos[2] ||\n            params_.secondsAgos[2] <= params_.secondsAgos[3] ||\n            params_.secondsAgos[3] <= params_.secondsAgos[4]\n        ) {\n            revert FluidOracleError(ErrorTypes.UniV3Oracle__InvalidSecondsAgos);\n        }\n        // sanity check that deltas are less than 100% and decreasing (as timespan is closer to current price):\n        // 1. delta must < 100%\n        // all following deltas must be <= than the previous one\n        if (\n            params_.tWAPMaxDeltaPercents[0] >= OracleUtils.HUNDRED_PERCENT_DELTA_SCALER ||\n            params_.tWAPMaxDeltaPercents[1] > params_.tWAPMaxDeltaPercents[0] ||\n            params_.tWAPMaxDeltaPercents[2] > params_.tWAPMaxDeltaPercents[1]\n        ) {\n            revert FluidOracleError(ErrorTypes.UniV3Oracle__InvalidDeltas);\n        }\n\n        _UNI_SECONDS_AGO_1 = uint256(params_.secondsAgos[0]);\n        _UNI_SECONDS_AGO_2 = uint256(params_.secondsAgos[1]);\n        _UNI_SECONDS_AGO_3 = uint256(params_.secondsAgos[2]);\n        _UNI_SECONDS_AGO_4 = uint256(params_.secondsAgos[3]);\n        _UNI_SECONDS_AGO_5 = uint256(params_.secondsAgos[4]);\n\n        _UNI_TWAP1_INTERVAL = int256(uint256(params_.secondsAgos[0] - params_.secondsAgos[1]));\n        _UNI_TWAP2_INTERVAL = int256(uint256(params_.secondsAgos[1] - params_.secondsAgos[2]));\n        _UNI_TWAP3_INTERVAL = int256(uint256(params_.secondsAgos[2] - params_.secondsAgos[3]));\n        _UNI_TWAP4_INTERVAL = int256(uint256(params_.secondsAgos[3] - params_.secondsAgos[4]));\n\n        _UNI_TWAP1_MAX_DELTA_PERCENT = params_.tWAPMaxDeltaPercents[0]; // e.g. for TWAP 240 -> 60 vs current price\n        _UNI_TWAP2_MAX_DELTA_PERCENT = params_.tWAPMaxDeltaPercents[1]; // e.g. for TWAP  60 -> 15 vs current price\n        _UNI_TWAP3_MAX_DELTA_PERCENT = params_.tWAPMaxDeltaPercents[2]; // e.g. for TWAP  15 ->  1 vs current price\n\n        _POOL = params_.pool;\n        _UNIV3_INVERT_RATE = params_.invertRate;\n\n        // uniswapV3 returned price is already scaled to token decimals.\n        _UNIV3_PRICE_SCALER_MULTIPLIER = 10 ** OracleUtils.RATE_OUTPUT_DECIMALS;\n        // uniV3 invert price dividend happens on the already scaled by 1e27 result for price in token1 per 1 token0\n        _UNIV3_INVERT_PRICE_DIVIDEND = 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS * 2);\n    }\n\n    /// @dev                        Get the last exchange rate from the pool's last observed value without any checks\n    /// @return exchangeRateUnsafe_ The exchange rate between the underlying asset and the peg asset in `OracleUtils.RATE_OUTPUT_DECIMALS`\n    function _getUniV3ExchangeRateUnsafe() internal view returns (uint256 exchangeRateUnsafe_) {\n        (uint160 sqrtPriceX96_, , , , , , ) = _POOL.slot0();\n\n        exchangeRateUnsafe_ = _UNIV3_INVERT_RATE\n            ? _invertUniV3Price(_getPriceFromSqrtPriceX96(sqrtPriceX96_))\n            : _getPriceFromSqrtPriceX96(sqrtPriceX96_);\n    }\n\n    /// @dev                   Get the last exchange rate from the pool's last observed value, checked against TWAP deviations.\n    /// @return exchangeRate_  The exchange rate between the underlying asset and the peg asset in `OracleUtils.RATE_OUTPUT_DECIMALS`\n    ///                        If 0 then the fetching the price failed or a delta was invalid.\n    function _getUniV3ExchangeRate() internal view returns (uint256 exchangeRate_) {\n        // build calldata bytes in a gas-optimized way without having to build an array / using abi.encode.\n        // gas efficient work around for Solidity not supporting immutable non-value types.\n        bytes memory data_ = abi.encodePacked(\n            hex\"883bdbfd\", // pack function selector\n            hex\"0000000000000000000000000000000000000000000000000000000000000020\", // pack start offset of dynamic array\n            _SECONDS_AGOS_LENGTH, // pack length of dynamic array\n            // pack seconds agos values:\n            _UNI_SECONDS_AGO_1,\n            _UNI_SECONDS_AGO_2,\n            _UNI_SECONDS_AGO_3,\n            _UNI_SECONDS_AGO_4,\n            _UNI_SECONDS_AGO_5\n        );\n\n        // get the tickCumulatives from Pool.observe()\n        (bool success_, bytes memory result_) = address(_POOL).staticcall(data_);\n\n        if (!success_) {\n            return 0;\n        }\n        int56[] memory tickCumulatives_ = abi.decode(result_, (int56[]));\n\n        unchecked {\n            int24 exchangeRateTick_;\n            {\n                int56 tickCumulativesDelta_ = (tickCumulatives_[_TWAP_DELTAS_LENGTH + 1] -\n                    tickCumulatives_[_TWAP_DELTAS_LENGTH]);\n                // _UNI_TWAP4_INTERVAL can not be 0 because of constructor sanity checks\n                exchangeRateTick_ = int24(tickCumulativesDelta_ / _UNI_TWAP4_INTERVAL);\n                // Always round to negative infinity, see UniV3 OracleLibrary\n                // https://github.com/Uniswap/v3-periphery/blob/697c2474757ea89fec12a4e6db16a574fe259610/contracts/libraries/OracleLibrary.sol#L36\n                if (tickCumulativesDelta_ < 0 && (tickCumulativesDelta_ % _UNI_TWAP4_INTERVAL != 0)) {\n                    exchangeRateTick_--;\n                }\n            }\n\n            // Check the latest Uniswap price is within the acceptable delta from each TWAP range\n            // TWAP 1 check\n            if (\n                _isInvalidTWAPDelta(\n                    int256(exchangeRateTick_),\n                    tickCumulatives_[1] - tickCumulatives_[0],\n                    _UNI_TWAP1_INTERVAL,\n                    int256(_UNI_TWAP1_MAX_DELTA_PERCENT)\n                )\n            ) {\n                return 0;\n            }\n\n            // TWAP 2 check\n            if (\n                _isInvalidTWAPDelta(\n                    int256(exchangeRateTick_),\n                    tickCumulatives_[2] - tickCumulatives_[1],\n                    _UNI_TWAP2_INTERVAL,\n                    int256(_UNI_TWAP2_MAX_DELTA_PERCENT)\n                )\n            ) {\n                return 0;\n            }\n\n            // TWAP 3 check\n            if (\n                _isInvalidTWAPDelta(\n                    int256(exchangeRateTick_),\n                    tickCumulatives_[3] - tickCumulatives_[2],\n                    _UNI_TWAP3_INTERVAL,\n                    int256(_UNI_TWAP3_MAX_DELTA_PERCENT)\n                )\n            ) {\n                return 0;\n            }\n\n            // get the current uniswap price, which is the last tick cumulatives interval, usually [..., 1, 0]\n            exchangeRate_ = _getPriceFromSqrtPriceX96(TickMath.getSqrtRatioAtTick(exchangeRateTick_));\n            if (_UNIV3_INVERT_RATE) {\n                exchangeRate_ = _invertUniV3Price(exchangeRate_);\n            }\n        }\n    }\n\n    /// @dev verifies that `exchangeRate_` is within `maxDelta_` for derived price from `tickCumulativesDelta_` and `interval_`.\n    /// returns true if delta is invalid\n    function _isInvalidTWAPDelta(\n        int256 exchangeRateTick_,\n        int256 tickCumulativesDelta_,\n        int256 interval_, // can not be 0 because of constructor sanity checks\n        int256 maxDelta_\n    ) internal pure returns (bool) {\n        unchecked {\n            int256 arithmeticMeanTick_ = int256(tickCumulativesDelta_ / interval_);\n            // Always round to negative infinity, see UniV3 OracleLibrary\n            // https://github.com/Uniswap/v3-periphery/blob/697c2474757ea89fec12a4e6db16a574fe259610/contracts/libraries/OracleLibrary.sol#L36\n            if (tickCumulativesDelta_ < 0 && (tickCumulativesDelta_ % interval_ != 0)) {\n                arithmeticMeanTick_--;\n            }\n\n            // Check that the uniswapPrice is within DELTA of the Uniswap TWAP (via tick)\n            // each univ3 tick is 0.01% increase or decrease in price. `maxDelta_` has near to same precision.\n            // Note: near to the same because each Uniswap tick is 0.01% away so price of ticks are if current one is 100 then next will be:\n            // 100 + 100 * 0.01% = 100.01\n            // 100.01 + 100.01 * 0.01% = 100.020001\n            if (\n                exchangeRateTick_ > (arithmeticMeanTick_ + maxDelta_) ||\n                exchangeRateTick_ < (arithmeticMeanTick_ - maxDelta_)\n            ) {\n                // Uniswap last price is NOT within the delta\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @notice returns all UniV3 oracle related data as utility for easy off-chain use / block explorer in a single view method\n    function uniV3OracleData()\n        public\n        view\n        returns (\n            IUniswapV3Pool uniV3Pool_,\n            bool uniV3InvertRate_,\n            uint32[] memory uniV3secondsAgos_,\n            uint256[] memory uniV3TwapDeltas_,\n            uint256 uniV3exchangeRateUnsafe_,\n            uint256 uniV3exchangeRate_\n        )\n    {\n        // Get the latest TWAP prices from the Uniswap Oracle for second intervals\n        uniV3secondsAgos_ = new uint32[](_SECONDS_AGOS_LENGTH);\n        uniV3secondsAgos_[0] = uint32(_UNI_SECONDS_AGO_1);\n        uniV3secondsAgos_[1] = uint32(_UNI_SECONDS_AGO_2);\n        uniV3secondsAgos_[2] = uint32(_UNI_SECONDS_AGO_3);\n        uniV3secondsAgos_[3] = uint32(_UNI_SECONDS_AGO_4);\n        uniV3secondsAgos_[4] = uint32(_UNI_SECONDS_AGO_5);\n\n        // Check the latest Uniswap price is within the acceptable delta from each TWAP range\n        uniV3TwapDeltas_ = new uint256[](_TWAP_DELTAS_LENGTH);\n        uniV3TwapDeltas_[0] = _UNI_TWAP1_MAX_DELTA_PERCENT;\n        uniV3TwapDeltas_[1] = _UNI_TWAP2_MAX_DELTA_PERCENT;\n        uniV3TwapDeltas_[2] = _UNI_TWAP3_MAX_DELTA_PERCENT;\n\n        return (\n            _POOL,\n            _UNIV3_INVERT_RATE,\n            uniV3secondsAgos_,\n            uniV3TwapDeltas_,\n            _getUniV3ExchangeRateUnsafe(),\n            _getUniV3ExchangeRate()\n        );\n    }\n\n    /// @dev                  Get the price from the sqrt price in `OracleUtils.RATE_OUTPUT_DECIMALS`\n    ///                       (see https://blog.uniswap.org/uniswap-v3-math-primer)\n    /// @param sqrtPriceX96_  The sqrt price to convert\n    function _getPriceFromSqrtPriceX96(uint160 sqrtPriceX96_) private view returns (uint256 priceX96_) {\n        return\n            FullMath.mulDiv(\n                uint256(sqrtPriceX96_) * uint256(sqrtPriceX96_),\n                _UNIV3_PRICE_SCALER_MULTIPLIER,\n                1 << 192 // 2^96 * 2\n            );\n    }\n\n    /// @dev                     Invert the price\n    /// @param price_            The price to invert\n    /// @return invertedPrice_   The inverted price in `OracleUtils.RATE_OUTPUT_DECIMALS`\n    function _invertUniV3Price(uint256 price_) private view returns (uint256 invertedPrice_) {\n        return _UNIV3_INVERT_PRICE_DIVIDEND / price_;\n    }\n}\n"
    },
    "contracts/oracle/interfaces/external/IBalancerRateProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IBalancerRateProvider {\n    /// @notice Returns the current rate of e.g. ezETH in ETH\n    function getRate() external view returns (uint256 rate);\n}\n"
    },
    "contracts/oracle/interfaces/external/IChainlinkAggregatorV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// from https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\n/// Copyright (c) 2018 SmartContract ChainLink, Ltd.\n\ninterface IChainlinkAggregatorV3 {\n    /// @notice represents the number of decimals the aggregator responses represent.\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/oracle/interfaces/external/IMaticXChildPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IMaticXChildPool {\n    /// @notice Converts an amount of MaticX shares to POL tokens.\n    /// @param _balance - Balance in MaticX shares\n    /// @return Balance in POL tokens\n    /// @return Total MaticX shares\n    /// @return Total pooled POL tokens\n    function convertMaticXToMatic(uint256 _balance) external view returns (uint256, uint256, uint256);\n}\n"
    },
    "contracts/oracle/interfaces/external/IRedstoneOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IRedstoneOracle {\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset\n    // @dev custom Redstone adapter for Instadapp implementation\n    function getExchangeRate() external view returns (uint256 exchangeRate_);\n\n    /**\n     * @notice Returns the number of decimals for the price feed\n     * @dev By default, RedStone uses 8 decimals for data feeds\n     * @return decimals The number of decimals in the price feed values\n     */\n    // see https://github.com/redstone-finance/redstone-oracles-monorepo/blob/main/packages/on-chain-relayer/contracts/price-feeds/PriceFeedBase.sol#L51C12-L51C20\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/oracle/interfaces/external/IRLPPrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IRLPPrice {\n    struct Price {\n        uint256 price;\n        uint256 timestamp;\n    }\n\n    function lastPrice() external view returns (Price memory price);\n}\n"
    },
    "contracts/oracle/interfaces/external/IRsETHLRTOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IRsETHLRTOracle {\n    /// @notice ETH per 1 rsETH exchange rate\n    function rsETHPrice() external view returns (uint256 rate);\n}\n"
    },
    "contracts/oracle/interfaces/external/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.21;\n\n/// from https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces.\n/// Copyright (c) 2022 Uniswap Labs\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(\n        uint32[] calldata secondsAgos\n    ) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(\n        int24 tickLower,\n        int24 tickUpper\n    ) external view returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside);\n}\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(\n        int24 tick\n    )\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(\n        bytes32 key\n    )\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(\n        uint256 index\n    )\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is IUniswapV3PoolImmutables, IUniswapV3PoolState, IUniswapV3PoolDerivedState {\n\n}\n"
    },
    "contracts/oracle/interfaces/external/IVedaAccountant.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n// Accountant interface as used by WEETHS and EBTC\ninterface IVedaAccountant {\n    /**\n     * @notice Get this BoringVault's current rate in the base.\n     */\n    function getRate() external view returns (uint256 rate);\n\n    /**\n     * @notice Get this BoringVault's current rate in the base.\n     * @dev Revert if paused.\n     */\n    function getRateSafe() external view returns (uint256 rate);\n\n    /**\n     * @notice The BoringVault this accountant is working with.\n     *         Used to determine share supply for fee calculation.\n     */\n    function vault() external view returns (address vault);\n}\n"
    },
    "contracts/oracle/interfaces/external/IWeETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IWeETH {\n    /**\n     * @notice Get amount of eETH for {_weETHAmount} weETH\n     * @return Amount of eETH for {_weETHAmount} weETH\n     */\n    function getEETHByWeETH(uint256 _weETHAmount) external view returns (uint256);\n\n    /**\n     * @notice Get amount of weETH for {_eETHAmount} eETH\n     * @return Amount of weETH for {_eETHAmount} eETH\n     */\n    function getWeETHByeETH(uint256 _eETHAmount) external view returns (uint256);\n}\n"
    },
    "contracts/oracle/interfaces/external/IWstETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IWstETH {\n    /**\n     * @notice Get amount of stETH for 1 wstETH\n     * @return Amount of stETH for 1 wstETH\n     */\n    function stEthPerToken() external view returns (uint256);\n\n    /**\n     * @notice Get amount of wstETH for 1 stETH\n     * @return Amount of wstETH for 1 stETH\n     */\n    function tokensPerStEth() external view returns (uint256);\n}\n"
    },
    "contracts/oracle/interfaces/iFluidCappedRate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"./iFluidOracle.sol\";\n\ninterface IFluidCappedRate is IFluidOracle {\n    /// @notice Get the operate() exchange rate for debt asset side, with no cap upwards and capped decrease\n    function getExchangeRateOperateDebt() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the liquidate() exchange rate for debt asset side, with max APR cap upwards, and capped decrease\n    function getExchangeRateLiquidateDebt() external view returns (uint256 exchangeRate_);\n\n    /// @notice Retrieves the center price for use in a Fluid dex pool\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\n    /// @return price_ The current price ratio of token1 to token0, expressed with 27 decimal places\n    function centerPrice() external returns (uint256 price_);\n}\n"
    },
    "contracts/oracle/interfaces/iFluidCenterPrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidCenterPrice {\n    /// @notice Retrieves the center price for the pool\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\n    /// @return price_ The current price ratio of token1 to token0, expressed with 27 decimal places\n    function centerPrice() external returns (uint256 price_);\n\n    /// @notice helper string to easily identify the oracle. E.g. token symbols\n    function infoName() external view returns (string memory);\n\n    /// @notice target decimals of the returned rate. for center price contracts it is always 27\n    function targetDecimals() external view returns (uint8);\n}\n"
    },
    "contracts/oracle/interfaces/iFluidOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidOracle {\n    /// @dev Deprecated. Use `getExchangeRateOperate()` and `getExchangeRateLiquidate()` instead. Only implemented for\n    ///      backwards compatibility.\n    function getExchangeRate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for operates\n    function getExchangeRateOperate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for liquidations\n    function getExchangeRateLiquidate() external view returns (uint256 exchangeRate_);\n\n    /// @notice helper string to easily identify the oracle. E.g. token symbols\n    function infoName() external view returns (string memory);\n\n    /// @notice target decimals of the returned oracle rate when scaling to 1e27. E.g. for ETH / USDC it would be 15\n    /// because diff of ETH decimals to 1e27 is 9, and USDC has 6 decimals, so 6+9 = 15, e.g. 2029,047772120364926\n    /// For USDC / ETH: 21 + 18 = 39, e.g. 0,000492842018675092636829357843847601646\n    function targetDecimals() external view returns (uint8);\n}\n"
    },
    "contracts/oracle/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// from: https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/FullMath.sol\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (0 - denominator) & denominator;\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) > 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}"
    },
    "contracts/oracle/libraries/oracleUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title Oracle utils library\n/// @notice implements common utility methods for Fluid Oracles\nlibrary OracleUtils {\n    /// @dev The scaler for max delta point math (100%)\n    uint256 internal constant HUNDRED_PERCENT_DELTA_SCALER = 10_000;\n    /// @dev output precision of rates\n    uint256 internal constant RATE_OUTPUT_DECIMALS = 27;\n\n    /// @dev checks if `mainSourceRate_` is within a `maxDeltaPercent_` of `checkSourceRate_`. Returns true if so.\n    function isRateOutsideDelta(\n        uint256 mainSourceRate_,\n        uint256 checkSourceRate_,\n        uint256 maxDeltaPercent_\n    ) internal pure returns (bool) {\n        uint256 offset_ = (checkSourceRate_ * maxDeltaPercent_) / HUNDRED_PERCENT_DELTA_SCALER;\n        return (mainSourceRate_ > (checkSourceRate_ + offset_) || mainSourceRate_ < (checkSourceRate_ - offset_));\n    }\n}\n"
    },
    "contracts/oracle/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.21;\n\n/// from: https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    error T();\n    error R();\n\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\n\n            uint256 ratio = absTick & 0x1 != 0\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\n                : 0x100000000000000000000000000000000;\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            if (tick > 0) ratio = type(uint256).max / ratio;\n\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // second inequality must be < because the price can never reach the price at the max tick\n            if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = ratio;\n            uint256 msb = 0;\n\n            assembly {\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(5, gt(r, 0xFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(4, gt(r, 0xFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(3, gt(r, 0xFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(2, gt(r, 0xF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(1, gt(r, 0x3))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := gt(r, 0x1)\n                msb := or(msb, f)\n            }\n\n            if (msb >= 128) r = ratio >> (msb - 127);\n            else r = ratio << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}"
    },
    "contracts/oracle/oracles/dex/dexSmartColPegOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracle, IFluidOracle } from \"../../fluidOracle.sol\";\nimport { DexOracleAdjustResult } from \"../../implementations/dex/dexOracleBase.sol\";\nimport { DexSmartColOracleImpl } from \"../../implementations/dex/dexSmartColOracleImpl.sol\";\n\nimport { DexColDebtPriceFluidOracle } from \"../../implementations/dex/colDebtPrices/colDebtPriceFluidOracle.sol\";\nimport { DexConversionPriceFluidOracle } from \"../../implementations/dex/conversionPriceGetters/conversionPriceFluidOracle.sol\";\nimport { DexReservesFromLiquidityPeg } from \"../../implementations/dex/reserveGetters/reservesFromLiquidityPeg.sol\";\n\n/// @title   Fluid Dex Smart Col Pegged Oracle for assets ~1=~1\n/// @notice  Gets the exchange rate between a Fluid Dex smart collateral shares and normal debt.\n/// @dev -> Reserves from Liquidity with Peg buffer percent.\n///      -> Reserves conversion price from separately deployed FluidOracle (optional e.g. needed for wstETH-ETH).\n///      -> colDebt Price Oracle is an IFluidOracle.\ncontract DexSmartColPegOracle is\n    FluidOracle,\n    DexSmartColOracleImpl,\n    DexColDebtPriceFluidOracle,\n    DexConversionPriceFluidOracle,\n    DexReservesFromLiquidityPeg\n{\n    struct DexSmartColPegOracleParams {\n        string infoName;\n        uint8 targetDecimals;\n        address dexPool;\n        bool quoteInToken0;\n        IFluidOracle colDebtOracle;\n        bool colDebtInvert;\n        uint256 pegBufferPercent;\n        DexConversionPriceFluidOracleParams reservesConversionParams;\n        uint256 resultMultiplier;\n        uint256 resultDivisor;\n    }\n\n    constructor(\n        DexSmartColPegOracleParams memory params_\n    )\n        FluidOracle(params_.infoName, params_.targetDecimals)\n        DexOracleAdjustResult(params_.resultMultiplier, params_.resultDivisor)\n        DexReservesFromLiquidityPeg(params_.dexPool, params_.quoteInToken0, params_.pegBufferPercent)\n        DexColDebtPriceFluidOracle(params_.colDebtOracle, params_.colDebtInvert)\n        DexConversionPriceFluidOracle(params_.reservesConversionParams)\n    {}\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateOperate() public view virtual override returns (uint256 exchangeRate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves();\n\n        uint256 quoteTokensPer1ColShare_ = _getDexSmartColExchangeRate(\n            _getDexReservesConversionPriceOperate(),\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return\n            (quoteTokensPer1ColShare_ * _getDexColDebtPriceOperate() * RESULT_MULTIPLIER) /\n            (DEX_COL_DEBT_ORACLE_PRECISION * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateLiquidate() public view virtual override returns (uint256 exchangeRate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves();\n\n        uint256 quoteTokensPer1ColShare_ = _getDexSmartColExchangeRate(\n            _getDexReservesConversionPriceLiquidate(),\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return\n            (quoteTokensPer1ColShare_ * _getDexColDebtPriceLiquidate() * RESULT_MULTIPLIER) /\n            (DEX_COL_DEBT_ORACLE_PRECISION * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() public view virtual override returns (uint256 exchangeRate_) {\n        return getExchangeRateOperate();\n    }\n\n    /// @inheritdoc DexSmartColOracleImpl\n    function dexSmartColSharesRates() public view override returns (uint256 operate_, uint256 liquidate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves();\n\n        return (\n            _getDexSmartColExchangeRate(_getDexReservesConversionPriceOperate(), token0Reserves_, token1Reserves_),\n            _getDexSmartColExchangeRate(_getDexReservesConversionPriceLiquidate(), token0Reserves_, token1Reserves_)\n        );\n    }\n}\n"
    },
    "contracts/oracle/oracles/dex/dexSmartDebtPegOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracle, IFluidOracle } from \"../../fluidOracle.sol\";\nimport { DexOracleAdjustResult } from \"../../implementations/dex/dexOracleBase.sol\";\nimport { DexSmartDebtOracleImpl } from \"../../implementations/dex/dexSmartDebtOracleImpl.sol\";\n\nimport { DexColDebtPriceFluidOracle } from \"../../implementations/dex/colDebtPrices/colDebtPriceFluidOracle.sol\";\nimport { DexConversionPriceFluidOracle } from \"../../implementations/dex/conversionPriceGetters/conversionPriceFluidOracle.sol\";\nimport { DexReservesFromLiquidityPeg } from \"../../implementations/dex/reserveGetters/reservesFromLiquidityPeg.sol\";\n\n/// @title   Fluid Dex Smart Debt Pegged Oracle for assets ~1=~1\n/// @notice  Gets the exchange rate between a Fluid Dex normal collateral and smart debt shares.\n/// @dev -> Reserves from Liquidity with Peg buffer percent.\n///      -> Reserves conversion price from separately deployed FluidOracle (optional e.g. needed for wstETH-ETH).\n///      -> colDebt Price Oracle is an IFluidOracle.\ncontract DexSmartDebtPegOracle is\n    FluidOracle,\n    DexSmartDebtOracleImpl,\n    DexColDebtPriceFluidOracle,\n    DexConversionPriceFluidOracle,\n    DexReservesFromLiquidityPeg\n{\n    struct DexSmartDebtPegOracleParams {\n        string infoName;\n        uint8 targetDecimals;\n        address dexPool;\n        bool quoteInToken0;\n        IFluidOracle colDebtOracle;\n        bool colDebtInvert;\n        uint256 pegBufferPercent;\n        DexConversionPriceFluidOracleParams reservesConversionParams;\n        uint256 resultMultiplier;\n        uint256 resultDivisor;\n    }\n\n    constructor(\n        DexSmartDebtPegOracleParams memory params_\n    )\n        FluidOracle(params_.infoName, params_.targetDecimals)\n        DexOracleAdjustResult(params_.resultMultiplier, params_.resultDivisor)\n        DexReservesFromLiquidityPeg(params_.dexPool, params_.quoteInToken0, params_.pegBufferPercent)\n        DexColDebtPriceFluidOracle(params_.colDebtOracle, params_.colDebtInvert)\n        DexConversionPriceFluidOracle(params_.reservesConversionParams)\n    {}\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateOperate() public view virtual override returns (uint256 exchangeRate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexDebtReserves();\n\n        uint256 debtSharesPer1QuoteToken_ = _getDexSmartDebtExchangeRate(\n            _getDexReservesConversionPriceOperate(),\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return\n            (debtSharesPer1QuoteToken_ * _getDexColDebtPriceOperate() * RESULT_MULTIPLIER) /\n            (DEX_COL_DEBT_ORACLE_PRECISION * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateLiquidate() public view virtual override returns (uint256 exchangeRate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexDebtReserves();\n\n        uint256 debtSharesPer1QuoteToken_ = _getDexSmartDebtExchangeRate(\n            _getDexReservesConversionPriceLiquidate(),\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return\n            (debtSharesPer1QuoteToken_ * _getDexColDebtPriceLiquidate() * RESULT_MULTIPLIER) /\n            (DEX_COL_DEBT_ORACLE_PRECISION * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() public view virtual override returns (uint256 exchangeRate_) {\n        return getExchangeRateOperate();\n    }\n\n    /// @inheritdoc DexSmartDebtOracleImpl\n    function dexSmartDebtSharesRates() public view override returns (uint256 operate_, uint256 liquidate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexDebtReserves();\n\n        return (\n            _getDexSmartDebtExchangeRate(_getDexReservesConversionPriceOperate(), token0Reserves_, token1Reserves_),\n            _getDexSmartDebtExchangeRate(_getDexReservesConversionPriceLiquidate(), token0Reserves_, token1Reserves_)\n        );\n    }\n}\n"
    },
    "contracts/oracle/oracles/dex/dexSmartT4CLOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracle, IFluidOracle } from \"../../fluidOracle.sol\";\nimport { DexOracleAdjustResult } from \"../../implementations/dex/dexOracleBase.sol\";\nimport { DexSmartColOracleImpl } from \"../../implementations/dex/dexSmartColOracleImpl.sol\";\nimport { DexSmartDebtOracleImpl } from \"../../implementations/dex/dexSmartDebtOracleImpl.sol\";\n\nimport { DexReservesFromPEX } from \"../../implementations/dex/reserveGetters/reservesFromPEX.sol\";\nimport { DexConversionPriceCL, ChainlinkOracleImpl } from \"../../implementations/dex/conversionPriceGetters/conversionPriceCL.sol\";\n\n/// @title   Fluid Dex Smart Col Debt VaultT4 Oracle\n/// @notice  Gets the exchange rate between a Fluid Dex smart collateral and smart debt for a T4 vault.\n///          returns amount of debt shares per 1 col share.\n/// @dev -> Reserves from Liquidity, adjusted for conversion price.\n///      -> Reserves conversion price from Chainlink feeds.\ncontract DexSmartT4CLOracle is\n    FluidOracle,\n    DexSmartColOracleImpl,\n    DexSmartDebtOracleImpl,\n    DexConversionPriceCL,\n    DexReservesFromPEX\n{\n    struct DexSmartT4CLOracleParams {\n        string infoName;\n        uint8 targetDecimals;\n        address dexPool;\n        bool quoteInToken0;\n        ChainlinkOracleImpl.ChainlinkConstructorParams reservesConversion;\n        uint256 reservesConversionPriceMultiplier;\n        uint256 reservesConversionPriceDivisor;\n        uint256 resultMultiplier;\n        uint256 resultDivisor;\n    }\n\n    constructor(\n        DexSmartT4CLOracleParams memory params_\n    )\n        FluidOracle(params_.infoName, params_.targetDecimals)\n        DexOracleAdjustResult(params_.resultMultiplier, params_.resultDivisor)\n        DexReservesFromPEX(params_.dexPool, params_.quoteInToken0)\n        DexConversionPriceCL(\n            params_.reservesConversion,\n            params_.reservesConversionPriceMultiplier,\n            params_.reservesConversionPriceDivisor\n        )\n    {}\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateOperate() public view virtual override returns (uint256 exchangeRate_) {\n        uint256 conversionPrice_ = _getDexReservesConversionPriceOperate();\n        PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices();\n\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves(conversionPrice_, pex_);\n\n        uint256 quoteTokensPer1ColShare_ = _getDexSmartColExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        (token0Reserves_, token1Reserves_) = _getDexDebtReserves(conversionPrice_, pex_);\n        uint256 debtSharesPer1QuoteToken_ = _getDexSmartDebtExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return (debtSharesPer1QuoteToken_ * quoteTokensPer1ColShare_ * RESULT_MULTIPLIER) / (1e27 * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateLiquidate() public view virtual override returns (uint256 exchangeRate_) {\n        uint256 conversionPrice_ = _getDexReservesConversionPriceLiquidate();\n        PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices();\n\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves(conversionPrice_, pex_);\n\n        uint256 quoteTokensPer1ColShare_ = _getDexSmartColExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        (token0Reserves_, token1Reserves_) = _getDexDebtReserves(conversionPrice_, pex_);\n        uint256 debtSharesPer1QuoteToken_ = _getDexSmartDebtExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return (debtSharesPer1QuoteToken_ * quoteTokensPer1ColShare_ * RESULT_MULTIPLIER) / (1e27 * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() public view virtual override returns (uint256 exchangeRate_) {\n        return getExchangeRateOperate();\n    }\n\n    /// @inheritdoc DexSmartColOracleImpl\n    function dexSmartColSharesRates() public view override returns (uint256 operate_, uint256 liquidate_) {\n        {\n            uint256 conversionPrice_ = _getDexReservesConversionPriceOperate();\n\n            (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves(\n                conversionPrice_,\n                _getPricesAndExchangePrices()\n            );\n\n            operate_ = _getDexSmartColExchangeRate(conversionPrice_, token0Reserves_, token1Reserves_);\n        }\n\n        {\n            uint256 conversionPrice_ = _getDexReservesConversionPriceLiquidate();\n\n            (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves(\n                conversionPrice_,\n                _getPricesAndExchangePrices()\n            );\n\n            liquidate_ = _getDexSmartColExchangeRate(conversionPrice_, token0Reserves_, token1Reserves_);\n        }\n    }\n\n    /// @inheritdoc DexSmartDebtOracleImpl\n    function dexSmartDebtSharesRates() public view override returns (uint256 operate_, uint256 liquidate_) {\n        {\n            uint256 conversionPrice_ = _getDexReservesConversionPriceOperate();\n\n            (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexDebtReserves(\n                conversionPrice_,\n                _getPricesAndExchangePrices()\n            );\n\n            operate_ = _getDexSmartDebtExchangeRate(conversionPrice_, token0Reserves_, token1Reserves_);\n        }\n\n        {\n            uint256 conversionPrice_ = _getDexReservesConversionPriceLiquidate();\n\n            (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexDebtReserves(\n                conversionPrice_,\n                _getPricesAndExchangePrices()\n            );\n\n            liquidate_ = _getDexSmartDebtExchangeRate(conversionPrice_, token0Reserves_, token1Reserves_);\n        }\n    }\n}\n"
    },
    "contracts/oracle/oracles/dex/dexSmartT4PegOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracle, IFluidOracle } from \"../../fluidOracle.sol\";\nimport { DexOracleAdjustResult } from \"../../implementations/dex/dexOracleBase.sol\";\nimport { DexSmartColOracleImpl } from \"../../implementations/dex/dexSmartColOracleImpl.sol\";\nimport { DexSmartDebtOracleImpl } from \"../../implementations/dex/dexSmartDebtOracleImpl.sol\";\n\nimport { DexReservesFromLiquidityPeg } from \"../../implementations/dex/reserveGetters/reservesFromLiquidityPeg.sol\";\nimport { DexConversionPriceFluidOracle } from \"../../implementations/dex/conversionPriceGetters/conversionPriceFluidOracle.sol\";\n\n/// @title   Fluid Dex Smart Col Debt Pegged Oracle for assets ~1=~1\n/// @notice  Gets the exchange rate between a Fluid Dex smart collateral shares and smart debt shares.\n/// @dev -> Reserves from Liquidity with Peg buffer percent.\n///      -> Reserves conversion price from separately deployed FluidOracle (optional e.g. needed for wstETH-ETH).\ncontract DexSmartT4PegOracle is\n    FluidOracle,\n    DexSmartColOracleImpl,\n    DexSmartDebtOracleImpl,\n    DexConversionPriceFluidOracle,\n    DexReservesFromLiquidityPeg\n{\n    struct DexSmartT4PegOracleParams {\n        string infoName;\n        uint8 targetDecimals;\n        address dexPool;\n        bool quoteInToken0;\n        uint256 pegBufferPercent;\n        // conversion oracle is optional, set to address zero if not used. See DexConversionPriceFluidOracle\n        DexConversionPriceFluidOracleParams reservesConversionParams;\n        uint256 resultMultiplier;\n        uint256 resultDivisor;\n    }\n\n    constructor(\n        DexSmartT4PegOracleParams memory params_\n    )\n        FluidOracle(params_.infoName, params_.targetDecimals)\n        DexOracleAdjustResult(params_.resultMultiplier, params_.resultDivisor)\n        DexReservesFromLiquidityPeg(params_.dexPool, params_.quoteInToken0, params_.pegBufferPercent)\n        DexConversionPriceFluidOracle(params_.reservesConversionParams)\n    {}\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateOperate() public view virtual override returns (uint256 exchangeRate_) {\n        uint256 conversionPrice_ = _getDexReservesConversionPriceOperate();\n\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves();\n        uint256 quoteTokensPer1ColShare_ = _getDexSmartColExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        (token0Reserves_, token1Reserves_) = _getDexDebtReserves();\n        uint256 debtSharesPer1QuoteToken_ = _getDexSmartDebtExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return (debtSharesPer1QuoteToken_ * quoteTokensPer1ColShare_ * RESULT_MULTIPLIER) / (1e27 * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateLiquidate() public view virtual override returns (uint256 exchangeRate_) {\n        uint256 conversionPrice_ = _getDexReservesConversionPriceLiquidate();\n\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves();\n        uint256 quoteTokensPer1ColShare_ = _getDexSmartColExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        (token0Reserves_, token1Reserves_) = _getDexDebtReserves();\n        uint256 debtSharesPer1QuoteToken_ = _getDexSmartDebtExchangeRate(\n            conversionPrice_,\n            token0Reserves_,\n            token1Reserves_\n        );\n\n        return (debtSharesPer1QuoteToken_ * quoteTokensPer1ColShare_ * RESULT_MULTIPLIER) / (1e27 * RESULT_DIVISOR);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() public view virtual override returns (uint256 exchangeRate_) {\n        return getExchangeRateOperate();\n    }\n\n    /// @inheritdoc DexSmartColOracleImpl\n    function dexSmartColSharesRates() public view override returns (uint256 operate_, uint256 liquidate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexCollateralReserves();\n\n        return (\n            _getDexSmartColExchangeRate(_getDexReservesConversionPriceOperate(), token0Reserves_, token1Reserves_),\n            _getDexSmartColExchangeRate(_getDexReservesConversionPriceLiquidate(), token0Reserves_, token1Reserves_)\n        );\n    }\n\n    /// @inheritdoc DexSmartDebtOracleImpl\n    function dexSmartDebtSharesRates() public view override returns (uint256 operate_, uint256 liquidate_) {\n        (uint256 token0Reserves_, uint256 token1Reserves_) = _getDexDebtReserves();\n\n        return (\n            _getDexSmartDebtExchangeRate(_getDexReservesConversionPriceOperate(), token0Reserves_, token1Reserves_),\n            _getDexSmartDebtExchangeRate(_getDexReservesConversionPriceLiquidate(), token0Reserves_, token1Reserves_)\n        );\n    }\n}\n"
    },
    "contracts/oracle/oracles/fallbackCLRSOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracle } from \"../fluidOracle.sol\";\nimport { FallbackOracleImpl } from \"../implementations/fallbackOracleImpl.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\n/// @DEV DEPRECATED. USE GENERIC ORACLE INSTEAD. WILL BE REMOVED SOON.\n\n/// @title   Chainlink / Redstone Oracle (with fallback)\n/// @notice  Gets the exchange rate between the underlying asset and the peg asset by using:\n///          the price from a Chainlink price feed or a Redstone Oracle with one of them being used as main source and\n///          the other one acting as a fallback if the main source fails for any reason. Reverts if fetched rate is 0.\ncontract FallbackCLRSOracle is FluidOracle, FallbackOracleImpl {\n    /// @notice                     sets the main source, Chainlink Oracle and Redstone Oracle data.\n    /// @param infoName_            Oracle identify helper name.\n    /// @param mainSource_          which oracle to use as main source: 1 = Chainlink, 2 = Redstone (other one is fallback).\n    /// @param chainlinkParams_     chainlink Oracle constructor params struct.\n    /// @param redstoneOracle_      Redstone Oracle data. (address can be set to zero address if using Chainlink only)\n    constructor(\n        string memory infoName_,\n        uint8 targetDecimals_,\n        uint8 mainSource_,\n        ChainlinkConstructorParams memory chainlinkParams_,\n        RedstoneOracleData memory redstoneOracle_\n    ) FallbackOracleImpl(mainSource_, chainlinkParams_, redstoneOracle_) FluidOracle(infoName_, targetDecimals_) {}\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateOperate() public view virtual override returns (uint256 exchangeRate_) {\n        (exchangeRate_, ) = _getRateWithFallback();\n\n        if (exchangeRate_ == 0) {\n            revert FluidOracleError(ErrorTypes.FallbackCLRSOracle__ExchangeRateZero);\n        }\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateLiquidate() public view virtual override returns (uint256 exchangeRate_) {\n        (exchangeRate_, ) = _getRateWithFallback();\n\n        if (exchangeRate_ == 0) {\n            revert FluidOracleError(ErrorTypes.FallbackCLRSOracle__ExchangeRateZero);\n        }\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRate() public view virtual override returns (uint256 exchangeRate_) {\n        return getExchangeRateOperate();\n    }\n\n    /// @notice which oracle to use as main source:\n    ///          - 1 = Chainlink ONLY (no fallback)\n    ///          - 2 = Chainlink with Redstone Fallback\n    ///          - 3 = Redstone with Chainlink Fallback\n    function FALLBACK_ORACLE_MAIN_SOURCE() public view returns (uint8) {\n        return _FALLBACK_ORACLE_MAIN_SOURCE;\n    }\n}\n"
    },
    "contracts/oracle/oracles/genericOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracle } from \"../fluidOracle.sol\";\nimport { FluidGenericOracleBase } from \"./genericOracleBase.sol\";\n\n/// @notice generic configurable Oracle\n/// combines up to 4 hops from sources such as\n///  - an existing IFluidOracle (e.g. ContractRate)\n///  - Redstone\n///  - Chainlink\ncontract FluidGenericOracle is FluidOracle, FluidGenericOracleBase {\n    constructor(\n        string memory infoName_,\n        uint8 targetDecimals_,\n        OracleHopSource[] memory sources_\n    ) FluidOracle(infoName_, targetDecimals_) FluidGenericOracleBase(sources_) {}\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateOperate() public view virtual override returns (uint256 exchangeRate_) {\n        exchangeRate_ = _getHopsExchangeRate(true);\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateLiquidate() public view virtual override returns (uint256 exchangeRate_) {\n        exchangeRate_ = _getHopsExchangeRate(false);\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRate() public view virtual override returns (uint256 exchangeRate_) {\n        exchangeRate_ = _getHopsExchangeRate(false);\n    }\n}\n"
    },
    "contracts/oracle/oracles/genericOracleBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error as OracleError } from \"../error.sol\";\nimport { ChainlinkSourceReader } from \"../sourceReaders/chainlinkSourceReader.sol\";\nimport { FluidSourceReader } from \"../sourceReaders/fluidSourceReader.sol\";\nimport { FluidDebtSourceReader } from \"../sourceReaders/fluidDebtSourceReader.sol\";\nimport { OracleUtils } from \"../libraries/oracleUtils.sol\";\n\nabstract contract GenericOracleStructs {\n    enum SourceType {\n        Fluid, // 0, e.g. FluidCappedRate col asset side or some other IFluidOracle\n        Redstone, // 1\n        Chainlink, // 2\n        UniV3Checked, // 3\n        FluidDebt // 4 FluidCappedRate debt asset side methods\n        // DO NOT add a rate source like ERC4626 here, any external contract source should ALWAYS be filtered through a FluidCappedRate contract\n    }\n\n    struct OracleHopSource {\n        address source;\n        bool invertRate;\n        uint256 multiplier;\n        uint256 divisor;\n        SourceType sourceType; // e.g. FLUID, REDSTONE, UNIV3CHECKED, CHAINLINK\n    }\n}\n\n/// @notice generic configurable Oracle Base\n/// combines up to 4 hops from sources such as\n///  - an existing IFluidOracle (e.g. ContractRate)\n///  - Redstone\n///  - Chainlink\nabstract contract FluidGenericOracleBase is\n    OracleError,\n    GenericOracleStructs,\n    ChainlinkSourceReader,\n    FluidSourceReader,\n    FluidDebtSourceReader\n{\n    address internal immutable _SOURCE1;\n    bool internal immutable _SOURCE1_INVERT;\n    uint256 internal immutable _SOURCE1_MULTIPLIER;\n    uint256 internal immutable _SOURCE1_DIVISOR;\n    SourceType internal immutable _SOURCE1_TYPE;\n\n    address internal immutable _SOURCE2;\n    bool internal immutable _SOURCE2_INVERT;\n    uint256 internal immutable _SOURCE2_MULTIPLIER;\n    uint256 internal immutable _SOURCE2_DIVISOR;\n    SourceType internal immutable _SOURCE2_TYPE;\n\n    address internal immutable _SOURCE3;\n    bool internal immutable _SOURCE3_INVERT;\n    uint256 internal immutable _SOURCE3_MULTIPLIER;\n    uint256 internal immutable _SOURCE3_DIVISOR;\n    SourceType internal immutable _SOURCE3_TYPE;\n\n    address internal immutable _SOURCE4;\n    bool internal immutable _SOURCE4_INVERT;\n    uint256 internal immutable _SOURCE4_MULTIPLIER;\n    uint256 internal immutable _SOURCE4_DIVISOR;\n    SourceType internal immutable _SOURCE4_TYPE;\n\n    address internal immutable _SOURCE5;\n    bool internal immutable _SOURCE5_INVERT;\n    uint256 internal immutable _SOURCE5_MULTIPLIER;\n    uint256 internal immutable _SOURCE5_DIVISOR;\n    SourceType internal immutable _SOURCE5_TYPE;\n\n    constructor(OracleHopSource[] memory sources_) {\n        if (sources_.length == 0 || sources_.length > 5) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__InvalidParams);\n        }\n\n        _verifyOracleHopSource(sources_[0]);\n        _SOURCE1 = sources_[0].source;\n        _SOURCE1_INVERT = sources_[0].invertRate;\n        _SOURCE1_MULTIPLIER = sources_[0].multiplier;\n        _SOURCE1_DIVISOR = sources_[0].divisor;\n        _SOURCE1_TYPE = sources_[0].sourceType;\n\n        if (sources_.length > 1) {\n            _verifyOracleHopSource(sources_[1]);\n            _SOURCE2 = sources_[1].source;\n            _SOURCE2_INVERT = sources_[1].invertRate;\n            _SOURCE2_MULTIPLIER = sources_[1].multiplier;\n            _SOURCE2_DIVISOR = sources_[1].divisor;\n            _SOURCE2_TYPE = sources_[1].sourceType;\n        }\n\n        if (sources_.length > 2) {\n            _verifyOracleHopSource(sources_[2]);\n            _SOURCE3 = sources_[2].source;\n            _SOURCE3_INVERT = sources_[2].invertRate;\n            _SOURCE3_MULTIPLIER = sources_[2].multiplier;\n            _SOURCE3_DIVISOR = sources_[2].divisor;\n            _SOURCE3_TYPE = sources_[2].sourceType;\n        }\n\n        if (sources_.length > 3) {\n            _verifyOracleHopSource(sources_[3]);\n            _SOURCE4 = sources_[3].source;\n            _SOURCE4_INVERT = sources_[3].invertRate;\n            _SOURCE4_MULTIPLIER = sources_[3].multiplier;\n            _SOURCE4_DIVISOR = sources_[3].divisor;\n            _SOURCE4_TYPE = sources_[3].sourceType;\n        }\n\n        if (sources_.length > 4) {\n            _verifyOracleHopSource(sources_[4]);\n            _SOURCE5 = sources_[4].source;\n            _SOURCE5_INVERT = sources_[4].invertRate;\n            _SOURCE5_MULTIPLIER = sources_[4].multiplier;\n            _SOURCE5_DIVISOR = sources_[4].divisor;\n            _SOURCE5_TYPE = sources_[4].sourceType;\n        }\n    }\n\n    /// @dev verifies a hop source config\n    function _verifyOracleHopSource(OracleHopSource memory source_) internal view virtual {\n        if (\n            address(source_.source) == address(0) ||\n            source_.sourceType == SourceType.UniV3Checked ||\n            source_.divisor == 0 ||\n            source_.multiplier == 0 ||\n            source_.divisor > 1e40 ||\n            source_.multiplier > 1e40\n        ) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__InvalidParams);\n        }\n    }\n\n    /// @dev reads the exchange rate for a hop source\n    function _readSource(\n        address source_,\n        SourceType sourceType_,\n        bool isOperate_\n    ) internal view virtual returns (uint256 rate_) {\n        if (sourceType_ == SourceType.Redstone || sourceType_ == SourceType.Chainlink) {\n            rate_ = _readChainlinkSource(source_);\n        } else if (sourceType_ == SourceType.Fluid) {\n            rate_ = _readFluidSource(source_, isOperate_);\n        } else if (sourceType_ == SourceType.FluidDebt) {\n            rate_ = _readFluidDebtSource(source_, isOperate_);\n        } else {\n            // should never happen because of config checks in constructor\n            revert FluidOracleError(ErrorTypes.GenericOracle__UnexpectedConfig);\n        }\n    }\n\n    /// @dev gets the exchange rate for a single configured hop\n    function _getExchangeRateForHop(\n        uint256 curHopsRate_,\n        bool isOperate_,\n        OracleHopSource memory source_\n    ) internal view virtual returns (uint256 rate_) {\n        rate_ = _readSource(source_.source, source_.sourceType, isOperate_);\n\n        // scale to 1e27\n        rate_ = (rate_ * source_.multiplier) / source_.divisor;\n\n        if (source_.invertRate && rate_ > 0) {\n            rate_ = (10 ** (OracleUtils.RATE_OUTPUT_DECIMALS * 2)) / uint256(rate_);\n        }\n\n        rate_ = (curHopsRate_ * rate_) / (10 ** OracleUtils.RATE_OUTPUT_DECIMALS); // combine with current hops rate\n    }\n\n    /// @dev gets the exchange rate combined for all configured hops\n    function _getHopsExchangeRate(bool isOperate_) internal view returns (uint256 rate_) {\n        rate_ = _getExchangeRateForHop(\n            (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n            isOperate_,\n            OracleHopSource(_SOURCE1, _SOURCE1_INVERT, _SOURCE1_MULTIPLIER, _SOURCE1_DIVISOR, _SOURCE1_TYPE)\n        );\n        if (rate_ == 0) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__RateZero);\n        }\n        if (address(_SOURCE2) == address(0) && _SOURCE2_TYPE != SourceType.UniV3Checked) {\n            return rate_;\n        }\n\n        // 2 hops -> return rate of hop 1 combined with hop 2\n        rate_ = _getExchangeRateForHop(\n            rate_,\n            isOperate_,\n            OracleHopSource(_SOURCE2, _SOURCE2_INVERT, _SOURCE2_MULTIPLIER, _SOURCE2_DIVISOR, _SOURCE2_TYPE)\n        );\n        if (rate_ == 0) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__RateZero);\n        }\n        if (address(_SOURCE3) == address(0) && _SOURCE3_TYPE != SourceType.UniV3Checked) {\n            return rate_;\n        }\n\n        // 3 hops -> return rate of hop 1 combined with hop 2 & hop 3\n        rate_ = _getExchangeRateForHop(\n            rate_,\n            isOperate_,\n            OracleHopSource(_SOURCE3, _SOURCE3_INVERT, _SOURCE3_MULTIPLIER, _SOURCE3_DIVISOR, _SOURCE3_TYPE)\n        );\n        if (rate_ == 0) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__RateZero);\n        }\n        if (address(_SOURCE4) == address(0) && _SOURCE4_TYPE != SourceType.UniV3Checked) {\n            return rate_;\n        }\n\n        // 4 hops -> return rate of hop 1 combined with hop 2, hop 3 & hop 4\n        rate_ = _getExchangeRateForHop(\n            rate_,\n            isOperate_,\n            OracleHopSource(_SOURCE4, _SOURCE4_INVERT, _SOURCE4_MULTIPLIER, _SOURCE4_DIVISOR, _SOURCE4_TYPE)\n        );\n        if (rate_ == 0) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__RateZero);\n        }\n        if (address(_SOURCE5) == address(0) && _SOURCE5_TYPE != SourceType.UniV3Checked) {\n            return rate_;\n        }\n\n        // 5 hops -> return rate of hop 1 combined with hop 2, hop 3, hop 4 & hop 5\n        rate_ = _getExchangeRateForHop(\n            rate_,\n            isOperate_,\n            OracleHopSource(_SOURCE5, _SOURCE5_INVERT, _SOURCE5_MULTIPLIER, _SOURCE5_DIVISOR, _SOURCE5_TYPE)\n        );\n        if (rate_ == 0) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__RateZero);\n        }\n    }\n\n    /// @notice Returns the exchange rate for each hop.\n    /// @return rateSource1Operate_ The exchange rate for hop 1 during operate.\n    /// @return rateSource1Liquidate_ The exchange rate for hop 1 during liquidate.\n    /// @return rateSource2Operate_ The exchange rate for hop 2 during operate.\n    /// @return rateSource2Liquidate_ The exchange rate for hop 2 during liquidate.\n    /// @return rateSource3Operate_ The exchange rate for hop 3 during operate.\n    /// @return rateSource3Liquidate_ The exchange rate for hop 3 during liquidate.\n    /// @return rateSource4Operate_ The exchange rate for hop 4 during operate.\n    /// @return rateSource4Liquidate_ The exchange rate for hop 4 during liquidate.\n    /// @return rateSource5Operate_ The exchange rate for hop 5 during operate.\n    /// @return rateSource5Liquidate_ The exchange rate for hop 5 during liquidate.\n    function getHopExchangeRates()\n        public\n        view\n        returns (\n            uint256 rateSource1Operate_,\n            uint256 rateSource1Liquidate_,\n            uint256 rateSource2Operate_,\n            uint256 rateSource2Liquidate_,\n            uint256 rateSource3Operate_,\n            uint256 rateSource3Liquidate_,\n            uint256 rateSource4Operate_,\n            uint256 rateSource4Liquidate_,\n            uint256 rateSource5Operate_,\n            uint256 rateSource5Liquidate_\n        )\n    {\n        rateSource1Operate_ = _getExchangeRateForHop(\n            (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n            true,\n            OracleHopSource(_SOURCE1, _SOURCE1_INVERT, _SOURCE1_MULTIPLIER, _SOURCE1_DIVISOR, _SOURCE1_TYPE)\n        );\n        rateSource1Liquidate_ = _getExchangeRateForHop(\n            (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n            false,\n            OracleHopSource(_SOURCE1, _SOURCE1_INVERT, _SOURCE1_MULTIPLIER, _SOURCE1_DIVISOR, _SOURCE1_TYPE)\n        );\n\n        if (address(_SOURCE2) != address(0) || _SOURCE2_TYPE == SourceType.UniV3Checked) {\n            rateSource2Operate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                true,\n                OracleHopSource(_SOURCE2, _SOURCE2_INVERT, _SOURCE2_MULTIPLIER, _SOURCE2_DIVISOR, _SOURCE2_TYPE)\n            );\n            rateSource2Liquidate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                false,\n                OracleHopSource(_SOURCE2, _SOURCE2_INVERT, _SOURCE2_MULTIPLIER, _SOURCE2_DIVISOR, _SOURCE2_TYPE)\n            );\n        }\n\n        if (address(_SOURCE3) != address(0) || _SOURCE3_TYPE == SourceType.UniV3Checked) {\n            rateSource3Operate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                true,\n                OracleHopSource(_SOURCE3, _SOURCE3_INVERT, _SOURCE3_MULTIPLIER, _SOURCE3_DIVISOR, _SOURCE3_TYPE)\n            );\n            rateSource3Liquidate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                false,\n                OracleHopSource(_SOURCE3, _SOURCE3_INVERT, _SOURCE3_MULTIPLIER, _SOURCE3_DIVISOR, _SOURCE3_TYPE)\n            );\n        }\n\n        if (address(_SOURCE4) != address(0) || _SOURCE4_TYPE == SourceType.UniV3Checked) {\n            rateSource4Operate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                true,\n                OracleHopSource(_SOURCE4, _SOURCE4_INVERT, _SOURCE4_MULTIPLIER, _SOURCE4_DIVISOR, _SOURCE4_TYPE)\n            );\n            rateSource4Liquidate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                false,\n                OracleHopSource(_SOURCE4, _SOURCE4_INVERT, _SOURCE4_MULTIPLIER, _SOURCE4_DIVISOR, _SOURCE4_TYPE)\n            );\n        }\n\n        if (address(_SOURCE5) != address(0) || _SOURCE5_TYPE == SourceType.UniV3Checked) {\n            rateSource5Operate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                true,\n                OracleHopSource(_SOURCE5, _SOURCE5_INVERT, _SOURCE5_MULTIPLIER, _SOURCE5_DIVISOR, _SOURCE5_TYPE)\n            );\n            rateSource5Liquidate_ = _getExchangeRateForHop(\n                (10 ** OracleUtils.RATE_OUTPUT_DECIMALS),\n                false,\n                OracleHopSource(_SOURCE5, _SOURCE5_INVERT, _SOURCE5_MULTIPLIER, _SOURCE5_DIVISOR, _SOURCE5_TYPE)\n            );\n        }\n    }\n\n    /// @notice Returns the configured OracleHopSources\n    function getOracleHopSources() public view returns (OracleHopSource[] memory sources_) {\n        sources_ = new OracleHopSource[](5);\n        sources_[0] = OracleHopSource(_SOURCE1, _SOURCE1_INVERT, _SOURCE1_MULTIPLIER, _SOURCE1_DIVISOR, _SOURCE1_TYPE);\n        sources_[1] = OracleHopSource(_SOURCE2, _SOURCE2_INVERT, _SOURCE2_MULTIPLIER, _SOURCE2_DIVISOR, _SOURCE2_TYPE);\n        sources_[2] = OracleHopSource(_SOURCE3, _SOURCE3_INVERT, _SOURCE3_MULTIPLIER, _SOURCE3_DIVISOR, _SOURCE3_TYPE);\n        sources_[3] = OracleHopSource(_SOURCE4, _SOURCE4_INVERT, _SOURCE4_MULTIPLIER, _SOURCE4_DIVISOR, _SOURCE4_TYPE);\n        sources_[4] = OracleHopSource(_SOURCE5, _SOURCE5_INVERT, _SOURCE5_MULTIPLIER, _SOURCE5_DIVISOR, _SOURCE5_TYPE);\n    }\n}\n"
    },
    "contracts/oracle/oracles/uniV3CheckCLRSOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracle } from \"../fluidOracle.sol\";\nimport { FallbackOracleImpl } from \"../implementations/fallbackOracleImpl.sol\";\nimport { UniV3OracleImpl } from \"../implementations/uniV3OracleImpl.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { OracleUtils } from \"../libraries/oracleUtils.sol\";\n\n/// @DEV DEPRECATED. USE GENERIC ORACLE INSTEAD. WILL BE REMOVED SOON.\n\n/// @title   UniswapV3 checked against Chainlink / Redstone Oracle. Either one reported as exchange rate.\n/// @notice  Gets the exchange rate between the underlying asset and the peg asset by using:\n///          the price from a UniV3 pool (compared against 3 TWAPs) and (optionally) comparing it against a Chainlink\n///          or Redstone price (one of Chainlink or Redstone being the main source and the other one the fallback source).\n///          Alternatively it can also use Chainlink / Redstone as main price and use UniV3 as check price.\n/// @dev     The process for getting the aggregate oracle price is:\n///           1. Fetch the UniV3 TWAPS, the latest interval is used as the current price\n///           2. Verify this price is within an acceptable DELTA from the Uniswap TWAPS e.g.:\n///              a. 240 to 60s\n///              b. 60 to 15s\n///              c. 15 to 1s (last block)\n///              d. 1 to 0s (current)\n///           3. (unless UniV3 only mode): Verify this price is within an acceptable DELTA from the Chainlink / Redstone Oracle\n///           4. If it passes all checks, return the price. Otherwise use fallbacks, usually to Chainlink. In extreme edge-cases revert.\n/// @dev     For UniV3 with check mode, if fetching the check price fails, the UniV3 rate is used directly.\ncontract UniV3CheckCLRSOracle is FluidOracle, UniV3OracleImpl, FallbackOracleImpl {\n    /// @dev Rate check oracle delta percent in 1e2 percent. If current uniswap price is out of this delta,\n    /// current price fetching reverts.\n    uint256 internal immutable _RATE_CHECK_MAX_DELTA_PERCENT;\n\n    /// @dev which oracle to use as final rate source:\n    ///      - 1 = UniV3 ONLY (no check),\n    ///      - 2 = UniV3 with Chainlink / Redstone check\n    ///      - 3 = Chainlink / Redstone with UniV3 used as check.\n    uint8 internal immutable _RATE_SOURCE;\n\n    struct UniV3CheckCLRSConstructorParams {\n        /// @param uniV3Params                UniV3Oracle constructor params struct.\n        UniV3ConstructorParams uniV3Params;\n        /// @param chainlinkParams            ChainlinkOracle constructor params struct for UniV3CheckCLRSOracle.\n        ChainlinkConstructorParams chainlinkParams;\n        /// @param redstoneOracle             Redstone Oracle data for UniV3CheckCLRSOracle. (address can be set to zero address if using Chainlink only)\n        RedstoneOracleData redstoneOracle;\n        /// @param rateSource                 which oracle to use as final rate source for UniV3CheckCLRSOracle:\n        ///                                         - 1 = UniV3 ONLY (no check),\n        ///                                         - 2 = UniV3 with Chainlink / Redstone check\n        ///                                         - 3 = Chainlink / Redstone with UniV3 used as check.\n        uint8 rateSource;\n        /// @param fallbackMainSource         which oracle to use as CL/RS main source for UniV3CheckCLRSOracle: see FallbackOracleImpl constructor `mainSource_`\n        uint8 fallbackMainSource;\n        /// @param rateCheckMaxDeltaPercent   Rate check oracle delta in 1e2 percent for UniV3CheckCLRSOracle\n        uint256 rateCheckMaxDeltaPercent;\n    }\n\n    constructor(\n        string memory infoName_,\n        uint8 targetDecimals_,\n        UniV3CheckCLRSConstructorParams memory params_\n    )\n        UniV3OracleImpl(params_.uniV3Params)\n        FallbackOracleImpl(params_.fallbackMainSource, params_.chainlinkParams, params_.redstoneOracle)\n        FluidOracle(infoName_, targetDecimals_)\n    {\n        if (\n            params_.rateSource < 1 ||\n            params_.rateSource > 3 ||\n            params_.rateCheckMaxDeltaPercent > OracleUtils.HUNDRED_PERCENT_DELTA_SCALER ||\n            // Chainlink only Oracle with UniV3 check. Delta would be ignored so revert this type of Oracle setup.\n            (params_.fallbackMainSource == 1 && params_.rateSource == 3)\n        ) {\n            revert FluidOracleError(ErrorTypes.UniV3CheckCLRSOracle__InvalidParams);\n        }\n\n        _RATE_CHECK_MAX_DELTA_PERCENT = params_.rateCheckMaxDeltaPercent;\n        _RATE_SOURCE = params_.rateSource;\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateOperate() public view virtual override returns (uint256 exchangeRate_) {\n        return _getExchangeRate();\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateLiquidate() public view virtual override returns (uint256 exchangeRate_) {\n        return _getExchangeRate();\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRate() public view virtual override returns (uint256 exchangeRate_) {\n        return _getExchangeRate();\n    }\n\n    /// @notice returns all oracle related data as utility for easy off-chain / block explorer use in a single view method\n    function uniV3CheckOracleData()\n        public\n        view\n        returns (uint256 rateCheckMaxDelta_, uint256 rateSource_, uint256 fallbackMainSource_)\n    {\n        return (_RATE_CHECK_MAX_DELTA_PERCENT, _RATE_SOURCE, _FALLBACK_ORACLE_MAIN_SOURCE);\n    }\n\n    function _getExchangeRate() internal view returns (uint256 exchangeRate_) {\n        if (_RATE_SOURCE == 1) {\n            // uniswap is the only main source without check:\n            // 1. get uniV3 rate.\n            // 2. If that fails (outside delta range) -> revert (no other Oracle configured).\n            exchangeRate_ = _getUniV3ExchangeRate();\n\n            if (exchangeRate_ == 0) {\n                // fetching UniV3 failed or invalid delta -> revert\n                revert FluidOracleError(ErrorTypes.UniV3CheckCLRSOracle__ExchangeRateZero);\n            }\n\n            return exchangeRate_;\n        }\n\n        uint256 checkRate_;\n        bool fallback_;\n        if (_RATE_SOURCE == 2) {\n            // uniswap is main source, with Chainlink / Redstone as check\n            // 1. get uniV3 rate\n\n            // case uniV3 rate fails (outside delta range):\n            // 2. get Chainlink rate. -> if successful, use Chainlink as result\n            // 3. if Chainlink fails too, get Redstone -> if successful, use Redstone as result\n            // 4. if Redstone fails too, revert\n\n            // case if uniV3 rate is ok\n            // 2. get Chainlink or Redstone rate for check (one is configured as main check source, other one is fallback source)\n            //    -> if both fail to fetch, use uniV3 rate directly.\n            // 3. check the delta for uniV3 rate against the check soure rate. -> if ok, return uniV3 rate\n            // 4. if delta check fails, check delta against the fallback check source. -> if ok, return uniV3 rate\n            // 5. if delta check fails for both sources, return Chainlink price\n\n            exchangeRate_ = _getUniV3ExchangeRate();\n\n            if (exchangeRate_ == 0) {\n                // uniV3 failed or invalid delta -> use (Chainlink with Redstone as fallback)\n                exchangeRate_ = _getChainlinkOrRedstoneAsFallback();\n                if (exchangeRate_ == 0) {\n                    // Chainlink / Redstone failed too -> revert\n                    revert FluidOracleError(ErrorTypes.UniV3CheckCLRSOracle__ExchangeRateZero);\n                }\n                return exchangeRate_;\n            }\n\n            (checkRate_, fallback_) = _getRateWithFallback();\n            if (checkRate_ == 0) {\n                // check price source failed to fetch -> directly use uniV3 TWAP checked price\n                // Note uniV3 price fetching was successful, would have been caught otherwise above.\n                return exchangeRate_;\n            }\n        } else {\n            // Chainlink / Redstone is main source, with uniV3 as check.\n            // 1. get Chainlink / Redstone rate (one is configured as main source, other one is fallback source)\n\n            // case when both Chainlink & Redstone fail:\n            // 2. get uniV3 rate. if successful, use uniV3 rate. otherwise, revert (all oracles failed).\n\n            // case when Chainlink / Redstone fetch is successful:\n            // 2. get uniV3 rate for check.\n            // 3. if uniV3 rate fails to fetch (outside delta), use Chainlink / Redstone directly (skip check).\n            // 4. if uniV3 rate is ok, check the delta for Chainlink / Redstone rate against uniV3 rate.\n            //    -> if ok, return Chainlink / Redstone (main) rate\n            // 5. if delta check fails, check delta against the fallback main source.\n            //    -> if ok, return fallback main rate\n            // 6. if delta check fails for both sources, return Chainlink price.\n\n            (exchangeRate_, fallback_) = _getRateWithFallback();\n            checkRate_ = _getUniV3ExchangeRate();\n\n            if (exchangeRate_ == 0) {\n                if (checkRate_ == 0) {\n                    // all oracles failed, revert\n                    revert FluidOracleError(ErrorTypes.UniV3CheckCLRSOracle__ExchangeRateZero);\n                }\n\n                // Both Chainlink & Redstone failed -> directly use uniV3 TWAP checked price\n                // Note uniV3 price fetching was successful, would have been caught otherwise above.\n                return checkRate_;\n            }\n\n            if (checkRate_ == 0) {\n                // uniV3 failed -> skip check against Uniswap price.\n\n                return exchangeRate_;\n            }\n        }\n\n        if (OracleUtils.isRateOutsideDelta(exchangeRate_, checkRate_, _RATE_CHECK_MAX_DELTA_PERCENT)) {\n            if (fallback_) {\n                // fallback already used, no other rate available to check.\n\n                // if price is chainlink price -> return it.\n                if (_FALLBACK_ORACLE_MAIN_SOURCE == 3) {\n                    // redstone with Chainlink as fallback\n                    return _RATE_SOURCE == 2 ? checkRate_ : exchangeRate_; // if rate source is 2, Chainlink rate is in checkRate_\n                }\n\n                // if price is redstone price -> revert\n                revert FluidOracleError(ErrorTypes.UniV3CheckCLRSOracle__InvalidPrice);\n            }\n\n            if (_FALLBACK_ORACLE_MAIN_SOURCE == 1) {\n                // 1 = only chainlink and UniV3 is configured and delta check failed. no fallback available.\n                if (_RATE_SOURCE == 2) {\n                    // case where uniV3 is main source with only Chainlink as check rate Oracle configured.\n                    // delta check failed -> return Chainlink price (instead of uniV3 price).\n                    return checkRate_;\n                }\n\n                // here: if (_FALLBACK_ORACLE_MAIN_SOURCE == 1 && _RATE_SOURCE == 3)\n                // rate source is 3: Chainlink as main, uniV3 as delta. delta check failed.\n                // this Oracle type would basically be a more expensive Chainlink-only Oracle because the delta check against UniV3 is ignored.\n                // this setup is reverted in constructor, but in any case returning Chainlink price here even though this code should never be reached.\n                return exchangeRate_; // exchangeRate_ here is chainlink price\n            }\n\n            // fallback not done yet -> check against fallback price.\n            // So if originally Chainlink was fetched and delta failed, check against Redstone.\n            // if originally Redstone was fetched and delta failed, check against Chainlink.\n            if (_FALLBACK_ORACLE_MAIN_SOURCE == 2) {\n                // 2 = Chainlink with Redstone Fallback. delta check against Chainlink failed. try against Redstone.\n                uint256 redstoneRate_ = _getRedstoneExchangeRate();\n                uint256 chainlinkRate_;\n                if (_RATE_SOURCE == 2) {\n                    // uniV3 main source. -> update checkRate_ with Redstone price\n                    chainlinkRate_ = checkRate_;\n                    checkRate_ = redstoneRate_;\n                } else {\n                    // uniV3 is check source. -> update exchangeRate_ with Redstone price\n                    chainlinkRate_ = exchangeRate_;\n                    exchangeRate_ = redstoneRate_;\n                }\n\n                if (redstoneRate_ == 0) {\n                    // fetching Redstone failed. So delta UniV3 <> Chainlink failed, fetching Redstone as backup failed.\n                    // -> return chainlink price (for both cases when Chainlink is main and when UniV3 is the main source).\n                    return chainlinkRate_;\n                }\n\n                if (OracleUtils.isRateOutsideDelta(exchangeRate_, checkRate_, _RATE_CHECK_MAX_DELTA_PERCENT)) {\n                    // delta check against Redstone failed too. return Chainlink price\n                    return chainlinkRate_;\n                }\n\n                // delta check against Redstone passed. if uniV3 main source -> return uniV3, else return Redstone.\n                // exchangeRate_ is already set correctly for this.\n            } else {\n                // 3 = Redstone with Chainlink Fallback. delta check against Redstone failed. try against Chainlink.\n                uint256 chainlinkRate_ = _getChainlinkExchangeRate();\n                if (chainlinkRate_ == 0) {\n                    // fetching Chainlink failed. So delta UniV3 <> Redstone failed, fetching Chainlink as backup check failed.\n                    // -> revert.\n                    revert FluidOracleError(ErrorTypes.UniV3CheckCLRSOracle__InvalidPrice);\n                }\n\n                if (_RATE_SOURCE == 3) {\n                    // uniV3 is check source. -> update exchangeRate_ with Chainlink price.\n                    // Optimization: in this case we can directly return chainlink price, because if delta check between\n                    // Chainlink (new main source) and uniV3 (check source) fails, we anyway return Chainlink price still.\n                    return chainlinkRate_;\n                }\n\n                // uniV3 main source. -> update checkRate_ with Chainlink price and compare delta again\n                checkRate_ = chainlinkRate_;\n\n                if (OracleUtils.isRateOutsideDelta(exchangeRate_, checkRate_, _RATE_CHECK_MAX_DELTA_PERCENT)) {\n                    // delta check against Chainlink failed too. case here can only be where uniV3 would have been\n                    // main source and Chainlink check source. -> return Chainlink as price instead of uniV3\n                    return checkRate_;\n                }\n\n                // delta check against Chainlink passed. if uniV3 main source -> return uniV3, else return Chainlink.\n                // exchangeRate_ is already set correctly for this.\n            }\n        }\n    }\n}\n"
    },
    "contracts/oracle/oraclesL2/dex/dexSmartColPegOracleL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracleL2 } from \"../../fluidOracleL2.sol\";\nimport { DexSmartColPegOracle } from \"../../oracles/dex/dexSmartColPegOracle.sol\";\n\n/// @title   Fluid Dex Smart Col Pegged Oracle for assets ~1=~1 on L2s\n/// @notice  Gets the exchange rate between a Fluid Dex smart collateral shares and normal debt.\n/// @dev -> Reserves from Liquidity with Peg buffer percent.\n///      -> Reserves conversion price from separately deployed FluidOracle (optional e.g. needed for wstETH-ETH).\n///      -> colDebt Price Oracle is an IFluidOracle.\ncontract DexSmartColPegOracleL2 is FluidOracleL2, DexSmartColPegOracle {\n    constructor(\n        DexSmartColPegOracle.DexSmartColPegOracleParams memory params_,\n        address sequencerUptimeFeed_\n    ) DexSmartColPegOracle(params_) FluidOracleL2(sequencerUptimeFeed_) {}\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateOperate()\n        public\n        view\n        \n        override(DexSmartColPegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateOperate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateLiquidate()\n        public\n        view\n        \n        override(DexSmartColPegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateLiquidate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRate()\n        public\n        view\n        \n        override(DexSmartColPegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        return getExchangeRateOperate();\n    }\n}\n"
    },
    "contracts/oracle/oraclesL2/dex/dexSmartDebtPegOracleL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracleL2 } from \"../../fluidOracleL2.sol\";\nimport { DexSmartDebtPegOracle } from \"../../oracles/dex/dexSmartDebtPegOracle.sol\";\n\n/// @title   Fluid Dex Smart Debt Pegged Oracle for assets ~1=~1 on L2s\n/// @notice  Gets the exchange rate between a Fluid Dex normal collateral and smart debt shares.\n/// @dev -> Reserves from Liquidity with Peg buffer percent.\n///      -> Reserves conversion price from separately deployed FluidOracle (optional e.g. needed for wstETH-ETH).\n///      -> colDebt Price Oracle is an IFluidOracle.\ncontract DexSmartDebtPegOracleL2 is FluidOracleL2, DexSmartDebtPegOracle {\n    constructor(\n        DexSmartDebtPegOracle.DexSmartDebtPegOracleParams memory params_,\n        address sequencerUptimeFeed_\n    ) DexSmartDebtPegOracle(params_) FluidOracleL2(sequencerUptimeFeed_) {}\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateOperate()\n        public\n        view\n        override(DexSmartDebtPegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateOperate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateLiquidate()\n        public\n        view\n        override(DexSmartDebtPegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateLiquidate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRate()\n        public\n        view\n        override(DexSmartDebtPegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        return getExchangeRateOperate();\n    }\n}\n"
    },
    "contracts/oracle/oraclesL2/dex/dexSmartT4CLOracleL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracleL2 } from \"../../fluidOracleL2.sol\";\nimport { DexSmartT4CLOracle } from \"../../oracles/dex/dexSmartT4CLOracle.sol\";\n\n/// @title   Fluid Dex Smart Col Debt VaultT4 Oracle on L2s\n/// @notice  Gets the exchange rate between a Fluid Dex smart collateral and smart debt for a T4 vault.\n///          returns amount of debt shares per 1 col share.\n/// @dev -> Reserves from Liquidity, adjusted for conversion price.\n///      -> Reserves conversion price from Chainlink feeds.\ncontract DexSmartT4CLOracleL2 is FluidOracleL2, DexSmartT4CLOracle {\n    constructor(\n        DexSmartT4CLOracle.DexSmartT4CLOracleParams memory params_,\n        address sequencerUptimeFeed_\n    ) DexSmartT4CLOracle(params_) FluidOracleL2(sequencerUptimeFeed_) {}\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateOperate()\n        public\n        view\n        override(DexSmartT4CLOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateOperate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateLiquidate()\n        public\n        view\n        override(DexSmartT4CLOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateLiquidate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRate() public view override(DexSmartT4CLOracle, FluidOracleL2) returns (uint256 exchangeRate_) {\n        return getExchangeRateOperate();\n    }\n}\n"
    },
    "contracts/oracle/oraclesL2/dex/dexSmartT4PegOracleL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracleL2 } from \"../../fluidOracleL2.sol\";\nimport { DexSmartT4PegOracle } from \"../../oracles/dex/dexSmartT4PegOracle.sol\";\n\n/// @title   Fluid Dex Smart Col Debt Pegged Oracle for assets ~1=~1 on L2s\n/// @notice  Gets the exchange rate between a Fluid Dex smart collateral shares and smart debt shares.\n/// @dev -> Reserves from Liquidity with Peg buffer percent.\n///      -> Reserves conversion price from separately deployed FluidOracle (optional e.g. needed for wstETH-ETH).\ncontract DexSmartT4PegOracleL2 is FluidOracleL2, DexSmartT4PegOracle {\n    constructor(\n        DexSmartT4PegOracle.DexSmartT4PegOracleParams memory params_,\n        address sequencerUptimeFeed_\n    ) DexSmartT4PegOracle(params_) FluidOracleL2(sequencerUptimeFeed_) {}\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateOperate()\n        public\n        view\n        override(DexSmartT4PegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateOperate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateLiquidate()\n        public\n        view\n        override(DexSmartT4PegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateLiquidate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRate()\n        public\n        view\n        override(DexSmartT4PegOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        return getExchangeRateOperate();\n    }\n}\n"
    },
    "contracts/oracle/oraclesL2/fallbackCLRSOracleL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracleL2 } from \"../fluidOracleL2.sol\";\nimport { FallbackCLRSOracle } from \"../oracles/fallbackCLRSOracle.sol\";\n\n/// @DEV DEPRECATED. USE GENERIC ORACLE INSTEAD. WILL BE REMOVED SOON.\n\n/// @title   Chainlink / Redstone Oracle (with fallback) for Layer 2 (with sequencer outage detection)\n/// @notice  Gets the exchange rate between the underlying asset and the peg asset by using:\n///          the price from a Chainlink price feed or a Redstone Oracle with one of them being used as main source and\n///          the other one acting as a fallback if the main source fails for any reason. Reverts if fetched rate is 0.\ncontract FallbackCLRSOracleL2 is FluidOracleL2, FallbackCLRSOracle {\n    struct CLRSConstructorParams {\n        /// @param mainSource                     which oracle to use as main source for wstETH <> CLRS: 1 = Chainlink, 2 = Redstone (other one is fallback).\n        uint8 mainSource;\n        /// @param chainlinkParams                chainlink Oracle constructor params struct for wstETH <> CLRS.\n        ChainlinkConstructorParams chainlinkParams;\n        /// @param redstoneOracle                 Redstone Oracle data for wstETH <> CLRS. (address can be set to zero address if using Chainlink only)\n        RedstoneOracleData redstoneOracle;\n    }\n\n    /// @notice                       sets the main source, Chainlink Oracle and Redstone Oracle data.\n    /// @param infoName_              Oracle identify helper name.\n    /// @param cLRSParams_            CLRS Fallback Oracle data\n    /// @param sequencerUptimeFeed_   L2 sequencer uptime Chainlink feed\n    constructor(\n        string memory infoName_,\n        uint8 targetDecimals_,\n        CLRSConstructorParams memory cLRSParams_,\n        address sequencerUptimeFeed_\n    )\n        FallbackCLRSOracle(\n            infoName_,\n            targetDecimals_,\n            cLRSParams_.mainSource,\n            cLRSParams_.chainlinkParams,\n            cLRSParams_.redstoneOracle\n        )\n        FluidOracleL2(sequencerUptimeFeed_)\n    {}\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateOperate()\n        public\n        view\n        virtual\n        override(FallbackCLRSOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateOperate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateLiquidate()\n        public\n        view\n        virtual\n        override(FallbackCLRSOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateLiquidate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRate()\n        public\n        view\n        virtual\n        override(FallbackCLRSOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        return getExchangeRateOperate();\n    }\n}\n"
    },
    "contracts/oracle/oraclesL2/genericOracleL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracleL2 } from \"../fluidOracleL2.sol\";\nimport { FluidGenericOracle } from \"../oracles/genericOracle.sol\";\n\n/// @notice generic configurable Oracle for Layer 2 (with sequencer outage detection)\n/// combines up to 4 hops from sources such as\n///  - an existing IFluidOracle (e.g. ContractRate)\n///  - Redstone\n///  - Chainlink\ncontract FluidGenericOracleL2 is FluidOracleL2, FluidGenericOracle {\n    constructor(\n        string memory infoName_,\n        uint8 targetDecimals_,\n        OracleHopSource[] memory sources_,\n        address sequencerUptimeFeed_\n    ) FluidGenericOracle(infoName_, targetDecimals_, sources_) FluidOracleL2(sequencerUptimeFeed_) {}\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateOperate()\n        public\n        view\n        override(FluidGenericOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateOperate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateLiquidate()\n        public\n        view\n        override(FluidGenericOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateLiquidate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRate() public view override(FluidGenericOracle, FluidOracleL2) returns (uint256 exchangeRate_) {\n        return getExchangeRateOperate();\n    }\n}\n"
    },
    "contracts/oracle/oraclesL2/uniV3CheckCLRSOracleL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidOracleL2 } from \"../fluidOracleL2.sol\";\nimport { UniV3CheckCLRSOracle } from \"../oracles/uniV3CheckCLRSOracle.sol\";\n\n/// @DEV DEPRECATED. USE GENERIC ORACLE INSTEAD. WILL BE REMOVED SOON.\n\n/// @title   UniswapV3 checked against Chainlink / Redstone Oracle for Layer 2 (with sequencer outage detection). Either one reported as exchange rate.\n/// @notice  Gets the exchange rate between the underlying asset and the peg asset by using:\n///          the price from a UniV3 pool (compared against 3 TWAPs) and (optionally) comparing it against a Chainlink\n///          or Redstone price (one of Chainlink or Redstone being the main source and the other one the fallback source).\n///          Alternatively it can also use Chainlink / Redstone as main price and use UniV3 as check price.\n/// @dev     The process for getting the aggregate oracle price is:\n///           1. Fetch the UniV3 TWAPS, the latest interval is used as the current price\n///           2. Verify this price is within an acceptable DELTA from the Uniswap TWAPS e.g.:\n///              a. 240 to 60s\n///              b. 60 to 15s\n///              c. 15 to 1s (last block)\n///              d. 1 to 0s (current)\n///           3. (unless UniV3 only mode): Verify this price is within an acceptable DELTA from the Chainlink / Redstone Oracle\n///           4. If it passes all checks, return the price. Otherwise use fallbacks, usually to Chainlink. In extreme edge-cases revert.\n/// @dev     For UniV3 with check mode, if fetching the check price fails, the UniV3 rate is used directly.\ncontract UniV3CheckCLRSOracleL2 is FluidOracleL2, UniV3CheckCLRSOracle {\n    constructor(\n        string memory infoName_,\n        uint8 targetDecimals_,\n        UniV3CheckCLRSConstructorParams memory params_,\n        address sequencerUptimeFeed_\n    ) UniV3CheckCLRSOracle(infoName_, targetDecimals_, params_) FluidOracleL2(sequencerUptimeFeed_) {}\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateOperate()\n        public\n        view\n        virtual\n        override(UniV3CheckCLRSOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateOperate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRateLiquidate()\n        public\n        view\n        virtual\n        override(UniV3CheckCLRSOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        _ensureSequencerUpAndValid();\n        return super.getExchangeRateLiquidate();\n    }\n\n    /// @inheritdoc FluidOracleL2\n    function getExchangeRate()\n        public\n        view\n        virtual\n        override(UniV3CheckCLRSOracle, FluidOracleL2)\n        returns (uint256 exchangeRate_)\n    {\n        return getExchangeRateOperate();\n    }\n}\n"
    },
    "contracts/oracle/sourceReaders/chainlinkSourceReader.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IChainlinkAggregatorV3 } from \"../interfaces/external/IChainlinkAggregatorV3.sol\";\n\nabstract contract ChainlinkSourceReader {\n    function _readChainlinkSource(address feed_) internal view returns (uint256 rate_) {\n        try IChainlinkAggregatorV3(feed_).latestRoundData() returns (\n            uint80,\n            int256 exchangeRate_,\n            uint256,\n            uint256,\n            uint80\n        ) {\n            // Return the price in `OracleUtils.RATE_OUTPUT_DECIMALS`\n            return uint256(exchangeRate_);\n        } catch {}\n    }\n}\n"
    },
    "contracts/oracle/sourceReaders/fluidDebtSourceReader.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidCappedRate } from \"../interfaces/iFluidCappedRate.sol\";\n\nabstract contract FluidDebtSourceReader {\n    function _readFluidDebtSource(address oracle_, bool isOperate_) internal view returns (uint256 rate_) {\n        if (isOperate_) {\n            try IFluidCappedRate(oracle_).getExchangeRateOperateDebt() returns (uint256 exchangeRate_) {\n                return exchangeRate_;\n            } catch {}\n        } else {\n            try IFluidCappedRate(oracle_).getExchangeRateLiquidateDebt() returns (uint256 exchangeRate_) {\n                return exchangeRate_;\n            } catch {}\n        }\n    }\n}\n"
    },
    "contracts/oracle/sourceReaders/fluidSourceReader.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"../interfaces/iFluidOracle.sol\";\n\nabstract contract FluidSourceReader {\n    function _readFluidSource(address oracle_, bool isOperate_) internal view returns (uint256 rate_) {\n        if (isOperate_) {\n            try IFluidOracle(oracle_).getExchangeRateOperate() returns (uint256 exchangeRate_) {\n                return exchangeRate_;\n            } catch {}\n        } else {\n            try IFluidOracle(oracle_).getExchangeRateLiquidate() returns (uint256 exchangeRate_) {\n                return exchangeRate_;\n            } catch {}\n        }\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dex/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { DexSlotsLink } from \"../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\nimport { BytesSliceAndConcat } from \"../../../libraries/bytesSliceAndConcat.sol\";\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { Structs as FluidLiquidityResolverStructs } from \"../liquidity/structs.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { Variables } from \"./variables.sol\";\n\n/// @title DexFactoryViews\n/// @notice Abstract contract providing view functions for DEX factory-related operations\nabstract contract DexFactoryViews is Variables {\n    /// @notice Get the address of a DEX given its ID\n    /// @param dexId_ The ID of the DEX\n    /// @return dex_ The address of the DEX\n    function getDexAddress(uint256 dexId_) public view returns (address dex_) {\n        return AddressCalcs.addressCalc(address(FACTORY), dexId_);\n    }\n\n    /// @notice Get the ID of a DEX given its address\n    /// @param dex_ The address of the DEX\n    /// @return id_ The ID of the DEX\n    function getDexId(address dex_) public view returns (uint id_) {\n        id_ = IFluidDexT1(dex_).DEX_ID();\n    }\n\n    /// @notice Get the total number of DEXes\n    /// @return The total number of DEXes\n    function getTotalDexes() public view returns (uint) {\n        return FACTORY.totalDexes();\n    }\n\n    /// @notice Get an array of all DEX addresses\n    /// @return dexes_ An array containing all DEX addresses\n    function getAllDexAddresses() public view returns (address[] memory dexes_) {\n        uint totalDexes_ = getTotalDexes();\n        dexes_ = new address[](totalDexes_);\n        for (uint i = 0; i < totalDexes_; i++) {\n            dexes_[i] = getDexAddress((i + 1));\n        }\n    }\n}\n\n/// @title DexStorageVars\n/// @notice Abstract contract providing view functions for DEX storage variables\nabstract contract DexStorageVars is Variables {\n    /// @notice Get the raw DEX variables\n    /// @param dex_ The address of the DEX\n    /// @return The raw DEX variables\n    function getDexVariablesRaw(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES_SLOT));\n    }\n\n    /// @notice Get the raw DEX variables2\n    /// @param dex_ The address of the DEX\n    /// @return The raw DEX variables2\n    function getDexVariables2Raw(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n    }\n\n    /// @notice Get the total supply shares slot data of a DEX\n    /// @param dex_ The address of the DEX\n    /// @return The total supply shares\n    function getTotalSupplySharesRaw(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_TOTAL_SUPPLY_SHARES_SLOT));\n    }\n\n    /// @notice Get the raw user supply data for a specific user and DEX\n    /// @param dex_ The address of the DEX\n    /// @param user_ The address of the user\n    /// @return The raw user supply data\n    function getUserSupplyDataRaw(address dex_, address user_) public view returns (uint) {\n        return\n            IFluidDexT1(dex_).readFromStorage(\n                DexSlotsLink.calculateMappingStorageSlot(DexSlotsLink.DEX_USER_SUPPLY_MAPPING_SLOT, user_)\n            );\n    }\n\n    /// @notice Get the total borrow shares slot data of a DEX\n    /// @param dex_ The address of the DEX\n    /// @return The total borrow shares\n    function getTotalBorrowSharesRaw(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_TOTAL_BORROW_SHARES_SLOT));\n    }\n\n    /// @notice Get the raw user borrow data for a specific user and DEX\n    /// @param dex_ The address of the DEX\n    /// @param user_ The address of the user\n    /// @return The raw user borrow data\n    function getUserBorrowDataRaw(address dex_, address user_) public view returns (uint) {\n        return\n            IFluidDexT1(dex_).readFromStorage(\n                DexSlotsLink.calculateMappingStorageSlot(DexSlotsLink.DEX_USER_BORROW_MAPPING_SLOT, user_)\n            );\n    }\n\n    /// @notice Get the raw oracle data for a specific DEX and index\n    /// @param dex_ The address of the DEX\n    /// @param index_ The index of the oracle data\n    /// @return The raw oracle data\n    function getOracleRaw(address dex_, uint index_) public view returns (uint) {\n        return\n            IFluidDexT1(dex_).readFromStorage(\n                _calculateStorageSlotUintMapping(DexSlotsLink.DEX_ORACLE_MAPPING_SLOT, index_)\n            );\n    }\n\n    /// @notice Get the raw range shift for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return The raw range shift\n    function getRangeShiftRaw(address dex_) public view returns (uint) {\n        return\n            IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_RANGE_THRESHOLD_SHIFTS_SLOT)) &\n            type(uint128).max;\n    }\n\n    /// @notice Get the raw threshold shift for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return The raw threshold shift\n    function getThresholdShiftRaw(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_RANGE_THRESHOLD_SHIFTS_SLOT)) >> 128;\n    }\n\n    /// @notice Get the raw center price shift for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return The raw center price shift\n    function getCenterPriceShiftRaw(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_CENTER_PRICE_SHIFT_SLOT));\n    }\n\n    /// @dev Calculate the storage slot for a uint mapping\n    /// @param slot_ The base slot of the mapping\n    /// @param key_ The key of the mapping\n    /// @return The calculated storage slot\n    function _calculateStorageSlotUintMapping(uint256 slot_, uint key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n}\n\nabstract contract DexActionEstimates {\n    address private constant ADDRESS_DEAD = 0x000000000000000000000000000000000000dEaD;\n\n    /// @notice estimates swap IN tokens execution\n    /// @param dex_ Dex pool\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function estimateSwapIn(\n        address dex_,\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_\n    ) public payable returns (uint256 amountOut_) {\n        try IFluidDexT1(dex_).swapIn{ value: msg.value }(swap0to1_, amountIn_, amountOutMin_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (amountOut_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSwapResult.selector);\n        }\n    }\n\n    /// @notice estimates swap OUT tokens execution\n    /// @param dex_ Dex pool\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function estimateSwapOut(\n        address dex_,\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_\n    ) public payable returns (uint256 amountIn_) {\n        try IFluidDexT1(dex_).swapOut{ value: msg.value }(swap0to1_, amountOut_, amountInMax_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (amountIn_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSwapResult.selector);\n        }\n    }\n\n    /// @dev Estimate deposit tokens in equal proportion to the current pool ratio\n    /// @param dex_ The address of the DEX contract\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @return token0Amt_ Estimated amount of token0 to deposit\n    /// @return token1Amt_ Estimated amount of token1 to deposit\n    function estimateDepositPerfect(\n        address dex_,\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_\n    ) public payable returns (uint token0Amt_, uint token1Amt_) {\n        try\n            IFluidDexT1(dex_).depositPerfect{ value: msg.value }(shares_, maxToken0Deposit_, maxToken1Deposit_, true)\n        {} catch (bytes memory lowLevelData_) {\n            (token0Amt_, token1Amt_) = _decodeLowLevelUint2x(\n                lowLevelData_,\n                IFluidDexT1.FluidDexPerfectLiquidityOutput.selector\n            );\n        }\n    }\n\n    /// @dev Estimate withdrawal of a perfect amount of collateral liquidity\n    /// @param dex_ The address of the DEX contract\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @return token0Amt_ Estimated amount of token0 to be withdrawn\n    /// @return token1Amt_ Estimated amount of token1 to be withdrawn\n    function estimateWithdrawPerfect(\n        address dex_,\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_\n    ) public returns (uint token0Amt_, uint token1Amt_) {\n        try IFluidDexT1(dex_).withdrawPerfect(shares_, minToken0Withdraw_, minToken1Withdraw_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (token0Amt_, token1Amt_) = _decodeLowLevelUint2x(\n                lowLevelData_,\n                IFluidDexT1.FluidDexPerfectLiquidityOutput.selector\n            );\n        }\n    }\n\n    /// @dev Estimate borrowing tokens in equal proportion to the current debt pool ratio\n    /// @param dex_ The address of the DEX contract\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @return token0Amt_ Estimated amount of token0 to be borrowed\n    /// @return token1Amt_ Estimated amount of token1 to be borrowed\n    function estimateBorrowPerfect(\n        address dex_,\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_\n    ) public returns (uint token0Amt_, uint token1Amt_) {\n        try IFluidDexT1(dex_).borrowPerfect(shares_, minToken0Borrow_, minToken1Borrow_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (token0Amt_, token1Amt_) = _decodeLowLevelUint2x(\n                lowLevelData_,\n                IFluidDexT1.FluidDexPerfectLiquidityOutput.selector\n            );\n        }\n    }\n\n    /// @dev Estimate paying back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param dex_ The address of the DEX contract\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @return token0Amt_ Estimated amount of token0 to be paid back\n    /// @return token1Amt_ Estimated amount of token1 to be paid back\n    function estimatePaybackPerfect(\n        address dex_,\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_\n    ) public payable returns (uint token0Amt_, uint token1Amt_) {\n        try\n            IFluidDexT1(dex_).paybackPerfect{ value: msg.value }(shares_, maxToken0Payback_, maxToken1Payback_, true)\n        {} catch (bytes memory lowLevelData_) {\n            (token0Amt_, token1Amt_) = _decodeLowLevelUint2x(\n                lowLevelData_,\n                IFluidDexT1.FluidDexPerfectLiquidityOutput.selector\n            );\n        }\n    }\n\n    /// @dev Estimate deposit of tokens\n    /// @param dex_ The address of the DEX contract\n    /// @param token0Amt_ Amount of token0 to deposit\n    /// @param token1Amt_ Amount of token1 to deposit\n    /// @param minSharesAmt_ Minimum amount of shares to receive\n    /// @return shares_ Estimated amount of shares to be minted\n    function estimateDeposit(\n        address dex_,\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_\n    ) public payable returns (uint shares_) {\n        try IFluidDexT1(dex_).deposit{ value: msg.value }(token0Amt_, token1Amt_, minSharesAmt_, true) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (shares_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexLiquidityOutput.selector);\n        }\n    }\n\n    /// @dev Estimate withdrawal of tokens\n    /// @param dex_ The address of the DEX contract\n    /// @param token0Amt_ Amount of token0 to withdraw\n    /// @param token1Amt_ Amount of token1 to withdraw\n    /// @param maxSharesAmt_ Maximum amount of shares to burn\n    /// @return shares_ Estimated amount of shares to be burned\n    function estimateWithdraw(\n        address dex_,\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_\n    ) public returns (uint shares_) {\n        try IFluidDexT1(dex_).withdraw(token0Amt_, token1Amt_, maxSharesAmt_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (shares_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexLiquidityOutput.selector);\n        }\n    }\n\n    /// @dev Estimate borrowing of tokens\n    /// @param dex_ The address of the DEX contract\n    /// @param token0Amt_ Amount of token0 to borrow\n    /// @param token1Amt_ Amount of token1 to borrow\n    /// @param maxSharesAmt_ Maximum amount of shares to mint\n    /// @return shares_ Estimated amount of shares to be minted\n    function estimateBorrow(\n        address dex_,\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_\n    ) public returns (uint shares_) {\n        try IFluidDexT1(dex_).borrow(token0Amt_, token1Amt_, maxSharesAmt_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (shares_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexLiquidityOutput.selector);\n        }\n    }\n\n    /// @dev Estimate paying back of borrowed tokens\n    /// @param dex_ The address of the DEX contract\n    /// @param token0Amt_ Amount of token0 to pay back\n    /// @param token1Amt_ Amount of token1 to pay back\n    /// @param minSharesAmt_ Minimum amount of shares to burn\n    /// @return shares_ Estimated amount of shares to be burned\n    function estimatePayback(\n        address dex_,\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_\n    ) public payable returns (uint shares_) {\n        try IFluidDexT1(dex_).payback{ value: msg.value }(token0Amt_, token1Amt_, minSharesAmt_, true) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (shares_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexLiquidityOutput.selector);\n        }\n    }\n\n    /// @dev Estimate withdrawal of a perfect amount of collateral liquidity in one token\n    /// @param dex_ The address of the DEX contract\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1_ The minimum amount of token1 the user is willing to accept\n    /// @return withdrawAmt_ Estimated amount of tokens to be withdrawn\n    function estimateWithdrawPerfectInOneToken(\n        address dex_,\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_\n    ) public returns (uint withdrawAmt_) {\n        try IFluidDexT1(dex_).withdrawPerfectInOneToken(shares_, minToken0_, minToken1_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (withdrawAmt_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexLiquidityOutput.selector);\n        }\n    }\n\n    /// @dev Estimate paying back of a perfect amount of borrowed tokens in one token\n    /// @param dex_ The address of the DEX contract\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0_ Maximum amount of token0 to pay back\n    /// @param maxToken1_ Maximum amount of token1 to pay back\n    /// @return paybackAmt_ Estimated amount of tokens to be paid back\n    function estimatePaybackPerfectInOneToken(\n        address dex_,\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_\n    ) public payable returns (uint paybackAmt_) {\n        try\n            IFluidDexT1(dex_).paybackPerfectInOneToken{ value: msg.value }(shares_, maxToken0_, maxToken1_, true)\n        {} catch (bytes memory lowLevelData_) {\n            (paybackAmt_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSingleTokenOutput.selector);\n        }\n    }\n\n    function _decodeLowLevelUint2x(\n        bytes memory lowLevelData_,\n        bytes4 targetErrorSelector_\n    ) internal pure returns (uint value1_, uint value2_) {\n        if (lowLevelData_.length < 68) {\n            return (0, 0);\n        }\n\n        bytes4 errorSelector_;\n        assembly {\n            // Extract the selector from the error data\n            errorSelector_ := mload(add(lowLevelData_, 0x20))\n        }\n        if (errorSelector_ == targetErrorSelector_) {\n            assembly {\n                value1_ := mload(add(lowLevelData_, 36))\n                value2_ := mload(add(lowLevelData_, 68))\n            }\n        }\n        // else => values remain 0\n    }\n\n    function _decodeLowLevelUint1x(\n        bytes memory lowLevelData_,\n        bytes4 targetErrorSelector_\n    ) internal pure returns (uint value1_) {\n        if (lowLevelData_.length < 36) {\n            return 0;\n        }\n\n        bytes4 errorSelector_;\n        assembly {\n            // Extract the selector from the error data\n            errorSelector_ := mload(add(lowLevelData_, 0x20))\n        }\n        if (errorSelector_ == targetErrorSelector_) {\n            assembly {\n                value1_ := mload(add(lowLevelData_, 36))\n            }\n        }\n        // else => values remain 0\n    }\n}\n\nabstract contract DexConstantsViews {\n    /// @notice returns all Dex constants\n    function getDexConstantsView(address dex_) public view returns (IFluidDexT1.ConstantViews memory constantsView_) {\n        return IFluidDexT1(dex_).constantsView();\n    }\n\n    /// @notice returns all Dex constants 2\n    function getDexConstantsView2(\n        address dex_\n    ) public view returns (IFluidDexT1.ConstantViews2 memory constantsView2_) {\n        return IFluidDexT1(dex_).constantsView2();\n    }\n\n    /// @notice Get the addresses of the tokens in a DEX\n    /// @param dex_ The address of the DEX\n    /// @return token0_ The address of token0 in the DEX\n    /// @return token1_ The address of token1 in the DEX\n    function getDexTokens(address dex_) public view returns (address token0_, address token1_) {\n        IFluidDexT1.ConstantViews memory constantsView_ = IFluidDexT1(dex_).constantsView();\n        return (constantsView_.token0, constantsView_.token1);\n    }\n}\n\nabstract contract DexPublicViews is DexStorageVars, DexConstantsViews {\n    /// @notice Get the prices and exchange prices for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return pex_ A struct containing prices and exchange prices\n    /// @dev expected to be called via callStatic\n    function getDexPricesAndExchangePrices(\n        address dex_\n    ) public returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n        try IFluidDexT1(dex_).getPricesAndExchangePrices() {} catch (bytes memory lowLevelData_) {\n            bytes4 errorSelector_;\n            assembly {\n                // Extract the selector from the error data\n                errorSelector_ := mload(add(lowLevelData_, 0x20))\n            }\n            if (errorSelector_ == IFluidDexT1.FluidDexPricesAndExchangeRates.selector) {\n                pex_ = abi.decode(\n                    BytesSliceAndConcat.bytesSlice(lowLevelData_, 4, lowLevelData_.length - 4),\n                    (IFluidDexT1.PricesAndExchangePrice)\n                );\n            }\n        }\n    }\n\n    /// @notice Get the collateral reserves for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing collateral reserve information\n    /// @dev expected to be called via callStatic\n    function getDexCollateralReserves(address dex_) public returns (IFluidDexT1.CollateralReserves memory reserves_) {\n        return _getDexCollateralReserves(dex_, getDexConstantsView2(dex_));\n    }\n\n    /// @notice Get the debt reserves for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing debt reserve information\n    /// @dev expected to be called via callStatic\n    function getDexDebtReserves(address dex_) public returns (IFluidDexT1.DebtReserves memory reserves_) {\n        return _getDexDebtReserves(dex_, getDexConstantsView2(dex_));\n    }\n\n    /// @notice get Dex oracle price TWAP data\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function getDexOraclePrice(\n        address dex_,\n        uint[] memory secondsAgos_\n    ) external view returns (IFluidDexT1.Oracle[] memory twaps_, uint currentPrice_) {\n        return IFluidDexT1(dex_).oraclePrice(secondsAgos_);\n    }\n\n    /// @dev Get the collateral reserves for a DEX scaled to token decimals\n    function _getDexCollateralReserves(\n        address dex_,\n        IFluidDexT1.ConstantViews2 memory constantsView2_\n    ) internal returns (IFluidDexT1.CollateralReserves memory reserves_) {\n        uint256 dexVariables2_ = getDexVariables2Raw(dex_);\n        if ((dexVariables2_ & 1) != 1) {\n            // smart col not enabled\n            return IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            try\n                IFluidDexT1(dex_).getCollateralReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.supplyToken0ExchangePrice,\n                    pex_.supplyToken1ExchangePrice\n                )\n            returns (IFluidDexT1.CollateralReserves memory colReserves_) {\n                // returned reserves are in 1e12 decimals -> normalize to token decimals\n                reserves_.token0RealReserves =\n                    (colReserves_.token0RealReserves * constantsView2_.token0DenominatorPrecision) /\n                    constantsView2_.token0NumeratorPrecision;\n                reserves_.token0ImaginaryReserves =\n                    (colReserves_.token0ImaginaryReserves * constantsView2_.token0DenominatorPrecision) /\n                    constantsView2_.token0NumeratorPrecision;\n                reserves_.token1RealReserves =\n                    (colReserves_.token1RealReserves * constantsView2_.token1DenominatorPrecision) /\n                    constantsView2_.token1NumeratorPrecision;\n                reserves_.token1ImaginaryReserves =\n                    (colReserves_.token1ImaginaryReserves * constantsView2_.token1DenominatorPrecision) /\n                    constantsView2_.token1NumeratorPrecision;\n            } catch {\n                reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n            }\n        } catch {\n            reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n    }\n\n    /// @dev Get the debt reserves for a DEX scaled to token decimals\n    function _getDexDebtReserves(\n        address dex_,\n        IFluidDexT1.ConstantViews2 memory constantsView2_\n    ) internal returns (IFluidDexT1.DebtReserves memory reserves_) {\n        uint256 dexVariables2_ = getDexVariables2Raw(dex_);\n        if ((dexVariables2_ & 2) != 2) {\n            // smart debt not enabled\n            return IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            try\n                IFluidDexT1(dex_).getDebtReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.borrowToken0ExchangePrice,\n                    pex_.borrowToken1ExchangePrice\n                )\n            returns (IFluidDexT1.DebtReserves memory debtReserves_) {\n                // returned reserves are in 1e12 decimals -> normalize to token decimals\n                reserves_.token0Debt =\n                    (debtReserves_.token0Debt * constantsView2_.token0DenominatorPrecision) /\n                    constantsView2_.token0NumeratorPrecision;\n                reserves_.token0RealReserves =\n                    (debtReserves_.token0RealReserves * constantsView2_.token0DenominatorPrecision) /\n                    constantsView2_.token0NumeratorPrecision;\n                reserves_.token0ImaginaryReserves =\n                    (debtReserves_.token0ImaginaryReserves * constantsView2_.token0DenominatorPrecision) /\n                    constantsView2_.token0NumeratorPrecision;\n                reserves_.token1Debt =\n                    (debtReserves_.token1Debt * constantsView2_.token1DenominatorPrecision) /\n                    constantsView2_.token1NumeratorPrecision;\n                reserves_.token1RealReserves =\n                    (debtReserves_.token1RealReserves * constantsView2_.token1DenominatorPrecision) /\n                    constantsView2_.token1NumeratorPrecision;\n                reserves_.token1ImaginaryReserves =\n                    (debtReserves_.token1ImaginaryReserves * constantsView2_.token1DenominatorPrecision) /\n                    constantsView2_.token1NumeratorPrecision;\n            } catch {\n                reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n            }\n        } catch {\n            reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n    }\n}\n\nabstract contract DexUserViews is Variables, Structs, DexConstantsViews, DexPublicViews {\n    /// @notice Get user supply data for a specific DEX and user\n    /// @param dex_ The address of the DEX\n    /// @param user_ The address of the user\n    /// @return userSupplyData_ Struct containing user supply data\n    function getUserSupplyData(\n        address dex_,\n        address user_\n    ) public view returns (UserSupplyData memory userSupplyData_) {\n        uint256 userSupply_ = getUserSupplyDataRaw(dex_, user_);\n\n        if (userSupply_ > 0) {\n            // if userSupply_ == 0 -> user not configured yet\n            userSupplyData_.isAllowed = userSupply_ & 1 == 1;\n            userSupplyData_.supply = BigMathMinified.fromBigNumber(\n                (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & DexCalcs.X64,\n                DexCalcs.DEFAULT_EXPONENT_SIZE,\n                DexCalcs.DEFAULT_EXPONENT_MASK\n            );\n\n            // get updated expanded withdrawal limit\n            userSupplyData_.withdrawalLimit = DexCalcs.calcWithdrawalLimitBeforeOperate(\n                userSupply_,\n                userSupplyData_.supply\n            );\n\n            userSupplyData_.lastUpdateTimestamp =\n                (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) &\n                DexCalcs.X33;\n            userSupplyData_.expandPercent =\n                (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) &\n                DexCalcs.X14;\n            userSupplyData_.expandDuration =\n                (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) &\n                DexCalcs.X24;\n            userSupplyData_.baseWithdrawalLimit = BigMathMinified.fromBigNumber(\n                (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & DexCalcs.X18,\n                DexCalcs.DEFAULT_EXPONENT_SIZE,\n                DexCalcs.DEFAULT_EXPONENT_MASK\n            );\n\n            userSupplyData_.withdrawableUntilLimit = userSupplyData_.supply > userSupplyData_.withdrawalLimit\n                ? userSupplyData_.supply - userSupplyData_.withdrawalLimit\n                : 0;\n\n            userSupplyData_.withdrawable = userSupplyData_.withdrawableUntilLimit;\n\n            (address token0_, address token1_) = getDexTokens(dex_);\n            (userSupplyData_.liquidityUserSupplyDataToken0, userSupplyData_.liquidityTokenData0) = LIQUIDITY_RESOLVER\n                .getUserSupplyData(dex_, token0_);\n            (userSupplyData_.liquidityUserSupplyDataToken1, userSupplyData_.liquidityTokenData1) = LIQUIDITY_RESOLVER\n                .getUserSupplyData(dex_, token1_);\n        }\n    }\n\n    /// @notice Get user supply data for multiple users in a specific DEX\n    /// @param dex_ The address of the DEX\n    /// @param users_ Array of user addresses\n    /// @return userSuppliesData_ Array of UserSupplyData structs for each user\n    function getUserSupplyDatas(\n        address dex_,\n        address[] calldata users_\n    ) public view returns (UserSupplyData[] memory userSuppliesData_) {\n        uint256 length_ = users_.length;\n        userSuppliesData_ = new UserSupplyData[](length_);\n\n        for (uint256 i; i < length_; i++) {\n            (userSuppliesData_[i]) = getUserSupplyData(dex_, users_[i]);\n        }\n    }\n\n    /// @notice Get user borrow data for a specific DEX and user\n    /// @param dex_ The address of the DEX\n    /// @param user_ The address of the user\n    /// @return userBorrowData_ Struct containing user borrow data\n    function getUserBorrowData(\n        address dex_,\n        address user_\n    ) public view returns (UserBorrowData memory userBorrowData_) {\n        uint256 userBorrow_ = getUserBorrowDataRaw(dex_, user_);\n\n        if (userBorrow_ > 0) {\n            // if userBorrow_ == 0 -> user not configured yet\n\n            userBorrowData_.isAllowed = userBorrow_ & 1 == 1;\n\n            userBorrowData_.borrow = BigMathMinified.fromBigNumber(\n                (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & DexCalcs.X64,\n                DexCalcs.DEFAULT_EXPONENT_SIZE,\n                DexCalcs.DEFAULT_EXPONENT_MASK\n            );\n\n            // get updated expanded borrow limit\n            userBorrowData_.borrowLimit = DexCalcs.calcBorrowLimitBeforeOperate(userBorrow_, userBorrowData_.borrow);\n\n            userBorrowData_.lastUpdateTimestamp =\n                (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) &\n                DexCalcs.X33;\n            userBorrowData_.expandPercent =\n                (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) &\n                DexCalcs.X14;\n            userBorrowData_.expandDuration =\n                (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) &\n                DexCalcs.X24;\n            userBorrowData_.baseBorrowLimit = BigMathMinified.fromBigNumber(\n                (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & DexCalcs.X18,\n                DexCalcs.DEFAULT_EXPONENT_SIZE,\n                DexCalcs.DEFAULT_EXPONENT_MASK\n            );\n            userBorrowData_.maxBorrowLimit = BigMathMinified.fromBigNumber(\n                (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & DexCalcs.X18,\n                DexCalcs.DEFAULT_EXPONENT_SIZE,\n                DexCalcs.DEFAULT_EXPONENT_MASK\n            );\n\n            userBorrowData_.borrowableUntilLimit = userBorrowData_.borrowLimit > userBorrowData_.borrow\n                ? userBorrowData_.borrowLimit - userBorrowData_.borrow\n                : 0;\n\n            userBorrowData_.borrowable = userBorrowData_.borrowableUntilLimit;\n\n            (address token0_, address token1_) = getDexTokens(dex_);\n            (userBorrowData_.liquidityUserBorrowDataToken0, userBorrowData_.liquidityTokenData0) = LIQUIDITY_RESOLVER\n                .getUserBorrowData(dex_, token0_);\n            (userBorrowData_.liquidityUserBorrowDataToken1, userBorrowData_.liquidityTokenData1) = LIQUIDITY_RESOLVER\n                .getUserBorrowData(dex_, token1_);\n        }\n    }\n\n    /// @notice Get user borrow data for multiple users in a specific DEX\n    /// @param dex_ The address of the DEX\n    /// @param users_ Array of user addresses\n    /// @return userBorrowingsData_ Array of UserBorrowData structs for each user\n    function getUserBorrowDatas(\n        address dex_,\n        address[] calldata users_\n    ) public view returns (UserBorrowData[] memory userBorrowingsData_) {\n        uint256 length_ = users_.length;\n        userBorrowingsData_ = new UserBorrowData[](length_);\n\n        for (uint256 i; i < length_; i++) {\n            (userBorrowingsData_[i]) = getUserBorrowData(dex_, users_[i]);\n        }\n    }\n\n    /// @notice Get both user supply and borrow data for multiple users in a specific DEX\n    /// @param dex_ The address of the DEX\n    /// @param users_ Array of user addresses\n    /// @return userSuppliesData_ Array of UserSupplyData structs for each user\n    /// @return userBorrowingsData_ Array of UserBorrowData structs for each user\n    function getUserBorrowSupplyDatas(\n        address dex_,\n        address[] calldata users_\n    ) public view returns (UserSupplyData[] memory userSuppliesData_, UserBorrowData[] memory userBorrowingsData_) {\n        uint256 length_ = users_.length;\n        userSuppliesData_ = new UserSupplyData[](length_);\n        userBorrowingsData_ = new UserBorrowData[](length_);\n        for (uint256 i; i < length_; i++) {\n            (userSuppliesData_[i]) = getUserSupplyData(dex_, users_[i]);\n            (userBorrowingsData_[i]) = getUserBorrowData(dex_, users_[i]);\n        }\n    }\n}\n\n/// @notice Fluid Dex protocol resolver\n/// Implements various view-only methods to give easy access to Dex protocol data.\ncontract FluidDexResolver is Variables, DexFactoryViews, DexActionEstimates, DexUserViews {\n    constructor(\n        address factory_,\n        address liquidity_,\n        address liquidityResolver_,\n        address deployer_\n    ) Variables(factory_, liquidity_, liquidityResolver_, deployer_) {}\n\n    /// @notice Get the current state of a DEX\n    /// @param dex_ The address of the DEX\n    /// @return state_ A struct containing the current state of the DEX\n    /// @dev expected to be called via callStatic\n    function getDexState(address dex_) public returns (DexState memory state_) {\n        return _getDexState(dex_, getDexCollateralReserves(dex_), getDexDebtReserves(dex_));\n    }\n\n    /// @notice Get the current configurations of a DEX\n    /// @param dex_ The address of the DEX\n    /// @return configs_ A struct containing the current configurations of the DEX\n    function getDexConfigs(address dex_) public view returns (Configs memory configs_) {\n        uint256 dexVariables2_ = getDexVariables2Raw(dex_);\n\n        configs_.isSmartCollateralEnabled = (dexVariables2_ & 1) == 1;\n        configs_.isSmartDebtEnabled = (dexVariables2_ & 2) == 2;\n        configs_.fee = (dexVariables2_ >> 2) & X17;\n        configs_.revenueCut = (dexVariables2_ >> 19) & X7;\n        configs_.upperRange = (dexVariables2_ >> 27) & X20;\n        configs_.lowerRange = (dexVariables2_ >> 47) & X20;\n        configs_.upperShiftThreshold = (dexVariables2_ >> 68) & X10;\n        configs_.lowerShiftThreshold = (dexVariables2_ >> 78) & X10;\n        configs_.shiftingTime = (dexVariables2_ >> 88) & X24;\n\n        configs_.maxSupplyShares = getTotalSupplySharesRaw(dex_) >> 128;\n        configs_.maxBorrowShares = getTotalBorrowSharesRaw(dex_) >> 128;\n\n        uint256 addressNonce_ = (dexVariables2_ >> 112) & X30;\n        if (addressNonce_ > 0) {\n            configs_.centerPriceAddress = AddressCalcs.addressCalc(DEPLOYER_CONTRACT, addressNonce_);\n        }\n\n        addressNonce_ = (dexVariables2_ >> 142) & X30;\n        if (addressNonce_ > 0) {\n            configs_.hookAddress = AddressCalcs.addressCalc(DEPLOYER_CONTRACT, addressNonce_);\n        }\n\n        configs_.maxCenterPrice = BigMathMinified.fromBigNumber(\n            (dexVariables2_ >> 172) & X28,\n            DexCalcs.DEFAULT_EXPONENT_SIZE,\n            DexCalcs.DEFAULT_EXPONENT_MASK\n        );\n        configs_.minCenterPrice = BigMathMinified.fromBigNumber(\n            (dexVariables2_ >> 200) & X28,\n            DexCalcs.DEFAULT_EXPONENT_SIZE,\n            DexCalcs.DEFAULT_EXPONENT_MASK\n        );\n\n        configs_.utilizationLimitToken0 = (dexVariables2_ >> 228) & X10;\n        configs_.utilizationLimitToken1 = (dexVariables2_ >> 238) & X10;\n    }\n\n    /// @notice Get the swap limits and availability for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return limitsAndAvailability_ A struct containing the swap limits and availability for the DEX\n    function getDexSwapLimitsAndAvailability(\n        address dex_\n    ) public view returns (SwapLimitsAndAvailability memory limitsAndAvailability_) {\n        (address token0_, address token1_) = getDexTokens(dex_);\n\n        uint256 dexVariables2_ = getDexVariables2Raw(dex_);\n        uint256 utilizationLimitToken0_ = (dexVariables2_ >> 228) & X10;\n        uint256 utilizationLimitToken1_ = (dexVariables2_ >> 238) & X10;\n\n        return\n            _getDexSwapLimitsAndAvailability(dex_, token0_, token1_, utilizationLimitToken0_, utilizationLimitToken1_);\n    }\n\n    /// @notice Get the entire data for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return data_ A struct containing all the data for the DEX\n    /// @dev expected to be called via callStatic\n    function getDexEntireData(address dex_) public returns (DexEntireData memory data_) {\n        data_.dex = dex_;\n        data_.constantViews = getDexConstantsView(dex_);\n        data_.constantViews2 = getDexConstantsView2(dex_);\n        data_.configs = getDexConfigs(dex_);\n        data_.pex = getDexPricesAndExchangePrices(dex_);\n        data_.colReserves = _getDexCollateralReserves(dex_, data_.constantViews2);\n        data_.debtReserves = _getDexDebtReserves(dex_, data_.constantViews2);\n        data_.dexState = _getDexState(dex_, data_.colReserves, data_.debtReserves);\n        data_.limitsAndAvailability = _getDexSwapLimitsAndAvailability(\n            dex_,\n            data_.constantViews.token0,\n            data_.constantViews.token1,\n            data_.configs.utilizationLimitToken0,\n            data_.configs.utilizationLimitToken1\n        );\n    }\n\n    /// @notice Get the entire data for multiple DEXes\n    /// @param dexes_ An array of DEX addresses\n    /// @return datas_ An array of structs containing all the data for each DEX\n    /// @dev expected to be called via callStatic\n    function getDexEntireDatas(address[] memory dexes_) public returns (DexEntireData[] memory datas_) {\n        uint256 length_ = dexes_.length;\n        datas_ = new DexEntireData[](length_);\n\n        for (uint256 i; i < length_; i++) {\n            datas_[i] = getDexEntireData(dexes_[i]);\n        }\n    }\n\n    /// @notice Get the entire data for all DEXes\n    /// @return datas_ An array of structs containing all the data for all DEXes\n    /// @dev expected to be called via callStatic\n    function getAllDexEntireDatas() external returns (DexEntireData[] memory datas_) {\n        return getDexEntireDatas(getAllDexAddresses());\n    }\n\n    /// @dev get the swap limits and availability for a DEX\n    /// @param dex_ The address of the DEX\n    /// @param token0_ The address of token0\n    /// @param token1_ The address of token1\n    /// @param utilizationLimitToken0Percent_ The utilization limit percentage for token0\n    /// @param utilizationLimitToken1Percent_ The utilization limit percentage for token1\n    /// @return limitsAndAvailability_ A struct containing the swap limits and availability for the DEX\n    function _getDexSwapLimitsAndAvailability(\n        address dex_,\n        address token0_,\n        address token1_,\n        uint256 utilizationLimitToken0Percent_,\n        uint256 utilizationLimitToken1Percent_\n    ) internal view returns (SwapLimitsAndAvailability memory limitsAndAvailability_) {\n        (\n            limitsAndAvailability_.liquidityUserSupplyDataToken0,\n            limitsAndAvailability_.liquidityTokenData0\n        ) = LIQUIDITY_RESOLVER.getUserSupplyData(dex_, token0_);\n        (\n            limitsAndAvailability_.liquidityUserSupplyDataToken1,\n            limitsAndAvailability_.liquidityTokenData1\n        ) = LIQUIDITY_RESOLVER.getUserSupplyData(dex_, token1_);\n\n        (limitsAndAvailability_.liquidityUserBorrowDataToken0, ) = LIQUIDITY_RESOLVER.getUserBorrowData(dex_, token0_);\n        (limitsAndAvailability_.liquidityUserBorrowDataToken1, ) = LIQUIDITY_RESOLVER.getUserBorrowData(dex_, token1_);\n\n        limitsAndAvailability_.liquiditySupplyToken0 = limitsAndAvailability_.liquidityTokenData0.totalSupply;\n        limitsAndAvailability_.liquiditySupplyToken1 = limitsAndAvailability_.liquidityTokenData1.totalSupply;\n        limitsAndAvailability_.liquidityBorrowToken0 = limitsAndAvailability_.liquidityTokenData0.totalBorrow;\n        limitsAndAvailability_.liquidityBorrowToken1 = limitsAndAvailability_.liquidityTokenData1.totalBorrow;\n\n        limitsAndAvailability_.liquidityWithdrawableToken0 = limitsAndAvailability_\n            .liquidityUserSupplyDataToken0\n            .withdrawable;\n        limitsAndAvailability_.liquidityWithdrawableToken1 = limitsAndAvailability_\n            .liquidityUserSupplyDataToken1\n            .withdrawable;\n\n        limitsAndAvailability_.liquidityBorrowableToken0 = limitsAndAvailability_\n            .liquidityUserBorrowDataToken0\n            .borrowable;\n        limitsAndAvailability_.liquidityBorrowableToken1 = limitsAndAvailability_\n            .liquidityUserBorrowDataToken1\n            .borrowable;\n\n        limitsAndAvailability_.utilizationLimitToken0 =\n            (limitsAndAvailability_.liquiditySupplyToken0 * utilizationLimitToken0Percent_) /\n            1e3;\n        limitsAndAvailability_.utilizationLimitToken1 =\n            (limitsAndAvailability_.liquiditySupplyToken1 * utilizationLimitToken1Percent_) /\n            1e3;\n\n        if (limitsAndAvailability_.liquidityBorrowToken0 < limitsAndAvailability_.utilizationLimitToken0) {\n            limitsAndAvailability_.withdrawableUntilUtilizationLimitToken0 =\n                (1e3 * limitsAndAvailability_.liquidityBorrowToken0) /\n                utilizationLimitToken0Percent_;\n            limitsAndAvailability_.withdrawableUntilUtilizationLimitToken0 = limitsAndAvailability_\n                .liquiditySupplyToken0 > limitsAndAvailability_.withdrawableUntilUtilizationLimitToken0\n                ? limitsAndAvailability_.liquiditySupplyToken0 -\n                    limitsAndAvailability_.withdrawableUntilUtilizationLimitToken0\n                : 0;\n\n            limitsAndAvailability_.borrowableUntilUtilizationLimitToken0 =\n                limitsAndAvailability_.utilizationLimitToken0 -\n                limitsAndAvailability_.liquidityBorrowToken0;\n        }\n\n        if (limitsAndAvailability_.liquidityBorrowToken1 < limitsAndAvailability_.utilizationLimitToken1) {\n            limitsAndAvailability_.withdrawableUntilUtilizationLimitToken1 =\n                (1e3 * limitsAndAvailability_.liquidityBorrowToken1) /\n                utilizationLimitToken1Percent_;\n            limitsAndAvailability_.withdrawableUntilUtilizationLimitToken1 = limitsAndAvailability_\n                .liquiditySupplyToken1 > limitsAndAvailability_.withdrawableUntilUtilizationLimitToken1\n                ? limitsAndAvailability_.liquiditySupplyToken1 -\n                    limitsAndAvailability_.withdrawableUntilUtilizationLimitToken1\n                : 0;\n\n            limitsAndAvailability_.borrowableUntilUtilizationLimitToken1 =\n                limitsAndAvailability_.utilizationLimitToken1 -\n                limitsAndAvailability_.liquidityBorrowToken1;\n        }\n    }\n\n    /// @dev Get the current state of a DEX\n    function _getDexState(\n        address dex_,\n        IFluidDexT1.CollateralReserves memory colReserves_,\n        IFluidDexT1.DebtReserves memory debtReserves_\n    ) internal view returns (DexState memory state_) {\n        uint256 storageVar_ = getDexVariablesRaw(dex_);\n\n        /// Next 40 bits => 1-40 => last to last stored price. BigNumber (32 bits precision, 8 bits exponent)\n        /// Next 40 bits => 41-80 => last stored price of pool. BigNumber (32 bits precision, 8 bits exponent)\n        /// Next 40 bits => 81-120 => center price. Center price from where the ranges will be calculated. BigNumber (32 bits precision, 8 bits exponent)\n        state_.lastToLastStoredPrice = (storageVar_ >> 1) & X40;\n        state_.lastToLastStoredPrice = (state_.lastToLastStoredPrice >> 8) << (state_.lastToLastStoredPrice & X8);\n        state_.lastStoredPrice = (storageVar_ >> 41) & X40;\n        state_.lastStoredPrice = (state_.lastStoredPrice >> 8) << (state_.lastStoredPrice & X8);\n        state_.centerPrice = (storageVar_ >> 81) & X40;\n        state_.centerPrice = (state_.centerPrice >> 8) << (state_.centerPrice & X8);\n\n        state_.lastUpdateTimestamp = (storageVar_ >> 121) & X33;\n        state_.lastPricesTimeDiff = (storageVar_ >> 154) & X22;\n        state_.oracleCheckPoint = (storageVar_ >> 176) & X3;\n        state_.oracleMapping = (storageVar_ >> 179) & X16;\n\n        state_.totalSupplyShares = getTotalSupplySharesRaw(dex_) & X128;\n        state_.totalBorrowShares = getTotalBorrowSharesRaw(dex_) & X128;\n\n        storageVar_ = getDexVariables2Raw(dex_);\n        state_.isSwapAndArbitragePaused = storageVar_ >> 255 == 1;\n\n        state_.shifts.isRangeChangeActive = (storageVar_ >> 26) & 1 == 1;\n        state_.shifts.isThresholdChangeActive = (storageVar_ >> 67) & 1 == 1;\n        state_.shifts.isCenterPriceShiftActive = (storageVar_ >> 248) & 1 == 1;\n\n        storageVar_ = getRangeShiftRaw(dex_);\n        state_.shifts.rangeShift.oldUpper = storageVar_ & X20;\n        state_.shifts.rangeShift.oldLower = (storageVar_ >> 20) & X20;\n        state_.shifts.rangeShift.duration = (storageVar_ >> 40) & X20;\n        state_.shifts.rangeShift.startTimestamp = (storageVar_ >> 60) & X33;\n\n        storageVar_ = getThresholdShiftRaw(dex_);\n        state_.shifts.thresholdShift.oldUpper = storageVar_ & X10;\n        state_.shifts.thresholdShift.oldLower = (storageVar_ >> 20) & X10;\n        state_.shifts.thresholdShift.duration = (storageVar_ >> 40) & X20;\n        state_.shifts.thresholdShift.startTimestamp = (storageVar_ >> 60) & X33;\n        state_.shifts.thresholdShift.oldTime = (storageVar_ >> 93) & X24;\n\n        storageVar_ = getCenterPriceShiftRaw(dex_);\n        state_.shifts.centerPriceShift.startTimestamp = storageVar_ & X33;\n        state_.shifts.centerPriceShift.shiftPercentage = (storageVar_ >> 33) & X20;\n        state_.shifts.centerPriceShift.duration = (storageVar_ >> 53) & X20;\n\n        if (state_.totalSupplyShares > 0) {\n            state_.token0PerSupplyShare = (colReserves_.token0RealReserves * 1e18) / state_.totalSupplyShares;\n            state_.token1PerSupplyShare = (colReserves_.token1RealReserves * 1e18) / state_.totalSupplyShares;\n        }\n        if (state_.totalBorrowShares > 0) {\n            state_.token0PerBorrowShare = (debtReserves_.token0Debt * 1e18) / state_.totalBorrowShares;\n            state_.token1PerBorrowShare = (debtReserves_.token1Debt * 1e18) / state_.totalBorrowShares;\n        }\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dex/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { Structs as FluidLiquidityResolverStructs } from \"../liquidity/structs.sol\";\n\nabstract contract Structs {\n    struct DexState {\n        uint256 lastToLastStoredPrice;\n        uint256 lastStoredPrice; // price of pool after the most recent swap\n        uint256 centerPrice;\n        uint256 lastUpdateTimestamp;\n        uint256 lastPricesTimeDiff;\n        uint256 oracleCheckPoint;\n        uint256 oracleMapping;\n        uint256 totalSupplyShares;\n        uint256 totalBorrowShares;\n        bool isSwapAndArbitragePaused; // if true, only perfect functions will be usable\n        ShiftChanges shifts;\n        // below values have to be combined with Oracle price data at the VaultResolver\n        uint256 token0PerSupplyShare; // token0 amount per 1e18 supply shares\n        uint256 token1PerSupplyShare; // token1 amount per 1e18 supply shares\n        uint256 token0PerBorrowShare; // token0 amount per 1e18 borrow shares\n        uint256 token1PerBorrowShare; // token1 amount per 1e18 borrow shares\n    }\n\n    struct ShiftData {\n        uint256 oldUpper;\n        uint256 oldLower;\n        uint256 duration;\n        uint256 startTimestamp;\n        uint256 oldTime; // only for thresholdShift\n    }\n\n    struct CenterPriceShift {\n        uint256 shiftPercentage;\n        uint256 duration;\n        uint256 startTimestamp;\n    }\n\n    struct ShiftChanges {\n        bool isRangeChangeActive;\n        bool isThresholdChangeActive;\n        bool isCenterPriceShiftActive;\n        ShiftData rangeShift;\n        ShiftData thresholdShift;\n        CenterPriceShift centerPriceShift;\n    }\n\n    struct Configs {\n        bool isSmartCollateralEnabled;\n        bool isSmartDebtEnabled;\n        uint256 fee;\n        uint256 revenueCut;\n        uint256 upperRange;\n        uint256 lowerRange;\n        uint256 upperShiftThreshold;\n        uint256 lowerShiftThreshold;\n        uint256 shiftingTime;\n        address centerPriceAddress;\n        address hookAddress;\n        uint256 maxCenterPrice;\n        uint256 minCenterPrice;\n        uint256 utilizationLimitToken0;\n        uint256 utilizationLimitToken1;\n        uint256 maxSupplyShares;\n        uint256 maxBorrowShares;\n    }\n\n    // @dev note there might be other things that act as effective limits which are not fully considered here.\n    // e.g. such as maximum 5% oracle shift in one swap, withdraws & borrowing together affecting each other,\n    // shares being below max supply / borrow shares etc.\n    struct SwapLimitsAndAvailability {\n        // liquidity total amounts\n        uint liquiditySupplyToken0;\n        uint liquiditySupplyToken1;\n        uint liquidityBorrowToken0;\n        uint liquidityBorrowToken1;\n        // liquidity limits\n        uint liquidityWithdrawableToken0;\n        uint liquidityWithdrawableToken1;\n        uint liquidityBorrowableToken0;\n        uint liquidityBorrowableToken1;\n        // utilization limits based on config at Dex. (e.g. liquiditySupplyToken0 * Configs.utilizationLimitToken0 / 1e3)\n        uint utilizationLimitToken0;\n        uint utilizationLimitToken1;\n        // swappable amounts until utilization limit.\n        // In a swap that does both withdraw and borrow, the effective amounts might be less because withdraw / borrow affect each other\n        // (both increase utilization).\n        uint withdrawableUntilUtilizationLimitToken0; // x = totalSupply - totalBorrow / maxUtilizationPercentage\n        uint withdrawableUntilUtilizationLimitToken1;\n        uint borrowableUntilUtilizationLimitToken0; // x = maxUtilizationPercentage * totalSupply - totalBorrow.\n        uint borrowableUntilUtilizationLimitToken1;\n        // additional liquidity related data such as supply amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyDataToken0;\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyDataToken1;\n        // additional liquidity related data such as borrow amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowDataToken0;\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowDataToken1;\n        // liquidity token related data\n        FluidLiquidityResolverStructs.OverallTokenData liquidityTokenData0;\n        FluidLiquidityResolverStructs.OverallTokenData liquidityTokenData1;\n    }\n\n    struct DexEntireData {\n        address dex;\n        IFluidDexT1.ConstantViews constantViews;\n        IFluidDexT1.ConstantViews2 constantViews2;\n        Configs configs;\n        IFluidDexT1.PricesAndExchangePrice pex;\n        IFluidDexT1.CollateralReserves colReserves;\n        IFluidDexT1.DebtReserves debtReserves;\n        DexState dexState;\n        SwapLimitsAndAvailability limitsAndAvailability;\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserSupplyData {\n        bool isAllowed;\n        uint256 supply; // user supply amount/shares\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\n        uint256 withdrawalLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\n        uint256 baseWithdrawalLimit;\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\n        uint256 withdrawableUntilLimit;\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\n        // liquidity related data such as supply amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyDataToken0;\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyDataToken1;\n        // liquidity token related data\n        FluidLiquidityResolverStructs.OverallTokenData liquidityTokenData0;\n        FluidLiquidityResolverStructs.OverallTokenData liquidityTokenData1;\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserBorrowData {\n        bool isAllowed;\n        uint256 borrow; // user borrow amount/shares\n        uint256 borrowLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseBorrowLimit;\n        uint256 maxBorrowLimit;\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        // liquidity related data such as borrow amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowDataToken0;\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowDataToken1;\n        // liquidity token related data\n        FluidLiquidityResolverStructs.OverallTokenData liquidityTokenData0;\n        FluidLiquidityResolverStructs.OverallTokenData liquidityTokenData1;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dex/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidityResolver } from \"../liquidity/iLiquidityResolver.sol\";\nimport { IFluidDexFactory } from \"../../../protocols/dex/interfaces/iDexFactory.sol\";\n\ninterface IFluidLiquidity {\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n\nabstract contract Variables {\n    IFluidDexFactory public immutable FACTORY;\n    IFluidLiquidity public immutable LIQUIDITY;\n    IFluidLiquidityResolver public immutable LIQUIDITY_RESOLVER;\n    /// @dev Address of contract used for deploying center price & hook related contract\n    address public immutable DEPLOYER_CONTRACT;\n\n    uint256 internal constant X2 = 0x3;\n    uint256 internal constant X3 = 0x7;\n    uint256 internal constant X5 = 0x1f;\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X8 = 0xff;\n    uint256 internal constant X9 = 0x1ff;\n    uint256 internal constant X10 = 0x3ff;\n    uint256 internal constant X11 = 0x7ff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X17 = 0x1ffff;\n    uint256 internal constant X20 = 0xfffff;\n    uint256 internal constant X22 = 0x3fffff;\n    uint256 internal constant X23 = 0x7fffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X28 = 0xfffffff;\n    uint256 internal constant X30 = 0x3fffffff;\n    uint256 internal constant X32 = 0xffffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X40 = 0xffffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n    uint256 internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n\n    /// @dev address that is mapped to the chain native token\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    constructor(address factory_, address liquidity_, address liquidityResolver_, address deployer_) {\n        FACTORY = IFluidDexFactory(factory_);\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        LIQUIDITY_RESOLVER = IFluidLiquidityResolver(liquidityResolver_);\n        DEPLOYER_CONTRACT = deployer_;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/iLiquidityResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Structs as LiquidityStructs } from \"../../../periphery/resolvers/liquidity/structs.sol\";\n\ninterface IFluidLiquidityResolver {\n    /// @notice gets the `revenueAmount_` for a `token_`.\n    function getRevenue(address token_) external view returns (uint256 revenueAmount_);\n\n    /// @notice address of contract that gets sent the revenue. Configurable by governance\n    function getRevenueCollector() external view returns (address);\n\n    /// @notice Liquidity contract paused status: status = 1 -> normal. status = 2 -> paused.\n    function getStatus() external view returns (uint256);\n\n    /// @notice checks if `auth_` is an allowed auth on Liquidity.\n    /// Auths can set most config values. E.g. contracts that automate certain flows like e.g. adding a new fToken.\n    /// Governance can add/remove auths. Governance is auth by default.\n    function isAuth(address auth_) external view returns (uint256);\n\n    /// @notice checks if `guardian_` is an allowed Guardian on Liquidity.\n    /// Guardians can pause lower class users.\n    /// Governance can add/remove guardians. Governance is guardian by default.\n    function isGuardian(address guardian_) external view returns (uint256);\n\n    /// @notice gets user class for `user_`. Class defines which protocols can be paused by guardians.\n    /// Currently there are 2 classes: 0 can be paused by guardians. 1 cannot be paused by guardians.\n    /// New protocols are added as class 0 and will be upgraded to 1 over time.\n    function getUserClass(address user_) external view returns (uint256);\n\n    /// @notice gets exchangePricesAndConfig packed uint256 storage slot for `token_`.\n    function getExchangePricesAndConfig(address token_) external view returns (uint256);\n\n    /// @notice gets rateConfig packed uint256 storage slot for `token_`.\n    function getRateConfig(address token_) external view returns (uint256);\n\n    /// @notice gets totalAmounts packed uint256 storage slot for `token_`.\n    function getTotalAmounts(address token_) external view returns (uint256);\n\n    /// @notice gets configs2 packed uint256 storage slot for `token_`.\n    function getConfigs2(address token_) external view returns (uint256);\n\n    /// @notice gets userSupply data packed uint256 storage slot for `user_` and `token_`.\n    function getUserSupply(address user_, address token_) external view returns (uint256);\n\n    /// @notice gets userBorrow data packed uint256 storage slot for `user_` and `token_`.\n    function getUserBorrow(address user_, address token_) external view returns (uint256);\n\n    /// @notice returns all `listedTokens_` at the Liquidity contract. Once configured, a token can never be removed.\n    function listedTokens() external view returns (address[] memory listedTokens_);\n\n    /// @notice get the Rate config data `rateData_` for a `token_` compiled from the packed uint256 rateConfig storage slot\n    function getTokenRateData(address token_) external view returns (LiquidityStructs.RateData memory rateData_);\n\n    /// @notice get the Rate config datas `rateDatas_` for multiple `tokens_` compiled from the packed uint256 rateConfig storage slot\n    function getTokensRateData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.RateData[] memory rateDatas_);\n\n    /// @notice returns general data for `token_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokenData(\n        address token_\n    ) external view returns (LiquidityStructs.OverallTokenData memory overallTokenData_);\n\n    /// @notice returns general data for multiple `tokens_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokensData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns general data for all `listedTokens()` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getAllOverallTokensData()\n        external\n        view\n        returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserSupplyData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData memory userSupplyData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleSupplyData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserBorrowData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData memory userBorrowData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleBorrowData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `supplyTokens_`\n    ///     and returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `borrowTokens_`\n    function getUserMultipleBorrowSupplyData(\n        address user_,\n        address[] calldata supplyTokens_,\n        address[] calldata borrowTokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallSupplyTokensData_,\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallBorrowTokensData_\n        );\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs as AdminModuleStructs } from \"../../../liquidity/adminModule/structs.sol\";\n\nabstract contract Structs {\n    struct RateData {\n        uint256 version;\n        AdminModuleStructs.RateDataV1Params rateDataV1;\n        AdminModuleStructs.RateDataV2Params rateDataV2;\n    }\n\n    struct OverallTokenData {\n        uint256 borrowRate;\n        uint256 supplyRate;\n        uint256 fee; // revenue fee\n        uint256 lastStoredUtilization;\n        uint256 storageUpdateThreshold;\n        uint256 lastUpdateTimestamp;\n        uint256 supplyExchangePrice;\n        uint256 borrowExchangePrice;\n        uint256 supplyRawInterest;\n        uint256 supplyInterestFree;\n        uint256 borrowRawInterest;\n        uint256 borrowInterestFree;\n        uint256 totalSupply;\n        uint256 totalBorrow;\n        uint256 revenue;\n        uint256 maxUtilization; // maximum allowed utilization\n        RateData rateData;\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserSupplyData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 supply; // user supply amount\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\n        uint256 withdrawalLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\n        uint256 baseWithdrawalLimit;\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\n        uint256 withdrawableUntilLimit;\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserBorrowData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 borrow; // user borrow amount\n        uint256 borrowLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseBorrowLimit;\n        uint256 maxBorrowLimit;\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\n    }\n}\n"
    },
    "contracts/periphery/resolvers/smartLending/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { FluidDexResolver } from \"../dex/main.sol\";\nimport { FluidSmartLendingFactory } from \"../../../protocols/dex/smartLending/factory/main.sol\";\nimport { FluidSmartLending } from \"../../../protocols/dex/smartLending/main.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { Structs as DexResolverStructs } from \"../dex/structs.sol\";\n\n/// @notice Fluid Smart Lending resolver\n/// Implements various view-only methods to give easy access to Smart Lending protocol data.\ncontract FluidSmartLendingResolver is Structs {\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    FluidDexResolver public immutable DEX_RESOLVER;\n\n    FluidSmartLendingFactory public immutable SMART_LENDING_FACTORY;\n\n    address internal constant _NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice thrown if an input param address is zero\n    error FluidSmartLendingResolver__AddressZero();\n\n    constructor(FluidDexResolver dexResolver_, FluidSmartLendingFactory smartLendingFactory_) {\n        if (address(dexResolver_) == address(0) || address(smartLendingFactory_) == address(0)) {\n            revert FluidSmartLendingResolver__AddressZero();\n        }\n\n        DEX_RESOLVER = dexResolver_;\n        SMART_LENDING_FACTORY = smartLendingFactory_;\n    }\n\n    /// @notice List of all existing SmartLending tokens\n    function getAllSmartLendingAddresses() public view returns (address[] memory) {\n        return SMART_LENDING_FACTORY.allTokens();\n    }\n\n    /// @notice Get the address of a SmartLending for a certain dexId. address zero if no SmartLending exists for the dex.\n    function getSmartLendingAddress(uint dexId_) public view returns (address smartLending) {\n        return SMART_LENDING_FACTORY.getSmartLendingAddress(dexId_);\n    }\n\n    /// @notice Get the entire data for a SmartLending, EXCEPT underlying DexEntireData. use write method for that.\n    /// @param smartLending_ The address of the SmartLending\n    /// @return data_ A struct containing all the data for the SmartLending\n    function getSmartLendingEntireViewData(\n        address payable smartLending_\n    ) public view returns (SmartLendingEntireData memory data_) {\n        data_.smartLending = smartLending_;\n        data_.name = FluidSmartLending(smartLending_).name();\n        data_.symbol = FluidSmartLending(smartLending_).symbol();\n        data_.decimals = 18;\n        data_.totalSupply = uint256(FluidSmartLending(smartLending_).totalSupply());\n\n        data_.token0 = FluidSmartLending(smartLending_).TOKEN0();\n        data_.token1 = FluidSmartLending(smartLending_).TOKEN1();\n        data_.dex = address(FluidSmartLending(smartLending_).DEX());\n\n        data_.lastTimestamp = uint256(FluidSmartLending(smartLending_).lastTimestamp());\n        data_.feeOrReward = int256(FluidSmartLending(smartLending_).feeOrReward());\n        (data_.exchangePrice, ) = FluidSmartLending(smartLending_).getUpdateExchangePrice();\n        // exchangePrice is in 1e18, shares are in 1e18, SmartLending is in 1e18\n        data_.assetsPerShare = (1e18 * 1e18) / data_.exchangePrice;\n        data_.sharesPerAsset = data_.exchangePrice; // just providing same value for extra clarity. would be 1e18 * exchangePrice / 1e18\n\n        data_.totalUnderlyingShares = (data_.totalSupply * data_.exchangePrice) / 1e18;\n\n        data_.rebalancer = FluidSmartLending(smartLending_).rebalancer();\n        data_.rebalanceDiff = uint256(FluidSmartLending(smartLending_).rebalanceDiff());\n\n        data_.dexUserSupplyData = DEX_RESOLVER.getUserSupplyData(data_.dex, smartLending_);\n    }\n\n    /// @notice Get the entire view data for multiple SmartLendings, EXCEPT underlying DexEntireData. use write method for that.\n    /// @param smartLendings_ An array of SmartLending addresses\n    /// @return datas_ An array of structs containing all the data for each SmartLending\n    function getSmartLendingEntireViewDatas(\n        address[] memory smartLendings_\n    ) public view returns (SmartLendingEntireData[] memory datas_) {\n        uint256 length_ = smartLendings_.length;\n        datas_ = new SmartLendingEntireData[](length_);\n\n        for (uint256 i; i < length_; i++) {\n            datas_[i] = getSmartLendingEntireViewData(payable(smartLendings_[i]));\n        }\n    }\n\n    /// @notice Get the entire data for all SmartLendings, EXCEPT underlying DexEntireData. use write method for that.\n    /// @return datas_ An array of structs containing all the data for all SmartLendings\n    function getAllSmartLendingEntireViewDatas() public view returns (SmartLendingEntireData[] memory datas_) {\n        return getSmartLendingEntireViewDatas(getAllSmartLendingAddresses());\n    }\n\n    /// @notice Get the entire data for a SmartLending, incl. underlying DexEntireData and totalUnderlyingAssets for each token\n    /// @param smartLending_ The address of the SmartLending\n    /// @return data_ A struct containing all the data for the SmartLending\n    /// @dev expected to be called via callStatic\n    function getSmartLendingEntireData(\n        address payable smartLending_\n    ) public returns (SmartLendingEntireData memory data_) {\n        data_ = getSmartLendingEntireViewData(smartLending_);\n\n        data_.dexEntireData = DEX_RESOLVER.getDexEntireData(data_.dex);\n\n        data_.totalUnderlyingAssetsToken0 =\n            (data_.totalUnderlyingShares * data_.dexEntireData.dexState.token0PerSupplyShare) /\n            1e18;\n        data_.totalUnderlyingAssetsToken1 =\n            (data_.totalUnderlyingShares * data_.dexEntireData.dexState.token1PerSupplyShare) /\n            1e18;\n    }\n\n    /// @notice Get the entire data for multiple SmartLendings\n    /// @param smartLendings_ An array of SmartLending addresses\n    /// @return datas_ An array of structs containing all the data for each SmartLending\n    /// @dev expected to be called via callStatic\n    function getSmartLendingEntireDatas(\n        address[] memory smartLendings_\n    ) public returns (SmartLendingEntireData[] memory datas_) {\n        uint256 length_ = smartLendings_.length;\n        datas_ = new SmartLendingEntireData[](length_);\n\n        for (uint256 i; i < length_; i++) {\n            datas_[i] = getSmartLendingEntireData(payable(smartLendings_[i]));\n        }\n    }\n\n    /// @notice Get the entire data for all SmartLendings\n    /// @return datas_ An array of structs containing all the data for all SmartLendings\n    /// @dev expected to be called via callStatic\n    function getAllSmartLendingEntireDatas() public returns (SmartLendingEntireData[] memory datas_) {\n        return getSmartLendingEntireDatas(getAllSmartLendingAddresses());\n    }\n\n    /// @notice gets a user position at a certain SmartLending. EXCLUDING underlyingAssetsToken0 and underlyingAssetsToken1.\n    ///          use write method for that.\n    function getUserPositionView(\n        address payable smartLending_,\n        address user_\n    ) public view returns (UserPosition memory userPosition_) {\n        userPosition_.user = user_;\n        userPosition_.smartLendingAssets = FluidSmartLending(payable(smartLending_)).balanceOf(user_);\n\n        {\n            (uint256 exchangePrice_, ) = FluidSmartLending(smartLending_).getUpdateExchangePrice();\n            userPosition_.underlyingShares = (userPosition_.smartLendingAssets * exchangePrice_) / 1e18;\n        }\n\n        {\n            IERC20 token0_ = IERC20(FluidSmartLending(smartLending_).TOKEN0());\n            IERC20 token1_ = IERC20(FluidSmartLending(smartLending_).TOKEN1());\n\n            if (address(token0_) == _NATIVE_TOKEN_ADDRESS) {\n                userPosition_.underlyingBalanceToken0 = address(user_).balance;\n            } else {\n                userPosition_.underlyingBalanceToken0 = token0_.balanceOf(user_);\n                userPosition_.allowanceToken0 = token0_.allowance(user_, address(smartLending_));\n            }\n\n            if (address(token1_) == _NATIVE_TOKEN_ADDRESS) {\n                userPosition_.underlyingBalanceToken1 = address(user_).balance;\n            } else {\n                userPosition_.underlyingBalanceToken1 = token1_.balanceOf(user_);\n                userPosition_.allowanceToken1 = token1_.allowance(user_, address(smartLending_));\n            }\n        }\n    }\n\n    /// @notice gets a user position at a certain SmartLending incl. underlyingAssetsToken0 and underlyingAssetsToken1\n    /// @dev expected to be called via callStatic\n    function getUserPosition(\n        address payable smartLending_,\n        address user_\n    ) public returns (UserPosition memory userPosition_) {\n        userPosition_ = getUserPositionView(smartLending_, user_);\n\n        {\n            DexResolverStructs.DexState memory dexState_ = DEX_RESOLVER.getDexState(\n                address(FluidSmartLending(smartLending_).DEX())\n            );\n\n            userPosition_.underlyingAssetsToken0 =\n                (userPosition_.underlyingShares * dexState_.token0PerSupplyShare) /\n                1e18;\n            userPosition_.underlyingAssetsToken1 =\n                (userPosition_.underlyingShares * dexState_.token1PerSupplyShare) /\n                1e18;\n        }\n    }\n\n    /// @notice gets all Smart lendings entire data and all user positions for each.\n    ///         Excluding underlying DexEntireData and underlyingAssetsToken0 and underlyingAssetsToken1. use write method for that.\n    function getUserPositionsView(address user_) external view returns (SmartLendingEntireDataUserPosition[] memory) {\n        SmartLendingEntireData[] memory smartLendingsEntireData_ = getAllSmartLendingEntireViewDatas();\n        SmartLendingEntireDataUserPosition[] memory userPositionArr_ = new SmartLendingEntireDataUserPosition[](\n            smartLendingsEntireData_.length\n        );\n        for (uint256 i = 0; i < smartLendingsEntireData_.length; ) {\n            userPositionArr_[i].smartLendingEntireData = smartLendingsEntireData_[i];\n            userPositionArr_[i].userPosition = getUserPositionView(\n                payable(smartLendingsEntireData_[i].smartLending),\n                user_\n            );\n            unchecked {\n                i++;\n            }\n        }\n        return userPositionArr_;\n    }\n\n    /// @notice gets all Smart lendings entire data and all user positions for each.\n    ///         incl. underlying Dex (=`getSmartLendingEntireViewData()` + DexEntireData) and underlyingAssetsToken0 and underlyingAssetsToken1.\n    /// @dev expected to be called via callStatic\n    function getUserPositions(address user_) external returns (SmartLendingEntireDataUserPosition[] memory) {\n        SmartLendingEntireData[] memory smartLendingsEntireData_ = getAllSmartLendingEntireDatas();\n        SmartLendingEntireDataUserPosition[] memory userPositionArr_ = new SmartLendingEntireDataUserPosition[](\n            smartLendingsEntireData_.length\n        );\n        for (uint256 i = 0; i < smartLendingsEntireData_.length; ) {\n            userPositionArr_[i].smartLendingEntireData = smartLendingsEntireData_[i];\n            userPositionArr_[i].userPosition = getUserPosition(\n                payable(smartLendingsEntireData_[i].smartLending),\n                user_\n            );\n            unchecked {\n                i++;\n            }\n        }\n        return userPositionArr_;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/smartLending/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs as DexResolverStructs } from \"../dex/structs.sol\";\n\nabstract contract Structs {\n    struct SmartLendingEntireData {\n        // address of the smart lending\n        address smartLending;\n        // The name of the SmartLending token.\n        string name;\n        // The symbol of the SmartLending token.\n        string symbol;\n        // The number of decimal places for the SmartLending token.\n        uint8 decimals;\n        // The total supply of the SmartLending token.\n        uint256 totalSupply;\n        // total dex shares according to smart lending exchange rate\n        uint256 totalUnderlyingShares;\n        // total token0 amount built with dex token0PerSupplyShare. (!!) this is not set when calling the view method\n        uint256 totalUnderlyingAssetsToken0;\n        // total token1 amount built with dex token1PerSupplyShare. (!!) this is not set when calling the view method\n        uint256 totalUnderlyingAssetsToken1;\n        // The address of the first token in the underlying dex pool.\n        address token0;\n        // The address of the second token in the underlying dex pool.\n        address token1;\n        // The address of the underlying dex pool.\n        address dex;\n        // The last timestamp when the exchange price was updated in storage.\n        uint256 lastTimestamp;\n        // The fee or reward rate for the SmartLending. If positive then rewards, if negative then fee. 1e6 = 100%, 1e4 = 1%, minimum 0.0001% fee or reward.\n        int256 feeOrReward;\n        // The current exchange price of the SmartLending updated to block.timestamp.\n        uint256 exchangePrice;\n        // The address of the rebalancer.\n        address rebalancer;\n        // exchange rate for x assets per 1 underlying pool share\n        uint256 assetsPerShare;\n        // exchange rate for x underlying pool shares per 1 SmartLending asset (=exchangePrice)\n        uint256 sharesPerAsset;\n        // The difference in balance for rebalancing. difference between the total smart lending shares on the DEX and the total smart lending shares calculated.\n        // A positive value indicates fees to collect, while a negative value indicates rewards to be rebalanced.\n        uint256 rebalanceDiff;\n        // structs fetched directly from DexResolver:\n        DexResolverStructs.DexEntireData dexEntireData; // (!!) this is not set when calling the view method\n        DexResolverStructs.UserSupplyData dexUserSupplyData; // supply data of the SmartLending at the dex\n    }\n\n    struct UserPosition {\n        address user;\n        uint256 smartLendingAssets; // ERC20 smart lending assets that the user owns\n        uint256 underlyingShares; // dex shares according to smart lending exchange rate\n        uint256 underlyingAssetsToken0; // position token0 amount built with dex token0PerSupplyShare. (!!) this is not set when calling the view method\n        uint256 underlyingAssetsToken1; // position token1 amount built with dex token1PerSupplyShare. (!!) this is not set when calling the view method\n        uint256 underlyingBalanceToken0; // token0 user balance\n        uint256 underlyingBalanceToken1; // token1 user balance\n        uint256 allowanceToken0; // allowance of token0 for user to the smartLending\n        uint256 allowanceToken1; // allowance of token1 for user to the smartLending\n    }\n\n    struct SmartLendingEntireDataUserPosition {\n        SmartLendingEntireData smartLendingEntireData;\n        UserPosition userPosition;\n    }\n}\n"
    },
    "contracts/protocols/dex/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs } from \"./poolT1/coreModule/structs.sol\";\n\nabstract contract Error {\n    error FluidDexError(uint256 errorId_);\n\n    error FluidDexFactoryError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares_);\n\n    error FluidDexPricesAndExchangeRates(Structs.PricesAndExchangePrice pex_);\n\n    error FluidSmartLendingError(uint256 errorId_);\n\n    error FluidSmartLendingFactoryError(uint256 errorId_);\n}\n"
    },
    "contracts/protocols/dex/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |             DexT1                 | \n    |__________________________________*/\n\n    /// @notice thrown at reentrancy\n    uint256 internal constant DexT1__AlreadyEntered = 51001;\n\n    uint256 internal constant DexT1__NotAnAuth = 51002;\n\n    uint256 internal constant DexT1__SmartColNotEnabled = 51003;\n\n    uint256 internal constant DexT1__SmartDebtNotEnabled = 51004;\n\n    uint256 internal constant DexT1__PoolNotInitialized = 51005;\n\n    uint256 internal constant DexT1__TokenReservesTooLow = 51006;\n\n    uint256 internal constant DexT1__EthAndAmountInMisMatch = 51007;\n\n    uint256 internal constant DexT1__EthSentForNonNativeSwap = 51008;\n\n    uint256 internal constant DexT1__NoSwapRoute = 51009;\n\n    uint256 internal constant DexT1__NotEnoughAmountOut = 51010;\n\n    uint256 internal constant DexT1__LiquidityLayerTokenUtilizationCapReached = 51011;\n\n    uint256 internal constant DexT1__HookReturnedFalse = 51012;\n\n    // Either user's config are not set or user is paused\n    uint256 internal constant DexT1__UserSupplyInNotOn = 51013;\n\n    // Either user's config are not set or user is paused\n    uint256 internal constant DexT1__UserDebtInNotOn = 51014;\n\n    // Thrown when contract asks for more token0 or token1 than what user's wants to give on deposit\n    uint256 internal constant DexT1__AboveDepositMax = 51015;\n\n    uint256 internal constant DexT1__MsgValueLowOnDepositOrPayback = 51016;\n\n    uint256 internal constant DexT1__WithdrawLimitReached = 51017;\n\n    // Thrown when contract gives less token0 or token1 than what user's wants on withdraw\n    uint256 internal constant DexT1__BelowWithdrawMin = 51018;\n\n    uint256 internal constant DexT1__DebtLimitReached = 51019;\n\n    // Thrown when contract gives less token0 or token1 than what user's wants on borrow\n    uint256 internal constant DexT1__BelowBorrowMin = 51020;\n\n    // Thrown when contract asks for more token0 or token1 than what user's wants on payback\n    uint256 internal constant DexT1__AbovePaybackMax = 51021;\n\n    uint256 internal constant DexT1__InvalidDepositAmts = 51022;\n\n    uint256 internal constant DexT1__DepositAmtsZero = 51023;\n\n    uint256 internal constant DexT1__SharesMintedLess = 51024;\n\n    uint256 internal constant DexT1__WithdrawalNotEnough = 51025;\n\n    uint256 internal constant DexT1__InvalidWithdrawAmts = 51026;\n\n    uint256 internal constant DexT1__WithdrawAmtsZero = 51027;\n\n    uint256 internal constant DexT1__WithdrawExcessSharesBurn = 51028;\n\n    uint256 internal constant DexT1__InvalidBorrowAmts = 51029;\n\n    uint256 internal constant DexT1__BorrowAmtsZero = 51030;\n\n    uint256 internal constant DexT1__BorrowExcessSharesMinted = 51031;\n\n    uint256 internal constant DexT1__PaybackAmtTooHigh = 51032;\n\n    uint256 internal constant DexT1__InvalidPaybackAmts = 51033;\n\n    uint256 internal constant DexT1__PaybackAmtsZero = 51034;\n\n    uint256 internal constant DexT1__PaybackSharedBurnedLess = 51035;\n\n    uint256 internal constant DexT1__NothingToArbitrage = 51036;\n\n    uint256 internal constant DexT1__MsgSenderNotLiquidity = 51037;\n\n    // On liquidity callback reentrancy bit should be on\n    uint256 internal constant DexT1__ReentrancyBitShouldBeOn = 51038;\n\n    // Thrown is reentrancy is already on and someone tries to fetch oracle price. Should not be possible to this\n    uint256 internal constant DexT1__OraclePriceFetchAlreadyEntered = 51039;\n\n    // Thrown when swap changes the current price by more than 5%\n    uint256 internal constant DexT1__OracleUpdateHugeSwapDiff = 51040;\n\n    uint256 internal constant DexT1__Token0ShouldBeSmallerThanToken1 = 51041;\n\n    uint256 internal constant DexT1__OracleMappingOverflow = 51042;\n\n    /// @notice thrown if governance has paused the swapping & arbitrage so only perfect functions are usable\n    uint256 internal constant DexT1__SwapAndArbitragePaused = 51043;\n\n    uint256 internal constant DexT1__ExceedsAmountInMax = 51044;\n\n    /// @notice thrown if amount in is too high or too low\n    uint256 internal constant DexT1__SwapInLimitingAmounts = 51045;\n\n    /// @notice thrown if amount out is too high or too low\n    uint256 internal constant DexT1__SwapOutLimitingAmounts = 51046;\n\n    uint256 internal constant DexT1__MintAmtOverflow = 51047;\n\n    uint256 internal constant DexT1__BurnAmtOverflow = 51048;\n\n    uint256 internal constant DexT1__LimitingAmountsSwapAndNonPerfectActions = 51049;\n\n    uint256 internal constant DexT1__InsufficientOracleData = 51050;\n\n    uint256 internal constant DexT1__SharesAmountInsufficient = 51051;\n\n    uint256 internal constant DexT1__CenterPriceOutOfRange = 51052;\n\n    uint256 internal constant DexT1__DebtReservesTooLow = 51053;\n\n    uint256 internal constant DexT1__SwapAndDepositTooLowOrTooHigh = 51054;\n\n    uint256 internal constant DexT1__WithdrawAndSwapTooLowOrTooHigh = 51055;\n\n    uint256 internal constant DexT1__BorrowAndSwapTooLowOrTooHigh = 51056;\n\n    uint256 internal constant DexT1__SwapAndPaybackTooLowOrTooHigh = 51057;\n\n    uint256 internal constant DexT1__InvalidImplementation = 51058;\n\n    uint256 internal constant DexT1__OnlyDelegateCallAllowed = 51059;\n\n    uint256 internal constant DexT1__IncorrectDataLength = 51060;\n\n    uint256 internal constant DexT1__AmountToSendLessThanAmount = 51061;\n\n    uint256 internal constant DexT1__InvalidCollateralReserves = 51062;\n\n    uint256 internal constant DexT1__InvalidDebtReserves = 51063;\n\n    uint256 internal constant DexT1__SupplySharesOverflow = 51064;\n\n    uint256 internal constant DexT1__BorrowSharesOverflow = 51065;\n\n    uint256 internal constant DexT1__OracleNotActive = 51066;\n\n    /***********************************|\n    |            DEX Admin              | \n    |__________________________________*/\n\n    /// @notice thrown when pool is not initialized\n    uint256 internal constant DexT1Admin__PoolNotInitialized = 52001;\n\n    uint256 internal constant DexT1Admin__SmartColIsAlreadyOn = 52002;\n\n    uint256 internal constant DexT1Admin__SmartDebtIsAlreadyOn = 52003;\n\n    /// @notice thrown when any of the configs value overflow the maximum limit\n    uint256 internal constant DexT1Admin__ConfigOverflow = 52004;\n\n    uint256 internal constant DexT1Admin__AddressNotAContract = 52005;\n\n    uint256 internal constant DexT1Admin__InvalidParams = 52006;\n\n    uint256 internal constant DexT1Admin__UserNotDefined = 52007;\n\n    uint256 internal constant DexT1Admin__OnlyDelegateCallAllowed = 52008;\n\n    uint256 internal constant DexT1Admin__UnexpectedPoolState = 52009;\n\n    /// @notice thrown when trying to pause or unpause but user is already in the target pause state\n    uint256 internal constant DexT1Admin__InvalidPauseToggle = 52009;\n\n    /***********************************|\n    |            DEX Factory            | \n    |__________________________________*/\n\n    uint256 internal constant DexFactory__InvalidOperation = 53001;\n    uint256 internal constant DexFactory__Unauthorized = 53002;\n    uint256 internal constant DexFactory__SameTokenNotAllowed = 53003;\n    uint256 internal constant DexFactory__TokenConfigNotProper = 53004;\n    uint256 internal constant DexFactory__InvalidParams = 53005;\n    uint256 internal constant DexFactory__OnlyDelegateCallAllowed = 53006;\n    uint256 internal constant DexFactory__InvalidDexAddress = 53007;\n\n    /***********************************|\n    |            Smart Lending          | \n    |__________________________________*/\n\n    uint256 internal constant SmartLending__ZeroAddress = 54001;\n    uint256 internal constant SmartLending__Unauthorized = 54002;\n    uint256 internal constant SmartLending__InvalidMsgValue = 54003;\n    uint256 internal constant SmartLending__OutOfRange = 54004;\n    uint256 internal constant SmartLending__InvalidRebalancer = 54005;\n    uint256 internal constant SmartLending__Reentrancy = 54006;\n    uint256 internal constant SmartLending__InvalidAmounts = 54007;\n\n    /***********************************|\n    |        Smart Lending Factory       | \n    |__________________________________*/\n\n    uint256 internal constant SmartLendingFactory__ZeroAddress = 55001;\n    uint256 internal constant SmartLendingFactory__Unauthorized = 55002;\n    uint256 internal constant SmartLendingFactory__AlreadyDeployed = 55003;\n    uint256 internal constant SmartLendingFactory__InvalidParams = 55004;\n    uint256 internal constant SmartLendingFactory__InvalidOperation = 55005;\n}\n"
    },
    "contracts/protocols/dex/factory/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Owned } from \"solmate/src/auth/Owned.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { StorageRead } from \"../../../libraries/storageRead.sol\";\n\nabstract contract DexFactoryVariables is Owned, StorageRead, Error {\n    /*//////////////////////////////////////////////////////////////\n                          STORAGE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    // ------------ storage variables from inherited contracts (Owned) come before vars here --------\n\n    // ----------------------- slot 0 ---------------------------\n    // address public owner; // from Owned\n\n    // 12 bytes empty\n\n    // ----------------------- slot 1  ---------------------------\n    /// @dev deployer can deploy new Dex Pool contract\n    /// owner can add/remove deployer.\n    /// Owner is deployer by default.\n    mapping(address => bool) internal _deployers;\n\n    // ----------------------- slot 2  ---------------------------\n    /// @dev global auths can update any dex pool config.\n    /// owner can add/remove global auths.\n    /// Owner is global auth by default.\n    mapping(address => bool) internal _globalAuths;\n\n    // ----------------------- slot 3  ---------------------------\n    /// @dev dex auths can update specific dex config.\n    /// owner can add/remove dex auths.\n    /// Owner is dex auth by default.\n    /// dex => auth => add/remove\n    mapping(address => mapping(address => bool)) internal _dexAuths;\n\n    // ----------------------- slot 4 ---------------------------\n    /// @dev total no of dexes deployed by the factory\n    /// only addresses that have deployer role or owner can deploy new dex pool.\n    uint256 internal _totalDexes;\n\n    // ----------------------- slot 5 ---------------------------\n    /// @dev dex deployment logics for deploying dex pool\n    /// These logic contracts hold the deployment logics of specific dexes and are called via .delegatecall inside deployDex().\n    /// only addresses that have owner can add/remove new dex deployment logic.\n    mapping(address => bool) internal _dexDeploymentLogics;\n\n    /*//////////////////////////////////////////////////////////////\n                          CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    constructor(address owner_) Owned(owner_) {}\n}\n\nabstract contract DexFactoryEvents {\n    /// @dev Emitted when a new dex is deployed.\n    /// @param dex The address of the newly deployed dex.\n    /// @param dexId The id of the newly deployed dex.\n    event LogDexDeployed(address indexed dex, uint256 indexed dexId);\n\n    /// @dev Emitted when the deployer is modified by owner.\n    /// @param deployer Address whose deployer status is updated.\n    /// @param allowed Indicates whether the address is authorized as a deployer or not.\n    event LogSetDeployer(address indexed deployer, bool indexed allowed);\n\n    /// @dev Emitted when the globalAuth is modified by owner.\n    /// @param globalAuth Address whose globalAuth status is updated.\n    /// @param allowed Indicates whether the address is authorized as a deployer or not.\n    event LogSetGlobalAuth(address indexed globalAuth, bool indexed allowed);\n\n    /// @dev Emitted when the dexAuth is modified by owner.\n    /// @param dexAuth Address whose dexAuth status is updated.\n    /// @param allowed Indicates whether the address is authorized as a deployer or not.\n    /// @param dex Address of the specific dex related to the authorization change.\n    event LogSetDexAuth(address indexed dexAuth, bool indexed allowed, address indexed dex);\n\n    /// @dev Emitted when the dex deployment logic is modified by owner.\n    /// @param dexDeploymentLogic The address of the dex deployment logic contract.\n    /// @param allowed  Indicates whether the address is authorized as a deployer or not.\n    event LogSetDexDeploymentLogic(address indexed dexDeploymentLogic, bool indexed allowed);\n}\n\nabstract contract DexFactoryCore is DexFactoryVariables, DexFactoryEvents {\n    constructor(address owner_) validAddress(owner_) DexFactoryVariables(owner_) {}\n\n    /// @dev validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidDexFactoryError(ErrorTypes.DexFactory__InvalidParams);\n        }\n        _;\n    }\n}\n\n/// @dev Implements Dex Factory auth-only callable methods. Owner / auths can set various config values and\n/// can define the allow-listed deployers.\nabstract contract DexFactoryAuth is DexFactoryCore {\n    /// @notice                         Sets an address (`deployer_`) as allowed deployer or not.\n    ///                                 This function can only be called by the owner.\n    /// @param deployer_                The address to be set as deployer.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to deploy dexes.\n    function setDeployer(address deployer_, bool allowed_) external onlyOwner validAddress(deployer_) {\n        _deployers[deployer_] = allowed_;\n\n        emit LogSetDeployer(deployer_, allowed_);\n    }\n\n    /// @notice                         Sets an address (`globalAuth_`) as a global authorization or not.\n    ///                                 This function can only be called by the owner.\n    /// @param globalAuth_              The address to be set as global authorization.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to update any dex config.\n    function setGlobalAuth(address globalAuth_, bool allowed_) external onlyOwner validAddress(globalAuth_) {\n        _globalAuths[globalAuth_] = allowed_;\n\n        emit LogSetGlobalAuth(globalAuth_, allowed_);\n    }\n\n    /// @notice                         Sets an address (`dexAuth_`) as allowed dex authorization or not for a specific dex (`dex_`).\n    ///                                 This function can only be called by the owner.\n    /// @param dex_                     The address of the dex for which the authorization is being set.\n    /// @param dexAuth_                 The address to be set as dex authorization.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to update the specific dex config.\n    function setDexAuth(address dex_, address dexAuth_, bool allowed_) external onlyOwner validAddress(dexAuth_) {\n        _dexAuths[dex_][dexAuth_] = allowed_;\n\n        emit LogSetDexAuth(dexAuth_, allowed_, dex_);\n    }\n\n    /// @notice                         Sets an address as allowed dex deployment logic (`deploymentLogic_`) contract or not.\n    ///                                 This function can only be called by the owner.\n    /// @param deploymentLogic_         The address of the dex deployment logic contract to be set.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to deploy new type of dex.\n    function setDexDeploymentLogic(\n        address deploymentLogic_,\n        bool allowed_\n    ) public onlyOwner validAddress(deploymentLogic_) {\n        _dexDeploymentLogics[deploymentLogic_] = allowed_;\n\n        emit LogSetDexDeploymentLogic(deploymentLogic_, allowed_);\n    }\n\n    /// @notice                         Spell allows owner aka governance to do any arbitrary call on factory\n    /// @param target_                  Address to which the call needs to be delegated\n    /// @param data_                    Data to execute at the delegated address\n    function spell(address target_, bytes memory data_) external onlyOwner returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n\n    /// @notice                         Checks if the provided address (`deployer_`) is authorized as a deployer.\n    /// @param deployer_                The address to be checked for deployer authorization.\n    /// @return                         Returns `true` if the address is a deployer, otherwise `false`.\n    function isDeployer(address deployer_) public view returns (bool) {\n        return _deployers[deployer_] || owner == deployer_;\n    }\n\n    /// @notice                         Checks if the provided address (`globalAuth_`) has global dex authorization privileges.\n    /// @param globalAuth_              The address to be checked for global authorization privileges.\n    /// @return                         Returns `true` if the given address has global authorization privileges, otherwise `false`.\n    function isGlobalAuth(address globalAuth_) public view returns (bool) {\n        return _globalAuths[globalAuth_] || owner == globalAuth_;\n    }\n\n    /// @notice                         Checks if the provided address (`dexAuth_`) has dex authorization privileges for the specified dex (`dex_`).\n    /// @param dex_                     The address of the dex to check.\n    /// @param dexAuth_                 The address to be checked for dex authorization privileges.\n    /// @return                         Returns `true` if the given address has dex authorization privileges for the specified dex, otherwise `false`.\n    function isDexAuth(address dex_, address dexAuth_) public view returns (bool) {\n        return _dexAuths[dex_][dexAuth_] || owner == dexAuth_;\n    }\n\n    /// @notice                         Checks if the provided (`dexDeploymentLogic_`) address has authorization for dex deployment.\n    /// @param dexDeploymentLogic_      The address of the dex deploy logic to check for authorization privileges.\n    /// @return                         Returns `true` if the given address has authorization privileges for dex deployment, otherwise `false`.\n    function isDexDeploymentLogic(address dexDeploymentLogic_) public view returns (bool) {\n        return _dexDeploymentLogics[dexDeploymentLogic_];\n    }\n}\n\n/// @dev implements DexFactory deploy dex related methods.\nabstract contract DexFactoryDeployment is DexFactoryCore, DexFactoryAuth {\n    /// @dev                            Deploys a contract using the CREATE opcode with the provided bytecode (`bytecode_`).\n    ///                                 This is an internal function, meant to be used within the contract to facilitate the deployment of other contracts.\n    /// @param bytecode_                The bytecode of the contract to be deployed.\n    /// @return address_                Returns the address of the deployed contract.\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\n        if (bytecode_.length == 0) {\n            revert FluidDexError(ErrorTypes.DexFactory__InvalidOperation);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\n        }\n        if (address_ == address(0)) {\n            revert FluidDexError(ErrorTypes.DexFactory__InvalidOperation);\n        }\n    }\n\n    /// @notice                       Deploys a new dex using the specified deployment logic `dexDeploymentLogic_` and data `dexDeploymentData_`.\n    ///                               Only accounts with deployer access or the owner can deploy a new dex.\n    /// @param dexDeploymentLogic_    The address of the dex deployment logic contract.\n    /// @param dexDeploymentData_     The data to be used for dex deployment.\n    /// @return dex_                  Returns the address of the newly deployed dex.\n    function deployDex(address dexDeploymentLogic_, bytes calldata dexDeploymentData_) external returns (address dex_) {\n        // Revert if msg.sender doesn't have deployer access or is an owner.\n        if (!isDeployer(msg.sender)) revert FluidDexError(ErrorTypes.DexFactory__Unauthorized);\n        // Revert if dexDeploymentLogic_ is not whitelisted.\n        if (!isDexDeploymentLogic(dexDeploymentLogic_)) revert FluidDexError(ErrorTypes.DexFactory__Unauthorized);\n\n        // Dex ID for the new dex and also acts as `nonce` for CREATE\n        uint256 dexId_ = ++_totalDexes;\n\n        // compute dex address for dex id.\n        dex_ = getDexAddress(dexId_);\n\n        // deploy the dex using dex deployment logic by making .delegatecall\n        (bool success_, bytes memory data_) = dexDeploymentLogic_.delegatecall(dexDeploymentData_);\n\n        if (!(success_ && dex_ == _deploy(abi.decode(data_, (bytes))) && isDex(dex_))) {\n            revert FluidDexError(ErrorTypes.DexFactory__InvalidDexAddress);\n        }\n\n        emit LogDexDeployed(dex_, dexId_);\n    }\n\n    /// @notice                       Computes the address of a dex based on its given ID (`dexId_`).\n    /// @param dexId_                 The ID of the dex.\n    /// @return dex_                  Returns the computed address of the dex.\n    function getDexAddress(uint256 dexId_) public view returns (address dex_) {\n        return AddressCalcs.addressCalc(address(this), dexId_);\n    }\n\n    /// @notice                         Checks if a given address (`dex_`) corresponds to a valid dex.\n    /// @param dex_                     The dex address to check.\n    /// @return                         Returns `true` if the given address corresponds to a valid dex, otherwise `false`.\n    function isDex(address dex_) public view returns (bool) {\n        if (dex_.code.length == 0) {\n            return false;\n        } else {\n            // DEX_ID() function signature is 0xf4b9a3fb\n            (bool success_, bytes memory data_) = dex_.staticcall(hex\"f4b9a3fb\");\n            return success_ && dex_ == getDexAddress(abi.decode(data_, (uint256)));\n        }\n    }\n\n    /// @notice                   Returns the total number of dexes deployed by the factory.\n    /// @return                   Returns the total number of dexes.\n    function totalDexes() external view returns (uint256) {\n        return _totalDexes;\n    }\n}\n\n/// @title Fluid DexFactory\n/// @notice creates Fluid dex protocol dexes, which are interacting with Fluid Liquidity to deposit / borrow funds.\n/// Dexes are created at a deterministic address, given an incrementing `dexId` (see `getDexAddress()`).\n/// Dexes can only be deployed by allow-listed deployer addresses.\n/// @dev Note the deployed dexes start out with no config at Liquidity contract.\n/// This must be done by Liquidity auths in a separate step, otherwise no deposits will be possible.\n/// This contract is not upgradeable. It supports adding new dex deployment logic contracts for new, future dexes.\ncontract FluidDexFactory is DexFactoryCore, DexFactoryAuth, DexFactoryDeployment {\n    constructor(address owner_) DexFactoryCore(owner_) {}\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexFactory {\n    /// @notice Global auth is auth for all dexes\n    function isGlobalAuth(address auth_) external view returns (bool);\n\n    /// @notice Dex auth is auth for a specific dex\n    function isDexAuth(address vault_, address auth_) external view returns (bool);\n\n    /// @notice Total dexes deployed.\n    function totalDexes() external view returns (uint256);\n\n    /// @notice Compute dexAddress\n    function getDexAddress(uint256 dexId_) external view returns (address);\n\n    /// @notice read uint256 `result_` for a storage `slot_` key\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexT1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexT1 {\n    error FluidDexError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares);\n\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\n\n    /// @notice returns the dex id\n    function DEX_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndOracle;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) external view returns (CollateralReserves memory c_);\n\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) external view returns (DebtReserves memory d_);\n\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\n    function getPricesAndExchangePrices() external;\n\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount in and callback functionality\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of tokens to swap in\n    /// @param amountOutMin_ The minimum amount of tokens to receive after swap\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapInWithCallback(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Swap tokens with perfect amount out and callback functionality\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOutWithCallback(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(uint token0Amt_, uint token1Amt_, uint maxSharesAmt_, address to_) external returns (uint shares_);\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) external returns (uint withdrawAmt_);\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) external payable returns (uint paybackAmt_);\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(uint[] memory secondsAgos_) external view returns (Oracle[] memory twaps_, uint currentPrice_);\n}\n"
    },
    "contracts/protocols/dex/poolT1/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct InitializeVariables {\n        bool smartCol;\n        uint token0ColAmt;\n        bool smartDebt;\n        uint token0DebtAmt;\n        uint centerPrice;\n        uint fee;\n        uint revenueCut;\n        uint upperPercent;\n        uint lowerPercent;\n        uint upperShiftThreshold;\n        uint lowerShiftThreshold;\n        uint thresholdShiftTime;\n        uint centerPriceAddress;\n        uint hookAddress;\n        uint maxCenterPrice;\n        uint minCenterPrice;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct ExchangePrices {\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct CollateralReservesSwap {\n        uint tokenInRealReserves;\n        uint tokenOutRealReserves;\n        uint tokenInImaginaryReserves;\n        uint tokenOutImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReservesSwap {\n        uint tokenInDebt;\n        uint tokenOutDebt;\n        uint tokenInRealReserves;\n        uint tokenOutRealReserves;\n        uint tokenInImaginaryReserves;\n        uint tokenOutImaginaryReserves;\n    }\n\n    struct SwapInMemory {\n        address tokenIn;\n        address tokenOut;\n        uint256 amtInAdjusted;\n        address withdrawTo;\n        address borrowTo;\n        uint price; // price of pool after swap\n        uint fee; // fee of pool\n        uint revenueCut; // revenue cut of pool\n        bool swap0to1;\n        int swapRoutingAmt;\n        bytes data; // just added to avoid stack-too-deep error\n    }\n\n    struct SwapOutMemory {\n        address tokenIn;\n        address tokenOut;\n        uint256 amtOutAdjusted;\n        address withdrawTo;\n        address borrowTo;\n        uint price; // price of pool after swap\n        uint fee;\n        uint revenueCut; // revenue cut of pool\n        bool swap0to1;\n        int swapRoutingAmt;\n        bytes data; // just added to avoid stack-too-deep error\n        uint msgValue;\n    }\n\n    struct DepositColMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0ReservesInitial;\n        uint256 token1ReservesInitial;\n    }\n\n    struct WithdrawColMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0ReservesInitial;\n        uint256 token1ReservesInitial;\n        address to;\n    }\n\n    struct BorrowDebtMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0DebtInitial;\n        uint256 token1DebtInitial;\n        address to;\n    }\n\n    struct PaybackDebtMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0DebtInitial;\n        uint256 token1DebtInitial;\n    }\n\n    struct OraclePriceMemory {\n        uint lowestPrice1by0;\n        uint highestPrice1by0;\n        uint oracleSlot;\n        uint oracleMap;\n        uint oracle;\n    }\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndSwapOut;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n}\n"
    },
    "contracts/protocols/dex/smartLending/factory/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Owned } from \"solmate/src/auth/Owned.sol\";\nimport { SSTORE2 } from \"solmate/src/utils/SSTORE2.sol\";\nimport { CREATE3 } from \"solmate/src/utils/CREATE3.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\n\nabstract contract Constants {\n    address public immutable DEX_FACTORY;\n    address public immutable LIQUIDITY;\n}\n\nabstract contract Variables is Owned {\n    // ------------ storage variables from inherited contracts (Owned) come before vars here --------\n\n    // ----------------------- slot 0 ---------------------------\n    // address public owner;\n\n    // 12 bytes empty\n\n    // ----------------------- slot 1  ---------------------------\n    /// @dev smart lending auths can update specific configs.\n    /// owner can add/remove auths.\n    /// Owner is auth by default.\n    mapping(address => mapping(address => uint256)) internal _smartLendingAuths;\n\n    // ----------------------- slot 2 ---------------------------\n    /// @dev deployers can deploy new smartLendings.\n    /// owner can add/remove deployers.\n    /// Owner is deployer by default.\n    mapping(address => uint256) internal _deployers;\n\n    // ----------------------- slot 3 ---------------------------\n    /// @notice list of all created tokens.\n    /// @dev Solidity creates an automatic getter only to fetch at a certain position, so explicitly define a getter that returns all.\n    address[] public createdTokens;\n\n    // ----------------------- slot 4 ---------------------------\n\n    /// @dev smart lending creation code, accessed via SSTORE2.\n    address internal _smartLendingCreationCodePointer;\n\n    /*//////////////////////////////////////////////////////////////\n                          CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address owner_) Owned(owner_) {}\n}\n\nabstract contract Events {\n    /// @dev Emitted when a new smart lending is deployed\n    /// @param dexId The ID of the deployed DEX\n    /// @param smartLending The address of the deployed smart lending\n    event LogSmartLendingDeployed(uint256 dexId, address smartLending);\n\n    /// @dev Emitted when a SmartLending auth is updated\n    /// @param smartLending address of SmartLending\n    /// @param auth address of auth whose status is being updated\n    /// @param allowed updated status of auth\n    event LogAuthUpdated(address smartLending, address auth, bool allowed);\n\n    /// @dev Emitted when a deployer is modified by owner\n    /// @param deployer address of deployer\n    /// @param allowed updated status of deployer\n    event LogDeployerUpdated(address deployer, bool allowed);\n\n    /// @dev Emitted when the smart lending creation code is modified by owner\n    /// @param creationCodePointer address of the creation code pointer\n    event LogSetCreationCode(address creationCodePointer);\n}\n\ncontract FluidSmartLendingFactory is Constants, Variables, Events, Error {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidSmartLendingFactoryError(ErrorTypes.SmartLendingFactory__ZeroAddress);\n        }\n        _;\n    }\n\n    constructor(\n        address dexFactory_,\n        address liquidity_,\n        address owner_\n    ) validAddress(dexFactory_) validAddress(liquidity_) validAddress(owner_) Variables(owner_) {\n        LIQUIDITY = liquidity_;\n        DEX_FACTORY = dexFactory_;\n    }\n\n    /// @dev Validates that msg.sender is deployer or owner\n    modifier onlyDeployers() {\n        if (!isDeployer(msg.sender)) {\n            revert FluidSmartLendingFactoryError(ErrorTypes.SmartLendingFactory__Unauthorized);\n        }\n        _;\n    }\n\n    /// @notice List of all created tokens\n    function allTokens() public view returns (address[] memory) {\n        return createdTokens;\n    }\n\n    /// @notice Reads if a certain `auth_` address is an allowed auth for `smartLending_` or not. Owner is auth by default.\n    function isSmartLendingAuth(address smartLending_, address auth_) public view returns (bool) {\n        return auth_ == owner || _smartLendingAuths[smartLending_][auth_] == 1;\n    }\n\n    /// @notice Reads if a certain `deployer_` address is an allowed deployer or not. Owner is deployer by default.\n    function isDeployer(address deployer_) public view returns (bool) {\n        return deployer_ == owner || _deployers[deployer_] == 1;\n    }\n\n    /// @dev Retrieves the creation code for the SmartLending contract\n    function smartLendingCreationCode() public view returns (bytes memory) {\n        return SSTORE2.read(_smartLendingCreationCodePointer);\n    }\n\n    /// @notice Sets an address as allowed deployer or not. Only callable by owner.\n    /// @param deployer_ Address to set deployer value for\n    /// @param allowed_ Bool flag for whether address is allowed as deployer or not\n    function updateDeployer(address deployer_, bool allowed_) external onlyOwner validAddress(deployer_) {\n        _deployers[deployer_] = allowed_ ? 1 : 0;\n\n        emit LogDeployerUpdated(deployer_, allowed_);\n    }\n\n    /// @notice Updates the authorization status of an address for a SmartLending contract. Only callable by owner.\n    /// @param smartLending_ The address of the SmartLending contract\n    /// @param auth_ The address to be updated\n    /// @param allowed_ The new authorization status\n    function updateSmartLendingAuth(\n        address smartLending_,\n        address auth_,\n        bool allowed_\n    ) external validAddress(smartLending_) validAddress(auth_) onlyOwner {\n        _smartLendingAuths[smartLending_][auth_] = allowed_ ? 1 : 0;\n\n        emit LogAuthUpdated(smartLending_, auth_, allowed_);\n    }\n\n    /// @notice Sets the `creationCode_` bytecode for new SmartLending contracts. Only callable by owner.\n    /// @param creationCode_ New SmartLending contract creation code.\n    function setSmartLendingCreationCode(bytes calldata creationCode_) external onlyOwner {\n        if (creationCode_.length == 0) {\n            revert FluidSmartLendingFactoryError(ErrorTypes.SmartLendingFactory__InvalidParams);\n        }\n\n        // write creation code to SSTORE2 pointer and set in mapping\n        address creationCodePointer_ = SSTORE2.write(creationCode_);\n        _smartLendingCreationCodePointer = creationCodePointer_;\n\n        emit LogSetCreationCode(creationCodePointer_);\n    }\n\n    /// @notice Spell allows owner aka governance to do any arbitrary call on factory\n    /// @param target_ Address to which the call needs to be delegated\n    /// @param data_ Data to execute at the delegated address\n    function spell(address target_, bytes memory data_) external onlyOwner returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n\n    /// @notice Deploys a new SmartLending contract. Only callable by deployers.\n    /// @param dexId_ The ID of the DEX for which the smart lending wrapper is being deployed\n    /// @return smartLending_ The newly deployed SmartLending contract\n    function deploy(uint256 dexId_) public onlyDeployers returns (address smartLending_) {\n        if (getSmartLendingAddress(dexId_).code.length != 0) {\n            revert FluidSmartLendingFactoryError(ErrorTypes.SmartLendingFactory__AlreadyDeployed);\n        }\n\n        // Use CREATE3 for deterministic deployments. Unfortunately it has 55k gas overhead\n        smartLending_ = CREATE3.deploy(\n            _getSalt(dexId_),\n            abi.encodePacked(\n                SSTORE2.read(_smartLendingCreationCodePointer), // creation code\n                abi.encode(dexId_, LIQUIDITY, DEX_FACTORY, address(this)) // constructor params\n            ),\n            0\n        );\n\n        createdTokens.push(smartLending_); // Add the created token to the allTokens array\n\n        emit LogSmartLendingDeployed(dexId_, smartLending_);\n    }\n\n    /// @notice Computes the address of a SmartLending contract based on a given dexId.\n    /// @param dexId_ The ID of the DEX for which the SmartLending contract address is being computed.\n    /// @return The computed address of the SmartLending contract.\n    function getSmartLendingAddress(uint256 dexId_) public view returns (address) {\n        return CREATE3.getDeployed(_getSalt(dexId_));\n    }\n\n    /// @notice Returns the total number of SmartLending contracts deployed by the factory.\n    /// @return The total number of SmartLending contracts deployed.\n    function totalSmartLendings() external view returns (uint256) {\n        return createdTokens.length;\n    }\n\n    /// @notice                         Checks if a given address (`smartLending_`) corresponds to a valid smart lending.\n    /// @param smartLending_            The smart lending address to check.\n    /// @return                         Returns `true` if the given address corresponds to a valid smart lending, otherwise `false`.\n    function isSmartLending(address smartLending_) public view returns (bool) {\n        if (smartLending_.code.length == 0) {\n            return false;\n        } else {\n            // DEX() function signature is 0x80935aa9\n            (bool success_, bytes memory data_) = smartLending_.staticcall(hex\"80935aa9\");\n            address dex_ = abi.decode(data_, (address));\n            // DEX_ID() function signature is 0xf4b9a3fb\n            (success_, data_) = dex_.staticcall(hex\"f4b9a3fb\");\n            return success_ && smartLending_ == getSmartLendingAddress(abi.decode(data_, (uint256)));\n        }\n    }\n\n    /// @dev unique deployment salt for the smart lending\n    function _getSalt(uint256 dexId_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(dexId_));\n    }\n\n    /// @dev Deploys a contract using the CREATE opcode with the provided bytecode (`bytecode_`).\n    /// This is an internal function, meant to be used within the contract to facilitate the deployment of other contracts.\n    /// @param bytecode_ The bytecode of the contract to be deployed.\n    /// @return address_ Returns the address of the deployed contract.\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\n        if (bytecode_.length == 0) {\n            revert FluidDexError(ErrorTypes.SmartLendingFactory__InvalidOperation);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\n        }\n        if (address_ == address(0)) {\n            revert FluidDexError(ErrorTypes.SmartLendingFactory__InvalidOperation);\n        }\n    }\n}\n"
    },
    "contracts/protocols/dex/smartLending/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { IFluidDexT1 } from \"../interfaces/iDexT1.sol\";\nimport { FluidDexFactory } from \"../factory/main.sol\";\nimport { FluidSmartLendingFactory } from \"./factory/main.sol\";\nimport { SafeTransfer } from \"../../../libraries/safeTransfer.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\nimport { DexSlotsLink } from \"../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../libraries/dexCalcs.sol\";\n\nabstract contract Constants {\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address internal constant DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n\n    FluidDexFactory public immutable DEX_FACTORY;\n\n    FluidSmartLendingFactory public immutable SMART_LENDING_FACTORY;\n\n    IFluidDexT1 public immutable DEX;\n\n    address public immutable LIQUIDITY;\n\n    address public immutable TOKEN0;\n\n    address public immutable TOKEN1;\n\n    bool public immutable IS_NATIVE_PAIR;\n}\n\nabstract contract Variables is ERC20, Constants {\n    // ------------ storage variables from inherited contracts come before vars here --------\n    // _________ ERC20 _______________\n    // ----------------------- slot 0 ---------------------------\n    // mapping(address => uint256) private _balances;\n\n    // ----------------------- slot 1 ---------------------------\n    // mapping(address => mapping(address => uint256)) private _allowances;\n\n    // ----------------------- slot 2 ---------------------------\n    // uint256 private _totalSupply;\n\n    // ----------------------- slot 3 ---------------------------\n    // string private _name;\n    // ----------------------- slot 4 ---------------------------\n    // string private _symbol;\n\n    // ------------ storage variables ------------------------------------------------------\n\n    // ----------------------- slot 5 ---------------------------\n    uint40 public lastTimestamp;\n    /// If positive then rewards, if negative then fee.\n    /// 1e6 = 100%, 1e4 = 1%, minimum 0.0001% fee or reward.\n    int32 public feeOrReward;\n    // Starting from 1e18\n    // If fees then reduce exchange price\n    // If reward then increase exchange price\n    uint184 public exchangePrice;\n\n    // ----------------------- slot 6 ---------------------------\n    address public rebalancer;\n\n    // ----------------------- slot 7 ---------------------------\n    address public dexFromAddress;\n\n    /// @dev status for reentrancy guard\n    uint8 internal _status;\n}\n\nabstract contract Events {\n    /// @dev Emitted when the share to tokens ratio is rebalanced\n    /// @param shares_ The number of shares rebalanced\n    /// @param token0Amt_ The amount of token0 rebalanced\n    /// @param token1Amt_ The amount of token1 rebalanced\n    /// @param isWithdraw_ Whether the rebalance is a withdrawal or deposit\n    event LogRebalance(uint256 shares_, uint256 token0Amt_, uint256 token1Amt_, bool isWithdraw_);\n\n    /// @dev Emitted when the rebalancer is set\n    /// @param rebalancer The new rebalancer\n    event LogRebalancerSet(address rebalancer);\n\n    /// @dev Emitted when the fee or reward is set\n    /// @param feeOrReward The new fee or reward\n    event LogFeeOrRewardSet(int256 feeOrReward);\n}\n\n/// @dev ReentrancyGuard based on OpenZeppelin implementation.\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.8/contracts/security/ReentrancyGuard.sol\nabstract contract ReentrancyGuard is Variables, Error {\n    uint8 internal constant REENTRANCY_NOT_ENTERED = 1;\n    uint8 internal constant REENTRANCY_ENTERED = 2;\n\n    constructor() {\n        _status = REENTRANCY_NOT_ENTERED;\n    }\n\n    /// @dev Prevents a contract from calling itself, directly or indirectly.\n    /// See OpenZeppelin implementation for more info\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status != REENTRANCY_NOT_ENTERED) {\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__Reentrancy);\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = REENTRANCY_ENTERED;\n\n        _;\n\n        // storing original value triggers a refund (see https://eips.ethereum.org/EIPS/eip-2200)\n        _status = REENTRANCY_NOT_ENTERED;\n    }\n}\n\ncontract FluidSmartLending is ERC20, Variables, Error, ReentrancyGuard, Events {\n    /// @dev prefix for token name. constructor appends dex id, e.g. \"Fluid Smart Lending 12\"\n    string private constant TOKEN_NAME_PREFIX = \"Fluid Smart Lending \";\n    /// @dev prefix for token symbol. constructor appends dex id, e.g. \"fSL12\"\n    string private constant TOKEN_SYMBOL_PREFIX = \"fSL\";\n\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__ZeroAddress);\n        }\n        _;\n    }\n\n    constructor(\n        uint256 dexId_,\n        address liquidity_,\n        address dexFactory_,\n        address smartLendingFactory_\n    )\n        ERC20(\n            string(abi.encodePacked(TOKEN_NAME_PREFIX, _toString(dexId_))),\n            string(abi.encodePacked(TOKEN_SYMBOL_PREFIX, _toString(dexId_)))\n        )\n        validAddress(liquidity_)\n        validAddress(dexFactory_)\n        validAddress(smartLendingFactory_)\n    {\n        LIQUIDITY = liquidity_;\n        DEX_FACTORY = FluidDexFactory(dexFactory_);\n        SMART_LENDING_FACTORY = FluidSmartLendingFactory(smartLendingFactory_);\n        DEX = IFluidDexT1(DEX_FACTORY.getDexAddress(dexId_));\n        IFluidDexT1.ConstantViews memory constants_ = DEX.constantsView();\n        TOKEN0 = constants_.token0;\n        TOKEN1 = constants_.token1;\n        IS_NATIVE_PAIR = (TOKEN0 == ETH_ADDRESS) || (TOKEN1 == ETH_ADDRESS);\n\n        exchangePrice = uint184(1e18);\n        feeOrReward = int32(0);\n        lastTimestamp = uint40(block.timestamp);\n\n        dexFromAddress = DEAD_ADDRESS;\n    }\n\n    modifier setDexFrom() {\n        dexFromAddress = msg.sender;\n        _;\n        dexFromAddress = DEAD_ADDRESS;\n    }\n\n    modifier onlyAuth() {\n        if (!SMART_LENDING_FACTORY.isSmartLendingAuth(address(this), msg.sender)) {\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__Unauthorized);\n        }\n        _;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != SMART_LENDING_FACTORY.owner()) {\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__Unauthorized);\n        }\n        _;\n    }\n\n    modifier _updateExchangePrice() {\n        bool rewardsOrFeeActive_;\n        (exchangePrice, rewardsOrFeeActive_) = getUpdateExchangePrice();\n        if (rewardsOrFeeActive_) {\n            lastTimestamp = uint40(block.timestamp); // only write to storage if fee or reward is active.\n        }\n        _;\n    }\n\n    /// @notice gets updated exchange price\n    function getUpdateExchangePrice() public view returns (uint184 exchangePrice_, bool rewardsOrFeeActive_) {\n        int256 feeOrReward_ = feeOrReward;\n        exchangePrice_ = exchangePrice;\n        if (feeOrReward_ > 0) {\n            exchangePrice_ =\n                exchangePrice_ +\n                uint184(\n                    (exchangePrice_ * uint256(feeOrReward_) * (block.timestamp - uint256(lastTimestamp))) /\n                        (1e6 * SECONDS_PER_YEAR)\n                );\n            rewardsOrFeeActive_ = true;\n        } else if (feeOrReward_ < 0) {\n            exchangePrice_ =\n                exchangePrice_ -\n                uint184(\n                    (exchangePrice_ * uint256(-feeOrReward_) * (block.timestamp - uint256(lastTimestamp))) /\n                        (1e6 * SECONDS_PER_YEAR)\n                );\n            rewardsOrFeeActive_ = true;\n        }\n    }\n\n    /// @notice triggers updateExchangePrice\n    function updateExchangePrice() public _updateExchangePrice {}\n\n    /// @dev Set the fee or reward. Only callable by auths.\n    /// @param feeOrReward_ The new fee or reward (1e6 = 100%, 1e4 = 1%, minimum 0.0001% fee or reward). 0 means no fee or reward\n    function setFeeOrReward(int256 feeOrReward_) external onlyAuth _updateExchangePrice {\n        if (feeOrReward_ > 1e6 || feeOrReward_ < -1e6) {\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__OutOfRange);\n        }\n        lastTimestamp = uint40(block.timestamp); // current fee or reward setting is applied until exactly now even if previously 0\n        feeOrReward = int32(feeOrReward_);\n\n        emit LogFeeOrRewardSet(feeOrReward_);\n    }\n\n    /// @dev Set the rebalancer. Only callable by auths.\n    /// @param rebalancer_ The new rebalancer\n    function setRebalancer(address rebalancer_) external onlyAuth validAddress(rebalancer_) {\n        rebalancer = rebalancer_;\n\n        emit LogRebalancerSet(rebalancer_);\n    }\n\n    /// @notice                         Spell allows auths (governance) to do any arbitrary call\n    /// @param target_                  Address to which the call needs to be delegated\n    /// @param data_                    Data to execute at the delegated address\n    function spell(address target_, bytes memory data_) external onlyOwner returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param to_ Recipient of minted tokens. If to_ == address(0) then out tokens will be sent to msg.sender.\n    /// @return amount_ Amount of tokens minted\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint256 shares_,\n        uint256 maxToken0Deposit_,\n        uint256 maxToken1Deposit_,\n        address to_\n    )\n        external\n        payable\n        setDexFrom\n        _updateExchangePrice\n        nonReentrant\n        returns (uint256 amount_, uint256 token0Amt_, uint256 token1Amt_)\n    {\n        if (!IS_NATIVE_PAIR) {\n            if (msg.value > 0) {\n                revert FluidSmartLendingError(ErrorTypes.SmartLending__InvalidMsgValue);\n            }\n\n            (token0Amt_, token1Amt_) = DEX.depositPerfect(\n                shares_ + 1, // + 1 rounding up but only minting shares\n                maxToken0Deposit_,\n                maxToken1Deposit_,\n                false\n            );\n        } else {\n            uint256 value_ = TOKEN0 == ETH_ADDRESS ? maxToken0Deposit_ : maxToken1Deposit_;\n            if (value_ > msg.value) {\n                revert FluidSmartLendingError(ErrorTypes.SmartLending__InvalidMsgValue);\n            }\n\n            uint256 initialEthAmount_ = address(this).balance - msg.value;\n\n            (token0Amt_, token1Amt_) = DEX.depositPerfect{ value: value_ }(\n                shares_ + 1, // + 1 rounding up but only minting shares\n                maxToken0Deposit_,\n                maxToken1Deposit_,\n                false\n            );\n\n            uint finalEth_ = payable(address(this)).balance;\n            if (finalEth_ > initialEthAmount_) {\n                unchecked {\n                    SafeTransfer.safeTransferNative(msg.sender, finalEth_ - initialEthAmount_); // sending back excess ETH\n                }\n            }\n        }\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        amount_ = (shares_ * 1e18) / exchangePrice;\n\n        _mint(to_, amount_);\n    }\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param to_ Recipient of minted tokens. If to_ == address(0) then out tokens will be sent to msg.sender.\n    /// @return amount_ The amount of tokens minted for the deposit\n    /// @return shares_ The number of dex pool shares deposited\n    function deposit(\n        uint256 token0Amt_,\n        uint256 token1Amt_,\n        uint256 minSharesAmt_,\n        address to_\n    ) external payable setDexFrom _updateExchangePrice nonReentrant returns (uint256 amount_, uint256 shares_) {\n        uint256 value_ = !IS_NATIVE_PAIR\n            ? 0\n            : (TOKEN0 == ETH_ADDRESS)\n                ? token0Amt_\n                : token1Amt_;\n\n        if (value_ != msg.value) {\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__InvalidMsgValue);\n        }\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        shares_ = DEX.deposit{ value: value_ }(token0Amt_, token1Amt_, minSharesAmt_, false);\n\n        amount_ = (shares_ * 1e18) / exchangePrice - 1;\n\n        _mint(to_, amount_);\n    }\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw. set to type(uint).max to withdraw maximum balance.\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of withdrawn tokens. If to_ == address(0) then out tokens will be sent to msg.sender.\n    /// @return amount_ amount_ of shares actually burnt\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint256 shares_,\n        uint256 minToken0Withdraw_,\n        uint256 minToken1Withdraw_,\n        address to_\n    ) external _updateExchangePrice nonReentrant returns (uint256 amount_, uint256 token0Amt_, uint256 token1Amt_) {\n        if (shares_ == type(uint).max) {\n            amount_ = balanceOf(msg.sender);\n            shares_ = (amount_ * exchangePrice) / 1e18 - 1;\n        } else {\n            amount_ = (shares_ * 1e18) / exchangePrice + 1;\n        }\n\n        _burn(msg.sender, amount_);\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        if (minToken0Withdraw_ > 0 && minToken1Withdraw_ > 0) {\n            (token0Amt_, token1Amt_) = DEX.withdrawPerfect(shares_, minToken0Withdraw_, minToken1Withdraw_, to_);\n        } else if (minToken0Withdraw_ > 0 && minToken1Withdraw_ == 0) {\n            // withdraw only in token0, token1Amt_ remains 0\n            (token0Amt_) = DEX.withdrawPerfectInOneToken(shares_, minToken0Withdraw_, minToken1Withdraw_, to_);\n        } else if (minToken0Withdraw_ == 0 && minToken1Withdraw_ > 0) {\n            // withdraw only in token1, token0Amt_ remains 0\n            (token1Amt_) = DEX.withdrawPerfectInOneToken(shares_, minToken0Withdraw_, minToken1Withdraw_, to_);\n        } else {\n            // meaning user sent both amounts as == 0\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__InvalidAmounts);\n        }\n    }\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of withdrawn tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return amount_ The number of tokens burned for the withdrawal\n    /// @return shares_ The number of dex pool shares withdrawn\n    function withdraw(\n        uint256 token0Amt_,\n        uint256 token1Amt_,\n        uint256 maxSharesAmt_,\n        address to_\n    ) external _updateExchangePrice nonReentrant returns (uint256 amount_, uint256 shares_) {\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        shares_ = DEX.withdraw(token0Amt_, token1Amt_, maxSharesAmt_, to_);\n\n        amount_ = (shares_ * 1e18) / exchangePrice + 1;\n\n        _burn(msg.sender, amount_);\n    }\n\n    /// @dev Rebalances the share to tokens ratio to balance out rewards and fees\n    function rebalance(\n        uint256 minOrMaxToken0_,\n        uint256 minOrMaxToken1_\n    )\n        public\n        payable\n        _updateExchangePrice\n        nonReentrant\n        returns (uint256 shares_, uint256 token0Amt_, uint256 token1Amt_, bool isWithdraw_)\n    {\n        if (rebalancer != msg.sender) revert FluidSmartLendingError(ErrorTypes.SmartLending__InvalidRebalancer);\n\n        int256 rebalanceDiff_ = rebalanceDiff();\n\n        if (rebalanceDiff_ > 0) {\n            // fees (withdraw)\n            isWithdraw_ = true;\n            if (msg.value > 0) {\n                revert FluidSmartLendingError(ErrorTypes.SmartLending__InvalidMsgValue);\n            }\n            shares_ = uint256(rebalanceDiff_);\n            (token0Amt_, token1Amt_) = DEX.withdrawPerfect(shares_, minOrMaxToken0_, minOrMaxToken1_, msg.sender);\n        } else if (rebalanceDiff_ < 0) {\n            // rewards (deposit)\n            isWithdraw_ = false;\n\n            uint256 initialEthAmount_ = address(this).balance - msg.value;\n\n            uint256 value_ = !IS_NATIVE_PAIR\n                ? 0\n                : (TOKEN0 == ETH_ADDRESS)\n                    ? minOrMaxToken0_\n                    : minOrMaxToken1_;\n\n            if (value_ > msg.value) {\n                revert FluidSmartLendingError(ErrorTypes.SmartLending__InvalidMsgValue);\n            }\n\n            shares_ = uint256(-rebalanceDiff_);\n\n            dexFromAddress = msg.sender;\n            (token0Amt_, token1Amt_) = DEX.depositPerfect{ value: value_ }(\n                shares_,\n                minOrMaxToken0_,\n                minOrMaxToken1_,\n                false\n            );\n            dexFromAddress = DEAD_ADDRESS;\n\n            uint finalEth_ = payable(address(this)).balance;\n            if (finalEth_ > initialEthAmount_) {\n                unchecked {\n                    SafeTransfer.safeTransferNative(msg.sender, finalEth_ - initialEthAmount_); // sending back excess ETH\n                }\n            }\n        }\n\n        emit LogRebalance(shares_, token0Amt_, token1Amt_, isWithdraw_);\n    }\n\n    /// @dev Returns the difference between the total smart lending shares on the DEX and the total smart lending shares calculated.\n    /// A positive value indicates fees to collect, while a negative value indicates rewards to be rebalanced.\n    function rebalanceDiff() public view returns (int256) {\n        uint256 totalSmartLendingSharesOnDex_ = DEX.readFromStorage(\n            DexSlotsLink.calculateMappingStorageSlot(DexSlotsLink.DEX_USER_SUPPLY_MAPPING_SLOT, address(this))\n        );\n        totalSmartLendingSharesOnDex_ =\n            (totalSmartLendingSharesOnDex_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) &\n            DexCalcs.X64;\n        totalSmartLendingSharesOnDex_ =\n            (totalSmartLendingSharesOnDex_ >> DexCalcs.DEFAULT_EXPONENT_SIZE) <<\n            (totalSmartLendingSharesOnDex_ & DexCalcs.DEFAULT_EXPONENT_MASK);\n\n        uint256 totalSmartLendingShares_ = (totalSupply() * exchangePrice) / 1e18;\n\n        return int256(totalSmartLendingSharesOnDex_) - int256(totalSmartLendingShares_);\n    }\n\n    /// @notice   dex liquidity callback\n    /// @param    token_ The token being transferred\n    /// @param    amount_ The amount being transferred\n    function dexCallback(address token_, uint256 amount_) external {\n        if (msg.sender != address(DEX)) {\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__Unauthorized);\n        }\n        SafeTransfer.safeTransferFrom(token_, dexFromAddress, LIQUIDITY, amount_);\n    }\n\n    /// @dev for excess eth being sent back from dex to here\n    receive() external payable {\n        if (msg.sender != address(DEX)) {\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__Unauthorized);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     * taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/Math.sol\n     */\n    function _log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     * taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\n     */\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    function _toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = _log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n}\n"
    },
    "contracts/protocols/lending/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Error {\n    error FluidLendingError(uint256 errorId_);\n}\n"
    },
    "contracts/protocols/lending/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |               fToken              | \n    |__________________________________*/\n\n    /// @notice thrown when a deposit amount is too small to increase BigMath stored balance in Liquidity.\n    /// precision of BigMath is 1e12, so if token holds 120_000_000_000 USDC, min amount to make a difference would be 0.1 USDC.\n    /// i.e. user would send a very small deposit which mints no shares -> revert\n    uint256 internal constant fToken__DepositInsignificant = 20001;\n\n    /// @notice thrown when minimum output amount is not reached, e.g. for minimum shares minted (deposit) or\n    ///         minimum assets received (redeem)\n    uint256 internal constant fToken__MinAmountOut = 20002;\n\n    /// @notice thrown when maximum amount is surpassed, e.g. for maximum shares burned (withdraw) or\n    ///         maximum assets input (mint)\n    uint256 internal constant fToken__MaxAmount = 20003;\n\n    /// @notice thrown when invalid params are sent to a method, e.g. zero address\n    uint256 internal constant fToken__InvalidParams = 20004;\n\n    /// @notice thrown when an unauthorized caller is trying to execute an auth-protected method\n    uint256 internal constant fToken__Unauthorized = 20005;\n\n    /// @notice thrown when a with permit / signature method is called from msg.sender that is the owner.\n    /// Should call the method without permit instead if msg.sender is the owner.\n    uint256 internal constant fToken__PermitFromOwnerCall = 20006;\n\n    /// @notice thrown when a reentrancy is detected.\n    uint256 internal constant fToken__Reentrancy = 20007;\n\n    /// @notice thrown when _tokenExchangePrice overflows type(uint64).max\n    uint256 internal constant fToken__ExchangePriceOverflow = 20008;\n\n    /// @notice thrown when msg.sender is not rebalancer\n    uint256 internal constant fToken__NotRebalancer = 20009;\n\n    /// @notice thrown when rebalance is called with msg.value > 0 for non NativeUnderlying fToken\n    uint256 internal constant fToken__NotNativeUnderlying = 20010;\n\n    /// @notice thrown when the received new liquidity exchange price is of unexpected value (< than the old one)\n    uint256 internal constant fToken__LiquidityExchangePriceUnexpected = 20011;\n\n    /***********************************|\n    |     fToken Native Underlying      | \n    |__________________________________*/\n\n    /// @notice thrown when native deposit is called but sent along `msg.value` does not cover the deposit amount\n    uint256 internal constant fTokenNativeUnderlying__TransferInsufficient = 21001;\n\n    /// @notice thrown when a liquidity callback is called for a native token operation\n    uint256 internal constant fTokenNativeUnderlying__UnexpectedLiquidityCallback = 21002;\n\n    /***********************************|\n    |         Lending Factory         | \n    |__________________________________*/\n\n    /// @notice thrown when a method is called with invalid params\n    uint256 internal constant LendingFactory__InvalidParams = 22001;\n\n    /// @notice thrown when the provided input param address is zero\n    uint256 internal constant LendingFactory__ZeroAddress = 22002;\n\n    /// @notice thrown when the token already exists\n    uint256 internal constant LendingFactory__TokenExists = 22003;\n\n    /// @notice thrown when the fToken has not yet been configured at Liquidity\n    uint256 internal constant LendingFactory__LiquidityNotConfigured = 22004;\n\n    /// @notice thrown when an unauthorized caller is trying to execute an auth-protected method\n    uint256 internal constant LendingFactory__Unauthorized = 22005;\n\n    /***********************************|\n    |   Lending Rewards Rate Model      | \n    |__________________________________*/\n\n    /// @notice thrown when invalid params are given as input\n    uint256 internal constant LendingRewardsRateModel__InvalidParams = 23001;\n\n    /// @notice thrown when calculated rewards rate is exceeding the maximum rate\n    uint256 internal constant LendingRewardsRateModel__MaxRate = 23002;\n\n    /// @notice thrown when msg.sender is not the configurator for admin methods\n    uint256 internal constant LendingRewardsRateModel__Unauthorized = 23003;\n\n    /// @notice thrown when start is called after the rewards are already started\n    uint256 internal constant LendingRewardsRateModel__AlreadyStarted = 23004;\n\n    /// @notice thrown when rewards are already stopped\n    uint256 internal constant LendingRewardsRateModel__AlreadyStopped = 23005;\n\n    /// @notice thrown when next rewards are already queued\n    uint256 internal constant LendingRewardsRateModel__NextRewardsQueued = 23006;\n\n    /// @notice thrown when current rewards have not ended yet\n    uint256 internal constant LendingRewardsRateModel__NotEnded = 23007;\n\n    /// @notice thrown when no next rewards are queued\n    uint256 internal constant LendingRewardsRateModel__NoQueuedRewards = 23008;\n\n    /// @notice thrown when transition to next queued rewards must be executed first\n    uint256 internal constant LendingRewardsRateModel__MustTransitionToNext = 23009;\n\n    /// @notice thrown when queuing next rewards without having any current rewards ever started\n    uint256 internal constant LendingRewardsRateModel__NoRewardsStarted = 23010;\n}\n"
    },
    "contracts/protocols/lending/interfaces/iFToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\nimport { IAllowanceTransfer } from \"./permit2/iAllowanceTransfer.sol\";\nimport { IFluidLendingRewardsRateModel } from \"./iLendingRewardsRateModel.sol\";\nimport { IFluidLendingFactory } from \"./iLendingFactory.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\n\ninterface IFTokenAdmin {\n    /// @notice updates the rewards rate model contract.\n    ///         Only callable by LendingFactory auths.\n    /// @param rewardsRateModel_  the new rewards rate model contract address.\n    ///                           can be set to address(0) to set no rewards (to save gas)\n    function updateRewards(IFluidLendingRewardsRateModel rewardsRateModel_) external;\n\n    /// @notice Balances out the difference between fToken supply at Liquidity vs totalAssets().\n    ///         Deposits underlying from rebalancer address into Liquidity but doesn't mint any shares\n    ///         -> thus making deposit available as rewards.\n    ///         Only callable by rebalancer.\n    /// @return assets_ amount deposited to Liquidity\n    function rebalance() external payable returns (uint256 assets_);\n\n    /// @notice gets the liquidity exchange price of the underlying asset, calculates the updated exchange price (with reward rates)\n    ///         and writes those values to storage.\n    ///         Callable by anyone.\n    /// @return tokenExchangePrice_ exchange price of fToken share to underlying asset\n    /// @return liquidityExchangePrice_ exchange price at Liquidity for the underlying asset\n    function updateRates() external returns (uint256 tokenExchangePrice_, uint256 liquidityExchangePrice_);\n\n    /// @notice sends any potentially stuck funds to Liquidity contract. Only callable by LendingFactory auths.\n    function rescueFunds(address token_) external;\n\n    /// @notice Updates the rebalancer address (ReserveContract). Only callable by LendingFactory auths.\n    function updateRebalancer(address rebalancer_) external;\n}\n\ninterface IFToken is IERC4626, IFTokenAdmin {\n    /// @notice returns minimum amount required for deposit (rounded up)\n    function minDeposit() external view returns (uint256);\n\n    /// @notice returns config, rewards and exchange prices data in a single view method.\n    /// @return liquidity_ address of the Liquidity contract.\n    /// @return lendingFactory_ address of the Lending factory contract.\n    /// @return lendingRewardsRateModel_ address of the rewards rate model contract. changeable by LendingFactory auths.\n    /// @return permit2_ address of the Permit2 contract used for deposits / mint with signature\n    /// @return rebalancer_ address of the rebalancer allowed to execute `rebalance()`\n    /// @return rewardsActive_ true if rewards are currently active\n    /// @return liquidityBalance_ current Liquidity supply balance of `address(this)` for the underyling asset\n    /// @return liquidityExchangePrice_ (updated) exchange price for the underlying assset in the liquidity protocol (without rewards)\n    /// @return tokenExchangePrice_ (updated) exchange price between fToken and the underlying assset (with rewards)\n    function getData()\n        external\n        view\n        returns (\n            IFluidLiquidity liquidity_,\n            IFluidLendingFactory lendingFactory_,\n            IFluidLendingRewardsRateModel lendingRewardsRateModel_,\n            IAllowanceTransfer permit2_,\n            address rebalancer_,\n            bool rewardsActive_,\n            uint256 liquidityBalance_,\n            uint256 liquidityExchangePrice_,\n            uint256 tokenExchangePrice_\n        );\n\n    /// @notice transfers `amount_` of `token_` to liquidity. Only callable by liquidity contract.\n    /// @dev this callback is used to optimize gas consumption (reducing necessary token transfers).\n    function liquidityCallback(address token_, uint256 amount_, bytes calldata data_) external;\n\n    /// @notice deposit `assets_` amount with Permit2 signature for underlying asset approval.\n    ///         reverts with `fToken__MinAmountOut()` if `minAmountOut_` of shares is not reached.\n    ///         `assets_` must at least be `minDeposit()` amount; reverts otherwise.\n    /// @param assets_ amount of assets to deposit\n    /// @param receiver_ receiver of minted fToken shares\n    /// @param minAmountOut_ minimum accepted amount of shares minted\n    /// @param permit_ Permit2 permit message\n    /// @param signature_  packed signature of signing the EIP712 hash of `permit_`\n    /// @return shares_ amount of minted shares\n    function depositWithSignature(\n        uint256 assets_,\n        address receiver_,\n        uint256 minAmountOut_,\n        IAllowanceTransfer.PermitSingle calldata permit_,\n        bytes calldata signature_\n    ) external returns (uint256 shares_);\n\n    /// @notice mint amount of `shares_` with Permit2 signature for underlying asset approval.\n    ///         Signature should approve a little bit more than expected assets amount (`previewMint()`) to avoid reverts.\n    ///         `shares_` must at least be `minMint()` amount; reverts otherwise.\n    ///         Note there might be tiny inaccuracies between requested `shares_` and actually received shares amount.\n    ///         Recommended to use `deposit()` over mint because it is more gas efficient and less likely to revert.\n    /// @param shares_ amount of shares to mint\n    /// @param receiver_ receiver of minted fToken shares\n    /// @param maxAssets_ maximum accepted amount of assets used as input to mint `shares_`\n    /// @param permit_ Permit2 permit message\n    /// @param signature_  packed signature of signing the EIP712 hash of `permit_`\n    /// @return assets_ deposited assets amount\n    function mintWithSignature(\n        uint256 shares_,\n        address receiver_,\n        uint256 maxAssets_,\n        IAllowanceTransfer.PermitSingle calldata permit_,\n        bytes calldata signature_\n    ) external returns (uint256 assets_);\n}\n\ninterface IFTokenNativeUnderlying is IFToken {\n    /// @notice address that is mapped to the chain native token at Liquidity\n    function NATIVE_TOKEN_ADDRESS() external view returns (address);\n\n    /// @notice deposits `msg.value` amount of native token for `receiver_`.\n    ///         `msg.value` must be at least `minDeposit()` amount; reverts otherwise.\n    ///         Recommended to use `depositNative()` with a `minAmountOut_` param instead to set acceptable limit.\n    /// @return shares_ actually minted shares\n    function depositNative(address receiver_) external payable returns (uint256 shares_);\n\n    /// @notice same as {depositNative} but with an additional setting for minimum output amount.\n    /// reverts with `fToken__MinAmountOut()` if `minAmountOut_` of shares is not reached\n    function depositNative(address receiver_, uint256 minAmountOut_) external payable returns (uint256 shares_);\n\n    /// @notice mints `shares_` for `receiver_`, paying with underlying native token.\n    ///         `shares_` must at least be `minMint()` amount; reverts otherwise.\n    ///         `shares_` set to type(uint256).max not supported.\n    ///         Note there might be tiny inaccuracies between requested `shares_` and actually received shares amount.\n    ///         Recommended to use `depositNative()` over mint because it is more gas efficient and less likely to revert.\n    ///         Recommended to use `mintNative()` with a `minAmountOut_` param instead to set acceptable limit.\n    /// @return assets_ deposited assets amount\n    function mintNative(uint256 shares_, address receiver_) external payable returns (uint256 assets_);\n\n    /// @notice same as {mintNative} but with an additional setting for minimum output amount.\n    /// reverts with `fToken__MaxAmount()` if `maxAssets_` of assets is surpassed to mint `shares_`.\n    function mintNative(\n        uint256 shares_,\n        address receiver_,\n        uint256 maxAssets_\n    ) external payable returns (uint256 assets_);\n\n    /// @notice withdraws `assets_` amount in native underlying to `receiver_`, burning shares of `owner_`.\n    ///         If `assets_` equals uint256.max then the whole fToken balance of `owner_` is withdrawn.This does not\n    ///         consider withdrawal limit at liquidity so best to check with `maxWithdraw()` before.\n    ///         Note there might be tiny inaccuracies between requested `assets_` and actually received assets amount.\n    ///         Recommended to use `withdrawNative()` with a `maxSharesBurn_` param instead to set acceptable limit.\n    /// @return shares_ burned shares\n    function withdrawNative(uint256 assets_, address receiver_, address owner_) external returns (uint256 shares_);\n\n    /// @notice same as {withdrawNative} but with an additional setting for minimum output amount.\n    /// reverts with `fToken__MaxAmount()` if `maxSharesBurn_` of shares burned is surpassed.\n    function withdrawNative(\n        uint256 assets_,\n        address receiver_,\n        address owner_,\n        uint256 maxSharesBurn_\n    ) external returns (uint256 shares_);\n\n    /// @notice redeems `shares_` to native underlying to `receiver_`, burning shares of `owner_`.\n    ///         If `shares_` equals uint256.max then the whole balance of `owner_` is withdrawn.This does not\n    ///         consider withdrawal limit at liquidity so best to check with `maxRedeem()` before.\n    ///         Recommended to use `withdrawNative()` over redeem because it is more gas efficient and can set specific amount.\n    ///         Recommended to use `redeemNative()` with a `minAmountOut_` param instead to set acceptable limit.\n    /// @return assets_ withdrawn assets amount\n    function redeemNative(uint256 shares_, address receiver_, address owner_) external returns (uint256 assets_);\n\n    /// @notice same as {redeemNative} but with an additional setting for minimum output amount.\n    /// reverts with `fToken__MinAmountOut()` if `minAmountOut_` of assets is not reached.\n    function redeemNative(\n        uint256 shares_,\n        address receiver_,\n        address owner_,\n        uint256 minAmountOut_\n    ) external returns (uint256 assets_);\n\n    /// @notice withdraw amount of `assets_` in native token with ERC-2612 permit signature for fToken approval.\n    /// `owner_` signs ERC-2612 permit `signature_` to give allowance of fTokens to `msg.sender`.\n    /// Note there might be tiny inaccuracies between requested `assets_` and actually received assets amount.\n    /// allowance via signature should cover `previewWithdraw(assets_)` plus a little buffer to avoid revert.\n    /// Inherent trust assumption that `msg.sender` will set `receiver_` and `minAmountOut_` as `owner_` intends\n    /// (which is always the case when giving allowance to some spender).\n    /// @param sharesToPermit_ shares amount to use for EIP2612 permit(). Should cover `previewWithdraw(assets_)` + small buffer.\n    /// @param assets_ amount of assets to withdraw\n    /// @param receiver_ receiver of withdrawn assets\n    /// @param owner_ owner to withdraw from (must be signature signer)\n    /// @param maxSharesBurn_ maximum accepted amount of shares burned\n    /// @param deadline_ deadline for signature validity\n    /// @param signature_  packed signature of signing the EIP712 hash for ERC-2612 permit\n    /// @return shares_ burned shares amount\n    function withdrawWithSignatureNative(\n        uint256 sharesToPermit_,\n        uint256 assets_,\n        address receiver_,\n        address owner_,\n        uint256 maxSharesBurn_,\n        uint256 deadline_,\n        bytes calldata signature_\n    ) external returns (uint256 shares_);\n\n    /// @notice redeem amount of `shares_` as native token with ERC-2612 permit signature for fToken approval.\n    /// `owner_` signs ERC-2612 permit `signature_` to give allowance of fTokens to `msg.sender`.\n    /// Note there might be tiny inaccuracies between requested `shares_` to redeem and actually burned shares.\n    /// allowance via signature must cover `shares_` plus a tiny buffer.\n    /// Inherent trust assumption that `msg.sender` will set `receiver_` and `minAmountOut_` as `owner_` intends\n    ///       (which is always the case when giving allowance to some spender).\n    /// Recommended to use `withdrawNative()` over redeem because it is more gas efficient and can set specific amount.\n    /// @param shares_ amount of shares to redeem\n    /// @param receiver_ receiver of withdrawn assets\n    /// @param owner_ owner to withdraw from (must be signature signer)\n    /// @param minAmountOut_ minimum accepted amount of assets withdrawn\n    /// @param deadline_ deadline for signature validity\n    /// @param signature_  packed signature of signing the EIP712 hash for ERC-2612 permit\n    /// @return assets_ withdrawn assets amount\n    function redeemWithSignatureNative(\n        uint256 shares_,\n        address receiver_,\n        address owner_,\n        uint256 minAmountOut_,\n        uint256 deadline_,\n        bytes calldata signature_\n    ) external returns (uint256 assets_);\n}\n"
    },
    "contracts/protocols/lending/interfaces/iLendingFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\n\ninterface IFluidLendingFactoryAdmin {\n    /// @notice reads if a certain `auth_` address is an allowed auth or not. Owner is auth by default.\n    function isAuth(address auth_) external view returns (bool);\n\n    /// @notice              Sets an address as allowed auth or not. Only callable by owner.\n    /// @param auth_         address to set auth value for\n    /// @param allowed_      bool flag for whether address is allowed as auth or not\n    function setAuth(address auth_, bool allowed_) external;\n\n    /// @notice reads if a certain `deployer_` address is an allowed deployer or not. Owner is deployer by default.\n    function isDeployer(address deployer_) external view returns (bool);\n\n    /// @notice              Sets an address as allowed deployer or not. Only callable by owner.\n    /// @param deployer_     address to set deployer value for\n    /// @param allowed_      bool flag for whether address is allowed as deployer or not\n    function setDeployer(address deployer_, bool allowed_) external;\n\n    /// @notice              Sets the `creationCode_` bytecode for a certain `fTokenType_`. Only callable by auths.\n    /// @param fTokenType_   the fToken Type used to refer the creation code\n    /// @param creationCode_ contract creation code. can be set to bytes(0) to remove a previously available `fTokenType_`\n    function setFTokenCreationCode(string memory fTokenType_, bytes calldata creationCode_) external;\n\n    /// @notice creates token for `asset_` for a lending protocol with interest. Only callable by deployers.\n    /// @param  asset_              address of the asset\n    /// @param  fTokenType_         type of fToken:\n    /// - if it's the native token, it should use `NativeUnderlying`\n    /// - otherwise it should use `fToken`\n    /// - could be more types available, check `fTokenTypes()`\n    /// @param  isNativeUnderlying_ flag to signal fToken type that uses native underlying at Liquidity\n    /// @return token_              address of the created token\n    function createToken(\n        address asset_,\n        string calldata fTokenType_,\n        bool isNativeUnderlying_\n    ) external returns (address token_);\n}\n\ninterface IFluidLendingFactory is IFluidLendingFactoryAdmin {\n    /// @notice list of all created tokens\n    function allTokens() external view returns (address[] memory);\n\n    /// @notice list of all fToken types that can be deployed\n    function fTokenTypes() external view returns (string[] memory);\n\n    /// @notice returns the creation code for a certain `fTokenType_`\n    function fTokenCreationCode(string memory fTokenType_) external view returns (bytes memory);\n\n    /// @notice address of the Liquidity contract.\n    function LIQUIDITY() external view returns (IFluidLiquidity);\n\n    /// @notice computes deterministic token address for `asset_` for a lending protocol\n    /// @param  asset_      address of the asset\n    /// @param  fTokenType_         type of fToken:\n    /// - if it's the native token, it should use `NativeUnderlying`\n    /// - otherwise it should use `fToken`\n    /// - could be more types available, check `fTokenTypes()`\n    /// @return token_      detemrinistic address of the computed token\n    function computeToken(address asset_, string calldata fTokenType_) external view returns (address token_);\n}\n"
    },
    "contracts/protocols/lending/interfaces/iLendingRewardsRateModel.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidLendingRewardsRateModel {\n    /// @notice Calculates the current rewards rate (APR)\n    /// @param totalAssets_ amount of assets in the lending\n    /// @return rate_ rewards rate percentage per year with 1e12 RATE_PRECISION, e.g. 1e12 = 1%, 1e14 = 100%\n    /// @return ended_ flag to signal that rewards have ended (always 0 going forward)\n    /// @return startTime_ start time of rewards to compare against last update timestamp\n    function getRate(uint256 totalAssets_) external view returns (uint256 rate_, bool ended_, uint256 startTime_);\n\n    /// @notice Returns config constants for rewards rate model\n    function getConfig()\n        external\n        view\n        returns (\n            uint256 duration_,\n            uint256 startTime_,\n            uint256 endTime_,\n            uint256 startTvl_,\n            uint256 maxRate_,\n            uint256 rewardAmount_,\n            address initiator_\n        );\n}\n"
    },
    "contracts/protocols/lending/interfaces/permit2/iAllowanceTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// @title AllowanceTransfer\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\n/// @dev Requires user's token approval on the Permit2 contract\n/// from https://github.com/Uniswap/permit2/blob/main/src/interfaces/ISignatureTransfer.sol.\n/// Copyright (c) 2022 Uniswap Labs\ninterface IAllowanceTransfer {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /// @notice Thrown when an allowance on a token has expired.\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\n    error AllowanceExpired(uint256 deadline);\n\n    /// @notice Thrown when an allowance on a token has been depleted.\n    /// @param amount The maximum amount allowed\n    error InsufficientAllowance(uint256 amount);\n\n    /// @notice Thrown when too many nonces are invalidated.\n    error ExcessiveInvalidation();\n\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\n    event NonceInvalidation(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint48 newNonce,\n        uint48 oldNonce\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\n    event Approval(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\n    event Lockdown(address indexed owner, address token, address spender);\n\n    /// @notice The permit data for a token\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice The permit message signed for a single token allownce\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The permit message signed for multiple token allowances\n    struct PermitBatch {\n        // the permit data for multiple token allowances\n        PermitDetails[] details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The saved permissions\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice A token spender pair.\n    struct TokenSpenderPair {\n        // the token the spender is approved\n        address token;\n        // the spender address\n        address spender;\n    }\n\n    /// @notice Details for a token transfer.\n    struct AllowanceTransferDetails {\n        // the owner of the token\n        address from;\n        // the recipient of the token\n        address to;\n        // the amount of the token\n        uint160 amount;\n        // the token to be transferred\n        address token;\n    }\n\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\n    function allowance(\n        address user,\n        address token,\n        address spender\n    ) external view returns (uint160 amount, uint48 expiration, uint48 nonce);\n\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\n    /// @param token The token to approve\n    /// @param spender The spender address to approve\n    /// @param amount The approved amount of the token\n    /// @param expiration The timestamp at which the approval is no longer valid\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n\n    /// @notice Transfer approved tokens from one address to another\n    /// @param from The address to transfer from\n    /// @param to The address of the recipient\n    /// @param amount The amount of the token to transfer\n    /// @param token The token address to transfer\n    /// @dev Requires the from address to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n\n    /// @notice Transfer approved tokens in a batch\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\n    /// @dev Requires the from addresses to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n\n    /// @notice Enables performing a \"lockdown\" of the sender's Permit2 identity\n    /// by batch revoking approvals\n    /// @param approvals Array of approvals to revoke.\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n\n    /// @notice Invalidate nonces for a given (token, spender) pair\n    /// @param token The token to invalidate nonces for\n    /// @param spender The spender to invalidate nonces for\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}\n"
    },
    "contracts/protocols/lending/lendingRewardsRateModel/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLendingRewardsRateModel } from \"../interfaces/iLendingRewardsRateModel.sol\";\nimport { IFTokenAdmin } from \"../interfaces/iFToken.sol\";\n\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\n\nabstract contract Constants {\n    /// @dev precision decimals for rewards rate\n    uint256 internal constant RATE_PRECISION = 1e12;\n\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /// @dev maximum rewards rate is 50%. no config higher than this should be possible.\n    uint256 internal constant MAX_RATE = 50 * RATE_PRECISION; // 1e12 = 1%, this is 50%.\n\n    /// @dev tvl below which rewards rate is 0\n    uint256 internal immutable START_TVL;\n\n    /// @dev address which has access to manage rewards amounts, start time etc.\n    address internal immutable CONFIGURATOR;\n\n    /// @notice address of the fTokens where these rewards are supposed to be set\n    address public immutable FTOKEN;\n    address public immutable FTOKEN2;\n    address public immutable FTOKEN3;\n}\n\nabstract contract Variables is Constants {\n    // ----------------------- slot 0 ---------------------------\n\n    /// @dev for how long current rewards should run\n    uint40 internal _duration;\n\n    /// @dev when current rewards got started\n    uint40 internal _startTime;\n\n    /// @dev current annualized reward based on input params (duration, rewardAmount)\n    uint176 internal _yearlyReward;\n\n    // ----------------------- slot 1 ---------------------------\n    /// @dev Duration for the next rewards phase.\n    uint40 internal _nextDuration;\n\n    /// @dev Amount of rewards for the next phase.\n    uint176 internal _nextRewardAmount;\n\n    // 40 bytes empty\n}\n\nabstract contract Events {\n    /// @notice Emitted when rewards are stopped.\n    event LogStopRewards();\n\n    /// @notice Emitted when queued rewards are cancelled.\n    event LogCancelQueuedRewards();\n\n    /// @notice Emitted when the rewards transition to the next phase.\n    event LogTransitionedToNextRewards(uint256 startTime, uint256 endTime);\n\n    /// @notice Emitted when rewards are started.\n    /// @param rewardAmount The amount of rewards to be distributed.\n    /// @param duration The duration for which the rewards will run.\n    /// @param startTime The timestamp when the rewards start.\n    event LogStartRewards(uint256 rewardAmount, uint256 duration, uint256 startTime);\n\n    /// @notice Emitted when the next rewards are queued.\n    /// @param rewardAmount The amount of rewards to be distributed in the next phase.\n    /// @param duration The duration for which the next rewards will run.\n    event LogQueueNextRewards(uint256 rewardAmount, uint256 duration);\n}\n\n/// @title LendingRewardsRateModel\n/// @notice Calculates rewards rate used for an fToken based on a rewardAmount over a given duration.\n/// Rewards start according to the configurator triggers and only accrue above a certain startTVL.\n/// Max rate cap is at 50%.\ncontract FluidLendingRewardsRateModel is Variables, IFluidLendingRewardsRateModel, Events, Error {\n    /// @dev Validates that an address is the configurator (team multisig)\n    modifier onlyConfigurator() {\n        if (msg.sender != CONFIGURATOR) {\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__Unauthorized);\n        }\n        _;\n    }\n\n    /// @notice Sets variables for rewards rate configuration based on input parameters.\n    /// @param configurator_ The address with authority to configure rewards.\n    /// @param fToken_ The address of the associated fToken contract.\n    /// @param fToken2_ The address of the associated fToken contract 2, optional.\n    /// @param fToken3_ The address of the associated fToken contract 3, optional.\n    /// @param startTvl_ The TVL threshold below which the reward rate is 0.\n    /// @param rewardAmount_ The total amount of underlying assets to be distributed as rewards.\n    /// @param duration_ The duration (in seconds) for which the rewards will run.\n    /// @param startTime_ The timestamp when rewards are scheduled to start; must be 0 or a future time.\n    constructor(\n        address configurator_,\n        address fToken_,\n        address fToken2_,\n        address fToken3_,\n        uint256 startTvl_,\n        uint256 rewardAmount_,\n        uint256 duration_,\n        uint256 startTime_\n    ) {\n        if (\n            configurator_ == address(0) ||\n            fToken_ == address(0) ||\n            rewardAmount_ == 0 ||\n            startTvl_ == 0 ||\n            duration_ == 0 ||\n            (startTime_ > 0 && startTime_ < block.timestamp)\n        ) {\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__InvalidParams);\n        }\n\n        CONFIGURATOR = configurator_;\n        FTOKEN = fToken_;\n        FTOKEN2 = fToken2_;\n        FTOKEN3 = fToken3_;\n        START_TVL = startTvl_;\n        _duration = uint40(duration_);\n        _startTime = uint40(startTime_);\n\n        _yearlyReward = uint176((rewardAmount_ * SECONDS_PER_YEAR) / duration_);\n    }\n\n    /// @inheritdoc IFluidLendingRewardsRateModel\n    /// @dev initiator_ is actually the configurator who has access to manage the rewards. named as is for backwards-compatibility reasons.\n    function getConfig()\n        external\n        view\n        returns (\n            uint256 duration_,\n            uint256 startTime_,\n            uint256 endTime_,\n            uint256 startTvl_,\n            uint256 maxRate_,\n            uint256 rewardAmount_,\n            address initiator_\n        )\n    {\n        rewardAmount_ = (_yearlyReward * _duration) / SECONDS_PER_YEAR;\n        endTime_ = _startTime + _duration;\n        return (_duration, _startTime, endTime_, START_TVL, MAX_RATE, rewardAmount_, CONFIGURATOR);\n    }\n\n    /// @inheritdoc IFluidLendingRewardsRateModel\n    function getRate(uint256 totalAssets_) public view returns (uint256 rate_, bool ended_, uint256 startTime_) {\n        startTime_ = _startTime;\n        uint256 endTime_;\n        uint256 duration_ = uint256(_duration);\n        unchecked {\n            endTime_ = startTime_ + duration_;\n        }\n        if (startTime_ == 0 || block.timestamp < startTime_) {\n            return (0, false, startTime_);\n        }\n        if (block.timestamp > endTime_) {\n            uint256 nextRewardAmount_ = uint256(_nextRewardAmount);\n            if (nextRewardAmount_ == 0) {\n                return (0, true, startTime_);\n            }\n\n            // use next queued rewards amounts. transition should be triggered via `transitionToNextRewards()` separately.\n            // can not do this here because it modifies state and this method _must_ stay a view method to be compatible with\n            // existing fTokens and all the view methods there that call this.\n\n            uint256 nextDuration_ = uint256(_nextDuration);\n            startTime_ = endTime_;\n            endTime_ = startTime_ + nextDuration_;\n\n            if (block.timestamp > endTime_) {\n                // even next rewards ended\n                return (0, true, startTime_);\n            }\n            if (totalAssets_ < START_TVL) {\n                return (0, false, startTime_);\n            }\n\n            rate_ = (nextRewardAmount_ * SECONDS_PER_YEAR) / nextDuration_; // yearly reward\n            rate_ = (rate_ * 1e14) / totalAssets_;\n        } else {\n            if (totalAssets_ < START_TVL) {\n                return (0, false, startTime_);\n            }\n\n            rate_ = (uint256(_yearlyReward) * 1e14) / totalAssets_;\n        }\n\n        // Note when rewards just got started, fToken handles applying rewards only from _startTime onwards\n\n        return (rate_ > MAX_RATE ? MAX_RATE : rate_, false, startTime_);\n    }\n\n    /// @notice stops current ongoing rewards instantly.\n    function stopRewards() external onlyConfigurator {\n        if (_startTime == 0 || block.timestamp > _startTime + _duration) {\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__AlreadyStopped);\n        }\n        if (_nextRewardAmount > 0) {\n            // must cancel first with `cancelQueuedRewards()`\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__NextRewardsQueued);\n        }\n\n        // update exchange price on fToken until now. Note there is no gas or otherwise benefit in calling `updateRewards()`\n        // and setting address to zero at the fToken instead. still leaving the rewards address linked gives more clarity\n        // when fetching data through resolvers.\n        IFTokenAdmin(FTOKEN).updateRates();\n        if (FTOKEN2 != address(0)) IFTokenAdmin(FTOKEN2).updateRates();\n        if (FTOKEN3 != address(0)) IFTokenAdmin(FTOKEN3).updateRates();\n\n        _duration = uint40(block.timestamp - _startTime - 1);\n        // _yearlyReward stays the same\n\n        emit LogStopRewards();\n    }\n\n    /// @notice start new rewards. LendingRewards must be an auth at the LendingFactory!\n    /// set startTime set to 0 for using block.timestamp\n    function startRewards(uint256 rewardAmount_, uint256 duration_, uint256 startTime_) public onlyConfigurator {\n        if (block.timestamp <= _startTime + _duration) {\n            // for instant switching must stop first with `stopRewards()`\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__NotEnded);\n        }\n        if (startTime_ == 0) {\n            startTime_ = block.timestamp;\n        }\n        if (duration_ == 0 || rewardAmount_ == 0 || startTime_ < block.timestamp) {\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__InvalidParams);\n        }\n\n        _startTime = uint40(startTime_);\n        _duration = uint40(duration_);\n\n        _yearlyReward = uint176((rewardAmount_ * SECONDS_PER_YEAR) / duration_);\n\n        // make sure fTokens do not have set rewardsActive_ as false (locked in state if previous rewards ended)\n        IFTokenAdmin(FTOKEN).updateRewards(IFluidLendingRewardsRateModel(address(this)));\n        if (FTOKEN2 != address(0)) IFTokenAdmin(FTOKEN2).updateRewards(IFluidLendingRewardsRateModel(address(this)));\n        if (FTOKEN3 != address(0)) IFTokenAdmin(FTOKEN3).updateRewards(IFluidLendingRewardsRateModel(address(this)));\n\n        emit LogStartRewards(rewardAmount_, duration_, startTime_);\n    }\n\n    /// @notice cancels currently queued rewards\n    function cancelQueuedRewards() external onlyConfigurator {\n        if (_nextRewardAmount == 0) {\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__NoQueuedRewards);\n        }\n        if (block.timestamp > _startTime + _duration) {\n            // can not be cancelled if switch from current queued that already became active to making them current ones\n            // has not been written to storage yet but time has passed for it. in this case, queued rewards must be\n            // activated with `transitionToNextRewards()` and then call `stopRewards()`.\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__MustTransitionToNext);\n        }\n\n        _nextDuration = 0;\n        _nextRewardAmount = 0;\n\n        emit LogCancelQueuedRewards();\n    }\n\n    /// @notice queues next rewards which can be come active after current ongoing rewards.\n    function queueNextRewards(uint256 rewardAmount_, uint256 duration_) external onlyConfigurator {\n        if (duration_ == 0 || rewardAmount_ == 0) {\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__InvalidParams);\n        }\n        if (_nextRewardAmount > 0) {\n            // must cancel already queued first with `cancelQueuedRewards()`\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__NextRewardsQueued);\n        }\n        if (_startTime == 0) {\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__NoRewardsStarted);\n        }\n        if (block.timestamp > _startTime + _duration) {\n            // if current rewards are ended, immediately start the new queued ones\n            return startRewards(rewardAmount_, duration_, block.timestamp);\n        }\n\n        _nextRewardAmount = uint176(rewardAmount_);\n        _nextDuration = uint40(duration_);\n\n        emit LogQueueNextRewards(rewardAmount_, duration_);\n    }\n\n    /// @notice transitions to next queued rewards after current ongoing rewards ended. Callable by anyone.\n    /// @dev    Note triggering this is not required for queued rewards to start accruing as that happens anyway in the `getRate`\n    ///         view method, but it cleans up the status here in storage and gas optimizes the `getRate()` call.\n    function transitionToNextRewards() public {\n        // there is no way to read lastUpdateTimestamp from fToken so we apply the new rewards rate\n        // for _startTime to until now. Rewards are only applied from _startTime to now at fToken code,\n        // so rewards between lastUpdateTimestamp and new _startTime (= old endTime) are lost.\n\n        uint256 startTime_ = uint256(_startTime);\n        uint256 endTime_ = startTime_ + _duration;\n        if (block.timestamp <= endTime_) {\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__NotEnded);\n        }\n\n        uint256 nextRewardAmount_ = uint256(_nextRewardAmount);\n        if (nextRewardAmount_ == 0) {\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__NoQueuedRewards);\n        }\n\n        uint256 nextDuration_ = uint256(_nextDuration);\n\n        startTime_ = endTime_;\n        _startTime = uint40(startTime_);\n        _duration = uint40(nextDuration_);\n        _yearlyReward = uint176((nextRewardAmount_ * SECONDS_PER_YEAR) / nextDuration_);\n\n        endTime_ = startTime_ + nextDuration_; // update for emit event\n\n        _nextDuration = 0;\n        _nextRewardAmount = 0;\n\n        emit LogTransitionedToNextRewards(startTime_, endTime_);\n    }\n}\n"
    },
    "contracts/protocols/lending/merkleDistributor/errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Errors {\n    error Unauthorized();\n    error InvalidParams();\n\n    // claim related errors:\n    error InvalidCycle();\n    error InvalidProof();\n    error NothingToClaim();\n    error MsgSenderNotRecipient();\n}\n"
    },
    "contracts/protocols/lending/merkleDistributor/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Events {\n    /// @notice Emitted when an address is added or removed from the allowed proposers\n    event LogUpdateProposer(address proposer, bool isProposer);\n\n    /// @notice Emitted when an address is added or removed from the allowed approvers\n    event LogUpdateApprover(address approver, bool isApprover);\n\n    /// @notice Emitted when a new cycle root hash is proposed\n    event LogRootProposed(uint256 cycle, bytes32 root, bytes32 contentHash, uint256 timestamp, uint256 blockNumber);\n\n    /// @notice Emitted when a new cycle root hash is approved by the owner and becomes the new active root\n    event LogRootUpdated(uint256 cycle, bytes32 root, bytes32 contentHash, uint256 timestamp, uint256 blockNumber);\n\n    /// @notice Emitted when a `user` claims `amount` via a valid merkle proof\n    event LogClaimed(\n        address user,\n        uint256 amount,\n        uint256 cycle,\n        uint8 positionType,\n        bytes32 positionId,\n        uint256 timestamp,\n        uint256 blockNumber\n    );\n\n    /// @notice Emitted when a new reward cycle is created\n    event LogRewardCycle(\n        uint256 indexed cycle,\n        uint256 indexed epoch,\n        uint256 amount,\n        uint256 startBlock,\n        uint256 endBlock\n    );\n\n    /// @notice Emitted when a new distribution is created\n    event LogDistribution(\n        uint256 indexed epoch,\n        address indexed initiator,\n        uint256 amount,\n        uint256 startCycle,\n        uint256 endCycle,\n        uint256 registrationBlock,\n        uint256 registrationTimestamp\n    );\n\n    /// @notice Emitted when the distribution configuration is updated\n    event LogDistributionConfigUpdated(\n        bool pullFromSender,\n        uint256 blocksPerDistribution,\n        uint256 cyclesPerDistribution\n    );\n\n    /// @notice Emitted when a rewards distributor is toggled\n    event LogRewardsDistributorToggled(address distributor, bool isDistributor);\n\n    /// @notice Emitted when the start block of the next cycle is updated\n    event LogStartBlockOfNextCycleUpdated(uint256 startBlockOfNextCycle);\n}\n"
    },
    "contracts/protocols/lending/merkleDistributor/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\nimport { Events } from \"./events.sol\";\nimport { Errors } from \"./errors.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { Variables } from \"./variables.sol\";\nimport { SafeTransfer } from \"../../../libraries/safeTransfer.sol\";\n\n// ---------------------------------------------------------------------------------------------\n//\n// @dev WARNING: DO NOT USE `multiProof` related methods of `MerkleProof`.\n// This repo uses OpenZeppelin 4.8.2 which has a vulnerability for multi proofs. See:\n// https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wprv-93r4-jj2p\n//\n// ---------------------------------------------------------------------------------------------\n\nabstract contract FluidMerkleDistributorCore is Structs, Variables, Events, Errors {\n    /// @dev validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert InvalidParams();\n        }\n        _;\n    }\n}\n\nabstract contract FluidMerkleDistributorAdmin is FluidMerkleDistributorCore {\n    /// @notice                  Updates an address status as a root proposer\n    /// @param proposer_         The address to update\n    /// @param isProposer_       Whether or not the address should be an allowed proposer\n    function updateProposer(address proposer_, bool isProposer_) public onlyOwner validAddress(proposer_) {\n        _proposers[proposer_] = isProposer_;\n        emit LogUpdateProposer(proposer_, isProposer_);\n    }\n\n    /// @notice                  Updates an address status as a root approver\n    /// @param approver_         The address to update\n    /// @param isApprover_       Whether or not the address should be an allowed approver\n    function updateApprover(address approver_, bool isApprover_) public onlyOwner validAddress(approver_) {\n        _approvers[approver_] = isApprover_;\n        emit LogUpdateApprover(approver_, isApprover_);\n    }\n\n    /// @notice                         Spell allows owner aka governance to do any arbitrary call on factory\n    /// @param target_                  Address to which the call needs to be delegated\n    /// @param data_                    Data to execute at the delegated address\n    function _spell(address target_, bytes memory data_) internal returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n\n    /// @dev open payload method for admin to resolve emergency cases\n    function spell(address[] memory targets_, bytes[] memory calldatas_) public onlyOwner {\n        for (uint256 i = 0; i < targets_.length; i++) _spell(targets_[i], calldatas_[i]);\n    }\n\n    /// @notice Pause contract functionality of new roots and claiming\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Unpause contract functionality of new roots and claiming\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n\nabstract contract FluidMerkleDistributorApprover is FluidMerkleDistributorCore {\n    /// @dev Checks that the sender is an approver\n    modifier onlyApprover() {\n        if (!isApprover(msg.sender)) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @notice checks if the `approver_` is an allowed root approver\n    function isApprover(address approver_) public view returns (bool) {\n        return (_approvers[approver_] || owner == approver_);\n    }\n\n    /// @notice Approve the current pending root and content hash\n    function approveRoot(\n        bytes32 root_,\n        bytes32 contentHash_,\n        uint40 cycle_,\n        uint40 startBlock_,\n        uint40 endBlock_\n    ) external onlyApprover {\n        MerkleCycle memory merkleCycle_ = _pendingMerkleCycle;\n\n        if (\n            root_ != merkleCycle_.merkleRoot ||\n            contentHash_ != merkleCycle_.merkleContentHash ||\n            cycle_ != merkleCycle_.cycle ||\n            startBlock_ != merkleCycle_.startBlock ||\n            endBlock_ != merkleCycle_.endBlock\n        ) {\n            revert InvalidParams();\n        }\n\n        previousMerkleRoot = _currentMerkleCycle.merkleRoot;\n\n        merkleCycle_.timestamp = uint40(block.timestamp);\n        merkleCycle_.publishBlock = uint40(block.number);\n\n        _currentMerkleCycle = merkleCycle_;\n\n        emit LogRootUpdated(cycle_, root_, contentHash_, block.timestamp, block.number);\n    }\n}\n\nabstract contract FluidMerkleDistributorProposer is FluidMerkleDistributorCore {\n    /// @dev Checks that the sender is a proposer\n    modifier onlyProposer() {\n        if (!isProposer(msg.sender)) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @notice checks if the `proposer_` is an allowed root proposer\n    function isProposer(address proposer_) public view returns (bool) {\n        return (_proposers[proposer_] || owner == proposer_);\n    }\n\n    /// @notice Propose a new root and content hash, which will be stored as pending until approved\n    function proposeRoot(\n        bytes32 root_,\n        bytes32 contentHash_,\n        uint40 cycle_,\n        uint40 startBlock_,\n        uint40 endBlock_\n    ) external whenNotPaused onlyProposer {\n        if (cycle_ != _currentMerkleCycle.cycle + 1 || startBlock_ > endBlock_) {\n            revert InvalidParams();\n        }\n\n        _pendingMerkleCycle = MerkleCycle({\n            merkleRoot: root_,\n            merkleContentHash: contentHash_,\n            cycle: cycle_,\n            startBlock: startBlock_,\n            endBlock: endBlock_,\n            timestamp: uint40(block.timestamp),\n            publishBlock: uint40(block.number)\n        });\n\n        emit LogRootProposed(cycle_, root_, contentHash_, block.timestamp, block.number);\n    }\n}\n\nabstract contract FluidMerkleDistributorRewards is FluidMerkleDistributorCore {\n    /// @dev Modifier to check if the sender is a rewards distributor\n    modifier onlyRewardsDistributor() {\n        if (!rewardsDistributor[msg.sender] && owner != msg.sender) revert Unauthorized();\n        _;\n    }\n\n    /// @notice Updates the distribution configuration\n    /// @param pullFromDistributor_ - whether to pull rewards from distributor or not\n    /// @param blocksPerDistribution_ - duration of distribution in blocks\n    /// @param cyclesPerDistribution_ - number of cycles to distribute rewards, if 0 then means paused\n    function updateDistributionConfig(\n        bool pullFromDistributor_,\n        uint40 blocksPerDistribution_,\n        uint40 cyclesPerDistribution_\n    ) external onlyOwner {\n        if (blocksPerDistribution_ == 0 || cyclesPerDistribution_ == 0) revert InvalidParams();\n        emit LogDistributionConfigUpdated(\n            pullFromDistributor = pullFromDistributor_,\n            blocksPerDistribution = blocksPerDistribution_,\n            cyclesPerDistribution = cyclesPerDistribution_\n        );\n    }\n\n    /// @notice Toggles a rewards distributor\n    /// @param distributor_ - address of the rewards distributor\n    function toggleRewardsDistributor(address distributor_) external onlyOwner {\n        if (distributor_ == address(0)) revert InvalidParams();\n        emit LogRewardsDistributorToggled(\n            distributor_,\n            rewardsDistributor[distributor_] = !rewardsDistributor[distributor_]\n        );\n    }\n\n    /// @notice Sets the start block of the next cycle\n    /// @param startBlockOfNextCycle_ The start block of the next cycle\n    function setStartBlockOfNextCycle(uint40 startBlockOfNextCycle_) external onlyOwner {\n        if (startBlockOfNextCycle_ < block.number || startBlockOfNextCycle_ == 0) revert InvalidParams();\n        emit LogStartBlockOfNextCycleUpdated(startBlockOfNextCycle = uint40(startBlockOfNextCycle_));\n    }\n\n    /////// Public Functions ///////\n\n    /// @notice Returns the cycle rewards\n    /// @return rewards_ - rewards\n    function getCycleRewards() external view returns (Reward[] memory) {\n        return rewards;\n    }\n\n    /// @notice Returns the cycle reward for a given cycle\n    /// @param cycle_ - cycle of the reward\n    /// @return reward_ - reward\n    function getCycleReward(uint256 cycle_) external view returns (Reward memory) {\n        if (cycle_ > rewards.length || cycle_ == 0) revert InvalidParams();\n        return rewards[cycle_ - 1];\n    }\n\n    /// @notice Returns the total number of cycles\n    /// @return totalCycles_ - total number of cycles\n    function totalCycleRewards() external view returns (uint256) {\n        return rewards.length;\n    }\n\n    /// @notice Returns the total number of distributions\n    /// @return totalDistributions_ - total number of distributions\n    function totalDistributions() external view returns (uint256) {\n        return distributions.length;\n    }\n\n    /// @notice Returns the distribution for a given epoch\n    /// @param epoch_ - epoch of the distribution\n    /// @return distribution_ - distribution\n    function getDistributionForEpoch(uint256 epoch_) external view returns (Distribution memory) {\n        if (epoch_ > distributions.length || epoch_ == 0) revert InvalidParams();\n        return distributions[epoch_ - 1];\n    }\n\n    /// @notice Returns all distributions\n    /// @return distributions_ - all distributions\n    function getDistributions() external view returns (Distribution[] memory) {\n        return distributions;\n    }\n\n    ////////// Distribution Function //////////\n\n    /// @notice Distributes rewards for a given token\n    /// @param amount_ - amount of tokens to distribute rewards for\n    function distributeRewards(uint256 amount_) public onlyRewardsDistributor {\n        if (amount_ == 0) revert InvalidParams();\n\n        uint256 amountPerCycle_ = amount_ / cyclesPerDistribution;\n        uint256 blocksPerCycle_ = blocksPerDistribution / cyclesPerDistribution;\n\n        uint256 cyclesLength_ = rewards.length;\n        uint256 startBlock_ = 0;\n        if (cyclesLength_ > 0) {\n            uint256 lastCycleEndBlock_ = rewards[cyclesLength_ - 1].endBlock + 1;\n            // if there are already some cycles, then we need to check if startBlockOfNextCycle was set in order to start from that block, then assign it to startBlock_\n            if (lastCycleEndBlock_ < startBlockOfNextCycle) {\n                startBlock_ = startBlockOfNextCycle;\n            } else {\n                // if lastCycleEndBlock_ of last cycle is still syncing, then we need to start last cycle's end block + 1, else start from current block\n                startBlock_ = lastCycleEndBlock_ > block.number ? lastCycleEndBlock_ : block.number;\n            }\n        } else {\n            // if there are no cycles, that means this is the first distribution, then we need to start from startBlockOfNextCycle, if it was set, else start from current block\n            startBlock_ = startBlockOfNextCycle > 0 ? startBlockOfNextCycle : block.number;\n        }\n\n        if (startBlock_ == 0) revert InvalidParams();\n\n        uint256 distributionEpoch_ = distributions.length + 1;\n\n        distributions.push(\n            Distribution({\n                amount: amount_,\n                epoch: uint40(distributionEpoch_),\n                startCycle: uint40(cyclesLength_ + 1),\n                endCycle: uint40(cyclesLength_ + cyclesPerDistribution),\n                registrationBlock: uint40(block.number),\n                registrationTimestamp: uint40(block.timestamp)\n            })\n        );\n\n        for (uint256 i = 0; i < cyclesPerDistribution; i++) {\n            uint256 endBlock_ = startBlock_ + blocksPerCycle_ - 1;\n            uint256 cycle_ = cyclesLength_ + 1 + i;\n            uint256 cycleAmount_ = amountPerCycle_;\n            if (i == cyclesPerDistribution - 1) {\n                cycleAmount_ = amount_ - (amountPerCycle_ * i);\n            }\n            rewards.push(\n                Reward({\n                    cycle: uint40(cycle_),\n                    amount: cycleAmount_,\n                    startBlock: uint40(startBlock_),\n                    endBlock: uint40(endBlock_),\n                    epoch: uint40(distributionEpoch_)\n                })\n            );\n            emit LogRewardCycle(cycle_, distributionEpoch_, cycleAmount_, startBlock_, endBlock_);\n            startBlock_ = endBlock_ + 1;\n        }\n\n        if (pullFromDistributor) SafeERC20.safeTransferFrom(TOKEN, msg.sender, address(this), amount_);\n\n        emit LogDistribution(\n            distributionEpoch_,\n            msg.sender,\n            amount_,\n            cyclesLength_ + 1,\n            cyclesLength_ + cyclesPerDistribution,\n            block.number,\n            block.timestamp\n        );\n    }\n}\n\ncontract FluidMerkleDistributor is\n    FluidMerkleDistributorCore,\n    FluidMerkleDistributorAdmin,\n    FluidMerkleDistributorApprover,\n    FluidMerkleDistributorProposer,\n    FluidMerkleDistributorRewards\n{\n    constructor(\n        ConstructorParams memory params_\n    )\n        validAddress(params_.owner)\n        validAddress(params_.proposer)\n        validAddress(params_.approver)\n        validAddress(params_.rewardToken)\n        Variables(params_.owner, params_.rewardToken)\n    {\n        if (params_.distributionInHours == 0 || params_.cycleInHours == 0) revert InvalidParams();\n\n        name = params_.name;\n\n        _proposers[params_.proposer] = true;\n        emit LogUpdateProposer(params_.proposer, true);\n\n        _approvers[params_.approver] = true;\n        emit LogUpdateApprover(params_.approver, true);\n\n        uint40 _blocksPerDistribution = uint40(params_.distributionInHours * 1 hours);\n        uint40 _cyclesPerDistribution = uint40(params_.distributionInHours / params_.cycleInHours);\n\n        if (block.chainid == 1) _blocksPerDistribution = _blocksPerDistribution / 12 seconds;\n        else if (block.chainid == 42161)\n            _blocksPerDistribution = _blocksPerDistribution * 4; // 0.25 seconds blocktime, means 4 blocks per second\n        else if (block.chainid == 8453 || block.chainid == 137)\n            _blocksPerDistribution = _blocksPerDistribution / 2 seconds;\n        else revert(\"Unsupported chain\");\n\n        emit LogDistributionConfigUpdated(\n            pullFromDistributor = params_.pullFromDistributor,\n            blocksPerDistribution = _blocksPerDistribution,\n            cyclesPerDistribution = _cyclesPerDistribution\n        );\n\n        vestingTime = uint40(params_.vestingTime);\n        vestingStartTime = uint40(params_.vestingStartTime);\n\n        if (params_.startBlock > 0)\n            emit LogStartBlockOfNextCycleUpdated(startBlockOfNextCycle = uint40(params_.startBlock));\n    }\n\n    /// @notice checks if there is a proposed root waiting to be approved\n    function hasPendingRoot() external view returns (bool) {\n        return _pendingMerkleCycle.cycle == _currentMerkleCycle.cycle + 1;\n    }\n\n    /// @notice merkle root data related to current cycle (proposed and approved).\n    function currentMerkleCycle() public view returns (MerkleCycle memory) {\n        return _currentMerkleCycle;\n    }\n\n    /// @notice merkle root data related to pending cycle (proposed but not yet approved).\n    function pendingMerkleCycle() public view returns (MerkleCycle memory) {\n        return _pendingMerkleCycle;\n    }\n\n    function encodeClaim(\n        address recipient_,\n        uint256 cumulativeAmount_,\n        uint8 positionType_,\n        bytes32 positionId_,\n        uint256 cycle_,\n        bytes memory metadata_\n    ) public pure returns (bytes memory encoded_, bytes32 hash_) {\n        encoded_ = abi.encode(positionType_, positionId_, recipient_, cycle_, cumulativeAmount_, metadata_);\n        hash_ = keccak256(bytes.concat(keccak256(encoded_)));\n    }\n\n    /// @notice Claims rewards on behalf of an address for a given recipient. Only for backup claiming for integrating protocols without\n    ///         ability to claim on their side. Only callable by owner.\n    /// @param onBehalfOf_ - user on behalf of which to claim the rewards. this users rewards get transferred to recipient_\n    /// @param recipient_ - address of the recipient\n    /// @param cumulativeAmount_ - cumulative amount of rewards to claim\n    /// @param positionType_ - type of position, 1 for lending, 2 for vaults, 3 for smart lending, etc\n    /// @param positionId_ - id of the position, fToken address for lending and vaultId for vaults\n    /// @param cycle_ - cycle of the rewards\n    /// @param merkleProof_ - merkle proof of the rewards\n    function claimOnBehalfOf(\n        address onBehalfOf_,\n        address recipient_,\n        uint256 cumulativeAmount_,\n        uint8 positionType_,\n        bytes32 positionId_,\n        uint256 cycle_,\n        bytes32[] calldata merkleProof_,\n        bytes memory metadata_\n    ) public onlyOwner whenNotPaused {\n        uint256 claimable_ = _claim(\n            onBehalfOf_,\n            cumulativeAmount_,\n            positionType_,\n            positionId_,\n            cycle_,\n            merkleProof_,\n            metadata_\n        );\n\n        SafeERC20.safeTransfer(TOKEN, recipient_, claimable_);\n\n        emit LogClaimed(onBehalfOf_, claimable_, cycle_, positionType_, positionId_, block.timestamp, block.number);\n    }\n\n    /// @notice Claims rewards for a given recipient\n    /// @param recipient_ - address of the recipient\n    /// @param cumulativeAmount_ - cumulative amount of rewards to claim\n    /// @param positionType_ - type of position, 1 for lending, 2 for vaults, 3 for smart lending, etc\n    /// @param positionId_ - id of the position, fToken address for lending and vaultId for vaults\n    /// @param cycle_ - cycle of the rewards\n    /// @param merkleProof_ - merkle proof of the rewards\n    function claim(\n        address recipient_,\n        uint256 cumulativeAmount_,\n        uint8 positionType_,\n        bytes32 positionId_,\n        uint256 cycle_,\n        bytes32[] calldata merkleProof_,\n        bytes memory metadata_\n    ) public whenNotPaused {\n        if (msg.sender != recipient_) revert MsgSenderNotRecipient();\n\n        uint256 claimable_ = _claim(\n            recipient_,\n            cumulativeAmount_,\n            positionType_,\n            positionId_,\n            cycle_,\n            merkleProof_,\n            metadata_\n        );\n\n        SafeERC20.safeTransfer(TOKEN, recipient_, claimable_);\n\n        emit LogClaimed(recipient_, claimable_, cycle_, positionType_, positionId_, block.timestamp, block.number);\n    }\n\n    function _claim(\n        address recipient_,\n        uint256 cumulativeAmount_,\n        uint8 positionType_,\n        bytes32 positionId_,\n        uint256 cycle_,\n        bytes32[] calldata merkleProof_,\n        bytes memory metadata_\n    ) internal returns (uint256 claimable_) {\n        uint256 currentCycle_ = uint256(_currentMerkleCycle.cycle);\n\n        if (!(cycle_ == currentCycle_ || (currentCycle_ > 0 && cycle_ == currentCycle_ - 1))) {\n            revert InvalidCycle();\n        }\n\n        // Verify the merkle proof.\n        bytes32 node_ = keccak256(\n            bytes.concat(\n                keccak256(abi.encode(positionType_, positionId_, recipient_, cycle_, cumulativeAmount_, metadata_))\n            )\n        );\n        if (\n            !MerkleProof.verify(\n                merkleProof_,\n                cycle_ == currentCycle_ ? _currentMerkleCycle.merkleRoot : previousMerkleRoot,\n                node_\n            )\n        ) {\n            revert InvalidProof();\n        }\n\n        claimable_ = cumulativeAmount_ - claimed[recipient_][positionId_];\n        if (claimable_ == 0) {\n            revert NothingToClaim();\n        }\n\n        if (vestingTime > 0) {\n            uint256 vestingPeriod_ = block.timestamp - vestingStartTime;\n            if (vestingPeriod_ < vestingTime) {\n                // Calculate total vested amount at current time\n                uint256 totalVestedAmount = (cumulativeAmount_ * vestingPeriod_) / vestingTime;\n                // Adjust claimable to only what's newly vested\n                claimable_ = totalVestedAmount - claimed[recipient_][positionId_];\n            }\n        }\n\n        claimed[recipient_][positionId_] += claimable_;\n    }\n\n    struct Claim {\n        address recipient;\n        uint256 cumulativeAmount;\n        uint8 positionType;\n        bytes32 positionId;\n        uint256 cycle;\n        bytes32[] merkleProof;\n        bytes metadata;\n    }\n\n    function bulkClaim(Claim[] calldata claims_) external {\n        for (uint i = 0; i < claims_.length; i++) {\n            claim(\n                claims_[i].recipient,\n                claims_[i].cumulativeAmount,\n                claims_[i].positionType,\n                claims_[i].positionId,\n                claims_[i].cycle,\n                claims_[i].merkleProof,\n                claims_[i].metadata\n            );\n        }\n    }\n}\n"
    },
    "contracts/protocols/lending/merkleDistributor/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct ConstructorParams {\n        string name;\n        address owner;\n        address proposer;\n        address approver;\n        address rewardToken;\n        uint256 distributionInHours;\n        uint256 cycleInHours;\n        uint256 startBlock;\n        bool pullFromDistributor;\n        uint256 vestingTime;\n        uint256 vestingStartTime;\n    }\n\n    struct MerkleCycle {\n        // slot 1\n        bytes32 merkleRoot;\n        // slot 2\n        bytes32 merkleContentHash;\n        // slot 3\n        uint40 cycle;\n        uint40 timestamp;\n        uint40 publishBlock;\n        uint40 startBlock;\n        uint40 endBlock;\n    }\n\n    struct Reward {\n        // slot 1\n        uint256 amount;\n        // slot 2\n        uint40 cycle;\n        uint40 startBlock;\n        uint40 endBlock;\n        uint40 epoch;\n    }\n\n    struct Distribution {\n        // slot 1\n        uint256 amount;\n        // slot 2\n        uint40 epoch;\n        uint40 startCycle;\n        uint40 endCycle;\n        uint40 registrationBlock;\n        uint40 registrationTimestamp;\n    }\n}\n"
    },
    "contracts/protocols/lending/merkleDistributor/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Owned } from \"solmate/src/auth/Owned.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport { Structs } from \"./structs.sol\";\n\nabstract contract Constants {\n    IERC20 public immutable TOKEN;\n\n    constructor(address rewardToken_) {\n        TOKEN = IERC20(rewardToken_);\n    }\n}\n\nabstract contract Variables is Owned, Pausable, Constants, Structs {\n    // ------------ storage variables from inherited contracts (Owned, Pausable) come before vars here --------\n\n    // ----------------------- slot 0 ---------------------------\n    // address public owner; -> from Owned\n\n    // bool private _paused; -> from Pausable\n\n    // 11 bytes empty\n\n    // ----------------------- slot 1 ---------------------------\n\n    /// @dev Name of the Merkle Distributor\n    string public name;\n\n    // ----------------------- slot 2 ---------------------------\n\n    /// @dev allow list for allowed root proposer addresses\n    mapping(address => bool) internal _proposers;\n\n    // ----------------------- slot 3 ---------------------------\n\n    /// @dev allow list for allowed root proposer addresses\n    mapping(address => bool) internal _approvers;\n\n    // ----------------------- slot 4-6 ---------------------------\n\n    /// @dev merkle root data related to current cycle (proposed and approved).\n    /// @dev timestamp & publishBlock = data from last publish.\n    // with custom getter to return whole struct at once instead of default solidity getter splitting it into tuple\n    MerkleCycle internal _currentMerkleCycle;\n\n    // ----------------------- slot 7-9 ---------------------------\n\n    /// @dev merkle root data related to pending cycle (proposed but not yet approved).\n    /// @dev timestamp & publishBlock = data from last propose.\n    // with custom getter to return whole struct at once instead of default solidity getter splitting it into tuple\n    MerkleCycle internal _pendingMerkleCycle;\n\n    // ----------------------- slot 10 ---------------------------\n\n    /// @notice merkle root of the previous cycle\n    bytes32 public previousMerkleRoot;\n\n    // ----------------------- slot 11 ---------------------------\n\n    /// @notice total claimed amount per user address and fToken. user => positionId => claimed amount\n    mapping(address => mapping(bytes32 => uint256)) public claimed;\n\n    // ----------------------- slot 12 ---------------------------\n\n    /// @notice Data of cycle rewards\n    Reward[] internal rewards;\n\n    // ----------------------- slot 13 ---------------------------\n\n    /// @notice data of distributions\n    Distribution[] internal distributions;\n\n    // ----------------------- slot 14 ---------------------------\n\n    /// @notice allow list for rewards distributors\n    mapping(address => bool) public rewardsDistributor;\n\n    // ----------------------- slot 15 ---------------------------\n\n    /// @notice Number of cycles to distribute rewards\n    uint40 public cyclesPerDistribution;\n\n    /// @notice Duration of each distribution in blocks\n    uint40 public blocksPerDistribution;\n\n    /// @notice Start block of the next cycle\n    uint40 public startBlockOfNextCycle;\n\n    /// @notice Whether to pull tokens from distributor or not\n    bool public pullFromDistributor;\n\n    /// @notice Vesting time for rewards\n    uint40 public vestingTime;\n\n    /// @notice Vesting start time\n    uint40 public vestingStartTime;\n\n    constructor(address owner_, address rewardToken_) Constants(rewardToken_) Owned(owner_) {}\n}\n"
    },
    "contracts/protocols/vault/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Error {\n    error FluidVaultError(uint256 errorId_);\n\n    /// @notice used to simulate liquidation to find the maximum liquidatable amounts\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n}\n"
    },
    "contracts/protocols/vault/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |           Vault Factory           | \n    |__________________________________*/\n\n    uint256 internal constant VaultFactory__InvalidOperation = 30001;\n    uint256 internal constant VaultFactory__Unauthorized = 30002;\n    uint256 internal constant VaultFactory__SameTokenNotAllowed = 30003;\n    uint256 internal constant VaultFactory__InvalidParams = 30004;\n    uint256 internal constant VaultFactory__InvalidVault = 30005;\n    uint256 internal constant VaultFactory__InvalidVaultAddress = 30006;\n    uint256 internal constant VaultFactory__OnlyDelegateCallAllowed = 30007;\n\n    /***********************************|\n    |            Vault                  | \n    |__________________________________*/\n\n    /// @notice thrown at reentrancy\n    uint256 internal constant Vault__AlreadyEntered = 31001;\n\n    /// @notice thrown when user sends deposit & borrow amount as 0\n    uint256 internal constant Vault__InvalidOperateAmount = 31002;\n\n    /// @notice thrown when msg.value is not in sync with native token deposit or payback\n    uint256 internal constant Vault__InvalidMsgValueOperate = 31003;\n\n    /// @notice thrown when msg.sender is not the owner of the vault\n    uint256 internal constant Vault__NotAnOwner = 31004;\n\n    /// @notice thrown when user's position does not exist. Sending the wrong index from the frontend\n    uint256 internal constant Vault__TickIsEmpty = 31005;\n\n    /// @notice thrown when the user's position is above CF and the user tries to make it more risky by trying to withdraw or borrow\n    uint256 internal constant Vault__PositionAboveCF = 31006;\n\n    /// @notice thrown when the top tick is not initialized. Happens if the vault is totally new or all the user's left\n    uint256 internal constant Vault__TopTickDoesNotExist = 31007;\n\n    /// @notice thrown when msg.value in liquidate is not in sync payback\n    uint256 internal constant Vault__InvalidMsgValueLiquidate = 31008;\n\n    /// @notice thrown when slippage is more on liquidation than what the liquidator sent\n    uint256 internal constant Vault__ExcessSlippageLiquidation = 31009;\n\n    /// @notice thrown when msg.sender is not the rebalancer/reserve contract\n    uint256 internal constant Vault__NotRebalancer = 31010;\n\n    /// @notice thrown when NFT of one vault interacts with the NFT of other vault\n    uint256 internal constant Vault__NftNotOfThisVault = 31011;\n\n    /// @notice thrown when the token is not initialized on the liquidity contract\n    uint256 internal constant Vault__TokenNotInitialized = 31012;\n\n    /// @notice thrown when admin updates fallback if a non-auth calls vault\n    uint256 internal constant Vault__NotAnAuth = 31013;\n\n    /// @notice thrown in operate when user tries to witdhraw more collateral than deposited\n    uint256 internal constant Vault__ExcessCollateralWithdrawal = 31014;\n\n    /// @notice thrown in operate when user tries to payback more debt than borrowed\n    uint256 internal constant Vault__ExcessDebtPayback = 31015;\n\n    /// @notice thrown when user try to withdrawal more than operate's withdrawal limit\n    uint256 internal constant Vault__WithdrawMoreThanOperateLimit = 31016;\n\n    /// @notice thrown when caller of liquidityCallback is not Liquidity\n    uint256 internal constant Vault__InvalidLiquidityCallbackAddress = 31017;\n\n    /// @notice thrown when reentrancy is not already on\n    uint256 internal constant Vault__NotEntered = 31018;\n\n    /// @notice thrown when someone directly calls operate or secondary implementation contract\n    uint256 internal constant Vault__OnlyDelegateCallAllowed = 31019;\n\n    /// @notice thrown when the safeTransferFrom for a token amount failed\n    uint256 internal constant Vault__TransferFromFailed = 31020;\n\n    /// @notice thrown when exchange price overflows while updating on storage\n    uint256 internal constant Vault__ExchangePriceOverFlow = 31021;\n\n    /// @notice thrown when debt to liquidate amt is sent wrong\n    uint256 internal constant Vault__InvalidLiquidationAmt = 31022;\n\n    /// @notice thrown when user debt or collateral goes above 2**128 or below -2**128\n    uint256 internal constant Vault__UserCollateralDebtExceed = 31023;\n\n    /// @notice thrown if on liquidation branch debt becomes lower than 100\n    uint256 internal constant Vault__BranchDebtTooLow = 31024;\n\n    /// @notice thrown when tick's debt is less than 10000\n    uint256 internal constant Vault__TickDebtTooLow = 31025;\n\n    /// @notice thrown when the received new liquidity exchange price is of unexpected value (< than the old one)\n    uint256 internal constant Vault__LiquidityExchangePriceUnexpected = 31026;\n\n    /// @notice thrown when user's debt is less than 10000\n    uint256 internal constant Vault__UserDebtTooLow = 31027;\n\n    /// @notice thrown when on only payback and only deposit the ratio of position increases\n    uint256 internal constant Vault__InvalidPaybackOrDeposit = 31028;\n\n    /// @notice thrown when liquidation just happens of a single partial or when there's nothing to liquidate\n    uint256 internal constant Vault__InvalidLiquidation = 31029;\n\n    /// @notice thrown when msg.value is sent wrong in rebalance\n    uint256 internal constant Vault__InvalidMsgValueInRebalance = 31030;\n\n    /// @notice thrown when nothing rebalanced\n    uint256 internal constant Vault__NothingToRebalance = 31031;\n\n    /// @notice thrown on unforseen liquidation scenarios. Might never come in use.\n    uint256 internal constant Vault__LiquidationReverts = 31032;\n\n    /// @notice thrown when oracle price is > 1e54\n    uint256 internal constant Vault__InvalidOraclePrice = 31033;\n\n    /// @notice thrown when constants are not set properly via contructor\n    uint256 internal constant Vault__ImproperConstantsSetup = 31034;\n\n    /// @notice thrown when externally calling fetchLatestPosition function\n    uint256 internal constant Vault__FetchLatestPositionFailed = 31035;\n\n    /// @notice thrown when dex callback is not from dex\n    uint256 internal constant Vault__InvalidDexCallbackAddress = 31036;\n\n    /// @notice thrown when dex callback is already set\n    uint256 internal constant Vault__DexFromAddressAlreadySet = 31037;\n\n    /// @notice thrown when an invalid min / max amounts config is passed to rebalance()\n    uint256 internal constant Vault__InvalidMinMaxInRebalance = 31038;\n\n    /***********************************|\n    |              ERC721               | \n    |__________________________________*/\n\n    uint256 internal constant ERC721__InvalidParams = 32001;\n    uint256 internal constant ERC721__Unauthorized = 32002;\n    uint256 internal constant ERC721__InvalidOperation = 32003;\n    uint256 internal constant ERC721__UnsafeRecipient = 32004;\n    uint256 internal constant ERC721__OutOfBoundsIndex = 32005;\n\n    /***********************************|\n    |            Vault Admin            | \n    |__________________________________*/\n\n    /// @notice thrown when admin tries to setup invalid value which are crossing limits\n    uint256 internal constant VaultAdmin__ValueAboveLimit = 33001;\n\n    /// @notice when someone directly calls admin implementation contract\n    uint256 internal constant VaultAdmin__OnlyDelegateCallAllowed = 33002;\n\n    /// @notice thrown when auth sends NFT ID as 0 while collecting dust debt\n    uint256 internal constant VaultAdmin__NftIdShouldBeNonZero = 33003;\n\n    /// @notice thrown when trying to collect dust debt of NFT which is not of this vault\n    uint256 internal constant VaultAdmin__NftNotOfThisVault = 33004;\n\n    /// @notice thrown when dust debt of NFT is 0, meaning nothing to collect\n    uint256 internal constant VaultAdmin__DustDebtIsZero = 33005;\n\n    /// @notice thrown when final debt after liquidation is not 0, meaning position 100% liquidated\n    uint256 internal constant VaultAdmin__FinalDebtShouldBeZero = 33006;\n\n    /// @notice thrown when NFT is not liquidated state\n    uint256 internal constant VaultAdmin__NftNotLiquidated = 33007;\n\n    /// @notice thrown when total absorbed dust debt is 0\n    uint256 internal constant VaultAdmin__AbsorbedDustDebtIsZero = 33008;\n\n    /// @notice thrown when address is set as 0\n    uint256 internal constant VaultAdmin__AddressZeroNotAllowed = 33009;\n\n    /***********************************|\n    |            Vault Rewards          | \n    |__________________________________*/\n\n    uint256 internal constant VaultRewards__Unauthorized = 34001;\n    uint256 internal constant VaultRewards__AddressZero = 34002;\n    uint256 internal constant VaultRewards__InvalidParams = 34003;\n    uint256 internal constant VaultRewards__NewMagnifierSameAsOldMagnifier = 34004;\n    uint256 internal constant VaultRewards__NotTheInitiator = 34005;\n    uint256 internal constant VaultRewards__NotTheGovernance = 34006;\n    uint256 internal constant VaultRewards__AlreadyStarted = 34007;\n    uint256 internal constant VaultRewards__RewardsNotStartedOrEnded = 34008;\n    uint256 internal constant VaultRewards__InvalidStartTime = 34009;\n    uint256 internal constant VaultRewards__AlreadyEnded = 34010;\n\n    /***********************************|\n    |          Vault DEX Types          | \n    |__________________________________*/\n\n    uint256 internal constant VaultDex__InvalidOperateAmount = 35001;\n    uint256 internal constant VaultDex__DebtSharesPaidMoreThanAvailableLiquidation = 35002;\n\n    /***********************************|\n    |        Vault Borrow Rewards       | \n    |__________________________________*/\n\n    uint256 internal constant VaultBorrowRewards__Unauthorized = 36001;\n    uint256 internal constant VaultBorrowRewards__AddressZero = 36002;\n    uint256 internal constant VaultBorrowRewards__InvalidParams = 36003;\n    uint256 internal constant VaultBorrowRewards__NewMagnifierSameAsOldMagnifier = 36004;\n    uint256 internal constant VaultBorrowRewards__NotTheInitiator = 36005;\n    uint256 internal constant VaultBorrowRewards__NotTheGovernance = 36006;\n    uint256 internal constant VaultBorrowRewards__AlreadyStarted = 36007;\n    uint256 internal constant VaultBorrowRewards__RewardsNotStartedOrEnded = 36008;\n    uint256 internal constant VaultBorrowRewards__InvalidStartTime = 36009;\n    uint256 internal constant VaultBorrowRewards__AlreadyEnded = 36010;\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVault.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\ninterface IFluidVault {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice returns the vault id\n    function TYPE() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Tokens {\n        address token0;\n        address token1;\n    }\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address operateImplementation;\n        address adminImplementation;\n        address secondaryImplementation;\n        address deployer; // address which deploys oracle\n        address supply; // either liquidity layer or DEX protocol\n        address borrow; // either liquidity layer or DEX protocol\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\n        uint256 vaultId;\n        uint256 vaultType;\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n\n    function rebalance(\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_\n    ) external payable returns (int supplyAmt_, int borrowAmt_);\n\n    /// @notice reverts with FluidLiquidateResult\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT1.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidVaultT1 {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice returns the vault factory address\n    function VAULT_FACTORY() external view returns (address);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address adminImplementation;\n        address secondaryImplementation;\n        address supplyToken;\n        address borrowToken;\n        uint8 supplyDecimals;\n        uint8 borrowDecimals;\n        uint vaultId;\n        bytes32 liquiditySupplyExchangePriceSlot;\n        bytes32 liquidityBorrowExchangePriceSlot;\n        bytes32 liquidityUserSupplySlot;\n        bytes32 liquidityUserBorrowSlot;\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    function operate(\n        uint256 nftId_, // if 0 then new position\n        int256 newCol_, // if negative then withdraw\n        int256 newDebt_, // if negative then payback\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint actualDebtAmt_, uint actualColAmt_);\n\n    function absorb() payable external;\n\n    function rebalance() external payable returns (int supplyAmt_, int borrowAmt_);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n}\n"
    },
    "contracts/protocols/vault/vaultT1/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Events {\n    /// @notice emitted when the supply rate magnifier config is updated\n    event LogUpdateSupplyRateMagnifier(uint supplyRateMagnifier_);\n\n    /// @notice emitted when the borrow rate magnifier config is updated\n    event LogUpdateBorrowRateMagnifier(uint borrowRateMagnifier_);\n\n    /// @notice emitted when the collateral factor config is updated\n    event LogUpdateCollateralFactor(uint collateralFactor_);\n\n    /// @notice emitted when the liquidation threshold config is updated\n    event LogUpdateLiquidationThreshold(uint liquidationThreshold_);\n\n    /// @notice emitted when the liquidation max limit config is updated\n    event LogUpdateLiquidationMaxLimit(uint liquidationMaxLimit_);\n\n    /// @notice emitted when the withdrawal gap config is updated\n    event LogUpdateWithdrawGap(uint withdrawGap_);\n\n    /// @notice emitted when the liquidation penalty config is updated\n    event LogUpdateLiquidationPenalty(uint liquidationPenalty_);\n\n    /// @notice emitted when the borrow fee config is updated\n    event LogUpdateBorrowFee(uint borrowFee_);\n\n    /// @notice emitted when the core setting configs are updated\n    event LogUpdateCoreSettings(\n        uint supplyRateMagnifier_,\n        uint borrowRateMagnifier_,\n        uint collateralFactor_,\n        uint liquidationThreshold_,\n        uint liquidationMaxLimit_,\n        uint withdrawGap_,\n        uint liquidationPenalty_,\n        uint borrowFee_\n    );\n\n    /// @notice emitted when the oracle is updated\n    event LogUpdateOracle(address indexed newOracle_);\n\n    /// @notice emitted when the allowed rebalancer is updated\n    event LogUpdateRebalancer(address indexed newRebalancer_);\n\n    /// @notice emitted when funds are rescued\n    event LogRescueFunds(address indexed token_);\n\n    /// @notice emitted when dust debt is absorbed for `nftIds_`\n    event LogAbsorbDustDebt(uint256[] nftIds_, uint256 absorbedDustDebt_);\n}\n"
    },
    "contracts/protocols/vault/vaultT1/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { Variables } from \"../common/variables.sol\";\nimport { Events } from \"./events.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { IFluidVaultT1 } from \"../../interfaces/iVaultT1.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { TickMath } from \"../../../../libraries/tickMath.sol\";\nimport { SafeTransfer } from \"../../../../libraries/safeTransfer.sol\";\n\n/// @notice Fluid Vault protocol Admin Module contract.\n///         Implements admin related methods to set configs such as liquidation params, rates\n///         oracle address etc.\n///         Methods are limited to be called via delegateCall only. Vault CoreModule (\"VaultT1\" contract)\n///         is expected to call the methods implemented here after checking the msg.sender is authorized.\n///         All methods update the exchange prices in storage before changing configs.\ncontract FluidVaultT1Admin is Variables, Events, Error {\n    uint private constant X8 = 0xff;\n    uint private constant X10 = 0x3ff;\n    uint private constant X16 = 0xffff;\n    uint private constant X19 = 0x7ffff;\n    uint private constant X24 = 0xffffff;\n    uint internal constant X64 = 0xffffffffffffffff;\n    uint private constant X96 = 0xffffffffffffffffffffffff;\n    address private constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address private immutable addressThis;\n\n    constructor() {\n        addressThis = address(this);\n    }\n\n    modifier _verifyCaller() {\n        if (address(this) == addressThis) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev updates exchange price on storage, called on all admin methods in combination with _verifyCaller modifier so\n    /// only called by authorized delegatecall\n    modifier _updateExchangePrice() {\n        IFluidVaultT1(address(this)).updateExchangePricesOnStorage();\n        _;\n    }\n\n    function _checkLiquidationMaxLimitAndPenalty(uint liquidationMaxLimit_, uint liquidationPenalty_) private pure {\n        // liquidation max limit with penalty should not go above 99.7%\n        // As liquidation with penalty can happen from liquidation Threshold to max limit\n        // If it goes above 100% than that means liquidator is getting more collateral than user's available\n        if ((liquidationMaxLimit_ + liquidationPenalty_) > 9970) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n    }\n\n    /// @notice updates the supply rate magnifier to `supplyRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateSupplyRateMagnifier(uint supplyRateMagnifier_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateSupplyRateMagnifier(supplyRateMagnifier_);\n\n        if (supplyRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000) |\n            supplyRateMagnifier_;\n    }\n\n    /// @notice updates the borrow rate magnifier to `borrowRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateBorrowRateMagnifier(uint borrowRateMagnifier_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowRateMagnifier(borrowRateMagnifier_);\n\n        if (borrowRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff) |\n            (borrowRateMagnifier_ << 16);\n    }\n\n    /// @notice updates the collateral factor to `collateralFactor_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateCollateralFactor(uint collateralFactor_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateCollateralFactor(collateralFactor_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\n\n        collateralFactor_ = collateralFactor_ / 10;\n\n        if (collateralFactor_ >= liquidationThreshold_) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffc00ffffffff) |\n            (collateralFactor_ << 32);\n    }\n\n    /// @notice updates the liquidation threshold to `liquidationThreshold_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationThreshold(uint liquidationThreshold_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationThreshold(liquidationThreshold_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint collateralFactor_ = ((vaultVariables2_ >> 32) & X10);\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\n\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n\n        if ((collateralFactor_ >= liquidationThreshold_) || (liquidationThreshold_ >= liquidationMaxLimit_))\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffff003ffffffffff) |\n            (liquidationThreshold_ << 42);\n    }\n\n    /// @notice updates the liquidation max limit to `liquidationMaxLimit_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationMaxLimit(uint liquidationMaxLimit_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationMaxLimit(liquidationMaxLimit_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\n        uint liquidationPenalty_ = ((vaultVariables2_ >> 72) & X10);\n\n        // both are in 1e2 decimals (1e2 = 1%)\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n\n        if (liquidationThreshold_ >= liquidationMaxLimit_)\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffc00fffffffffffff) |\n            (liquidationMaxLimit_ << 52);\n    }\n\n    /// @notice updates the withdrawal gap to `withdrawGap_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateWithdrawGap(uint withdrawGap_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateWithdrawGap(withdrawGap_);\n\n        withdrawGap_ = withdrawGap_ / 10;\n\n        // withdrawGap must not be > 100%\n        if (withdrawGap_ > 1000) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffff003fffffffffffffff) |\n            (withdrawGap_ << 62);\n    }\n\n    /// @notice updates the liquidation penalty to `liquidationPenalty_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationPenalty(uint liquidationPenalty_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationPenalty(liquidationPenalty_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\n\n        // Converting liquidationMaxLimit_ in 1e2 decimals (1e2 = 1%)\n        _checkLiquidationMaxLimitAndPenalty((liquidationMaxLimit_ * 10), liquidationPenalty_);\n\n        if (liquidationPenalty_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffc00ffffffffffffffffff) |\n            (liquidationPenalty_ << 72);\n    }\n\n    /// @notice updates the borrow fee to `borrowFee_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateBorrowFee(uint borrowFee_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowFee(borrowFee_);\n\n        if (borrowFee_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff003ffffffffffffffffffff) |\n            (borrowFee_ << 82);\n    }\n\n    /// @notice updates the all Vault core settings according to input params.\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\n    function updateCoreSettings(\n        uint256 supplyRateMagnifier_,\n        uint256 borrowRateMagnifier_,\n        uint256 collateralFactor_,\n        uint256 liquidationThreshold_,\n        uint256 liquidationMaxLimit_,\n        uint256 withdrawGap_,\n        uint256 liquidationPenalty_,\n        uint256 borrowFee_\n    ) public _updateExchangePrice _verifyCaller {\n        // emitting the event at the start as then we are updating numbers to store in a more optimized way\n        emit LogUpdateCoreSettings(\n            supplyRateMagnifier_,\n            borrowRateMagnifier_,\n            collateralFactor_,\n            liquidationThreshold_,\n            liquidationMaxLimit_,\n            withdrawGap_,\n            liquidationPenalty_,\n            borrowFee_\n        );\n\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        collateralFactor_ = collateralFactor_ / 10;\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n        withdrawGap_ = withdrawGap_ / 10;\n\n        if (\n            (supplyRateMagnifier_ > X16) ||\n            (borrowRateMagnifier_ > X16) ||\n            (collateralFactor_ >= liquidationThreshold_) ||\n            (liquidationThreshold_ >= liquidationMaxLimit_) ||\n            (withdrawGap_ > X10) ||\n            (liquidationPenalty_ > X10) ||\n            (borrowFee_ > X10)\n        ) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff00000000000000000000000) |\n            supplyRateMagnifier_ |\n            (borrowRateMagnifier_ << 16) |\n            (collateralFactor_ << 32) |\n            (liquidationThreshold_ << 42) |\n            (liquidationMaxLimit_ << 52) |\n            (withdrawGap_ << 62) |\n            (liquidationPenalty_ << 72) |\n            (borrowFee_ << 82);\n    }\n\n    /// @notice updates the Vault oracle to `newOracle_`. Must implement the FluidOracle interface.\n    function updateOracle(address newOracle_) public _updateExchangePrice _verifyCaller {\n        if (newOracle_ == address(0)) revert FluidVaultError(ErrorTypes.VaultAdmin__AddressZeroNotAllowed);\n\n        // Removing current oracle by masking only first 96 bits then inserting new oracle as bits\n        vaultVariables2 = (vaultVariables2 & X96) | (uint256(uint160(newOracle_)) << 96);\n\n        emit LogUpdateOracle(newOracle_);\n    }\n\n    /// @notice updates the allowed rebalancer to `newRebalancer_`.\n    function updateRebalancer(address newRebalancer_) public _updateExchangePrice _verifyCaller {\n        if (newRebalancer_ == address(0)) revert FluidVaultError(ErrorTypes.VaultAdmin__AddressZeroNotAllowed);\n\n        rebalancer = newRebalancer_;\n\n        emit LogUpdateRebalancer(newRebalancer_);\n    }\n\n    /// @notice sends any potentially stuck funds to Liquidity contract.\n    /// @dev this contract never holds any funds as all operations send / receive funds from user <-> Liquidity.\n    function rescueFunds(address token_) external _verifyCaller {\n        if (token_ == NATIVE_TOKEN) {\n            SafeTransfer.safeTransferNative(IFluidVaultT1(address(this)).LIQUIDITY(), address(this).balance);\n        } else {\n            SafeTransfer.safeTransfer(\n                token_,\n                IFluidVaultT1(address(this)).LIQUIDITY(),\n                IERC20(token_).balanceOf(address(this))\n            );\n        }\n\n        emit LogRescueFunds(token_);\n    }\n\n    /// @notice absorbs accumulated dust debt\n    /// @dev in decades if a lot of positions are 100% liquidated (aka absorbed) then dust debt can mount up\n    /// which is basically sort of an extra revenue for the protocol.\n    //\n    // this function might never come in use that's why adding it in admin module\n    function absorbDustDebt(uint[] memory nftIds_) public _verifyCaller {\n        uint256 vaultVariables_ = vaultVariables;\n        // re-entrancy check\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        uint nftId_;\n        uint posData_;\n        int posTick_;\n        uint tickId_;\n        uint posCol_;\n        uint posDebt_;\n        uint posDustDebt_;\n        uint tickData_;\n\n        uint absorbedDustDebt_ = absorbedDustDebt;\n\n        for (uint i = 0; i < nftIds_.length; ) {\n            nftId_ = nftIds_[i];\n            if (nftId_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftIdShouldBeNonZero);\n            }\n\n            // user's position data\n            posData_ = positionData[nftId_];\n\n            if (posData_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotOfThisVault);\n            }\n\n            posCol_ = (posData_ >> 45) & X64;\n            // Converting big number into normal number\n            posCol_ = (posCol_ >> 8) << (posCol_ & X8);\n\n            posDustDebt_ = (posData_ >> 109) & X64;\n            // Converting big number into normal number\n            posDustDebt_ = (posDustDebt_ >> 8) << (posDustDebt_ & X8);\n\n            if (posDustDebt_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__DustDebtIsZero);\n            }\n\n            // borrow position (has collateral & debt)\n            posTick_ = posData_ & 2 == 2 ? int((posData_ >> 2) & X19) : -int((posData_ >> 2) & X19);\n            tickId_ = (posData_ >> 21) & X24;\n\n            posDebt_ = (TickMath.getRatioAtTick(int24(posTick_)) * posCol_) >> 96;\n\n            // Tick data from user's tick\n            tickData_ = tickData[posTick_];\n\n            // Checking if tick is liquidated OR if the total IDs of tick is greater than user's tick ID\n            if (((tickData_ & 1) == 1) || (((tickData_ >> 1) & X24) > tickId_)) {\n                // User got liquidated\n                (, posDebt_, , , ) = IFluidVaultT1(address(this)).fetchLatestPosition(\n                    posTick_,\n                    tickId_,\n                    posDebt_,\n                    tickData_\n                );\n                if (posDebt_ > 0) {\n                    revert FluidVaultError(ErrorTypes.VaultAdmin__FinalDebtShouldBeZero);\n                }\n                // absorbing user's debt as it's 100% or almost 100% liquidated\n                absorbedDustDebt_ = absorbedDustDebt_ + posDustDebt_;\n                // making position as supply only\n                positionData[nftId_] = 1;\n            } else {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotLiquidated);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n\n        if (absorbedDustDebt_ == 0) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__AbsorbedDustDebtIsZero);\n        }\n\n        uint totalBorrow_ = (vaultVariables_ >> 146) & X64;\n        // Converting big number into normal number\n        totalBorrow_ = (totalBorrow_ >> 8) << (totalBorrow_ & X8);\n        // note: by default dust debt is not added into total borrow but on 100% liquidation (aka absorb) dust debt equivalent\n        // is removed from total borrow so adding it back again here\n        totalBorrow_ = totalBorrow_ + absorbedDustDebt_;\n        totalBorrow_ = BigMathMinified.toBigNumber(totalBorrow_, 56, 8, BigMathMinified.ROUND_UP);\n\n        // adding absorbed dust debt to total borrow so it will get included in the next rebalancing.\n        // there is some fuzziness here as when the position got fully liquidated (aka absorbed) the exchange price was different\n        // than what it'll be now. The fuzziness which will be extremely small so we can ignore it\n        // updating on storage\n        vaultVariables =\n            (vaultVariables_ & 0xfffffffffffc0000000000000003ffffffffffffffffffffffffffffffffffff) |\n            (totalBorrow_ << 146);\n\n        // updating on storage\n        absorbedDustDebt = 0;\n\n        emit LogAbsorbDustDebt(nftIds_, absorbedDustDebt_);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT1/common/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Variables {\n    /***********************************|\n    |         Storage Variables         |\n    |__________________________________*/\n\n    /// note: in all variables. For tick >= 0 are represented with bit as 1, tick < 0 are represented with bit as 0\n    /// note: read all the variables through storageRead.sol\n\n    /// note: vaultVariables contains vault variables which need regular updates through transactions\n    /// First 1 bit => 0 => re-entrancy. If 0 then allow transaction to go, else throw.\n    /// Next 1 bit => 1 => Is the current active branch liquidated? If true then check the branch's minima tick before creating a new position\n    /// If the new tick is greater than minima tick then initialize a new branch, make that as current branch & do proper linking\n    /// Next 1 bit => 2 => sign of topmost tick (0 -> negative; 1 -> positive)\n    /// Next 19 bits => 3-21 => absolute value of topmost tick\n    /// Next 30 bits => 22-51 => current branch ID\n    /// Next 30 bits => 52-81 => total branch ID\n    /// Next 64 bits => 82-145 => Total supply\n    /// Next 64 bits => 146-209 => Total borrow\n    /// Next 32 bits => 210-241 => Total positions\n    uint256 internal vaultVariables;\n\n    /// note: vaultVariables2 contains variables which do not update on every transaction. So mainly admin/auth set amount\n    /// First 16 bits => 0-15 => supply rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\n    /// Next 16 bits => 16-31 => borrow rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\n    /// Next 10 bits => 32-41 => collateral factor. 800 = 0.8 = 80% (max precision of 0.1%)\n    /// Next 10 bits => 42-51 => liquidation Threshold. 900 = 0.9 = 90% (max precision of 0.1%)\n    /// Next 10 bits => 52-61 => liquidation Max Limit. 950 = 0.95 = 95% (max precision of 0.1%) (above this 100% liquidation can happen)\n    /// Next 10 bits => 62-71 => withdraw gap. 100 = 0.1 = 10%. (max precision of 0.1%) (max 7 bits can also suffice for the requirement here of 0.1% to 10%). Needed to save some limits on withdrawals so liquidate can work seamlessly.\n    /// Next 10 bits => 72-81 => liquidation penalty. 100 = 0.01 = 1%. (max precision of 0.01%) (max liquidation penantly can be 10.23%). Applies when tick is in between liquidation Threshold & liquidation Max Limit.\n    /// Next 10 bits => 82-91 => borrow fee. 100 = 0.01 = 1%. (max precision of 0.01%) (max borrow fee can be 10.23%). Fees on borrow.\n    /// Next 4  bits => 92-95 => empty\n    /// Next 160 bits => 96-255 => Oracle address\n    uint256 internal vaultVariables2;\n\n    /// note: stores absorbed liquidity\n    /// First 128 bits raw debt amount\n    /// last 128 bits raw col amount\n    uint256 internal absorbedLiquidity;\n\n    /// position index => position data uint\n    /// if the entire variable is 0 (meaning not initialized) at the start that means no position at all\n    /// First 1 bit => 0 => position type (0 => borrow position; 1 => supply position)\n    /// Next 1 bit => 1 => sign of user's tick (0 => negative; 1 => positive)\n    /// Next 19 bits => 2-20 => absolute value of user's tick\n    /// Next 24 bits => 21-44 => user's tick's id\n    /// Below we are storing user's collateral & not debt, because the position can also be only collateral with no tick but it can never be only debt\n    /// Next 64 bits => 45-108 => user's supply amount. Debt will be calculated through supply & ratio.\n    /// Next 64 bits => 109-172 => user's dust debt amount. User's net debt = total debt - dust amount. Total debt is calculated through supply & ratio\n    /// User won't pay any extra interest on dust debt & hence we will not show it as a debt on UI. For user's there's no dust.\n    mapping(uint256 => uint256) internal positionData;\n\n    /// Tick has debt only keeps data of non liquidated positions. liquidated tick's data stays in branch itself\n    /// tick parent => uint (represents bool for 256 children)\n    /// parent of (i)th tick:-\n    /// if (i>=0) (i / 256);\n    /// else ((i + 1) / 256) - 1\n    /// first bit of the variable is the smallest tick & last bit is the biggest tick of that slot\n    mapping(int256 => uint256) internal tickHasDebt;\n\n    /// mapping tickId => tickData\n    /// Tick related data. Total debt & other things\n    /// First bit => 0 => If 1 then liquidated else not liquidated\n    /// Next 24 bits => 1-24 => Total IDs. ID should start from 1.\n    /// If not liquidated:\n    /// Next 64 bits => 25-88 => raw debt\n    /// If liquidated\n    /// The below 3 things are of last ID. This is to be updated when user creates a new position\n    /// Next 1 bit => 25 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated (100% liquidated)\n    /// Next 30 bits => 26-55 => branch ID where this tick got liquidated\n    /// Next 50 bits => 56-105 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    mapping(int256 => uint256) internal tickData;\n\n    /// tick id => previous tick id liquidation data. ID starts from 1\n    /// One tick ID contains 3 IDs of 80 bits in it, holding liquidation data of previously active but liquidated ticks\n    /// 81 bits data below\n    /// #### First 85 bits ####\n    /// 1st bit => 0 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 1-30 => branch ID where this tick got liquidated\n    /// Next 50 bits => 31-80 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    /// #### Second 85 bits ####\n    /// 85th bit => 85 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 86-115 => branch ID where this tick got liquidated\n    /// Next 50 bits => 116-165 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    /// #### Third 85 bits ####\n    /// 170th bit => 170 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 171-200 => branch ID where this tick got liquidated\n    /// Next 50 bits => 201-250 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    mapping(int256 => mapping(uint256 => uint256)) internal tickId;\n\n    /// mapping branchId => branchData\n    /// First 2 bits => 0-1 => if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\n    /// merged means the branch is merged into it's base branch\n    /// closed means all the users are 100% liquidated\n    /// Next 1 bit => 2 => minima tick sign of this branch. Will only be there if any liquidation happened.\n    /// Next 19 bits => 3-21 => minima tick of this branch. Will only be there if any liquidation happened.\n    /// Next 30 bits => 22-51 => Partials of minima tick of branch this is connected to. 0 if master branch.\n    /// Next 64 bits => 52-115 Debt liquidity at this branch. Similar to last's top tick data. Remaining debt will move here from tickData after first liquidation\n    /// If not merged\n    /// Next 50 bits => 116-165 => Debt factor or of this branch. (35 bits coefficient | 15 bits expansion)\n    /// If merged\n    /// Next 50 bits => 116-165 => Connection/adjustment debt factor of this branch with the next branch.\n    /// If closed\n    /// Next 50 bits => 116-165 => Debt factor as 0. As all the user's positions are now fully gone\n    /// following values are present always again (merged / not merged / closed)\n    /// Next 30 bits => 166-195 => Branch's ID with which this branch is connected. If 0 then that means this is the master branch\n    /// Next 1 bit => 196 => sign of minima tick of branch this is connected to. 0 if master branch.\n    /// Next 19 bits => 197-215 => minima tick of branch this is connected to. 0 if master branch.\n    mapping(uint256 => uint256) internal branchData;\n\n    /// Exchange prices are in 1e12\n    /// First 64 bits => 0-63 => Liquidity's collateral token supply exchange price\n    /// First 64 bits => 64-127 => Liquidity's debt token borrow exchange price\n    /// First 64 bits => 128-191 => Vault's collateral token supply exchange price\n    /// First 64 bits => 192-255 => Vault's debt token borrow exchange price\n    uint256 internal rates;\n\n    /// address of rebalancer\n    address internal rebalancer;\n\n    uint256 internal absorbedDustDebt;\n}\n"
    },
    "contracts/protocols/vault/vaultT2/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract VaultT2Events {\n    /// @notice emitted when the supply rate config is updated\n    event LogUpdateSupplyRate(int supplyRate_);\n\n    /// @notice emitted when the borrow rate magnifier config is updated\n    event LogUpdateBorrowRateMagnifier(uint borrowRateMagnifier_);\n\n    /// @notice emitted when the core setting configs are updated\n    event LogUpdateCoreSettings(\n        int supplyRate_,\n        uint borrowRateMagnifier_,\n        uint collateralFactor_,\n        uint liquidationThreshold_,\n        uint liquidationMaxLimit_,\n        uint withdrawGap_,\n        uint liquidationPenalty_,\n        uint borrowFee_\n    );\n}\n"
    },
    "contracts/protocols/vault/vaultT2/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidVaultAdmin } from \"../../vaultTypesCommon/adminModule/main.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { VaultT2Events } from \"./events.sol\";\n\n/// @notice Fluid Vault protocol Admin Module contract.\n///         Implements admin related methods to set configs such as liquidation params, rates\n///         oracle address etc.\n///         Methods are limited to be called via delegateCall only. Vault CoreModule is expected\n///         to call the methods implemented here after checking the msg.sender is authorized.\n///         All methods update the exchange prices in storage before changing configs.\ncontract FluidVaultT2Admin is FluidVaultAdmin, VaultT2Events {\n    /// @notice updates the supply rate. Input in 1e2 (1% = 100, 100% = 10_000). If positive then incentives else charging\n    function updateSupplyRate(int supplyRate_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateSupplyRate(supplyRate_);\n\n        if ((supplyRate_ > int(X15)) || (-supplyRate_ > int(X15))) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        uint supplyRateToInsert_ = supplyRate_ < 0 ? (uint(-supplyRate_) << 1) : (uint(1) | (uint(supplyRate_) << 1));\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000) |\n            supplyRateToInsert_;\n    }\n\n    /// @notice updates the borrow rate magnifier to `borrowRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateBorrowRateMagnifier(uint borrowRateMagnifier_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowRateMagnifier(borrowRateMagnifier_);\n\n        if (borrowRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff) |\n            (borrowRateMagnifier_ << 16);\n    }\n\n    /// @notice updates the all Vault core settings according to input params.\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\n    function updateCoreSettings(\n        int256 supplyRate_,\n        uint256 borrowRateMagnifier_,\n        uint256 collateralFactor_,\n        uint256 liquidationThreshold_,\n        uint256 liquidationMaxLimit_,\n        uint256 withdrawGap_,\n        uint256 liquidationPenalty_,\n        uint256 borrowFee_\n    ) public _updateExchangePrice _verifyCaller {\n        // emitting the event at the start as then we are updating numbers to store in a more optimized way\n        emit LogUpdateCoreSettings(\n            supplyRate_,\n            borrowRateMagnifier_,\n            collateralFactor_,\n            liquidationThreshold_,\n            liquidationMaxLimit_,\n            withdrawGap_,\n            liquidationPenalty_,\n            borrowFee_\n        );\n\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        collateralFactor_ = collateralFactor_ / 10;\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n        withdrawGap_ = withdrawGap_ / 10;\n\n        if (\n            (supplyRate_ > int(X15)) ||\n            (-supplyRate_ > int(X15)) ||\n            (borrowRateMagnifier_ > X16) ||\n            (collateralFactor_ >= liquidationThreshold_) ||\n            (liquidationThreshold_ >= liquidationMaxLimit_) ||\n            (withdrawGap_ > X10) ||\n            (liquidationPenalty_ > X10) ||\n            (borrowFee_ > X10)\n        ) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        uint supplyRateToInsert_ = supplyRate_ < 0 ? (uint(-supplyRate_) << 1) : (uint(1) | (uint(supplyRate_) << 1));\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff00000000000000000000000) |\n            supplyRateToInsert_ |\n            (borrowRateMagnifier_ << 16) |\n            (collateralFactor_ << 32) |\n            (liquidationThreshold_ << 42) |\n            (liquidationMaxLimit_ << 52) |\n            (withdrawGap_ << 62) |\n            (liquidationPenalty_ << 72) |\n            (borrowFee_ << 82);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT3/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract VaultT3Events {\n    /// @notice emitted when the supply rate magnifier config is updated\n    event LogUpdateSupplyRateMagnifier(uint supplyRateMagnifier_);\n\n    /// @notice emitted when the borrow rate config is updated\n    event LogUpdateBorrowRate(int borrowRate_);\n\n    /// @notice emitted when the core setting configs are updated\n    event LogUpdateCoreSettings(\n        uint supplyRateMagnifier_,\n        int borrowRate_,\n        uint collateralFactor_,\n        uint liquidationThreshold_,\n        uint liquidationMaxLimit_,\n        uint withdrawGap_,\n        uint liquidationPenalty_,\n        uint borrowFee_\n    );\n}\n"
    },
    "contracts/protocols/vault/vaultT3/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidVaultAdmin } from \"../../vaultTypesCommon/adminModule/main.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { VaultT3Events } from \"./events.sol\";\n\n/// @notice Fluid Vault protocol Admin Module contract.\n///         Implements admin related methods to set configs such as liquidation params, rates\n///         oracle address etc.\n///         Methods are limited to be called via delegateCall only. Vault CoreModule is expected\n///         to call the methods implemented here after checking the msg.sender is authorized.\n///         All methods update the exchange prices in storage before changing configs.\ncontract FluidVaultT3Admin is FluidVaultAdmin, VaultT3Events {\n    /// @notice updates the supply rate magnifier to `supplyRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateSupplyRateMagnifier(uint supplyRateMagnifier_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateSupplyRateMagnifier(supplyRateMagnifier_);\n\n        if (supplyRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000) |\n            supplyRateMagnifier_;\n    }\n\n    /// @notice updates the borrow rate. Input in 1e2 (1% = 100, 100% = 10_000). If positive then charging else incentives\n    function updateBorrowRate(int borrowRate_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowRate(borrowRate_);\n\n        if ((borrowRate_ > int(X15)) || (-borrowRate_ > int(X15))) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        uint borrowRateToInsert_ = borrowRate_ < 0 ? ((uint(-borrowRate_) << 1)) : (uint(1) | (uint(borrowRate_) << 1));\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff) |\n            (borrowRateToInsert_ << 16);\n    }\n\n    /// @notice updates the all Vault core settings according to input params.\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\n    function updateCoreSettings(\n        uint256 supplyRateMagnifier_,\n        int256 borrowRate_,\n        uint256 collateralFactor_,\n        uint256 liquidationThreshold_,\n        uint256 liquidationMaxLimit_,\n        uint256 withdrawGap_,\n        uint256 liquidationPenalty_,\n        uint256 borrowFee_\n    ) public _updateExchangePrice _verifyCaller {\n        // emitting the event at the start as then we are updating numbers to store in a more optimized way\n        emit LogUpdateCoreSettings(\n            supplyRateMagnifier_,\n            borrowRate_,\n            collateralFactor_,\n            liquidationThreshold_,\n            liquidationMaxLimit_,\n            withdrawGap_,\n            liquidationPenalty_,\n            borrowFee_\n        );\n\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        collateralFactor_ = collateralFactor_ / 10;\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n        withdrawGap_ = withdrawGap_ / 10;\n\n        if (\n            (supplyRateMagnifier_ > X16) ||\n            (borrowRate_ > int(X15)) ||\n            (-borrowRate_ > int(X15)) ||\n            (collateralFactor_ >= liquidationThreshold_) ||\n            (liquidationThreshold_ >= liquidationMaxLimit_) ||\n            (withdrawGap_ > X10) ||\n            (liquidationPenalty_ > X10) ||\n            (borrowFee_ > X10)\n        ) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        uint borrowRateToInsert_ = borrowRate_ < 0 ? ((uint(-borrowRate_) << 1)) : (uint(1) | (uint(borrowRate_) << 1));\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff00000000000000000000000) |\n            supplyRateMagnifier_ |\n            (borrowRateToInsert_ << 16) |\n            (collateralFactor_ << 32) |\n            (liquidationThreshold_ << 42) |\n            (liquidationMaxLimit_ << 52) |\n            (withdrawGap_ << 62) |\n            (liquidationPenalty_ << 72) |\n            (borrowFee_ << 82);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Events {\n    /// @notice emitted when the collateral factor config is updated\n    event LogUpdateCollateralFactor(uint collateralFactor_);\n\n    /// @notice emitted when the liquidation threshold config is updated\n    event LogUpdateLiquidationThreshold(uint liquidationThreshold_);\n\n    /// @notice emitted when the liquidation max limit config is updated\n    event LogUpdateLiquidationMaxLimit(uint liquidationMaxLimit_);\n\n    /// @notice emitted when the withdrawal gap config is updated\n    event LogUpdateWithdrawGap(uint withdrawGap_);\n\n    /// @notice emitted when the liquidation penalty config is updated\n    event LogUpdateLiquidationPenalty(uint liquidationPenalty_);\n\n    /// @notice emitted when the borrow fee config is updated\n    event LogUpdateBorrowFee(uint borrowFee_);\n\n    /// @notice emitted when the oracle is updated\n    event LogUpdateOracle(uint indexed deploymentNonce_, address indexed newOracle_);\n\n    /// @notice emitted when the allowed rebalancer is updated\n    event LogUpdateRebalancer(address indexed newRebalancer_);\n\n    /// @notice emitted when funds are rescued\n    event LogRescueFunds(address indexed token_);\n\n    /// @notice emitted when dust debt is absorbed for `nftIds_`\n    event LogAbsorbDustDebt(uint256[] nftIds_, uint256 absorbedDustDebt_);\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IFluidOracle } from \"../../../../oracle/fluidOracle.sol\";\n\nimport { Variables } from \"../common/variables.sol\";\nimport { Events } from \"./events.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { IFluidVault } from \"../../interfaces/iVault.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { TickMath } from \"../../../../libraries/tickMath.sol\";\nimport { AddressCalcs } from \"../../../../libraries/addressCalcs.sol\";\nimport { SafeTransfer } from \"../../../../libraries/safeTransfer.sol\";\n\n/// @notice Fluid Vault protocol Admin Module contract.\n///         Implements admin related methods to set configs such as liquidation params, rates\n///         oracle address etc.\n///         Methods are limited to be called via delegateCall only. Vault CoreModule (\"VaultT1\" contract)\n///         is expected to call the methods implemented here after checking the msg.sender is authorized.\n///         All methods update the exchange prices in storage before changing configs.\nabstract contract FluidVaultAdmin is Variables, Events, Error {\n    uint internal constant X8 = 0xff;\n    uint internal constant X10 = 0x3ff;\n    uint internal constant X15 = 0x7fff;\n    uint internal constant X16 = 0xffff;\n    uint internal constant X19 = 0x7ffff;\n    uint internal constant X24 = 0xffffff;\n    uint internal constant X30 = 0x3fffffff;\n    uint internal constant X64 = 0xffffffffffffffff;\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address internal immutable addressThis;\n\n    constructor() {\n        addressThis = address(this);\n    }\n\n    modifier _verifyCaller() {\n        if (address(this) == addressThis) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev updates exchange price on storage, called on all admin methods in combination with _verifyCaller modifier so\n    /// only called by authorized delegatecall\n    modifier _updateExchangePrice() {\n        IFluidVault(address(this)).updateExchangePricesOnStorage();\n        _;\n    }\n\n    function _checkLiquidationMaxLimitAndPenalty(uint liquidationMaxLimit_, uint liquidationPenalty_) internal pure {\n        // liquidation max limit with penalty should not go above 99.7%\n        // As liquidation with penalty can happen from liquidation Threshold to max limit\n        // If it goes above 100% than that means liquidator is getting more collateral than user's available\n        if ((liquidationMaxLimit_ + liquidationPenalty_) > 9970) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n    }\n\n    /// @notice updates the collateral factor to `collateralFactor_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateCollateralFactor(uint collateralFactor_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateCollateralFactor(collateralFactor_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\n\n        collateralFactor_ = collateralFactor_ / 10;\n\n        if (collateralFactor_ >= liquidationThreshold_) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffc00ffffffff) |\n            (collateralFactor_ << 32);\n    }\n\n    /// @notice updates the liquidation threshold to `liquidationThreshold_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationThreshold(uint liquidationThreshold_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationThreshold(liquidationThreshold_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint collateralFactor_ = ((vaultVariables2_ >> 32) & X10);\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\n\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n\n        if ((collateralFactor_ >= liquidationThreshold_) || (liquidationThreshold_ >= liquidationMaxLimit_))\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffff003ffffffffff) |\n            (liquidationThreshold_ << 42);\n    }\n\n    /// @notice updates the liquidation max limit to `liquidationMaxLimit_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationMaxLimit(uint liquidationMaxLimit_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationMaxLimit(liquidationMaxLimit_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\n        uint liquidationPenalty_ = ((vaultVariables2_ >> 72) & X10);\n\n        // both are in 1e2 decimals (1e2 = 1%)\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n\n        if (liquidationThreshold_ >= liquidationMaxLimit_)\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffc00fffffffffffff) |\n            (liquidationMaxLimit_ << 52);\n    }\n\n    /// @notice updates the withdrawal gap to `withdrawGap_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateWithdrawGap(uint withdrawGap_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateWithdrawGap(withdrawGap_);\n\n        withdrawGap_ = withdrawGap_ / 10;\n\n        // withdrawGap must not be > 100%\n        if (withdrawGap_ > 1000) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffff003fffffffffffffff) |\n            (withdrawGap_ << 62);\n    }\n\n    /// @notice updates the liquidation penalty to `liquidationPenalty_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationPenalty(uint liquidationPenalty_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationPenalty(liquidationPenalty_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\n\n        // Converting liquidationMaxLimit_ in 1e2 decimals (1e2 = 1%)\n        _checkLiquidationMaxLimitAndPenalty((liquidationMaxLimit_ * 10), liquidationPenalty_);\n\n        if (liquidationPenalty_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffc00ffffffffffffffffff) |\n            (liquidationPenalty_ << 72);\n    }\n\n    /// @notice updates the borrow fee to `borrowFee_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateBorrowFee(uint borrowFee_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowFee(borrowFee_);\n\n        if (borrowFee_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff003ffffffffffffffffffff) |\n            (borrowFee_ << 82);\n    }\n\n    /// @notice updates the Vault oracle to `newOracleNonce_`. Must implement the FluidOracle interface.\n    function updateOracle(uint newOracleNonce_) public _updateExchangePrice _verifyCaller {\n        if (newOracleNonce_ > X30) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        // masking to remove old oracle and keep all the other values intact\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffc0000000fffffffffffffffffffffff) |\n            (newOracleNonce_ << 92);\n\n        IFluidVault.ConstantViews memory c_ = IFluidVault(address(this)).constantsView();\n\n        address oracle_ = AddressCalcs.addressCalc(c_.deployer, newOracleNonce_);\n\n        // checking if oracle address follows the standard\n        IFluidOracle(oracle_).getExchangeRateOperate();\n        IFluidOracle(oracle_).getExchangeRateLiquidate();\n\n        emit LogUpdateOracle(newOracleNonce_, oracle_);\n    }\n\n    /// @notice updates the allowed rebalancer to `newRebalancer_`.\n    function updateRebalancer(address newRebalancer_) public _updateExchangePrice _verifyCaller {\n        if (newRebalancer_ == address(0)) revert FluidVaultError(ErrorTypes.VaultAdmin__AddressZeroNotAllowed);\n\n        rebalancer = newRebalancer_;\n\n        emit LogUpdateRebalancer(newRebalancer_);\n    }\n\n    /// @notice sends any potentially stuck funds to Liquidity contract.\n    /// @dev this contract never holds any funds as all operations send / receive funds from user <-> Liquidity.\n    function rescueFunds(address token_) external _verifyCaller {\n        if (token_ == NATIVE_TOKEN) {\n            SafeTransfer.safeTransferNative(IFluidVault(address(this)).LIQUIDITY(), address(this).balance);\n        } else {\n            SafeTransfer.safeTransfer(\n                token_,\n                IFluidVault(address(this)).LIQUIDITY(),\n                IERC20(token_).balanceOf(address(this))\n            );\n        }\n\n        emit LogRescueFunds(token_);\n    }\n\n    /// @notice absorbs accumulated dust debt\n    /// @dev in decades if a lot of positions are 100% liquidated (aka absorbed) then dust debt can mount up\n    /// which is basically sort of an extra revenue for the protocol.\n    //\n    // this function might never come in use that's why adding it in admin module\n    function absorbDustDebt(uint[] memory nftIds_) public _verifyCaller {\n        uint256 vaultVariables_ = vaultVariables;\n        // re-entrancy check\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        uint nftId_;\n        uint posData_;\n        int posTick_;\n        uint tickId_;\n        uint posCol_;\n        uint posDebt_;\n        uint posDustDebt_;\n        uint tickData_;\n\n        uint absorbedDustDebt_ = absorbedDustDebt;\n\n        for (uint i = 0; i < nftIds_.length; ) {\n            nftId_ = nftIds_[i];\n            if (nftId_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftIdShouldBeNonZero);\n            }\n\n            // user's position data\n            posData_ = positionData[nftId_];\n\n            if (posData_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotOfThisVault);\n            }\n\n            posCol_ = (posData_ >> 45) & X64;\n            // Converting big number into normal number\n            posCol_ = (posCol_ >> 8) << (posCol_ & X8);\n\n            posDustDebt_ = (posData_ >> 109) & X64;\n            // Converting big number into normal number\n            posDustDebt_ = (posDustDebt_ >> 8) << (posDustDebt_ & X8);\n\n            if (posDustDebt_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__DustDebtIsZero);\n            }\n\n            // borrow position (has collateral & debt)\n            posTick_ = posData_ & 2 == 2 ? int((posData_ >> 2) & X19) : -int((posData_ >> 2) & X19);\n            tickId_ = (posData_ >> 21) & X24;\n\n            posDebt_ = (TickMath.getRatioAtTick(int24(posTick_)) * posCol_) >> 96;\n\n            // Tick data from user's tick\n            tickData_ = tickData[posTick_];\n\n            // Checking if tick is liquidated OR if the total IDs of tick is greater than user's tick ID\n            if (((tickData_ & 1) == 1) || (((tickData_ >> 1) & X24) > tickId_)) {\n                // User got liquidated\n                (, posDebt_, , , ) = IFluidVault(address(this)).fetchLatestPosition(\n                    posTick_,\n                    tickId_,\n                    posDebt_,\n                    tickData_\n                );\n                if (posDebt_ > 0) {\n                    revert FluidVaultError(ErrorTypes.VaultAdmin__FinalDebtShouldBeZero);\n                }\n                // absorbing user's debt as it's 100% or almost 100% liquidated\n                absorbedDustDebt_ = absorbedDustDebt_ + posDustDebt_;\n                // making position as supply only\n                positionData[nftId_] = 1;\n            } else {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotLiquidated);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n\n        if (absorbedDustDebt_ == 0) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__AbsorbedDustDebtIsZero);\n        }\n\n        uint totalBorrow_ = (vaultVariables_ >> 146) & X64;\n        // Converting big number into normal number\n        totalBorrow_ = (totalBorrow_ >> 8) << (totalBorrow_ & X8);\n        // note: by default dust debt is not added into total borrow but on 100% liquidation (aka absorb) dust debt equivalent\n        // is removed from total borrow so adding it back again here\n        totalBorrow_ = totalBorrow_ + absorbedDustDebt_;\n        totalBorrow_ = BigMathMinified.toBigNumber(totalBorrow_, 56, 8, BigMathMinified.ROUND_UP);\n\n        // adding absorbed dust debt to total borrow so it will get included in the next rebalancing.\n        // there is some fuzziness here as when the position got fully liquidated (aka absorbed) the exchange price was different\n        // than what it'll be now. The fuzziness which will be extremely small so we can ignore it\n        // updating on storage\n        vaultVariables =\n            (vaultVariables_ & 0xfffffffffffc0000000000000003ffffffffffffffffffffffffffffffffffff) |\n            (totalBorrow_ << 146);\n\n        // updating on storage\n        absorbedDustDebt = 0;\n\n        emit LogAbsorbDustDebt(nftIds_, absorbedDustDebt_);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/common/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Variables {\n    /***********************************|\n    |         Storage Variables         |\n    |__________________________________*/\n\n    /// note: in all variables. For tick >= 0 are represented with bit as 1, tick < 0 are represented with bit as 0\n    /// note: read all the variables through storageRead.sol\n\n    /// note: vaultVariables contains vault variables which need regular updates through transactions\n    /// First 1 bit => 0 => re-entrancy. If 0 then allow transaction to go, else throw.\n    /// Next 1 bit => 1 => Is the current active branch liquidated? If true then check the branch's minima tick before creating a new position\n    /// If the new tick is greater than minima tick then initialize a new branch, make that as current branch & do proper linking\n    /// Next 1 bit => 2 => sign of topmost tick (0 -> negative; 1 -> positive)\n    /// Next 19 bits => 3-21 => absolute value of topmost tick\n    /// Next 30 bits => 22-51 => current branch ID\n    /// Next 30 bits => 52-81 => total branch ID\n    /// Next 64 bits => 82-145 => Total supply\n    /// Next 64 bits => 146-209 => Total borrow\n    /// Next 32 bits => 210-241 => Total positions\n    uint256 internal vaultVariables;\n\n    /// note: vaultVariables2 contains variables which do not update on every transaction. So mainly admin/auth set amount\n    /// First 16 bits => 0-15 => supply rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\n    /// Next 16 bits => 16-31 => borrow rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\n    /// Next 10 bits => 32-41 => collateral factor. 800 = 0.8 = 80% (max precision of 0.1%)\n    /// Next 10 bits => 42-51 => liquidation Threshold. 900 = 0.9 = 90% (max precision of 0.1%)\n    /// Next 10 bits => 52-61 => liquidation Max Limit. 950 = 0.95 = 95% (max precision of 0.1%) (above this 100% liquidation can happen)\n    /// Next 10 bits => 62-71 => withdraw gap. 100 = 0.1 = 10%. (max precision of 0.1%) (max 7 bits can also suffice for the requirement here of 0.1% to 10%). Needed to save some limits on withdrawals so liquidate can work seamlessly.\n    /// Next 10 bits => 72-81 => liquidation penalty. 100 = 0.01 = 1%. (max precision of 0.01%) (max liquidation penantly can be 10.23%). Applies when tick is in between liquidation Threshold & liquidation Max Limit.\n    /// Next 10 bits => 82-91 => borrow fee. 100 = 0.01 = 1%. (max precision of 0.01%) (max borrow fee can be 10.23%). Fees on borrow.\n    /// Next 30 bits => 92-121 => bits to calculate address of oracle\n    /// Next 33 bits => 122-154 => last update timestamp\n    uint256 internal vaultVariables2;\n\n    /// note: stores absorbed liquidity\n    /// First 128 bits raw debt amount\n    /// last 128 bits raw col amount\n    uint256 internal absorbedLiquidity;\n\n    /// position index => position data uint\n    /// if the entire variable is 0 (meaning not initialized) at the start that means no position at all\n    /// First 1 bit => 0 => position type (0 => borrow position; 1 => supply position)\n    /// Next 1 bit => 1 => sign of user's tick (0 => negative; 1 => positive)\n    /// Next 19 bits => 2-20 => absolute value of user's tick\n    /// Next 24 bits => 21-44 => user's tick's id\n    /// Below we are storing user's collateral & not debt, because the position can also be only collateral with no tick but it can never be only debt\n    /// Next 64 bits => 45-108 => user's supply amount. Debt will be calculated through supply & ratio.\n    /// Next 64 bits => 109-172 => user's dust debt amount. User's net debt = total debt - dust amount. Total debt is calculated through supply & ratio\n    /// User won't pay any extra interest on dust debt & hence we will not show it as a debt on UI. For user's there's no dust.\n    mapping(uint256 => uint256) internal positionData;\n\n    /// Tick has debt only keeps data of non liquidated positions. liquidated tick's data stays in branch itself\n    /// tick parent => uint (represents bool for 256 children)\n    /// parent of (i)th tick:-\n    /// if (i>=0) (i / 256);\n    /// else ((i + 1) / 256) - 1\n    /// first bit of the variable is the smallest tick & last bit is the biggest tick of that slot\n    mapping(int256 => uint256) internal tickHasDebt;\n\n    /// mapping tickId => tickData\n    /// Tick related data. Total debt & other things\n    /// First bit => 0 => If 1 then liquidated else not liquidated\n    /// Next 24 bits => 1-24 => Total IDs. ID should start from 1.\n    /// If not liquidated:\n    /// Next 64 bits => 25-88 => raw debt\n    /// If liquidated\n    /// The below 3 things are of last ID. This is to be updated when user creates a new position\n    /// Next 1 bit => 25 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated (100% liquidated)\n    /// Next 30 bits => 26-55 => branch ID where this tick got liquidated\n    /// Next 50 bits => 56-105 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    mapping(int256 => uint256) internal tickData;\n\n    /// tick id => previous tick id liquidation data. ID starts from 1\n    /// One tick ID contains 3 IDs of 80 bits in it, holding liquidation data of previously active but liquidated ticks\n    /// 81 bits data below\n    /// #### First 85 bits ####\n    /// 1st bit => 0 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 1-30 => branch ID where this tick got liquidated\n    /// Next 50 bits => 31-80 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    /// #### Second 85 bits ####\n    /// 85th bit => 85 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 86-115 => branch ID where this tick got liquidated\n    /// Next 50 bits => 116-165 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    /// #### Third 85 bits ####\n    /// 170th bit => 170 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 171-200 => branch ID where this tick got liquidated\n    /// Next 50 bits => 201-250 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    mapping(int256 => mapping(uint256 => uint256)) internal tickId;\n\n    /// mapping branchId => branchData\n    /// First 2 bits => 0-1 => if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\n    /// merged means the branch is merged into it's base branch\n    /// closed means all the users are 100% liquidated\n    /// Next 1 bit => 2 => minima tick sign of this branch. Will only be there if any liquidation happened.\n    /// Next 19 bits => 3-21 => minima tick of this branch. Will only be there if any liquidation happened.\n    /// Next 30 bits => 22-51 => Partials of minima tick of branch this is connected to. 0 if master branch.\n    /// Next 64 bits => 52-115 Debt liquidity at this branch. Similar to last's top tick data. Remaining debt will move here from tickData after first liquidation\n    /// If not merged\n    /// Next 50 bits => 116-165 => Debt factor or of this branch. (35 bits coefficient | 15 bits expansion)\n    /// If merged\n    /// Next 50 bits => 116-165 => Connection/adjustment debt factor of this branch with the next branch.\n    /// If closed\n    /// Next 50 bits => 116-165 => Debt factor as 0. As all the user's positions are now fully gone\n    /// following values are present always again (merged / not merged / closed)\n    /// Next 30 bits => 166-195 => Branch's ID with which this branch is connected. If 0 then that means this is the master branch\n    /// Next 1 bit => 196 => sign of minima tick of branch this is connected to. 0 if master branch.\n    /// Next 19 bits => 197-215 => minima tick of branch this is connected to. 0 if master branch.\n    mapping(uint256 => uint256) internal branchData;\n\n    /// Exchange prices are in 1e12\n    /// First 64 bits => 0-63 => Liquidity's collateral token supply exchange price\n    /// First 64 bits => 64-127 => Liquidity's debt token borrow exchange price\n    /// First 64 bits => 128-191 => Vault's collateral token supply exchange price\n    /// First 64 bits => 192-255 => Vault's debt token borrow exchange price\n    uint256 internal rates;\n\n    /// address of rebalancer\n    address internal rebalancer;\n\n    uint256 internal absorbedDustDebt;\n\n    address internal dexFromAddress;\n}\n"
    },
    "contracts/reserve/interfaces/iReserveContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\n\ninterface IFluidReserveContract {\n    function isRebalancer(address user) external returns (bool);\n\n    function initialize(\n        address[] memory _auths,\n        address[] memory _rebalancers,\n        IFluidLiquidity liquidity_,\n        address owner_\n    ) external;\n\n    function rebalanceFToken(address protocol_) external;\n\n    function rebalanceVault(address protocol_) external;\n\n    function transferFunds(address token_) external;\n\n    function getProtocolTokens(address protocol_) external;\n\n    function updateAuth(address auth_, bool isAuth_) external;\n\n    function updateRebalancer(address rebalancer_, bool isRebalancer_) external;\n\n    function approve(address[] memory protocols_, address[] memory tokens_, uint256[] memory amounts_) external;\n\n    function revoke(address[] memory protocols_, address[] memory tokens_) external;\n}\n"
    },
    "solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
    },
    "solmate/src/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "solmate/src/utils/CREATE3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Bytes32AddressLib} from \"./Bytes32AddressLib.sol\";\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)\nlibrary CREATE3 {\n    using Bytes32AddressLib for bytes32;\n\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //\n    // 0x37       |  0x37                 | CALLDATACOPY     |                        //\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //\n    // 0xf0       |  0xf0                 | CREATE           | newContract            //\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //\n    // 0x52       |  0x52                 | MSTORE           |                        //\n    // 0x60       |  0x6008               | PUSH1 08         | 8                      //\n    // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //\n    // 0xf3       |  0xf3                 | RETURN           |                        //\n    //--------------------------------------------------------------------------------//\n    bytes internal constant PROXY_BYTECODE = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n\n    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);\n\n    function deploy(\n        bytes32 salt,\n        bytes memory creationCode,\n        uint256 value\n    ) internal returns (address deployed) {\n        bytes memory proxyChildBytecode = PROXY_BYTECODE;\n\n        address proxy;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)\n        }\n        require(proxy != address(0), \"DEPLOYMENT_FAILED\");\n\n        deployed = getDeployed(salt);\n        (bool success, ) = proxy.call{value: value}(creationCode);\n        require(success && deployed.code.length != 0, \"INITIALIZATION_FAILED\");\n    }\n\n    function getDeployed(bytes32 salt) internal view returns (address) {\n        address proxy = keccak256(\n            abi.encodePacked(\n                // Prefix:\n                bytes1(0xFF),\n                // Creator:\n                address(this),\n                // Salt:\n                salt,\n                // Bytecode hash:\n                PROXY_BYTECODE_HASH\n            )\n        ).fromLast20Bytes();\n\n        return\n            keccak256(\n                abi.encodePacked(\n                    // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)\n                    // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n                    hex\"d6_94\",\n                    proxy,\n                    hex\"01\" // Nonce of the proxy contract (1)\n                )\n            ).fromLast20Bytes();\n    }\n}\n"
    },
    "solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    },
    "solmate/src/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}