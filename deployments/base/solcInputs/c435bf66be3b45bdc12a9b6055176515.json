{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/libraries/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n\n    /***********************************|\n    |           SafeApprove             | \n    |__________________________________*/\n\n    /// @notice thrown when safe approve from for an ERC20 fails\n    uint256 internal constant SafeApprove__ApproveFailed = 81001;\n}\n"
    },
    "contracts/libraries/safeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\n\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\nlibrary SafeTransfer {\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 20000; // pass max. 20k gas for native transfers\n\n    error FluidSafeTransferError(uint256 errorId_);\n\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from_\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of `token_` to `to_`.\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of ` native token to `to_`.\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\n    function safeTransferNative(address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n}\n"
    },
    "contracts/protocols/lending/merkleDistributor/errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Errors {\n    error Unauthorized();\n    error InvalidParams();\n\n    // claim related errors:\n    error InvalidCycle();\n    error InvalidProof();\n    error NothingToClaim();\n    error MsgSenderNotRecipient();\n}\n"
    },
    "contracts/protocols/lending/merkleDistributor/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Events {\n    /// @notice Emitted when an address is added or removed from the allowed proposers\n    event LogUpdateProposer(address proposer, bool isProposer);\n\n    /// @notice Emitted when an address is added or removed from the allowed approvers\n    event LogUpdateApprover(address approver, bool isApprover);\n\n    /// @notice Emitted when a new cycle root hash is proposed\n    event LogRootProposed(uint256 cycle, bytes32 root, bytes32 contentHash, uint256 timestamp, uint256 blockNumber);\n\n    /// @notice Emitted when a new cycle root hash is approved by the owner and becomes the new active root\n    event LogRootUpdated(uint256 cycle, bytes32 root, bytes32 contentHash, uint256 timestamp, uint256 blockNumber);\n\n    /// @notice Emitted when a `user` claims `amount` via a valid merkle proof\n    event LogClaimed(\n        address user,\n        uint256 amount,\n        uint256 cycle,\n        uint8 positionType,\n        bytes32 positionId,\n        uint256 timestamp,\n        uint256 blockNumber\n    );\n\n    /// @notice Emitted when a new reward cycle is created\n    event LogRewardCycle(\n        uint256 indexed cycle,\n        uint256 indexed epoch,\n        uint256 amount,\n        uint256 startBlock,\n        uint256 endBlock\n    );\n\n    /// @notice Emitted when a new distribution is created\n    event LogDistribution(\n        uint256 indexed epoch,\n        address indexed initiator,\n        uint256 amount,\n        uint256 startCycle,\n        uint256 endCycle,\n        uint256 registrationBlock,\n        uint256 registrationTimestamp\n    );\n\n    /// @notice Emitted when the distribution configuration is updated\n    event LogDistributionConfigUpdated(bool pullFromSender, uint256 blocksPerDistribution, uint256 cyclesPerDistribution);\n\n    /// @notice Emitted when a rewards distributor is toggled\n    event LogRewardsDistributorToggled(address distributor, bool isDistributor);\n}\n"
    },
    "contracts/protocols/lending/merkleDistributor/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\nimport { Events } from \"./events.sol\";\nimport { Errors } from \"./errors.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { Variables } from \"./variables.sol\";\nimport { SafeTransfer } from \"../../../libraries/safeTransfer.sol\";\n\n// ---------------------------------------------------------------------------------------------\n//\n// @dev WARNING: DO NOT USE `multiProof` related methods of `MerkleProof`.\n// This repo uses OpenZeppelin 4.8.2 which has a vulnerability for multi proofs. See:\n// https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wprv-93r4-jj2p\n//\n// ---------------------------------------------------------------------------------------------\n\nabstract contract FluidMerkleDistributorCore is Structs, Variables, Events, Errors {\n    /// @dev validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert InvalidParams();\n        }\n        _;\n    }\n}\n\nabstract contract FluidMerkleDistributorAdmin is FluidMerkleDistributorCore {\n    /// @notice                  Updates an address status as a root proposer\n    /// @param proposer_         The address to update\n    /// @param isProposer_       Whether or not the address should be an allowed proposer\n    function updateProposer(address proposer_, bool isProposer_) public onlyOwner validAddress(proposer_) {\n        _proposers[proposer_] = isProposer_;\n        emit LogUpdateProposer(proposer_, isProposer_);\n    }\n\n    /// @notice                  Updates an address status as a root approver\n    /// @param approver_         The address to update\n    /// @param isApprover_       Whether or not the address should be an allowed approver\n    function updateApprover(address approver_, bool isApprover_) public onlyOwner validAddress(approver_) {\n        _approvers[approver_] = isApprover_;\n        emit LogUpdateApprover(approver_, isApprover_);\n    }\n\n    /// @notice                         Spell allows owner aka governance to do any arbitrary call on factory\n    /// @param target_                  Address to which the call needs to be delegated\n    /// @param data_                    Data to execute at the delegated address\n    function spell(address target_, bytes memory data_) internal returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n\n    /// @dev open payload method for admin to resolve emergency cases\n    function spell(address[] memory targets_, bytes[] memory calldatas_) public onlyOwner {\n        for (uint256 i = 0; i < targets_.length; i++) {\n            spell(targets_[i], calldatas_[i]);\n        }\n    }\n\n    /// @notice Pause contract functionality of new roots and claiming\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Unpause contract functionality of new roots and claiming\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n\nabstract contract FluidMerkleDistributorApprover is FluidMerkleDistributorCore {\n    /// @dev Checks that the sender is an approver\n    modifier onlyApprover() {\n        if (!isApprover(msg.sender)) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @notice checks if the `approver_` is an allowed root approver\n    function isApprover(address approver_) public view returns (bool) {\n        return (_approvers[approver_] || owner == approver_);\n    }\n\n    /// @notice Approve the current pending root and content hash\n    function approveRoot(\n        bytes32 root_,\n        bytes32 contentHash_,\n        uint40 cycle_,\n        uint40 startBlock_,\n        uint40 endBlock_\n    ) external onlyApprover {\n        MerkleCycle memory merkleCycle_ = _pendingMerkleCycle;\n\n        if (\n            root_ != merkleCycle_.merkleRoot ||\n            contentHash_ != merkleCycle_.merkleContentHash ||\n            cycle_ != merkleCycle_.cycle ||\n            startBlock_ != merkleCycle_.startBlock ||\n            endBlock_ != merkleCycle_.endBlock\n        ) {\n            revert InvalidParams();\n        }\n\n        previousMerkleRoot = _currentMerkleCycle.merkleRoot;\n\n        merkleCycle_.timestamp = uint40(block.timestamp);\n        merkleCycle_.publishBlock = uint40(block.number);\n\n        _currentMerkleCycle = merkleCycle_;\n\n        emit LogRootUpdated(cycle_, root_, contentHash_, block.timestamp, block.number);\n    }\n}\n\nabstract contract FluidMerkleDistributorProposer is FluidMerkleDistributorCore {\n    /// @dev Checks that the sender is a proposer\n    modifier onlyProposer() {\n        if (!isProposer(msg.sender)) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @notice checks if the `proposer_` is an allowed root proposer\n    function isProposer(address proposer_) public view returns (bool) {\n        return (_proposers[proposer_] || owner == proposer_);\n    }\n\n    /// @notice Propose a new root and content hash, which will be stored as pending until approved\n    function proposeRoot(\n        bytes32 root_,\n        bytes32 contentHash_,\n        uint40 cycle_,\n        uint40 startBlock_,\n        uint40 endBlock_\n    ) external whenNotPaused onlyProposer {\n        if (cycle_ != _currentMerkleCycle.cycle + 1 || startBlock_ > endBlock_) {\n            revert InvalidParams();\n        }\n\n        _pendingMerkleCycle = MerkleCycle({\n            merkleRoot: root_,\n            merkleContentHash: contentHash_,\n            cycle: cycle_,\n            startBlock: startBlock_,\n            endBlock: endBlock_,\n            timestamp: uint40(block.timestamp),\n            publishBlock: uint40(block.number)\n        });\n\n        emit LogRootProposed(cycle_, root_, contentHash_, block.timestamp, block.number);\n    }\n}\n\nabstract contract FluidMerkleDistributorRewards is FluidMerkleDistributorCore {\n    /// @dev Modifier to check if the sender is a rewards distributor\n    modifier onlyRewardsDistributor() {\n        if (!rewardsDistributor[msg.sender] && owner != msg.sender) revert Unauthorized();\n        _;\n    }\n\n    /// @notice Updates the distribution configuration\n    /// @param pullFromDistributor_ - whether to pull rewards from distributor or not\n    /// @param blocksPerDistribution_ - duration of distribution in blocks\n    /// @param cyclesPerDistribution_ - number of cycles to distribute rewards, if 0 then means paused\n    function updateDistributionConfig(\n        bool pullFromDistributor_,\n        uint40 blocksPerDistribution_,\n        uint40 cyclesPerDistribution_\n    ) external onlyOwner {\n        if (blocksPerDistribution_ == 0 || cyclesPerDistribution_ == 0) revert InvalidParams();\n        emit LogDistributionConfigUpdated(\n            pullFromDistributor = pullFromDistributor_,\n            blocksPerDistribution = blocksPerDistribution_,\n            cyclesPerDistribution = cyclesPerDistribution_\n        );\n    }\n\n    /// @notice Toggles a rewards distributor\n    /// @param distributor_ - address of the rewards distributor\n    function toggleRewardsDistributor(address distributor_) external onlyOwner {\n        if (distributor_ == address(0)) revert InvalidParams();\n        emit LogRewardsDistributorToggled(\n            distributor_,\n            rewardsDistributor[distributor_] = !rewardsDistributor[distributor_]\n        );\n    }\n\n    /////// Public Functions ///////\n\n    /// @notice Returns the cycle rewards\n    /// @return rewards_ - rewards\n    function getCycleRewards() external view returns (Reward[] memory) {\n        return rewards;\n    }\n\n    /// @notice Returns the cycle reward for a given cycle\n    /// @param cycle_ - cycle of the reward\n    /// @return reward_ - reward\n    function getCycleReward(uint256 cycle_) external view returns (Reward memory) {\n        if (cycle_ > rewards.length || cycle_ == 0) revert InvalidParams();\n        return rewards[cycle_ - 1];\n    }\n\n    /// @notice Returns the total number of cycles\n    /// @return totalCycles_ - total number of cycles\n    function totalCycleRewards() external view returns (uint256) {\n        return rewards.length;\n    }\n\n    /// @notice Returns the total number of distributions\n    /// @return totalDistributions_ - total number of distributions\n    function totalDistributions() external view returns (uint256) {\n        return distributions.length;\n    }\n\n    /// @notice Returns the distribution for a given epoch\n    /// @param epoch_ - epoch of the distribution\n    /// @return distribution_ - distribution\n    function getDistributionForEpoch(uint256 epoch_) external view returns (Distribution memory) {\n        if (epoch_ > distributions.length || epoch_ == 0) revert InvalidParams();\n        return distributions[epoch_ - 1];\n    }\n\n    /// @notice Returns all distributions\n    /// @return distributions_ - all distributions\n    function getDistributions() external view returns (Distribution[] memory) {\n        return distributions;\n    }\n\n    ////////// Distribution Function //////////\n\n    /// @notice Distributes rewards for a given token\n    /// @param amount_ - amount of tokens to distribute rewards for\n    function distributeRewards(uint256 amount_) public onlyRewardsDistributor {\n        if (amount_ == 0) revert InvalidParams();\n\n        uint256 amountPerCycle_ = amount_ / cyclesPerDistribution;\n        uint256 blocksPerCycle_ = blocksPerDistribution / cyclesPerDistribution;\n\n        uint256 cyclesLength_ = rewards.length;\n        uint256 lastCycleEndBlock_ = cyclesLength_ > 0 ? rewards[cyclesLength_ - 1].endBlock + 1 : block.number;\n        // check if last cycle was ended before next distribution, then there will be a cap between two cycles\n        uint256 startBlock_ = lastCycleEndBlock_ > block.number ? lastCycleEndBlock_ : block.number;\n\n        uint256 distributionEpoch_ = distributions.length + 1;\n\n        distributions.push(\n            Distribution({\n                amount: amount_,\n                epoch: uint40(distributionEpoch_),\n                startCycle: uint40(cyclesLength_ + 1),\n                endCycle: uint40(cyclesLength_ + cyclesPerDistribution),\n                registrationBlock: uint40(block.number),\n                registrationTimestamp: uint40(block.timestamp)\n            })\n        );\n\n        for (uint256 i = 0; i < cyclesPerDistribution; i++) {\n            uint256 endBlock_ = startBlock_ + blocksPerCycle_ - 1;\n            uint256 cycle_ = cyclesLength_ + 1 + i;\n            uint256 cycleAmount_ = amountPerCycle_;\n            if (i == cyclesPerDistribution - 1) {\n                cycleAmount_ = amount_ - (amountPerCycle_ * i);\n            }\n            rewards.push(\n                Reward({\n                    cycle: uint40(cycle_),\n                    amount: cycleAmount_,\n                    startBlock: uint40(startBlock_),\n                    endBlock: uint40(endBlock_),\n                    epoch: uint40(distributionEpoch_)\n                })\n            );\n            emit LogRewardCycle(cycle_, distributionEpoch_, cycleAmount_, startBlock_, endBlock_);\n            startBlock_ = endBlock_ + 1;\n        }\n\n        if (pullFromDistributor) SafeERC20.safeTransferFrom(TOKEN, msg.sender, address(this), amount_);\n\n        emit LogDistribution(\n            distributionEpoch_,\n            msg.sender,\n            amount_,\n            cyclesLength_ + 1,\n            cyclesLength_ + cyclesPerDistribution,\n            block.number,\n            block.timestamp\n        );\n    }\n\n    /// @notice Distributes rewards for a given token\n    /// @param amount_ - amount of tokens to distribute rewards for\n    /// @param startBlock_ - start block of the distribution\n    function distributeRewards(uint256 amount_, uint256 startBlock_) public onlyRewardsDistributor {\n        if (amount_ == 0) revert InvalidParams();\n\n        uint256 amountPerCycle_ = amount_ / cyclesPerDistribution;\n        uint256 blocksPerCycle_ = blocksPerDistribution / cyclesPerDistribution;\n\n        uint256 cyclesLength_ = rewards.length;\n        // uint256 lastCycleEndBlock_ = cyclesLength_ > 0 ? rewards[cyclesLength_ - 1].endBlock + 1 : block.number;\n        // // check if last cycle was ended before next distribution, then there will be a cap between two cycles\n        // uint256 startBlock_ = lastCycleEndBlock_ > block.number ? lastCycleEndBlock_ : block.number;\n        if (startBlock_ == 0) startBlock_ = block.number;\n        uint256 distributionEpoch_ = distributions.length + 1;\n\n        distributions.push(\n            Distribution({\n                amount: amount_,\n                epoch: uint40(distributionEpoch_),\n                startCycle: uint40(cyclesLength_ + 1),\n                endCycle: uint40(cyclesLength_ + cyclesPerDistribution),\n                registrationBlock: uint40(block.number),\n                registrationTimestamp: uint40(block.timestamp)\n            })\n        );\n\n        for (uint256 i = 0; i < cyclesPerDistribution; i++) {\n            uint256 endBlock_ = startBlock_ + blocksPerCycle_ - 1;\n            uint256 cycle_ = cyclesLength_ + 1 + i;\n            uint256 cycleAmount_ = amountPerCycle_;\n            if (i == cyclesPerDistribution - 1) {\n                cycleAmount_ = amount_ - (amountPerCycle_ * i);\n            }\n            rewards.push(\n                Reward({\n                    cycle: uint40(cycle_),\n                    amount: cycleAmount_,\n                    startBlock: uint40(startBlock_),\n                    endBlock: uint40(endBlock_),\n                    epoch: uint40(distributionEpoch_)\n                })\n            );\n            emit LogRewardCycle(cycle_, distributionEpoch_, cycleAmount_, startBlock_, endBlock_);\n            startBlock_ = endBlock_ + 1;\n        }\n\n        if (pullFromDistributor) SafeERC20.safeTransferFrom(TOKEN, msg.sender, address(this), amount_);\n\n        emit LogDistribution(\n            distributionEpoch_,\n            msg.sender,\n            amount_,\n            cyclesLength_ + 1,\n            cyclesLength_ + cyclesPerDistribution,\n            block.number,\n            block.timestamp\n        );\n    }\n}\n\ncontract FluidMerkleDistributor is\n    FluidMerkleDistributorCore,\n    FluidMerkleDistributorAdmin,\n    FluidMerkleDistributorApprover,\n    FluidMerkleDistributorProposer,\n    FluidMerkleDistributorRewards\n{\n    constructor(\n        string memory name_,\n        address owner_,\n        address proposer_,\n        address approver_,\n        address rewardToken_\n    )\n        validAddress(owner_)\n        validAddress(proposer_)\n        validAddress(approver_)\n        validAddress(rewardToken_)\n        Variables(owner_, rewardToken_)\n    {\n        name = name_;\n\n        _proposers[proposer_] = true;\n        emit LogUpdateProposer(proposer_, true);\n\n        _approvers[approver_] = true;\n        emit LogUpdateApprover(approver_, true);\n\n        // blocksPerDistribution = 28 days;\n        // cyclesPerDistribution = blocksPerDistribution / 7 days;\n\n        blocksPerDistribution = 20 minutes;\n        cyclesPerDistribution = 2;\n\n        if (block.chainid == 1) {\n            blocksPerDistribution = blocksPerDistribution / 12 seconds;\n        } else if (block.chainid == 42161) {\n            blocksPerDistribution = (blocksPerDistribution * 25) / 100; // 0.25 seconds\n        } else if (block.chainid == 8453) {\n            blocksPerDistribution = blocksPerDistribution / 2 seconds;\n        } else {\n            revert(\"Unsupported chain\");\n        }\n    }\n\n    /// @notice checks if there is a proposed root waiting to be approved\n    function hasPendingRoot() external view returns (bool) {\n        return _pendingMerkleCycle.cycle == _currentMerkleCycle.cycle + 1;\n    }\n\n    /// @notice merkle root data related to current cycle (proposed and approved).\n    function currentMerkleCycle() public view returns (MerkleCycle memory) {\n        return _currentMerkleCycle;\n    }\n\n    /// @notice merkle root data related to pending cycle (proposed but not yet approved).\n    function pendingMerkleCycle() public view returns (MerkleCycle memory) {\n        return _pendingMerkleCycle;\n    }\n\n    function encodeClaim(\n        address recipient_,\n        uint256 cumulativeAmount_,\n        uint8 positionType_,\n        bytes32 positionId_,\n        uint256 cycle_,\n        bytes memory metadata_\n    ) public pure returns (bytes memory encoded_, bytes32 hash_) {\n        encoded_ = abi.encode(positionType_, positionId_, recipient_, cycle_, cumulativeAmount_, metadata_);\n        hash_ = keccak256(bytes.concat(keccak256(encoded_)));\n    }\n\n    /// @notice Claims rewards for a given recipient\n    /// @param recipient_ - address of the recipient\n    /// @param cumulativeAmount_ - cumulative amount of rewards to claim\n    /// @param positionType_ - type of position, 1 for lending, 2 for vaults, 3 for smart lending, etc\n    /// @param positionId_ - id of the position, fToken address for lending and vaultId for vaults\n    /// @param cycle_ - cycle of the rewards\n    /// @param merkleProof_ - merkle proof of the rewards\n    function claim(\n        address recipient_,\n        uint256 cumulativeAmount_,\n        uint8 positionType_,\n        bytes32 positionId_,\n        uint256 cycle_,\n        bytes32[] calldata merkleProof_,\n        bytes memory metadata_\n    ) public whenNotPaused {\n        if (msg.sender != recipient_) revert MsgSenderNotRecipient();\n        uint256 currentCycle_ = uint256(_currentMerkleCycle.cycle);\n\n        if (!(cycle_ == currentCycle_ || (currentCycle_ > 0 && cycle_ == currentCycle_ - 1))) {\n            revert InvalidCycle();\n        }\n\n        // Verify the merkle proof.\n        bytes32 node_ = keccak256(\n            bytes.concat(\n                keccak256(abi.encode(positionType_, positionId_, recipient_, cycle_, cumulativeAmount_, metadata_))\n            )\n        );\n        if (\n            !MerkleProof.verify(\n                merkleProof_,\n                cycle_ == currentCycle_ ? _currentMerkleCycle.merkleRoot : previousMerkleRoot,\n                node_\n            )\n        ) {\n            revert InvalidProof();\n        }\n\n        uint256 claimable_ = cumulativeAmount_ - claimed[recipient_][positionId_];\n        if (claimable_ == 0) {\n            revert NothingToClaim();\n        }\n\n        claimed[recipient_][positionId_] = cumulativeAmount_;\n\n        SafeERC20.safeTransfer(TOKEN, recipient_, claimable_);\n\n        emit LogClaimed(recipient_, claimable_, cycle_, positionType_, positionId_, block.timestamp, block.number);\n    }\n\n    struct Claim {\n        address recipient;\n        uint256 cumulativeAmount;\n        uint8 positionType;\n        bytes32 positionId;\n        uint256 cycle;\n        bytes32[] merkleProof;\n        bytes metadata;\n    }\n\n    function bulkClaim(Claim[] calldata claims_) external {\n        for (uint i = 0; i < claims_.length; i++) {\n            claim(\n                claims_[i].recipient,\n                claims_[i].cumulativeAmount,\n                claims_[i].positionType,\n                claims_[i].positionId,\n                claims_[i].cycle,\n                claims_[i].merkleProof,\n                claims_[i].metadata\n            );\n        }\n    }\n}\n"
    },
    "contracts/protocols/lending/merkleDistributor/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct MerkleCycle {\n        // slot 1\n        bytes32 merkleRoot;\n        // slot 2\n        bytes32 merkleContentHash;\n        // slot 3\n        uint40 cycle;\n        uint40 timestamp;\n        uint40 publishBlock;\n        uint40 startBlock;\n        uint40 endBlock;\n    }\n\n    struct Reward {\n        // slot 1\n        uint256 amount;\n        // slot 2\n        uint40 cycle;\n        uint40 startBlock;\n        uint40 endBlock;\n        uint40 epoch;\n    }\n\n    struct Distribution {\n        // slot 1\n        uint256 amount;\n        // slot 2\n        uint40 epoch;\n        uint40 startCycle;\n        uint40 endCycle;\n        uint40 registrationBlock;\n        uint40 registrationTimestamp;\n    }\n}\n"
    },
    "contracts/protocols/lending/merkleDistributor/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Owned } from \"solmate/src/auth/Owned.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport { Structs } from \"./structs.sol\";\n\nabstract contract Constants {\n    IERC20 public immutable TOKEN;\n\n    constructor(address rewardToken_) {\n        TOKEN = IERC20(rewardToken_);\n    }\n}\n\nabstract contract Variables is Owned, Pausable, Constants, Structs {\n    // ------------ storage variables from inherited contracts (Owned, Pausable) come before vars here --------\n\n    // ----------------------- slot 0 ---------------------------\n    // address public owner; -> from Owned\n\n    // bool private _paused; -> from Pausable\n\n    // 11 bytes empty\n\n    // ----------------------- slot 1 ---------------------------\n\n    /// @dev Name of the Merkle Distributor\n    string public name;\n\n    // ----------------------- slot 2 ---------------------------\n\n    /// @dev allow list for allowed root proposer addresses\n    mapping(address => bool) internal _proposers;\n\n    // ----------------------- slot 3 ---------------------------\n\n    /// @dev allow list for allowed root proposer addresses\n    mapping(address => bool) internal _approvers;\n\n    // ----------------------- slot 4-6 ---------------------------\n\n    /// @dev merkle root data related to current cycle (proposed and approved).\n    /// @dev timestamp & publishBlock = data from last publish.\n    // with custom getter to return whole struct at once instead of default solidity getter splitting it into tuple\n    MerkleCycle internal _currentMerkleCycle;\n\n    // ----------------------- slot 7-9 ---------------------------\n\n    /// @dev merkle root data related to pending cycle (proposed but not yet approved).\n    /// @dev timestamp & publishBlock = data from last propose.\n    // with custom getter to return whole struct at once instead of default solidity getter splitting it into tuple\n    MerkleCycle internal _pendingMerkleCycle;\n\n    // ----------------------- slot 10 ---------------------------\n\n    /// @notice merkle root of the previous cycle\n    bytes32 public previousMerkleRoot;\n\n    // ----------------------- slot 11 ---------------------------\n\n    /// @notice total claimed amount per user address and fToken. user => positionId => claimed amount\n    mapping(address => mapping(bytes32 => uint256)) public claimed;\n\n    // ----------------------- slot 12 ---------------------------\n\n    /// @notice Data of cycle rewards\n    Reward[] internal rewards;\n\n    // ----------------------- slot 13 ---------------------------\n\n    /// @notice data of distributions\n    Distribution[] internal distributions;\n\n    // ----------------------- slot 14 ---------------------------\n\n    /// @notice allow list for rewards distributors\n    mapping(address => bool) public rewardsDistributor;\n\n    // ----------------------- slot 15 ---------------------------\n\n    /// @notice Number of cycles to distribute rewards\n    uint40 public cyclesPerDistribution;\n\n    /// @notice Duration of each distribution in blocks\n    uint40 public blocksPerDistribution;\n\n    /// @notice Whether to pull tokens from distributor or not\n    bool public pullFromDistributor;\n\n    constructor(address owner_, address rewardToken_) Constants(rewardToken_) Owned(owner_) {}\n}\n"
    },
    "solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}