{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/libraries/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n\n    /***********************************|\n    |           SafeApprove             | \n    |__________________________________*/\n\n    /// @notice thrown when safe approve from for an ERC20 fails\n    uint256 internal constant SafeApprove__ApproveFailed = 81001;\n}\n"
    },
    "contracts/libraries/safeApprove.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\n\n/// @notice provides minimalistic methods for safe approve, e.g. ERC20 safeApprove\nlibrary SafeApprove {\n    error FluidSafeApproveError(uint256 errorId_);\n\n    /// @dev Approve `amount_` of `token_` to `to_`.\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L97-L127\n    function safeApprove(\n        address token_,\n        address to_,\n        uint256 amount_\n    ) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            success_ := call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\n\n            // Set success to whether the call reverted, if not we check it either\n            // returned exactly 1 (can't just be non-zero data), or had no return data and token has code.\n            if and(iszero(and(eq(mload(0), 1), gt(returndatasize(), 31))), success_) {\n                success_ := iszero(or(iszero(extcodesize(token_)), returndatasize())) \n            }\n        }\n\n        if (!success_) {\n            revert FluidSafeApproveError(ErrorTypes.SafeApprove__ApproveFailed);\n        }\n    }\n}\n"
    },
    "contracts/libraries/safeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\n\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\nlibrary SafeTransfer {\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 20000; // pass max. 20k gas for native transfers\n\n    error FluidSafeTransferError(uint256 errorId_);\n\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from_\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of `token_` to `to_`.\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of ` native token to `to_`.\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\n    function safeTransferNative(address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n}\n"
    },
    "contracts/oracle/contractRates/rseth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IRsETHLRTOracle } from \"../../interfaces/external/IRsETHLRTOracle.sol\";\nimport { IFluidOracle } from \"../../interfaces/iFluidOracle.sol\";\nimport { FluidCenterPrice } from \"../../fluidCenterPrice.sol\";\n\nimport { Error as OracleError } from \"../../error.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\n\nabstract contract Events {\n    /// @notice emitted when rebalancer successfully changes the contract rate\n    event LogRebalanceRate(uint256 oldRate, uint256 newRate);\n}\n\nabstract contract Constants {\n    /// @dev RSETH LRT oracle contract; 0x349A73444b1a310BAe67ef67973022020d70020d\n    IRsETHLRTOracle internal immutable _RSETH_LRT_ORACLE;\n\n    /// @dev Minimum difference to trigger update in percent 1e4 decimals, 10000 = 1%\n    uint256 internal immutable _MIN_UPDATE_DIFF_PERCENT;\n\n    /// @dev Minimum time after which an update can trigger, even if it does not reach `_MIN_UPDATE_DIFF_PERCENT`\n    uint256 internal immutable _MIN_HEART_BEAT;\n}\n\nabstract contract Variables is Constants {\n    /// @dev amount of ETH for 1 rsETH, in 1e27 decimals\n    uint216 internal _rate;\n\n    /// @dev time when last update for rate happened\n    uint40 internal _lastUpdateTime;\n}\n\n/// @notice This contract stores the rate of ETH for 1 rstETH in intervals to optimize gas cost.\n/// @notice Properly implements all interfaces for use as IFluidCenterPrice and IFluidOracle.\ncontract RsETHContractRate is IRsETHLRTOracle, IFluidOracle, FluidCenterPrice, Variables, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidOracleError(ErrorTypes.ContractRate__InvalidParams);\n        }\n        _;\n    }\n\n    constructor(\n        string memory infoName_,\n        IRsETHLRTOracle rstETHLRTOracle_,\n        uint256 minUpdateDiffPercent_,\n        uint256 minHeartBeat_\n    ) validAddress(address(rstETHLRTOracle_)) FluidCenterPrice(infoName_) {\n        if (minUpdateDiffPercent_ == 0 || minUpdateDiffPercent_ > 1e5 || minHeartBeat_ == 0) {\n            // revert if > 10% or 0\n            revert FluidOracleError(ErrorTypes.ContractRate__InvalidParams);\n        }\n        _RSETH_LRT_ORACLE = rstETHLRTOracle_;\n        _MIN_UPDATE_DIFF_PERCENT = minUpdateDiffPercent_;\n        _MIN_HEART_BEAT = minHeartBeat_;\n        _rate = uint216(_RSETH_LRT_ORACLE.rsETHPrice() * 1e9);\n        _lastUpdateTime = uint40(block.timestamp);\n    }\n\n    /// @inheritdoc FluidCenterPrice\n    function infoName() public view override(IFluidOracle, FluidCenterPrice) returns (string memory) {\n        return super.infoName();\n    }\n\n    /// @notice Rebalance the contract rate by updating the stored rate with the current rate from the RSETH oracle contract.\n    /// @dev The rate is only updated if the difference between the current rate and the new rate is greater than or\n    ///      equal to the minimum update difference percentage.\n    function rebalance() external {\n        uint256 curRate_ = _rate;\n        uint256 newRate_ = _RSETH_LRT_ORACLE.rsETHPrice() * 1e9; // scale to 1e27\n\n        uint256 rateDiffPercent;\n        unchecked {\n            if (curRate_ > newRate_) {\n                rateDiffPercent = ((curRate_ - newRate_) * 1e6) / curRate_;\n            } else if (newRate_ > curRate_) {\n                rateDiffPercent = ((newRate_ - curRate_) * 1e6) / curRate_;\n            }\n        }\n        if (rateDiffPercent < _MIN_UPDATE_DIFF_PERCENT) {\n            revert FluidOracleError(ErrorTypes.ContractRate__MinUpdateDiffNotReached);\n        }\n\n        _rate = uint216(newRate_);\n        _lastUpdateTime = uint40(block.timestamp);\n\n        emit LogRebalanceRate(curRate_, newRate_);\n    }\n\n    /// @inheritdoc IRsETHLRTOracle\n    function rsETHPrice() external view override returns (uint256) {\n        return _rate / 1e9; // scale to 1e18\n    }\n\n    /// @inheritdoc FluidCenterPrice\n    function centerPrice() external override returns (uint256 price_) {\n        // heart beat check update for Dex swaps\n        if (_lastUpdateTime + _MIN_HEART_BEAT < block.timestamp) {\n            uint256 curRate_ = _rate;\n            uint256 newRate_ = _RSETH_LRT_ORACLE.rsETHPrice() * 1e9; // scale to 1e27\n\n            _rate = uint216(newRate_);\n            _lastUpdateTime = uint40(block.timestamp);\n\n            emit LogRebalanceRate(curRate_, newRate_);\n        }\n\n        return _rate;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_) {\n        return _rate;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() external view virtual returns (uint256 exchangeRate_) {\n        return _rate;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() external view virtual returns (uint256 exchangeRate_) {\n        return _rate;\n    }\n\n    /// @notice returns how much the new rate would be different from current rate in percent (10000 = 1%, 1 = 0.0001%).\n    function configPercentDiff() public view virtual returns (uint256 configPercentDiff_) {\n        uint256 curRate_ = _rate;\n        uint256 newRate_ = _RSETH_LRT_ORACLE.rsETHPrice() * 1e9; // scale to 1e27\n\n        unchecked {\n            if (curRate_ > newRate_) {\n                configPercentDiff_ = ((curRate_ - newRate_) * 1e6) / curRate_;\n            } else if (newRate_ > curRate_) {\n                configPercentDiff_ = ((newRate_ - curRate_) * 1e6) / curRate_;\n            }\n        }\n    }\n\n    /// @notice returns all config vars, last update timestamp, and rsETH LRT oracle address\n    function configData()\n        external\n        view\n        returns (uint256 minUpdateDiffPercent_, uint256 minHeartBeat_, uint40 lastUpdateTime_, address rsETHLRTOracle_)\n    {\n        return (_MIN_UPDATE_DIFF_PERCENT, _MIN_HEART_BEAT, _lastUpdateTime, address(_RSETH_LRT_ORACLE));\n    }\n}\n"
    },
    "contracts/oracle/contractRates/weeths/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IWeETHsAccountant } from \"../../interfaces/external/IWeETHsAccountant.sol\";\nimport { IFluidOracle } from \"../../interfaces/iFluidOracle.sol\";\nimport { FluidCenterPrice } from \"../../fluidCenterPrice.sol\";\n\nimport { Error as OracleError } from \"../../error.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\n\nabstract contract Events {\n    /// @notice emitted when rebalancer successfully changes the contract rate\n    event LogRebalanceRate(uint256 oldRate, uint256 newRate);\n}\n\nabstract contract Constants {\n    /// @dev WEETHS accountant contract; 0xbe16605B22a7faCEf247363312121670DFe5afBE\n    IWeETHsAccountant internal immutable _WEETHS_ACCOUNTANT;\n\n    /// @dev Minimum difference to trigger update in percent 1e4 decimals, 10000 = 1%\n    uint256 internal immutable _MIN_UPDATE_DIFF_PERCENT;\n\n    /// @dev Minimum time after which an update can trigger, even if it does not reach `_MIN_UPDATE_DIFF_PERCENT`\n    uint256 internal immutable _MIN_HEART_BEAT;\n}\n\nabstract contract Variables is Constants {\n    /// @dev amount of eETH for 1 weETHs, in 1e27 decimals\n    uint216 internal _rate;\n\n    /// @dev time when last update for rate happened\n    uint40 internal _lastUpdateTime;\n}\n\n/// @notice This contract stores the rate of ETH for 1 weETHs in intervals to optimize gas cost.\n/// @notice Properly implements all interfaces for use as IFluidCenterPrice and IFluidOracle.\ncontract WeETHsContractRate is IWeETHsAccountant, IFluidOracle, FluidCenterPrice, Variables, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidOracleError(ErrorTypes.ContractRate__InvalidParams);\n        }\n        _;\n    }\n\n    constructor(\n        string memory infoName_,\n        IWeETHsAccountant weETHsAccountant_,\n        uint256 minUpdateDiffPercent_,\n        uint256 minHeartBeat_\n    ) validAddress(address(weETHsAccountant_)) FluidCenterPrice(infoName_) {\n        if (minUpdateDiffPercent_ == 0 || minUpdateDiffPercent_ > 1e5 || minHeartBeat_ == 0) {\n            // revert if > 10% or 0\n            revert FluidOracleError(ErrorTypes.ContractRate__InvalidParams);\n        }\n        _WEETHS_ACCOUNTANT = weETHsAccountant_;\n        _MIN_UPDATE_DIFF_PERCENT = minUpdateDiffPercent_;\n        _MIN_HEART_BEAT = minHeartBeat_;\n        _rate = uint216(_WEETHS_ACCOUNTANT.getRate() * 1e9);\n        _lastUpdateTime = uint40(block.timestamp);\n    }\n\n    /// @inheritdoc FluidCenterPrice\n    function infoName() public view override(IFluidOracle, FluidCenterPrice) returns (string memory) {\n        return super.infoName();\n    }\n\n    /// @inheritdoc IWeETHsAccountant\n    function vault() external view override returns (address) {\n        return _WEETHS_ACCOUNTANT.vault();\n    }\n\n    /// @inheritdoc IWeETHsAccountant\n    function getRate() external view override returns (uint256) {\n        return _rate / 1e9; // scale to 1e18\n    }\n\n    /// @inheritdoc IWeETHsAccountant\n    function getRateSafe() external view override returns (uint256) {\n        _WEETHS_ACCOUNTANT.getRateSafe(); // will revert if paused\n        // return actual rate of this contract to keep equivalency with getRate() and other methods.\n        return _rate / 1e9; // scale to 1e18\n    }\n\n    /// @notice Rebalance the contract rate by updating the stored rate with the current rate from the WEETHs contract.\n    /// @dev The rate is only updated if the difference between the current rate and the new rate is greater than or\n    ///      equal to the minimum update difference percentage.\n    function rebalance() external {\n        uint256 curRate_ = _rate;\n        uint256 newRate_ = _WEETHS_ACCOUNTANT.getRateSafe() * 1e9; // scale to 1e27\n\n        uint256 rateDiffPercent;\n        unchecked {\n            if (curRate_ > newRate_) {\n                rateDiffPercent = ((curRate_ - newRate_) * 1e6) / curRate_;\n            } else if (newRate_ > curRate_) {\n                rateDiffPercent = ((newRate_ - curRate_) * 1e6) / curRate_;\n            }\n        }\n        if (rateDiffPercent < _MIN_UPDATE_DIFF_PERCENT) {\n            revert FluidOracleError(ErrorTypes.ContractRate__MinUpdateDiffNotReached);\n        }\n\n        _rate = uint216(newRate_);\n        _lastUpdateTime = uint40(block.timestamp);\n\n        emit LogRebalanceRate(curRate_, newRate_);\n    }\n\n    /// @inheritdoc FluidCenterPrice\n    function centerPrice() external override returns (uint256 price_) {\n        // heart beat check update for Dex swaps\n        if (_lastUpdateTime + _MIN_HEART_BEAT < block.timestamp) {\n            uint256 curRate_ = _rate;\n            uint256 newRate_ = _WEETHS_ACCOUNTANT.getRate() * 1e9; // scale to 1e27\n\n            _rate = uint216(newRate_);\n            _lastUpdateTime = uint40(block.timestamp);\n\n            emit LogRebalanceRate(curRate_, newRate_);\n        }\n\n        return _rate;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_) {\n        return _rate;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() external view virtual returns (uint256 exchangeRate_) {\n        return _rate;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() external view virtual returns (uint256 exchangeRate_) {\n        return _rate;\n    }\n\n    /// @notice returns how much the new rate would be different from current rate in percent (10000 = 1%, 1 = 0.0001%).\n    function configPercentDiff() public view virtual returns (uint256 configPercentDiff_) {\n        uint256 curRate_ = _rate;\n        uint256 newRate_ = _WEETHS_ACCOUNTANT.getRateSafe() * 1e9; // scale to 1e27\n\n        unchecked {\n            if (curRate_ > newRate_) {\n                configPercentDiff_ = ((curRate_ - newRate_) * 1e6) / curRate_;\n            } else if (newRate_ > curRate_) {\n                configPercentDiff_ = ((newRate_ - curRate_) * 1e6) / curRate_;\n            }\n        }\n    }\n\n    /// @notice returns all config vars, last update timestamp, and weETHs accountant address\n    function configData()\n        external\n        view\n        returns (\n            uint256 minUpdateDiffPercent_,\n            uint256 minHeartBeat_,\n            uint40 lastUpdateTime_,\n            address weETHsAccountant_\n        )\n    {\n        return (_MIN_UPDATE_DIFF_PERCENT, _MIN_HEART_BEAT, _lastUpdateTime, address(_WEETHS_ACCOUNTANT));\n    }\n}\n"
    },
    "contracts/oracle/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Error {\n    error FluidOracleError(uint256 errorId_);\n}\n"
    },
    "contracts/oracle/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |           FluidOracleL2           | \n    |__________________________________*/\n\n    /// @notice thrown when sequencer on a L2 has an outage and grace period has not yet passed.\n    uint256 internal constant FluidOracleL2__SequencerOutage = 60000;\n\n    /***********************************|\n    |     UniV3CheckCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the delta between main price source and check rate source is exceeding the allowed delta\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidPrice = 60001;\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidParams = 60002;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant UniV3CheckCLRSOracle__ExchangeRateZero = 60003;\n\n    /***********************************|\n    |           FluidOracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid info name is passed into a fluid oracle (e.g. not set or too long)\n    uint256 internal constant FluidOracle__InvalidInfoName = 60010;\n\n    /***********************************|\n    |            sUSDe Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDeOracle__InvalidParams = 60102;\n\n    /***********************************|\n    |           Pendle Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PendleOracle__InvalidParams = 60201;\n\n    /// @notice thrown when the Pendle market Oracle has not been initialized yet\n    uint256 internal constant PendleOracle__MarketNotInitialized = 60202;\n\n    /// @notice thrown when the Pendle market does not have 18 decimals\n    uint256 internal constant PendleOracle__MarketInvalidDecimals = 60203;\n\n    /// @notice thrown when the Pendle market returns an unexpected price\n    uint256 internal constant PendleOracle__InvalidPrice = 60204;\n\n    /***********************************|\n    |    CLRS2UniV3CheckCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant CLRS2UniV3CheckCLRSOracleL2__ExchangeRateZero = 60301;\n\n    /***********************************|\n    |    Ratio2xFallbackCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant Ratio2xFallbackCLRSOracleL2__ExchangeRateZero = 60311;\n\n    /***********************************|\n    |            WeETHsOracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHsOracle__InvalidParams = 60321;\n\n    /***********************************|\n    |        DexSmartColOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexSmartColOracle__InvalidParams = 60331;\n\n    /// @notice thrown when smart col is not enabled\n    uint256 internal constant DexSmartColOracle__SmartColNotEnabled = 60332;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexSmartColOracle__ExchangeRateZero = 60333;\n\n    /***********************************|\n    |        DexSmartDebtOracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexSmartDebtOracle__InvalidParams = 60341;\n\n    /// @notice thrown when smart debt is not enabled\n    uint256 internal constant DexSmartDebtOracle__SmartDebtNotEnabled = 60342;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexSmartDebtOracle__ExchangeRateZero = 60343;\n\n    /***********************************|\n    |            ContractRate           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant ContractRate__InvalidParams = 60351;\n\n    /// @notice thrown when caller is not authorized\n    uint256 internal constant ContractRate__Unauthorized = 60352;\n\n    /// @notice thrown when minimum diff for triggering update on the stared rate is not reached\n    uint256 internal constant ContractRate__MinUpdateDiffNotReached = 60353;\n\n    /***********************************|\n    |            sUSDs Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDsOracle__InvalidParams = 60361;\n\n    /***********************************|\n    |            Peg Oracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PegOracle__InvalidParams = 60371;\n\n    /***********************************|\n    |              DexOracle            | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexOracle__InvalidParams = 60381;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexOracle__ExchangeRateZero = 60382;\n\n    /***********************************|\n    |          Chainlink Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant ChainlinkOracle__InvalidParams = 61001;\n\n    /***********************************|\n    |          UniswapV3 Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3Oracle__InvalidParams = 62001;\n\n    /// @notice thrown when constructor is called with invalid ordered seconds agos values\n    uint256 internal constant UniV3Oracle__InvalidSecondsAgos = 62002;\n\n    /// @notice thrown when constructor is called with invalid delta values > 100%\n    uint256 internal constant UniV3Oracle__InvalidDeltas = 62003;\n\n    /***********************************|\n    |            WstETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WstETHOracle__InvalidParams = 63001;\n\n    /***********************************|\n    |           Redstone Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant RedstoneOracle__InvalidParams = 64001;\n\n    /***********************************|\n    |          Fallback Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant FallbackOracle__InvalidParams = 65001;\n\n    /***********************************|\n    |       FallbackCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant FallbackCLRSOracle__ExchangeRateZero = 66001;\n\n    /***********************************|\n    |         WstETHCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant WstETHCLRSOracle__ExchangeRateZero = 67001;\n\n    /***********************************|\n    |        CLFallbackUniV3Oracle      | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant CLFallbackUniV3Oracle__ExchangeRateZero = 68001;\n\n    /***********************************|\n    |  WstETHCLRS2UniV3CheckCLRSOracle  | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant WstETHCLRS2UniV3CheckCLRSOracle__ExchangeRateZero = 69001;\n\n    /***********************************|\n    |             WeETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHOracle__InvalidParams = 70001;\n}\n"
    },
    "contracts/oracle/fluidCenterPrice.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidCenterPrice } from \"./interfaces/iFluidCenterPrice.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { Error as OracleError } from \"./error.sol\";\n\n/// @title   FluidCenterPrice\n/// @notice  Base contract that any Fluid Center Price must implement\nabstract contract FluidCenterPrice is IFluidCenterPrice, OracleError {\n    /// @dev short helper string to easily identify the center price oracle. E.g. token symbols\n    //\n    // using a bytes32 because string can not be immutable.\n    bytes32 private immutable _infoName;\n\n    constructor(string memory infoName_) {\n        if (bytes(infoName_).length > 32 || bytes(infoName_).length == 0) {\n            revert FluidOracleError(ErrorTypes.FluidOracle__InvalidInfoName);\n        }\n\n        // convert string to bytes32\n        bytes32 infoNameBytes32_;\n        assembly {\n            infoNameBytes32_ := mload(add(infoName_, 32))\n        }\n        _infoName = infoNameBytes32_;\n    }\n\n    /// @inheritdoc IFluidCenterPrice\n    function infoName() public view virtual returns (string memory) {\n        // convert bytes32 to string\n        uint256 length_;\n        while (length_ < 32 && _infoName[length_] != 0) {\n            length_++;\n        }\n        bytes memory infoNameBytes_ = new bytes(length_);\n        for (uint256 i; i < length_; i++) {\n            infoNameBytes_[i] = _infoName[i];\n        }\n        return string(infoNameBytes_);\n    }\n\n    /// @inheritdoc IFluidCenterPrice\n    function centerPrice() external virtual returns (uint256 price_);\n}\n"
    },
    "contracts/oracle/fluidOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"./interfaces/iFluidOracle.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { Error as OracleError } from \"./error.sol\";\n\n/// @title   FluidOracle\n/// @notice  Base contract that any Fluid Oracle must implement\nabstract contract FluidOracle is IFluidOracle, OracleError {\n    /// @dev short helper string to easily identify the oracle. E.g. token symbols\n    //\n    // using a bytes32 because string can not be immutable.\n    bytes32 private immutable _infoName;\n\n    constructor(string memory infoName_) {\n        if (bytes(infoName_).length > 32 || bytes(infoName_).length == 0) {\n            revert FluidOracleError(ErrorTypes.FluidOracle__InvalidInfoName);\n        }\n\n        // convert string to bytes32\n        bytes32 infoNameBytes32_;\n        assembly {\n            infoNameBytes32_ := mload(add(infoName_, 32))\n        }\n        _infoName = infoNameBytes32_;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function infoName() external view returns (string memory) {\n        // convert bytes32 to string\n        uint256 length_;\n        while (length_ < 32 && _infoName[length_] != 0) {\n            length_++;\n        }\n        bytes memory infoNameBytes_ = new bytes(length_);\n        for (uint256 i; i < length_; i++) {\n            infoNameBytes_[i] = _infoName[i];\n        }\n        return string(infoNameBytes_);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() external view virtual returns (uint256 exchangeRate_);\n}\n"
    },
    "contracts/oracle/interfaces/external/IRsETHLRTOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IRsETHLRTOracle {\n    /// @notice ETH per 1 rsETH exchange rate\n    function rsETHPrice() external view returns (uint256 rate);\n}\n"
    },
    "contracts/oracle/interfaces/external/IWeETHsAccountant.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IWeETHsAccountant {\n    /**\n     * @notice Get this BoringVault's current rate in the base.\n     */\n    function getRate() external view returns (uint256 rate);\n\n    /**\n     * @notice Get this BoringVault's current rate in the base.\n     * @dev Revert if paused.\n     */\n    function getRateSafe() external view returns (uint256 rate);\n\n    /**\n     * @notice The BoringVault this accountant is working with.\n     *         Used to determine share supply for fee calculation.\n     */\n    function vault() external view returns (address vault);\n}\n"
    },
    "contracts/oracle/interfaces/iFluidCenterPrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidCenterPrice {\n    /// @notice Retrieves the center price for the pool\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\n    /// @return price_ The current price ratio of token1 to token0, expressed with 27 decimal places\n    function centerPrice() external returns (uint256 price_);\n\n    /// @notice helper string to easily identify the oracle. E.g. token symbols\n    function infoName() external view returns (string memory);\n}\n"
    },
    "contracts/oracle/interfaces/iFluidOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidOracle {\n    /// @dev Deprecated. Use `getExchangeRateOperate()` and `getExchangeRateLiquidate()` instead. Only implemented for\n    ///      backwards compatibility.\n    function getExchangeRate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for operates\n    function getExchangeRateOperate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for liquidations\n    function getExchangeRateLiquidate() external view returns (uint256 exchangeRate_);\n\n    /// @notice helper string to easily identify the oracle. E.g. token symbols\n    function infoName() external view returns (string memory);\n}\n"
    },
    "contracts/oracle/libraries/oracleUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title Oracle utils library\n/// @notice implements common utility methods for Fluid Oracles\nlibrary OracleUtils {\n    /// @dev The scaler for max delta point math (100%)\n    uint256 internal constant HUNDRED_PERCENT_DELTA_SCALER = 10_000;\n    /// @dev output precision of rates\n    uint256 internal constant RATE_OUTPUT_DECIMALS = 27;\n\n    /// @dev checks if `mainSourceRate_` is within a `maxDeltaPercent_` of `checkSourceRate_`. Returns true if so.\n    function isRateOutsideDelta(\n        uint256 mainSourceRate_,\n        uint256 checkSourceRate_,\n        uint256 maxDeltaPercent_\n    ) internal pure returns (bool) {\n        uint256 offset_ = (checkSourceRate_ * maxDeltaPercent_) / HUNDRED_PERCENT_DELTA_SCALER;\n        return (mainSourceRate_ > (checkSourceRate_ + offset_) || mainSourceRate_ < (checkSourceRate_ - offset_));\n    }\n}\n"
    },
    "contracts/oracle/oracles/pegFluidOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"../interfaces/iFluidOracle.sol\";\nimport { FluidOracle } from \"../fluidOracle.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { OracleUtils } from \"../libraries/oracleUtils.sol\";\n\n/// @title Peg oracle for pegged assets with an existing Fluid Oracle (e.g. Fluid ContractRate)\n/// @notice  This contract is used to get the exchange rate between pegged assets like WEETH / WSTETH or RSETH / WSTETH.\n///          Price is adjusted for token decimals and optionally a Fluid oracle source feed can be set (e.g. Fluid ContractRate).\n///          e.g. for RSETH / WSTETH: RSETH contract rate / WSTETH contract rate\ncontract PegFluidOracle is FluidOracle {\n    IFluidOracle internal immutable _COL_FLUID_ORACLE;\n    IFluidOracle internal immutable _DEBT_FLUID_ORACLE;\n\n    constructor(\n        string memory infoName_,\n        IFluidOracle colFluidOracle_,\n        IFluidOracle debtFluidOracle_\n    ) FluidOracle(infoName_) {\n        if (address(colFluidOracle_) == address(0) || address(debtFluidOracle_) == address(0)) {\n            revert FluidOracleError(ErrorTypes.PegOracle__InvalidParams);\n        }\n\n        _COL_FLUID_ORACLE = colFluidOracle_;\n        _DEBT_FLUID_ORACLE = debtFluidOracle_;\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateOperate() public view override returns (uint256 exchangeRate_) {\n        // e.g. weEth -> wstETH\n        exchangeRate_ =\n            (_COL_FLUID_ORACLE.getExchangeRateOperate() * (10 ** OracleUtils.RATE_OUTPUT_DECIMALS)) /\n            _DEBT_FLUID_ORACLE.getExchangeRateOperate();\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRateLiquidate() external view override returns (uint256 exchangeRate_) {\n        // e.g. weEth -> wstETH\n        exchangeRate_ =\n            (_COL_FLUID_ORACLE.getExchangeRateLiquidate() * (10 ** OracleUtils.RATE_OUTPUT_DECIMALS)) /\n            _DEBT_FLUID_ORACLE.getExchangeRateLiquidate();\n    }\n\n    /// @inheritdoc FluidOracle\n    function getExchangeRate() external view override returns (uint256 exchangeRate_) {\n        return getExchangeRateOperate();\n    }\n\n    /// @notice returns the configured col and debt fluid oracles\n    function pegFluidOracleData() public view returns (IFluidOracle colFluidOracle_, IFluidOracle debtFluidOracle_) {\n        return (_COL_FLUID_ORACLE, _DEBT_FLUID_ORACLE);\n    }\n}\n"
    },
    "contracts/periphery/liquidation/implementations/implementationsV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidVaultT1 } from \"../../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { IFluidVaultT2 } from \"../../../protocols/vault/interfaces/iVaultT2.sol\";\nimport { IFluidVaultT3 } from \"../../../protocols/vault/interfaces/iVaultT3.sol\";\nimport { IFluidVaultT4 } from \"../../../protocols/vault/interfaces/iVaultT4.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { IWETH9 } from \"../../../protocols/lending/interfaces/external/iWETH9.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { SafeTransfer } from \"../../../libraries/safeTransfer.sol\";\nimport { SafeApprove } from \"../../../libraries/safeApprove.sol\";\n\ninterface InstaFlashInterface {\n    function flashLoan(address[] memory tokens, uint256[] memory amts, uint route, bytes memory data, bytes memory extraData) external;\n}\n\ninterface InstaFlashReceiverInterface {\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata _data\n    ) external returns (bool);\n}\n\ncontract VaultLiquidatorImplementationV1 {\n    uint256 internal constant X19 = 0x7ffff;\n    uint256 internal constant X20 = 0xfffff;\n    address constant public ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    InstaFlashInterface immutable public FLA;\n    IWETH9 immutable public WETH;\n    address internal immutable ADDRESS_THIS = address(this);\n\n\n    error FluidVaultLiquidator__InvalidOperation();\n    error FluidVaultLiquidator__InvalidTimestamp();\n    error FluidVaultLiquidator__InvalidTopTick();\n\n    event Liquidated(\n        address indexed vault,\n        uint256 collateral,\n        uint256 debt\n    );\n\n    struct LiquidationParams {\n        address vault; // address of the vault to liquidate\n        uint256 vaultType; // 1 for T1, 2 for T2, 3 for T3, 4 for T4\n        uint256 expiration; // 0 if no expiration\n        int256 topTick; // type(int256).min if no topTick\n\n        uint256 route; // Flashloan Route\n        address flashloanToken; // Debt Token\n        uint256 flashloanAmount; // Amount of debt token to payback\n\n        uint256 token0DebtAmt;\n        uint256 token1DebtAmt;\n        uint256 debtSharesMin;\n        uint256 colPerUnitDebt; // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares; // in 1e18\n        uint256 token1ColAmtPerUnitShares; // in 1e18\n        bool absorb;\n\n        address swapToken; // Collateral Token\n        uint256 swapAmount; // Collateral amount to swap\n        address swapRouter; // Dex Aggregator Router Contract\n        address swapApproval; // Dex Aggregator Approval Contract\n        bytes swapData; // Data to swap collateral token\n    }\n\n    struct LiquidationDustParams {\n        address vault; // address of the vault to liquidate\n        uint256 vaultType; // 1 for T1, 2 for T2, 3 for T3, 4 for T4\n        uint256 expiration; // 0 if no expiration\n        int256 topTick; // type(int256).min if no topTick\n\n        address debtToken; // Debt Token\n        uint256 debtAmount; // Amount of debt token to payback\n\n        uint256 token0DebtAmt;\n        uint256 token1DebtAmt;\n        uint256 debtSharesMin;\n        uint256 colPerUnitDebt; // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares; // in 1e18\n        uint256 token1ColAmtPerUnitShares; // in 1e18\n        bool absorb;\n    }\n\n    constructor (\n        address fla_,\n        address weth_\n    ) {\n        FLA = InstaFlashInterface(fla_);\n        WETH = IWETH9(weth_);\n    }\n\n    modifier _onlyDelegateCall() {\n        if (address(this) == ADDRESS_THIS) {\n            revert FluidVaultLiquidator__InvalidOperation();\n        }\n        _;\n    }\n\n    function _tickHelper(uint tickRaw_) internal pure returns (int tick) {\n        require(tickRaw_ < X20, \"invalid-number\");\n        if (tickRaw_ > 0) {\n            tick = tickRaw_ & 1 == 1 ? int((tickRaw_ >> 1) & X19) : -int((tickRaw_ >> 1) & X19);\n        } else {\n            tick = type(int).min;\n        }\n    }\n\n    function _validateParams(LiquidationParams memory params_) internal view {\n        if (params_.expiration > 0 && params_.expiration < block.timestamp) revert FluidVaultLiquidator__InvalidTimestamp();\n\n        uint256 vaultVariables_ = IFluidVaultT1(params_.vault).readFromStorage(0);\n\n        int256 topTick_ = _tickHelper(((vaultVariables_ >> 2) & X20));\n\n        if (params_.topTick > topTick_ && params_.topTick != type(int256).min) revert FluidVaultLiquidator__InvalidTopTick();\n    }\n\n    function liquidateDust(LiquidationDustParams memory params_) public _onlyDelegateCall {\n        LiquidationParams memory param_;\n        param_.expiration = params_.expiration;\n        param_.topTick = params_.topTick;\n        param_.vault = params_.vault;\n        param_.vaultType = params_.vaultType;\n\n        _validateParams(param_);\n\n        uint256 value_;\n        if (params_.debtToken != ETH_ADDRESS) {\n            SafeApprove.safeApprove(params_.debtToken, params_.vault, 0);\n            SafeApprove.safeApprove(params_.debtToken, params_.vault, params_.debtAmount);\n            value_ = 0;\n        } else {\n            value_ = params_.debtAmount;\n        }\n\n        uint256 debtAmount_;\n        uint256 collateralAmount_;\n        if (params_.vaultType == 1) {\n            (debtAmount_, collateralAmount_) = IFluidVaultT1(params_.vault).liquidate{value: value_}(params_.token0DebtAmt, params_.colPerUnitDebt, address(this), params_.absorb);\n        } else if (params_.vaultType == 2) {\n            (debtAmount_, collateralAmount_, , ) = IFluidVaultT2(params_.vault).liquidate{value: value_}(params_.token0DebtAmt, params_.colPerUnitDebt, params_.token0ColAmtPerUnitShares, params_.token1ColAmtPerUnitShares, address(this), params_.absorb);\n        } else if (params_.vaultType == 3) {\n            (debtAmount_, collateralAmount_) = IFluidVaultT3(params_.vault).liquidate{value: value_}(params_.token0DebtAmt, params_.token1DebtAmt, params_.debtSharesMin, params_.colPerUnitDebt, address(this), params_.absorb);\n        } else if (params_.vaultType == 4) {\n            (debtAmount_, collateralAmount_, , ) = IFluidVaultT4(params_.vault).liquidate{value: value_}(params_.token0DebtAmt, params_.token1DebtAmt, params_.debtSharesMin, params_.colPerUnitDebt, params_.token0ColAmtPerUnitShares, params_.token1ColAmtPerUnitShares, address(this), params_.absorb);\n        }\n    }\n\n    function liquidation(LiquidationParams memory params_) public _onlyDelegateCall {\n        _validateParams(params_);\n\n        address[] memory tokens = new address[](1);\n        uint256[] memory amts = new uint256[](1);\n\n        // Take flashloan in borrow token of the vault\n        tokens[0] = params_.flashloanToken == ETH_ADDRESS ? address(WETH) : params_.flashloanToken;\n        amts[0] = params_.flashloanAmount;\n\n        bytes memory data_ = abi.encode(params_);\n\n        FLA.flashLoan(tokens, amts, params_.route, data_, abi.encode());\n\n    }\n\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata _data\n    ) external returns (bool) {\n        if (msg.sender != address(FLA)) revert FluidVaultLiquidator__InvalidOperation();\n        if (initiator != address(this)) revert FluidVaultLiquidator__InvalidOperation();\n        LiquidationParams memory params_ = abi.decode(_data, (LiquidationParams));\n\n        {\n            uint256 value_;\n            if (params_.flashloanToken != ETH_ADDRESS) {\n                SafeApprove.safeApprove(params_.flashloanToken, params_.vault, 0);\n                SafeApprove.safeApprove(params_.flashloanToken, params_.vault, params_.flashloanAmount);\n                value_ = 0;\n            } else {\n                WETH.withdraw(params_.flashloanAmount);\n                value_ = params_.flashloanAmount;\n            }\n\n            uint256 debtAmount_;\n            uint256 collateralAmount_;\n            if (params_.vaultType == 1) {\n                (debtAmount_, collateralAmount_) = IFluidVaultT1(params_.vault).liquidate{value: value_}(params_.token0DebtAmt, params_.colPerUnitDebt, address(this), params_.absorb);\n            } else if (params_.vaultType == 2) {\n                (debtAmount_, collateralAmount_, , ) = IFluidVaultT2(params_.vault).liquidate{value: value_}(params_.token0DebtAmt, params_.colPerUnitDebt, params_.token0ColAmtPerUnitShares, params_.token1ColAmtPerUnitShares, address(this), params_.absorb);\n            } else if (params_.vaultType == 3) {\n                (debtAmount_, collateralAmount_) = IFluidVaultT3(params_.vault).liquidate{value: value_}(params_.token0DebtAmt, params_.token1DebtAmt, params_.debtSharesMin, params_.colPerUnitDebt, address(this), params_.absorb);\n            } else if (params_.vaultType == 4) {\n                (debtAmount_, collateralAmount_, , ) = IFluidVaultT4(params_.vault).liquidate{value: value_}(params_.token0DebtAmt, params_.token1DebtAmt, params_.debtSharesMin, params_.colPerUnitDebt, params_.token0ColAmtPerUnitShares, params_.token1ColAmtPerUnitShares, address(this), params_.absorb);\n            }\n\n            if (params_.flashloanToken != params_.swapToken) {\n                if (params_.swapToken != ETH_ADDRESS) {\n                    SafeApprove.safeApprove(params_.swapToken, params_.swapApproval, 0);\n                    SafeApprove.safeApprove(params_.swapToken, params_.swapApproval, params_.swapAmount);\n                    value_ = 0;\n                } else {\n                    value_ = params_.swapAmount;\n                }\n\n                Address.functionCallWithValue(params_.swapRouter, params_.swapData, value_, \"Swap: failed\");\n            }\n\n            emit Liquidated(params_.vault, collateralAmount_, debtAmount_);\n        }\n\n        uint256 flashloanAmount_ = amounts[0] + premiums[0] + 10;\n\n        if (params_.flashloanToken == ETH_ADDRESS) {\n            uint256 wethBalance_ = WETH.balanceOf(address(this));\n            if (wethBalance_ < flashloanAmount_) {\n                WETH.deposit{value: flashloanAmount_ - wethBalance_}();\n            }\n        }\n\n        SafeTransfer.safeTransfer(assets[0], msg.sender, flashloanAmount_);\n\n        return true;\n    }\n\n    receive() payable external {}\n}"
    },
    "contracts/periphery/wallet/wallet/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC721 } from \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\nimport { SafeTransfer } from \"../../../libraries/safeTransfer.sol\";\n\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { IFluidVaultFactory } from \"../../../protocols/vault/interfaces/iVaultFactory.sol\";\nimport { IFluidVaultT1 } from \"../../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { IFluidVault } from \"../../../protocols/vault/interfaces/iVault.sol\";\n\n\ninterface IFluidWalletFactory {\n    function WALLET_PROXY() external view returns(address);\n}\n\ninterface InstaFlashReceiverInterface {\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata _data\n    ) external returns (bool);\n}\n\nabstract contract FluidWalletVariables {\n    /***********************************|\n    |   Constants/Immutables            |\n    |__________________________________*/\n    string public constant VERSION = \"1.1.1\";\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 internal constant X32 = 0xffffffff;\n\n    address public immutable VAULT_FACTORY;\n    address public immutable FLUID_WALLET_FACTORY;\n\n    /***********************************|\n    |           Slot 0                  |\n    |__________________________________*/\n    /// @dev owner address of this wallet. It is initialized while deploying the wallet for the user.\n    address public owner;\n\n    /***********************************|\n    |           Slot 1                  |\n    |__________________________________*/\n    /// @dev transient allow hash used to signal allowing certain entry into methods such as executeOperation etc.\n    bytes32 internal _transientAllowHash;\n    \n    function _resetTransientStorage() internal {\n        assembly {\n            sstore(1, 1) // Store 1 in the transient storage 1\n        }\n    }\n}\n\ncontract FluidWalletErrorsAndEvents {\n    error FluidWallet__NotAllowed();\n    error FluidWallet__ToHexDigit();\n    error FluidWallet__Unauthorized();\n\n    event Executed(\n        address indexed owner,\n        uint256 indexed tokenId\n    );\n\n    event ExecutedCast(address indexed owner);\n\n    struct Action {\n        address target;\n        bytes data;\n        uint256 value;\n        uint8 operation;\n    }\n}\n\ncontract FluidWalletImplementation is FluidWalletVariables, FluidWalletErrorsAndEvents {\n    \n    constructor(\n        address vaultFactory_,\n        address fluidWalletFactory_\n    ) {\n        VAULT_FACTORY = vaultFactory_;\n        FLUID_WALLET_FACTORY = fluidWalletFactory_;\n    }\n\n    /// @dev                    ERC721 callback used Fluid Vault Factory and executes actions encoded in `data_`\n    ///                         Caller should be Fluid Wallet Factory.\n    /// @param operator_        operator_ caller to transfer the the given token ID\n    /// @param from_            from_ previous owner of the given token ID\n    /// @param tokenId_         tokenId_ id of the ERC721\n    /// @param data_            data bytes containing the `abi.encoded()` actions that are executed like in `Action[]` & `owner`\n    function onERC721Received(\n        address operator_,\n        address from_,\n        uint256 tokenId_,\n        bytes calldata data_\n    ) external returns (bytes4) {\n        if (msg.sender != address(VAULT_FACTORY)) revert FluidWallet__NotAllowed();\n        if (operator_ != from_) revert FluidWallet__NotAllowed();\n        if (operator_ != FLUID_WALLET_FACTORY) revert FluidWallet__NotAllowed();\n\n        (address owner_, Action[] memory actions_) = abi.decode(data_, (address, Action[]));\n\n        /// @dev validate owner by computing wallet address.\n        _validateOwner(owner_);\n\n        /// @dev execute actions.\n        _executeActions(actions_);\n\n        /// @dev reset _transientAllowHash to prevent reentrancy\n        _resetTransientStorage();\n\n        // Transfer tokenId back to main owner\n        if (IERC721(VAULT_FACTORY).ownerOf(tokenId_) == address(this)) {\n            IERC721(VAULT_FACTORY).transferFrom(address(this), owner_, tokenId_);\n        }\n\n        // sweep vault specific tokens to owner address\n        _sweepTokens(owner_, tokenId_);\n\n        emit Executed(owner_, tokenId_);\n\n        return this.onERC721Received.selector;\n    }\n\n    function cast(\n        Action[] memory actions_\n    ) public payable {\n        /// @dev validate owner by computing wallet address.\n        _validateOwner(msg.sender);\n\n        /// @dev execute actions.\n        _executeActions(actions_);\n\n        /// @dev reset _transientAllowHash to prevent reentrancy\n        _resetTransientStorage();\n\n        emit ExecutedCast(msg.sender);\n    }\n    \n\n    /***********************************|\n    |         FLASHLOAN CALLBACK        |\n    |__________________________________*/\n\n    /// @dev                    callback used by Instadapp Flashloan Aggregator, executes operations while owning\n    ///                         the flashloaned amounts. `data_` must contain actions, one of them must pay back flashloan\n    // /// @param assets_       assets_ received a flashloan for\n    // /// @param amounts_      flashloaned amounts for each asset\n    // /// @param premiums_     fees to pay for the flashloan\n    /// @param initiator_       flashloan initiator -> must be this contract\n    /// @param data_            data bytes containing the `abi.encoded()` actions that are executed like in `CastParams.actions`\n\n    function executeOperation(\n        address[] calldata /* assets */,\n        uint256[] calldata /* amounts */,\n        uint256[] calldata /* premiums */,\n        address initiator_,\n        bytes calldata data_\n    ) external returns (bool) {\n        if (\n            !(_transientAllowHash ==\n                bytes32(keccak256(abi.encode(data_, block.timestamp))) &&\n                initiator_ == address(this))\n        ) {\n            revert FluidWallet__Unauthorized();\n        }\n\n        _executeActions(abi.decode(data_, (Action[])));\n\n        return true;\n    }\n\n    /***********************************|\n    |         INTERNAL HELPERS          |\n    |__________________________________*/\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping\n    function _calculateStorageSlotUintMapping(uint256 slot_, uint key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    struct VaultConstants {\n        address supplyToken0;\n        address supplyToken1;\n        address borrowToken0;\n        address borrowToken1;\n    }\n\n    function _sweepTokens(address owner_, uint256 tokenId_) internal {\n        uint256 tokenConfig_ = IFluidVaultFactory(VAULT_FACTORY).readFromStorage(_calculateStorageSlotUintMapping(3, tokenId_));\n        address vaultAddress_ = IFluidVaultFactory(VAULT_FACTORY).getVaultAddress((tokenConfig_ >> 192) & X32);\n\n        VaultConstants memory constants_ = _getVaultConstants(vaultAddress_);\n\n        _flushTokens(constants_.supplyToken0, owner_);\n        _flushTokens(constants_.supplyToken1, owner_);\n        _flushTokens(constants_.borrowToken0, owner_);\n        _flushTokens(constants_.borrowToken1, owner_);\n    }\n\n    function _getVaultConstants(address vault_) internal view returns (VaultConstants memory constants_) {\n        if (vault_.code.length == 0) {\n            return constants_;\n        }\n        try IFluidVault(vault_).TYPE() returns (uint256 type_) {\n            IFluidVault.ConstantViews memory vaultConstants_ = IFluidVault(vault_).constantsView();\n\n            constants_.supplyToken0 = vaultConstants_.supplyToken.token0;\n            constants_.supplyToken1 = vaultConstants_.supplyToken.token1;\n            constants_.borrowToken0 = vaultConstants_.borrowToken.token0;\n            constants_.borrowToken1 = vaultConstants_.borrowToken.token1;\n        } catch {\n            IFluidVaultT1.ConstantViews memory vaultConstants_ = IFluidVaultT1(vault_).constantsView();\n            \n            constants_.supplyToken0 = vaultConstants_.supplyToken;\n            constants_.supplyToken1 = address(0);\n            constants_.borrowToken0 = vaultConstants_.borrowToken;\n            constants_.borrowToken1 = address(0);\n        }\n    }\n\n    function _flushTokens(address token_, address owner_) internal {\n        if (token_ == address(0)) return;\n\n        if (token_ == ETH_ADDRESS) {\n            uint256 balance_ = address(this).balance;\n            \n            if (balance_ > 0) SafeTransfer.safeTransferNative(payable(owner_), balance_);\n        } else {\n            uint256 balance_ = IERC20(token_).balanceOf(address(this));\n\n            if (balance_ > 0) SafeTransfer.safeTransfer(token_, owner_, balance_);\n        }\n    }\n\n    /// @dev validate `owner` by recomputing fluid address.\n    function _validateOwner(address owner_) internal view {\n        address wallet_ = Clones.predictDeterministicAddress(\n            IFluidWalletFactory(FLUID_WALLET_FACTORY).WALLET_PROXY(),\n            keccak256(abi.encode(owner_)),\n            FLUID_WALLET_FACTORY\n        );\n        if (wallet_ != address(this)) revert FluidWallet__NotAllowed();\n    }\n\n    /// @dev executes `actions_` with respective target, calldata, operation etc.\n    function _executeActions(Action[] memory actions_) internal {\n       uint256 actionsLength_ = actions_.length;\n        for (uint256 i; i < actionsLength_; ) {\n            Action memory action_ = actions_[i];\n\n            // execute action\n            bool success_;\n            bytes memory result_;\n            if (action_.operation == 0) {\n                // call (operation = 0)\n\n                // low-level call will return success true also if action target is not even a contract.\n                // we do not explicitly check for this, default interaction is via UI which can check and handle this.\n                // Also applies to delegatecall etc.\n                (success_, result_) = action_.target.call{ value: action_.value }(action_.data);\n\n                // handle action failure right after external call to better detect out of gas errors\n                if (!success_) {\n                    _handleActionFailure(i, result_);\n                }\n            } else if (action_.operation == 1) {\n                // delegatecall (operation = 1)\n\n                (success_, result_) = action_.target.delegatecall(action_.data);\n\n                // reset _transientAllowHash to make sure it can not be set up in any way for reentrancy\n                _resetTransientStorage();\n\n                // handle action failure right after external call to better detect out of gas errors\n                if (!success_) {\n                    _handleActionFailure(i, result_);\n                }\n            } else if (action_.operation == 2) {\n                // flashloan (operation = 2)\n                // flashloan is always executed via .call, flashloan aggregator uses `msg.sender`, so .delegatecall\n                // wouldn't send funds to this contract but rather to the original sender.\n\n                bytes memory data_ = action_.data;\n                assembly {\n                    data_ := add(data_, 4) // Skip function selector (4 bytes)\n                }\n                // get actions data from calldata action_.data. Only supports InstaFlashAggregatorInterface\n                (, , , data_, ) = abi.decode(data_, (address[], uint256[], uint256, bytes, bytes));\n\n                // set allowHash to signal allowed entry into executeOperation()\n                _transientAllowHash = bytes32(\n                    keccak256(abi.encode(data_, block.timestamp))\n                );\n\n                // handle action failure right after external call to better detect out of gas errors\n                (success_, result_) = action_.target.call{ value: action_.value }(action_.data);\n\n                if (!success_) {\n                    _handleActionFailure(i, result_);\n                }\n\n                // reset _transientAllowHash to prevent reentrancy during actions execution\n                _resetTransientStorage();\n            } else {\n                // either operation does not exist or the id was not set according to what the action wants to execute\n                revert(string.concat(Strings.toString(i), \"_FLUID__INVALID_ID_OR_OPERATION\"));\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev handles failure of an action execution depending on error cause,\n    /// decoding and reverting with `result_` as reason string.\n    function _handleActionFailure(uint256 i_, bytes memory result_) internal pure {\n        revert(string.concat(Strings.toString(i_), _getRevertReasonFromReturnedData(result_)));\n    }\n\n    uint256 internal constant REVERT_REASON_MAX_LENGTH = 250;\n\n    /// @dev Get the revert reason from the returnedData (supports Panic, Error & Custom Errors).\n    /// Based on https://github.com/superfluid-finance/protocol-monorepo/blob/dev/packages/ethereum-contracts/contracts/libs/CallUtils.sol\n    /// This is needed in order to provide some human-readable revert message from a call.\n    /// @param returnedData_ revert data of the call\n    /// @return reason_      revert reason\n    function _getRevertReasonFromReturnedData(\n        bytes memory returnedData_\n    ) internal pure returns (string memory reason_) {\n        if (returnedData_.length < 4) {\n            // case 1: catch all\n            return \"_REASON_NOT_DEFINED\";\n        }\n\n        bytes4 errorSelector_;\n        assembly {\n            errorSelector_ := mload(add(returnedData_, 0x20))\n        }\n        if (errorSelector_ == bytes4(0x4e487b71)) {\n            // case 2: Panic(uint256), selector 0x4e487b71 (Defined since 0.8.0)\n            // ref: https://docs.soliditylang.org/en/v0.8.0/control-structures.html#panic-via-assert-and-error-via-require)\n\n            // convert last byte to hex digits -> string to decode the panic code\n            bytes memory result_ = new bytes(2);\n            result_[0] = _toHexDigit(uint8(returnedData_[returnedData_.length - 1]) / 16);\n            result_[1] = _toHexDigit(uint8(returnedData_[returnedData_.length - 1]) % 16);\n            reason_ = string.concat(\"_TARGET_PANICKED: 0x\", string(result_));\n        } else if (errorSelector_ == bytes4(0x08c379a0)) {\n            // case 3: Error(string), selector 0x08c379a0 (Defined at least since 0.7.0)\n            // based on https://ethereum.stackexchange.com/a/83577\n            assembly {\n                returnedData_ := add(returnedData_, 0x04)\n            }\n            reason_ = string.concat(\"_\", abi.decode(returnedData_, (string)));\n        } else {\n            // case 4: Custom errors (Defined since 0.8.0)\n\n            // convert bytes4 selector to string, params are ignored...\n            // based on https://ethereum.stackexchange.com/a/111876\n            bytes memory result_ = new bytes(8);\n            for (uint256 i; i < 4; ) {\n                // use unchecked as i is < 4 and division. also errorSelector can not underflow\n                unchecked {\n                    result_[2 * i] = _toHexDigit(uint8(errorSelector_[i]) / 16);\n                    result_[2 * i + 1] = _toHexDigit(uint8(errorSelector_[i]) % 16);\n                    ++i;\n                }\n            }\n            reason_ = string.concat(\"_CUSTOM_ERROR: 0x\", string(result_));\n        }\n\n        {\n            // truncate reason_ string to REVERT_REASON_MAX_LENGTH for reserveGas used to ensure Cast event is emitted\n            if (bytes(reason_).length > REVERT_REASON_MAX_LENGTH) {\n                bytes memory reasonBytes_ = bytes(reason_);\n                uint256 maxLength_ = REVERT_REASON_MAX_LENGTH + 1; // cheaper than <= in each loop\n                bytes memory truncatedRevertReason_ = new bytes(maxLength_);\n                for (uint256 i; i < maxLength_; ) {\n                    truncatedRevertReason_[i] = reasonBytes_[i];\n\n                    unchecked {\n                        ++i;\n                    }\n                }\n                reason_ = string(truncatedRevertReason_);\n            }\n        }\n    }\n\n    /// @dev used to convert bytes4 selector to string\n    function _toHexDigit(uint8 d) internal pure returns (bytes1) {\n        // use unchecked as the operations with d can not over / underflow\n        unchecked {\n            if (d < 10) {\n                return bytes1(uint8(bytes1(\"0\")) + d);\n            }\n            if (d < 16) {\n                return bytes1(uint8(bytes1(\"a\")) + d - 10);\n            }\n        }\n        revert FluidWallet__ToHexDigit();\n    }\n}"
    },
    "contracts/protocols/lending/interfaces/external/iWETH9.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWETH9 is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVault.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\ninterface IFluidVault {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice returns the vault id\n    function TYPE() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Tokens {\n        address token0;\n        address token1;\n    }\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address operateImplementation;\n        address adminImplementation;\n        address secondaryImplementation;\n        address deployer; // address which deploys oracle\n        address supply; // either liquidity layer or DEX protocol\n        address borrow; // either liquidity layer or DEX protocol\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\n        uint256 vaultId;\n        uint256 vaultType;\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n\n    function rebalance(\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_\n    ) external payable returns (int supplyAmt_, int borrowAmt_);\n\n    /// @notice reverts with FluidLiquidateResult\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\ninterface IFluidVaultFactory is IERC721Enumerable {\n    /// @notice Minting an NFT Vault for the user\n    function mint(uint256 vaultId_, address user_) external returns (uint256 tokenId_);\n\n    /// @notice returns owner of Vault which is also an NFT\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /// @notice Global auth is auth for all vaults\n    function isGlobalAuth(address auth_) external view returns (bool);\n\n    /// @notice Vault auth is auth for a specific vault\n    function isVaultAuth(address vault_, address auth_) external view returns (bool);\n\n    /// @notice Total vaults deployed.\n    function totalVaults() external view returns (uint256);\n\n    /// @notice Compute vaultAddress\n    function getVaultAddress(uint256 vaultId) external view returns (address);\n\n    /// @notice read uint256 `result_` for a storage `slot_` key\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT1.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidVaultT1 {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address adminImplementation;\n        address secondaryImplementation;\n        address supplyToken;\n        address borrowToken;\n        uint8 supplyDecimals;\n        uint8 borrowDecimals;\n        uint vaultId;\n        bytes32 liquiditySupplyExchangePriceSlot;\n        bytes32 liquidityBorrowExchangePriceSlot;\n        bytes32 liquidityUserSupplySlot;\n        bytes32 liquidityUserBorrowSlot;\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    function operate(\n        uint256 nftId_, // if 0 then new position\n        int256 newCol_, // if negative then withdraw\n        int256 newDebt_, // if negative then payback\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint actualDebtAmt_, uint actualColAmt_);\n\n    function absorb() external;\n\n    function rebalance() external payable returns (int supplyAmt_, int borrowAmt_);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT2.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFluidVault } from \"./iVault.sol\";\n\ninterface IFluidVaultT2 is IFluidVault {\n    function operate(\n        uint nftId_,\n        int newColToken0_,\n        int newColToken1_,\n        int colSharesMinMax_,\n        int newDebt_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function operatePerfect(\n        uint nftId_,\n        int perfectColShares_,\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int newDebt_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256[] memory r_\n        );\n\n    function liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint256 actualDebt_, uint256 actualColShares_, uint256 token0Col_, uint256 token1Col_);\n\n    function liquidatePerfect(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint256 actualDebt_, uint256 actualColShares_, uint256 token0Col_, uint256 token1Col_);\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT3.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFluidVault } from \"./iVault.sol\";\n\ninterface IFluidVaultT3 is IFluidVault {\n    function operate(\n        uint nftId_,\n        int newCol_,\n        int newDebtToken0_,\n        int newDebtToken1_,\n        int debtSharesMinMax_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function operatePerfect(\n        uint nftId_,\n        int newCol_,\n        int perfectDebtShares_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256[] memory r_\n        );\n\n    function liquidate(\n        uint256 token0DebtAmt_,\n        uint256 token1DebtAmt_,\n        uint256 debtSharesMin_,\n        uint256 colPerUnitDebt_,\n        address to_,\n        bool absorb_\n    ) external payable returns (uint256 actualDebtShares_, uint256 actualCol_);\n\n    function liquidatePerfect(\n        uint256 debtShares_,\n        uint256 token0DebtAmtPerUnitShares_,\n        uint256 token1DebtAmtPerUnitShares_,\n        uint256 colPerUnitDebt_,\n        address to_,\n        bool absorb_\n    )\n        external\n        payable\n        returns (uint256 actualDebtShares_, uint256 token0Debt_, uint256 token1Debt_, uint256 actualCol_);\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT4.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFluidVault } from \"./iVault.sol\";\n\ninterface IFluidVaultT4 is IFluidVault {\n    function operate(\n        uint nftId_,\n        int newColToken0_,\n        int newColToken1_,\n        int colSharesMinMax_,\n        int newDebtToken0_,\n        int newDebtToken1_,\n        int debtSharesMinMax_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function operatePerfect(\n        uint nftId_,\n        int perfectColShares_,\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int perfectDebtShares_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256[] memory r_\n        );\n\n    function liquidate(\n        uint256 token0DebtAmt_,\n        uint256 token1DebtAmt_,\n        uint256 debtSharesMin_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    )\n        external\n        payable\n        returns (uint256 actualDebtShares_, uint256 actualColShares_, uint256 token0Col_, uint256 token1Col_);\n\n    function liquidatePerfect(\n        uint256 debtShares_,\n        uint256 token0DebtAmtPerUnitShares_,\n        uint256 token1DebtAmtPerUnitShares_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    )\n        external\n        payable\n        returns (\n            uint256 actualDebtShares_,\n            uint256 token0Debt_,\n            uint256 token1Debt_,\n            uint256 actualColShares_,\n            uint256 token0Col_,\n            uint256 token1Col_\n        );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}