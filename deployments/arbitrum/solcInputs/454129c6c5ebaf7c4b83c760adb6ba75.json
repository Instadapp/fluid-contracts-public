{
  "language": "Solidity",
  "sources": {
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/bigMathMinified.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\nlibrary BigMathMinified {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/bytesSliceAndConcat.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary BytesSliceAndConcat {\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesConcat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    ) internal pure returns (bytes memory tempBytes) {\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesSlice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory tempBytes) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/libraries/dexCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\nimport { DexSlotsLink } from \"./dexSlotsLink.sol\";\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// @DEV ATTENTION: ON ANY CHANGES HERE, MAKE SURE THAT LOGIC IN VAULTS WILL STILL BE VALID.\n// SOME CODE THERE ASSUMES DEXCALCS == LIQUIDITYCALCS.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n/// @notice implements calculation methods used for Fluid Dex such as updated withdrawal / borrow limits.\nlibrary DexCalcs {\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) &\n            X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ = block.timestamp - ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ = block.timestamp - ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n}\n"
    },
    "contracts/libraries/dexSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\nlibrary DexSlotsLink {\n    /// @dev storage slot for variables at Dex\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\n    /// @dev storage slot for variables2 at Dex\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\n    /// @dev storage slot for total supply shares at Dex\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\n    /// @dev storage slot for user supply mapping at Dex\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\n    /// @dev storage slot for total borrow shares at Dex\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\n    /// @dev storage slot for user borrow mapping at Dex\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\n    /// @dev storage slot for oracle mapping at Dex\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\n    /// @dev storage slot for range and threshold shifts at Dex\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\n    /// @dev storage slot for center price shift at Dex\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/liquidity/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    /// @notice struct to set borrow rate data for version 1\n    struct RateDataV1Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\n        uint256 kink;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink;\n        ///\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set borrow rate data for version 2\n    struct RateDataV2Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\n        uint256 kink1;\n        ///\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\n        uint256 kink2;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink1;\n        ///\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\n        uint256 rateAtUtilizationKink2;\n        ///\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set token config\n    struct TokenConfig {\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\n        uint256 fee;\n        ///\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\n        uint256 threshold;\n        ///\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\n        uint256 maxUtilization;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dex/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { DexSlotsLink } from \"../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\nimport { BytesSliceAndConcat } from \"../../../libraries/bytesSliceAndConcat.sol\";\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { Structs as FluidLiquidityResolverStructs } from \"../liquidity/structs.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { Variables } from \"./variables.sol\";\n\n/// @title DexFactoryViews\n/// @notice Abstract contract providing view functions for DEX factory-related operations\nabstract contract DexFactoryViews is Variables {\n    /// @notice Get the address of a DEX given its ID\n    /// @param dexId_ The ID of the DEX\n    /// @return dex_ The address of the DEX\n    function getDexAddress(uint256 dexId_) public view returns (address dex_) {\n        return AddressCalcs.addressCalc(address(FACTORY), dexId_);\n    }\n\n    /// @notice Get the ID of a DEX given its address\n    /// @param dex_ The address of the DEX\n    /// @return id_ The ID of the DEX\n    function getDexId(address dex_) public view returns (uint id_) {\n        id_ = IFluidDexT1(dex_).DEX_ID();\n    }\n\n    /// @notice Get the total number of DEXes\n    /// @return The total number of DEXes\n    function getTotalDexes() public view returns (uint) {\n        return FACTORY.totalDexes();\n    }\n\n    /// @notice Get an array of all DEX addresses\n    /// @return dexes_ An array containing all DEX addresses\n    function getAllDexAddresses() public view returns (address[] memory dexes_) {\n        uint totalDexes_ = getTotalDexes();\n        dexes_ = new address[](totalDexes_);\n        for (uint i = 0; i < totalDexes_; i++) {\n            dexes_[i] = getDexAddress((i + 1));\n        }\n    }\n}\n\n/// @title DexStorageVars\n/// @notice Abstract contract providing view functions for DEX storage variables\nabstract contract DexStorageVars is Variables {\n    /// @notice Get the raw DEX variables\n    /// @param dex_ The address of the DEX\n    /// @return The raw DEX variables\n    function getDexVariablesRaw(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES_SLOT));\n    }\n\n    /// @notice Get the raw DEX variables2\n    /// @param dex_ The address of the DEX\n    /// @return The raw DEX variables2\n    function getDexVariables2Raw(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n    }\n\n    /// @notice Get the total supply shares slot data of a DEX\n    /// @param dex_ The address of the DEX\n    /// @return The total supply shares\n    function getTotalSupplySharesRaw(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_TOTAL_SUPPLY_SHARES_SLOT));\n    }\n\n    /// @notice Get the raw user supply data for a specific user and DEX\n    /// @param dex_ The address of the DEX\n    /// @param user_ The address of the user\n    /// @return The raw user supply data\n    function getUserSupplyDataRaw(address dex_, address user_) public view returns (uint) {\n        return\n            IFluidDexT1(dex_).readFromStorage(\n                DexSlotsLink.calculateMappingStorageSlot(DexSlotsLink.DEX_USER_SUPPLY_MAPPING_SLOT, user_)\n            );\n    }\n\n    /// @notice Get the total borrow shares slot data of a DEX\n    /// @param dex_ The address of the DEX\n    /// @return The total borrow shares\n    function getTotalBorrowSharesRaw(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_TOTAL_BORROW_SHARES_SLOT));\n    }\n\n    /// @notice Get the raw user borrow data for a specific user and DEX\n    /// @param dex_ The address of the DEX\n    /// @param user_ The address of the user\n    /// @return The raw user borrow data\n    function getUserBorrowDataRaw(address dex_, address user_) public view returns (uint) {\n        return\n            IFluidDexT1(dex_).readFromStorage(\n                DexSlotsLink.calculateMappingStorageSlot(DexSlotsLink.DEX_USER_BORROW_MAPPING_SLOT, user_)\n            );\n    }\n\n    /// @notice Get the raw oracle data for a specific DEX and index\n    /// @param dex_ The address of the DEX\n    /// @param index_ The index of the oracle data\n    /// @return The raw oracle data\n    function getOracleRaw(address dex_, uint index_) public view returns (uint) {\n        return\n            IFluidDexT1(dex_).readFromStorage(\n                _calculateStorageSlotUintMapping(DexSlotsLink.DEX_ORACLE_MAPPING_SLOT, index_)\n            );\n    }\n\n    /// @notice Get the raw range shift for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return The raw range shift\n    function getRangeShiftRaw(address dex_) public view returns (uint) {\n        return\n            IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_RANGE_THRESHOLD_SHIFTS_SLOT)) &\n            type(uint128).max;\n    }\n\n    /// @notice Get the raw threshold shift for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return The raw threshold shift\n    function getThresholdShiftRaw(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_RANGE_THRESHOLD_SHIFTS_SLOT)) >> 128;\n    }\n\n    /// @notice Get the raw center price shift for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return The raw center price shift\n    function getCenterPriceShiftRaw(address dex_) public view returns (uint) {\n        return IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_CENTER_PRICE_SHIFT_SLOT));\n    }\n\n    /// @dev Calculate the storage slot for a uint mapping\n    /// @param slot_ The base slot of the mapping\n    /// @param key_ The key of the mapping\n    /// @return The calculated storage slot\n    function _calculateStorageSlotUintMapping(uint256 slot_, uint key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n}\n\nabstract contract DexActionEstimates {\n    address private constant ADDRESS_DEAD = 0x000000000000000000000000000000000000dEaD;\n\n    /// @notice estimates swap IN tokens execution\n    /// @param dex_ Dex pool\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function estimateSwapIn(\n        address dex_,\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_\n    ) public payable returns (uint256 amountOut_) {\n        try IFluidDexT1(dex_).swapIn{ value: msg.value }(swap0to1_, amountIn_, amountOutMin_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (amountOut_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSwapResult.selector);\n        }\n    }\n\n    /// @notice estimates swap OUT tokens execution\n    /// @param dex_ Dex pool\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function estimateSwapOut(\n        address dex_,\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_\n    ) public payable returns (uint256 amountIn_) {\n        try IFluidDexT1(dex_).swapOut{ value: msg.value }(swap0to1_, amountOut_, amountInMax_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (amountIn_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSwapResult.selector);\n        }\n    }\n\n    /// @dev Estimate deposit tokens in equal proportion to the current pool ratio\n    /// @param dex_ The address of the DEX contract\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @return token0Amt_ Estimated amount of token0 to deposit\n    /// @return token1Amt_ Estimated amount of token1 to deposit\n    function estimateDepositPerfect(\n        address dex_,\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_\n    ) public payable returns (uint token0Amt_, uint token1Amt_) {\n        try\n            IFluidDexT1(dex_).depositPerfect{ value: msg.value }(shares_, maxToken0Deposit_, maxToken1Deposit_, true)\n        {} catch (bytes memory lowLevelData_) {\n            (token0Amt_, token1Amt_) = _decodeLowLevelUint2x(\n                lowLevelData_,\n                IFluidDexT1.FluidDexPerfectLiquidityOutput.selector\n            );\n        }\n    }\n\n    /// @dev Estimate withdrawal of a perfect amount of collateral liquidity\n    /// @param dex_ The address of the DEX contract\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @return token0Amt_ Estimated amount of token0 to be withdrawn\n    /// @return token1Amt_ Estimated amount of token1 to be withdrawn\n    function estimateWithdrawPerfect(\n        address dex_,\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_\n    ) public returns (uint token0Amt_, uint token1Amt_) {\n        try IFluidDexT1(dex_).withdrawPerfect(shares_, minToken0Withdraw_, minToken1Withdraw_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (token0Amt_, token1Amt_) = _decodeLowLevelUint2x(\n                lowLevelData_,\n                IFluidDexT1.FluidDexPerfectLiquidityOutput.selector\n            );\n        }\n    }\n\n    /// @dev Estimate borrowing tokens in equal proportion to the current debt pool ratio\n    /// @param dex_ The address of the DEX contract\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @return token0Amt_ Estimated amount of token0 to be borrowed\n    /// @return token1Amt_ Estimated amount of token1 to be borrowed\n    function estimateBorrowPerfect(\n        address dex_,\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_\n    ) public returns (uint token0Amt_, uint token1Amt_) {\n        try IFluidDexT1(dex_).borrowPerfect(shares_, minToken0Borrow_, minToken1Borrow_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (token0Amt_, token1Amt_) = _decodeLowLevelUint2x(\n                lowLevelData_,\n                IFluidDexT1.FluidDexPerfectLiquidityOutput.selector\n            );\n        }\n    }\n\n    /// @dev Estimate paying back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param dex_ The address of the DEX contract\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @return token0Amt_ Estimated amount of token0 to be paid back\n    /// @return token1Amt_ Estimated amount of token1 to be paid back\n    function estimatePaybackPerfect(\n        address dex_,\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_\n    ) public payable returns (uint token0Amt_, uint token1Amt_) {\n        try\n            IFluidDexT1(dex_).paybackPerfect{ value: msg.value }(shares_, maxToken0Payback_, maxToken1Payback_, true)\n        {} catch (bytes memory lowLevelData_) {\n            (token0Amt_, token1Amt_) = _decodeLowLevelUint2x(\n                lowLevelData_,\n                IFluidDexT1.FluidDexPerfectLiquidityOutput.selector\n            );\n        }\n    }\n\n    /// @dev Estimate deposit of tokens\n    /// @param dex_ The address of the DEX contract\n    /// @param token0Amt_ Amount of token0 to deposit\n    /// @param token1Amt_ Amount of token1 to deposit\n    /// @param minSharesAmt_ Minimum amount of shares to receive\n    /// @return shares_ Estimated amount of shares to be minted\n    function estimateDeposit(\n        address dex_,\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_\n    ) public payable returns (uint shares_) {\n        try IFluidDexT1(dex_).deposit{ value: msg.value }(token0Amt_, token1Amt_, minSharesAmt_, true) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (shares_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexLiquidityOutput.selector);\n        }\n    }\n\n    /// @dev Estimate withdrawal of tokens\n    /// @param dex_ The address of the DEX contract\n    /// @param token0Amt_ Amount of token0 to withdraw\n    /// @param token1Amt_ Amount of token1 to withdraw\n    /// @param maxSharesAmt_ Maximum amount of shares to burn\n    /// @return shares_ Estimated amount of shares to be burned\n    function estimateWithdraw(\n        address dex_,\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_\n    ) public returns (uint shares_) {\n        try IFluidDexT1(dex_).withdraw(token0Amt_, token1Amt_, maxSharesAmt_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (shares_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexLiquidityOutput.selector);\n        }\n    }\n\n    /// @dev Estimate borrowing of tokens\n    /// @param dex_ The address of the DEX contract\n    /// @param token0Amt_ Amount of token0 to borrow\n    /// @param token1Amt_ Amount of token1 to borrow\n    /// @param maxSharesAmt_ Maximum amount of shares to mint\n    /// @return shares_ Estimated amount of shares to be minted\n    function estimateBorrow(\n        address dex_,\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_\n    ) public returns (uint shares_) {\n        try IFluidDexT1(dex_).borrow(token0Amt_, token1Amt_, maxSharesAmt_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (shares_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexLiquidityOutput.selector);\n        }\n    }\n\n    /// @dev Estimate paying back of borrowed tokens\n    /// @param dex_ The address of the DEX contract\n    /// @param token0Amt_ Amount of token0 to pay back\n    /// @param token1Amt_ Amount of token1 to pay back\n    /// @param minSharesAmt_ Minimum amount of shares to burn\n    /// @return shares_ Estimated amount of shares to be burned\n    function estimatePayback(\n        address dex_,\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_\n    ) public payable returns (uint shares_) {\n        try IFluidDexT1(dex_).payback{ value: msg.value }(token0Amt_, token1Amt_, minSharesAmt_, true) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (shares_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexLiquidityOutput.selector);\n        }\n    }\n\n    /// @dev Estimate withdrawal of a perfect amount of collateral liquidity in one token\n    /// @param dex_ The address of the DEX contract\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1_ The minimum amount of token1 the user is willing to accept\n    /// @return withdrawAmt_ Estimated amount of tokens to be withdrawn\n    function estimateWithdrawPerfectInOneToken(\n        address dex_,\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_\n    ) public returns (uint withdrawAmt_) {\n        try IFluidDexT1(dex_).withdrawPerfectInOneToken(shares_, minToken0_, minToken1_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (withdrawAmt_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSingleTokenOutput.selector);\n        }\n    }\n\n    /// @dev Estimate paying back of a perfect amount of borrowed tokens in one token\n    /// @param dex_ The address of the DEX contract\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0_ Maximum amount of token0 to pay back\n    /// @param maxToken1_ Maximum amount of token1 to pay back\n    /// @return paybackAmt_ Estimated amount of tokens to be paid back\n    function estimatePaybackPerfectInOneToken(\n        address dex_,\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_\n    ) public payable returns (uint paybackAmt_) {\n        try\n            IFluidDexT1(dex_).paybackPerfectInOneToken{ value: msg.value }(shares_, maxToken0_, maxToken1_, true)\n        {} catch (bytes memory lowLevelData_) {\n            (paybackAmt_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSingleTokenOutput.selector);\n        }\n    }\n\n    function _decodeLowLevelUint2x(\n        bytes memory lowLevelData_,\n        bytes4 targetErrorSelector_\n    ) internal pure returns (uint value1_, uint value2_) {\n        if (lowLevelData_.length < 68) {\n            return (0, 0);\n        }\n\n        bytes4 errorSelector_;\n        assembly {\n            // Extract the selector from the error data\n            errorSelector_ := mload(add(lowLevelData_, 0x20))\n        }\n        if (errorSelector_ == targetErrorSelector_) {\n            assembly {\n                value1_ := mload(add(lowLevelData_, 36))\n                value2_ := mload(add(lowLevelData_, 68))\n            }\n        }\n        // else => values remain 0\n    }\n\n    function _decodeLowLevelUint1x(\n        bytes memory lowLevelData_,\n        bytes4 targetErrorSelector_\n    ) internal pure returns (uint value1_) {\n        if (lowLevelData_.length < 36) {\n            return 0;\n        }\n\n        bytes4 errorSelector_;\n        assembly {\n            // Extract the selector from the error data\n            errorSelector_ := mload(add(lowLevelData_, 0x20))\n        }\n        if (errorSelector_ == targetErrorSelector_) {\n            assembly {\n                value1_ := mload(add(lowLevelData_, 36))\n            }\n        }\n        // else => values remain 0\n    }\n}\n\nabstract contract DexConstantsViews {\n    /// @notice returns all Dex constants\n    function getDexConstantsView(address dex_) public view returns (IFluidDexT1.ConstantViews memory constantsView_) {\n        return IFluidDexT1(dex_).constantsView();\n    }\n\n    /// @notice returns all Dex constants 2\n    function getDexConstantsView2(\n        address dex_\n    ) public view returns (IFluidDexT1.ConstantViews2 memory constantsView2_) {\n        return IFluidDexT1(dex_).constantsView2();\n    }\n\n    /// @notice Get the addresses of the tokens in a DEX\n    /// @param dex_ The address of the DEX\n    /// @return token0_ The address of token0 in the DEX\n    /// @return token1_ The address of token1 in the DEX\n    function getDexTokens(address dex_) public view returns (address token0_, address token1_) {\n        IFluidDexT1.ConstantViews memory constantsView_ = IFluidDexT1(dex_).constantsView();\n        return (constantsView_.token0, constantsView_.token1);\n    }\n}\n\nabstract contract DexPublicViews is DexStorageVars, DexConstantsViews {\n    /// @notice Get the prices and exchange prices for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return pex_ A struct containing prices and exchange prices\n    /// @dev expected to be called via callStatic\n    function getDexPricesAndExchangePrices(\n        address dex_\n    ) public returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n        try IFluidDexT1(dex_).getPricesAndExchangePrices() {} catch (bytes memory lowLevelData_) {\n            bytes4 errorSelector_;\n            assembly {\n                // Extract the selector from the error data\n                errorSelector_ := mload(add(lowLevelData_, 0x20))\n            }\n            if (errorSelector_ == IFluidDexT1.FluidDexPricesAndExchangeRates.selector) {\n                pex_ = abi.decode(\n                    BytesSliceAndConcat.bytesSlice(lowLevelData_, 4, lowLevelData_.length - 4),\n                    (IFluidDexT1.PricesAndExchangePrice)\n                );\n            }\n        }\n    }\n\n    /// @notice Get the collateral reserves for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing collateral reserve information\n    /// @dev expected to be called via callStatic\n    function getDexCollateralReserves(address dex_) public returns (IFluidDexT1.CollateralReserves memory reserves_) {\n        return _getDexCollateralReserves(dex_, getDexConstantsView2(dex_));\n    }\n\n    /// @notice Get the debt reserves for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing debt reserve information\n    /// @dev expected to be called via callStatic\n    function getDexDebtReserves(address dex_) public returns (IFluidDexT1.DebtReserves memory reserves_) {\n        return _getDexDebtReserves(dex_, getDexConstantsView2(dex_));\n    }\n\n    /// @notice get Dex oracle price TWAP data\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function getDexOraclePrice(\n        address dex_,\n        uint[] memory secondsAgos_\n    ) external view returns (IFluidDexT1.Oracle[] memory twaps_, uint currentPrice_) {\n        return IFluidDexT1(dex_).oraclePrice(secondsAgos_);\n    }\n\n    /// @dev Get the collateral reserves for a DEX scaled to token decimals\n    function _getDexCollateralReserves(\n        address dex_,\n        IFluidDexT1.ConstantViews2 memory constantsView2_\n    ) internal returns (IFluidDexT1.CollateralReserves memory reserves_) {\n        uint256 dexVariables2_ = getDexVariables2Raw(dex_);\n        if ((dexVariables2_ & 1) != 1) {\n            // smart col not enabled\n            return IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            try\n                IFluidDexT1(dex_).getCollateralReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.supplyToken0ExchangePrice,\n                    pex_.supplyToken1ExchangePrice\n                )\n            returns (IFluidDexT1.CollateralReserves memory colReserves_) {\n                // returned reserves are in 1e12 decimals -> normalize to token decimals\n                reserves_.token0RealReserves =\n                    (colReserves_.token0RealReserves * constantsView2_.token0DenominatorPrecision) /\n                    constantsView2_.token0NumeratorPrecision;\n                reserves_.token0ImaginaryReserves =\n                    (colReserves_.token0ImaginaryReserves * constantsView2_.token0DenominatorPrecision) /\n                    constantsView2_.token0NumeratorPrecision;\n                reserves_.token1RealReserves =\n                    (colReserves_.token1RealReserves * constantsView2_.token1DenominatorPrecision) /\n                    constantsView2_.token1NumeratorPrecision;\n                reserves_.token1ImaginaryReserves =\n                    (colReserves_.token1ImaginaryReserves * constantsView2_.token1DenominatorPrecision) /\n                    constantsView2_.token1NumeratorPrecision;\n            } catch {\n                reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n            }\n        } catch {\n            reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n    }\n\n    /// @dev Get the debt reserves for a DEX scaled to token decimals\n    function _getDexDebtReserves(\n        address dex_,\n        IFluidDexT1.ConstantViews2 memory constantsView2_\n    ) internal returns (IFluidDexT1.DebtReserves memory reserves_) {\n        uint256 dexVariables2_ = getDexVariables2Raw(dex_);\n        if ((dexVariables2_ & 2) != 2) {\n            // smart debt not enabled\n            return IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            try\n                IFluidDexT1(dex_).getDebtReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.borrowToken0ExchangePrice,\n                    pex_.borrowToken1ExchangePrice\n                )\n            returns (IFluidDexT1.DebtReserves memory debtReserves_) {\n                // returned reserves are in 1e12 decimals -> normalize to token decimals\n                reserves_.token0Debt =\n                    (debtReserves_.token0Debt * constantsView2_.token0DenominatorPrecision) /\n                    constantsView2_.token0NumeratorPrecision;\n                reserves_.token0RealReserves =\n                    (debtReserves_.token0RealReserves * constantsView2_.token0DenominatorPrecision) /\n                    constantsView2_.token0NumeratorPrecision;\n                reserves_.token0ImaginaryReserves =\n                    (debtReserves_.token0ImaginaryReserves * constantsView2_.token0DenominatorPrecision) /\n                    constantsView2_.token0NumeratorPrecision;\n                reserves_.token1Debt =\n                    (debtReserves_.token1Debt * constantsView2_.token1DenominatorPrecision) /\n                    constantsView2_.token1NumeratorPrecision;\n                reserves_.token1RealReserves =\n                    (debtReserves_.token1RealReserves * constantsView2_.token1DenominatorPrecision) /\n                    constantsView2_.token1NumeratorPrecision;\n                reserves_.token1ImaginaryReserves =\n                    (debtReserves_.token1ImaginaryReserves * constantsView2_.token1DenominatorPrecision) /\n                    constantsView2_.token1NumeratorPrecision;\n            } catch {\n                reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n            }\n        } catch {\n            reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n    }\n}\n\nabstract contract DexUserViews is Variables, Structs, DexConstantsViews, DexPublicViews {\n    /// @notice Get user supply data for a specific DEX and user\n    /// @param dex_ The address of the DEX\n    /// @param user_ The address of the user\n    /// @return userSupplyData_ Struct containing user supply data\n    function getUserSupplyData(\n        address dex_,\n        address user_\n    ) public view returns (UserSupplyData memory userSupplyData_) {\n        uint256 userSupply_ = getUserSupplyDataRaw(dex_, user_);\n\n        if (userSupply_ > 0) {\n            // if userSupply_ == 0 -> user not configured yet\n            userSupplyData_.isAllowed = userSupply_ & 1 == 1;\n            userSupplyData_.supply = BigMathMinified.fromBigNumber(\n                (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & DexCalcs.X64,\n                DexCalcs.DEFAULT_EXPONENT_SIZE,\n                DexCalcs.DEFAULT_EXPONENT_MASK\n            );\n\n            // get updated expanded withdrawal limit\n            userSupplyData_.withdrawalLimit = DexCalcs.calcWithdrawalLimitBeforeOperate(\n                userSupply_,\n                userSupplyData_.supply\n            );\n\n            userSupplyData_.lastUpdateTimestamp =\n                (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) &\n                DexCalcs.X33;\n            userSupplyData_.expandPercent =\n                (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) &\n                DexCalcs.X14;\n            userSupplyData_.expandDuration =\n                (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) &\n                DexCalcs.X24;\n            userSupplyData_.baseWithdrawalLimit = BigMathMinified.fromBigNumber(\n                (userSupply_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & DexCalcs.X18,\n                DexCalcs.DEFAULT_EXPONENT_SIZE,\n                DexCalcs.DEFAULT_EXPONENT_MASK\n            );\n\n            userSupplyData_.withdrawableUntilLimit = userSupplyData_.supply > userSupplyData_.withdrawalLimit\n                ? userSupplyData_.supply - userSupplyData_.withdrawalLimit\n                : 0;\n\n            userSupplyData_.withdrawable = userSupplyData_.withdrawableUntilLimit;\n\n            (address token0_, address token1_) = getDexTokens(dex_);\n            (userSupplyData_.liquidityUserSupplyDataToken0, userSupplyData_.liquidityTokenData0) = LIQUIDITY_RESOLVER\n                .getUserSupplyData(dex_, token0_);\n            (userSupplyData_.liquidityUserSupplyDataToken1, userSupplyData_.liquidityTokenData1) = LIQUIDITY_RESOLVER\n                .getUserSupplyData(dex_, token1_);\n        }\n    }\n\n    /// @notice Get user supply data for multiple users in a specific DEX\n    /// @param dex_ The address of the DEX\n    /// @param users_ Array of user addresses\n    /// @return userSuppliesData_ Array of UserSupplyData structs for each user\n    function getUserSupplyDatas(\n        address dex_,\n        address[] calldata users_\n    ) public view returns (UserSupplyData[] memory userSuppliesData_) {\n        uint256 length_ = users_.length;\n        userSuppliesData_ = new UserSupplyData[](length_);\n\n        for (uint256 i; i < length_; i++) {\n            (userSuppliesData_[i]) = getUserSupplyData(dex_, users_[i]);\n        }\n    }\n\n    /// @notice Get user borrow data for a specific DEX and user\n    /// @param dex_ The address of the DEX\n    /// @param user_ The address of the user\n    /// @return userBorrowData_ Struct containing user borrow data\n    function getUserBorrowData(\n        address dex_,\n        address user_\n    ) public view returns (UserBorrowData memory userBorrowData_) {\n        uint256 userBorrow_ = getUserBorrowDataRaw(dex_, user_);\n\n        if (userBorrow_ > 0) {\n            // if userBorrow_ == 0 -> user not configured yet\n\n            userBorrowData_.isAllowed = userBorrow_ & 1 == 1;\n\n            userBorrowData_.borrow = BigMathMinified.fromBigNumber(\n                (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & DexCalcs.X64,\n                DexCalcs.DEFAULT_EXPONENT_SIZE,\n                DexCalcs.DEFAULT_EXPONENT_MASK\n            );\n\n            // get updated expanded borrow limit\n            userBorrowData_.borrowLimit = DexCalcs.calcBorrowLimitBeforeOperate(userBorrow_, userBorrowData_.borrow);\n\n            userBorrowData_.lastUpdateTimestamp =\n                (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) &\n                DexCalcs.X33;\n            userBorrowData_.expandPercent =\n                (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) &\n                DexCalcs.X14;\n            userBorrowData_.expandDuration =\n                (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) &\n                DexCalcs.X24;\n            userBorrowData_.baseBorrowLimit = BigMathMinified.fromBigNumber(\n                (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & DexCalcs.X18,\n                DexCalcs.DEFAULT_EXPONENT_SIZE,\n                DexCalcs.DEFAULT_EXPONENT_MASK\n            );\n            userBorrowData_.maxBorrowLimit = BigMathMinified.fromBigNumber(\n                (userBorrow_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & DexCalcs.X18,\n                DexCalcs.DEFAULT_EXPONENT_SIZE,\n                DexCalcs.DEFAULT_EXPONENT_MASK\n            );\n\n            userBorrowData_.borrowableUntilLimit = userBorrowData_.borrowLimit > userBorrowData_.borrow\n                ? userBorrowData_.borrowLimit - userBorrowData_.borrow\n                : 0;\n\n            userBorrowData_.borrowable = userBorrowData_.borrowableUntilLimit;\n\n            (address token0_, address token1_) = getDexTokens(dex_);\n            (userBorrowData_.liquidityUserBorrowDataToken0, userBorrowData_.liquidityTokenData0) = LIQUIDITY_RESOLVER\n                .getUserBorrowData(dex_, token0_);\n            (userBorrowData_.liquidityUserBorrowDataToken1, userBorrowData_.liquidityTokenData1) = LIQUIDITY_RESOLVER\n                .getUserBorrowData(dex_, token1_);\n        }\n    }\n\n    /// @notice Get user borrow data for multiple users in a specific DEX\n    /// @param dex_ The address of the DEX\n    /// @param users_ Array of user addresses\n    /// @return userBorrowingsData_ Array of UserBorrowData structs for each user\n    function getUserBorrowDatas(\n        address dex_,\n        address[] calldata users_\n    ) public view returns (UserBorrowData[] memory userBorrowingsData_) {\n        uint256 length_ = users_.length;\n        userBorrowingsData_ = new UserBorrowData[](length_);\n\n        for (uint256 i; i < length_; i++) {\n            (userBorrowingsData_[i]) = getUserBorrowData(dex_, users_[i]);\n        }\n    }\n\n    /// @notice Get both user supply and borrow data for multiple users in a specific DEX\n    /// @param dex_ The address of the DEX\n    /// @param users_ Array of user addresses\n    /// @return userSuppliesData_ Array of UserSupplyData structs for each user\n    /// @return userBorrowingsData_ Array of UserBorrowData structs for each user\n    function getUserBorrowSupplyDatas(\n        address dex_,\n        address[] calldata users_\n    ) public view returns (UserSupplyData[] memory userSuppliesData_, UserBorrowData[] memory userBorrowingsData_) {\n        uint256 length_ = users_.length;\n        userSuppliesData_ = new UserSupplyData[](length_);\n        userBorrowingsData_ = new UserBorrowData[](length_);\n        for (uint256 i; i < length_; i++) {\n            (userSuppliesData_[i]) = getUserSupplyData(dex_, users_[i]);\n            (userBorrowingsData_[i]) = getUserBorrowData(dex_, users_[i]);\n        }\n    }\n}\n\n/// @notice Fluid Dex protocol resolver\n/// Implements various view-only methods to give easy access to Dex protocol data.\ncontract FluidDexResolver is Variables, DexFactoryViews, DexActionEstimates, DexUserViews {\n    constructor(\n        address factory_,\n        address liquidity_,\n        address liquidityResolver_,\n        address deployer_\n    ) Variables(factory_, liquidity_, liquidityResolver_, deployer_) {}\n\n    /// @notice Get the current state of a DEX\n    /// @param dex_ The address of the DEX\n    /// @return state_ A struct containing the current state of the DEX\n    /// @dev expected to be called via callStatic\n    function getDexState(address dex_) public returns (DexState memory state_) {\n        return _getDexState(dex_, getDexCollateralReserves(dex_), getDexDebtReserves(dex_));\n    }\n\n    /// @notice Get the current configurations of a DEX\n    /// @param dex_ The address of the DEX\n    /// @return configs_ A struct containing the current configurations of the DEX\n    function getDexConfigs(address dex_) public view returns (Configs memory configs_) {\n        uint256 dexVariables2_ = getDexVariables2Raw(dex_);\n\n        configs_.isSmartCollateralEnabled = (dexVariables2_ & 1) == 1;\n        configs_.isSmartDebtEnabled = (dexVariables2_ & 2) == 2;\n        configs_.fee = (dexVariables2_ >> 2) & X17;\n        configs_.revenueCut = (dexVariables2_ >> 19) & X7;\n        configs_.upperRange = (dexVariables2_ >> 27) & X20;\n        configs_.lowerRange = (dexVariables2_ >> 47) & X20;\n        configs_.upperShiftThreshold = (dexVariables2_ >> 68) & X10;\n        configs_.lowerShiftThreshold = (dexVariables2_ >> 78) & X10;\n        configs_.shiftingTime = (dexVariables2_ >> 88) & X24;\n\n        configs_.maxSupplyShares = getTotalSupplySharesRaw(dex_) >> 128;\n        configs_.maxBorrowShares = getTotalBorrowSharesRaw(dex_) >> 128;\n\n        uint256 addressNonce_ = (dexVariables2_ >> 112) & X30;\n        if (addressNonce_ > 0) {\n            configs_.centerPriceAddress = AddressCalcs.addressCalc(DEPLOYER_CONTRACT, addressNonce_);\n        }\n\n        addressNonce_ = (dexVariables2_ >> 142) & X30;\n        if (addressNonce_ > 0) {\n            configs_.hookAddress = AddressCalcs.addressCalc(DEPLOYER_CONTRACT, addressNonce_);\n        }\n\n        configs_.maxCenterPrice = BigMathMinified.fromBigNumber(\n            (dexVariables2_ >> 172) & X28,\n            DexCalcs.DEFAULT_EXPONENT_SIZE,\n            DexCalcs.DEFAULT_EXPONENT_MASK\n        );\n        configs_.minCenterPrice = BigMathMinified.fromBigNumber(\n            (dexVariables2_ >> 200) & X28,\n            DexCalcs.DEFAULT_EXPONENT_SIZE,\n            DexCalcs.DEFAULT_EXPONENT_MASK\n        );\n\n        configs_.utilizationLimitToken0 = (dexVariables2_ >> 228) & X10;\n        configs_.utilizationLimitToken1 = (dexVariables2_ >> 238) & X10;\n    }\n\n    /// @notice Get the swap limits and availability for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return limitsAndAvailability_ A struct containing the swap limits and availability for the DEX\n    function getDexSwapLimitsAndAvailability(\n        address dex_\n    ) public view returns (SwapLimitsAndAvailability memory limitsAndAvailability_) {\n        (address token0_, address token1_) = getDexTokens(dex_);\n\n        uint256 dexVariables2_ = getDexVariables2Raw(dex_);\n        uint256 utilizationLimitToken0_ = (dexVariables2_ >> 228) & X10;\n        uint256 utilizationLimitToken1_ = (dexVariables2_ >> 238) & X10;\n\n        return\n            _getDexSwapLimitsAndAvailability(dex_, token0_, token1_, utilizationLimitToken0_, utilizationLimitToken1_);\n    }\n\n    /// @notice Get the entire data for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return data_ A struct containing all the data for the DEX\n    /// @dev expected to be called via callStatic\n    function getDexEntireData(address dex_) public returns (DexEntireData memory data_) {\n        data_.dex = dex_;\n        data_.constantViews = getDexConstantsView(dex_);\n        data_.constantViews2 = getDexConstantsView2(dex_);\n        data_.configs = getDexConfigs(dex_);\n        data_.pex = getDexPricesAndExchangePrices(dex_);\n        data_.colReserves = _getDexCollateralReserves(dex_, data_.constantViews2);\n        data_.debtReserves = _getDexDebtReserves(dex_, data_.constantViews2);\n        data_.dexState = _getDexState(dex_, data_.colReserves, data_.debtReserves);\n        data_.limitsAndAvailability = _getDexSwapLimitsAndAvailability(\n            dex_,\n            data_.constantViews.token0,\n            data_.constantViews.token1,\n            data_.configs.utilizationLimitToken0,\n            data_.configs.utilizationLimitToken1\n        );\n    }\n\n    /// @notice Get the entire data for multiple DEXes\n    /// @param dexes_ An array of DEX addresses\n    /// @return datas_ An array of structs containing all the data for each DEX\n    /// @dev expected to be called via callStatic\n    function getDexEntireDatas(address[] memory dexes_) public returns (DexEntireData[] memory datas_) {\n        uint256 length_ = dexes_.length;\n        datas_ = new DexEntireData[](length_);\n\n        for (uint256 i; i < length_; i++) {\n            datas_[i] = getDexEntireData(dexes_[i]);\n        }\n    }\n\n    /// @notice Get the entire data for all DEXes\n    /// @return datas_ An array of structs containing all the data for all DEXes\n    /// @dev expected to be called via callStatic\n    function getAllDexEntireDatas() external returns (DexEntireData[] memory datas_) {\n        return getDexEntireDatas(getAllDexAddresses());\n    }\n\n    /// @dev get the swap limits and availability for a DEX\n    /// @param dex_ The address of the DEX\n    /// @param token0_ The address of token0\n    /// @param token1_ The address of token1\n    /// @param utilizationLimitToken0Percent_ The utilization limit percentage for token0\n    /// @param utilizationLimitToken1Percent_ The utilization limit percentage for token1\n    /// @return limitsAndAvailability_ A struct containing the swap limits and availability for the DEX\n    function _getDexSwapLimitsAndAvailability(\n        address dex_,\n        address token0_,\n        address token1_,\n        uint256 utilizationLimitToken0Percent_,\n        uint256 utilizationLimitToken1Percent_\n    ) internal view returns (SwapLimitsAndAvailability memory limitsAndAvailability_) {\n        (\n            limitsAndAvailability_.liquidityUserSupplyDataToken0,\n            limitsAndAvailability_.liquidityTokenData0\n        ) = LIQUIDITY_RESOLVER.getUserSupplyData(dex_, token0_);\n        (\n            limitsAndAvailability_.liquidityUserSupplyDataToken1,\n            limitsAndAvailability_.liquidityTokenData1\n        ) = LIQUIDITY_RESOLVER.getUserSupplyData(dex_, token1_);\n\n        (limitsAndAvailability_.liquidityUserBorrowDataToken0, ) = LIQUIDITY_RESOLVER.getUserBorrowData(dex_, token0_);\n        (limitsAndAvailability_.liquidityUserBorrowDataToken1, ) = LIQUIDITY_RESOLVER.getUserBorrowData(dex_, token1_);\n\n        limitsAndAvailability_.liquiditySupplyToken0 = limitsAndAvailability_.liquidityTokenData0.totalSupply;\n        limitsAndAvailability_.liquiditySupplyToken1 = limitsAndAvailability_.liquidityTokenData1.totalSupply;\n        limitsAndAvailability_.liquidityBorrowToken0 = limitsAndAvailability_.liquidityTokenData0.totalBorrow;\n        limitsAndAvailability_.liquidityBorrowToken1 = limitsAndAvailability_.liquidityTokenData1.totalBorrow;\n\n        limitsAndAvailability_.liquidityWithdrawableToken0 = limitsAndAvailability_\n            .liquidityUserSupplyDataToken0\n            .withdrawable;\n        limitsAndAvailability_.liquidityWithdrawableToken1 = limitsAndAvailability_\n            .liquidityUserSupplyDataToken1\n            .withdrawable;\n\n        limitsAndAvailability_.liquidityBorrowableToken0 = limitsAndAvailability_\n            .liquidityUserBorrowDataToken0\n            .borrowable;\n        limitsAndAvailability_.liquidityBorrowableToken1 = limitsAndAvailability_\n            .liquidityUserBorrowDataToken1\n            .borrowable;\n\n        limitsAndAvailability_.utilizationLimitToken0 =\n            (limitsAndAvailability_.liquiditySupplyToken0 * utilizationLimitToken0Percent_) /\n            1e3;\n        limitsAndAvailability_.utilizationLimitToken1 =\n            (limitsAndAvailability_.liquiditySupplyToken1 * utilizationLimitToken1Percent_) /\n            1e3;\n\n        if (limitsAndAvailability_.liquidityBorrowToken0 < limitsAndAvailability_.utilizationLimitToken0) {\n            limitsAndAvailability_.withdrawableUntilUtilizationLimitToken0 =\n                (1e3 * limitsAndAvailability_.liquidityBorrowToken0) /\n                utilizationLimitToken0Percent_;\n            limitsAndAvailability_.withdrawableUntilUtilizationLimitToken0 = limitsAndAvailability_\n                .liquiditySupplyToken0 > limitsAndAvailability_.withdrawableUntilUtilizationLimitToken0\n                ? limitsAndAvailability_.liquiditySupplyToken0 -\n                    limitsAndAvailability_.withdrawableUntilUtilizationLimitToken0\n                : 0;\n\n            limitsAndAvailability_.borrowableUntilUtilizationLimitToken0 =\n                limitsAndAvailability_.utilizationLimitToken0 -\n                limitsAndAvailability_.liquidityBorrowToken0;\n        }\n\n        if (limitsAndAvailability_.liquidityBorrowToken1 < limitsAndAvailability_.utilizationLimitToken1) {\n            limitsAndAvailability_.withdrawableUntilUtilizationLimitToken1 =\n                (1e3 * limitsAndAvailability_.liquidityBorrowToken1) /\n                utilizationLimitToken1Percent_;\n            limitsAndAvailability_.withdrawableUntilUtilizationLimitToken1 = limitsAndAvailability_\n                .liquiditySupplyToken1 > limitsAndAvailability_.withdrawableUntilUtilizationLimitToken1\n                ? limitsAndAvailability_.liquiditySupplyToken1 -\n                    limitsAndAvailability_.withdrawableUntilUtilizationLimitToken1\n                : 0;\n\n            limitsAndAvailability_.borrowableUntilUtilizationLimitToken1 =\n                limitsAndAvailability_.utilizationLimitToken1 -\n                limitsAndAvailability_.liquidityBorrowToken1;\n        }\n    }\n\n    /// @dev Get the current state of a DEX\n    function _getDexState(\n        address dex_,\n        IFluidDexT1.CollateralReserves memory colReserves_,\n        IFluidDexT1.DebtReserves memory debtReserves_\n    ) internal view returns (DexState memory state_) {\n        uint256 storageVar_ = getDexVariablesRaw(dex_);\n\n        /// Next 40 bits => 1-40 => last to last stored price. BigNumber (32 bits precision, 8 bits exponent)\n        /// Next 40 bits => 41-80 => last stored price of pool. BigNumber (32 bits precision, 8 bits exponent)\n        /// Next 40 bits => 81-120 => center price. Center price from where the ranges will be calculated. BigNumber (32 bits precision, 8 bits exponent)\n        state_.lastToLastStoredPrice = (storageVar_ >> 1) & X40;\n        state_.lastToLastStoredPrice = (state_.lastToLastStoredPrice >> 8) << (state_.lastToLastStoredPrice & X8);\n        state_.lastStoredPrice = (storageVar_ >> 41) & X40;\n        state_.lastStoredPrice = (state_.lastStoredPrice >> 8) << (state_.lastStoredPrice & X8);\n        state_.centerPrice = (storageVar_ >> 81) & X40;\n        state_.centerPrice = (state_.centerPrice >> 8) << (state_.centerPrice & X8);\n\n        state_.lastUpdateTimestamp = (storageVar_ >> 121) & X33;\n        state_.lastPricesTimeDiff = (storageVar_ >> 154) & X22;\n        state_.oracleCheckPoint = (storageVar_ >> 176) & X3;\n        state_.oracleMapping = (storageVar_ >> 179) & X16;\n\n        state_.totalSupplyShares = getTotalSupplySharesRaw(dex_) & X128;\n        state_.totalBorrowShares = getTotalBorrowSharesRaw(dex_) & X128;\n\n        storageVar_ = getDexVariables2Raw(dex_);\n        state_.isSwapAndArbitragePaused = storageVar_ >> 255 == 1;\n\n        state_.shifts.isRangeChangeActive = (storageVar_ >> 26) & 1 == 1;\n        state_.shifts.isThresholdChangeActive = (storageVar_ >> 67) & 1 == 1;\n        state_.shifts.isCenterPriceShiftActive = (storageVar_ >> 248) & 1 == 1;\n\n        storageVar_ = getRangeShiftRaw(dex_);\n        state_.shifts.rangeShift.oldUpper = storageVar_ & X20;\n        state_.shifts.rangeShift.oldLower = (storageVar_ >> 20) & X20;\n        state_.shifts.rangeShift.duration = (storageVar_ >> 40) & X20;\n        state_.shifts.rangeShift.startTimestamp = (storageVar_ >> 60) & X33;\n\n        storageVar_ = getThresholdShiftRaw(dex_);\n        state_.shifts.thresholdShift.oldUpper = storageVar_ & X10;\n        state_.shifts.thresholdShift.oldLower = (storageVar_ >> 20) & X10;\n        state_.shifts.thresholdShift.duration = (storageVar_ >> 40) & X20;\n        state_.shifts.thresholdShift.startTimestamp = (storageVar_ >> 60) & X33;\n        state_.shifts.thresholdShift.oldTime = (storageVar_ >> 93) & X24;\n\n        storageVar_ = getCenterPriceShiftRaw(dex_);\n        state_.shifts.centerPriceShift.startTimestamp = storageVar_ & X33;\n        state_.shifts.centerPriceShift.shiftPercentage = (storageVar_ >> 33) & X20;\n        state_.shifts.centerPriceShift.duration = (storageVar_ >> 53) & X20;\n\n        if (state_.totalSupplyShares > 0) {\n            state_.token0PerSupplyShare = (colReserves_.token0RealReserves * 1e18) / state_.totalSupplyShares;\n            state_.token1PerSupplyShare = (colReserves_.token1RealReserves * 1e18) / state_.totalSupplyShares;\n        }\n        if (state_.totalBorrowShares > 0) {\n            state_.token0PerBorrowShare = (debtReserves_.token0Debt * 1e18) / state_.totalBorrowShares;\n            state_.token1PerBorrowShare = (debtReserves_.token1Debt * 1e18) / state_.totalBorrowShares;\n        }\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dex/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { Structs as FluidLiquidityResolverStructs } from \"../liquidity/structs.sol\";\n\nabstract contract Structs {\n    struct DexState {\n        uint256 lastToLastStoredPrice;\n        uint256 lastStoredPrice; // price of pool after the most recent swap\n        uint256 centerPrice;\n        uint256 lastUpdateTimestamp;\n        uint256 lastPricesTimeDiff;\n        uint256 oracleCheckPoint;\n        uint256 oracleMapping;\n        uint256 totalSupplyShares;\n        uint256 totalBorrowShares;\n        bool isSwapAndArbitragePaused; // if true, only perfect functions will be usable\n        ShiftChanges shifts;\n        // below values have to be combined with Oracle price data at the VaultResolver\n        uint256 token0PerSupplyShare; // token0 amount per 1e18 supply shares\n        uint256 token1PerSupplyShare; // token1 amount per 1e18 supply shares\n        uint256 token0PerBorrowShare; // token0 amount per 1e18 borrow shares\n        uint256 token1PerBorrowShare; // token1 amount per 1e18 borrow shares\n    }\n\n    struct ShiftData {\n        uint256 oldUpper;\n        uint256 oldLower;\n        uint256 duration;\n        uint256 startTimestamp;\n        uint256 oldTime; // only for thresholdShift\n    }\n\n    struct CenterPriceShift {\n        uint256 shiftPercentage;\n        uint256 duration;\n        uint256 startTimestamp;\n    }\n\n    struct ShiftChanges {\n        bool isRangeChangeActive;\n        bool isThresholdChangeActive;\n        bool isCenterPriceShiftActive;\n        ShiftData rangeShift;\n        ShiftData thresholdShift;\n        CenterPriceShift centerPriceShift;\n    }\n\n    struct Configs {\n        bool isSmartCollateralEnabled;\n        bool isSmartDebtEnabled;\n        uint256 fee;\n        uint256 revenueCut;\n        uint256 upperRange;\n        uint256 lowerRange;\n        uint256 upperShiftThreshold;\n        uint256 lowerShiftThreshold;\n        uint256 shiftingTime;\n        address centerPriceAddress;\n        address hookAddress;\n        uint256 maxCenterPrice;\n        uint256 minCenterPrice;\n        uint256 utilizationLimitToken0;\n        uint256 utilizationLimitToken1;\n        uint256 maxSupplyShares;\n        uint256 maxBorrowShares;\n    }\n\n    // @dev note there might be other things that act as effective limits which are not fully considered here.\n    // e.g. such as maximum 5% oracle shift in one swap, withdraws & borrowing together affecting each other,\n    // shares being below max supply / borrow shares etc.\n    struct SwapLimitsAndAvailability {\n        // liquidity total amounts\n        uint liquiditySupplyToken0;\n        uint liquiditySupplyToken1;\n        uint liquidityBorrowToken0;\n        uint liquidityBorrowToken1;\n        // liquidity limits\n        uint liquidityWithdrawableToken0;\n        uint liquidityWithdrawableToken1;\n        uint liquidityBorrowableToken0;\n        uint liquidityBorrowableToken1;\n        // utilization limits based on config at Dex. (e.g. liquiditySupplyToken0 * Configs.utilizationLimitToken0 / 1e3)\n        uint utilizationLimitToken0;\n        uint utilizationLimitToken1;\n        // swappable amounts until utilization limit.\n        // In a swap that does both withdraw and borrow, the effective amounts might be less because withdraw / borrow affect each other\n        // (both increase utilization).\n        uint withdrawableUntilUtilizationLimitToken0; // x = totalSupply - totalBorrow / maxUtilizationPercentage\n        uint withdrawableUntilUtilizationLimitToken1;\n        uint borrowableUntilUtilizationLimitToken0; // x = maxUtilizationPercentage * totalSupply - totalBorrow.\n        uint borrowableUntilUtilizationLimitToken1;\n        // additional liquidity related data such as supply amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyDataToken0;\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyDataToken1;\n        // additional liquidity related data such as borrow amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowDataToken0;\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowDataToken1;\n        // liquidity token related data\n        FluidLiquidityResolverStructs.OverallTokenData liquidityTokenData0;\n        FluidLiquidityResolverStructs.OverallTokenData liquidityTokenData1;\n    }\n\n    struct DexEntireData {\n        address dex;\n        IFluidDexT1.ConstantViews constantViews;\n        IFluidDexT1.ConstantViews2 constantViews2;\n        Configs configs;\n        IFluidDexT1.PricesAndExchangePrice pex;\n        IFluidDexT1.CollateralReserves colReserves;\n        IFluidDexT1.DebtReserves debtReserves;\n        DexState dexState;\n        SwapLimitsAndAvailability limitsAndAvailability;\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserSupplyData {\n        bool isAllowed;\n        uint256 supply; // user supply amount/shares\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\n        uint256 withdrawalLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\n        uint256 baseWithdrawalLimit;\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\n        uint256 withdrawableUntilLimit;\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\n        // liquidity related data such as supply amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyDataToken0;\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyDataToken1;\n        // liquidity token related data\n        FluidLiquidityResolverStructs.OverallTokenData liquidityTokenData0;\n        FluidLiquidityResolverStructs.OverallTokenData liquidityTokenData1;\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserBorrowData {\n        bool isAllowed;\n        uint256 borrow; // user borrow amount/shares\n        uint256 borrowLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseBorrowLimit;\n        uint256 maxBorrowLimit;\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        // liquidity related data such as borrow amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowDataToken0;\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowDataToken1;\n        // liquidity token related data\n        FluidLiquidityResolverStructs.OverallTokenData liquidityTokenData0;\n        FluidLiquidityResolverStructs.OverallTokenData liquidityTokenData1;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dex/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidityResolver } from \"../liquidity/iLiquidityResolver.sol\";\nimport { IFluidDexFactory } from \"../../../protocols/dex/interfaces/iDexFactory.sol\";\n\ninterface IFluidLiquidity {\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n\nabstract contract Variables {\n    IFluidDexFactory public immutable FACTORY;\n    IFluidLiquidity public immutable LIQUIDITY;\n    IFluidLiquidityResolver public immutable LIQUIDITY_RESOLVER;\n    /// @dev Address of contract used for deploying center price & hook related contract\n    address public immutable DEPLOYER_CONTRACT;\n\n    uint256 internal constant X2 = 0x3;\n    uint256 internal constant X3 = 0x7;\n    uint256 internal constant X5 = 0x1f;\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X8 = 0xff;\n    uint256 internal constant X9 = 0x1ff;\n    uint256 internal constant X10 = 0x3ff;\n    uint256 internal constant X11 = 0x7ff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X17 = 0x1ffff;\n    uint256 internal constant X20 = 0xfffff;\n    uint256 internal constant X22 = 0x3fffff;\n    uint256 internal constant X23 = 0x7fffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X28 = 0xfffffff;\n    uint256 internal constant X30 = 0x3fffffff;\n    uint256 internal constant X32 = 0xffffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X40 = 0xffffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n    uint256 internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n\n    /// @dev address that is mapped to the chain native token\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    constructor(address factory_, address liquidity_, address liquidityResolver_, address deployer_) {\n        FACTORY = IFluidDexFactory(factory_);\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        LIQUIDITY_RESOLVER = IFluidLiquidityResolver(liquidityResolver_);\n        DEPLOYER_CONTRACT = deployer_;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/iLiquidityResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Structs as LiquidityStructs } from \"../../../periphery/resolvers/liquidity/structs.sol\";\n\ninterface IFluidLiquidityResolver {\n    /// @notice gets the `revenueAmount_` for a `token_`.\n    function getRevenue(address token_) external view returns (uint256 revenueAmount_);\n\n    /// @notice address of contract that gets sent the revenue. Configurable by governance\n    function getRevenueCollector() external view returns (address);\n\n    /// @notice Liquidity contract paused status: status = 1 -> normal. status = 2 -> paused.\n    function getStatus() external view returns (uint256);\n\n    /// @notice checks if `auth_` is an allowed auth on Liquidity.\n    /// Auths can set most config values. E.g. contracts that automate certain flows like e.g. adding a new fToken.\n    /// Governance can add/remove auths. Governance is auth by default.\n    function isAuth(address auth_) external view returns (uint256);\n\n    /// @notice checks if `guardian_` is an allowed Guardian on Liquidity.\n    /// Guardians can pause lower class users.\n    /// Governance can add/remove guardians. Governance is guardian by default.\n    function isGuardian(address guardian_) external view returns (uint256);\n\n    /// @notice gets user class for `user_`. Class defines which protocols can be paused by guardians.\n    /// Currently there are 2 classes: 0 can be paused by guardians. 1 cannot be paused by guardians.\n    /// New protocols are added as class 0 and will be upgraded to 1 over time.\n    function getUserClass(address user_) external view returns (uint256);\n\n    /// @notice gets exchangePricesAndConfig packed uint256 storage slot for `token_`.\n    function getExchangePricesAndConfig(address token_) external view returns (uint256);\n\n    /// @notice gets rateConfig packed uint256 storage slot for `token_`.\n    function getRateConfig(address token_) external view returns (uint256);\n\n    /// @notice gets totalAmounts packed uint256 storage slot for `token_`.\n    function getTotalAmounts(address token_) external view returns (uint256);\n\n    /// @notice gets configs2 packed uint256 storage slot for `token_`.\n    function getConfigs2(address token_) external view returns (uint256);\n\n    /// @notice gets userSupply data packed uint256 storage slot for `user_` and `token_`.\n    function getUserSupply(address user_, address token_) external view returns (uint256);\n\n    /// @notice gets userBorrow data packed uint256 storage slot for `user_` and `token_`.\n    function getUserBorrow(address user_, address token_) external view returns (uint256);\n\n    /// @notice returns all `listedTokens_` at the Liquidity contract. Once configured, a token can never be removed.\n    function listedTokens() external view returns (address[] memory listedTokens_);\n\n    /// @notice get the Rate config data `rateData_` for a `token_` compiled from the packed uint256 rateConfig storage slot\n    function getTokenRateData(address token_) external view returns (LiquidityStructs.RateData memory rateData_);\n\n    /// @notice get the Rate config datas `rateDatas_` for multiple `tokens_` compiled from the packed uint256 rateConfig storage slot\n    function getTokensRateData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.RateData[] memory rateDatas_);\n\n    /// @notice returns general data for `token_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokenData(\n        address token_\n    ) external view returns (LiquidityStructs.OverallTokenData memory overallTokenData_);\n\n    /// @notice returns general data for multiple `tokens_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokensData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns general data for all `listedTokens()` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getAllOverallTokensData()\n        external\n        view\n        returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserSupplyData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData memory userSupplyData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleSupplyData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserBorrowData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData memory userBorrowData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleBorrowData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `supplyTokens_`\n    ///     and returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `borrowTokens_`\n    function getUserMultipleBorrowSupplyData(\n        address user_,\n        address[] calldata supplyTokens_,\n        address[] calldata borrowTokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallSupplyTokensData_,\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallBorrowTokensData_\n        );\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs as AdminModuleStructs } from \"../../../liquidity/adminModule/structs.sol\";\n\nabstract contract Structs {\n    struct RateData {\n        uint256 version;\n        AdminModuleStructs.RateDataV1Params rateDataV1;\n        AdminModuleStructs.RateDataV2Params rateDataV2;\n    }\n\n    struct OverallTokenData {\n        uint256 borrowRate;\n        uint256 supplyRate;\n        uint256 fee; // revenue fee\n        uint256 lastStoredUtilization;\n        uint256 storageUpdateThreshold;\n        uint256 lastUpdateTimestamp;\n        uint256 supplyExchangePrice;\n        uint256 borrowExchangePrice;\n        uint256 supplyRawInterest;\n        uint256 supplyInterestFree;\n        uint256 borrowRawInterest;\n        uint256 borrowInterestFree;\n        uint256 totalSupply;\n        uint256 totalBorrow;\n        uint256 revenue;\n        uint256 maxUtilization; // maximum allowed utilization\n        RateData rateData;\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserSupplyData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 supply; // user supply amount\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\n        uint256 withdrawalLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\n        uint256 baseWithdrawalLimit;\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\n        uint256 withdrawableUntilLimit;\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserBorrowData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 borrow; // user borrow amount\n        uint256 borrowLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseBorrowLimit;\n        uint256 maxBorrowLimit;\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\n    }\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexFactory {\n    /// @notice Global auth is auth for all dexes\n    function isGlobalAuth(address auth_) external view returns (bool);\n\n    /// @notice Dex auth is auth for a specific dex\n    function isDexAuth(address vault_, address auth_) external view returns (bool);\n\n    /// @notice Total dexes deployed.\n    function totalDexes() external view returns (uint256);\n\n    /// @notice Compute dexAddress\n    function getDexAddress(uint256 dexId_) external view returns (address);\n\n    /// @notice read uint256 `result_` for a storage `slot_` key\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexT1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexT1 {\n    error FluidDexError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares);\n\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\n\n    /// @notice returns the dex id\n    function DEX_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndOracle;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) external view returns (CollateralReserves memory c_);\n\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) external view returns (DebtReserves memory d_);\n\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\n    function getPricesAndExchangePrices() external;\n\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) external returns (\n        uint withdrawAmt_\n    );\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) external payable returns (\n        uint paybackAmt_\n    );\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(\n        uint[] memory secondsAgos_\n    ) external view returns (\n        Oracle[] memory twaps_,\n        uint currentPrice_\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}