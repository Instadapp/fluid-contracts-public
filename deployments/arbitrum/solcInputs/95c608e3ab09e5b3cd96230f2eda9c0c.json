{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/bytesSliceAndConcat.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary BytesSliceAndConcat {\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesConcat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    ) internal pure returns (bytes memory tempBytes) {\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesSlice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory tempBytes) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/libraries/dexSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\nlibrary DexSlotsLink {\n    /// @dev storage slot for variables at Dex\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\n    /// @dev storage slot for variables2 at Dex\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\n    /// @dev storage slot for total supply shares at Dex\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\n    /// @dev storage slot for user supply mapping at Dex\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\n    /// @dev storage slot for total borrow shares at Dex\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\n    /// @dev storage slot for user borrow mapping at Dex\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\n    /// @dev storage slot for oracle mapping at Dex\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\n    /// @dev storage slot for range and threshold shifts at Dex\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\n    /// @dev storage slot for center price shift at Dex\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/liquidity/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    /// @notice struct to set borrow rate data for version 1\n    struct RateDataV1Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\n        uint256 kink;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink;\n        ///\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set borrow rate data for version 2\n    struct RateDataV2Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\n        uint256 kink1;\n        ///\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\n        uint256 kink2;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink1;\n        ///\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\n        uint256 rateAtUtilizationKink2;\n        ///\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set token config\n    struct TokenConfig {\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\n        uint256 fee;\n        ///\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\n        uint256 threshold;\n        ///\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\n        uint256 maxUtilization;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/oracle/centerPrices/chainlinkCenterPriceL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidCenterPriceL2 } from \"../fluidCenterPriceL2.sol\";\nimport { ChainlinkOracleImpl } from \"../implementations/chainlinkOracleImpl.sol\";\nimport { IFluidOracle } from \"../interfaces/iFluidOracle.sol\";\n\n/// @title   ChainlinkCenterPriceL2\n/// @notice  Gets the exchange rate between 2 tokens via Chainlink feeds for Layer 2 (with sequencer uptime feed check)\n/// @dev     Also implements IFluidOracle interface\ncontract ChainlinkCenterPriceL2 is FluidCenterPriceL2, IFluidOracle, ChainlinkOracleImpl {\n    /// @notice constructor sets the chainlink feeds config & L2 sequencer uptime feed\n    constructor(\n        string memory infoName_,\n        ChainlinkOracleImpl.ChainlinkConstructorParams memory clParams_,\n        address sequencerUptimeFeed_\n    ) ChainlinkOracleImpl(clParams_) FluidCenterPriceL2(infoName_, sequencerUptimeFeed_) {}\n\n    /// @inheritdoc FluidCenterPriceL2\n    function centerPrice() external view override returns (uint256 price_) {\n        _ensureSequencerUpAndValid();\n        return _getChainlinkExchangeRate();\n    }\n\n    /// @inheritdoc FluidCenterPriceL2\n    function infoName() public view override(IFluidOracle, FluidCenterPriceL2) returns (string memory) {\n        return super.infoName();\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_) {\n        _ensureSequencerUpAndValid();\n        return _getChainlinkExchangeRate();\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() external view virtual returns (uint256 exchangeRate_) {\n        _ensureSequencerUpAndValid();\n        return _getChainlinkExchangeRate();\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() external view virtual returns (uint256 exchangeRate_) {\n        _ensureSequencerUpAndValid();\n        return _getChainlinkExchangeRate();\n    }\n}\n"
    },
    "contracts/oracle/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Error {\n    error FluidOracleError(uint256 errorId_);\n}\n"
    },
    "contracts/oracle/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |           FluidOracleL2           | \n    |__________________________________*/\n\n    /// @notice thrown when sequencer on a L2 has an outage and grace period has not yet passed.\n    uint256 internal constant FluidOracleL2__SequencerOutage = 60000;\n\n    /***********************************|\n    |     UniV3CheckCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the delta between main price source and check rate source is exceeding the allowed delta\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidPrice = 60001;\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidParams = 60002;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant UniV3CheckCLRSOracle__ExchangeRateZero = 60003;\n\n    /***********************************|\n    |           FluidOracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid info name is passed into a fluid oracle (e.g. not set or too long)\n    uint256 internal constant FluidOracle__InvalidInfoName = 60010;\n\n    /***********************************|\n    |            sUSDe Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDeOracle__InvalidParams = 60102;\n\n    /***********************************|\n    |           Pendle Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PendleOracle__InvalidParams = 60201;\n\n    /// @notice thrown when the Pendle market Oracle has not been initialized yet\n    uint256 internal constant PendleOracle__MarketNotInitialized = 60202;\n\n    /// @notice thrown when the Pendle market does not have 18 decimals\n    uint256 internal constant PendleOracle__MarketInvalidDecimals = 60203;\n\n    /// @notice thrown when the Pendle market returns an unexpected price\n    uint256 internal constant PendleOracle__InvalidPrice = 60204;\n\n    /***********************************|\n    |    CLRS2UniV3CheckCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant CLRS2UniV3CheckCLRSOracleL2__ExchangeRateZero = 60301;\n\n    /***********************************|\n    |    Ratio2xFallbackCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant Ratio2xFallbackCLRSOracleL2__ExchangeRateZero = 60311;\n\n    /***********************************|\n    |            WeETHsOracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHsOracle__InvalidParams = 60321;\n\n    /***********************************|\n    |        DexSmartColOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexSmartColOracle__InvalidParams = 60331;\n\n    /// @notice thrown when smart col is not enabled\n    uint256 internal constant DexSmartColOracle__SmartColNotEnabled = 60332;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexSmartColOracle__ExchangeRateZero = 60333;\n\n    /***********************************|\n    |        DexSmartDebtOracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexSmartDebtOracle__InvalidParams = 60341;\n\n    /// @notice thrown when smart debt is not enabled\n    uint256 internal constant DexSmartDebtOracle__SmartDebtNotEnabled = 60342;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexSmartDebtOracle__ExchangeRateZero = 60343;\n\n    /***********************************|\n    |            ContractRate           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant ContractRate__InvalidParams = 60351;\n\n    /// @notice thrown when caller is not authorized\n    uint256 internal constant ContractRate__Unauthorized = 60352;\n\n    /// @notice thrown when minimum diff for triggering update on the stared rate is not reached\n    uint256 internal constant ContractRate__MinUpdateDiffNotReached = 60353;\n\n    /***********************************|\n    |            sUSDs Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDsOracle__InvalidParams = 60361;\n\n    /***********************************|\n    |            Peg Oracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PegOracle__InvalidParams = 60371;\n\n    /***********************************|\n    |              DexOracle            | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexOracle__InvalidParams = 60381;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexOracle__ExchangeRateZero = 60382;\n\n    /***********************************|\n    |          Chainlink Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant ChainlinkOracle__InvalidParams = 61001;\n\n    /***********************************|\n    |          UniswapV3 Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3Oracle__InvalidParams = 62001;\n\n    /// @notice thrown when constructor is called with invalid ordered seconds agos values\n    uint256 internal constant UniV3Oracle__InvalidSecondsAgos = 62002;\n\n    /// @notice thrown when constructor is called with invalid delta values > 100%\n    uint256 internal constant UniV3Oracle__InvalidDeltas = 62003;\n\n    /***********************************|\n    |            WstETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WstETHOracle__InvalidParams = 63001;\n\n    /***********************************|\n    |           Redstone Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant RedstoneOracle__InvalidParams = 64001;\n\n    /***********************************|\n    |          Fallback Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant FallbackOracle__InvalidParams = 65001;\n\n    /***********************************|\n    |       FallbackCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant FallbackCLRSOracle__ExchangeRateZero = 66001;\n\n    /***********************************|\n    |         WstETHCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant WstETHCLRSOracle__ExchangeRateZero = 67001;\n\n    /***********************************|\n    |        CLFallbackUniV3Oracle      | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant CLFallbackUniV3Oracle__ExchangeRateZero = 68001;\n\n    /***********************************|\n    |  WstETHCLRS2UniV3CheckCLRSOracle  | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant WstETHCLRS2UniV3CheckCLRSOracle__ExchangeRateZero = 69001;\n\n    /***********************************|\n    |             WeETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHOracle__InvalidParams = 70001;\n}\n"
    },
    "contracts/oracle/fluidCenterPriceL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidCenterPrice } from \"./interfaces/iFluidCenterPrice.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { Error as OracleError } from \"./error.sol\";\nimport { IChainlinkAggregatorV3 } from \"./interfaces/external/IChainlinkAggregatorV3.sol\";\n\n/// @title   FluidCenterPriceL2\n/// @notice  Base contract that any Fluid Center Price L2 must implement\nabstract contract FluidCenterPriceL2 is IFluidCenterPrice, OracleError {\n    /// @dev short helper string to easily identify the center price oracle. E.g. token symbols\n    //\n    // using a bytes32 because string can not be immutable.\n    bytes32 private immutable _infoName;\n\n    /// @dev Chainlink L2 Sequencer Uptime feed to detect sequencer outages\n    IChainlinkAggregatorV3 internal _SEQUENCER_ORACLE;\n    /// @dev max time period until oracle assumes normal behavior after a sequencer outage.\n    uint256 internal constant _SEQUENCER_MAX_GRACE_PERIOD = 45 minutes;\n\n    constructor(string memory infoName_, address sequencerUptimeFeed_) {\n        if (bytes(infoName_).length > 32 || bytes(infoName_).length == 0) {\n            revert FluidOracleError(ErrorTypes.FluidOracle__InvalidInfoName);\n        }\n\n        // convert string to bytes32\n        bytes32 infoNameBytes32_;\n        assembly {\n            infoNameBytes32_ := mload(add(infoName_, 32))\n        }\n        _infoName = infoNameBytes32_;\n\n        _SEQUENCER_ORACLE = IChainlinkAggregatorV3(sequencerUptimeFeed_);\n    }\n\n    /// @notice returns all sequencer uptime feed related data\n    function sequencerL2Data()\n        public\n        view\n        returns (\n            address sequencerUptimeFeed_,\n            uint256 maxGracePeriod_,\n            bool isSequencerUp_,\n            uint256 lastUptimeStartedAt_,\n            uint256 gracePeriod_,\n            bool gracePeriodPassed_,\n            uint256 lastOutageStartedAt_,\n            bool isSequencerUpAndValid_\n        )\n    {\n        uint80 uptimeStartRoundId_;\n        (isSequencerUp_, uptimeStartRoundId_, lastUptimeStartedAt_) = _sequencerUpStatus();\n\n        if (isSequencerUp_) {\n            (gracePeriod_, gracePeriodPassed_, lastOutageStartedAt_) = _gracePeriod(\n                uptimeStartRoundId_,\n                lastUptimeStartedAt_\n            );\n        } else {\n            gracePeriod_ = _SEQUENCER_MAX_GRACE_PERIOD;\n            (uint80 roundId_, , , , ) = _SEQUENCER_ORACLE.latestRoundData();\n            lastOutageStartedAt_ = _lastSequencerOutageStart(roundId_ + 1);\n        }\n\n        return (\n            address(_SEQUENCER_ORACLE),\n            _SEQUENCER_MAX_GRACE_PERIOD,\n            isSequencerUp_,\n            lastUptimeStartedAt_,\n            gracePeriod_,\n            gracePeriodPassed_,\n            lastOutageStartedAt_,\n            isSequencerUp_ && gracePeriodPassed_\n        );\n    }\n\n    /// @dev ensures that the sequencer is up and grace period has passed\n    function _ensureSequencerUpAndValid() internal view {\n        (bool isSequencerUp_, uint80 uptimeStartRoundId_, uint256 uptimeStartedAt_) = _sequencerUpStatus();\n\n        if (!isSequencerUp_) {\n            revert FluidOracleError(ErrorTypes.FluidOracleL2__SequencerOutage);\n        }\n\n        (, bool gracePeriodPassed_, ) = _gracePeriod(uptimeStartRoundId_, uptimeStartedAt_);\n        if (!gracePeriodPassed_) {\n            revert FluidOracleError(ErrorTypes.FluidOracleL2__SequencerOutage);\n        }\n    }\n\n    /// @inheritdoc IFluidCenterPrice\n    function infoName() public view virtual returns (string memory) {\n        // convert bytes32 to string\n        uint256 length_;\n        while (length_ < 32 && _infoName[length_] != 0) {\n            length_++;\n        }\n        bytes memory infoNameBytes_ = new bytes(length_);\n        for (uint256 i; i < length_; i++) {\n            infoNameBytes_[i] = _infoName[i];\n        }\n        return string(infoNameBytes_);\n    }\n\n    /// @inheritdoc IFluidCenterPrice\n    function centerPrice() external virtual returns (uint256 price_);\n\n    /// @dev finds last round before `uptimeStartRoundId_` where sequencer status was down, incl. handling cases of\n    /// consecutive rounds where status was down.\n    function _lastSequencerOutageStart(uint80 uptimeStartRoundId_) private view returns (uint256 outageStartedAt_) {\n        uint80 roundId_ = uptimeStartRoundId_;\n        int256 answer_;\n        uint256 startedAt_;\n        do {\n            (roundId_, answer_, startedAt_, , ) = _SEQUENCER_ORACLE.getRoundData(roundId_ - 1);\n            if (answer_ != 0) {\n                // sequencer was down at this round, update outage started at data\n                outageStartedAt_ = startedAt_;\n            } // else: while loop is going to break\n        } while (answer_ != 0 && startedAt_ > 0);\n    }\n\n    /// @dev finds last round where sequencer status was up, incl. handling cases of consecutive rounds where status was up.\n    function _sequencerUpStatus()\n        private\n        view\n        returns (bool isSequencerUp_, uint80 uptimeStartRoundId_, uint256 uptimeStartedAt_)\n    {\n        (uint80 roundId_, int256 answer_, uint256 startedAt_, , ) = _SEQUENCER_ORACLE.latestRoundData();\n        if (answer_ != 0) {\n            // sequencer is down currently.\n            return (false, 0, 0);\n        }\n\n        isSequencerUp_ = true;\n\n        // cover case where there were other consecutive uptime report rounds in between\n        uptimeStartRoundId_ = roundId_;\n        uptimeStartedAt_ = startedAt_;\n        if (uptimeStartedAt_ > 0) {\n            do {\n                (roundId_, answer_, startedAt_, , ) = _SEQUENCER_ORACLE.getRoundData(roundId_ - 1);\n                if (answer_ == 0) {\n                    // sequencer was up at this round, consecutive uptime so update uptime start data\n                    uptimeStartRoundId_ = roundId_;\n                    uptimeStartedAt_ = startedAt_;\n                } // else: while loop is going to break\n            } while (answer_ == 0 && startedAt_ > 0);\n        } // else if startedAt == 0, then it is the first ever round.\n    }\n\n    /// @dev returns the `gracePeriod_` duration and if the grace period has `passed_` based on\n    /// current uptime round data vs the last sequencer outage duration.\n    function _gracePeriod(\n        uint80 uptimeStartRoundId_,\n        uint256 uptimeStartedAt_\n    ) private view returns (uint256 gracePeriod_, bool passed_, uint256 outageStartedAt_) {\n        uint256 uptimeDuration_ = block.timestamp - uptimeStartedAt_;\n        if (uptimeStartedAt_ == 0 || uptimeDuration_ > _SEQUENCER_MAX_GRACE_PERIOD) {\n            return (_SEQUENCER_MAX_GRACE_PERIOD, true, 0);\n        }\n\n        outageStartedAt_ = _lastSequencerOutageStart(uptimeStartRoundId_);\n\n        // grace period is outage duration, capped at _SEQUENCER_MAX_GRACE_PERIOD\n        gracePeriod_ = uptimeStartedAt_ - outageStartedAt_; // outage duration\n        if (gracePeriod_ > _SEQUENCER_MAX_GRACE_PERIOD) {\n            gracePeriod_ = _SEQUENCER_MAX_GRACE_PERIOD;\n        }\n\n        return (gracePeriod_, uptimeDuration_ > gracePeriod_, outageStartedAt_);\n    }\n}\n"
    },
    "contracts/oracle/implementations/chainlinkOracleImpl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { IChainlinkAggregatorV3 } from \"../interfaces/external/IChainlinkAggregatorV3.sol\";\nimport { Error as OracleError } from \"../error.sol\";\nimport { OracleUtils } from \"../libraries/oracleUtils.sol\";\nimport { ChainlinkStructs } from \"./structs.sol\";\n\n/// @title   Chainlink Oracle implementation\n/// @notice  This contract is used to get the exchange rate via up to 3 hops at Chainlink price feeds.\n///          The rate is multiplied with the previous rate at each hop.\n///          E.g. to go from wBTC to USDC (assuming rates for example):\n///          1. wBTC -> BTC https://data.chain.link/ethereum/mainnet/crypto-other/wbtc-btc, rate: 0.92.\n///          2. BTC -> USD https://data.chain.link/ethereum/mainnet/crypto-usd/btc-usd rate: 30,000.\n///          3. USD -> USDC https://data.chain.link/ethereum/mainnet/stablecoins/usdc-usd rate: 0.98. Must invert feed: 1.02\n///          finale rate would be: 0.92 * 30,000 * 1.02 = 28,152\nabstract contract ChainlinkOracleImpl is OracleError, ChainlinkStructs {\n    /// @notice Chainlink price feed 1 to check for the exchange rate\n    IChainlinkAggregatorV3 internal immutable _CHAINLINK_FEED1;\n    /// @notice Chainlink price feed 2 to check for the exchange rate\n    IChainlinkAggregatorV3 internal immutable _CHAINLINK_FEED2;\n    /// @notice Chainlink price feed 3 to check for the exchange rate\n    IChainlinkAggregatorV3 internal immutable _CHAINLINK_FEED3;\n\n    /// @notice Flag to invert the price or not for feed 1 (to e.g. for WETH/USDC pool return prive of USDC per 1 WETH)\n    bool internal immutable _CHAINLINK_INVERT_RATE1;\n    /// @notice Flag to invert the price or not for feed 2 (to e.g. for WETH/USDC pool return prive of USDC per 1 WETH)\n    bool internal immutable _CHAINLINK_INVERT_RATE2;\n    /// @notice Flag to invert the price or not for feed 3 (to e.g. for WETH/USDC pool return prive of USDC per 1 WETH)\n    bool internal immutable _CHAINLINK_INVERT_RATE3;\n\n    /// @notice constant value for price scaling to reduce gas usage for feed 1\n    uint256 internal immutable _CHAINLINK_PRICE_SCALER_MULTIPLIER1;\n    /// @notice constant value for inverting price to reduce gas usage for feed 1\n    uint256 internal immutable _CHAINLINK_INVERT_PRICE_DIVIDEND1;\n\n    /// @notice constant value for price scaling to reduce gas usage for feed 2\n    uint256 internal immutable _CHAINLINK_PRICE_SCALER_MULTIPLIER2;\n    /// @notice constant value for inverting price to reduce gas usage for feed 2\n    uint256 internal immutable _CHAINLINK_INVERT_PRICE_DIVIDEND2;\n\n    /// @notice constant value for price scaling to reduce gas usage for feed 3\n    uint256 internal immutable _CHAINLINK_PRICE_SCALER_MULTIPLIER3;\n    /// @notice constant value for inverting price to reduce gas usage for feed 3\n    uint256 internal immutable _CHAINLINK_INVERT_PRICE_DIVIDEND3;\n\n    /// @notice constructor sets the Chainlink price feed and invertRate flag for each hop.\n    /// E.g. `invertRate_` should be true if for the USDC/ETH pool it's expected that the oracle returns USDC per 1 ETH\n    constructor(ChainlinkConstructorParams memory params_) {\n        if (\n            (params_.hops < 1 || params_.hops > 3) || // hops must be 1, 2 or 3\n            (address(params_.feed1.feed) == address(0) || params_.feed1.token0Decimals == 0) || // first feed must always be defined\n            (params_.hops > 1 && (address(params_.feed2.feed) == address(0) || params_.feed2.token0Decimals == 0)) || // if hops > 1, feed 2 must be defined\n            (params_.hops > 2 && (address(params_.feed3.feed) == address(0) || params_.feed3.token0Decimals == 0)) // if hops > 2, feed 3 must be defined\n        ) {\n            revert FluidOracleError(ErrorTypes.ChainlinkOracle__InvalidParams);\n        }\n\n        _CHAINLINK_FEED1 = params_.feed1.feed;\n        _CHAINLINK_FEED2 = params_.feed2.feed;\n        _CHAINLINK_FEED3 = params_.feed3.feed;\n\n        _CHAINLINK_INVERT_RATE1 = params_.feed1.invertRate;\n        _CHAINLINK_INVERT_RATE2 = params_.feed2.invertRate;\n        _CHAINLINK_INVERT_RATE3 = params_.feed3.invertRate;\n\n        // Actual desired output rate example USDC/ETH (6 decimals / 18 decimals).\n        // Note ETH has 12 decimals more than USDC.\n        //    0.000515525322211842331991619857165357691 // 39 decimals.  ETH for 1 USDC\n        // 1954.190000000000433             // 15 decimals. USDC for 1 ETH\n\n        // to get to PRICE_SCLAER_MULTIPLIER and INVERT_PRICE_DIVIDEND:\n        // fetched Chainlink price is in token1Decimals per 1 token0Decimals.\n        // E.g. for an USDC/ETH price feed it's in ETH 18 decimals.\n        //      for an  BTC/USD price feed it's in USD  8 decimals.\n        // So to scale to 1e27 we need to multiply by 1e27 - token0Decimals.\n        // E.g. for USDC/ETH it would be: fetchedPrice * 1e21\n        //\n        // or for inverted (x token0 per 1 token1), formula would be:\n        //    = 1e27 * 10**token0Decimals / fetchedPrice\n        // E.g. for USDC/ETH it would be: 1e33 / fetchedPrice\n\n        // no support for token1Decimals with more than OracleUtils.RATE_OUTPUT_DECIMALS decimals for now as extremely unlikely case\n        _CHAINLINK_PRICE_SCALER_MULTIPLIER1 = 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS - params_.feed1.token0Decimals);\n        _CHAINLINK_INVERT_PRICE_DIVIDEND1 = 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS + params_.feed1.token0Decimals);\n\n        _CHAINLINK_PRICE_SCALER_MULTIPLIER2 = params_.hops > 1\n            ? 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS - params_.feed2.token0Decimals)\n            : 1;\n        _CHAINLINK_INVERT_PRICE_DIVIDEND2 = params_.hops > 1\n            ? 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS + params_.feed2.token0Decimals)\n            : 1;\n\n        _CHAINLINK_PRICE_SCALER_MULTIPLIER3 = params_.hops > 2\n            ? 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS - params_.feed3.token0Decimals)\n            : 1;\n        _CHAINLINK_INVERT_PRICE_DIVIDEND3 = params_.hops > 2\n            ? 10 ** (OracleUtils.RATE_OUTPUT_DECIMALS + params_.feed3.token0Decimals)\n            : 1;\n    }\n\n    /// @dev            Get the exchange rate from Chainlike oracle price feed(s)\n    /// @return rate_   The exchange rate in `OracleUtils.RATE_OUTPUT_DECIMALS`\n    function _getChainlinkExchangeRate() internal view returns (uint256 rate_) {\n        rate_ = _readFeedRate(\n            _CHAINLINK_FEED1,\n            _CHAINLINK_INVERT_RATE1,\n            _CHAINLINK_PRICE_SCALER_MULTIPLIER1,\n            _CHAINLINK_INVERT_PRICE_DIVIDEND1\n        );\n        if (rate_ == 0 || address(_CHAINLINK_FEED2) == address(0)) {\n            // rate 0 or only 1 hop -> return rate of price feed 1\n            return rate_;\n        }\n        rate_ =\n            (rate_ *\n                _readFeedRate(\n                    _CHAINLINK_FEED2,\n                    _CHAINLINK_INVERT_RATE2,\n                    _CHAINLINK_PRICE_SCALER_MULTIPLIER2,\n                    _CHAINLINK_INVERT_PRICE_DIVIDEND2\n                )) /\n            (10 ** OracleUtils.RATE_OUTPUT_DECIMALS);\n\n        if (rate_ == 0 || address(_CHAINLINK_FEED3) == address(0)) {\n            // rate 0 or 2 hops -> return rate of feed 1 combined with feed 2\n            return rate_;\n        }\n\n        // 3 hops -> return rate of feed 1 combined with feed 2 & feed 3\n        rate_ =\n            (rate_ *\n                _readFeedRate(\n                    _CHAINLINK_FEED3,\n                    _CHAINLINK_INVERT_RATE3,\n                    _CHAINLINK_PRICE_SCALER_MULTIPLIER3,\n                    _CHAINLINK_INVERT_PRICE_DIVIDEND3\n                )) /\n            (10 ** OracleUtils.RATE_OUTPUT_DECIMALS);\n    }\n\n    /// @dev reads the exchange `rate_` from a Chainlink price `feed_` taking into account scaling and `invertRate_`\n    function _readFeedRate(\n        IChainlinkAggregatorV3 feed_,\n        bool invertRate_,\n        uint256 priceMultiplier_,\n        uint256 invertDividend_\n    ) private view returns (uint256 rate_) {\n        try feed_.latestRoundData() returns (uint80, int256 exchangeRate_, uint256, uint256, uint80) {\n            // Return the price in `OracleUtils.RATE_OUTPUT_DECIMALS`\n            if (invertRate_) {\n                return invertDividend_ / uint256(exchangeRate_);\n            } else {\n                return uint256(exchangeRate_) * priceMultiplier_;\n            }\n        } catch {\n            return 0;\n        }\n    }\n\n    /// @notice returns all Chainlink oracle related data as utility for easy off-chain use / block explorer in a single view method\n    function chainlinkOracleData()\n        public\n        view\n        returns (\n            uint256 chainlinkExchangeRate_,\n            IChainlinkAggregatorV3 chainlinkFeed1_,\n            bool chainlinkInvertRate1_,\n            uint256 chainlinkExchangeRate1_,\n            IChainlinkAggregatorV3 chainlinkFeed2_,\n            bool chainlinkInvertRate2_,\n            uint256 chainlinkExchangeRate2_,\n            IChainlinkAggregatorV3 chainlinkFeed3_,\n            bool chainlinkInvertRate3_,\n            uint256 chainlinkExchangeRate3_\n        )\n    {\n        return (\n            _getChainlinkExchangeRate(),\n            _CHAINLINK_FEED1,\n            _CHAINLINK_INVERT_RATE1,\n            _readFeedRate(\n                _CHAINLINK_FEED1,\n                _CHAINLINK_INVERT_RATE1,\n                _CHAINLINK_PRICE_SCALER_MULTIPLIER1,\n                _CHAINLINK_INVERT_PRICE_DIVIDEND1\n            ),\n            _CHAINLINK_FEED2,\n            _CHAINLINK_INVERT_RATE2,\n            address(_CHAINLINK_FEED2) == address(0)\n                ? 0\n                : _readFeedRate(\n                    _CHAINLINK_FEED2,\n                    _CHAINLINK_INVERT_RATE2,\n                    _CHAINLINK_PRICE_SCALER_MULTIPLIER2,\n                    _CHAINLINK_INVERT_PRICE_DIVIDEND2\n                ),\n            _CHAINLINK_FEED3,\n            _CHAINLINK_INVERT_RATE3,\n            address(_CHAINLINK_FEED3) == address(0)\n                ? 0\n                : _readFeedRate(\n                    _CHAINLINK_FEED3,\n                    _CHAINLINK_INVERT_RATE3,\n                    _CHAINLINK_PRICE_SCALER_MULTIPLIER3,\n                    _CHAINLINK_INVERT_PRICE_DIVIDEND3\n                )\n        );\n    }\n}\n"
    },
    "contracts/oracle/implementations/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IChainlinkAggregatorV3 } from \"../interfaces/external/IChainlinkAggregatorV3.sol\";\nimport { IRedstoneOracle } from \"../interfaces/external/IRedstoneOracle.sol\";\n\nabstract contract ChainlinkStructs {\n    struct ChainlinkFeedData {\n        /// @param feed           address of Chainlink feed.\n        IChainlinkAggregatorV3 feed;\n        /// @param invertRate     true if rate read from price feed must be inverted.\n        bool invertRate;\n        /// @param token0Decimals decimals of asset 0. E.g. for a USDC/ETH feed, USDC is token0 and has 6 decimals.\n        ///                       (token1Decimals are available directly via Chainlink `FEED.decimals()`)\n        uint256 token0Decimals;\n    }\n\n    struct ChainlinkConstructorParams {\n        /// @param param        hops count of hops, used for sanity checks. Must be 1, 2 or 3.\n        uint8 hops;\n        /// @param feed1        Chainlink feed 1 data. Required.\n        ChainlinkFeedData feed1;\n        /// @param feed2        Chainlink feed 2 data. Required if hops > 1.\n        ChainlinkFeedData feed2;\n        /// @param feed3        Chainlink feed 3 data. Required if hops > 2.\n        ChainlinkFeedData feed3;\n    }\n}\n\nabstract contract RedstoneStructs {\n    struct RedstoneOracleData {\n        /// @param oracle         address of Redstone oracle.\n        IRedstoneOracle oracle;\n        /// @param invertRate     true if rate read from price feed must be inverted.\n        bool invertRate;\n        /// @param token0Decimals decimals of asset 0. E.g. for a USDC/ETH feed, USDC is token0 and has 6 decimals.\n        ///                       (token1Decimals are available directly via Redstone `Oracle.decimals()`)\n        uint256 token0Decimals;\n    }\n}\n"
    },
    "contracts/oracle/interfaces/external/IChainlinkAggregatorV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// from https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\n/// Copyright (c) 2018 SmartContract ChainLink, Ltd.\n\ninterface IChainlinkAggregatorV3 {\n    /// @notice represents the number of decimals the aggregator responses represent.\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/oracle/interfaces/external/IRedstoneOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IRedstoneOracle {\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset\n    // @dev custom Redstone adapter for Instadapp implementation\n    function getExchangeRate() external view returns (uint256 exchangeRate_);\n\n    /**\n     * @notice Returns the number of decimals for the price feed\n     * @dev By default, RedStone uses 8 decimals for data feeds\n     * @return decimals The number of decimals in the price feed values\n     */\n    // see https://github.com/redstone-finance/redstone-oracles-monorepo/blob/main/packages/on-chain-relayer/contracts/price-feeds/PriceFeedBase.sol#L51C12-L51C20\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/oracle/interfaces/iFluidCenterPrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidCenterPrice {\n    /// @notice Retrieves the center price for the pool\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\n    /// @return price_ The current price ratio of token1 to token0, expressed with 27 decimal places\n    function centerPrice() external returns (uint256 price_);\n\n    /// @notice helper string to easily identify the oracle. E.g. token symbols\n    function infoName() external view returns (string memory);\n}\n"
    },
    "contracts/oracle/interfaces/iFluidOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidOracle {\n    /// @dev Deprecated. Use `getExchangeRateOperate()` and `getExchangeRateLiquidate()` instead. Only implemented for\n    ///      backwards compatibility.\n    function getExchangeRate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for operates\n    function getExchangeRateOperate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for liquidations\n    function getExchangeRateLiquidate() external view returns (uint256 exchangeRate_);\n\n    /// @notice helper string to easily identify the oracle. E.g. token symbols\n    function infoName() external view returns (string memory);\n}\n"
    },
    "contracts/oracle/libraries/oracleUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title Oracle utils library\n/// @notice implements common utility methods for Fluid Oracles\nlibrary OracleUtils {\n    /// @dev The scaler for max delta point math (100%)\n    uint256 internal constant HUNDRED_PERCENT_DELTA_SCALER = 10_000;\n    /// @dev output precision of rates\n    uint256 internal constant RATE_OUTPUT_DECIMALS = 27;\n\n    /// @dev checks if `mainSourceRate_` is within a `maxDeltaPercent_` of `checkSourceRate_`. Returns true if so.\n    function isRateOutsideDelta(\n        uint256 mainSourceRate_,\n        uint256 checkSourceRate_,\n        uint256 maxDeltaPercent_\n    ) internal pure returns (bool) {\n        uint256 offset_ = (checkSourceRate_ * maxDeltaPercent_) / HUNDRED_PERCENT_DELTA_SCALER;\n        return (mainSourceRate_ > (checkSourceRate_ + offset_) || mainSourceRate_ < (checkSourceRate_ - offset_));\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexReserves/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { DexSlotsLink } from \"../../../libraries/dexSlotsLink.sol\";\nimport { BytesSliceAndConcat } from \"../../../libraries/bytesSliceAndConcat.sol\";\nimport { Structs as FluidLiquidityResolverStructs } from \"../liquidity/structs.sol\";\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { Variables } from \"./variables.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\ninterface TokenInterface {\n    function balanceOf(address) external view returns (uint);\n}\n\n/// @title DexFactoryViews\n/// @notice Abstract contract providing view functions for DEX factory-related operations\nabstract contract DexFactoryViews is Variables {\n    /// @notice Get the address of a Pool given its ID\n    /// @param poolId_ The ID of the Pool\n    /// @return pool_ The address of the Pool\n    function getPoolAddress(uint256 poolId_) public view returns (address pool_) {\n        return AddressCalcs.addressCalc(address(FACTORY), poolId_);\n    }\n\n    /// @notice Get the total number of Pools\n    /// @return The total number of Pools\n    function getTotalPools() public view returns (uint) {\n        return FACTORY.totalDexes();\n    }\n\n    /// @notice Get an array of all Pool addresses\n    /// @return pools_ An array containing all Pool addresses\n    function getAllPoolAddresses() public view returns (address[] memory pools_) {\n        uint totalPools_ = getTotalPools();\n        pools_ = new address[](totalPools_);\n        for (uint i = 0; i < totalPools_; i++) {\n            pools_[i] = getPoolAddress((i + 1));\n        }\n    }\n}\n\n/// @title DexPublicViews\n/// @notice Abstract contract providing view functions for DEX public data\nabstract contract DexPublicViews {\n    /// @notice Get the prices and exchange prices for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return pex_ A struct containing prices and exchange prices\n    /// @dev expected to be called via callStatic\n    function getDexPricesAndExchangePrices(\n        address dex_\n    ) public returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n        try IFluidDexT1(dex_).getPricesAndExchangePrices() {} catch (bytes memory lowLevelData_) {\n            bytes4 errorSelector_;\n            assembly {\n                // Extract the selector from the error data\n                errorSelector_ := mload(add(lowLevelData_, 0x20))\n            }\n            if (errorSelector_ == IFluidDexT1.FluidDexPricesAndExchangeRates.selector) {\n                pex_ = abi.decode(\n                    BytesSliceAndConcat.bytesSlice(lowLevelData_, 4, lowLevelData_.length - 4),\n                    (IFluidDexT1.PricesAndExchangePrice)\n                );\n            }\n        }\n    }\n\n    /// @notice Get the collateral reserves for a DEX in token decimals amounts\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing collateral reserve information\n    /// @dev expected to be called via callStatic\n    function getDexCollateralReserves(address dex_) public returns (IFluidDexT1.CollateralReserves memory reserves_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        if ((dexVariables2_ & 1) != 1) {\n            // smart col not enabled\n            return IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            reserves_ = _getDexCollateralReserves(dex_, pex_);\n        } catch {\n            reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n    }\n\n    /// @notice Get the collateral reserves for a DEX scaled to 1e12\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing collateral reserve information\n    /// @dev expected to be called via callStatic\n    function getDexCollateralReservesAdjusted(\n        address dex_\n    ) public returns (IFluidDexT1.CollateralReserves memory reserves_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        if ((dexVariables2_ & 1) != 1) {\n            // smart col not enabled\n            return IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            reserves_ = _getDexCollateralReservesAdjusted(dex_, pex_);\n        } catch {\n            reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n    }\n\n    /// @notice Get the debt reserves for a DEX in token decimals amounts\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing debt reserve information\n    /// @dev expected to be called via callStatic\n    function getDexDebtReserves(address dex_) public returns (IFluidDexT1.DebtReserves memory reserves_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        if ((dexVariables2_ & 2) != 2) {\n            // smart debt not enabled\n            return IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            reserves_ = _getDexDebtReserves(dex_, pex_);\n        } catch {\n            reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n    }\n\n    /// @notice Get the debt reserves for a DEX scaled to 1e12\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing debt reserve information\n    /// @dev expected to be called via callStatic\n    function getDexDebtReservesAdjusted(address dex_) public returns (IFluidDexT1.DebtReserves memory reserves_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        if ((dexVariables2_ & 2) != 2) {\n            // smart debt not enabled\n            return IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            reserves_ = _getDexDebtReservesAdjusted(dex_, pex_);\n        } catch {\n            reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n    }\n\n    /// @dev Retrieves and normalizes the collateral reserves for a given DEX.\n    /// @param dex_ The address of the DEX.\n    /// @param pex_ A struct containing price and exchange price information.\n    /// @return reserves_ A struct containing the normalized collateral reserves.\n    function _getDexCollateralReserves(\n        address dex_,\n        IFluidDexT1.PricesAndExchangePrice memory pex_\n    ) internal view returns (IFluidDexT1.CollateralReserves memory reserves_) {\n        reserves_ = _getDexCollateralReservesAdjusted(dex_, pex_);\n\n        IFluidDexT1.ConstantViews2 memory constantsView2_ = IFluidDexT1(dex_).constantsView2();\n\n        // returned reserves are in 1e12 decimals -> normalize to token decimals\n        reserves_.token0RealReserves =\n            (reserves_.token0RealReserves * constantsView2_.token0DenominatorPrecision) /\n            constantsView2_.token0NumeratorPrecision;\n        reserves_.token0ImaginaryReserves =\n            (reserves_.token0ImaginaryReserves * constantsView2_.token0DenominatorPrecision) /\n            constantsView2_.token0NumeratorPrecision;\n        reserves_.token1RealReserves =\n            (reserves_.token1RealReserves * constantsView2_.token1DenominatorPrecision) /\n            constantsView2_.token1NumeratorPrecision;\n        reserves_.token1ImaginaryReserves =\n            (reserves_.token1ImaginaryReserves * constantsView2_.token1DenominatorPrecision) /\n            constantsView2_.token1NumeratorPrecision;\n    }\n\n    /// @dev Retrieves the adjusted collateral reserves for a given DEX.\n    /// @param dex_ The address of the DEX.\n    /// @param pex_ A struct containing price and exchange price information.\n    /// @return reserves_ A struct containing the adjusted collateral reserves.\n    function _getDexCollateralReservesAdjusted(\n        address dex_,\n        IFluidDexT1.PricesAndExchangePrice memory pex_\n    ) internal view returns (IFluidDexT1.CollateralReserves memory reserves_) {\n        try\n            IFluidDexT1(dex_).getCollateralReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.supplyToken0ExchangePrice,\n                pex_.supplyToken1ExchangePrice\n            )\n        returns (IFluidDexT1.CollateralReserves memory colReserves_) {\n            // returned reserves are in 1e12 decimals -> normalize to token decimals\n            reserves_ = colReserves_;\n        } catch {\n            reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n    }\n\n    /// @dev Retrieves and normalizes the debt reserves for a given DEX.\n    /// @param dex_ The address of the DEX.\n    /// @param pex_ A struct containing price and exchange price information.\n    /// @return reserves_ A struct containing the normalized debt reserves.\n    function _getDexDebtReserves(\n        address dex_,\n        IFluidDexT1.PricesAndExchangePrice memory pex_\n    ) internal view returns (IFluidDexT1.DebtReserves memory reserves_) {\n        reserves_ = _getDexDebtReservesAdjusted(dex_, pex_);\n\n        IFluidDexT1.ConstantViews2 memory constantsView2_ = IFluidDexT1(dex_).constantsView2();\n\n        // returned reserves are in 1e12 decimals -> normalize to token decimals\n        reserves_.token0Debt =\n            (reserves_.token0Debt * constantsView2_.token0DenominatorPrecision) /\n            constantsView2_.token0NumeratorPrecision;\n        reserves_.token0RealReserves =\n            (reserves_.token0RealReserves * constantsView2_.token0DenominatorPrecision) /\n            constantsView2_.token0NumeratorPrecision;\n        reserves_.token0ImaginaryReserves =\n            (reserves_.token0ImaginaryReserves * constantsView2_.token0DenominatorPrecision) /\n            constantsView2_.token0NumeratorPrecision;\n        reserves_.token1Debt =\n            (reserves_.token1Debt * constantsView2_.token1DenominatorPrecision) /\n            constantsView2_.token1NumeratorPrecision;\n        reserves_.token1RealReserves =\n            (reserves_.token1RealReserves * constantsView2_.token1DenominatorPrecision) /\n            constantsView2_.token1NumeratorPrecision;\n        reserves_.token1ImaginaryReserves =\n            (reserves_.token1ImaginaryReserves * constantsView2_.token1DenominatorPrecision) /\n            constantsView2_.token1NumeratorPrecision;\n    }\n\n    /// @dev Retrieves the adjusted debt reserves for a given DEX.\n    /// @param dex_ The address of the DEX.\n    /// @param pex_ A struct containing price and exchange price information.\n    /// @return reserves_ A struct containing the adjusted debt reserves.\n    function _getDexDebtReservesAdjusted(\n        address dex_,\n        IFluidDexT1.PricesAndExchangePrice memory pex_\n    ) internal view returns (IFluidDexT1.DebtReserves memory reserves_) {\n        try\n            IFluidDexT1(dex_).getDebtReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.borrowToken0ExchangePrice,\n                pex_.borrowToken1ExchangePrice\n            )\n        returns (IFluidDexT1.DebtReserves memory debtReserves_) {\n            // returned reserves are in 1e12 decimals -> normalize to token decimals\n            reserves_ = debtReserves_;\n        } catch {\n            reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n    }\n}\n\n/// @title DexConstantsViews\n/// @notice Abstract contract providing view functions for DEX constants\nabstract contract DexConstantsViews {\n    /// @notice returns all Pool constants\n    function getPoolConstantsView(address pool_) public view returns (IFluidDexT1.ConstantViews memory constantsView_) {\n        return IFluidDexT1(pool_).constantsView();\n    }\n\n    /// @notice returns all Pool constants 2\n    function getPoolConstantsView2(\n        address pool_\n    ) public view returns (IFluidDexT1.ConstantViews2 memory constantsView2_) {\n        return IFluidDexT1(pool_).constantsView2();\n    }\n\n    /// @notice Get the addresses of the tokens in a Pool\n    /// @param pool_ The address of the Pool\n    /// @return token0_ The address of token0 in the Pool\n    /// @return token1_ The address of token1 in the Pool\n    function getPoolTokens(address pool_) public view returns (address token0_, address token1_) {\n        IFluidDexT1.ConstantViews memory constantsView_ = IFluidDexT1(pool_).constantsView();\n        return (constantsView_.token0, constantsView_.token1);\n    }\n}\n\nabstract contract DexSwapLimits is Variables, Structs, DexConstantsViews {\n    /// @notice get the swap limits for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return limits_ A struct containing the swap limits for the DEX\n    function getDexLimits(address dex_) public view returns (DexLimits memory limits_) {\n        // additional liquidity related data such as supply amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserSupplyData memory liquidityUserSupplyDataToken0_;\n        FluidLiquidityResolverStructs.UserSupplyData memory liquidityUserSupplyDataToken1_;\n        // liquidity token related data\n        FluidLiquidityResolverStructs.OverallTokenData memory liquidityTokenData0_;\n        FluidLiquidityResolverStructs.OverallTokenData memory liquidityTokenData1_;\n        // additional liquidity related data such as borrow amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserBorrowData memory liquidityUserBorrowDataToken0_;\n        FluidLiquidityResolverStructs.UserBorrowData memory liquidityUserBorrowDataToken1_;\n\n        {\n            (address token0_, address token1_) = getPoolTokens(dex_);\n            (liquidityUserSupplyDataToken0_, liquidityTokenData0_) = LIQUIDITY_RESOLVER.getUserSupplyData(\n                dex_,\n                token0_\n            );\n            (liquidityUserSupplyDataToken1_, liquidityTokenData1_) = LIQUIDITY_RESOLVER.getUserSupplyData(\n                dex_,\n                token1_\n            );\n            (liquidityUserBorrowDataToken0_, ) = LIQUIDITY_RESOLVER.getUserBorrowData(dex_, token0_);\n            (liquidityUserBorrowDataToken1_, ) = LIQUIDITY_RESOLVER.getUserBorrowData(dex_, token1_);\n\n            // ----------------------- 1. UTILIZATION LIMITS (include liquidity layer balances) -----------------------\n            // for dex, utilization limit check is not just after borrow but also after withdraw (after any swap).\n            // for liquidity, utilization limit check is only after borrow.\n            // so for borrow, use utilization config of either liquidity or dex, whatever is smaller. for withdraw, use dex.\n\n            uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n            /// Next 10 bits => 228-237 => utilization limit of token0. Max value 1000 = 100%, if 100% then no need to check the utilization.\n            /// Next 10 bits => 238-247 => utilization limit of token1. Max value 1000 = 100%, if 100% then no need to check the utilization.\n            {\n                // TOKEN 0\n                uint256 maxUtilizationToken0Dex_ = ((dexVariables2_ >> 228) & X10) * 10; // bring to 1e2 same as liquidity layer\n                // check if max utilization at liquidity layer is smaller for combined config\n                uint256 maxUtilizationToken0Combined_ = maxUtilizationToken0Dex_;\n                if (liquidityTokenData0_.maxUtilization < maxUtilizationToken0Combined_) {\n                    maxUtilizationToken0Combined_ = liquidityTokenData0_.maxUtilization;\n                }\n\n                // calculate utilization limit amount % of total supply (with combined config for borrow)\n                uint256 maxUtilizationToken0_ = (liquidityTokenData0_.totalSupply * maxUtilizationToken0Combined_) /\n                    1e4;\n\n                if (liquidityTokenData0_.totalBorrow < maxUtilizationToken0_) {\n                    // expands to & available: amount until utilization max\n                    // get amount where currently borrowed = utilization limit of total supply. for withdraw only dex config counts.\n                    limits_.withdrawableToken0.available = maxUtilizationToken0Dex_ == 0\n                        ? 0\n                        : (1e4 * liquidityTokenData0_.totalBorrow) / maxUtilizationToken0Dex_;\n                    limits_.withdrawableToken0.available = liquidityTokenData0_.totalSupply >\n                        limits_.withdrawableToken0.available\n                        ? liquidityTokenData0_.totalSupply - limits_.withdrawableToken0.available\n                        : 0;\n                    // no expansion on utilization\n                    limits_.withdrawableToken0.expandsTo = limits_.withdrawableToken0.available;\n\n                    limits_.borrowableToken0.available = maxUtilizationToken0_ - liquidityTokenData0_.totalBorrow;\n                    // no expansion on utilization\n                    limits_.borrowableToken0.expandsTo = limits_.borrowableToken0.available;\n\n                    // balance at liquidity layer is a hard limit that can not be expanded beyond\n                    uint balanceLiquidity_ = token0_ == NATIVE_TOKEN_ADDRESS\n                        ? address(LIQUIDITY).balance\n                        : TokenInterface(token0_).balanceOf(address(LIQUIDITY));\n                    if (limits_.withdrawableToken0.expandsTo > balanceLiquidity_) {\n                        limits_.withdrawableToken0.expandsTo = balanceLiquidity_;\n                    }\n                    if (limits_.borrowableToken0.expandsTo > balanceLiquidity_) {\n                        limits_.borrowableToken0.expandsTo = balanceLiquidity_;\n                    }\n                }\n            }\n\n            {\n                // TOKEN 1\n                uint256 maxUtilizationToken1Dex_ = ((dexVariables2_ >> 238) & X10) * 10;\n                uint256 maxUtilizationToken1Combined_ = maxUtilizationToken1Dex_;\n                if (liquidityTokenData1_.maxUtilization < maxUtilizationToken1Combined_) {\n                    maxUtilizationToken1Combined_ = liquidityTokenData1_.maxUtilization;\n                }\n                uint256 maxUtilizationToken1_ = (liquidityTokenData1_.totalSupply * maxUtilizationToken1Combined_) /\n                    1e4;\n                if (liquidityTokenData1_.totalBorrow < maxUtilizationToken1_) {\n                    // expands to & available: amount until utilization max\n                    // get amount where currently borrowed = utilization limit of total supply. for withdraw only dex config counts.\n                    limits_.withdrawableToken1.available = maxUtilizationToken1Dex_ == 0\n                        ? 0\n                        : (1e4 * liquidityTokenData1_.totalBorrow) / maxUtilizationToken1Dex_;\n                    limits_.withdrawableToken1.available = liquidityTokenData1_.totalSupply >\n                        limits_.withdrawableToken1.available\n                        ? liquidityTokenData1_.totalSupply - limits_.withdrawableToken1.available\n                        : 0;\n                    // no expansion on utilization\n                    limits_.withdrawableToken1.expandsTo = limits_.withdrawableToken1.available;\n\n                    limits_.borrowableToken1.available = maxUtilizationToken1_ - liquidityTokenData1_.totalBorrow;\n                    // no expansion on utilization\n                    limits_.borrowableToken1.expandsTo = limits_.borrowableToken1.available;\n\n                    // balance at liquidity layer is a hard limit that can not be expanded beyond\n                    uint balanceLiquidity_ = token1_ == NATIVE_TOKEN_ADDRESS\n                        ? address(LIQUIDITY).balance\n                        : TokenInterface(token1_).balanceOf(address(LIQUIDITY));\n                    if (limits_.withdrawableToken1.expandsTo > balanceLiquidity_) {\n                        limits_.withdrawableToken1.expandsTo = balanceLiquidity_;\n                    }\n                    if (limits_.borrowableToken1.expandsTo > balanceLiquidity_) {\n                        limits_.borrowableToken1.expandsTo = balanceLiquidity_;\n                    }\n                }\n            }\n        }\n\n        // ----------------------- 2. WITHDRAW AND BORROW LIMITS (include liquidity layer balances) -----------------------\n\n        // expandsTo = max possible amount at full expansion\n        // expandDuration = time of expandDuration config left until maxExpansion is reached\n\n        // TOKEN 0 WITHDRAWABLE\n        {\n            uint256 expandTimeLeft_ = liquidityUserSupplyDataToken0_.lastUpdateTimestamp +\n                liquidityUserSupplyDataToken0_.expandDuration;\n            expandTimeLeft_ = block.timestamp > expandTimeLeft_ ? 0 : expandTimeLeft_ - block.timestamp;\n\n            uint256 maxWithdrawable_ = (liquidityUserSupplyDataToken0_.expandPercent *\n                liquidityUserSupplyDataToken0_.supply) / 1e4;\n            if (liquidityUserSupplyDataToken0_.withdrawable > maxWithdrawable_) {\n                // max expansion already reached or below base limit\n                maxWithdrawable_ = liquidityUserSupplyDataToken0_.withdrawable;\n                expandTimeLeft_ = 0;\n            }\n\n            if (maxWithdrawable_ <= limits_.withdrawableToken0.expandsTo) {\n                // if max withdrawable until limit is less than utilization limit, then set max withdrawable until limit as expansion limit.\n                limits_.withdrawableToken0.expandsTo = maxWithdrawable_;\n\n                expandTimeLeft_ = maxWithdrawable_ == 0\n                    ? 0\n                    : ((limits_.withdrawableToken0.expandsTo - liquidityUserSupplyDataToken0_.withdrawable) *\n                        liquidityUserSupplyDataToken0_.expandDuration) / maxWithdrawable_;\n            } else {\n                // max withdrawable expansion is limited by utilization or liquidity layer balance.\n                // recalculate the duration until that earlier limit is hit.\n                if (liquidityUserSupplyDataToken0_.withdrawable > limits_.withdrawableToken0.expandsTo) {\n                    // withdrawable amount at LiquidityResolver does not have dex utilization limit included\n                    // so this case could actually happen. if so, then adjust withdrawable and expansion is already\n                    // max reached so duration left is 0.\n                    expandTimeLeft_ = 0;\n                    liquidityUserSupplyDataToken0_.withdrawable = limits_.withdrawableToken0.expandsTo;\n                } else {\n                    // expansionPerSecond_ = maxWithdrawable_ / expandDuration;\n                    // withdrawable + expansionPerSecond_ * x = expandsTo;\n                    // so x = (expandsTo - withdrawable) / expansionPerSecond_;\n                    // so x = (expandsTo - withdrawable) / (maxWithdrawable_ / expandDuration);\n                    // so x = (expandsTo - withdrawable) * expandDuration / maxWithdrawable_;\n                    expandTimeLeft_ = maxWithdrawable_ == 0\n                        ? 0\n                        : ((limits_.withdrawableToken0.expandsTo - liquidityUserSupplyDataToken0_.withdrawable) *\n                            liquidityUserSupplyDataToken0_.expandDuration) / maxWithdrawable_;\n                }\n            }\n            limits_.withdrawableToken0.expandDuration = expandTimeLeft_;\n        }\n\n        // TOKEN 1 WITHDRAWABLE\n        {\n            uint256 expandTimeLeft_ = liquidityUserSupplyDataToken1_.lastUpdateTimestamp +\n                liquidityUserSupplyDataToken1_.expandDuration;\n            expandTimeLeft_ = block.timestamp > expandTimeLeft_ ? 0 : expandTimeLeft_ - block.timestamp;\n\n            uint256 maxWithdrawable_ = (liquidityUserSupplyDataToken1_.expandPercent *\n                liquidityUserSupplyDataToken1_.supply) / 1e4;\n            if (liquidityUserSupplyDataToken1_.withdrawable > maxWithdrawable_) {\n                // max expansion already reached or below base limit\n                maxWithdrawable_ = liquidityUserSupplyDataToken1_.withdrawable;\n                expandTimeLeft_ = 0;\n            }\n\n            if (maxWithdrawable_ <= limits_.withdrawableToken1.expandsTo) {\n                // if max withdrawable until limit is less than utilization limit, then set max withdrawable until limit as expansion limit.\n                limits_.withdrawableToken1.expandsTo = maxWithdrawable_;\n\n                expandTimeLeft_ = maxWithdrawable_ == 0\n                    ? 0\n                    : ((limits_.withdrawableToken1.expandsTo - liquidityUserSupplyDataToken1_.withdrawable) *\n                        liquidityUserSupplyDataToken1_.expandDuration) / maxWithdrawable_;\n            } else {\n                // max withdrawable expansion is limited by utilization or liquidity layer balance.\n                // recalculate the duration until that earlier limit is hit.\n                if (liquidityUserSupplyDataToken1_.withdrawable > limits_.withdrawableToken1.expandsTo) {\n                    // withdrawable amount at LiquidityResolver does not have dex utilization limit included\n                    // so this case could actually happen. if so, then adjust withdrawable and expansion is already\n                    // max reached so duration left is 0.\n                    expandTimeLeft_ = 0;\n                    liquidityUserSupplyDataToken1_.withdrawable = limits_.withdrawableToken1.expandsTo;\n                } else {\n                    expandTimeLeft_ = maxWithdrawable_ == 0\n                        ? 0\n                        : ((limits_.withdrawableToken1.expandsTo - liquidityUserSupplyDataToken1_.withdrawable) *\n                            liquidityUserSupplyDataToken1_.expandDuration) / maxWithdrawable_;\n                }\n            }\n            limits_.withdrawableToken1.expandDuration = expandTimeLeft_;\n        }\n\n        // TOKEN 0 BORROWABLE\n        {\n            uint256 expandTimeLeft_ = liquidityUserBorrowDataToken0_.lastUpdateTimestamp +\n                liquidityUserBorrowDataToken0_.expandDuration;\n            expandTimeLeft_ = block.timestamp > expandTimeLeft_ ? 0 : expandTimeLeft_ - block.timestamp;\n\n            uint256 maxBorrowable_ = (liquidityUserBorrowDataToken0_.expandPercent *\n                liquidityUserBorrowDataToken0_.borrow) / 1e4;\n            {\n                // consider max hard borrow limit\n                uint256 maxBorrowableUntilHardLimit_ = liquidityUserBorrowDataToken0_.maxBorrowLimit -\n                    liquidityUserBorrowDataToken0_.borrow;\n                if (limits_.borrowableToken0.expandsTo > maxBorrowableUntilHardLimit_) {\n                    limits_.borrowableToken0.expandsTo = maxBorrowableUntilHardLimit_;\n                }\n            }\n            if (liquidityUserBorrowDataToken0_.borrowable > maxBorrowable_) {\n                // max expansion already reached or below base limit\n                maxBorrowable_ = liquidityUserBorrowDataToken0_.borrowable;\n                expandTimeLeft_ = 0;\n            }\n\n            if (maxBorrowable_ <= limits_.borrowableToken0.expandsTo) {\n                // if max borrowable until limit is less than utilization limit, then set max borrowable until limit as expansion limit.\n                limits_.borrowableToken0.expandsTo = maxBorrowable_;\n\n                // expansionPerSecond_ = maxBorrowable_ / expandDuration;\n                // borrowable + expansionPerSecond_ * x = expandsTo;\n                expandTimeLeft_ = maxBorrowable_ == 0\n                    ? 0\n                    : ((limits_.borrowableToken0.expandsTo - liquidityUserBorrowDataToken0_.borrowable) *\n                        liquidityUserBorrowDataToken0_.expandDuration) / maxBorrowable_;\n            } else {\n                // max borrowable expansion is limited by utilization or liquidity layer balance.\n                // recalculate the duration until that earlier limit is hit.\n                if (liquidityUserBorrowDataToken0_.borrowable > limits_.borrowableToken0.expandsTo) {\n                    // borrowable amount at LiquidityResolver does not have dex utilization limit included\n                    // so this case could actually happen. if so, then adjust borrowable and expansion is already\n                    // max reached so duration left is 0.\n                    expandTimeLeft_ = 0;\n                    liquidityUserBorrowDataToken0_.borrowable = limits_.borrowableToken0.expandsTo;\n                } else {\n                    expandTimeLeft_ = maxBorrowable_ == 0\n                        ? 0\n                        : ((limits_.borrowableToken0.expandsTo - liquidityUserBorrowDataToken0_.borrowable) *\n                            liquidityUserBorrowDataToken0_.expandDuration) / maxBorrowable_;\n                }\n            }\n            limits_.borrowableToken0.expandDuration = expandTimeLeft_;\n        }\n\n        // TOKEN 1 BORROWABLE\n        {\n            uint256 expandTimeLeft_ = liquidityUserBorrowDataToken1_.lastUpdateTimestamp +\n                liquidityUserBorrowDataToken1_.expandDuration;\n            expandTimeLeft_ = block.timestamp > expandTimeLeft_ ? 0 : expandTimeLeft_ - block.timestamp;\n\n            uint256 maxBorrowable_ = (liquidityUserBorrowDataToken1_.expandPercent *\n                liquidityUserBorrowDataToken1_.borrow) / 1e4;\n            {\n                // consider max hard borrow limit\n                uint256 maxBorrowableUntilHardLimit_ = liquidityUserBorrowDataToken1_.maxBorrowLimit -\n                    liquidityUserBorrowDataToken1_.borrow;\n                if (limits_.borrowableToken1.expandsTo > maxBorrowableUntilHardLimit_) {\n                    limits_.borrowableToken1.expandsTo = maxBorrowableUntilHardLimit_;\n                }\n            }\n            if (liquidityUserBorrowDataToken1_.borrowable > maxBorrowable_) {\n                // max expansion already reached or below base limit\n                maxBorrowable_ = liquidityUserBorrowDataToken1_.borrowable;\n                expandTimeLeft_ = 0;\n            }\n\n            if (maxBorrowable_ <= limits_.borrowableToken1.expandsTo) {\n                // if max borrowable until limit is less than utilization limit, then set max borrowable until limit as expansion limit.\n                limits_.borrowableToken1.expandsTo = maxBorrowable_;\n\n                // expansionPerSecond_ = maxBorrowable_ / expandDuration;\n                // borrowable + expansionPerSecond_ * x = expandsTo;\n                expandTimeLeft_ = maxBorrowable_ == 0\n                    ? 0\n                    : ((limits_.borrowableToken1.expandsTo - liquidityUserBorrowDataToken1_.borrowable) *\n                        liquidityUserBorrowDataToken1_.expandDuration) / maxBorrowable_;\n            } else {\n                // max borrowable expansion is limited by utilization or liquidity layer balance.\n                // recalculate the duration until that earlier limit is hit.\n                if (liquidityUserBorrowDataToken1_.borrowable > limits_.borrowableToken1.expandsTo) {\n                    // borrowable amount at LiquidityResolver does not have dex utilization limit included\n                    // so this case could actually happen. if so, then adjust borrowable and expansion is already\n                    // max reached so duration left is 0.\n                    expandTimeLeft_ = 0;\n                    liquidityUserBorrowDataToken1_.borrowable = limits_.borrowableToken1.expandsTo;\n                } else {\n                    expandTimeLeft_ = maxBorrowable_ == 0\n                        ? 0\n                        : ((limits_.borrowableToken1.expandsTo - liquidityUserBorrowDataToken1_.borrowable) *\n                            liquidityUserBorrowDataToken1_.expandDuration) / maxBorrowable_;\n                }\n            }\n            limits_.borrowableToken1.expandDuration = expandTimeLeft_;\n        }\n\n        // for available amounts, set withdrawable / borrowable (incl. liquidity balances) if less than available until utilization\n        if (liquidityUserSupplyDataToken1_.withdrawable < limits_.withdrawableToken0.available) {\n            limits_.withdrawableToken0.available = liquidityUserSupplyDataToken0_.withdrawable;\n        }\n        if (liquidityUserSupplyDataToken1_.withdrawable < limits_.withdrawableToken1.available) {\n            limits_.withdrawableToken1.available = liquidityUserSupplyDataToken1_.withdrawable;\n        }\n        if (liquidityUserBorrowDataToken0_.borrowable < limits_.borrowableToken0.available) {\n            limits_.borrowableToken0.available = liquidityUserBorrowDataToken0_.borrowable;\n        }\n        if (liquidityUserBorrowDataToken1_.borrowable < limits_.borrowableToken1.available) {\n            limits_.borrowableToken1.available = liquidityUserBorrowDataToken1_.borrowable;\n        }\n    }\n}\n\nabstract contract DexActionEstimates is DexPublicViews, DexSwapLimits {\n    address private constant ADDRESS_DEAD = 0x000000000000000000000000000000000000dEaD;\n\n    /// @param t total amount in\n    /// @param x imaginary reserves of token out of collateral\n    /// @param y imaginary reserves of token in of collateral\n    /// @param x2 imaginary reserves of token out of debt\n    /// @param y2 imaginary reserves of token in of debt\n    /// @return a_ how much swap should go through collateral pool. Remaining will go from debt\n    /// note if a < 0 then entire trade route through debt pool and debt pool arbitrage with col pool\n    /// note if a > t then entire trade route through col pool and col pool arbitrage with debt pool\n    /// note if a > 0 & a < t then swap will route through both pools\n    function _swapRoutingIn(uint t, uint x, uint y, uint x2, uint y2) private pure returns (int a_) {\n        // Main equations:\n        // 1. out = x * a / (y + a)\n        // 2. out2 = x2 * (t - a) / (y2 + (t - a))\n        // final price should be same\n        // 3. (y + a) / (x - out) = (y2 + (t - a)) / (x2 - out2)\n        // derivation: https://chatgpt.com/share/dce6f381-ee5f-4d5f-b6ea-5996e84d5b57\n\n        // adding 1e18 precision\n        uint xyRoot_ = FixedPointMathLib.sqrt(x * y * 1e18);\n        uint x2y2Root_ = FixedPointMathLib.sqrt(x2 * y2 * 1e18);\n\n        a_ = (int(y2 * xyRoot_ + t * xyRoot_) - int(y * x2y2Root_)) / int(xyRoot_ + x2y2Root_);\n    }\n\n    /// @param t total amount out\n    /// @param x imaginary reserves of token in of collateral\n    /// @param y imaginary reserves of token out of collateral\n    /// @param x2 imaginary reserves of token in of debt\n    /// @param y2 imaginary reserves of token out of debt\n    /// @return a_ how much swap should go through collateral pool. Remaining will go from debt\n    /// note if a < 0 then entire trade route through debt pool and debt pool arbitrage with col pool\n    /// note if a > t then entire trade route through col pool and col pool arbitrage with debt pool\n    /// note if a > 0 & a < t then swap will route through both pools\n    function _swapRoutingOut(uint t, uint x, uint y, uint x2, uint y2) private pure returns (int a_) {\n        // Main equations:\n        // 1. in = (x * a) / (y - a)\n        // 2. in2 = (x2 * (t - a)) / (y2 - (t - a))\n        // final price should be same\n        // 3. (y - a) / (x + in) = (y2 - (t - a)) / (x2 + in2)\n        // derivation: https://chatgpt.com/share/6585bc28-841f-49ec-aea2-1e5c5b7f4fa9\n\n        // adding 1e18 precision\n        uint xyRoot_ = FixedPointMathLib.sqrt(x * y * 1e18);\n        uint x2y2Root_ = FixedPointMathLib.sqrt(x2 * y2 * 1e18);\n\n        // 1e18 precision gets cancelled out in division\n        a_ = (int(t * xyRoot_ + y * x2y2Root_) - int(y2 * xyRoot_)) / int(xyRoot_ + x2y2Root_);\n    }\n\n    /// @dev Given an input amount of asset and pair reserves, returns the maximum output amount of the other asset\n    /// @param amountIn_ The amount of input asset.\n    /// @param iReserveIn_ Imaginary token reserve with input amount.\n    /// @param iReserveOut_ Imaginary token reserve of output amount.\n    function _getAmountOut(\n        uint256 amountIn_,\n        uint iReserveIn_,\n        uint iReserveOut_\n    ) private pure returns (uint256 amountOut_) {\n        unchecked {\n            // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\n            uint256 numerator_ = amountIn_ * iReserveOut_;\n            uint256 denominator_ = iReserveIn_ + amountIn_;\n\n            // Using the swap formula: (AmountIn * iReserveY) / (iReserveX + AmountIn)\n            amountOut_ = numerator_ / denominator_;\n        }\n    }\n\n    /// @dev Given an output amount of asset and pair reserves, returns the input amount of the other asset\n    /// @param amountOut_ Desired output amount of the asset.\n    /// @param iReserveIn_ Imaginary token reserve of input amount.\n    /// @param iReserveOut_ Imaginary token reserve of output amount.\n    function _getAmountIn(\n        uint256 amountOut_,\n        uint iReserveIn_,\n        uint iReserveOut_\n    ) private pure returns (uint256 amountIn_) {\n        // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\n        uint256 numerator_ = amountOut_ * iReserveIn_;\n        uint256 denominator_ = iReserveOut_ - amountOut_;\n\n        // Using the swap formula: (AmountOut * iReserveX) / (iReserveY - AmountOut)\n        amountIn_ = numerator_ / denominator_;\n    }\n\n    struct EstimateMemoryVars {\n        uint256 colTokenInImaginaryReserves;\n        uint256 colTokenOutImaginaryReserves;\n        uint256 debtTokenInImaginaryReserves;\n        uint256 debtTokenOutImaginaryReserves;\n        uint256 amountOutCollateralAdjusted;\n        uint256 amountOutDebtAdjusted;\n        uint256 amountInCollateralAdjusted;\n        uint256 amountInDebtAdjusted;\n    }\n\n    /// @notice estimates swap IN tokens execution\n    /// @param dex_ Dex pool\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function estimateSwapIn(\n        address dex_,\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_\n    ) public payable returns (uint256 amountOut_) {\n        try IFluidDexT1(dex_).swapIn{ value: msg.value }(swap0to1_, amountIn_, amountOutMin_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (amountOut_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSwapResult.selector);\n        }\n\n        EstimateMemoryVars memory e_;\n        {\n            IFluidDexT1.CollateralReserves memory colReserves_ = getDexCollateralReservesAdjusted(dex_);\n            IFluidDexT1.DebtReserves memory debtReserves_ = getDexDebtReservesAdjusted(dex_);\n            if (swap0to1_) {\n                e_.colTokenInImaginaryReserves = colReserves_.token0ImaginaryReserves;\n                e_.colTokenOutImaginaryReserves = colReserves_.token1ImaginaryReserves;\n                e_.debtTokenInImaginaryReserves = debtReserves_.token0ImaginaryReserves;\n                e_.debtTokenOutImaginaryReserves = debtReserves_.token1ImaginaryReserves;\n            } else {\n                e_.colTokenInImaginaryReserves = colReserves_.token1ImaginaryReserves;\n                e_.colTokenOutImaginaryReserves = colReserves_.token0ImaginaryReserves;\n                e_.debtTokenInImaginaryReserves = debtReserves_.token1ImaginaryReserves;\n                e_.debtTokenOutImaginaryReserves = debtReserves_.token0ImaginaryReserves;\n            }\n        }\n\n        IFluidDexT1.ConstantViews2 memory constantsView2_ = IFluidDexT1(dex_).constantsView2();\n\n        {\n            int256 swapRoutingAmt_;\n            uint256 poolFee_;\n            uint256 amountInAdjusted_;\n            // bring amount in to 1e12 decimals adjusted\n            if (swap0to1_) {\n                amountInAdjusted_ =\n                    (amountIn_ * constantsView2_.token0NumeratorPrecision) /\n                    constantsView2_.token0DenominatorPrecision;\n            } else {\n                amountInAdjusted_ =\n                    (amountIn_ * constantsView2_.token1NumeratorPrecision) /\n                    constantsView2_.token1DenominatorPrecision;\n            }\n\n            {\n                uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n                poolFee_ = (dexVariables2_ >> 2) & X17;\n                bool colPoolEnabled_ = (dexVariables2_ & 1) == 1;\n                bool debtPoolEnabled_ = (dexVariables2_ & 2) == 2;\n                if (colPoolEnabled_ && debtPoolEnabled_) {\n                    swapRoutingAmt_ = _swapRoutingIn(\n                        amountInAdjusted_,\n                        e_.colTokenOutImaginaryReserves,\n                        e_.colTokenInImaginaryReserves,\n                        e_.debtTokenOutImaginaryReserves,\n                        e_.debtTokenInImaginaryReserves\n                    );\n                } else if (debtPoolEnabled_) {\n                    swapRoutingAmt_ = -1; // Route from debt pool\n                } else if (colPoolEnabled_) {\n                    swapRoutingAmt_ = int256(amountInAdjusted_) + 1; // Route from collateral pool\n                } else {\n                    revert(\"No pools are enabled\");\n                }\n            }\n\n            if (swapRoutingAmt_ <= 0) {\n                // Entire trade routes through debt pool\n                e_.amountInDebtAdjusted = amountInAdjusted_;\n                e_.amountOutDebtAdjusted = _getAmountOut(\n                    ((amountInAdjusted_ * (1e6 - poolFee_)) / 1e6),\n                    e_.debtTokenInImaginaryReserves,\n                    e_.debtTokenOutImaginaryReserves\n                );\n            } else if (swapRoutingAmt_ >= int256(amountInAdjusted_)) {\n                // Entire trade routes through collateral pool\n                e_.amountInCollateralAdjusted = amountInAdjusted_;\n                e_.amountOutCollateralAdjusted = _getAmountOut(\n                    ((amountInAdjusted_ * (1e6 - poolFee_)) / 1e6),\n                    e_.colTokenInImaginaryReserves,\n                    e_.colTokenOutImaginaryReserves\n                );\n            } else {\n                // Trade routes through both pools\n                e_.amountInCollateralAdjusted = uint(swapRoutingAmt_);\n                e_.amountInDebtAdjusted = amountInAdjusted_ - e_.amountInCollateralAdjusted;\n\n                e_.amountOutCollateralAdjusted = _getAmountOut(\n                    ((e_.amountInCollateralAdjusted * (1e6 - poolFee_)) / 1e6),\n                    e_.colTokenInImaginaryReserves,\n                    e_.colTokenOutImaginaryReserves\n                );\n\n                e_.amountOutDebtAdjusted = _getAmountOut(\n                    ((e_.amountInDebtAdjusted * (1e6 - poolFee_)) / 1e6),\n                    e_.debtTokenInImaginaryReserves,\n                    e_.debtTokenOutImaginaryReserves\n                );\n            }\n        }\n\n        {\n            uint256 borrowableAdjusted_;\n            uint256 withdrawableAdjusted_;\n            DexLimits memory limits_ = getDexLimits(dex_);\n\n            // bring amount to 1e12 decimals adjusted\n            if (swap0to1_) {\n                borrowableAdjusted_ =\n                    (limits_.borrowableToken1.available * constantsView2_.token1NumeratorPrecision) /\n                    constantsView2_.token1DenominatorPrecision;\n                withdrawableAdjusted_ =\n                    (limits_.withdrawableToken1.available * constantsView2_.token1NumeratorPrecision) /\n                    constantsView2_.token1DenominatorPrecision;\n            } else {\n                borrowableAdjusted_ =\n                    (limits_.borrowableToken0.available * constantsView2_.token0NumeratorPrecision) /\n                    constantsView2_.token0DenominatorPrecision;\n                withdrawableAdjusted_ =\n                    (limits_.withdrawableToken0.available * constantsView2_.token0NumeratorPrecision) /\n                    constantsView2_.token0DenominatorPrecision;\n            }\n\n            if (e_.amountOutDebtAdjusted > borrowableAdjusted_) {\n                return 0;\n            }\n            if (e_.amountOutCollateralAdjusted > withdrawableAdjusted_) {\n                return 0;\n            }\n        }\n\n        uint256 oldPrice_;\n        uint256 newPrice_;\n        // from whatever pool higher amount of swap is routing we are taking that as final price, does not matter much because both pools final price should be same\n        if (e_.amountInCollateralAdjusted > e_.amountInDebtAdjusted) {\n            // new pool price from col pool\n            oldPrice_ = swap0to1_\n                ? (e_.colTokenOutImaginaryReserves * 1e27) / (e_.colTokenInImaginaryReserves)\n                : (e_.colTokenInImaginaryReserves * 1e27) / (e_.colTokenOutImaginaryReserves);\n            newPrice_ = swap0to1_\n                ? ((e_.colTokenOutImaginaryReserves - e_.amountOutCollateralAdjusted) * 1e27) /\n                    (e_.colTokenInImaginaryReserves + e_.amountInCollateralAdjusted)\n                : ((e_.colTokenInImaginaryReserves + e_.amountInCollateralAdjusted) * 1e27) /\n                    (e_.colTokenOutImaginaryReserves - e_.amountOutCollateralAdjusted);\n        } else {\n            // new pool price from debt pool\n            oldPrice_ = swap0to1_\n                ? (e_.debtTokenOutImaginaryReserves * 1e27) / (e_.debtTokenInImaginaryReserves)\n                : (e_.debtTokenInImaginaryReserves * 1e27) / (e_.debtTokenOutImaginaryReserves);\n            newPrice_ = swap0to1_\n                ? ((e_.debtTokenOutImaginaryReserves - e_.amountOutDebtAdjusted) * 1e27) /\n                    (e_.debtTokenInImaginaryReserves + e_.amountInDebtAdjusted)\n                : ((e_.debtTokenInImaginaryReserves + e_.amountInDebtAdjusted) * 1e27) /\n                    (e_.debtTokenOutImaginaryReserves - e_.amountOutDebtAdjusted);\n        }\n\n        uint256 priceDiff_ = oldPrice_ > newPrice_ ? oldPrice_ - newPrice_ : newPrice_ - oldPrice_;\n        if (priceDiff_ > ((oldPrice_ * ORACLE_LIMIT) / 1e18)) {\n            // if price diff is > 5% then swap would revert.\n            return 0;\n        }\n\n        return amountOut_;\n    }\n\n    /// @notice estimates swap OUT tokens execution\n    /// @param dex_ Dex pool\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function estimateSwapOut(\n        address dex_,\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_\n    ) public payable returns (uint256 amountIn_) {\n        try IFluidDexT1(dex_).swapOut{ value: msg.value }(swap0to1_, amountOut_, amountInMax_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (amountIn_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSwapResult.selector);\n        }\n\n        EstimateMemoryVars memory e_;\n        {\n            IFluidDexT1.CollateralReserves memory colReserves_ = getDexCollateralReservesAdjusted(dex_);\n            IFluidDexT1.DebtReserves memory debtReserves_ = getDexDebtReservesAdjusted(dex_);\n            if (swap0to1_) {\n                e_.colTokenInImaginaryReserves = colReserves_.token0ImaginaryReserves;\n                e_.colTokenOutImaginaryReserves = colReserves_.token1ImaginaryReserves;\n                e_.debtTokenInImaginaryReserves = debtReserves_.token0ImaginaryReserves;\n                e_.debtTokenOutImaginaryReserves = debtReserves_.token1ImaginaryReserves;\n            } else {\n                e_.colTokenInImaginaryReserves = colReserves_.token1ImaginaryReserves;\n                e_.colTokenOutImaginaryReserves = colReserves_.token0ImaginaryReserves;\n                e_.debtTokenInImaginaryReserves = debtReserves_.token1ImaginaryReserves;\n                e_.debtTokenOutImaginaryReserves = debtReserves_.token0ImaginaryReserves;\n            }\n        }\n\n        IFluidDexT1.ConstantViews2 memory constantsView2_ = IFluidDexT1(dex_).constantsView2();\n\n        {\n            int256 swapRoutingAmt_;\n            uint256 poolFee_;\n            uint256 amountOutAdjusted_;\n            // bring amount in to 1e12 decimals adjusted\n            if (swap0to1_) {\n                amountOutAdjusted_ =\n                    (amountOut_ * constantsView2_.token1NumeratorPrecision) /\n                    constantsView2_.token1DenominatorPrecision;\n            } else {\n                amountOutAdjusted_ =\n                    (amountOut_ * constantsView2_.token0NumeratorPrecision) /\n                    constantsView2_.token0DenominatorPrecision;\n            }\n\n            {\n                uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n                poolFee_ = (dexVariables2_ >> 2) & X17;\n                bool colPoolEnabled_ = (dexVariables2_ & 1) == 1;\n                bool debtPoolEnabled_ = (dexVariables2_ & 2) == 2;\n                if (colPoolEnabled_ && debtPoolEnabled_) {\n                    swapRoutingAmt_ = _swapRoutingOut(\n                        amountOutAdjusted_,\n                        e_.colTokenInImaginaryReserves,\n                        e_.colTokenOutImaginaryReserves,\n                        e_.debtTokenInImaginaryReserves,\n                        e_.debtTokenOutImaginaryReserves\n                    );\n                } else if (debtPoolEnabled_) {\n                    swapRoutingAmt_ = -1; // Route from debt pool\n                } else if (colPoolEnabled_) {\n                    swapRoutingAmt_ = int256(amountOutAdjusted_) + 1; // Route from collateral pool\n                } else {\n                    revert(\"No pools are enabled\");\n                }\n            }\n\n            if (swapRoutingAmt_ <= 0) {\n                // Entire trade routes through debt pool\n                e_.amountOutDebtAdjusted = amountOutAdjusted_;\n                e_.amountInDebtAdjusted = _getAmountIn(\n                    e_.amountOutDebtAdjusted,\n                    e_.debtTokenInImaginaryReserves,\n                    e_.debtTokenOutImaginaryReserves\n                );\n                e_.amountInDebtAdjusted = (e_.amountInDebtAdjusted * 1e6) / (1e6 - poolFee_);\n            } else if (swapRoutingAmt_ >= int256(amountOutAdjusted_)) {\n                // Entire trade routes through collateral pool\n                e_.amountOutCollateralAdjusted = amountOutAdjusted_;\n                e_.amountInCollateralAdjusted = _getAmountIn(\n                    e_.amountOutCollateralAdjusted,\n                    e_.colTokenInImaginaryReserves,\n                    e_.colTokenOutImaginaryReserves\n                );\n                e_.amountInCollateralAdjusted = (e_.amountInCollateralAdjusted * 1e6) / (1e6 - poolFee_);\n            } else {\n                // Trade routes through both pools\n                e_.amountOutCollateralAdjusted = uint(swapRoutingAmt_);\n                e_.amountOutDebtAdjusted = amountOutAdjusted_ - e_.amountOutCollateralAdjusted;\n\n                e_.amountInCollateralAdjusted = _getAmountIn(\n                    e_.amountOutCollateralAdjusted,\n                    e_.colTokenInImaginaryReserves,\n                    e_.colTokenOutImaginaryReserves\n                );\n                e_.amountInCollateralAdjusted = (e_.amountInCollateralAdjusted * 1e6) / (1e6 - poolFee_);\n\n                e_.amountInDebtAdjusted = _getAmountIn(\n                    e_.amountOutDebtAdjusted,\n                    e_.debtTokenInImaginaryReserves,\n                    e_.debtTokenOutImaginaryReserves\n                );\n                e_.amountInDebtAdjusted = (e_.amountInDebtAdjusted * 1e6) / (1e6 - poolFee_);\n            }\n        }\n\n        {\n            uint256 borrowableAdjusted_;\n            uint256 withdrawableAdjusted_;\n            DexLimits memory limits_ = getDexLimits(dex_);\n\n            // bring amount to 1e12 decimals adjusted\n            if (swap0to1_) {\n                borrowableAdjusted_ =\n                    (limits_.borrowableToken1.available * constantsView2_.token1NumeratorPrecision) /\n                    constantsView2_.token1DenominatorPrecision;\n                withdrawableAdjusted_ =\n                    (limits_.withdrawableToken1.available * constantsView2_.token1NumeratorPrecision) /\n                    constantsView2_.token1DenominatorPrecision;\n            } else {\n                borrowableAdjusted_ =\n                    (limits_.borrowableToken0.available * constantsView2_.token0NumeratorPrecision) /\n                    constantsView2_.token0DenominatorPrecision;\n                withdrawableAdjusted_ =\n                    (limits_.withdrawableToken0.available * constantsView2_.token0NumeratorPrecision) /\n                    constantsView2_.token0DenominatorPrecision;\n            }\n\n            if (e_.amountOutDebtAdjusted > borrowableAdjusted_) {\n                return type(uint256).max;\n            }\n            if (e_.amountOutCollateralAdjusted > withdrawableAdjusted_) {\n                return type(uint256).max;\n            }\n        }\n\n        uint256 oldPrice_;\n        uint256 newPrice_;\n        // from whatever pool higher amount of swap is routing we are taking that as final price, does not matter much because both pools final price should be same\n        if (e_.amountOutCollateralAdjusted > e_.amountOutDebtAdjusted) {\n            // new pool price from col pool\n            oldPrice_ = swap0to1_\n                ? (e_.colTokenOutImaginaryReserves * 1e27) / (e_.colTokenInImaginaryReserves)\n                : (e_.colTokenInImaginaryReserves * 1e27) / (e_.colTokenOutImaginaryReserves);\n            newPrice_ = swap0to1_\n                ? ((e_.colTokenOutImaginaryReserves - e_.amountOutCollateralAdjusted) * 1e27) /\n                    (e_.colTokenInImaginaryReserves + e_.amountInCollateralAdjusted)\n                : ((e_.colTokenInImaginaryReserves + e_.amountInCollateralAdjusted) * 1e27) /\n                    (e_.colTokenOutImaginaryReserves - e_.amountOutCollateralAdjusted);\n        } else {\n            // new pool price from debt pool\n            oldPrice_ = swap0to1_\n                ? (e_.debtTokenOutImaginaryReserves * 1e27) / (e_.debtTokenInImaginaryReserves)\n                : (e_.debtTokenInImaginaryReserves * 1e27) / (e_.debtTokenOutImaginaryReserves);\n            newPrice_ = swap0to1_\n                ? ((e_.debtTokenOutImaginaryReserves - e_.amountOutDebtAdjusted) * 1e27) /\n                    (e_.debtTokenInImaginaryReserves + e_.amountInDebtAdjusted)\n                : ((e_.debtTokenInImaginaryReserves + e_.amountInDebtAdjusted) * 1e27) /\n                    (e_.debtTokenOutImaginaryReserves - e_.amountOutDebtAdjusted);\n        }\n\n        uint256 priceDiff_ = oldPrice_ > newPrice_ ? oldPrice_ - newPrice_ : newPrice_ - oldPrice_;\n        if (priceDiff_ > ((oldPrice_ * ORACLE_LIMIT) / 1e18)) {\n            // if price diff is > 5% then swap would revert.\n            return type(uint256).max;\n        }\n\n        return amountIn_;\n    }\n\n    function _decodeLowLevelUint1x(\n        bytes memory lowLevelData_,\n        bytes4 targetErrorSelector_\n    ) internal pure returns (uint value1_) {\n        if (lowLevelData_.length < 36) {\n            return 0;\n        }\n\n        bytes4 errorSelector_;\n        assembly {\n            // Extract the selector from the error data\n            errorSelector_ := mload(add(lowLevelData_, 0x20))\n        }\n        if (errorSelector_ == targetErrorSelector_) {\n            assembly {\n                value1_ := mload(add(lowLevelData_, 36))\n            }\n        }\n        // else => values remain 0\n    }\n}\n\n/// @notice Fluid Dex Reserves resolver\n/// Implements various view-only methods to give easy access to Dex protocol reserves data.\ncontract FluidDexReservesResolver is DexFactoryViews, DexActionEstimates {\n    constructor(\n        address factory_,\n        address liquidity_,\n        address liquidityResolver_\n    ) Variables(factory_, liquidity_, liquidityResolver_) {}\n\n    /// @notice Get a Pool's address and its token addresses\n    /// @param poolId_ The ID of the Pool\n    /// @return pool_ The Pool data\n    function getPool(uint256 poolId_) public view returns (Pool memory pool_) {\n        address poolAddress_ = getPoolAddress(poolId_);\n        (address token0_, address token1_) = getPoolTokens(poolAddress_);\n        return Pool(poolAddress_, token0_, token1_, getPoolFee(poolAddress_));\n    }\n\n    /// @notice Get a Pool's fee\n    /// @param pool_ The Pool address\n    /// @return fee_ The Pool fee as 1% = 10000\n    function getPoolFee(address pool_) public view returns (uint256 fee_) {\n        uint256 dexVariables2_ = IFluidDexT1(pool_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        return (dexVariables2_ >> 2) & X17;\n    }\n\n    /// @notice Get an array of all Pool addresses and their token addresses\n    /// @return pools_ An array containing all Pool data\n    function getAllPools() public view returns (Pool[] memory pools_) {\n        uint256 totalPools_ = getTotalPools();\n        pools_ = new Pool[](totalPools_);\n        for (uint256 i; i < totalPools_; i++) {\n            pools_[i] = getPool(i + 1);\n        }\n    }\n\n    /// @notice Get the token addresses, collateral reserves, and debt reserves for a given Pool address\n    /// @param pool_ The Pool address\n    /// @return poolReserves_ The Pool data with reserves.\n    /// @dev expected to be called via callStatic\n    function getPoolReserves(address pool_) public returns (PoolWithReserves memory poolReserves_) {\n        (poolReserves_.token0, poolReserves_.token1) = getPoolTokens(pool_);\n\n        try this.getDexPricesAndExchangePrices(pool_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            poolReserves_.centerPrice = pex_.centerPrice;\n            poolReserves_.collateralReserves = _getDexCollateralReserves(pool_, pex_);\n            poolReserves_.debtReserves = _getDexDebtReserves(pool_, pex_);\n        } catch {\n            poolReserves_.collateralReserves = getDexCollateralReserves(pool_);\n            poolReserves_.debtReserves = getDexDebtReserves(pool_);\n        }\n\n        poolReserves_.pool = pool_;\n        poolReserves_.fee = getPoolFee(pool_);\n\n        poolReserves_.limits = getDexLimits(pool_);\n    }\n\n    /// @notice Get an array of Pool addresses, their token addresses, collateral reserves, and debt reserves for a given array of Pool addresses\n    /// @param pools_ The array of Pool addresses\n    /// @return poolsReserves_ An array containing all Pool data with reserves\n    /// @dev expected to be called via callStatic\n    function getPoolsReserves(address[] memory pools_) public returns (PoolWithReserves[] memory poolsReserves_) {\n        poolsReserves_ = new PoolWithReserves[](pools_.length);\n        for (uint256 i; i < pools_.length; i++) {\n            poolsReserves_[i] = getPoolReserves(pools_[i]);\n        }\n    }\n\n    /// @notice Get an array of all Pool addresses, their token addresses, collateral reserves, and debt reserves\n    /// @return poolsReserves_ An array containing all Pool data with reserves\n    /// @dev expected to be called via callStatic\n    function getAllPoolsReserves() public returns (PoolWithReserves[] memory poolsReserves_) {\n        return getPoolsReserves(getAllPoolAddresses());\n    }\n\n    /// @notice Get the token addresses, adjusted collateral reserves, and adjusted debt reserves for a given Pool address\n    /// @param pool_ The Pool address\n    /// @return poolReserves_ The Pool data with adjusted reserves scaled to 1e12. balanceTokens are in token decimals.\n    /// @dev expected to be called via callStatic\n    function getPoolReservesAdjusted(address pool_) public returns (PoolWithReserves memory poolReserves_) {\n        (poolReserves_.token0, poolReserves_.token1) = getPoolTokens(pool_);\n\n        try this.getDexPricesAndExchangePrices(pool_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            poolReserves_.centerPrice = pex_.centerPrice;\n            poolReserves_.collateralReserves = _getDexCollateralReservesAdjusted(pool_, pex_);\n            poolReserves_.debtReserves = _getDexDebtReservesAdjusted(pool_, pex_);\n        } catch {\n            poolReserves_.collateralReserves = getDexCollateralReservesAdjusted(pool_);\n            poolReserves_.debtReserves = getDexDebtReservesAdjusted(pool_);\n        }\n\n        poolReserves_.pool = pool_;\n        poolReserves_.fee = getPoolFee(pool_);\n\n        poolReserves_.limits = getDexLimits(pool_);\n    }\n\n    /// @notice Get an array of Pool addresses, their token addresses, adjusted collateral reserves, and adjusted debt reserves for a given array of Pool addresses\n    /// @param pools_ The array of Pool addresses\n    /// @return poolsReserves_ An array containing all Pool data with adjusted reserves scaled to 1e12\n    /// @dev expected to be called via callStatic\n    function getPoolsReservesAdjusted(\n        address[] memory pools_\n    ) public returns (PoolWithReserves[] memory poolsReserves_) {\n        poolsReserves_ = new PoolWithReserves[](pools_.length);\n        for (uint256 i; i < pools_.length; i++) {\n            poolsReserves_[i] = getPoolReservesAdjusted(pools_[i]);\n        }\n    }\n\n    /// @notice Get an array of all Pool addresses, their token addresses, adjusted collateral reserves, and adjusted debt reserves\n    /// @return poolsReserves_ An array containing all Pool data with adjusted reserves scaled to 1e12\n    /// @dev expected to be called via callStatic\n    function getAllPoolsReservesAdjusted() public returns (PoolWithReserves[] memory poolsReserves_) {\n        return getPoolsReservesAdjusted(getAllPoolAddresses());\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexReserves/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\n\nabstract contract Structs {\n    struct Pool {\n        address pool;\n        address token0;\n        address token1;\n        uint256 fee;\n    }\n\n    struct PoolWithReserves {\n        address pool;\n        address token0;\n        address token1;\n        uint256 fee;\n        uint256 centerPrice;\n        IFluidDexT1.CollateralReserves collateralReserves;\n        IFluidDexT1.DebtReserves debtReserves;\n        DexLimits limits;\n    }\n\n    struct TokenLimit {\n        // both `available` and `expandsTo` limits consider:\n        // - max utilization (at Liquidity layer and at Dex, for withdrawable only dex)\n        // - withdraw limits / borrow limits\n        // - balances at liquidity layer\n        uint256 available; // maximum available swap amount\n        uint256 expandsTo; // maximum amount the available swap amount expands to\n        uint256 expandDuration; // duration for `available` to grow to `expandsTo`\n    }\n\n    struct DexLimits {\n        TokenLimit withdrawableToken0;\n        TokenLimit withdrawableToken1;\n        TokenLimit borrowableToken0;\n        TokenLimit borrowableToken1;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexReserves/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidDexFactory } from \"../../../protocols/dex/interfaces/iDexFactory.sol\";\nimport { IFluidLiquidityResolver } from \"../liquidity/iLiquidityResolver.sol\";\n\ninterface IFluidLiquidity {\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n\nabstract contract Variables {\n    uint256 internal constant X10 = 0x3ff;\n    uint256 internal constant X17 = 0x1ffff;\n\n    uint256 internal constant ORACLE_LIMIT = 5 * 1e16; // 5%\n\n    /// @dev address that is mapped to the chain native token\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    IFluidDexFactory public immutable FACTORY;\n    IFluidLiquidity public immutable LIQUIDITY;\n    IFluidLiquidityResolver public immutable LIQUIDITY_RESOLVER;\n\n    constructor(address factory_, address liquidity_, address liquidityResolver_) {\n        FACTORY = IFluidDexFactory(factory_);\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        LIQUIDITY_RESOLVER = IFluidLiquidityResolver(liquidityResolver_);\n    }\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/iLiquidityResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Structs as LiquidityStructs } from \"../../../periphery/resolvers/liquidity/structs.sol\";\n\ninterface IFluidLiquidityResolver {\n    /// @notice gets the `revenueAmount_` for a `token_`.\n    function getRevenue(address token_) external view returns (uint256 revenueAmount_);\n\n    /// @notice address of contract that gets sent the revenue. Configurable by governance\n    function getRevenueCollector() external view returns (address);\n\n    /// @notice Liquidity contract paused status: status = 1 -> normal. status = 2 -> paused.\n    function getStatus() external view returns (uint256);\n\n    /// @notice checks if `auth_` is an allowed auth on Liquidity.\n    /// Auths can set most config values. E.g. contracts that automate certain flows like e.g. adding a new fToken.\n    /// Governance can add/remove auths. Governance is auth by default.\n    function isAuth(address auth_) external view returns (uint256);\n\n    /// @notice checks if `guardian_` is an allowed Guardian on Liquidity.\n    /// Guardians can pause lower class users.\n    /// Governance can add/remove guardians. Governance is guardian by default.\n    function isGuardian(address guardian_) external view returns (uint256);\n\n    /// @notice gets user class for `user_`. Class defines which protocols can be paused by guardians.\n    /// Currently there are 2 classes: 0 can be paused by guardians. 1 cannot be paused by guardians.\n    /// New protocols are added as class 0 and will be upgraded to 1 over time.\n    function getUserClass(address user_) external view returns (uint256);\n\n    /// @notice gets exchangePricesAndConfig packed uint256 storage slot for `token_`.\n    function getExchangePricesAndConfig(address token_) external view returns (uint256);\n\n    /// @notice gets rateConfig packed uint256 storage slot for `token_`.\n    function getRateConfig(address token_) external view returns (uint256);\n\n    /// @notice gets totalAmounts packed uint256 storage slot for `token_`.\n    function getTotalAmounts(address token_) external view returns (uint256);\n\n    /// @notice gets configs2 packed uint256 storage slot for `token_`.\n    function getConfigs2(address token_) external view returns (uint256);\n\n    /// @notice gets userSupply data packed uint256 storage slot for `user_` and `token_`.\n    function getUserSupply(address user_, address token_) external view returns (uint256);\n\n    /// @notice gets userBorrow data packed uint256 storage slot for `user_` and `token_`.\n    function getUserBorrow(address user_, address token_) external view returns (uint256);\n\n    /// @notice returns all `listedTokens_` at the Liquidity contract. Once configured, a token can never be removed.\n    function listedTokens() external view returns (address[] memory listedTokens_);\n\n    /// @notice get the Rate config data `rateData_` for a `token_` compiled from the packed uint256 rateConfig storage slot\n    function getTokenRateData(address token_) external view returns (LiquidityStructs.RateData memory rateData_);\n\n    /// @notice get the Rate config datas `rateDatas_` for multiple `tokens_` compiled from the packed uint256 rateConfig storage slot\n    function getTokensRateData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.RateData[] memory rateDatas_);\n\n    /// @notice returns general data for `token_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokenData(\n        address token_\n    ) external view returns (LiquidityStructs.OverallTokenData memory overallTokenData_);\n\n    /// @notice returns general data for multiple `tokens_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokensData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns general data for all `listedTokens()` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getAllOverallTokensData()\n        external\n        view\n        returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserSupplyData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData memory userSupplyData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleSupplyData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserBorrowData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData memory userBorrowData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleBorrowData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `supplyTokens_`\n    ///     and returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `borrowTokens_`\n    function getUserMultipleBorrowSupplyData(\n        address user_,\n        address[] calldata supplyTokens_,\n        address[] calldata borrowTokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallSupplyTokensData_,\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallBorrowTokensData_\n        );\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs as AdminModuleStructs } from \"../../../liquidity/adminModule/structs.sol\";\n\nabstract contract Structs {\n    struct RateData {\n        uint256 version;\n        AdminModuleStructs.RateDataV1Params rateDataV1;\n        AdminModuleStructs.RateDataV2Params rateDataV2;\n    }\n\n    struct OverallTokenData {\n        uint256 borrowRate;\n        uint256 supplyRate;\n        uint256 fee; // revenue fee\n        uint256 lastStoredUtilization;\n        uint256 storageUpdateThreshold;\n        uint256 lastUpdateTimestamp;\n        uint256 supplyExchangePrice;\n        uint256 borrowExchangePrice;\n        uint256 supplyRawInterest;\n        uint256 supplyInterestFree;\n        uint256 borrowRawInterest;\n        uint256 borrowInterestFree;\n        uint256 totalSupply;\n        uint256 totalBorrow;\n        uint256 revenue;\n        uint256 maxUtilization; // maximum allowed utilization\n        RateData rateData;\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserSupplyData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 supply; // user supply amount\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\n        uint256 withdrawalLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\n        uint256 baseWithdrawalLimit;\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\n        uint256 withdrawableUntilLimit;\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserBorrowData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 borrow; // user borrow amount\n        uint256 borrowLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseBorrowLimit;\n        uint256 maxBorrowLimit;\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\n    }\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexFactory {\n    /// @notice Global auth is auth for all dexes\n    function isGlobalAuth(address auth_) external view returns (bool);\n\n    /// @notice Dex auth is auth for a specific dex\n    function isDexAuth(address vault_, address auth_) external view returns (bool);\n\n    /// @notice Total dexes deployed.\n    function totalDexes() external view returns (uint256);\n\n    /// @notice Compute dexAddress\n    function getDexAddress(uint256 dexId_) external view returns (address);\n\n    /// @notice read uint256 `result_` for a storage `slot_` key\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexT1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexT1 {\n    error FluidDexError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares);\n\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\n\n    /// @notice returns the dex id\n    function DEX_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndOracle;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) external view returns (CollateralReserves memory c_);\n\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) external view returns (DebtReserves memory d_);\n\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\n    function getPricesAndExchangePrices() external;\n\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) external returns (\n        uint withdrawAmt_\n    );\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) external payable returns (\n        uint paybackAmt_\n    );\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(\n        uint[] memory secondsAgos_\n    ) external view returns (\n        Oracle[] memory twaps_,\n        uint currentPrice_\n    );\n}\n"
    },
    "contracts/protocols/lending/merkleDistributor/errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Errors {\n    error Unauthorized();\n    error InvalidParams();\n\n    // claim related errors:\n    error InvalidCycle();\n    error InvalidProof();\n    error NothingToClaim();\n    error MsgSenderNotRecipient();\n}\n"
    },
    "contracts/protocols/lending/merkleDistributor/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Events {\n    /// @notice Emitted when an address is added or removed from the allowed proposers\n    event LogUpdateProposer(address proposer, bool isProposer);\n\n    /// @notice Emitted when an address is added or removed from the allowed approvers\n    event LogUpdateApprover(address approver, bool isApprover);\n\n    /// @notice Emitted when a new cycle root hash is proposed\n    event LogRootProposed(uint256 cycle, bytes32 root, bytes32 contentHash, uint256 timestamp, uint256 blockNumber);\n\n    /// @notice Emitted when a new cycle root hash is approved by the owner and becomes the new active root\n    event LogRootUpdated(uint256 cycle, bytes32 root, bytes32 contentHash, uint256 timestamp, uint256 blockNumber);\n\n    /// @notice Emitted when a `user` claims `amount` via a valid merkle proof\n    event LogClaimed(\n        address user,\n        uint256 amount,\n        uint256 cycle,\n        uint8 positionType,\n        bytes32 positionId,\n        uint256 timestamp,\n        uint256 blockNumber\n    );\n}\n"
    },
    "contracts/protocols/lending/merkleDistributor/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { Structs } from \"./structs.sol\";\nimport { Variables } from \"./variables.sol\";\nimport { Events } from \"./events.sol\";\nimport { Errors } from \"./errors.sol\";\n\n// ---------------------------------------------------------------------------------------------\n//\n// @dev WARNING: DO NOT USE `multiProof` related methods of `MerkleProof`.\n// This repo uses OpenZeppelin 4.8.2 which has a vulnerability for multi proofs. See:\n// https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wprv-93r4-jj2p\n//\n// ---------------------------------------------------------------------------------------------\n\nabstract contract FluidMerkleDistributorCore is Structs, Variables, Events, Errors {\n    /// @dev validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert InvalidParams();\n        }\n        _;\n    }\n}\n\nabstract contract FluidMerkleDistributorAdmin is FluidMerkleDistributorCore {\n    /// @notice                  Updates an address status as a root proposer\n    /// @param proposer_         The address to update\n    /// @param isProposer_       Whether or not the address should be an allowed proposer\n    function updateProposer(address proposer_, bool isProposer_) public onlyOwner validAddress(proposer_) {\n        _proposers[proposer_] = isProposer_;\n        emit LogUpdateProposer(proposer_, isProposer_);\n    }\n\n    /// @notice                  Updates an address status as a root approver\n    /// @param approver_         The address to update\n    /// @param isApprover_       Whether or not the address should be an allowed approver\n    function updateApprover(address approver_, bool isApprover_) public onlyOwner validAddress(approver_) {\n        _approvers[approver_] = isApprover_;\n        emit LogUpdateApprover(approver_, isApprover_);\n    }\n\n    /// @dev open payload method for admin to resolve emergency cases\n    function spell(address[] memory targets_, bytes[] memory calldatas_) public onlyOwner {\n        for (uint256 i = 0; i < targets_.length; i++) {\n            Address.functionDelegateCall(targets_[i], calldatas_[i]);\n        }\n    }\n\n    /// @notice Pause contract functionality of new roots and claiming\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Unpause contract functionality of new roots and claiming\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n\nabstract contract FluidMerkleDistributorApprover is FluidMerkleDistributorCore {\n    /// @dev Checks that the sender is an approver\n    modifier onlyApprover() {\n        if (!isApprover(msg.sender)) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @notice checks if the `approver_` is an allowed root approver\n    function isApprover(address approver_) public view returns (bool) {\n        return (_approvers[approver_] || owner == approver_);\n    }\n\n    /// @notice Approve the current pending root and content hash\n    function approveRoot(\n        bytes32 root_,\n        bytes32 contentHash_,\n        uint40 cycle_,\n        uint40 startBlock_,\n        uint40 endBlock_\n    ) external onlyApprover {\n        MerkleCycle memory merkleCycle_ = _pendingMerkleCycle;\n\n        if (\n            root_ != merkleCycle_.merkleRoot ||\n            contentHash_ != merkleCycle_.merkleContentHash ||\n            cycle_ != merkleCycle_.cycle ||\n            startBlock_ != merkleCycle_.startBlock ||\n            endBlock_ != merkleCycle_.endBlock\n        ) {\n            revert InvalidParams();\n        }\n\n        previousMerkleRoot = _currentMerkleCycle.merkleRoot;\n\n        merkleCycle_.timestamp = uint40(block.timestamp);\n        merkleCycle_.publishBlock = uint40(block.number);\n\n        _currentMerkleCycle = merkleCycle_;\n\n        emit LogRootUpdated(cycle_, root_, contentHash_, block.timestamp, block.number);\n    }\n}\n\nabstract contract FluidMerkleDistributorProposer is FluidMerkleDistributorCore {\n    /// @dev Checks that the sender is a proposer\n    modifier onlyProposer() {\n        if (!isProposer(msg.sender)) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @notice checks if the `proposer_` is an allowed root proposer\n    function isProposer(address proposer_) public view returns (bool) {\n        return (_proposers[proposer_] || owner == proposer_);\n    }\n\n    /// @notice Propose a new root and content hash, which will be stored as pending until approved\n    function proposeRoot(\n        bytes32 root_,\n        bytes32 contentHash_,\n        uint40 cycle_,\n        uint40 startBlock_,\n        uint40 endBlock_\n    ) external whenNotPaused onlyProposer {\n        if (cycle_ != _currentMerkleCycle.cycle + 1 || startBlock_ > endBlock_) {\n            revert InvalidParams();\n        }\n\n        _pendingMerkleCycle = MerkleCycle({\n            merkleRoot: root_,\n            merkleContentHash: contentHash_,\n            cycle: cycle_,\n            startBlock: startBlock_,\n            endBlock: endBlock_,\n            timestamp: uint40(block.timestamp),\n            publishBlock: uint40(block.number)\n        });\n\n        emit LogRootProposed(cycle_, root_, contentHash_, block.timestamp, block.number);\n    }\n}\n\ncontract FluidMerkleDistributor is\n    FluidMerkleDistributorCore,\n    FluidMerkleDistributorAdmin,\n    FluidMerkleDistributorApprover,\n    FluidMerkleDistributorProposer\n{\n    constructor(\n        string memory name_,\n        address owner_,\n        address proposer_,\n        address approver_,\n        address rewardToken_\n    )\n        validAddress(owner_)\n        validAddress(proposer_)\n        validAddress(approver_)\n        validAddress(rewardToken_)\n        Variables(owner_, rewardToken_)\n    {   \n        name = name_;\n        \n        _proposers[proposer_] = true;\n        emit LogUpdateProposer(proposer_, true);\n\n        _approvers[approver_] = true;\n        emit LogUpdateApprover(approver_, true);\n    }\n\n    /// @notice checks if there is a proposed root waiting to be approved\n    function hasPendingRoot() external view returns (bool) {\n        return _pendingMerkleCycle.cycle == _currentMerkleCycle.cycle + 1;\n    }\n\n    /// @notice merkle root data related to current cycle (proposed and approved).\n    function currentMerkleCycle() public view returns (MerkleCycle memory) {\n        return _currentMerkleCycle;\n    }\n\n    /// @notice merkle root data related to pending cycle (proposed but not yet approved).\n    function pendingMerkleCycle() public view returns (MerkleCycle memory) {\n        return _pendingMerkleCycle;\n    }\n\n    function encodeClaim(\n        address recipient_,\n        uint256 cumulativeAmount_,\n        uint8 positionType_,\n        bytes32 positionId_,\n        uint256 cycle_,\n        bytes memory metadata_\n    ) public pure returns (bytes memory encoded_, bytes32 hash_) {\n        encoded_ = abi.encode(positionType_, positionId_, recipient_, cycle_, cumulativeAmount_, metadata_);\n        hash_ = keccak256(bytes.concat(keccak256(encoded_)));\n    }\n\n    function claim(\n        address recipient_,\n        uint256 cumulativeAmount_,\n        uint8 positionType_,\n        bytes32 positionId_,\n        uint256 cycle_,\n        bytes32[] calldata merkleProof_,\n        bytes memory metadata_\n    ) external whenNotPaused {\n        if(msg.sender != recipient_) revert MsgSenderNotRecipient();\n        uint256 currentCycle_ = uint256(_currentMerkleCycle.cycle);\n\n        if (!(cycle_ == currentCycle_ || (currentCycle_ > 0 && cycle_ == currentCycle_ - 1))) {\n            revert InvalidCycle();\n        }\n\n        // Verify the merkle proof.\n        bytes32 node_ = keccak256(\n            bytes.concat(keccak256(abi.encode(positionType_, positionId_, recipient_, cycle_, cumulativeAmount_, metadata_)))\n        );\n        if (\n            !MerkleProof.verify(\n                merkleProof_,\n                cycle_ == currentCycle_ ? _currentMerkleCycle.merkleRoot : previousMerkleRoot,\n                node_\n            )\n        ) {\n            revert InvalidProof();\n        }\n\n        uint256 claimable_ = cumulativeAmount_ - claimed[recipient_][positionId_];\n        if (claimable_ == 0) {\n            revert NothingToClaim();\n        }\n\n        claimed[recipient_][positionId_] = cumulativeAmount_;\n\n        SafeERC20.safeTransfer(TOKEN, recipient_, claimable_);\n\n        emit LogClaimed(recipient_, claimable_, cycle_, positionType_, positionId_, block.timestamp, block.number);\n    }\n}\n"
    },
    "contracts/protocols/lending/merkleDistributor/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct MerkleCycle {\n        // slot 1\n        bytes32 merkleRoot;\n        // slot 2\n        bytes32 merkleContentHash;\n        // slot 3\n        uint40 cycle;\n        uint40 timestamp;\n        uint40 publishBlock;\n        uint40 startBlock;\n        uint40 endBlock;\n    }\n}\n"
    },
    "contracts/protocols/lending/merkleDistributor/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Owned } from \"solmate/src/auth/Owned.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport { Structs } from \"./structs.sol\";\n\nabstract contract Constants {\n    IERC20 public immutable TOKEN;\n\n    constructor(address rewardToken_) {\n        TOKEN = IERC20(rewardToken_);\n    }\n}\n\nabstract contract Variables is Owned, Pausable, Constants, Structs {\n    // ------------ storage variables from inherited contracts (Owned, Pausable) come before vars here --------\n\n    // ----------------------- slot 0 ---------------------------\n    // address public owner; -> from Owned\n\n    // bool private _paused; -> from Pausable\n\n    // 11 bytes empty\n\n    // ----------------------- slot 1 ---------------------------\n\n    /// @dev Name of the Merkle Distributor\n    string public name;\n\n    // ----------------------- slot 2 ---------------------------\n\n    /// @dev allow list for allowed root proposer addresses\n    mapping(address => bool) internal _proposers;\n\n    // ----------------------- slot 3 ---------------------------\n\n    /// @dev allow list for allowed root proposer addresses\n    mapping(address => bool) internal _approvers;\n\n    // ----------------------- slot 4-6 ---------------------------\n\n    /// @dev merkle root data related to current cycle (proposed and approved).\n    /// @dev timestamp & publishBlock = data from last publish.\n    // with custom getter to return whole struct at once instead of default solidity getter splitting it into tuple\n    MerkleCycle internal _currentMerkleCycle;\n\n    // ----------------------- slot 7-9 ---------------------------\n\n    /// @dev merkle root data related to pending cycle (proposed but not yet approved).\n    /// @dev timestamp & publishBlock = data from last propose.\n    // with custom getter to return whole struct at once instead of default solidity getter splitting it into tuple\n    MerkleCycle internal _pendingMerkleCycle;\n\n    // ----------------------- slot 10 ---------------------------\n\n    /// @notice merkle root of the previous cycle\n    bytes32 public previousMerkleRoot;\n\n    // ----------------------- slot 11 ---------------------------\n\n    /// @notice total claimed amount per user address and fToken. user => positionId => claimed amount\n    mapping(address => mapping(bytes32 => uint256)) public claimed;\n\n    constructor(address owner_, address rewardToken_) Constants(rewardToken_) Owned(owner_) {}\n}\n"
    },
    "solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
    },
    "solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}