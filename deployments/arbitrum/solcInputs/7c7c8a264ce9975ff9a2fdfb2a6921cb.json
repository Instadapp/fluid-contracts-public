{
  "language": "Solidity",
  "sources": {
    "contracts/config/dexFeeHandler/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nimport { DexSlotsLink } from \"../../libraries/dexSlotsLink.sol\";\nimport { IFluidDexT1 } from \"../../protocols/dex/interfaces/iDexT1.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\n\ninterface IFluidDexT1Admin {\n    /// @notice sets a new fee and revenue cut for a certain dex\n    /// @param fee_ new fee (scaled so that 1% = 10000)\n    /// @param revenueCut_ new revenue cut\n    function updateFeeAndRevenueCut(uint fee_, uint revenueCut_) external;\n}\n\nabstract contract Events {\n    /// @notice emitted when rebalancer successfully changes the fee and revenue cut\n    event LogRebalanceFeeAndRevenueCut(address dex, uint fee, uint revenueCut);\n}\n\nabstract contract Constants {\n    // 1% = 10000\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n\n    uint256 internal constant SCALE = 1e27;\n\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X17 = 0x1ffff;\n    uint256 internal constant X40 = 0xffffffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 public immutable MIN_FEE; // e.g. 10 -> 0.001%\n    uint256 public immutable MAX_FEE; // e.g. 100 -> 0.01%\n    uint256 public immutable MIN_DEVIATION; // in 1e27 scale, e.g. 3e23 -> 0.003\n    uint256 public immutable MAX_DEVIATION; // in 1e27 scale, e.g. 1e24 -> 0.01\n\n    uint256 public immutable UPDATE_FEE_TRIGGER_BUFFER = 10; // e.g. 1e4 -> 1%\n\n    // USDC-USDT dex\n    address public immutable DEX;\n\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n}\n\nabstract contract DynamicFee is Constants, Error, Events {\n    constructor(uint256 _minFee, uint256 _maxFee, uint256 _minDeviation, uint256 _maxDeviation) {\n        // check for zero values\n        if (_minFee == 0 || _maxFee == 0 || _minDeviation == 0 || _maxDeviation == 0)\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\n\n        // check that max fee is not greater or equal to 1%\n        if (_maxFee >= 1e4) revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\n\n        // check that min deviation is not greater than max deviation\n        if (_minDeviation > _maxDeviation) revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\n\n        // check that min fee is not greater than max fee\n        if (_minFee > _maxFee) revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\n\n        MIN_FEE = _minFee;\n        MAX_FEE = _maxFee;\n        MIN_DEVIATION = _minDeviation;\n        MAX_DEVIATION = _maxDeviation;\n    }\n\n    function _getDeviationFromPrice(uint256 price_) internal pure returns (uint256) {\n        // Absolute deviation from 1e27\n        return price_ > SCALE ? price_ - SCALE : SCALE - price_;\n    }\n\n    function dynamicFeeFromPrice(uint256 price) external view returns (uint256) {\n        return _computeDynamicFee(_getDeviationFromPrice(price));\n    }\n\n    function dynamicFeeFromDeviation(uint256 deviation) external view returns (uint256) {\n        return _computeDynamicFee(deviation);\n    }\n\n    /**\n     * @dev Internal helper that implements a smooth-step curve for fee calculation\n     * @param deviation Deviation from the target price in SCALE (1e27)\n     * @return Fee in basis points (1e4 = 1%)\n     */\n    function _computeDynamicFee(uint256 deviation) internal view returns (uint256) {\n        if (deviation <= MIN_DEVIATION) {\n            return MIN_FEE;\n        } else if (deviation >= MAX_DEVIATION) {\n            return MAX_FEE;\n        } else {\n            // Calculate normalized position between min and max deviation (0 to 1 in SCALE)\n            uint256 alpha = ((deviation - MIN_DEVIATION) * SCALE) / (MAX_DEVIATION - MIN_DEVIATION);\n\n            // Smooth step formula: 3x² - 2x³\n            // https://en.wikipedia.org/wiki/Smoothstep\n            uint256 alpha2 = _scaleMul(alpha, alpha);\n            uint256 alpha3 = _scaleMul(alpha2, alpha);\n\n            uint256 smooth = _scaleMul(3 * SCALE, alpha2) - _scaleMul(2 * SCALE, alpha3);\n\n            uint256 feeDelta = MAX_FEE - MIN_FEE;\n            uint256 interpolatedFee = MIN_FEE + (_scaleMul(smooth, feeDelta));\n\n            return interpolatedFee;\n        }\n    }\n\n    function _scaleMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * b) / SCALE;\n    }\n}\n\ncontract FluidDexFeeHandler is DynamicFee {\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\n        }\n        _;\n    }\n\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(\n        IFluidReserveContract reserveContract_,\n        uint256 minFee_,\n        uint256 maxFee_,\n        uint256 minDeviation_,\n        uint256 maxDeviation_,\n        address dex_\n    )\n        validAddress(dex_)\n        validAddress(address(reserveContract_))\n        DynamicFee(minFee_, maxFee_, minDeviation_, maxDeviation_)\n    {\n        RESERVE_CONTRACT = reserveContract_;\n        DEX = dex_;\n    }\n\n    /// @notice returns the fee for the dex\n    function getDexFee() public view returns (uint256 fee_) {\n        uint256 dexVariables2_ = IFluidDexT1(DEX).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        return (dexVariables2_ >> 2) & X17;\n    }\n\n    /// @notice returns the revenue cut for the dex\n    function getDexRevenueCut() public view returns (uint256 revenueCut_) {\n        uint256 dexVariables2_ = IFluidDexT1(DEX).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        return (dexVariables2_ >> 19) & X7;\n    }\n\n    /// @notice returns the fee and revenue cut for the dex\n    function getDexFeeAndRevenueCut() public view returns (uint256 fee_, uint256 revenueCut_) {\n        uint256 dexVariables2_ = IFluidDexT1(DEX).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        fee_ = (dexVariables2_ >> 2) & X17;\n        revenueCut_ = (dexVariables2_ >> 19) & X7;\n    }\n\n    /// @notice returns the last stored prices of the pool and the last interaction time stamp\n    function getDexVariable()\n        public\n        view\n        returns (uint256 lastToLastStoredPrice_, uint256 lastStoredPriceOfPool_, uint256 lastInteractionTimeStamp_)\n    {\n        uint256 dexVariables_ = IFluidDexT1(DEX).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES_SLOT));\n\n        lastToLastStoredPrice_ = (dexVariables_ >> 1) & X40;\n        lastToLastStoredPrice_ =\n            (lastToLastStoredPrice_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastToLastStoredPrice_ & DEFAULT_EXPONENT_MASK);\n\n        lastStoredPriceOfPool_ = (dexVariables_ >> 41) & X40;\n        lastStoredPriceOfPool_ =\n            (lastStoredPriceOfPool_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastStoredPriceOfPool_ & DEFAULT_EXPONENT_MASK);\n\n        lastInteractionTimeStamp_ = (dexVariables_ >> 121) & X33;\n    }\n\n    /// @notice returns the dynamic fee for the dex based on the last stored price of the pool\n    function getDexDynamicFees() public view returns (uint256) {\n        (\n            uint256 lastToLastStoredPrice_,\n            uint256 lastStoredPriceOfPool_,\n            uint256 lastInteractionTimeStamp_\n        ) = getDexVariable();\n\n        if (lastInteractionTimeStamp_ == block.timestamp) lastStoredPriceOfPool_ = lastToLastStoredPrice_;\n\n        return _computeDynamicFee(_getDeviationFromPrice(lastStoredPriceOfPool_));\n    }\n\n    /// @notice rebalances the fee\n    function rebalance() external onlyRebalancer {\n        uint256 newFee_ = getDexDynamicFees();\n\n        (uint256 currentFee_, uint256 currentRevenueCut_) = getDexFeeAndRevenueCut();\n\n        uint256 feePercentageChange_ = _configPercentDiff(currentFee_, newFee_);\n\n        // should be more than 0.001% to update\n        if (feePercentageChange_ > UPDATE_FEE_TRIGGER_BUFFER) {\n            IFluidDexT1Admin(DEX).updateFeeAndRevenueCut(newFee_, currentRevenueCut_ * FOUR_DECIMALS);\n            emit LogRebalanceFeeAndRevenueCut(DEX, newFee_, currentRevenueCut_ * FOUR_DECIMALS);\n        } else {\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__FeeUpdateNotRequired);\n        }\n    }\n\n    /// @notice returns how much new config would be different from current config in percent (100 = 1%, 1 = 0.01%).\n    function configPercentDiff() public view returns (uint256) {\n        uint256 newFee_ = getDexDynamicFees();\n        (uint256 currentFee_, ) = getDexFeeAndRevenueCut();\n\n        return _configPercentDiff(currentFee_, newFee_);\n    }\n\n    function _configPercentDiff(\n        uint256 currentFee_,\n        uint256 newFee_\n    ) internal pure returns (uint256 configPercentDiff_) {\n        if (currentFee_ == newFee_) {\n            return 0;\n        }\n\n        if (currentFee_ > newFee_) configPercentDiff_ = currentFee_ - newFee_;\n        else configPercentDiff_ = newFee_ - currentFee_;\n\n        return (configPercentDiff_ * FOUR_DECIMALS) / currentFee_;\n    }\n}\n"
    },
    "contracts/config/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Error {\n    error FluidConfigError(uint256 errorId_);\n}\n"
    },
    "contracts/config/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |    ExpandPercentConfigHandler     | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant ExpandPercentConfigHandler__AddressZero = 100001;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant ExpandPercentConfigHandler__Unauthorized = 100002;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant ExpandPercentConfigHandler__InvalidParams = 100003;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant ExpandPercentConfigHandler__NoUpdate = 100004;\n\n    /// @notice thrown when slot is not used, e.g. when borrow token is 0 there is no borrow data\n    uint256 internal constant ExpandPercentConfigHandler__SlotDoesNotExist = 100005;\n\n    /***********************************|\n    |      EthenaRateConfigHandler      | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant EthenaRateConfigHandler__AddressZero = 100011;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant EthenaRateConfigHandler__Unauthorized = 100012;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant EthenaRateConfigHandler__InvalidParams = 100013;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant EthenaRateConfigHandler__NoUpdate = 100014;\n\n    /***********************************|\n    |       MaxBorrowConfigHandler      | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant MaxBorrowConfigHandler__AddressZero = 100021;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant MaxBorrowConfigHandler__Unauthorized = 100022;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant MaxBorrowConfigHandler__InvalidParams = 100023;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant MaxBorrowConfigHandler__NoUpdate = 100024;\n\n    /***********************************|\n    |       BufferRateConfigHandler     | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant BufferRateConfigHandler__AddressZero = 100031;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant BufferRateConfigHandler__Unauthorized = 100032;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant BufferRateConfigHandler__InvalidParams = 100033;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant BufferRateConfigHandler__NoUpdate = 100034;\n\n    /// @notice thrown when rate data version is not supported\n    uint256 internal constant BufferRateConfigHandler__RateVersionUnsupported = 100035;\n\n    /***********************************|\n    |          FluidRatesAuth           | \n    |__________________________________*/\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant RatesAuth__NoUpdate = 100041;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant RatesAuth__Unauthorized = 100042;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant RatesAuth__InvalidParams = 100043;\n\n    /// @notice thrown when cooldown is not yet expired\n    uint256 internal constant RatesAuth__CooldownLeft = 100044;\n\n    /// @notice thrown when version is invalid\n    uint256 internal constant RatesAuth__InvalidVersion = 100045;\n\n    /***********************************|\n    |          ListTokenAuth            | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant ListTokenAuth__Unauthorized = 100051;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant ListTokenAuth_AlreadyInitialized = 100052;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant ListTokenAuth__InvalidParams = 100053;\n\n    /***********************************|\n    |       CollectRevenueAuth          | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant CollectRevenueAuth__Unauthorized = 100061;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant CollectRevenueAuth__InvalidParams = 100062;\n\n    /***********************************|\n    |       FluidWithdrawLimitAuth      | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant WithdrawLimitAuth__NoUserSupply = 100071;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant WithdrawLimitAuth__Unauthorized = 100072;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant WithdrawLimitAuth__InvalidParams = 100073;\n\n    /// @notice thrown when no more withdrawal limit can be set for the day\n    uint256 internal constant WithdrawLimitAuth__DailyLimitReached = 100074;\n\n    /// @notice thrown when no more withdrawal limit can be set for the hour\n    uint256 internal constant WithdrawLimitAuth__HourlyLimitReached = 100075;\n\n    /// @notice thrown when the withdrawal limit and userSupply difference exceeds 5%\n    uint256 internal constant WithdrawLimitAuth__ExcessPercentageDifference = 100076;\n\n    /***********************************|\n    |       DexFeeHandler               | \n    |__________________________________*/\n\n    /// @notice thrown when fee update is not required\n    uint256 internal constant DexFeeHandler__FeeUpdateNotRequired = 100081;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant DexFeeHandler__InvalidParams = 100082;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls\n    uint256 internal constant DexFeeHandler__Unauthorized = 100083;\n}\n"
    },
    "contracts/infiniteProxy/interfaces/iProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IProxy {\n    function setAdmin(address newAdmin_) external;\n\n    function setDummyImplementation(address newDummyImplementation_) external;\n\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\n\n    function removeImplementation(address implementation_) external;\n\n    function getAdmin() external view returns (address);\n\n    function getDummyImplementation() external view returns (address);\n\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\n\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/libraries/bigMathMinified.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\nlibrary BigMathMinified {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/dexSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\nlibrary DexSlotsLink {\n    /// @dev storage slot for variables at Dex\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\n    /// @dev storage slot for variables2 at Dex\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\n    /// @dev storage slot for total supply shares at Dex\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\n    /// @dev storage slot for user supply mapping at Dex\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\n    /// @dev storage slot for total borrow shares at Dex\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\n    /// @dev storage slot for user borrow mapping at Dex\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\n    /// @dev storage slot for oracle mapping at Dex\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\n    /// @dev storage slot for range and threshold shifts at Dex\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\n    /// @dev storage slot for center price shift at Dex\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n\n    /***********************************|\n    |           SafeApprove             | \n    |__________________________________*/\n\n    /// @notice thrown when safe approve from for an ERC20 fails\n    uint256 internal constant SafeApprove__ApproveFailed = 81001;\n}\n"
    },
    "contracts/libraries/fluidProtocolTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ninterface IFluidProtocol {\n    function TYPE() external view returns (uint256);\n}\n\n/// @notice implements helper methods to filter Fluid protocols by a certain type\nlibrary FluidProtocolTypes {\n    uint256 internal constant VAULT_T1_TYPE = 10000; // VaultT1 borrow protocol type vaults\n    uint256 internal constant VAULT_T2_SMART_COL_TYPE = 20000; // DEX protocol type vault\n    uint256 internal constant VAULT_T3_SMART_DEBT_TYPE = 30000; // DEX protocol type vault\n    uint256 internal constant VAULT_T4_SMART_COL_SMART_DEBT_TYPE = 40000; // DEX protocol type vault\n\n    /// @dev filters input `addresses_` by protocol `type_`. Input addresses must be actual Fluid protocols, otherwise\n    ///      they would be wrongly assumed to be VaultT1 even if they are not Fluid VaultT1 smart contracts.\n    ///      `type_` must be a listed constant type of this library.\n    ///      Example usage is to filter all vault addresses at the Vault factory by a certain type, e.g. to not include\n    ///      DEX protocol type vaults.\n    function filterBy(address[] memory addresses_, uint256 type_) internal view returns (address[] memory filtered_) {\n        uint256 curType_;\n        uint256 filteredProtocols_ = addresses_.length;\n        for (uint256 i; i < addresses_.length; ) {\n            try IFluidProtocol(addresses_[i]).TYPE() returns (uint256 protocolType_) {\n                curType_ = protocolType_;\n            } catch {\n                curType_ = VAULT_T1_TYPE;\n            }\n\n            if (curType_ != type_) {\n                addresses_[i] = address(0);\n                --filteredProtocols_;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        filtered_ = new address[](filteredProtocols_);\n        uint256 index_;\n        unchecked {\n            for (uint256 i; i < addresses_.length; ) {\n                if (addresses_[i] != address(0)) {\n                    filtered_[index_] = addresses_[i];\n                    ++index_;\n                }\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/liquidityCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\nimport { LiquiditySlotsLink } from \"./liquiditySlotsLink.sol\";\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\n\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\n/// borrow rate, withdrawal / borrow limits, revenue amount.\nlibrary LiquidityCalcs {\n    error FluidLiquidityCalcsError(uint256 errorId_);\n\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\n    event BorrowRateMaxCap();\n\n    /// @dev constants as from Liquidity variables.sol\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X15 = 0x7fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                  CALC EXCHANGE PRICES                  /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\n    function calcExchangePrices(\n        uint256 exchangePricesAndConfig_\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\n        // Extracting exchange prices\n        supplyExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\n            X64;\n        borrowExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\n            X64;\n\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\n        }\n\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\n\n        unchecked {\n            // last timestamp can not be > current timestamp\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\n\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\n                X15;\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // calculate new borrow exchange price.\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\n            borrowExchangePrice_ +=\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\n\n            // FOR SUPPLY EXCHANGE PRICE:\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\n            //\n            // Example:\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\n            // yield is 10 (so half a year must have passed).\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 20%) = 62,5%\n            // supplyRate = (40% * (100% - 10%)) * = 36% * 62,5% = 22.5%\n            // increase in supplyExchangePrice, assuming 100 as previous price.\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\n\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\n\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\n\n            if (temp_ == 1) {\n                // if no raw supply: no exchange price update needed\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\n            if (temp_ & 1 == 1) {\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n                temp_ = temp_ >> 1;\n\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\n                // in the if statement a little above.\n\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\n                // so ratioSupplyYield must come out as 2.5 (250%).\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\n                temp_ =\n                    // utilization * (100% + 100% / supplyRatio)\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\n                    (FOUR_DECIMALS);\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\n            } else {\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n                temp_ = temp_ >> 1;\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\n\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\n                temp_ =\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\n                    (1e27 *\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\n                        (FOUR_DECIMALS + temp_)) /\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\n            }\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\n\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\n            if (borrowRatio_ & 1 == 1) {\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\n\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\n            } else {\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\n            }\n\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\n\n            // 2. calculate supply rate\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\n            // but more suppliers not earning interest.\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\n                temp_ * // ratioSupplyYield\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\n\n            // 3. calculate increase in supply exchange price\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                     CALC REVENUE                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\n    /// and the current balance of the Fluid liquidity contract for the token.\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\n    /// @return revenueAmount_ collectable revenue amount\n    function calcRevenue(\n        uint256 totalAmounts_,\n        uint256 exchangePricesAndConfig_,\n        uint256 liquidityTokenBalance_\n    ) internal view returns (uint256 revenueAmount_) {\n        // @dev no need to super-optimize this method as it is only used by admin\n\n        // calculate the new exchange prices based on earned interest\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\n\n        // total supply = interest free + with interest converted from raw\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\n\n        if (totalSupply_ > 0) {\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\n            // ensure there is no possible case because of rounding etc. where this would revert,\n            // explicitly check if >\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\n            // can only be revenue.\n        } else {\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\n            revenueAmount_ = liquidityTokenBalance_;\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ =\n                block.timestamp -\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ =\n                block.timestamp -\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC RATES                        /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev Calculates new borrow rate from utilization for a token\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\n        // extract rate version: 4 bits (0xF) starting from bit 0\n        uint256 rateVersion_ = (rateData_ & 0xF);\n\n        if (rateVersion_ == 1) {\n            rate_ = calcRateV1(rateData_, utilization_);\n        } else if (rateVersion_ == 2) {\n            rate_ = calcRateV2(rateData_, utilization_);\n        } else {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\n        }\n\n        if (rate_ > X16) {\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\n            // this is unlikely to ever happen if configs stay within expected levels.\n            rate_ = X16;\n            // emit event to more easily become aware\n            emit BorrowRateMaxCap();\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e2 precision\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v1 (one kink) ------------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // else utilization is greater than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\n            x1_ = kink1_;\n            x2_ = FOUR_DECIMALS; // 100%\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e4 precision\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v2 (two kinks) -----------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 156 bits => 100-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink1\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\n            if (utilization_ < kink2_) {\n                // if utilization is less than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                x1_ = kink1_;\n                x2_ = kink2_;\n            } else {\n                // else utilization is greater than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\n                x1_ = kink2_;\n                x2_ = FOUR_DECIMALS;\n            }\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\n    function getTotalSupply(\n        uint256 totalAmounts_,\n        uint256 supplyExchangePrice_\n    ) internal pure returns (uint256 totalSupply_) {\n        // totalSupply_ => supplyInterestFree\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\n    function getTotalBorrow(\n        uint256 totalAmounts_,\n        uint256 borrowExchangePrice_\n    ) internal pure returns (uint256 totalBorrow_) {\n        // totalBorrow_ => borrowInterestFree\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n}\n"
    },
    "contracts/libraries/liquiditySlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\nlibrary LiquiditySlotsLink {\n    /// @dev storage slot for status at Liquidity\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\n    /// @dev storage slot for auths mapping at Liquidity\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\n    /// @dev storage slot for guardians mapping at Liquidity\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\n    /// @dev storage slot for user class mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\n    /// @dev storage slot for rateData mapping at Liquidity\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\n    /// @dev storage slot for totalAmounts mapping at Liquidity\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\n    /// @dev storage slot for user supply double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\n    /// @dev storage slot for user borrow double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // ExchangePricesAndConfig\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\n\n    // RateData:\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\n    // RateData: V1\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\n    // RateData: V2\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\n\n    // TotalAmounts\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\n\n    // Configs2\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/liquidity/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    /// @notice struct to set borrow rate data for version 1\n    struct RateDataV1Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\n        uint256 kink;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink;\n        ///\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set borrow rate data for version 2\n    struct RateDataV2Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\n        uint256 kink1;\n        ///\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\n        uint256 kink2;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink1;\n        ///\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\n        uint256 rateAtUtilizationKink2;\n        ///\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set token config\n    struct TokenConfig {\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\n        uint256 fee;\n        ///\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\n        uint256 threshold;\n        ///\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\n        uint256 maxUtilization;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/liquidity/interfaces/iLiquidity.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IProxy } from \"../../infiniteProxy/interfaces/iProxy.sol\";\nimport { Structs as AdminModuleStructs } from \"../adminModule/structs.sol\";\n\ninterface IFluidLiquidityAdmin {\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\n    /// @param authsStatus_ array of structs setting allowed status for an address.\n    ///                     status true => add auth, false => remove auth\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\n\n    /// @notice adds/removes guardians. Only callable by Governance.\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\n    ///                         status true => add guardian, false => remove guardian\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\n\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\n    /// @param revenueCollector_  new revenue collector address\n    function updateRevenueCollector(address revenueCollector_) external;\n\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\n    /// @param newStatus_ new status\n    ///        status = 2 -> pause, status = 1 -> resume.\n    function changeStatus(uint256 newStatus_) external;\n\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\n\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\n\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\n    ///         Only callable by Auths.\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\n\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\n    ///         Only callable by Auths.\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\n\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param token_ token address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\n\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\n\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to pause operations for\n    /// @param supplyTokens_  token addresses to pause withdrawals for\n    /// @param borrowTokens_  token addresses to pause borrowings for\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to unpause operations for\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\n    /// @param borrowTokens_  token addresses to unpause borrowings for\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\n    /// @param tokens_  array of tokens to collect revenue for\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\n    function collectRevenue(address[] calldata tokens_) external;\n\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\n    /// @param tokens_ tokens to update exchange prices for\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\n    function updateExchangePrices(\n        address[] calldata tokens_\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\n}\n\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\n    /// @notice Single function which handles supply, withdraw, borrow & payback\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\n    /// @param withdrawTo_ if withdrawal then to which address\n    /// @param borrowTo_ if borrow then to which address\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\n    /// @return memVar3_ updated supplyExchangePrice\n    /// @return memVar4_ updated borrowExchangePrice\n    /// @dev to trigger skipping in / out transfers (gas optimization):\n    /// -  ` callbackData_` MUST be encoded so that \"from\" address is the last 20 bytes in the last 32 bytes slot,\n    ///     also for native token operations where liquidityCallback is not triggered!\n    ///     from address must come at last position if there is more data. I.e. encode like:\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\n    /// -   this \"from\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\n    ///     in the slot before (bytes 32 to 63)\n    /// -   `msg.value` must be 0.\n    /// -   Amounts must be either:\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\n}\n\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\n"
    },
    "contracts/periphery/resolvers/liquidity/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs as AdminModuleStructs } from \"../../../liquidity/adminModule/structs.sol\";\n\nabstract contract Structs {\n    struct RateData {\n        uint256 version;\n        AdminModuleStructs.RateDataV1Params rateDataV1;\n        AdminModuleStructs.RateDataV2Params rateDataV2;\n    }\n\n    struct OverallTokenData {\n        uint256 borrowRate;\n        uint256 supplyRate;\n        uint256 fee; // revenue fee\n        uint256 lastStoredUtilization;\n        uint256 storageUpdateThreshold;\n        uint256 lastUpdateTimestamp;\n        uint256 supplyExchangePrice;\n        uint256 borrowExchangePrice;\n        uint256 supplyRawInterest;\n        uint256 supplyInterestFree;\n        uint256 borrowRawInterest;\n        uint256 borrowInterestFree;\n        uint256 totalSupply;\n        uint256 totalBorrow;\n        uint256 revenue;\n        uint256 maxUtilization; // maximum allowed utilization\n        RateData rateData;\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserSupplyData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 supply; // user supply amount\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\n        uint256 withdrawalLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\n        uint256 baseWithdrawalLimit;\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\n        uint256 withdrawableUntilLimit;\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserBorrowData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 borrow; // user borrow amount\n        uint256 borrowLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseBorrowLimit;\n        uint256 maxBorrowLimit;\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vault/iVaultResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Structs } from \"./structs.sol\";\n\ninterface IFluidVaultResolver {\n    function vaultByNftId(uint nftId_) external view returns (address vault_);\n\n    function positionByNftId(\n        uint nftId_\n    ) external view returns (Structs.UserPosition memory userPosition_, Structs.VaultEntireData memory vaultData_);\n\n    function getVaultVariablesRaw(address vault_) external view returns (uint);\n\n    function getVaultVariables2Raw(address vault_) external view returns (uint);\n\n    function getTickHasDebtRaw(address vault_, int key_) external view returns (uint);\n\n    function getTickDataRaw(address vault_, int tick_) external view returns (uint);\n\n    function getBranchDataRaw(address vault_, uint branch_) external view returns (uint);\n\n    function getPositionDataRaw(address vault_, uint positionId_) external view returns (uint);\n\n    function getAllVaultsAddresses() external view returns (address[] memory vaults_);\n\n    function getVaultLiquidation(\n        address vault_,\n        uint tokenInAmt_\n    ) external returns (Structs.LiquidationStruct memory liquidationData_);\n\n    function getVaultEntireData(address vault_) external view returns (Structs.VaultEntireData memory vaultData_);\n}\n"
    },
    "contracts/periphery/resolvers/vault/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidVault } from \"../../../protocols/vault/interfaces/iVault.sol\";\nimport { Structs as FluidLiquidityResolverStructs } from \"../liquidity/structs.sol\";\n\n// @dev Amounts are always in token amount for normal col / normal debt or in\n// shares for Dex smart col / smart debt.\ncontract Structs {\n    struct Configs {\n        // can be supplyRate instead if Vault Type is smart col. in that case if 1st bit == 1 then positive else negative\n        uint16 supplyRateMagnifier;\n        // can be borrowRate instead if Vault Type is smart debt. in that case if 1st bit == 1 then positive else negative\n        uint16 borrowRateMagnifier;\n        uint16 collateralFactor;\n        uint16 liquidationThreshold;\n        uint16 liquidationMaxLimit;\n        uint16 withdrawalGap;\n        uint16 liquidationPenalty;\n        uint16 borrowFee;\n        address oracle;\n        // Oracle price is always debt per col, i.e. amount of debt for 1 col.\n        // In case of Dex this price can be used to resolve shares values w.r.t. token0 or token1:\n        // - T2: debt token per 1 col share\n        // - T3: debt shares per 1 col token\n        // - T4: debt shares per 1 col share\n        uint oraclePriceOperate;\n        uint oraclePriceLiquidate;\n        address rebalancer;\n        uint lastUpdateTimestamp;\n    }\n\n    struct ExchangePricesAndRates {\n        uint lastStoredLiquiditySupplyExchangePrice; // 0 in case of smart col\n        uint lastStoredLiquidityBorrowExchangePrice; // 0 in case of smart debt\n        uint lastStoredVaultSupplyExchangePrice;\n        uint lastStoredVaultBorrowExchangePrice;\n        uint liquiditySupplyExchangePrice; // set to 1e12 in case of smart col\n        uint liquidityBorrowExchangePrice; // set to 1e12 in case of smart debt\n        uint vaultSupplyExchangePrice;\n        uint vaultBorrowExchangePrice;\n        uint supplyRateLiquidity; // set to 0 in case of smart col. Must get per token through DexEntireData\n        uint borrowRateLiquidity; // set to 0 in case of smart debt. Must get per token through DexEntireData\n        // supplyRateVault or borrowRateVault:\n        // - when normal col / debt: rate at liquidity + diff rewards or fee through magnifier (rewardsOrFeeRate below)\n        // - when smart col / debt: rewards or fee rate at the vault itself. always == rewardsOrFeeRate below.\n        // to get the full rates for vault when smart col / debt, combine with data from DexResolver:\n        // - rateAtLiquidity for token0 or token1 (DexResolver)\n        // - the rewards or fee rate at the vault (VaultResolver)\n        // - the Dex APR (currently off-chain compiled through tracking swap events at the DEX)\n        int supplyRateVault; // can be negative in case of smart col (meaning pay to supply)\n        int borrowRateVault; // can be negative in case of smart debt (meaning get paid to borrow)\n        // rewardsOrFeeRateSupply: rewards or fee rate in percent 1e2 precision (1% = 100, 100% = 10000).\n        // positive rewards, negative fee.\n        // for smart col vaults: supplyRateVault == supplyRateLiquidity.\n        // for normal col vaults: relative percent to supplyRateLiquidity, e.g.:\n        // when rewards: supplyRateLiquidity = 4%, rewardsOrFeeRateSupply = 20%, supplyRateVault = 4.8%.\n        // when fee: supplyRateLiquidity = 4%, rewardsOrFeeRateSupply = -30%, supplyRateVault = 2.8%.\n        int rewardsOrFeeRateSupply;\n        // rewardsOrFeeRateBorrow: rewards or fee rate in percent 1e2 precision (1% = 100, 100% = 10000).\n        // negative rewards, positive fee.\n        // for smart debt vaults: borrowRateVault == borrowRateLiquidity.\n        // for normal debt vaults: relative percent to borrowRateLiquidity, e.g.:\n        // when rewards: borrowRateLiquidity = 4%, rewardsOrFeeRateBorrow = -20%, borrowRateVault = 3.2%.\n        // when fee: borrowRateLiquidity = 4%, rewardsOrFeeRateBorrow = 30%, borrowRateVault = 5.2%.\n        int rewardsOrFeeRateBorrow;\n    }\n\n    struct TotalSupplyAndBorrow {\n        uint totalSupplyVault;\n        uint totalBorrowVault;\n        uint totalSupplyLiquidityOrDex;\n        uint totalBorrowLiquidityOrDex;\n        uint absorbedSupply;\n        uint absorbedBorrow;\n    }\n\n    struct LimitsAndAvailability {\n        // in case of DEX: withdrawable / borrowable amount of vault at DEX, BUT there could be that DEX can not withdraw\n        // that much at Liquidity! So for DEX this must be combined with returned data in DexResolver.\n        uint withdrawLimit;\n        uint withdrawableUntilLimit;\n        uint withdrawable;\n        uint borrowLimit;\n        uint borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        uint borrowLimitUtilization; // borrow limit for `maxUtilization` config at Liquidity\n        uint minimumBorrowing;\n    }\n\n    struct CurrentBranchState {\n        uint status; // if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\n        int minimaTick;\n        uint debtFactor;\n        uint partials;\n        uint debtLiquidity;\n        uint baseBranchId;\n        int baseBranchMinima;\n    }\n\n    struct VaultState {\n        uint totalPositions;\n        int topTick;\n        uint currentBranch;\n        uint totalBranch;\n        uint totalBorrow;\n        uint totalSupply;\n        CurrentBranchState currentBranchState;\n    }\n\n    struct VaultEntireData {\n        address vault;\n        bool isSmartCol; // true if col token is a Fluid Dex\n        bool isSmartDebt; // true if debt token is a Fluid Dex\n        IFluidVault.ConstantViews constantVariables;\n        Configs configs;\n        ExchangePricesAndRates exchangePricesAndRates;\n        TotalSupplyAndBorrow totalSupplyAndBorrow;\n        LimitsAndAvailability limitsAndAvailability;\n        VaultState vaultState;\n        // liquidity related data such as supply amount, limits, expansion etc.\n        // Also set for Dex, limits are in shares and same things apply as noted for LimitsAndAvailability above!\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyData;\n        // liquidity related data such as borrow amount, limits, expansion etc.\n        // Also set for Dex, limits are in shares and same things apply as noted for LimitsAndAvailability above!\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowData;\n    }\n\n    struct UserPosition {\n        uint nftId;\n        address owner;\n        bool isLiquidated;\n        bool isSupplyPosition; // if true that means borrowing is 0\n        int tick;\n        uint tickId;\n        uint beforeSupply;\n        uint beforeBorrow;\n        uint beforeDustBorrow;\n        uint supply;\n        uint borrow;\n        uint dustBorrow;\n    }\n\n    /// @dev liquidation related data\n    /// @param vault address of vault\n    /// @param token0In address of token in\n    /// @param token0Out address of token out\n    /// @param token1In address of token in (if smart debt)\n    /// @param token1Out address of token out (if smart col)\n    /// @param inAmt (without absorb liquidity) minimum of available liquidation\n    /// @param outAmt (without absorb liquidity) expected token out, collateral to withdraw\n    /// @param inAmtWithAbsorb (absorb liquidity included) minimum of available liquidation. In most cases it'll be same as inAmt but sometimes can be bigger.\n    /// @param outAmtWithAbsorb (absorb liquidity included) expected token out, collateral to withdraw. In most cases it'll be same as outAmt but sometimes can be bigger.\n    /// @param absorbAvailable true if absorb is available\n    /// @dev Liquidity in with absirb will always be >= without asborb. Sometimes without asborb can provide better swaps,\n    ///      sometimes with absirb can provide better swaps. But available in with absirb will always be >= One\n    struct LiquidationStruct {\n        address vault;\n        address token0In;\n        address token0Out;\n        address token1In;\n        address token1Out;\n        // amounts in case of smart debt are in shares, otherwise token amounts.\n        // smart col can not be liquidated so to exchange inAmt always use DexResolver DexState.tokenPerDebtShare\n        // and tokenPerColShare for outAmt when Vault is smart col.\n        uint inAmt;\n        uint outAmt;\n        uint inAmtWithAbsorb;\n        uint outAmtWithAbsorb;\n        bool absorbAvailable;\n    }\n\n    struct AbsorbStruct {\n        address vault;\n        bool absorbAvailable;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultLiquidation/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\nimport { Variables } from \"./variables.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { FluidProtocolTypes } from \"../../../libraries/fluidProtocolTypes.sol\";\nimport { Structs as VaultResolverStructs } from \"../vault/structs.sol\";\nimport { IFluidVaultResolver } from \"../vault/iVaultResolver.sol\";\nimport { IFluidVaultT1 } from \"../../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { LiquiditySlotsLink } from \"../../../libraries/liquiditySlotsLink.sol\";\nimport { LiquidityCalcs } from \"../../../libraries/liquidityCalcs.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\n\ninterface TokenInterface {\n    function balanceOf(address) external view returns (uint);\n}\n\n/// @notice Resolver contract that helps in finding available token (liquidation) swaps available in Fluid VaultT1s.\n/// @dev    Note that on the same protocol, if \"withAbsorb = true\" is executed, this also consumes the swap\n///         that would be on the same protocol with \"withAbsorb = false\". So the total available swap amount\n///         at a protocol if both a swap with and without absorb is available is not `with inAmt + without inAmt`\n///         but rather `with inAmt`.\n///         Sometimes with absorb can provide better swaps, sometimes without absorb can provide better swaps.\n///         But available liquidity for \"withAbsorb\" amounts will always be >= without absorb amounts.\n/// @dev    The \"Raw\" methods return both the with and without absorb swaps for the same Fluid Vault, the non-\"Raw\"\n///         methods automatically filter by the better ratio swap. For same cases a better optimization of ratios\n///         is possible with custom logic based on the \"Raw\" methods, see details in comments.\n/// @dev    for native token, send 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE.\n/// @dev    returned swaps Struct can be fed into `getSwapTx` to prepare the tx that executes the swaps.\n/// @dev    non-view methods in this contract are expected to be called with callStatic,\n///         although they would anyway not do any actual state changes.\ncontract FluidVaultLiquidationResolver is Variables, Structs {\n    /// @notice thrown if an input param address is zero\n    error FluidVaultLiquidationsResolver__AddressZero();\n    /// @notice thrown if an invalid param is given to a method\n    error FluidVaultLiquidationsResolver__InvalidParams();\n\n    /// @notice constructor sets the immutable vault resolver address\n    constructor(IFluidVaultResolver vaultResolver_, IFluidLiquidity liquidity_) Variables(vaultResolver_, liquidity_) {\n        if (address(vaultResolver_) == address(0) || address(liquidity_) == address(0)) {\n            revert FluidVaultLiquidationsResolver__AddressZero();\n        }\n    }\n\n    /// @notice returns all available token swap paths\n    function getAllSwapPaths() public view returns (SwapPath[] memory paths_) {\n        address[] memory vaultAddresses_ = _getVaultT1s();\n        paths_ = new SwapPath[](vaultAddresses_.length);\n\n        address borrowToken_;\n        address supplyToken_;\n        for (uint256 i; i < vaultAddresses_.length; ++i) {\n            (borrowToken_, supplyToken_) = _getVaultTokens(vaultAddresses_[i]);\n            paths_[i] = SwapPath({ protocol: vaultAddresses_[i], tokenIn: borrowToken_, tokenOut: supplyToken_ });\n        }\n    }\n\n    /// @notice returns all swap paths for a certain `tokenIn_` swapped to a `tokenOut_`.\n    ///         returns empty array if no swap path is available for a given pair.\n    function getSwapPaths(address tokenIn_, address tokenOut_) public view returns (SwapPath[] memory paths_) {\n        address[] memory vaultAddresses_ = _getVaultT1s();\n\n        uint256 foundVaultsCount_;\n        address[] memory foundVaults_ = new address[](vaultAddresses_.length);\n\n        address borrowToken_;\n        address supplyToken_;\n        for (uint256 i; i < vaultAddresses_.length; ++i) {\n            (borrowToken_, supplyToken_) = _getVaultTokens(vaultAddresses_[i]);\n\n            if (borrowToken_ == tokenIn_ && supplyToken_ == tokenOut_) {\n                foundVaults_[foundVaultsCount_] = vaultAddresses_[i];\n                ++foundVaultsCount_;\n            }\n        }\n\n        paths_ = new SwapPath[](foundVaultsCount_);\n        for (uint256 i; i < foundVaultsCount_; ++i) {\n            paths_[i] = SwapPath({ protocol: foundVaults_[i], tokenIn: tokenIn_, tokenOut: tokenOut_ });\n        }\n    }\n\n    /// @notice returns all available swap paths for any `tokensIn_` to any `tokensOut_`.\n    function getAnySwapPaths(\n        address[] calldata tokensIn_,\n        address[] calldata tokensOut_\n    ) public view returns (SwapPath[] memory paths_) {\n        SwapPath[] memory maxPaths_ = new SwapPath[](tokensIn_.length * tokensOut_.length);\n\n        address[] memory vaultAddresses_ = _getVaultT1s();\n\n        uint256 matches_;\n\n        address borrowToken_;\n        address supplyToken_;\n        unchecked {\n            for (uint256 vi; vi < vaultAddresses_.length; ++vi) {\n                (borrowToken_, supplyToken_) = _getVaultTokens(vaultAddresses_[vi]);\n\n                // for each vault, iterate over all possible input params token combinations\n                for (uint256 i; i < tokensIn_.length; ++i) {\n                    for (uint256 j; j < tokensOut_.length; ++j) {\n                        if (borrowToken_ == tokensIn_[i] && supplyToken_ == tokensOut_[j]) {\n                            maxPaths_[matches_] = SwapPath({\n                                protocol: vaultAddresses_[vi],\n                                tokenIn: borrowToken_,\n                                tokenOut: supplyToken_\n                            });\n                            ++matches_;\n                        }\n                    }\n                }\n            }\n\n            paths_ = new SwapPath[](matches_);\n            for (uint256 i; i < matches_; ++i) {\n                paths_[i] = maxPaths_[i];\n            }\n        }\n    }\n\n    /// @notice returns the swap data for with and without absorb for a Fluid `vault_`.\n    function getVaultSwapData(\n        address vault_\n    ) public returns (SwapData memory withoutAbsorb_, SwapData memory withAbsorb_) {\n        VaultResolverStructs.LiquidationStruct memory liquidationData_ = VAULT_RESOLVER.getVaultLiquidation(vault_, 0);\n\n        withoutAbsorb_ = SwapData({\n            inAmt: liquidationData_.inAmt,\n            outAmt: liquidationData_.outAmt,\n            withAbsorb: false,\n            ratio: _calcRatio(liquidationData_.inAmt, liquidationData_.outAmt)\n        });\n\n        withAbsorb_ = SwapData({\n            inAmt: liquidationData_.inAmtWithAbsorb,\n            outAmt: liquidationData_.outAmtWithAbsorb,\n            withAbsorb: true,\n            ratio: _calcRatio(liquidationData_.inAmtWithAbsorb, liquidationData_.outAmtWithAbsorb)\n        });\n    }\n\n    /// @notice returns the swap data for with and without absorb for multiple Fluid `vaults_`.\n    function getVaultsSwapData(\n        address[] memory vaults_\n    ) public returns (SwapData[] memory withoutAbsorb_, SwapData[] memory withAbsorb_) {\n        withoutAbsorb_ = new SwapData[](vaults_.length);\n        withAbsorb_ = new SwapData[](vaults_.length);\n        for (uint256 i; i < vaults_.length; ++i) {\n            (withoutAbsorb_[i], withAbsorb_[i]) = getVaultSwapData(vaults_[i]);\n        }\n    }\n\n    /// @notice returns the swap data for with and without absorb for all Fluid vaults.\n    function getAllVaultsSwapData() public returns (SwapData[] memory withoutAbsorb_, SwapData[] memory withAbsorb_) {\n        return getVaultsSwapData(_getVaultT1s());\n    }\n\n    /// @notice returns the available swap amounts at a certain `protocol_`. Only returns non-zero swaps.\n    ///         For vault protocol considering both a swap that uses liquidation with absorb and without absorb.\n    function getSwapForProtocol(address protocol_) public returns (Swap memory swap_) {\n        if (protocol_ == address(0)) {\n            return swap_;\n        }\n\n        (address borrowToken_, address supplyToken_) = _getVaultTokens(protocol_);\n        (SwapData memory withoutAbsorb_, SwapData memory withAbsorb_) = getVaultSwapData(protocol_);\n\n        swap_ = _getSwapAccountingForWithdrawable(\n            Swap({\n                path: SwapPath({ protocol: protocol_, tokenIn: borrowToken_, tokenOut: supplyToken_ }),\n                data: _getBetterRatioSwapData(withoutAbsorb_, withAbsorb_)\n            }),\n            withAbsorb_.outAmt == 0 ? 0 : _getVaultT1Withdrawable(protocol_, supplyToken_)\n        );\n    }\n\n    /// @notice returns all available `swaps_` for multiple Fluid `vaults_` raw. Only returns non-zero swaps.\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\n    function getVaultsSwapRaw(address[] memory vaults_) public returns (Swap[] memory swaps_) {\n        unchecked {\n            uint256 nonZeroSwaps_;\n            Swap[] memory allSwaps_ = new Swap[](vaults_.length * 2);\n\n            SwapData memory withoutAbsorb_;\n            SwapData memory withAbsorb_;\n            address borrowToken_;\n            address supplyToken_;\n            uint256 withdrawable_;\n            for (uint256 i; i < vaults_.length; ++i) {\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(vaults_[i]);\n                if (withAbsorb_.inAmt == 0) {\n                    // if with absorb is 0, then without absorb can only be 0 too\n                    continue;\n                }\n                (borrowToken_, supplyToken_) = _getVaultTokens(vaults_[i]);\n                withdrawable_ = _getVaultT1Withdrawable(vaults_[i], supplyToken_);\n                if (withdrawable_ == 0) {\n                    continue;\n                }\n                ++nonZeroSwaps_;\n                if (withAbsorb_.inAmt == withoutAbsorb_.inAmt) {\n                    // with absorb has the same liquidity as without absorb.\n                    // running liquidate() with absorb in that case only costs extra gas. return only without absorb swap\n                    withAbsorb_.inAmt = 0;\n                } else if (withoutAbsorb_.inAmt > 0) {\n                    // both with and without absorb swaps\n                    ++nonZeroSwaps_;\n                }\n\n                allSwaps_[i * 2] = _getSwapAccountingForWithdrawable(\n                    Swap({\n                        path: SwapPath({ protocol: vaults_[i], tokenIn: borrowToken_, tokenOut: supplyToken_ }),\n                        data: withoutAbsorb_\n                    }),\n                    withdrawable_\n                );\n                allSwaps_[i * 2 + 1] = _getSwapAccountingForWithdrawable(\n                    Swap({\n                        path: SwapPath({ protocol: vaults_[i], tokenIn: borrowToken_, tokenOut: supplyToken_ }),\n                        data: withAbsorb_\n                    }),\n                    withdrawable_\n                );\n            }\n\n            return _getNonZeroSwaps(allSwaps_, nonZeroSwaps_);\n        }\n    }\n\n    /// @notice returns all available `swaps_` for all Fluid vaults raw. Only returns non-zero swaps.\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\n    function getAllVaultsSwapRaw() public returns (Swap[] memory swaps_) {\n        return getVaultsSwapRaw(_getVaultT1s());\n    }\n\n    /// @notice returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\n    function getSwapsForPathsRaw(SwapPath[] memory paths_) public returns (Swap[] memory swaps_) {\n        unchecked {\n            Swap[] memory allSwaps_ = new Swap[](paths_.length * 2);\n\n            uint256 nonZeroSwaps_;\n            SwapData memory withoutAbsorb_;\n            SwapData memory withAbsorb_;\n            uint256 withdrawable_;\n            for (uint256 i; i < paths_.length; ++i) {\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(paths_[i].protocol);\n\n                if (withAbsorb_.inAmt == 0) {\n                    // if with absorb is 0, then without absorb can only be 0 too\n                    continue;\n                }\n                withdrawable_ = _getVaultT1Withdrawable(paths_[i].protocol, paths_[i].tokenOut);\n                if (withdrawable_ == 0) {\n                    continue;\n                }\n                ++nonZeroSwaps_;\n                if (withAbsorb_.inAmt == withoutAbsorb_.inAmt) {\n                    // with absorb has the same liquidity as without absorb.\n                    // running liquidate() with absorb in that case only costs extra gas. return only without absorb swap\n                    withAbsorb_.inAmt = 0;\n                } else if (withoutAbsorb_.inAmt > 0) {\n                    // both with and without absorb swaps\n                    ++nonZeroSwaps_;\n                }\n\n                allSwaps_[i * 2] = _getSwapAccountingForWithdrawable(\n                    Swap({ path: paths_[i], data: withoutAbsorb_ }),\n                    withdrawable_\n                );\n\n                allSwaps_[i * 2 + 1] = _getSwapAccountingForWithdrawable(\n                    Swap({ path: paths_[i], data: withAbsorb_ }),\n                    withdrawable_\n                );\n            }\n\n            swaps_ = new Swap[](nonZeroSwaps_);\n            uint256 index_;\n            for (uint256 i; i < allSwaps_.length; ++i) {\n                if (allSwaps_[i].data.inAmt > 0) {\n                    swaps_[index_] = allSwaps_[i];\n                    ++index_;\n                }\n            }\n        }\n    }\n\n    /// @notice finds all available `swaps_` for `tokenIn_` to `tokenOut_`.\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\n    function getSwapsRaw(address tokenIn_, address tokenOut_) public returns (Swap[] memory swaps_) {\n        return getSwapsForPathsRaw(getSwapPaths(tokenIn_, tokenOut_));\n    }\n\n    /// @notice finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.\n    ///         Token pairs that are not available or where available swap amounts are zero\n    ///         will not be present in the returned `swaps_` array.\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\n    function getAnySwapsRaw(\n        address[] calldata tokensIn_,\n        address[] calldata tokensOut_\n    ) public returns (Swap[] memory swaps_) {\n        return getSwapsForPathsRaw(getAnySwapPaths(tokensIn_, tokensOut_));\n    }\n\n    /// @notice returns all available `swaps_` for multiple Fluid `vaults_`. Only returns non-zero swaps.\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\n    ///         better ratio.\n    function getVaultsSwap(address[] memory vaults_) public returns (Swap[] memory swaps_) {\n        unchecked {\n            uint256 nonZeroSwaps_;\n            Swap[] memory allSwaps_ = new Swap[](vaults_.length);\n\n            SwapData memory withoutAbsorb_;\n            SwapData memory withAbsorb_;\n            Swap memory swap_;\n            uint256 withdrawable_;\n            for (uint256 i; i < vaults_.length; ++i) {\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(vaults_[i]);\n                swap_ = Swap({\n                    path: SwapPath({ protocol: vaults_[i], tokenIn: address(0), tokenOut: address(0) }),\n                    data: _getBetterRatioSwapData(withoutAbsorb_, withAbsorb_)\n                });\n\n                if (swap_.data.inAmt == 0) {\n                    // no swap available on this vault\n                    continue;\n                }\n                (swap_.path.tokenIn, swap_.path.tokenOut) = _getVaultTokens(vaults_[i]);\n                withdrawable_ = _getVaultT1Withdrawable(swap_.path.protocol, swap_.path.tokenOut);\n                if (withdrawable_ == 0) {\n                    continue;\n                }\n\n                ++nonZeroSwaps_;\n\n                allSwaps_[i] = _getSwapAccountingForWithdrawable(swap_, withdrawable_);\n            }\n\n            return _getNonZeroSwaps(allSwaps_, nonZeroSwaps_);\n        }\n    }\n\n    /// @notice returns all available `swaps_` for all Fluid vaults. Only returns non-zero swaps.\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\n    ///         better ratio.\n    function getAllVaultsSwap() public returns (Swap[] memory swaps_) {\n        return getVaultsSwap(_getVaultT1s());\n    }\n\n    /// @notice returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\n    ///         better ratio.\n    function getSwapsForPaths(SwapPath[] memory paths_) public returns (Swap[] memory swaps_) {\n        unchecked {\n            Swap[] memory allSwaps_ = new Swap[](paths_.length);\n\n            uint256 nonZeroSwaps_;\n            Swap memory swap_;\n            SwapData memory withoutAbsorb_;\n            SwapData memory withAbsorb_;\n            uint256 withdrawable_;\n            for (uint256 i; i < paths_.length; ++i) {\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(paths_[i].protocol);\n                swap_ = Swap({ path: paths_[i], data: _getBetterRatioSwapData(withoutAbsorb_, withAbsorb_) });\n\n                if (swap_.data.inAmt == 0) {\n                    // no swap available on this vault\n                    continue;\n                }\n                withdrawable_ = _getVaultT1Withdrawable(swap_.path.protocol, swap_.path.tokenOut);\n                if (withdrawable_ == 0) {\n                    continue;\n                }\n\n                ++nonZeroSwaps_;\n\n                allSwaps_[i] = _getSwapAccountingForWithdrawable(swap_, withdrawable_);\n            }\n\n            return _getNonZeroSwaps(allSwaps_, nonZeroSwaps_);\n        }\n    }\n\n    /// @notice finds all available `swaps_` for `tokenIn_` to `tokenOut_`.\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\n    ///         better ratio.\n    function getSwaps(address tokenIn_, address tokenOut_) public returns (Swap[] memory swaps_) {\n        return getSwapsForPaths(getSwapPaths(tokenIn_, tokenOut_));\n    }\n\n    /// @notice finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.\n    ///         Token pairs that are not available or where available swap amounts are zero\n    ///         will not be present in the returned `swaps_` array.\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\n    ///         better ratio.\n    function getAnySwaps(\n        address[] calldata tokensIn_,\n        address[] calldata tokensOut_\n    ) public returns (Swap[] memory swaps_) {\n        return getSwapsForPaths(getAnySwapPaths(tokensIn_, tokensOut_));\n    }\n\n    /// @notice returns the calldata to execute a swap as returned by the other methods in this contract.\n    ///         `swap_.data.inAmt` must come from msg.sender, `swap_.data.outAmt` goes to `receiver_`. If the input token\n    ///         is the native token, msg.value must be sent along when triggering the actual call with the returned calldata\n    ///         which should be `swap_.data.inAmt`.\n    /// @param swap_ Swap struct as returned by other methods\n    /// @param receiver_ receiver address that the output token is sent to\n    /// @param slippage_ maximum allowed slippage for the expected output token amount. Reverts iIf received token out\n    ///                  amount is lower than this. in 1e4 percentage, e.g. 1% = 10000, 0.3% = 3000, 0.01% = 100, 0.0001% = 1.\n    /// @return target_ target address where `calldata_` must be executed\n    /// @return calldata_ the calldata that can be used to trigger the liquidation call, resulting in the desired swap.\n    function getSwapTx(\n        Swap calldata swap_,\n        address receiver_,\n        uint256 slippage_\n    ) public pure returns (address target_, bytes memory calldata_) {\n        if (swap_.path.protocol == address(0) || receiver_ == address(0)) {\n            revert FluidVaultLiquidationsResolver__AddressZero();\n        }\n        if (slippage_ >= 1e6 || swap_.data.inAmt == 0 || swap_.data.outAmt == 0) {\n            revert FluidVaultLiquidationsResolver__InvalidParams();\n        }\n\n        uint256 colPerUnitDebt_ = (swap_.data.outAmt * 1e18) / swap_.data.inAmt;\n        colPerUnitDebt_ = (colPerUnitDebt_ * (1e6 - slippage_)) / 1e6; // e.g. 50 * 99% / 100% = 49.5\n\n        calldata_ = abi.encodeWithSelector(\n            IFluidVaultT1(swap_.path.protocol).liquidate.selector,\n            swap_.data.inAmt,\n            colPerUnitDebt_,\n            receiver_,\n            swap_.data.withAbsorb\n        );\n        target_ = swap_.path.protocol;\n    }\n\n    /// @notice returns the same data as `getSwapTx` for an array of input `swaps_` at once.\n    function getSwapTxs(\n        Swap[] calldata swaps_,\n        address receiver_,\n        uint256 slippage_\n    ) public pure returns (address[] memory targets_, bytes[] memory calldatas_) {\n        targets_ = new address[](swaps_.length);\n        calldatas_ = new bytes[](swaps_.length);\n        for (uint256 i; i < swaps_.length; ++i) {\n            (targets_[i], calldatas_[i]) = getSwapTx(swaps_[i], receiver_, slippage_);\n        }\n    }\n\n    /// @notice finds all swaps from `tokenIn_` to `tokenOut_` for an exact input amount `inAmt_`.\n    ///         filters the available swaps and sorts them by ratio, so the returned swaps are the best available\n    ///         swaps to reach the target `inAmt_`.\n    ///         If the full available amount is less than the target `inAmt_`, the available amount is returned as `actualInAmt_`.\n    /// @dev The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better\n    /// but the target swap amount is more than the available without absorb liquidity. For this, currently the available\n    /// withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity.\n    /// The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false\n    /// to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing\n    /// amount up to the target amount with the worse ratio with absorb liquidity.\n    /// @param tokenIn_ input token\n    /// @param tokenOut_ output token\n    /// @param inAmt_ exact input token amount that should be swapped to output token\n    /// @return swaps_ swaps to reach the target amount, sorted by ratio in descending order\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\n    /// @return actualInAmt_ actual input token amount. Can be less than inAmt_ if all available swaps can not cover\n    ///                      the target amount.\n    /// @return outAmt_ output token amount received for `actualInAmt_`\n    function exactInput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 inAmt_\n    ) public returns (Swap[] memory swaps_, uint256 actualInAmt_, uint256 outAmt_) {\n        return filterToTargetInAmt(getSwapsRaw(tokenIn_, tokenOut_), inAmt_);\n    }\n\n    /// @notice finds all swaps from `tokenIn_` to `tokenOut_` for an APPROXIMATE output amount `outAmt_`.\n    ///         filters the available swaps and sorts them by ratio, so the returned swaps are the best available\n    ///         swaps to reach the target `outAmt_`.\n    ///         If the full available amount is less than the target `outAmt_`, the available amount is returned as `actualOutAmt_`.\n    ///         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to\n    ///         approximately estimate the required input amounts to reach a certain output amount. This\n    ///         will change until execution and should be controlled with a maximum slippage.\n    ///         Recommended to use exact input methods instead.\n    /// @dev The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better\n    /// but the target swap amount is more than the available without absorb liquidity. For this currently the available\n    /// withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity.\n    /// The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false\n    /// to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing\n    /// amount up to the target amount with the worse ratio with absorb liquidity.\n    /// @param tokenIn_ input token\n    /// @param tokenOut_ output token\n    /// @param outAmt_ exact output token amount that should be swapped to from input token\n    /// @return swaps_ swaps to reach the target amount, sorted by ratio in descending order\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\n    /// @return inAmt_ input token amount needed to receive `actualOutAmt_`\n    /// @return approxOutAmt_ approximate output token amount. Can be less than `outAmt_` if all available swaps can not cover\n    ///                       the target amount.\n    function approxOutput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 outAmt_\n    ) public returns (Swap[] memory swaps_, uint256 inAmt_, uint256 approxOutAmt_) {\n        return filterToApproxOutAmt(getSwapsRaw(tokenIn_, tokenOut_), outAmt_);\n    }\n\n    /// @notice filters the `swaps_` to the point where `targetInAmt_` is reached.\n    ///         This is best used in combination with the \"Raw\" methods, as the `targetInAmt_` allows for more optimized\n    ///         filtering than otherwise done with the non-\"Raw\" methods.\n    /// @return filteredSwaps_ swaps to reach the target amount, sorted by ratio in descending order\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\n    /// @return actualInAmt_ actual input amount. Can be less than targetInAmt_ if all available swaps can not cover\n    ///                      the target amount.\n    /// @return approxOutAmt_ actual estimated output amount.\n    function filterToTargetInAmt(\n        Swap[] memory swaps_,\n        uint256 targetInAmt_\n    ) public returns (Swap[] memory filteredSwaps_, uint256 actualInAmt_, uint256 approxOutAmt_) {\n        return _filterToTarget(swaps_, targetInAmt_, type(uint256).max);\n    }\n\n    /// @notice filters the `swaps_` to the point where APPROXIMATELY `targetOutAmt_` is reached.\n    ///         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to\n    ///         approximately estimate the required input amounts to reach a certain output amount. This\n    ///         will change until execution and should be controlled with a maximum slippage.\n    ///         Recommended to use exact input methods instead.\n    ///         This is best used in combination with the \"Raw\" methods, as the `targetInAmt_` allows for more optimized\n    ///         filtering than otherwise done with the non-\"Raw\" methods.\n    /// @return filteredSwaps_ swaps to reach the target amount, sorted by ratio in descending order\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\n    /// @return actualInAmt_ actual input amount.\n    /// @return approxOutAmt_ APPROXIMATE actual output amount. Can be less than targetOutAmt_ if all available swaps\n    ///                      can not cover the target amount.\n    function filterToApproxOutAmt(\n        Swap[] memory swaps_,\n        uint256 targetApproxOutAmt_\n    ) public returns (Swap[] memory filteredSwaps_, uint256 actualInAmt_, uint256 approxOutAmt_) {\n        return _filterToTarget(swaps_, type(uint256).max, targetApproxOutAmt_);\n    }\n\n    function _getUserSupplyData(address user_, address token_) internal view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n                    user_,\n                    token_\n                )\n            );\n    }\n\n    function _getExchangePricesAndConfig(address token_) internal view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n                    token_\n                )\n            );\n    }\n\n    /// @dev get withdrawable amount at a certain T1 vault, which limits liquidations. Incl. balance check at Liquidity\n    function _getVaultT1Withdrawable(address vault_, address token_) internal view returns (uint256 withdrawable_) {\n        uint256 userSupplyData_ = _getUserSupplyData(vault_, token_);\n\n        if (userSupplyData_ == 0) {\n            return 0;\n        }\n\n        uint256 userSupply_ = BigMathMinified.fromBigNumber(\n            (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & LiquidityCalcs.X64,\n            LiquidityCalcs.DEFAULT_EXPONENT_SIZE,\n            LiquidityCalcs.DEFAULT_EXPONENT_MASK\n        );\n\n        // get updated expanded withdrawal limit\n        uint256 withdrawalLimit_ = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\n\n        if (userSupplyData_ & 1 == 1) {\n            uint256 exchangePricesAndConfig_ = _getExchangePricesAndConfig(token_);\n            if (exchangePricesAndConfig_ == 0) {\n                return 0;\n            }\n            (uint256 supplyExchangePrice_, ) = LiquidityCalcs.calcExchangePrices(exchangePricesAndConfig_);\n            // convert raw amounts to normal for withInterest mode\n            userSupply_ = (userSupply_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION;\n            withdrawalLimit_ = (withdrawalLimit_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION;\n        }\n\n        withdrawable_ = userSupply_ > withdrawalLimit_ ? userSupply_ - withdrawalLimit_ : 0;\n        uint256 balanceOf_ = token_ == NATIVE_TOKEN_ADDRESS\n            ? address(LIQUIDITY).balance\n            : TokenInterface(token_).balanceOf(address(LIQUIDITY));\n\n        withdrawable_ = balanceOf_ > withdrawable_ ? withdrawable_ : balanceOf_;\n    }\n\n    /// @dev limits a Swap liquidatable amount according to actually col side withdrawable amount\n    function _getSwapAccountingForWithdrawable(\n        Swap memory swap_,\n        uint256 withdrawable_\n    ) internal pure returns (Swap memory) {\n        if (swap_.data.outAmt == 0) {\n            return swap_;\n        }\n\n        if (withdrawable_ < swap_.data.outAmt) {\n            // reduce swap in and out amount to max withdrawable\n            swap_.data.inAmt = (swap_.data.inAmt * withdrawable_) / swap_.data.outAmt;\n            swap_.data.outAmt = withdrawable_;\n        }\n\n        return swap_;\n    }\n\n    /// @dev filters the `swaps_` to the point where either `targetInAmt_` or `targetOutAmt_` is reached.\n    ///         To filter only by in or only by out amount, send `type(uint256).max` for the other param.\n    /// @return filteredSwaps_ swaps to reach the target amount, sorted by ratio in descending order\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\n    /// @return actualInAmt_ actual input amount. Can be less than targetInAmt_ if all available swaps can not cover\n    ///                      the target amount.\n    /// @return actualOutAmt_ actual output amount. Can be less than targetOutAmt_ if all available swaps can not cover\n    ///                      the target amount.\n    function _filterToTarget(\n        Swap[] memory swaps_,\n        uint256 targetInAmt_,\n        uint256 targetOutAmt_\n    ) internal returns (Swap[] memory filteredSwaps_, uint256 actualInAmt_, uint256 actualOutAmt_) {\n        swaps_ = _sortByRatio(swaps_);\n        (filteredSwaps_, actualInAmt_, actualOutAmt_) = _filterSwapsUntilTarget(swaps_, targetInAmt_, targetOutAmt_);\n\n        if (actualInAmt_ > targetInAmt_ || actualOutAmt_ > targetOutAmt_) {\n            // reduce last swap in amt to match target in amt\n            uint256 lastSwapIndex_ = filteredSwaps_.length - 1;\n\n            uint256 missingInAmt_;\n            if (actualInAmt_ > targetInAmt_) {\n                // swaps_[i].data.inAmt is causing that we over reach targetInAmt_\n                // so to get missing account from here until targetInAmt_, we only want\n                // swaps_[i].data.inAmt minus whatever is too much (actualInAmt_ - targetInAmt_)\n                missingInAmt_ = filteredSwaps_[lastSwapIndex_].data.inAmt + 1 - (actualInAmt_ - targetInAmt_);\n            } else {\n                // get missing in amt to use for liquidation call input param based on missing out amt and ratio\n                uint256 missingOutAmt_ = filteredSwaps_[lastSwapIndex_].data.outAmt - (actualOutAmt_ - targetOutAmt_);\n\n                // get total available liquidation and the ratios for with absorb vs without absorb\n                VaultResolverStructs.LiquidationStruct memory liquidationDataAvailable_ = VAULT_RESOLVER\n                    .getVaultLiquidation(filteredSwaps_[lastSwapIndex_].path.protocol, 0);\n\n                uint256 withoutAbsorbRatio_ = _calcRatio(\n                    liquidationDataAvailable_.inAmt,\n                    liquidationDataAvailable_.outAmt\n                );\n                // calculate the ratio of the absorb only liquidity part\n                uint256 absorbOnlyRatio_ = _calcRatio(\n                    liquidationDataAvailable_.inAmtWithAbsorb - liquidationDataAvailable_.inAmt,\n                    liquidationDataAvailable_.outAmtWithAbsorb - liquidationDataAvailable_.outAmt\n                );\n                if (absorbOnlyRatio_ > withoutAbsorbRatio_ || liquidationDataAvailable_.outAmt < missingOutAmt_) {\n                    // with absorb has the better ratio than without absorb or without absorb can not fully cover\n                    // the missing out amount. So with absorb has to be run.\n                    // Note for the case liquidationDataAvailable_.outAmt < missingOutAmt_:\n                    // missing in amt would ideally be a combination of the whole without absorb liquidity +\n                    // some left over which has the different (worse) with absorb ratio.\n                    // when running withAbsorb = true, always the whole with absorb liquidity is taken first.\n                    // so to profit of the better without absorb liquidity, this would have to be turned into 2 swaps.\n                    // but this might not always be better because of gas usage etc., so for simplicity we just\n                    // take the whole absorb liquidity first.\n\n                    // check if absorb only liquidity covers the missing out amount, if so then the swap ratio is already known\n                    // as absorbOnlyRatio_ which can be used to derive the required inAmt\n                    uint256 asborbOnlyLiquidity_ = liquidationDataAvailable_.outAmtWithAbsorb -\n                        liquidationDataAvailable_.outAmt;\n                    if (asborbOnlyLiquidity_ >= missingOutAmt_) {\n                        missingInAmt_ = (missingOutAmt_ * 1e27) / absorbOnlyRatio_ + 1;\n                    } else {\n                        // missing in amt is a combination of the whole absorb liquidity + some left over\n                        // which has the different without absorb ratio\n                        missingInAmt_ = (asborbOnlyLiquidity_ * 1e27) / absorbOnlyRatio_ + 1;\n                        missingInAmt_ += ((missingOutAmt_ - asborbOnlyLiquidity_) * 1e27) / withoutAbsorbRatio_ + 1;\n                    }\n                } else {\n                    // without absorb has the better ratio AND missing out amount can be covered by without absorb liquidity\n                    missingInAmt_ = (missingOutAmt_ * 1e27) / withoutAbsorbRatio_ + 1;\n                }\n            }\n\n            VaultResolverStructs.LiquidationStruct memory liquidationData_ = VAULT_RESOLVER.getVaultLiquidation(\n                filteredSwaps_[lastSwapIndex_].path.protocol,\n                missingInAmt_\n            );\n\n            actualInAmt_ -= filteredSwaps_[lastSwapIndex_].data.inAmt;\n            actualOutAmt_ -= filteredSwaps_[lastSwapIndex_].data.outAmt;\n\n            if (filteredSwaps_[lastSwapIndex_].data.withAbsorb) {\n                filteredSwaps_[lastSwapIndex_].data.inAmt = liquidationData_.inAmtWithAbsorb;\n                filteredSwaps_[lastSwapIndex_].data.outAmt = liquidationData_.outAmtWithAbsorb;\n                filteredSwaps_[lastSwapIndex_].data.ratio = _calcRatio(\n                    liquidationData_.inAmtWithAbsorb,\n                    liquidationData_.outAmtWithAbsorb\n                );\n            } else {\n                filteredSwaps_[lastSwapIndex_].data.inAmt = liquidationData_.inAmt;\n                filteredSwaps_[lastSwapIndex_].data.outAmt = liquidationData_.outAmt;\n                filteredSwaps_[lastSwapIndex_].data.ratio = _calcRatio(liquidationData_.inAmt, liquidationData_.outAmt);\n            }\n\n            actualInAmt_ += filteredSwaps_[lastSwapIndex_].data.inAmt;\n            actualOutAmt_ += filteredSwaps_[lastSwapIndex_].data.outAmt;\n        }\n    }\n\n    /// @dev sorts `swaps_` by ratio descending. Higher ratio is better (getting more output for input).\n    ///      Best ratio swap will be at pos 0, second best at pos 1 and so on\n    function _sortByRatio(Swap[] memory swaps_) internal pure returns (Swap[] memory) {\n        bool swapped_;\n        Swap memory helper_;\n        for (uint256 i = 1; i < swaps_.length; i++) {\n            swapped_ = false;\n            for (uint256 j = 0; j < swaps_.length - i; j++) {\n                if (swaps_[j + 1].data.ratio > swaps_[j].data.ratio) {\n                    helper_ = swaps_[j];\n                    swaps_[j] = swaps_[j + 1];\n                    swaps_[j + 1] = helper_;\n                    swapped_ = true;\n                }\n            }\n            if (!swapped_) {\n                return swaps_;\n            }\n        }\n\n        return swaps_;\n    }\n\n    /// @dev filters `swaps_` to exactly reach `targetInAmt_`. Takes into consideration to filter out any swaps\n    ///      where both the withAbsorb and withoutAbsorb swap would be present for the same protocol, only\n    ///      leaving the withAbsorb swap (as that includes withoutAbsorb).\n    ///      Also returns the total in `sumInAmt_` and out `sumOutAmt_` amounts, which will be less than `targetInAmt_`\n    ///      in the case that the target amount can not be reached even with all swaps.\n    function _filterSwapsUntilTarget(\n        Swap[] memory swaps_,\n        uint256 targetInAmt_,\n        uint256 targetOutAmt_\n    ) internal returns (Swap[] memory filteredSwaps_, uint256 sumInAmt_, uint256 sumOutAmt_) {\n        if (swaps_.length == 0) {\n            return (swaps_, 0, 0);\n        }\n        uint256 filteredCount_;\n        // find swaps needed until target in amt\n        while (sumInAmt_ < targetInAmt_ && sumOutAmt_ < targetOutAmt_ && filteredCount_ < swaps_.length) {\n            sumInAmt_ += swaps_[filteredCount_].data.inAmt;\n            sumOutAmt_ += swaps_[filteredCount_].data.outAmt;\n            ++filteredCount_;\n        }\n\n        // must not double count without absorb when with absorb is already present\n        // until filteredCount, for any protocol where with absorb is present,\n        // filter out the without absorb if that swap is present too.\n        // if any is found then the while to find swaps until targetAmt must be run again\n        // as it will be less with the filtered out element deducted.\n        uint256 duplicatesCount_;\n        for (uint256 i; i < filteredCount_ - 1; ++i) {\n            for (uint256 j = i + 1; j < filteredCount_; ++j) {\n                if (swaps_[i].path.protocol == swaps_[j].path.protocol) {\n                    // same protocol present twice (with and without absorb).\n                    // mark without absorb to be removed by setting the inAmt to 0\n                    if (swaps_[i].data.withAbsorb) {\n                        swaps_[j].data.inAmt = 0;\n                    } else {\n                        swaps_[i].data.inAmt = 0;\n                    }\n                    duplicatesCount_++;\n                }\n            }\n        }\n\n        if (duplicatesCount_ > 0) {\n            uint256 index_;\n            // filter swaps that are set to 0\n            filteredSwaps_ = new Swap[](swaps_.length - duplicatesCount_);\n            for (uint256 i; i < swaps_.length; ++i) {\n                if (swaps_[i].data.inAmt > 0) {\n                    filteredSwaps_[index_] = swaps_[i];\n                    ++index_;\n                }\n            }\n\n            // recursive call again to reach target amount as planned.\n            return _filterSwapsUntilTarget(filteredSwaps_, targetInAmt_, targetOutAmt_);\n        }\n\n        // when clean of duplicates -> finished, return filtered swaps and total sumInAmt\n        filteredSwaps_ = new Swap[](filteredCount_);\n        for (uint256 i; i < filteredCount_; ++i) {\n            filteredSwaps_[i] = swaps_[i];\n        }\n        return (filteredSwaps_, sumInAmt_, sumOutAmt_);\n    }\n\n    /// @dev gets the better swap based on ratio of with vs without absorb swap data.\n    function _getBetterRatioSwapData(\n        SwapData memory withoutAbsorb_,\n        SwapData memory withAbsorb_\n    ) internal pure returns (SwapData memory swap_) {\n        if (withAbsorb_.inAmt == 0) {\n            // if ratio == 0, meaning inAmt is 0, then the with absorb swap is returned.\n            return withAbsorb_;\n        }\n\n        if (withAbsorb_.ratio > withoutAbsorb_.ratio) {\n            // If (ratio of withAbsorb > ratio of withoutAbsorb) then always absorb should be true.\n            return withAbsorb_;\n        }\n\n        if (withAbsorb_.ratio == withoutAbsorb_.ratio) {\n            if (withAbsorb_.inAmt == withoutAbsorb_.inAmt) {\n                // with absorb has the same liquidity as without absorb.\n                // running liquidate() with absorb in that case only costs extra gas. return only without absorb swap\n                return withoutAbsorb_;\n            }\n\n            // with absorb has more liquidity, but same ratio -> return with absorb\n            return withAbsorb_;\n        }\n\n        // ratio of without absorb is better.\n        // Note: case where with absorb has worse ratio. but it could have significant more liquidity -> will not be\n        // returned here as long as there is without absorb liquidity...\n        return withoutAbsorb_;\n    }\n\n    /// @dev filters `allSwaps_` to the non zero amount `swaps_`, knowing the `nonZeroSwapsCount_`\n    function _getNonZeroSwaps(\n        Swap[] memory allSwaps_,\n        uint256 nonZeroSwapsCount_\n    ) internal pure returns (Swap[] memory swaps_) {\n        unchecked {\n            swaps_ = new Swap[](nonZeroSwapsCount_);\n            uint256 index_;\n            for (uint256 i; i < allSwaps_.length; ++i) {\n                if (allSwaps_[i].data.inAmt > 0) {\n                    swaps_[index_] = allSwaps_[i];\n                    ++index_;\n                }\n            }\n        }\n    }\n\n    /// @dev gets the `vault_` token in (borrow token) and token out (supply token)\n    function _getVaultTokens(address vault_) internal view returns (address tokenIn_, address tokenOut_) {\n        IFluidVaultT1.ConstantViews memory constants_ = IFluidVaultT1(vault_).constantsView();\n        return (constants_.borrowToken, constants_.supplyToken);\n    }\n\n    /// @dev returns ratio for how much outAmt_ am I getting for inAmt_. scaled by 1e27\n    function _calcRatio(uint256 inAmt_, uint256 outAmt_) internal pure returns (uint256) {\n        if (outAmt_ == 0) {\n            return 0;\n        }\n        return (outAmt_ * 1e27) / inAmt_;\n    }\n\n    /// @dev returns all VaultT1 type protocols at the Fluid VaultFactory\n    function _getVaultT1s() internal view returns (address[] memory) {\n        return FluidProtocolTypes.filterBy(VAULT_RESOLVER.getAllVaultsAddresses(), FluidProtocolTypes.VAULT_T1_TYPE);\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultLiquidation/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Structs {\n    struct SwapPath {\n        ///\n        /// @param protocol vault address at which the token pair is available\n        address protocol;\n        ///\n        /// @param tokenIn input token, borrow token at the vault\n        address tokenIn;\n        ///\n        /// @param tokenOut output token, collateral token at the vault\n        address tokenOut;\n    }\n\n    struct SwapData {\n        ///\n        /// @param inAmt total input token amount\n        uint256 inAmt;\n        ///\n        /// @param outAmt total output token amount received\n        uint256 outAmt;\n        ///\n        /// @param withAbsorb flag for using mode \"withAbsorb\" when calling liquidate() on the Vault.\n        ///                   Is set to true if a) liquidity without absorb would not\n        ///                   cover the desired `inAmt_` or if b) the rate of with absorb is better than without absorb.\n        bool withAbsorb;\n        ///\n        /// @param ratio ratio of outAmt / inAmt scaled by 1e27\n        uint256 ratio;\n    }\n\n    struct Swap {\n        ///\n        /// @param path swap path struct info such as protocol where the swap is available\n        SwapPath path;\n        ///\n        /// @param data swap data struct info such as amounts\n        SwapData data;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultLiquidation/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidVaultResolver } from \"../vault/iVaultResolver.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\n\ncontract Variables {\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    IFluidVaultResolver public immutable VAULT_RESOLVER;\n\n    /// @notice address of the liquidity contract\n    IFluidLiquidity public immutable LIQUIDITY;\n\n    constructor(IFluidVaultResolver vaultResolver_, IFluidLiquidity liquidity_) {\n        VAULT_RESOLVER = vaultResolver_;\n        LIQUIDITY = liquidity_;\n    }\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexT1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexT1 {\n    error FluidDexError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares);\n\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\n\n    /// @notice returns the dex id\n    function DEX_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndOracle;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) external view returns (CollateralReserves memory c_);\n\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) external view returns (DebtReserves memory d_);\n\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\n    function getPricesAndExchangePrices() external;\n\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) external returns (\n        uint withdrawAmt_\n    );\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) external payable returns (\n        uint paybackAmt_\n    );\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(\n        uint[] memory secondsAgos_\n    ) external view returns (\n        Oracle[] memory twaps_,\n        uint currentPrice_\n    );\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVault.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\ninterface IFluidVault {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice returns the vault id\n    function TYPE() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Tokens {\n        address token0;\n        address token1;\n    }\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address operateImplementation;\n        address adminImplementation;\n        address secondaryImplementation;\n        address deployer; // address which deploys oracle\n        address supply; // either liquidity layer or DEX protocol\n        address borrow; // either liquidity layer or DEX protocol\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\n        uint256 vaultId;\n        uint256 vaultType;\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n\n    function rebalance(\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_\n    ) external payable returns (int supplyAmt_, int borrowAmt_);\n\n    /// @notice reverts with FluidLiquidateResult\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT1.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidVaultT1 {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice returns the vault factory address\n    function VAULT_FACTORY() external view returns (address);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address adminImplementation;\n        address secondaryImplementation;\n        address supplyToken;\n        address borrowToken;\n        uint8 supplyDecimals;\n        uint8 borrowDecimals;\n        uint vaultId;\n        bytes32 liquiditySupplyExchangePriceSlot;\n        bytes32 liquidityBorrowExchangePriceSlot;\n        bytes32 liquidityUserSupplySlot;\n        bytes32 liquidityUserBorrowSlot;\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    function operate(\n        uint256 nftId_, // if 0 then new position\n        int256 newCol_, // if negative then withdraw\n        int256 newDebt_, // if negative then payback\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint actualDebtAmt_, uint actualColAmt_);\n\n    function absorb() payable external;\n\n    function rebalance() external payable returns (int supplyAmt_, int borrowAmt_);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n}\n"
    },
    "contracts/reserve/interfaces/iReserveContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\n\ninterface IFluidReserveContract {\n    function isRebalancer(address user) external returns (bool);\n\n    function initialize(\n        address[] memory _auths,\n        address[] memory _rebalancers,\n        IFluidLiquidity liquidity_,\n        address owner_\n    ) external;\n\n    function rebalanceFToken(address protocol_) external;\n\n    function rebalanceVault(address protocol_) external;\n\n    function transferFunds(address token_) external;\n\n    function getProtocolTokens(address protocol_) external;\n\n    function updateAuth(address auth_, bool isAuth_) external;\n\n    function updateRebalancer(address rebalancer_, bool isRebalancer_) external;\n\n    function approve(address[] memory protocols_, address[] memory tokens_, uint256[] memory amounts_) external;\n\n    function revoke(address[] memory protocols_, address[] memory tokens_) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}