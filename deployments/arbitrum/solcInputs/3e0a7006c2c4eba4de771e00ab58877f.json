{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/bigMathMinified.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\nlibrary BigMathMinified {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/dexCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\nimport { DexSlotsLink } from \"./dexSlotsLink.sol\";\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// @DEV ATTENTION: ON ANY CHANGES HERE, MAKE SURE THAT LOGIC IN VAULTS WILL STILL BE VALID.\n// SOME CODE THERE ASSUMES DEXCALCS == LIQUIDITYCALCS.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n/// @notice implements calculation methods used for Fluid Dex such as updated withdrawal / borrow limits.\nlibrary DexCalcs {\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) &\n            X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ = block.timestamp - ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ = block.timestamp - ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n}\n"
    },
    "contracts/libraries/dexSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\nlibrary DexSlotsLink {\n    /// @dev storage slot for variables at Dex\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\n    /// @dev storage slot for variables2 at Dex\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\n    /// @dev storage slot for total supply shares at Dex\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\n    /// @dev storage slot for user supply mapping at Dex\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\n    /// @dev storage slot for total borrow shares at Dex\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\n    /// @dev storage slot for user borrow mapping at Dex\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\n    /// @dev storage slot for oracle mapping at Dex\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\n    /// @dev storage slot for range and threshold shifts at Dex\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\n    /// @dev storage slot for center price shift at Dex\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n\n    /***********************************|\n    |           SafeApprove             | \n    |__________________________________*/\n\n    /// @notice thrown when safe approve from for an ERC20 fails\n    uint256 internal constant SafeApprove__ApproveFailed = 81001;\n}\n"
    },
    "contracts/libraries/safeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\n\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\nlibrary SafeTransfer {\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 20000; // pass max. 20k gas for native transfers\n\n    error FluidSafeTransferError(uint256 errorId_);\n\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from_\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of `token_` to `to_`.\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of ` native token to `to_`.\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\n    function safeTransferNative(address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n}\n"
    },
    "contracts/libraries/storageRead.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements a method to read uint256 data from storage at a bytes32 storage slot key.\ncontract StorageRead {\n    function readFromStorage(bytes32 slot_) public view returns (uint256 result_) {\n        assembly {\n            result_ := sload(slot_) // read value from the storage slot\n        }\n    }\n}\n"
    },
    "contracts/protocols/dex/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs } from \"./poolT1/coreModule/structs.sol\";\n\nabstract contract Error {\n    error FluidDexError(uint256 errorId_);\n\n    error FluidDexFactoryError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares_);\n\n    error FluidDexPricesAndExchangeRates(Structs.PricesAndExchangePrice pex_);\n\n    error FluidSmartLendingError(uint256 errorId_);\n\n    error FluidSmartLendingFactoryError(uint256 errorId_);\n}\n"
    },
    "contracts/protocols/dex/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |             DexT1                 | \n    |__________________________________*/\n\n    /// @notice thrown at reentrancy\n    uint256 internal constant DexT1__AlreadyEntered = 51001;\n\n    uint256 internal constant DexT1__NotAnAuth = 51002;\n\n    uint256 internal constant DexT1__SmartColNotEnabled = 51003;\n\n    uint256 internal constant DexT1__SmartDebtNotEnabled = 51004;\n\n    uint256 internal constant DexT1__PoolNotInitialized = 51005;\n\n    uint256 internal constant DexT1__TokenReservesTooLow = 51006;\n\n    uint256 internal constant DexT1__EthAndAmountInMisMatch = 51007;\n\n    uint256 internal constant DexT1__EthSentForNonNativeSwap = 51008;\n\n    uint256 internal constant DexT1__NoSwapRoute = 51009;\n\n    uint256 internal constant DexT1__NotEnoughAmountOut = 51010;\n\n    uint256 internal constant DexT1__LiquidityLayerTokenUtilizationCapReached = 51011;\n\n    uint256 internal constant DexT1__HookReturnedFalse = 51012;\n\n    // Either user's config are not set or user is paused\n    uint256 internal constant DexT1__UserSupplyInNotOn = 51013;\n\n    // Either user's config are not set or user is paused\n    uint256 internal constant DexT1__UserDebtInNotOn = 51014;\n\n    // Thrown when contract asks for more token0 or token1 than what user's wants to give on deposit\n    uint256 internal constant DexT1__AboveDepositMax = 51015;\n\n    uint256 internal constant DexT1__MsgValueLowOnDepositOrPayback = 51016;\n\n    uint256 internal constant DexT1__WithdrawLimitReached = 51017;\n\n    // Thrown when contract gives less token0 or token1 than what user's wants on withdraw\n    uint256 internal constant DexT1__BelowWithdrawMin = 51018;\n\n    uint256 internal constant DexT1__DebtLimitReached = 51019;\n\n    // Thrown when contract gives less token0 or token1 than what user's wants on borrow\n    uint256 internal constant DexT1__BelowBorrowMin = 51020;\n\n    // Thrown when contract asks for more token0 or token1 than what user's wants on payback\n    uint256 internal constant DexT1__AbovePaybackMax = 51021;\n\n    uint256 internal constant DexT1__InvalidDepositAmts = 51022;\n\n    uint256 internal constant DexT1__DepositAmtsZero = 51023;\n\n    uint256 internal constant DexT1__SharesMintedLess = 51024;\n\n    uint256 internal constant DexT1__WithdrawalNotEnough = 51025;\n\n    uint256 internal constant DexT1__InvalidWithdrawAmts = 51026;\n\n    uint256 internal constant DexT1__WithdrawAmtsZero = 51027;\n\n    uint256 internal constant DexT1__WithdrawExcessSharesBurn = 51028;\n\n    uint256 internal constant DexT1__InvalidBorrowAmts = 51029;\n\n    uint256 internal constant DexT1__BorrowAmtsZero = 51030;\n\n    uint256 internal constant DexT1__BorrowExcessSharesMinted = 51031;\n\n    uint256 internal constant DexT1__PaybackAmtTooHigh = 51032;\n\n    uint256 internal constant DexT1__InvalidPaybackAmts = 51033;\n\n    uint256 internal constant DexT1__PaybackAmtsZero = 51034;\n\n    uint256 internal constant DexT1__PaybackSharedBurnedLess = 51035;\n\n    uint256 internal constant DexT1__NothingToArbitrage = 51036;\n\n    uint256 internal constant DexT1__MsgSenderNotLiquidity = 51037;\n\n    // On liquidity callback reentrancy bit should be on\n    uint256 internal constant DexT1__ReentrancyBitShouldBeOn = 51038;\n\n    // Thrown is reentrancy is already on and someone tries to fetch oracle price. Should not be possible to this\n    uint256 internal constant DexT1__OraclePriceFetchAlreadyEntered = 51039;\n\n    // Thrown when swap changes the current price by more than 5%\n    uint256 internal constant DexT1__OracleUpdateHugeSwapDiff = 51040;\n\n    uint256 internal constant DexT1__Token0ShouldBeSmallerThanToken1 = 51041;\n\n    uint256 internal constant DexT1__OracleMappingOverflow = 51042;\n\n    /// @notice thrown if governance has paused the swapping & arbitrage so only perfect functions are usable\n    uint256 internal constant DexT1__SwapAndArbitragePaused = 51043;\n\n    uint256 internal constant DexT1__ExceedsAmountInMax = 51044;\n\n    /// @notice thrown if amount in is too high or too low\n    uint256 internal constant DexT1__SwapInLimitingAmounts = 51045;\n\n    /// @notice thrown if amount out is too high or too low\n    uint256 internal constant DexT1__SwapOutLimitingAmounts = 51046;\n\n    uint256 internal constant DexT1__MintAmtOverflow = 51047;\n\n    uint256 internal constant DexT1__BurnAmtOverflow = 51048;\n\n    uint256 internal constant DexT1__LimitingAmountsSwapAndNonPerfectActions = 51049;\n\n    uint256 internal constant DexT1__InsufficientOracleData = 51050;\n\n    uint256 internal constant DexT1__SharesAmountInsufficient = 51051;\n\n    uint256 internal constant DexT1__CenterPriceOutOfRange = 51052;\n\n    uint256 internal constant DexT1__DebtReservesTooLow = 51053;\n\n    uint256 internal constant DexT1__SwapAndDepositTooLowOrTooHigh = 51054;\n\n    uint256 internal constant DexT1__WithdrawAndSwapTooLowOrTooHigh = 51055;\n\n    uint256 internal constant DexT1__BorrowAndSwapTooLowOrTooHigh = 51056;\n\n    uint256 internal constant DexT1__SwapAndPaybackTooLowOrTooHigh = 51057;\n\n    uint256 internal constant DexT1__InvalidImplementation = 51058;\n\n    uint256 internal constant DexT1__OnlyDelegateCallAllowed = 51059;\n\n    uint256 internal constant DexT1__IncorrectDataLength = 51060;\n\n    uint256 internal constant DexT1__AmountToSendLessThanAmount = 51061;\n\n    uint256 internal constant DexT1__InvalidCollateralReserves = 51062;\n\n    uint256 internal constant DexT1__InvalidDebtReserves = 51063;\n\n    uint256 internal constant DexT1__SupplySharesOverflow = 51064;\n\n    uint256 internal constant DexT1__BorrowSharesOverflow = 51065;\n\n    uint256 internal constant DexT1__OracleNotActive = 51066;\n\n    /***********************************|\n    |            DEX Admin              | \n    |__________________________________*/\n\n    /// @notice thrown when pool is not initialized\n    uint256 internal constant DexT1Admin__PoolNotInitialized = 52001;\n\n    uint256 internal constant DexT1Admin__SmartColIsAlreadyOn = 52002;\n\n    uint256 internal constant DexT1Admin__SmartDebtIsAlreadyOn = 52003;\n\n    /// @notice thrown when any of the configs value overflow the maximum limit\n    uint256 internal constant DexT1Admin__ConfigOverflow = 52004;\n\n    uint256 internal constant DexT1Admin__AddressNotAContract = 52005;\n\n    uint256 internal constant DexT1Admin__InvalidParams = 52006;\n\n    uint256 internal constant DexT1Admin__UserNotDefined = 52007;\n\n    uint256 internal constant DexT1Admin__OnlyDelegateCallAllowed = 52008;\n\n    uint256 internal constant DexT1Admin__UnexpectedPoolState = 52009;\n\n    /// @notice thrown when trying to pause or unpause but user is already in the target pause state\n    uint256 internal constant DexT1Admin__InvalidPauseToggle = 52009;\n\n    /***********************************|\n    |            DEX Factory            | \n    |__________________________________*/\n\n    uint256 internal constant DexFactory__InvalidOperation = 53001;\n    uint256 internal constant DexFactory__Unauthorized = 53002;\n    uint256 internal constant DexFactory__SameTokenNotAllowed = 53003;\n    uint256 internal constant DexFactory__TokenConfigNotProper = 53004;\n    uint256 internal constant DexFactory__InvalidParams = 53005;\n    uint256 internal constant DexFactory__OnlyDelegateCallAllowed = 53006;\n    uint256 internal constant DexFactory__InvalidDexAddress = 53007;\n\n    /***********************************|\n    |            Smart Lending          | \n    |__________________________________*/\n\n    uint256 internal constant SmartLending__ZeroAddress = 54001;\n    uint256 internal constant SmartLending__Unauthorized = 54002;\n    uint256 internal constant SmartLending__InvalidMsgValue = 54003;\n    uint256 internal constant SmartLending__OutOfRange = 54004;\n    uint256 internal constant SmartLending__InvalidRebalancer = 54005;\n    uint256 internal constant SmartLending__Reentrancy = 54006;\n\n    /***********************************|\n    |        Smart Lending Factory       | \n    |__________________________________*/\n\n    uint256 internal constant SmartLendingFactory__ZeroAddress = 55001;\n    uint256 internal constant SmartLendingFactory__Unauthorized = 55002;\n    uint256 internal constant SmartLendingFactory__AlreadyDeployed = 55003;\n    uint256 internal constant SmartLendingFactory__InvalidParams = 55004;\n    uint256 internal constant SmartLendingFactory__InvalidOperation = 55005;\n}\n"
    },
    "contracts/protocols/dex/factory/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Owned } from \"solmate/src/auth/Owned.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { StorageRead } from \"../../../libraries/storageRead.sol\";\n\nabstract contract DexFactoryVariables is Owned, StorageRead, Error {\n    /*//////////////////////////////////////////////////////////////\n                          STORAGE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    // ------------ storage variables from inherited contracts (Owned) come before vars here --------\n\n    // ----------------------- slot 0 ---------------------------\n    // address public owner; // from Owned\n\n    // 12 bytes empty\n\n    // ----------------------- slot 1  ---------------------------\n    /// @dev deployer can deploy new Dex Pool contract\n    /// owner can add/remove deployer.\n    /// Owner is deployer by default.\n    mapping(address => bool) internal _deployers;\n\n    // ----------------------- slot 2  ---------------------------\n    /// @dev global auths can update any dex pool config.\n    /// owner can add/remove global auths.\n    /// Owner is global auth by default.\n    mapping(address => bool) internal _globalAuths;\n\n    // ----------------------- slot 3  ---------------------------\n    /// @dev dex auths can update specific dex config.\n    /// owner can add/remove dex auths.\n    /// Owner is dex auth by default.\n    /// dex => auth => add/remove\n    mapping(address => mapping(address => bool)) internal _dexAuths;\n\n    // ----------------------- slot 4 ---------------------------\n    /// @dev total no of dexes deployed by the factory\n    /// only addresses that have deployer role or owner can deploy new dex pool.\n    uint256 internal _totalDexes;\n\n    // ----------------------- slot 5 ---------------------------\n    /// @dev dex deployment logics for deploying dex pool\n    /// These logic contracts hold the deployment logics of specific dexes and are called via .delegatecall inside deployDex().\n    /// only addresses that have owner can add/remove new dex deployment logic.\n    mapping(address => bool) internal _dexDeploymentLogics;\n\n    /*//////////////////////////////////////////////////////////////\n                          CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    constructor(address owner_) Owned(owner_) {}\n}\n\nabstract contract DexFactoryEvents {\n    /// @dev Emitted when a new dex is deployed.\n    /// @param dex The address of the newly deployed dex.\n    /// @param dexId The id of the newly deployed dex.\n    event LogDexDeployed(address indexed dex, uint256 indexed dexId);\n\n    /// @dev Emitted when the deployer is modified by owner.\n    /// @param deployer Address whose deployer status is updated.\n    /// @param allowed Indicates whether the address is authorized as a deployer or not.\n    event LogSetDeployer(address indexed deployer, bool indexed allowed);\n\n    /// @dev Emitted when the globalAuth is modified by owner.\n    /// @param globalAuth Address whose globalAuth status is updated.\n    /// @param allowed Indicates whether the address is authorized as a deployer or not.\n    event LogSetGlobalAuth(address indexed globalAuth, bool indexed allowed);\n\n    /// @dev Emitted when the dexAuth is modified by owner.\n    /// @param dexAuth Address whose dexAuth status is updated.\n    /// @param allowed Indicates whether the address is authorized as a deployer or not.\n    /// @param dex Address of the specific dex related to the authorization change.\n    event LogSetDexAuth(address indexed dexAuth, bool indexed allowed, address indexed dex);\n\n    /// @dev Emitted when the dex deployment logic is modified by owner.\n    /// @param dexDeploymentLogic The address of the dex deployment logic contract.\n    /// @param allowed  Indicates whether the address is authorized as a deployer or not.\n    event LogSetDexDeploymentLogic(address indexed dexDeploymentLogic, bool indexed allowed);\n}\n\nabstract contract DexFactoryCore is DexFactoryVariables, DexFactoryEvents {\n    constructor(address owner_) validAddress(owner_) DexFactoryVariables(owner_) {}\n\n    /// @dev validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidDexFactoryError(ErrorTypes.DexFactory__InvalidParams);\n        }\n        _;\n    }\n}\n\n/// @dev Implements Dex Factory auth-only callable methods. Owner / auths can set various config values and\n/// can define the allow-listed deployers.\nabstract contract DexFactoryAuth is DexFactoryCore {\n    /// @notice                         Sets an address (`deployer_`) as allowed deployer or not.\n    ///                                 This function can only be called by the owner.\n    /// @param deployer_                The address to be set as deployer.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to deploy dexes.\n    function setDeployer(address deployer_, bool allowed_) external onlyOwner validAddress(deployer_) {\n        _deployers[deployer_] = allowed_;\n\n        emit LogSetDeployer(deployer_, allowed_);\n    }\n\n    /// @notice                         Sets an address (`globalAuth_`) as a global authorization or not.\n    ///                                 This function can only be called by the owner.\n    /// @param globalAuth_              The address to be set as global authorization.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to update any dex config.\n    function setGlobalAuth(address globalAuth_, bool allowed_) external onlyOwner validAddress(globalAuth_) {\n        _globalAuths[globalAuth_] = allowed_;\n\n        emit LogSetGlobalAuth(globalAuth_, allowed_);\n    }\n\n    /// @notice                         Sets an address (`dexAuth_`) as allowed dex authorization or not for a specific dex (`dex_`).\n    ///                                 This function can only be called by the owner.\n    /// @param dex_                     The address of the dex for which the authorization is being set.\n    /// @param dexAuth_                 The address to be set as dex authorization.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to update the specific dex config.\n    function setDexAuth(address dex_, address dexAuth_, bool allowed_) external onlyOwner validAddress(dexAuth_) {\n        _dexAuths[dex_][dexAuth_] = allowed_;\n\n        emit LogSetDexAuth(dexAuth_, allowed_, dex_);\n    }\n\n    /// @notice                         Sets an address as allowed dex deployment logic (`deploymentLogic_`) contract or not.\n    ///                                 This function can only be called by the owner.\n    /// @param deploymentLogic_         The address of the dex deployment logic contract to be set.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to deploy new type of dex.\n    function setDexDeploymentLogic(\n        address deploymentLogic_,\n        bool allowed_\n    ) public onlyOwner validAddress(deploymentLogic_) {\n        _dexDeploymentLogics[deploymentLogic_] = allowed_;\n\n        emit LogSetDexDeploymentLogic(deploymentLogic_, allowed_);\n    }\n\n    /// @notice                         Spell allows owner aka governance to do any arbitrary call on factory\n    /// @param target_                  Address to which the call needs to be delegated\n    /// @param data_                    Data to execute at the delegated address\n    function spell(address target_, bytes memory data_) external onlyOwner returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n\n    /// @notice                         Checks if the provided address (`deployer_`) is authorized as a deployer.\n    /// @param deployer_                The address to be checked for deployer authorization.\n    /// @return                         Returns `true` if the address is a deployer, otherwise `false`.\n    function isDeployer(address deployer_) public view returns (bool) {\n        return _deployers[deployer_] || owner == deployer_;\n    }\n\n    /// @notice                         Checks if the provided address (`globalAuth_`) has global dex authorization privileges.\n    /// @param globalAuth_              The address to be checked for global authorization privileges.\n    /// @return                         Returns `true` if the given address has global authorization privileges, otherwise `false`.\n    function isGlobalAuth(address globalAuth_) public view returns (bool) {\n        return _globalAuths[globalAuth_] || owner == globalAuth_;\n    }\n\n    /// @notice                         Checks if the provided address (`dexAuth_`) has dex authorization privileges for the specified dex (`dex_`).\n    /// @param dex_                     The address of the dex to check.\n    /// @param dexAuth_                 The address to be checked for dex authorization privileges.\n    /// @return                         Returns `true` if the given address has dex authorization privileges for the specified dex, otherwise `false`.\n    function isDexAuth(address dex_, address dexAuth_) public view returns (bool) {\n        return _dexAuths[dex_][dexAuth_] || owner == dexAuth_;\n    }\n\n    /// @notice                         Checks if the provided (`dexDeploymentLogic_`) address has authorization for dex deployment.\n    /// @param dexDeploymentLogic_      The address of the dex deploy logic to check for authorization privileges.\n    /// @return                         Returns `true` if the given address has authorization privileges for dex deployment, otherwise `false`.\n    function isDexDeploymentLogic(address dexDeploymentLogic_) public view returns (bool) {\n        return _dexDeploymentLogics[dexDeploymentLogic_];\n    }\n}\n\n/// @dev implements DexFactory deploy dex related methods.\nabstract contract DexFactoryDeployment is DexFactoryCore, DexFactoryAuth {\n    /// @dev                            Deploys a contract using the CREATE opcode with the provided bytecode (`bytecode_`).\n    ///                                 This is an internal function, meant to be used within the contract to facilitate the deployment of other contracts.\n    /// @param bytecode_                The bytecode of the contract to be deployed.\n    /// @return address_                Returns the address of the deployed contract.\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\n        if (bytecode_.length == 0) {\n            revert FluidDexError(ErrorTypes.DexFactory__InvalidOperation);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\n        }\n        if (address_ == address(0)) {\n            revert FluidDexError(ErrorTypes.DexFactory__InvalidOperation);\n        }\n    }\n\n    /// @notice                       Deploys a new dex using the specified deployment logic `dexDeploymentLogic_` and data `dexDeploymentData_`.\n    ///                               Only accounts with deployer access or the owner can deploy a new dex.\n    /// @param dexDeploymentLogic_    The address of the dex deployment logic contract.\n    /// @param dexDeploymentData_     The data to be used for dex deployment.\n    /// @return dex_                  Returns the address of the newly deployed dex.\n    function deployDex(address dexDeploymentLogic_, bytes calldata dexDeploymentData_) external returns (address dex_) {\n        // Revert if msg.sender doesn't have deployer access or is an owner.\n        if (!isDeployer(msg.sender)) revert FluidDexError(ErrorTypes.DexFactory__Unauthorized);\n        // Revert if dexDeploymentLogic_ is not whitelisted.\n        if (!isDexDeploymentLogic(dexDeploymentLogic_)) revert FluidDexError(ErrorTypes.DexFactory__Unauthorized);\n\n        // Dex ID for the new dex and also acts as `nonce` for CREATE\n        uint256 dexId_ = ++_totalDexes;\n\n        // compute dex address for dex id.\n        dex_ = getDexAddress(dexId_);\n\n        // deploy the dex using dex deployment logic by making .delegatecall\n        (bool success_, bytes memory data_) = dexDeploymentLogic_.delegatecall(dexDeploymentData_);\n\n        if (!(success_ && dex_ == _deploy(abi.decode(data_, (bytes))) && isDex(dex_))) {\n            revert FluidDexError(ErrorTypes.DexFactory__InvalidDexAddress);\n        }\n\n        emit LogDexDeployed(dex_, dexId_);\n    }\n\n    /// @notice                       Computes the address of a dex based on its given ID (`dexId_`).\n    /// @param dexId_                 The ID of the dex.\n    /// @return dex_                  Returns the computed address of the dex.\n    function getDexAddress(uint256 dexId_) public view returns (address dex_) {\n        return AddressCalcs.addressCalc(address(this), dexId_);\n    }\n\n    /// @notice                         Checks if a given address (`dex_`) corresponds to a valid dex.\n    /// @param dex_                     The dex address to check.\n    /// @return                         Returns `true` if the given address corresponds to a valid dex, otherwise `false`.\n    function isDex(address dex_) public view returns (bool) {\n        if (dex_.code.length == 0) {\n            return false;\n        } else {\n            // DEX_ID() function signature is 0xf4b9a3fb\n            (bool success_, bytes memory data_) = dex_.staticcall(hex\"f4b9a3fb\");\n            return success_ && dex_ == getDexAddress(abi.decode(data_, (uint256)));\n        }\n    }\n\n    /// @notice                   Returns the total number of dexes deployed by the factory.\n    /// @return                   Returns the total number of dexes.\n    function totalDexes() external view returns (uint256) {\n        return _totalDexes;\n    }\n}\n\n/// @title Fluid DexFactory\n/// @notice creates Fluid dex protocol dexes, which are interacting with Fluid Liquidity to deposit / borrow funds.\n/// Dexes are created at a deterministic address, given an incrementing `dexId` (see `getDexAddress()`).\n/// Dexes can only be deployed by allow-listed deployer addresses.\n/// @dev Note the deployed dexes start out with no config at Liquidity contract.\n/// This must be done by Liquidity auths in a separate step, otherwise no deposits will be possible.\n/// This contract is not upgradeable. It supports adding new dex deployment logic contracts for new, future dexes.\ncontract FluidDexFactory is DexFactoryCore, DexFactoryAuth, DexFactoryDeployment {\n    constructor(address owner_) DexFactoryCore(owner_) {}\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexT1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexT1 {\n    error FluidDexError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares);\n\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\n\n    /// @notice returns the dex id\n    function DEX_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndOracle;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) external view returns (CollateralReserves memory c_);\n\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) external view returns (DebtReserves memory d_);\n\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\n    function getPricesAndExchangePrices() external;\n\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) external returns (\n        uint withdrawAmt_\n    );\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) external payable returns (\n        uint paybackAmt_\n    );\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(\n        uint[] memory secondsAgos_\n    ) external view returns (\n        Oracle[] memory twaps_,\n        uint currentPrice_\n    );\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct ExchangePrices {\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct CollateralReservesSwap {\n        uint tokenInRealReserves;\n        uint tokenOutRealReserves;\n        uint tokenInImaginaryReserves;\n        uint tokenOutImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReservesSwap {\n        uint tokenInDebt;\n        uint tokenOutDebt;\n        uint tokenInRealReserves;\n        uint tokenOutRealReserves;\n        uint tokenInImaginaryReserves;\n        uint tokenOutImaginaryReserves;\n    }\n\n    struct SwapInMemory {\n        address tokenIn;\n        address tokenOut;\n        uint256 amtInAdjusted;\n        address withdrawTo;\n        address borrowTo;\n        uint price; // price of pool after swap\n        uint fee; // fee of pool\n        uint revenueCut; // revenue cut of pool\n        bool swap0to1;\n        int swapRoutingAmt;\n        bytes data; // just added to avoid stack-too-deep error\n    }\n\n    struct SwapOutMemory {\n        address tokenIn;\n        address tokenOut;\n        uint256 amtOutAdjusted;\n        address withdrawTo;\n        address borrowTo;\n        uint price; // price of pool after swap\n        uint fee;\n        uint revenueCut; // revenue cut of pool\n        bool swap0to1;\n        int swapRoutingAmt;\n        bytes data; // just added to avoid stack-too-deep error\n        uint msgValue;\n    }\n\n    struct DepositColMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0ReservesInitial;\n        uint256 token1ReservesInitial;\n    }\n\n    struct WithdrawColMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0ReservesInitial;\n        uint256 token1ReservesInitial;\n        address to;\n    }\n\n    struct BorrowDebtMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0DebtInitial;\n        uint256 token1DebtInitial;\n        address to;\n    }\n\n    struct PaybackDebtMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0DebtInitial;\n        uint256 token1DebtInitial;\n    }\n\n    struct OraclePriceMemory {\n        uint lowestPrice1by0;\n        uint highestPrice1by0;\n        uint oracleSlot;\n        uint oracleMap;\n        uint oracle;\n    }\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndSwapOut;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n}\n"
    },
    "contracts/protocols/dex/smartLending/factory/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Owned } from \"solmate/src/auth/Owned.sol\";\nimport { SSTORE2 } from \"solmate/src/utils/SSTORE2.sol\";\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\n\nabstract contract Constants {\n    address public immutable DEX_FACTORY;\n    address public immutable LIQUIDITY;\n}\n\nabstract contract Variables is Owned {\n    // ------------ storage variables from inherited contracts (Owned) come before vars here --------\n\n    // ----------------------- slot 0 ---------------------------\n    // address public owner;\n\n    // 12 bytes empty\n\n    // ----------------------- slot 1 ---------------------------\n    /// @dev Maps the DEX ID to the corresponding SmartLending contract address\n    mapping(uint256 dexId => address) public smartLendingAddress;\n\n    // ----------------------- slot 2  ---------------------------\n    /// @dev smart lending auths can update specific configs.\n    /// owner can add/remove auths.\n    /// Owner is auth by default.\n    mapping(address => mapping(address => uint256)) internal _smartLendingAuths;\n\n    // ----------------------- slot 3 ---------------------------\n    /// @dev deployers can deploy new smartLendings.\n    /// owner can add/remove deployers.\n    /// Owner is deployer by default.\n    mapping(address => uint256) internal _deployers;\n\n    // ----------------------- slot 4 ---------------------------\n    /// @notice list of all created tokens.\n    /// @dev Solidity creates an automatic getter only to fetch at a certain position, so explicitly define a getter that returns all.\n    address[] public createdTokens;\n\n    // ----------------------- slot 5 ---------------------------\n\n    /// @dev smart lending creation code, accessed via SSTORE2.\n    address internal _smartLendingCreationCodePointer;\n\n    /*//////////////////////////////////////////////////////////////\n                          CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address owner_) Owned(owner_) {}\n}\n\nabstract contract Events {\n    /// @dev Emitted when a new smart lending is deployed\n    /// @param dexId The ID of the deployed DEX\n    /// @param smartLending The address of the deployed smart lending\n    event LogSmartLendingDeployed(uint256 dexId, address smartLending);\n\n    /// @dev Emitted when a SmartLending auth is updated\n    /// @param smartLending address of SmartLending\n    /// @param auth address of auth whose status is being updated\n    /// @param allowed updated status of auth\n    event LogAuthUpdated(address smartLending, address auth, bool allowed);\n\n    /// @dev Emitted when a deployer is modified by owner\n    /// @param deployer address of deployer\n    /// @param allowed updated status of deployer\n    event LogDeployerUpdated(address deployer, bool allowed);\n\n    /// @dev Emitted when the smart lending creation code is modified by owner\n    /// @param creationCodePointer address of the creation code pointer\n    event LogSetCreationCode(address creationCodePointer);\n}\n\ncontract FluidSmartLendingFactory is Constants, Variables, Events, Error {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidSmartLendingFactoryError(ErrorTypes.SmartLendingFactory__ZeroAddress);\n        }\n        _;\n    }\n\n    constructor(\n        address dexFactory_,\n        address liquidity_,\n        address owner_\n    ) validAddress(dexFactory_) validAddress(liquidity_) validAddress(owner_) Variables(owner_) {\n        LIQUIDITY = liquidity_;\n        DEX_FACTORY = dexFactory_;\n    }\n\n    /// @dev Validates that msg.sender is deployer or owner\n    modifier onlyDeployers() {\n        if (!isDeployer(msg.sender)) {\n            revert FluidSmartLendingFactoryError(ErrorTypes.SmartLendingFactory__Unauthorized);\n        }\n        _;\n    }\n\n    /// @notice List of all created tokens\n    function allTokens() public view returns (address[] memory) {\n        return createdTokens;\n    }\n\n    /// @notice Reads if a certain `auth_` address is an allowed auth for `smartLending_` or not. Owner is auth by default.\n    function isSmartLendingAuth(address smartLending_, address auth_) public view returns (bool) {\n        return auth_ == owner || _smartLendingAuths[smartLending_][auth_] == 1;\n    }\n\n    /// @notice Reads if a certain `deployer_` address is an allowed deployer or not. Owner is deployer by default.\n    function isDeployer(address deployer_) public view returns (bool) {\n        return deployer_ == owner || _deployers[deployer_] == 1;\n    }\n\n    /// @dev Retrieves the creation code for the SmartLending contract\n    function smartLendingCreationCode() public view returns (bytes memory) {\n        return SSTORE2.read(_smartLendingCreationCodePointer);\n    }\n\n    /// @notice Sets an address as allowed deployer or not. Only callable by owner.\n    /// @param deployer_ Address to set deployer value for\n    /// @param allowed_ Bool flag for whether address is allowed as deployer or not\n    function updateDeployer(address deployer_, bool allowed_) external onlyOwner validAddress(deployer_) {\n        _deployers[deployer_] = allowed_ ? 1 : 0;\n\n        emit LogDeployerUpdated(deployer_, allowed_);\n    }\n\n    /// @notice Updates the authorization status of an address for a SmartLending contract. Only callable by owner.\n    /// @param smartLending_ The address of the SmartLending contract\n    /// @param auth_ The address to be updated\n    /// @param allowed_ The new authorization status\n    function updateSmartLendingAuth(\n        address smartLending_,\n        address auth_,\n        bool allowed_\n    ) external validAddress(smartLending_) validAddress(auth_) onlyOwner {\n        _smartLendingAuths[smartLending_][auth_] = allowed_ ? 1 : 0;\n\n        emit LogAuthUpdated(smartLending_, auth_, allowed_);\n    }\n\n    /// @notice Sets the `creationCode_` bytecode for new SmartLending contracts. Only callable by owner.\n    /// @param creationCode_ New SmartLending contract creation code.\n    function setSmartLendingCreationCode(bytes calldata creationCode_) external onlyOwner {\n        if (creationCode_.length == 0) {\n            revert FluidSmartLendingFactoryError(ErrorTypes.SmartLendingFactory__InvalidParams);\n        }\n\n        // write creation code to SSTORE2 pointer and set in mapping\n        address creationCodePointer_ = SSTORE2.write(creationCode_);\n        _smartLendingCreationCodePointer = creationCodePointer_;\n\n        emit LogSetCreationCode(creationCodePointer_);\n    }\n\n    /// @notice Spell allows owner aka governance to do any arbitrary call on factory\n    /// @param target_ Address to which the call needs to be delegated\n    /// @param data_ Data to execute at the delegated address\n    function spell(address target_, bytes memory data_) external onlyOwner returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n\n    /// @notice Deploys a new SmartLending contract. Only callable by deployers.\n    /// @param dexId_ The ID of the DEX for which the smart lending wrapper is being deployed\n    /// @return smartLending_ The newly deployed SmartLending contract\n    function deploy(uint256 dexId_) public onlyDeployers returns (address smartLending_) {\n        if (smartLendingAddress[dexId_] != address(0)) {\n            revert FluidSmartLendingFactoryError(ErrorTypes.SmartLendingFactory__AlreadyDeployed);\n        }\n\n        smartLending_ = _deploy(\n            abi.encodePacked(\n                SSTORE2.read(_smartLendingCreationCodePointer), // creation code\n                abi.encode(dexId_, LIQUIDITY, DEX_FACTORY, address(this)) // constructor params\n            )\n        );\n\n        createdTokens.push(smartLending_); // Add the created token to the allTokens array\n        smartLendingAddress[dexId_] = smartLending_;\n\n        emit LogSmartLendingDeployed(dexId_, smartLending_);\n    }\n\n    /// @dev Deploys a contract using the CREATE opcode with the provided bytecode (`bytecode_`).\n    /// This is an internal function, meant to be used within the contract to facilitate the deployment of other contracts.\n    /// @param bytecode_ The bytecode of the contract to be deployed.\n    /// @return address_ Returns the address of the deployed contract.\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\n        if (bytecode_.length == 0) {\n            revert FluidDexError(ErrorTypes.SmartLendingFactory__InvalidOperation);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\n        }\n        if (address_ == address(0)) {\n            revert FluidDexError(ErrorTypes.SmartLendingFactory__InvalidOperation);\n        }\n    }\n}\n"
    },
    "contracts/protocols/dex/smartLending/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { IFluidDexT1 } from \"../interfaces/iDexT1.sol\";\nimport { FluidDexFactory } from \"../factory/main.sol\";\nimport { FluidSmartLendingFactory } from \"./factory/main.sol\";\nimport { SafeTransfer } from \"../../../libraries/safeTransfer.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\nimport { DexSlotsLink } from \"../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\n\nabstract contract Constants {\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address internal constant DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n\n    FluidDexFactory public immutable DEX_FACTORY;\n\n    FluidSmartLendingFactory public immutable SMART_LENDING_FACTORY;\n\n    IFluidDexT1 public immutable DEX;\n\n    address public immutable LIQUIDITY;\n\n    address public immutable TOKEN0;\n\n    address public immutable TOKEN1;\n\n    bool public immutable IS_NATIVE_PAIR;\n}\n\nabstract contract Variables is ERC20, Constants {\n    // ------------ storage variables from inherited contracts come before vars here --------\n    // _________ ERC20 _______________\n    // ----------------------- slot 0 ---------------------------\n    // mapping(address => uint256) private _balances;\n\n    // ----------------------- slot 1 ---------------------------\n    // mapping(address => mapping(address => uint256)) private _allowances;\n\n    // ----------------------- slot 2 ---------------------------\n    // uint256 private _totalSupply;\n\n    // ----------------------- slot 3 ---------------------------\n    // string private _name;\n    // ----------------------- slot 4 ---------------------------\n    // string private _symbol;\n\n    // ------------ storage variables ------------------------------------------------------\n\n    // ----------------------- slot 5 ---------------------------\n    uint40 public lastTimestamp;\n    /// If positive then rewards, if negative then fee.\n    /// 1e6 = 100%, 1e4 = 1%, minimum 0.0001% fee or reward.\n    int32 public feeOrReward;\n    // Starting from 1e18\n    // If fees then reduce exchange price\n    // If reward then increase exchange price\n    uint184 public exchangePrice;\n\n    // ----------------------- slot 6 ---------------------------\n    address public rebalancer;\n\n    // ----------------------- slot 7 ---------------------------\n    address public dexFromAddress;\n\n    /// @dev status for reentrancy guard\n    uint8 internal _status;\n}\n\nabstract contract Events {\n    /// @dev Emitted when the share to tokens ratio is rebalanced\n    /// @param shares_ The number of shares rebalanced\n    /// @param token0Amt_ The amount of token0 rebalanced\n    /// @param token1Amt_ The amount of token1 rebalanced\n    /// @param isWithdraw_ Whether the rebalance is a withdrawal or deposit\n    event LogRebalance(uint256 shares_, uint256 token0Amt_, uint256 token1Amt_, bool isWithdraw_);\n\n    /// @dev Emitted when the rebalancer is set\n    /// @param rebalancer The new rebalancer\n    event LogRebalancerSet(address rebalancer);\n\n    /// @dev Emitted when the fee or reward is set\n    /// @param feeOrReward The new fee or reward\n    event LogFeeOrRewardSet(int256 feeOrReward);\n}\n\n/// @dev ReentrancyGuard based on OpenZeppelin implementation.\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.8/contracts/security/ReentrancyGuard.sol\nabstract contract ReentrancyGuard is Variables, Error {\n    uint8 internal constant REENTRANCY_NOT_ENTERED = 1;\n    uint8 internal constant REENTRANCY_ENTERED = 2;\n\n    constructor() {\n        _status = REENTRANCY_NOT_ENTERED;\n    }\n\n    /// @dev Prevents a contract from calling itself, directly or indirectly.\n    /// See OpenZeppelin implementation for more info\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status != REENTRANCY_NOT_ENTERED) {\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__Reentrancy);\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = REENTRANCY_ENTERED;\n\n        _;\n\n        // storing original value triggers a refund (see https://eips.ethereum.org/EIPS/eip-2200)\n        _status = REENTRANCY_NOT_ENTERED;\n    }\n}\n\ncontract FluidSmartLending is ERC20, Variables, Error, ReentrancyGuard, Events {\n    /// @dev prefix for token name. constructor appends dex id, e.g. \"Fluid Smart Lending 12\"\n    string private constant TOKEN_NAME_PREFIX = \"Fluid Smart Lending \";\n    /// @dev prefix for token symbol. constructor appends dex id, e.g. \"fSL12\"\n    string private constant TOKEN_SYMBOL_PREFIX = \"fSL\";\n\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__ZeroAddress);\n        }\n        _;\n    }\n\n    constructor(\n        uint256 dexId_,\n        address liquidity_,\n        address dexFactory_,\n        address smartLendingFactory_\n    )\n        ERC20(\n            string(abi.encodePacked(TOKEN_NAME_PREFIX, _toString(dexId_))),\n            string(abi.encodePacked(TOKEN_SYMBOL_PREFIX, _toString(dexId_)))\n        )\n        validAddress(liquidity_)\n        validAddress(dexFactory_)\n        validAddress(smartLendingFactory_)\n    {\n        LIQUIDITY = liquidity_;\n        DEX_FACTORY = FluidDexFactory(dexFactory_);\n        SMART_LENDING_FACTORY = FluidSmartLendingFactory(smartLendingFactory_);\n        DEX = IFluidDexT1(DEX_FACTORY.getDexAddress(dexId_));\n        IFluidDexT1.ConstantViews memory constants_ = DEX.constantsView();\n        TOKEN0 = constants_.token0;\n        TOKEN1 = constants_.token1;\n        IS_NATIVE_PAIR = (TOKEN0 == ETH_ADDRESS) || (TOKEN1 == ETH_ADDRESS);\n\n        exchangePrice = uint184(1e18);\n        feeOrReward = int32(0);\n        lastTimestamp = uint40(block.timestamp);\n\n        dexFromAddress = DEAD_ADDRESS;\n    }\n\n    modifier setDexFrom() {\n        dexFromAddress = msg.sender;\n        _;\n        dexFromAddress = DEAD_ADDRESS;\n    }\n\n    modifier onlyAuth() {\n        if (!SMART_LENDING_FACTORY.isSmartLendingAuth(address(this), msg.sender)) {\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__Unauthorized);\n        }\n        _;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != SMART_LENDING_FACTORY.owner()) {\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__Unauthorized);\n        }\n        _;\n    }\n\n    modifier _updateExchangePrice() {\n        if (feeOrReward > 0) {\n            exchangePrice =\n                exchangePrice +\n                uint184(\n                    (exchangePrice * uint256(int256(feeOrReward)) * (block.timestamp - uint256(lastTimestamp))) /\n                        (1e6 * SECONDS_PER_YEAR)\n                );\n\n            lastTimestamp = uint40(block.timestamp); // only write to storage if fee or reward is active.\n        } else if (feeOrReward < 0) {\n            exchangePrice =\n                exchangePrice -\n                uint184(\n                    (exchangePrice * uint256(-int256(feeOrReward)) * (block.timestamp - uint256(lastTimestamp))) /\n                        (1e6 * SECONDS_PER_YEAR)\n                );\n\n            lastTimestamp = uint40(block.timestamp); // only write to storage if fee or reward is active.\n        }\n        _;\n    }\n\n    /// @notice triggers updateExchangePrice\n    function updateExchangePrice() public _updateExchangePrice {}\n\n    /// @dev Set the fee or reward. Only callable by auths.\n    /// @param feeOrReward_ The new fee or reward (1e6 = 100%, 1e4 = 1%, minimum 0.0001% fee or reward). 0 means no fee or reward\n    function setFeeOrReward(int256 feeOrReward_) external onlyAuth _updateExchangePrice {\n        if (feeOrReward_ > 1e6 || feeOrReward_ < -1e6) {\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__OutOfRange);\n        }\n        lastTimestamp = uint40(block.timestamp); // current fee or reward setting is applied until exactly now even if previously 0\n        feeOrReward = int32(feeOrReward_);\n\n        emit LogFeeOrRewardSet(feeOrReward_);\n    }\n\n    /// @dev Set the rebalancer. Only callable by auths.\n    /// @param rebalancer_ The new rebalancer\n    function setRebalancer(address rebalancer_) external onlyAuth validAddress(rebalancer_) {\n        rebalancer = rebalancer_;\n\n        emit LogRebalancerSet(rebalancer_);\n    }\n\n    /// @notice                         Spell allows auths (governance) to do any arbitrary call\n    /// @param target_                  Address to which the call needs to be delegated\n    /// @param data_                    Data to execute at the delegated address\n    function spell(address target_, bytes memory data_) external onlyOwner returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @return amount_ Amount of shares actually minted\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint256 shares_,\n        uint256 maxToken0Deposit_,\n        uint256 maxToken1Deposit_\n    )\n        external\n        payable\n        setDexFrom\n        _updateExchangePrice\n        nonReentrant\n        returns (uint256 amount_, uint256 token0Amt_, uint256 token1Amt_)\n    {\n        if (!IS_NATIVE_PAIR) {\n            if (msg.value > 0) {\n                revert FluidSmartLendingError(ErrorTypes.SmartLending__InvalidMsgValue);\n            }\n\n            (token0Amt_, token1Amt_) = DEX.depositPerfect(shares_, maxToken0Deposit_, maxToken1Deposit_, false);\n        } else {\n            uint256 value_ = TOKEN0 == ETH_ADDRESS ? maxToken0Deposit_ : maxToken1Deposit_;\n            if (value_ > msg.value) {\n                revert FluidSmartLendingError(ErrorTypes.SmartLending__InvalidMsgValue);\n            }\n\n            uint256 initialEthAmount_ = address(this).balance - msg.value;\n\n            (token0Amt_, token1Amt_) = DEX.depositPerfect{ value: value_ }(\n                shares_,\n                maxToken0Deposit_,\n                maxToken1Deposit_,\n                false\n            );\n\n            uint finalEth_ = payable(address(this)).balance;\n            if (finalEth_ > initialEthAmount_) {\n                unchecked {\n                    SafeTransfer.safeTransferNative(msg.sender, finalEth_ - initialEthAmount_); // sending back excess ETH\n                }\n            }\n        }\n\n        amount_ = (shares_ * 1e18) / exchangePrice - 1;\n\n        _mint(msg.sender, amount_);\n    }\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @return amount_ The amount of tokens minted for the deposit\n    /// @return shares_ The number of dex pool shares deposited\n    function deposit(\n        uint256 token0Amt_,\n        uint256 token1Amt_,\n        uint256 minSharesAmt_\n    ) external payable setDexFrom _updateExchangePrice nonReentrant returns (uint256 amount_, uint256 shares_) {\n        uint256 value_ = !IS_NATIVE_PAIR\n            ? 0\n            : (TOKEN0 == ETH_ADDRESS)\n                ? token0Amt_\n                : token1Amt_;\n\n        if (value_ != msg.value) {\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__InvalidMsgValue);\n        }\n\n        shares_ = DEX.deposit{ value: value_ }(token0Amt_, token1Amt_, minSharesAmt_, false);\n\n        amount_ = (shares_ * 1e18) / exchangePrice - 1;\n\n        _mint(msg.sender, amount_);\n    }\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw. set to type(uint).max to withdraw maximum balance.\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender.\n    /// @return amount_ amount_ of shares actually burnt\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint256 shares_,\n        uint256 minToken0Withdraw_,\n        uint256 minToken1Withdraw_,\n        address to_\n    ) external _updateExchangePrice nonReentrant returns (uint256 amount_, uint256 token0Amt_, uint256 token1Amt_) {\n        if (shares_ == type(uint).max) {\n            amount_ = balanceOf(msg.sender);\n            shares_ = (amount_ * exchangePrice) / 1e18 - 1;\n        } else {\n            amount_ = (shares_ * 1e18) / exchangePrice + 1;\n        }\n\n        _burn(msg.sender, amount_);\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        (token0Amt_, token1Amt_) = DEX.withdrawPerfect(shares_, minToken0Withdraw_, minToken1Withdraw_, to_);\n    }\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return amount_ The number of tokens burned for the withdrawal\n    /// @return shares_ The number of dex pool shares withdrawn\n    function withdraw(\n        uint256 token0Amt_,\n        uint256 token1Amt_,\n        uint256 maxSharesAmt_,\n        address to_\n    ) external _updateExchangePrice nonReentrant returns (uint256 amount_, uint256 shares_) {\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        shares_ = DEX.withdraw(token0Amt_, token1Amt_, maxSharesAmt_, to_);\n\n        amount_ = (shares_ * 1e18) / exchangePrice + 1;\n\n        _burn(msg.sender, amount_);\n    }\n\n    /// @dev Rebalances the share to tokens ratio to balance out rewards and fees\n    function rebalance(\n        uint256 minOrMaxToken0_,\n        uint256 minOrMaxToken1_\n    )\n        public\n        payable\n        _updateExchangePrice\n        nonReentrant\n        returns (uint256 shares_, uint256 token0Amt_, uint256 token1Amt_, bool isWithdraw_)\n    {\n        if (rebalancer != msg.sender) revert FluidSmartLendingError(ErrorTypes.SmartLending__InvalidRebalancer);\n\n        int256 rebalanceDiff_ = rebalanceDiff();\n\n        if (rebalanceDiff_ > 0) {\n            // fees (withdraw)\n            isWithdraw_ = true;\n            if (msg.value > 0) {\n                revert FluidSmartLendingError(ErrorTypes.SmartLending__InvalidMsgValue);\n            }\n            shares_ = uint256(rebalanceDiff_);\n            (token0Amt_, token1Amt_) = DEX.withdrawPerfect(shares_, minOrMaxToken0_, minOrMaxToken1_, msg.sender);\n        } else if (rebalanceDiff_ < 0) {\n            // rewards (deposit)\n            isWithdraw_ = false;\n\n            uint256 initialEthAmount_ = address(this).balance - msg.value;\n\n            uint256 value_ = !IS_NATIVE_PAIR\n                ? 0\n                : (TOKEN0 == ETH_ADDRESS)\n                    ? minOrMaxToken0_\n                    : minOrMaxToken1_;\n\n            if (value_ > msg.value) {\n                revert FluidSmartLendingError(ErrorTypes.SmartLending__InvalidMsgValue);\n            }\n\n            shares_ = uint256(-rebalanceDiff_);\n\n            dexFromAddress = msg.sender;\n            (token0Amt_, token1Amt_) = DEX.depositPerfect{ value: value_ }(\n                shares_,\n                minOrMaxToken0_,\n                minOrMaxToken1_,\n                false\n            );\n            dexFromAddress = DEAD_ADDRESS;\n\n            uint finalEth_ = payable(address(this)).balance;\n            if (finalEth_ > initialEthAmount_) {\n                unchecked {\n                    SafeTransfer.safeTransferNative(msg.sender, finalEth_ - initialEthAmount_); // sending back excess ETH\n                }\n            }\n        }\n\n        emit LogRebalance(shares_, token0Amt_, token1Amt_, isWithdraw_);\n    }\n\n    /// @dev Returns the difference between the total smart lending shares on the DEX and the total smart lending shares calculated.\n    /// A positive value indicates fees to collect, while a positive value indicates rewards to be rebalanced.\n    function rebalanceDiff() public view returns (int256) {\n        uint256 totalSmartLendingSharesOnDex_ = DEX.readFromStorage(\n            DexSlotsLink.calculateMappingStorageSlot(DexSlotsLink.DEX_USER_SUPPLY_MAPPING_SLOT, address(this))\n        );\n        totalSmartLendingSharesOnDex_ = BigMathMinified.fromBigNumber(\n            (totalSmartLendingSharesOnDex_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & DexCalcs.X64,\n            DexCalcs.DEFAULT_EXPONENT_SIZE,\n            DexCalcs.DEFAULT_EXPONENT_MASK\n        );\n\n        uint256 totalSmartLendingShares_ = (totalSupply() * exchangePrice) / 1e18;\n\n        return int256(totalSmartLendingSharesOnDex_) - int256(totalSmartLendingShares_);\n    }\n\n    /// @notice   dex liquidity callback\n    /// @param    token_ The token being transferred\n    /// @param    amount_ The amount being transferred\n    function dexCallback(address token_, uint256 amount_) external {\n        if (msg.sender != address(DEX)) {\n            revert FluidSmartLendingError(ErrorTypes.SmartLending__Unauthorized);\n        }\n        SafeTransfer.safeTransferFrom(token_, dexFromAddress, LIQUIDITY, amount_);\n    }\n\n    /// @dev for excess eth being sent back from dex to here\n    receive() external payable {}\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     * taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/Math.sol\n     */\n    function _log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     * taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\n     */\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    function _toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = _log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n}\n"
    },
    "solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
    },
    "solmate/src/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}