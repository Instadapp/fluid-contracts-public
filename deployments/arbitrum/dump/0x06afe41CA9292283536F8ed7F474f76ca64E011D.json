{
  "address": "0x06afe41CA9292283536F8ed7F474f76ca64E011D",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IFluidVaultResolver",
          "name": "vaultResolver_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "FluidVaultTicksBranchesResolver__AddressZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "VAULT_RESOLVER",
      "outputs": [
        {
          "internalType": "contract IFluidVaultResolver",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllVaultsBranchesDebt",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "debtRaw",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "collateralRaw",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "debtNormal",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "collateralNormal",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "branchId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "status",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "tick",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "partials",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "debtFactor",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "baseBranchId",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "baseBranchTick",
                  "type": "int256"
                }
              ],
              "internalType": "struct Structs.BranchDebt[]",
              "name": "branchDebt",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct Structs.BranchesDebt[]",
          "name": "branchesDebt_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "totalTicks_",
          "type": "uint256"
        }
      ],
      "name": "getAllVaultsTicksDebt",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "debtRaw",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "collateralRaw",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "debtNormal",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "collateralNormal",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "tick",
                  "type": "int256"
                }
              ],
              "internalType": "struct Structs.TickDebt[]",
              "name": "tickDebt",
              "type": "tuple[]"
            },
            {
              "internalType": "int256",
              "name": "toTick",
              "type": "int256"
            }
          ],
          "internalType": "struct Structs.VaultsTickDebt[]",
          "name": "vaultsTickDebt_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "fromBranchId_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "toBranchId_",
          "type": "uint256"
        }
      ],
      "name": "getBranchesDebt",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "debtRaw",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collateralRaw",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "debtNormal",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collateralNormal",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "branchId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "status",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "tick",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "partials",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "ratio",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "debtFactor",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "baseBranchId",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "baseBranchTick",
              "type": "int256"
            }
          ],
          "internalType": "struct Structs.BranchDebt[]",
          "name": "branchesDebt_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "vaults_",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "fromBranchIds_",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "toBranchIds_",
          "type": "uint256[]"
        }
      ],
      "name": "getMultipleVaultsBranchesDebt",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "debtRaw",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "collateralRaw",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "debtNormal",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "collateralNormal",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "branchId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "status",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "tick",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "partials",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "debtFactor",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "baseBranchId",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "baseBranchTick",
                  "type": "int256"
                }
              ],
              "internalType": "struct Structs.BranchDebt[]",
              "name": "branchDebt",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct Structs.BranchesDebt[]",
          "name": "branchesDebt_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "vaults_",
          "type": "address[]"
        },
        {
          "internalType": "int256[]",
          "name": "fromTicks_",
          "type": "int256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "totalTicks_",
          "type": "uint256[]"
        }
      ],
      "name": "getMultipleVaultsTicksDebt",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "debtRaw",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "collateralRaw",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "debtNormal",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "collateralNormal",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "tick",
                  "type": "int256"
                }
              ],
              "internalType": "struct Structs.TickDebt[]",
              "name": "tickDebt",
              "type": "tuple[]"
            },
            {
              "internalType": "int256",
              "name": "toTick",
              "type": "int256"
            }
          ],
          "internalType": "struct Structs.VaultsTickDebt[]",
          "name": "vaultsTickDebt_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        },
        {
          "internalType": "int256",
          "name": "fromTick_",
          "type": "int256"
        },
        {
          "internalType": "uint256",
          "name": "totalTicks_",
          "type": "uint256"
        }
      ],
      "name": "getTicksDebt",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "debtRaw",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collateralRaw",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "debtNormal",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collateralNormal",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "ratio",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "tick",
              "type": "int256"
            }
          ],
          "internalType": "struct Structs.TickDebt[]",
          "name": "ticksDebt_",
          "type": "tuple[]"
        },
        {
          "internalType": "int256",
          "name": "toTick_",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xab513c396961a2badfebb7feb5428d617ac8a65fe5c2f3760d231c80cc613a05",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x0Ed35B1609Ec45c7079E80d11149a52717e4859A",
    "contractAddress": null,
    "transactionIndex": 3,
    "gasUsed": "3826864",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd17fb892d0b97cc9f1bbe575730aa34189d31201c02500eeb5cd9d9908cdea42",
    "transactionHash": "0xab513c396961a2badfebb7feb5428d617ac8a65fe5c2f3760d231c80cc613a05",
    "logs": [],
    "blockNumber": 220708469,
    "cumulativeGasUsed": "4142708",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x77648D39be25a1422467060e11E5b979463bEA3d"
  ],
  "numDeployments": 2,
  "solcInputHash": "09ef5f25427412692b8e9ff1980d94df",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IFluidVaultResolver\",\"name\":\"vaultResolver_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FluidVaultTicksBranchesResolver__AddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VAULT_RESOLVER\",\"outputs\":[{\"internalType\":\"contract IFluidVaultResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllVaultsBranchesDebt\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"debtRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtNormal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralNormal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"branchId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"tick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"partials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBranchId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"baseBranchTick\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.BranchDebt[]\",\"name\":\"branchDebt\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Structs.BranchesDebt[]\",\"name\":\"branchesDebt_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalTicks_\",\"type\":\"uint256\"}],\"name\":\"getAllVaultsTicksDebt\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"debtRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtNormal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralNormal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"tick\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.TickDebt[]\",\"name\":\"tickDebt\",\"type\":\"tuple[]\"},{\"internalType\":\"int256\",\"name\":\"toTick\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.VaultsTickDebt[]\",\"name\":\"vaultsTickDebt_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromBranchId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toBranchId_\",\"type\":\"uint256\"}],\"name\":\"getBranchesDebt\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"debtRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtNormal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralNormal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"branchId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"tick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"partials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBranchId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"baseBranchTick\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.BranchDebt[]\",\"name\":\"branchesDebt_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaults_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"fromBranchIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"toBranchIds_\",\"type\":\"uint256[]\"}],\"name\":\"getMultipleVaultsBranchesDebt\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"debtRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtNormal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralNormal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"branchId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"tick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"partials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBranchId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"baseBranchTick\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.BranchDebt[]\",\"name\":\"branchDebt\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Structs.BranchesDebt[]\",\"name\":\"branchesDebt_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaults_\",\"type\":\"address[]\"},{\"internalType\":\"int256[]\",\"name\":\"fromTicks_\",\"type\":\"int256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"totalTicks_\",\"type\":\"uint256[]\"}],\"name\":\"getMultipleVaultsTicksDebt\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"debtRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtNormal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralNormal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"tick\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.TickDebt[]\",\"name\":\"tickDebt\",\"type\":\"tuple[]\"},{\"internalType\":\"int256\",\"name\":\"toTick\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.VaultsTickDebt[]\",\"name\":\"vaultsTickDebt_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"fromTick_\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"totalTicks_\",\"type\":\"uint256\"}],\"name\":\"getTicksDebt\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"debtRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtNormal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralNormal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"tick\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.TickDebt[]\",\"name\":\"ticksDebt_\",\"type\":\"tuple[]\"},{\"internalType\":\"int256\",\"name\":\"toTick_\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"errors\":{\"FluidVaultTicksBranchesResolver__AddressZero()\":[{\"notice\":\"thrown if an input param address is zero\"}]},\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"constructor sets the immutable vault resolver address\"}},\"notice\":\"Fluid Vault protocol ticks & branches resolver\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/periphery/resolvers/vaultTicksBranches/main.sol\":\"FluidVaultTicksBranchesResolver\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[]},\"sources\":{\"contracts/libraries/bigMathMinified.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\\n/// result in significant gas cost reduction due to storage space reduction.\\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\\nlibrary BigMathMinified {\\n    /// @dev constants to use for `roundUp` input param to increase readability\\n    bool internal constant ROUND_DOWN = false;\\n    bool internal constant ROUND_UP = true;\\n\\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\\n    /// e.g.:\\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\\n    /// exponent =                                            0011,0011     (51)\\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\\n    ///\\n    /// @param normal number which needs to be converted into Big Number\\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\\n    /// @param roundUp signals if result should be rounded down or up\\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\\n    function toBigNumber(\\n        uint256 normal,\\n        uint256 coefficientSize,\\n        uint256 exponentSize,\\n        bool roundUp\\n    ) internal pure returns (uint256 bigNumber) {\\n        assembly {\\n            let lastBit_\\n            let number_ := normal\\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x80, number_)\\n                lastBit_ := 0x80\\n            }\\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x40, number_)\\n                lastBit_ := add(lastBit_, 0x40)\\n            }\\n            if gt(number_, 0xFFFFFFFF) {\\n                number_ := shr(0x20, number_)\\n                lastBit_ := add(lastBit_, 0x20)\\n            }\\n            if gt(number_, 0xFFFF) {\\n                number_ := shr(0x10, number_)\\n                lastBit_ := add(lastBit_, 0x10)\\n            }\\n            if gt(number_, 0xFF) {\\n                number_ := shr(0x8, number_)\\n                lastBit_ := add(lastBit_, 0x8)\\n            }\\n            if gt(number_, 0xF) {\\n                number_ := shr(0x4, number_)\\n                lastBit_ := add(lastBit_, 0x4)\\n            }\\n            if gt(number_, 0x3) {\\n                number_ := shr(0x2, number_)\\n                lastBit_ := add(lastBit_, 0x2)\\n            }\\n            if gt(number_, 0x1) {\\n                lastBit_ := add(lastBit_, 1)\\n            }\\n            if gt(number_, 0) {\\n                lastBit_ := add(lastBit_, 1)\\n            }\\n            if lt(lastBit_, coefficientSize) {\\n                // for throw exception\\n                lastBit_ := coefficientSize\\n            }\\n            let exponent := sub(lastBit_, coefficientSize)\\n            let coefficient := shr(exponent, normal)\\n            if and(roundUp, gt(exponent, 0)) {\\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\\n                coefficient := add(coefficient, 1)\\n                if eq(shl(coefficientSize, 1), coefficient) {\\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\\n                    coefficient := shl(sub(coefficientSize, 1), 1)\\n                    exponent := add(exponent, 1)\\n                }\\n            }\\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\\n                // if exponent is >= exponentSize, the normal number is too big to fit within\\n                // BigNumber with too small sizes for coefficient and exponent\\n                revert(0, 0)\\n            }\\n            bigNumber := shl(exponentSize, coefficient)\\n            bigNumber := add(bigNumber, exponent)\\n        }\\n    }\\n\\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\\n    function fromBigNumber(\\n        uint256 bigNumber,\\n        uint256 exponentSize,\\n        uint256 exponentMask\\n    ) internal pure returns (uint256 normal) {\\n        assembly {\\n            let coefficient := shr(exponentSize, bigNumber)\\n            let exponent := and(bigNumber, exponentMask)\\n            normal := shl(exponent, coefficient)\\n        }\\n    }\\n\\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\\n    /// e.g.\\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\\n        assembly {\\n            let number_ := normal\\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x80, number_)\\n                lastBit := 0x80\\n            }\\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x40, number_)\\n                lastBit := add(lastBit, 0x40)\\n            }\\n            if gt(number_, 0xFFFFFFFF) {\\n                number_ := shr(0x20, number_)\\n                lastBit := add(lastBit, 0x20)\\n            }\\n            if gt(number_, 0xFFFF) {\\n                number_ := shr(0x10, number_)\\n                lastBit := add(lastBit, 0x10)\\n            }\\n            if gt(number_, 0xFF) {\\n                number_ := shr(0x8, number_)\\n                lastBit := add(lastBit, 0x8)\\n            }\\n            if gt(number_, 0xF) {\\n                number_ := shr(0x4, number_)\\n                lastBit := add(lastBit, 0x4)\\n            }\\n            if gt(number_, 0x3) {\\n                number_ := shr(0x2, number_)\\n                lastBit := add(lastBit, 0x2)\\n            }\\n            if gt(number_, 0x1) {\\n                lastBit := add(lastBit, 1)\\n            }\\n            if gt(number_, 0) {\\n                lastBit := add(lastBit, 1)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf0be1002909edf30aec3dc6623c2bd2407ed94064b62674c01032b844dec206a\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/tickMath.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @title library that calculates number \\\"tick\\\" and \\\"ratioX96\\\" from this: ratioX96 = (1.0015^tick) * 2^96\\n/// @notice this library is used in Fluid Vault protocol for optimiziation.\\n/// @dev \\\"tick\\\" supports between -32767 and 32767. \\\"ratioX96\\\" supports between 37075072 and 169307877264527972847801929085841449095838922544595\\nlibrary TickMath {\\n    /// The minimum tick that can be passed in getRatioAtTick. 1.0015**-32767\\n    int24 internal constant MIN_TICK = -32767;\\n    /// The maximum tick that can be passed in getRatioAtTick. 1.0015**32767\\n    int24 internal constant MAX_TICK = 32767;\\n\\n    uint256 internal constant FACTOR00 = 0x100000000000000000000000000000000;\\n    uint256 internal constant FACTOR01 = 0xff9dd7de423466c20352b1246ce4856f; // 2^128/1.0015**1 = 339772707859149738855091969477551883631\\n    uint256 internal constant FACTOR02 = 0xff3bd55f4488ad277531fa1c725a66d0; // 2^128/1.0015**2 = 339263812140938331358054887146831636176\\n    uint256 internal constant FACTOR03 = 0xfe78410fd6498b73cb96a6917f853259; // 2^128/1.0015**4 = 338248306163758188337119769319392490073\\n    uint256 internal constant FACTOR04 = 0xfcf2d9987c9be178ad5bfeffaa123273; // 2^128/1.0015**8 = 336226404141693512316971918999264834163\\n    uint256 internal constant FACTOR05 = 0xf9ef02c4529258b057769680fc6601b3; // 2^128/1.0015**16 = 332218786018727629051611634067491389875\\n    uint256 internal constant FACTOR06 = 0xf402d288133a85a17784a411f7aba082; // 2^128/1.0015**32 = 324346285652234375371948336458280706178\\n    uint256 internal constant FACTOR07 = 0xe895615b5beb6386553757b0352bda90; // 2^128/1.0015**64 = 309156521885964218294057947947195947664\\n    uint256 internal constant FACTOR08 = 0xd34f17a00ffa00a8309940a15930391a; // 2^128/1.0015**128 = 280877777739312896540849703637713172762 \\n    uint256 internal constant FACTOR09 = 0xae6b7961714e20548d88ea5123f9a0ff; // 2^128/1.0015**256 = 231843708922198649176471782639349113087\\n    uint256 internal constant FACTOR10 = 0x76d6461f27082d74e0feed3b388c0ca1; // 2^128/1.0015**512 = 157961477267171621126394973980180876449\\n    uint256 internal constant FACTOR11 = 0x372a3bfe0745d8b6b19d985d9a8b85bb; // 2^128/1.0015**1024 = 73326833024599564193373530205717235131\\n    uint256 internal constant FACTOR12 = 0x0be32cbee48979763cf7247dd7bb539d; // 2^128/1.0015**2048 = 15801066890623697521348224657638773661\\n    uint256 internal constant FACTOR13 = 0x8d4f70c9ff4924dac37612d1e2921e;   // 2^128/1.0015**4096 = 733725103481409245883800626999235102\\n    uint256 internal constant FACTOR14 = 0x4e009ae5519380809a02ca7aec77;     // 2^128/1.0015**8192 = 1582075887005588088019997442108535\\n    uint256 internal constant FACTOR15 = 0x17c45e641b6e95dee056ff10;         // 2^128/1.0015**16384 = 7355550435635883087458926352\\n\\n    /// The minimum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MIN_TICK). ~ Equivalent to `(1 << 96) * (1.0015**-32767)`\\n    uint256 internal constant MIN_RATIOX96 = 37075072;\\n    /// The maximum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MAX_TICK).\\n    /// ~ Equivalent to `(1 << 96) * (1.0015**32767)`, rounding etc. leading to minor difference\\n    uint256 internal constant MAX_RATIOX96 = 169307877264527972847801929085841449095838922544595;\\n\\n    uint256 internal constant ZERO_TICK_SCALED_RATIO = 0x1000000000000000000000000; // 1 << 96 // 79228162514264337593543950336\\n    uint256 internal constant _1E26 = 1e26;\\n\\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return ratioX96 ratio = (debt amount/collateral amount)\\n    function getRatioAtTick(int tick) internal pure returns (uint256 ratioX96) {\\n        assembly {\\n            let absTick_ := sub(xor(tick, sar(255, tick)), sar(255, tick))\\n\\n            if gt(absTick_, MAX_TICK) {\\n                revert(0, 0)\\n            }\\n            let factor_ := FACTOR00\\n            if and(absTick_, 0x1) {\\n                factor_ := FACTOR01\\n            }\\n            if and(absTick_, 0x2) {\\n                factor_ := shr(128, mul(factor_, FACTOR02))\\n            }\\n            if and(absTick_, 0x4) {\\n                factor_ := shr(128, mul(factor_, FACTOR03))\\n            }\\n            if and(absTick_, 0x8) {\\n                factor_ := shr(128, mul(factor_, FACTOR04))\\n            }\\n            if and(absTick_, 0x10) {\\n                factor_ := shr(128, mul(factor_, FACTOR05))\\n            }\\n            if and(absTick_, 0x20) {\\n                factor_ := shr(128, mul(factor_, FACTOR06))\\n            }\\n            if and(absTick_, 0x40) {\\n                factor_ := shr(128, mul(factor_, FACTOR07))\\n            }\\n            if and(absTick_, 0x80) {\\n                factor_ := shr(128, mul(factor_, FACTOR08))\\n            }\\n            if and(absTick_, 0x100) {\\n                factor_ := shr(128, mul(factor_, FACTOR09))\\n            }\\n            if and(absTick_, 0x200) {\\n                factor_ := shr(128, mul(factor_, FACTOR10))\\n            }\\n            if and(absTick_, 0x400) {\\n                factor_ := shr(128, mul(factor_, FACTOR11))\\n            }\\n            if and(absTick_, 0x800) {\\n                factor_ := shr(128, mul(factor_, FACTOR12))\\n            }\\n            if and(absTick_, 0x1000) {\\n                factor_ := shr(128, mul(factor_, FACTOR13))\\n            }\\n            if and(absTick_, 0x2000) {\\n                factor_ := shr(128, mul(factor_, FACTOR14))\\n            }\\n            if and(absTick_, 0x4000) {\\n                factor_ := shr(128, mul(factor_, FACTOR15))\\n            }\\n\\n            let precision_ := 0\\n            if iszero(and(tick, 0x8000000000000000000000000000000000000000000000000000000000000000)) {\\n                factor_ := div(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, factor_)\\n                // we round up in the division so getTickAtRatio of the output price is always consistent\\n                if mod(factor_, 0x100000000) {\\n                    precision_ := 1\\n                }\\n            }\\n            ratioX96 := add(shr(32, factor_), precision_)\\n        }\\n    }\\n\\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\\n    /// @dev Throws if ratioX96 > max ratio || ratioX96 < min ratio\\n    /// @param ratioX96 The input ratio; ratio = (debt amount/collateral amount)\\n    /// @return tick The output tick for the above formula. Returns in round down form. if tick is 123.23 then 123, if tick is -123.23 then returns -124\\n    /// @return perfectRatioX96 perfect ratio for the above tick\\n    function getTickAtRatio(uint256 ratioX96) internal pure returns (int tick, uint perfectRatioX96) {\\n        assembly {\\n            if or(gt(ratioX96, MAX_RATIOX96), lt(ratioX96, MIN_RATIOX96)) {\\n                revert(0, 0)\\n            }\\n\\n            let cond := lt(ratioX96, ZERO_TICK_SCALED_RATIO)\\n            let factor_\\n\\n            if iszero(cond) {\\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\\n                factor_ := div(mul(ratioX96, _1E26), ZERO_TICK_SCALED_RATIO)\\n            }\\n            if cond {\\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\\n                factor_ := div(mul(ZERO_TICK_SCALED_RATIO, _1E26), ratioX96)\\n            }\\n\\n            // put in https://www.wolframalpha.com/ whole equation: (1.0015^tick) * 2^96 * 10^26 / 79228162514264337593543950336\\n\\n            // for tick = 16384\\n            // ratioX96 = (1.0015^16384) * 2^96 = 3665252098134783297721995888537077351735\\n            // 3665252098134783297721995888537077351735 * 10^26 / 79228162514264337593543950336 =\\n            // 4626198540796508716348404308345255985.06131964639489434655721\\n            if iszero(lt(factor_, 4626198540796508716348404308345255985)) {\\n                tick := or(tick, 0x4000)\\n                factor_ := div(mul(factor_, _1E26), 4626198540796508716348404308345255985)\\n            }\\n            // for tick = 8192\\n            // ratioX96 = (1.0015^8192) * 2^96 = 17040868196391020479062776466509865\\n            // 17040868196391020479062776466509865 * 10^26 / 79228162514264337593543950336 =\\n            // 21508599537851153911767490449162.3037648642153898377655505172\\n            if iszero(lt(factor_, 21508599537851153911767490449162)) {\\n                tick := or(tick, 0x2000)\\n                factor_ := div(mul(factor_, _1E26), 21508599537851153911767490449162)\\n            }\\n            // for tick = 4096\\n            // ratioX96 = (1.0015^4096) * 2^96 = 36743933851015821532611831851150\\n            // 36743933851015821532611831851150 * 10^26 / 79228162514264337593543950336 =\\n            // 46377364670549310883002866648.9777607649742626173648716941385\\n            if iszero(lt(factor_, 46377364670549310883002866649)) {\\n                tick := or(tick, 0x1000)\\n                factor_ := div(mul(factor_, _1E26), 46377364670549310883002866649)\\n            }\\n            // for tick = 2048\\n            // ratioX96 = (1.0015^2048) * 2^96 = 1706210527034005899209104452335\\n            // 1706210527034005899209104452335 * 10^26 / 79228162514264337593543950336 =\\n            // 2153540449365864845468344760.06357108484096046743300420319322\\n            if iszero(lt(factor_, 2153540449365864845468344760)) {\\n                tick := or(tick, 0x800)\\n                factor_ := div(mul(factor_, _1E26), 2153540449365864845468344760)\\n            }\\n            // for tick = 1024\\n            // ratioX96 = (1.0015^1024) * 2^96 = 367668226692760093024536487236\\n            // 367668226692760093024536487236 * 10^26 / 79228162514264337593543950336 =\\n            // 464062544207767844008185024.950588990554136265212906454481127\\n            if iszero(lt(factor_, 464062544207767844008185025)) {\\n                tick := or(tick, 0x400)\\n                factor_ := div(mul(factor_, _1E26), 464062544207767844008185025)\\n            }\\n            // for tick = 512\\n            // ratioX96 = (1.0015^512) * 2^96 = 170674186729409605620119663668\\n            // 170674186729409605620119663668 * 10^26 / 79228162514264337593543950336 =\\n            // 215421109505955298802281577.031879604792139232258508172947569\\n            if iszero(lt(factor_, 215421109505955298802281577)) {\\n                tick := or(tick, 0x200)\\n                factor_ := div(mul(factor_, _1E26), 215421109505955298802281577)\\n            }\\n            // for tick = 256\\n            // ratioX96 = (1.0015^256) * 2^96 = 116285004205991934861656513301\\n            // 116285004205991934861656513301 * 10^26 / 79228162514264337593543950336 =\\n            // 146772309890508740607270614.667650899656438875541505058062410\\n            if iszero(lt(factor_, 146772309890508740607270615)) {\\n                tick := or(tick, 0x100)\\n                factor_ := div(mul(factor_, _1E26), 146772309890508740607270615)\\n            }\\n            // for tick = 128\\n            // ratioX96 = (1.0015^128) * 2^96 = 95984619659632141743747099590\\n            // 95984619659632141743747099590 * 10^26 / 79228162514264337593543950336 =\\n            // 121149622323187099817270416.157248837742741760456796835775887\\n            if iszero(lt(factor_, 121149622323187099817270416)) {\\n                tick := or(tick, 0x80)\\n                factor_ := div(mul(factor_, _1E26), 121149622323187099817270416)\\n            }\\n            // for tick = 64\\n            // ratioX96 = (1.0015^64) * 2^96 = 87204845308406958006717891124\\n            // 87204845308406958006717891124 * 10^26 / 79228162514264337593543950336 =\\n            // 110067989135437147685980801.568068573422377364214113968609839\\n            if iszero(lt(factor_, 110067989135437147685980801)) {\\n                tick := or(tick, 0x40)\\n                factor_ := div(mul(factor_, _1E26), 110067989135437147685980801)\\n            }\\n            // for tick = 32\\n            // ratioX96 = (1.0015^32) * 2^96 = 83120873769022354029916374475\\n            // 83120873769022354029916374475 * 10^26 / 79228162514264337593543950336 =\\n            // 104913292358707887270979599.831816586773651266562785765558183\\n            if iszero(lt(factor_, 104913292358707887270979600)) {\\n                tick := or(tick, 0x20)\\n                factor_ := div(mul(factor_, _1E26), 104913292358707887270979600)\\n            }\\n            // for tick = 16\\n            // ratioX96 = (1.0015^16) * 2^96 = 81151180492336368327184716176\\n            // 81151180492336368327184716176 * 10^26 / 79228162514264337593543950336 =\\n            // 102427189924701091191840927.762844039579442328381455567932128\\n            if iszero(lt(factor_, 102427189924701091191840928)) {\\n                tick := or(tick, 0x10)\\n                factor_ := div(mul(factor_, _1E26), 102427189924701091191840928)\\n            }\\n            // for tick = 8\\n            // ratioX96 = (1.0015^8) * 2^96 = 80183906840906820640659903620\\n            // 80183906840906820640659903620 * 10^26 / 79228162514264337593543950336 =\\n            // 101206318935480056907421312.890625\\n            if iszero(lt(factor_, 101206318935480056907421313)) {\\n                tick := or(tick, 0x8)\\n                factor_ := div(mul(factor_, _1E26), 101206318935480056907421313)\\n            }\\n            // for tick = 4\\n            // ratioX96 = (1.0015^4) * 2^96 = 79704602139525152702959747603\\n            // 79704602139525152702959747603 * 10^26 / 79228162514264337593543950336 =\\n            // 100601351350506250000000000\\n            if iszero(lt(factor_, 100601351350506250000000000)) {\\n                tick := or(tick, 0x4)\\n                factor_ := div(mul(factor_, _1E26), 100601351350506250000000000)\\n            }\\n            // for tick = 2\\n            // ratioX96 = (1.0015^2) * 2^96 = 79466025265172787701084167660\\n            // 79466025265172787701084167660 * 10^26 / 79228162514264337593543950336 =\\n            // 100300225000000000000000000\\n            if iszero(lt(factor_, 100300225000000000000000000)) {\\n                tick := or(tick, 0x2)\\n                factor_ := div(mul(factor_, _1E26), 100300225000000000000000000)\\n            }\\n            // for tick = 1\\n            // ratioX96 = (1.0015^1) * 2^96 = 79347004758035734099934266261\\n            // 79347004758035734099934266261 * 10^26 / 79228162514264337593543950336 =\\n            // 100150000000000000000000000\\n            if iszero(lt(factor_, 100150000000000000000000000)) {\\n                tick := or(tick, 0x1)\\n                factor_ := div(mul(factor_, _1E26), 100150000000000000000000000)\\n            }\\n            if iszero(cond) {\\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\\n                perfectRatioX96 := div(mul(ratioX96, _1E26), factor_)\\n            }\\n            if cond {\\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\\n                tick := not(tick)\\n                perfectRatioX96 := div(mul(ratioX96, factor_), 100150000000000000000000000)\\n            }\\n            // perfect ratio should always be <= ratioX96\\n            // not sure if it can ever be bigger but better to have extra checks\\n            if gt(perfectRatioX96, ratioX96) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc5c13deaa16bb036a4370c0e38c33445712e8e7da1c792018dd3dc4a641ea0c0\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/adminModule/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Structs {\\n    struct AddressBool {\\n        address addr;\\n        bool value;\\n    }\\n\\n    struct AddressUint256 {\\n        address addr;\\n        uint256 value;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 1\\n    struct RateDataV1Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\\n        uint256 kink;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink;\\n        ///\\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 2\\n    struct RateDataV2Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\\n        uint256 kink1;\\n        ///\\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\\n        uint256 kink2;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink1;\\n        ///\\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\\n        uint256 rateAtUtilizationKink2;\\n        ///\\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set token config\\n    struct TokenConfig {\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 fee;\\n        ///\\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 threshold;\\n        ///\\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\\n        uint256 maxUtilization;\\n    }\\n\\n    /// @notice struct to set user supply & withdrawal config\\n    struct UserSupplyConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration withdrawal limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseWithdrawalLimit;\\n    }\\n\\n    /// @notice struct to set user borrow & payback config\\n    struct UserBorrowConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which debt limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration debt limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseDebtCeiling;\\n        ///\\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 maxDebtCeiling;\\n    }\\n}\\n\",\"keccak256\":\"0x10353c70015f27b880125cefab806dbed24a4458f187da66964f3ef60488f757\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/liquidity/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Structs as AdminModuleStructs } from \\\"../../../liquidity/adminModule/structs.sol\\\";\\n\\nabstract contract Structs {\\n    struct RateData {\\n        uint256 version;\\n        AdminModuleStructs.RateDataV1Params rateDataV1;\\n        AdminModuleStructs.RateDataV2Params rateDataV2;\\n    }\\n\\n    struct OverallTokenData {\\n        uint256 borrowRate;\\n        uint256 supplyRate;\\n        uint256 fee; // revenue fee\\n        uint256 lastStoredUtilization;\\n        uint256 storageUpdateThreshold;\\n        uint256 lastUpdateTimestamp;\\n        uint256 supplyExchangePrice;\\n        uint256 borrowExchangePrice;\\n        uint256 supplyRawInterest;\\n        uint256 supplyInterestFree;\\n        uint256 borrowRawInterest;\\n        uint256 borrowInterestFree;\\n        uint256 totalSupply;\\n        uint256 totalBorrow;\\n        uint256 revenue;\\n        uint256 maxUtilization; // maximum allowed utilization\\n        RateData rateData;\\n    }\\n\\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\\n    struct UserSupplyData {\\n        bool modeWithInterest; // true if mode = with interest, false = without interest\\n        uint256 supply; // user supply amount\\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\\n        uint256 withdrawalLimit;\\n        uint256 lastUpdateTimestamp;\\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\\n        uint256 baseWithdrawalLimit;\\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\\n        uint256 withdrawableUntilLimit;\\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\\n    }\\n\\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\\n    struct UserBorrowData {\\n        bool modeWithInterest; // true if mode = with interest, false = without interest\\n        uint256 borrow; // user borrow amount\\n        uint256 borrowLimit;\\n        uint256 lastUpdateTimestamp;\\n        uint256 expandPercent;\\n        uint256 expandDuration;\\n        uint256 baseBorrowLimit;\\n        uint256 maxBorrowLimit;\\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\\n    }\\n}\\n\",\"keccak256\":\"0xf8a59b6c7963d0bd43be07db0c594e278f97e6dfa498dee8436e3707dd9f574e\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vault/iVaultResolver.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { Structs } from \\\"./structs.sol\\\";\\n\\ninterface IFluidVaultResolver {\\n    function vaultByNftId(uint nftId_) external view returns (address vault_);\\n\\n    function positionByNftId(\\n        uint nftId_\\n    ) external view returns (Structs.UserPosition memory userPosition_, Structs.VaultEntireData memory vaultData_);\\n\\n    function getVaultVariablesRaw(address vault_) external view returns (uint);\\n\\n    function getVaultVariables2Raw(address vault_) external view returns (uint);\\n\\n    function getTickHasDebtRaw(address vault_, int key_) external view returns (uint);\\n\\n    function getTickDataRaw(address vault_, int tick_) external view returns (uint);\\n\\n    function getBranchDataRaw(address vault_, uint branch_) external view returns (uint);\\n\\n    function getPositionDataRaw(address vault_, uint positionId_) external view returns (uint);\\n\\n    function getAllVaultsAddresses() external view returns (address[] memory vaults_);\\n\\n    function getVaultLiquidation(\\n        address vault_,\\n        uint tokenInAmt_\\n    ) external returns (Structs.LiquidationStruct memory liquidationData_);\\n\\n    function getVaultEntireData(address vault_) external view returns (Structs.VaultEntireData memory vaultData_);\\n}\\n\",\"keccak256\":\"0x8db2ba8c10b3f2a624ad2924ec5b59dbb805b42357eb98e9df6835963fff0634\",\"license\":\"MIT\"},\"contracts/periphery/resolvers/vault/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidVaultT1 } from \\\"../../../protocols/vault/interfaces/iVaultT1.sol\\\";\\nimport { Structs as FluidLiquidityResolverStructs } from \\\"../liquidity/structs.sol\\\";\\n\\ncontract Structs {\\n    struct Configs {\\n        uint16 supplyRateMagnifier;\\n        uint16 borrowRateMagnifier;\\n        uint16 collateralFactor;\\n        uint16 liquidationThreshold;\\n        uint16 liquidationMaxLimit;\\n        uint16 withdrawalGap;\\n        uint16 liquidationPenalty;\\n        uint16 borrowFee;\\n        address oracle;\\n        uint oraclePriceOperate;\\n        uint oraclePriceLiquidate;\\n        address rebalancer;\\n    }\\n\\n    struct ExchangePricesAndRates {\\n        uint lastStoredLiquiditySupplyExchangePrice;\\n        uint lastStoredLiquidityBorrowExchangePrice;\\n        uint lastStoredVaultSupplyExchangePrice;\\n        uint lastStoredVaultBorrowExchangePrice;\\n        uint liquiditySupplyExchangePrice;\\n        uint liquidityBorrowExchangePrice;\\n        uint vaultSupplyExchangePrice;\\n        uint vaultBorrowExchangePrice;\\n        uint supplyRateVault;\\n        uint borrowRateVault;\\n        uint supplyRateLiquidity;\\n        uint borrowRateLiquidity;\\n        uint rewardsRate; // rewards rate in percent 1e2 precision (1% = 100, 100% = 10000)\\n    }\\n\\n    struct TotalSupplyAndBorrow {\\n        uint totalSupplyVault;\\n        uint totalBorrowVault;\\n        uint totalSupplyLiquidity;\\n        uint totalBorrowLiquidity;\\n        uint absorbedSupply;\\n        uint absorbedBorrow;\\n    }\\n\\n    struct LimitsAndAvailability {\\n        uint withdrawLimit;\\n        uint withdrawableUntilLimit;\\n        uint withdrawable;\\n        uint borrowLimit;\\n        uint borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\\n        uint borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\\n        uint borrowLimitUtilization; // borrow limit for `maxUtilization` config at Liquidity\\n        uint minimumBorrowing;\\n    }\\n\\n    struct CurrentBranchState {\\n        uint status; // if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\\n        int minimaTick;\\n        uint debtFactor;\\n        uint partials;\\n        uint debtLiquidity;\\n        uint baseBranchId;\\n        int baseBranchMinima;\\n    }\\n\\n    struct VaultState {\\n        uint totalPositions;\\n        int topTick;\\n        uint currentBranch;\\n        uint totalBranch;\\n        uint totalBorrow;\\n        uint totalSupply;\\n        CurrentBranchState currentBranchState;\\n    }\\n\\n    struct VaultEntireData {\\n        address vault;\\n        IFluidVaultT1.ConstantViews constantVariables;\\n        Configs configs;\\n        ExchangePricesAndRates exchangePricesAndRates;\\n        TotalSupplyAndBorrow totalSupplyAndBorrow;\\n        LimitsAndAvailability limitsAndAvailability;\\n        VaultState vaultState;\\n        // liquidity related data such as supply amount, limits, expansion etc.\\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyData;\\n        // liquidity related data such as borrow amount, limits, expansion etc.\\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowData;\\n    }\\n\\n    struct UserPosition {\\n        uint nftId;\\n        address owner;\\n        bool isLiquidated;\\n        bool isSupplyPosition; // if true that means borrowing is 0\\n        int tick;\\n        uint tickId;\\n        uint beforeSupply;\\n        uint beforeBorrow;\\n        uint beforeDustBorrow;\\n        uint supply;\\n        uint borrow;\\n        uint dustBorrow;\\n    }\\n\\n    /// @dev liquidation related data\\n    /// @param vault address of vault\\n    /// @param tokenIn_ address of token in\\n    /// @param tokenOut_ address of token out\\n    /// @param tokenInAmtOne_ (without absorb liquidity) minimum of available liquidation & tokenInAmt_\\n    /// @param tokenOutAmtOne_ (without absorb liquidity) expected token out, collateral to withdraw\\n    /// @param tokenInAmtTwo_ (absorb liquidity included) minimum of available liquidation & tokenInAmt_. In most cases it'll be same as tokenInAmtOne_ but sometimes can be bigger.\\n    /// @param tokenOutAmtTwo_ (absorb liquidity included) expected token out, collateral to withdraw. In most cases it'll be same as tokenOutAmtOne_ but sometimes can be bigger.\\n    /// @dev Liquidity in Two will always be >= One. Sometimes One can provide better swaps, sometimes Two can provide better swaps. But available in Two will always be >= One\\n    struct LiquidationStruct {\\n        address vault;\\n        address tokenIn;\\n        address tokenOut;\\n        uint tokenInAmtOne;\\n        uint tokenOutAmtOne;\\n        uint tokenInAmtTwo;\\n        uint tokenOutAmtTwo;\\n    }\\n\\n    struct AbsorbStruct {\\n        address vault;\\n        bool absorbAvailable;\\n    }\\n}\\n\",\"keccak256\":\"0x7bfd2c661ed85a4bce5b66b6261254f28bb0eb975847ba1eda8b40d0a46e7584\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vaultTicksBranches/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { TickMath } from \\\"../../../libraries/tickMath.sol\\\";\\nimport { BigMathMinified } from \\\"../../../libraries/bigMathMinified.sol\\\";\\nimport { IFluidVaultResolver } from \\\"../vault/iVaultResolver.sol\\\";\\nimport { IFluidVaultT1 } from \\\"../../../protocols/vault/interfaces/iVaultT1.sol\\\";\\n\\nimport { Structs } from \\\"./structs.sol\\\";\\nimport { Variables } from \\\"./variables.sol\\\";\\n\\n/// @notice Fluid Vault protocol ticks & branches resolver\\ncontract FluidVaultTicksBranchesResolver is Variables, Structs {\\n    /// @notice thrown if an input param address is zero\\n    error FluidVaultTicksBranchesResolver__AddressZero();\\n\\n    /// @notice constructor sets the immutable vault resolver address\\n    constructor(IFluidVaultResolver vaultResolver_) Variables(vaultResolver_) {\\n        if (address(vaultResolver_) == address(0)) {\\n            revert FluidVaultTicksBranchesResolver__AddressZero();\\n        }\\n    }\\n\\n    function getTicksDebt(\\n        address vault_,\\n        int fromTick_,\\n        uint totalTicks_\\n    ) public view returns (TickDebt[] memory ticksDebt_, int toTick_) {\\n        int topTick_ = _tickHelper(((VAULT_RESOLVER.getVaultVariablesRaw(vault_) >> 2) & X20));\\n\\n        fromTick_ = topTick_ < fromTick_ ? topTick_ : fromTick_;\\n        if (fromTick_ > type(int).min) {\\n            // if fromTick_ == tpye(int).min means top tick is not set, meaning no positions exist\\n            int startMapId_ = fromTick_ < 0 ? ((fromTick_ + 1) / 256) - 1 : fromTick_ / 256;\\n            // Removing all other after fromTick\\n            uint tickHasDebt_;\\n            {\\n                uint tickHasDebtRaw_ = VAULT_RESOLVER.getTickHasDebtRaw(vault_, startMapId_);\\n\\n                uint bitsToRemove_ = uint(-fromTick_ + (startMapId_ * 256 + 255));\\n                tickHasDebt_ = (tickHasDebtRaw_ << bitsToRemove_) >> bitsToRemove_;\\n            }\\n\\n            // Adding 1 here as toTick_ is inclusive in the data so if totalTicks_ = 400 then it'll only check 400\\n            toTick_ = fromTick_ - int(totalTicks_) + 1;\\n\\n            uint count_ = _countTicksWithDebt(vault_, toTick_, startMapId_, tickHasDebt_);\\n\\n            (, , uint vaultSupplyExchangePrice_, uint vaultBorrowExchangePrice_) = IFluidVaultT1(vault_)\\n                .updateExchangePrices(VAULT_RESOLVER.getVaultVariables2Raw(vault_));\\n\\n            ticksDebt_ = _populateTicksDebt(\\n                vault_,\\n                toTick_,\\n                startMapId_,\\n                tickHasDebt_,\\n                count_,\\n                vaultSupplyExchangePrice_,\\n                vaultBorrowExchangePrice_\\n            );\\n        }\\n    }\\n\\n    function getMultipleVaultsTicksDebt(\\n        address[] memory vaults_,\\n        int[] memory fromTicks_,\\n        uint[] memory totalTicks_\\n    ) public view returns (VaultsTickDebt[] memory vaultsTickDebt_) {\\n        uint length_ = vaults_.length;\\n\\n        vaultsTickDebt_ = new VaultsTickDebt[](length_);\\n        for (uint i = 0; i < length_; i++) {\\n            (vaultsTickDebt_[i].tickDebt, vaultsTickDebt_[i].toTick) = getTicksDebt(\\n                vaults_[i],\\n                fromTicks_[i],\\n                totalTicks_[i]\\n            );\\n        }\\n    }\\n\\n    function getAllVaultsTicksDebt(uint totalTicks_) public view returns (VaultsTickDebt[] memory vaultsTickDebt_) {\\n        address[] memory vaults_ = VAULT_RESOLVER.getAllVaultsAddresses();\\n        uint length_ = vaults_.length;\\n\\n        vaultsTickDebt_ = new VaultsTickDebt[](length_);\\n        for (uint i = 0; i < length_; i++) {\\n            (vaultsTickDebt_[i].tickDebt, vaultsTickDebt_[i].toTick) = getTicksDebt(\\n                vaults_[i],\\n                type(int).max,\\n                totalTicks_\\n            );\\n        }\\n    }\\n\\n    function getBranchesDebt(\\n        address vault_,\\n        uint fromBranchId_,\\n        uint toBranchId_\\n    ) public view returns (BranchDebt[] memory branchesDebt_) {\\n        uint vaultVariables_ = VAULT_RESOLVER.getVaultVariablesRaw(vault_);\\n        uint totalBranch_ = (vaultVariables_ >> 52) & X30;\\n        toBranchId_ = (toBranchId_ == 0 ? 1 : toBranchId_);\\n        fromBranchId_ = (totalBranch_ < fromBranchId_ ? totalBranch_ : fromBranchId_);\\n\\n        require(fromBranchId_ >= toBranchId_, \\\"fromBranchId_ must be greater than or equal to toBranchId_\\\");\\n\\n        branchesDebt_ = new BranchDebt[](fromBranchId_ - toBranchId_ + 1);\\n\\n        uint index_;\\n\\n        for (uint i = fromBranchId_; i >= toBranchId_; i--) {\\n            branchesDebt_[index_++] = _getBranchDebt(vault_, vaultVariables_, i);\\n        }\\n    }\\n\\n    function getMultipleVaultsBranchesDebt(\\n        address[] memory vaults_,\\n        uint[] memory fromBranchIds_,\\n        uint[] memory toBranchIds_\\n    ) external view returns (BranchesDebt[] memory branchesDebt_) {\\n        uint length_ = vaults_.length;\\n\\n        branchesDebt_ = new BranchesDebt[](length_);\\n        for (uint i = 0; i < length_; i++) {\\n            branchesDebt_[i].branchDebt = getBranchesDebt(vaults_[i], fromBranchIds_[i], toBranchIds_[i]);\\n        }\\n    }\\n\\n    function getAllVaultsBranchesDebt() external view returns (BranchesDebt[] memory branchesDebt_) {\\n        address[] memory vaults_ = VAULT_RESOLVER.getAllVaultsAddresses();\\n        uint length_ = vaults_.length;\\n\\n        branchesDebt_ = new BranchesDebt[](length_);\\n        for (uint i = 0; i < length_; i++) {\\n            branchesDebt_[i].branchDebt = getBranchesDebt(vaults_[i], type(uint).max, 0);\\n        }\\n    }\\n\\n    function _populateTicksDebt(\\n        address vault_,\\n        int toTick_,\\n        int mapId_,\\n        uint tickHasDebt_,\\n        uint count_,\\n        uint vaultSupplyExchangePrice_,\\n        uint vaultBorrowExchangePrice_\\n    ) internal view returns (TickDebt[] memory ticksDebt_) {\\n        ticksDebt_ = new TickDebt[](count_);\\n\\n        count_ = 0; // reuse var for loop index counter\\n        int nextTick_;\\n        uint tickExistingRawDebt_;\\n        uint ratio_;\\n        uint collateralRaw_;\\n\\n        while (true) {\\n            while (tickHasDebt_ > 0) {\\n                {\\n                    uint msb_ = BigMathMinified.mostSignificantBit(tickHasDebt_);\\n                    // removing next tick from tickHasDebt\\n                    tickHasDebt_ = (tickHasDebt_ << (257 - msb_)) >> (257 - msb_);\\n                    nextTick_ = mapId_ * 256 + int(msb_ - 1);\\n                }\\n                if (nextTick_ < toTick_) {\\n                    return ticksDebt_;\\n                }\\n                tickExistingRawDebt_ = (VAULT_RESOLVER.getTickDataRaw(vault_, nextTick_) >> 25) & X64;\\n                tickExistingRawDebt_ = (tickExistingRawDebt_ >> 8) << (tickExistingRawDebt_ & X8);\\n                ratio_ = TickMath.getRatioAtTick(nextTick_);\\n                collateralRaw_ = (tickExistingRawDebt_ * (1 << 96)) / ratio_;\\n                ticksDebt_[count_++] = TickDebt({\\n                    debtRaw: tickExistingRawDebt_,\\n                    collateralRaw: collateralRaw_,\\n                    debtNormal: (tickExistingRawDebt_ * vaultBorrowExchangePrice_) / 1e12,\\n                    collateralNormal: (collateralRaw_ * vaultSupplyExchangePrice_) / 1e12,\\n                    ratio: ratio_,\\n                    tick: nextTick_\\n                });\\n            }\\n\\n            if (--mapId_ == -129) {\\n                break;\\n            }\\n\\n            tickHasDebt_ = VAULT_RESOLVER.getTickHasDebtRaw(vault_, mapId_);\\n        }\\n    }\\n\\n    function _tickHelper(uint tickRaw_) internal pure returns (int tick) {\\n        require(tickRaw_ < X20, \\\"invalid-number\\\");\\n        if (tickRaw_ > 0) {\\n            tick = tickRaw_ & 1 == 1 ? int((tickRaw_ >> 1) & X19) : -int((tickRaw_ >> 1) & X19);\\n        } else {\\n            tick = type(int).min;\\n        }\\n    }\\n\\n    function _countTicksWithDebt(\\n        address vault_,\\n        int toTick_,\\n        int mapId_,\\n        uint tickHasDebt_\\n    ) internal view returns (uint count_) {\\n        uint msb_;\\n        int nextTick_;\\n        while (true) {\\n            while (tickHasDebt_ > 0) {\\n                msb_ = BigMathMinified.mostSignificantBit(tickHasDebt_);\\n                // removing next tick from tickHasDebt\\n                tickHasDebt_ = (tickHasDebt_ << (257 - msb_)) >> (257 - msb_);\\n                nextTick_ = mapId_ * 256 + int(msb_ - 1);\\n                if (nextTick_ < toTick_) {\\n                    return count_;\\n                }\\n                count_++;\\n            }\\n\\n            if (--mapId_ == -129) {\\n                break;\\n            }\\n            tickHasDebt_ = VAULT_RESOLVER.getTickHasDebtRaw(vault_, mapId_);\\n        }\\n        return count_;\\n    }\\n\\n    function _getBranchDebt(\\n        address vault_,\\n        uint vaultVariables_,\\n        uint branchId_\\n    ) internal view returns (BranchDebt memory) {\\n        uint currentBranchData_ = VAULT_RESOLVER.getBranchDataRaw(vault_, branchId_);\\n\\n        int minimaTick_ = _tickHelper((currentBranchData_ >> 2) & X20);\\n        uint status_ = currentBranchData_ & 3;\\n\\n        if (status_ == 0) {\\n            // not liquidated status == 0\\n            // only current branch can be non-liquidated branch\\n            return _getActiveBranchDebt(vaultVariables_, currentBranchData_, branchId_, status_);\\n        } else if (status_ == 1) {\\n            // liquidated status == 1\\n            return _getLiquidatedBranchDebt(vault_, currentBranchData_, branchId_, status_, minimaTick_);\\n        } else {\\n            // merged status == 2\\n            // absorbed status == 3\\n            return _getClosedOrMergedBranchDebt(currentBranchData_, branchId_, status_);\\n        }\\n    }\\n\\n    function _getActiveBranchDebt(\\n        uint vaultVariables_,\\n        uint currentBranchData_,\\n        uint branchId_,\\n        uint status_\\n    ) internal pure returns (BranchDebt memory branchDebt_) {\\n        int topTick_ = _tickHelper((vaultVariables_ >> 2) & X20);\\n\\n        uint ratio_ = topTick_ > type(int).min ? TickMath.getRatioAtTick(topTick_) : 0;\\n\\n        branchDebt_ = BranchDebt({\\n            debtRaw: 0,\\n            collateralRaw: 0,\\n            debtNormal: 0,\\n            collateralNormal: 0,\\n            branchId: branchId_,\\n            status: status_, // active status\\n            tick: topTick_, // as branch is not liquidated, just returning topTick for now, as whenever liquidation starts it'll start from topTick\\n            partials: 0,\\n            ratio: ratio_,\\n            debtFactor: (currentBranchData_ >> 116) & X50,\\n            baseBranchId: ((currentBranchData_ >> 166) & X30),\\n            baseBranchTick: _tickHelper((currentBranchData_ >> 196) & X20) // if == type(int).min, then current branch is master branch\\n        });\\n    }\\n\\n    function _getClosedOrMergedBranchDebt(\\n        uint currentBranchData_,\\n        uint branchId_,\\n        uint status_\\n    ) internal pure returns (BranchDebt memory branchDebt_) {\\n        int baseBranchTick_ = _tickHelper((currentBranchData_ >> 196) & X20);\\n        uint ratio_ = baseBranchTick_ > type(int).min ? TickMath.getRatioAtTick(baseBranchTick_) : 0;\\n\\n        branchDebt_ = BranchDebt({\\n            debtRaw: 0,\\n            collateralRaw: 0,\\n            debtNormal: 0,\\n            collateralNormal: 0,\\n            branchId: branchId_,\\n            status: status_,\\n            tick: baseBranchTick_, // as branch is merged/closed, so adding baseBranchTick_ as this is where it went out of existance\\n            partials: 0,\\n            ratio: ratio_,\\n            debtFactor: (currentBranchData_ >> 116) & X50,\\n            baseBranchId: ((currentBranchData_ >> 166) & X30),\\n            baseBranchTick: baseBranchTick_ // if == type(int).min, then current branch is master branch\\n        });\\n    }\\n\\n    function _getLiquidatedBranchDebt(\\n        address vault_,\\n        uint currentBranchData_,\\n        uint branchId_,\\n        uint status_,\\n        int minimaTick_\\n    ) internal view returns (BranchDebt memory branchDebt_) {\\n        uint debtLiquidity_ = BigMathMinified.fromBigNumber((currentBranchData_ >> 52) & X64, 8, X8);\\n        (uint collateralRaw_, uint ratio_) = _getCollateralRaw(currentBranchData_, debtLiquidity_, minimaTick_);\\n\\n        (, , uint256 vaultSupplyExchangePrice_, uint256 vaultBorrowExchangePrice_) = IFluidVaultT1(vault_)\\n            .updateExchangePrices(VAULT_RESOLVER.getVaultVariables2Raw(vault_));\\n\\n        branchDebt_ = BranchDebt({\\n            debtRaw: debtLiquidity_,\\n            collateralRaw: collateralRaw_,\\n            debtNormal: (debtLiquidity_ * vaultBorrowExchangePrice_) / 1e12,\\n            collateralNormal: (collateralRaw_ * vaultSupplyExchangePrice_) / 1e12,\\n            branchId: branchId_,\\n            status: status_,\\n            tick: minimaTick_, // as branch is merged/closed, so adding baseBranchTick_ as this is where it went out of existance\\n            partials: 0,\\n            ratio: ratio_,\\n            debtFactor: (currentBranchData_ >> 116) & X50,\\n            baseBranchId: ((currentBranchData_ >> 166) & X30),\\n            baseBranchTick: _tickHelper((currentBranchData_ >> 196) & X20) // if == type(int).min, then current branch is master branch\\n        });\\n    }\\n\\n    function _getCollateralRaw(\\n        uint currentBranchData_,\\n        uint debtLiquidity_,\\n        int minimaTick_\\n    ) internal pure returns (uint collateralRaw_, uint ratio_) {\\n        ratio_ = TickMath.getRatioAtTick(int24(minimaTick_));\\n        uint ratioOneLess_ = (ratio_ * 10000) / 10015;\\n        uint length_ = ratio_ - ratioOneLess_;\\n        uint partials_ = (currentBranchData_ >> 22) & X30;\\n        uint currentRatio_ = ratioOneLess_ + ((length_ * partials_) / X30);\\n        collateralRaw_ = (debtLiquidity_ * TickMath.ZERO_TICK_SCALED_RATIO) / currentRatio_;\\n    }\\n}\\n\",\"keccak256\":\"0x6be1683fa345677d4277dd6aec9df1bc9defae123247c0d17a7769a4c16e0aed\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vaultTicksBranches/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ncontract Structs {\\n    struct TickDebt {\\n        uint256 debtRaw;\\n        uint256 collateralRaw;\\n        uint256 debtNormal; // debtRaw * exchange price\\n        uint256 collateralNormal; // collateralRaw * exchange price\\n        uint256 ratio;\\n        int256 tick;\\n    }\\n\\n    struct VaultsTickDebt {\\n        TickDebt[] tickDebt;\\n        int toTick;\\n    }\\n\\n    struct BranchDebt {\\n        uint256 debtRaw;\\n        uint256 collateralRaw;\\n        uint256 debtNormal; // debtRaw * exchange price\\n        uint256 collateralNormal; // collateralRaw * exchange price\\n        uint256 branchId;\\n        uint256 status; // if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\\n        int256 tick;\\n        uint256 partials;\\n        uint256 ratio;\\n        uint debtFactor; // debt factor or connection factor\\n        uint baseBranchId;\\n        int baseBranchTick;\\n    }\\n\\n    struct BranchesDebt {\\n        BranchDebt[] branchDebt;\\n    }\\n}\\n\",\"keccak256\":\"0x01d7c79b3399cf9c85625aacb90929fb6b2c7f14f9de17009b91826488342aee\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vaultTicksBranches/variables.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidVaultResolver } from \\\"../vault/iVaultResolver.sol\\\";\\n\\ncontract Variables {\\n    IFluidVaultResolver public immutable VAULT_RESOLVER;\\n\\n    uint internal constant X8 = 0xff;\\n    uint internal constant X19 = 0x7ffff;\\n    uint internal constant X20 = 0xfffff;\\n    uint internal constant X30 = 0x3fffffff;\\n    uint internal constant X50 = 0x3ffffffffffff;\\n    uint internal constant X64 = 0xffffffffffffffff;\\n\\n    constructor(IFluidVaultResolver vaultResolver_) {\\n        VAULT_RESOLVER = vaultResolver_;\\n    }\\n}\\n\",\"keccak256\":\"0xd9553795490f4dce2f5da52d6356a76b05853c7729a647c38377fedcf906c1cf\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/interfaces/iVaultT1.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IFluidVaultT1 {\\n    /// @notice returns the vault id\\n    function VAULT_ID() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct ConstantViews {\\n        address liquidity;\\n        address factory;\\n        address adminImplementation;\\n        address secondaryImplementation;\\n        address supplyToken;\\n        address borrowToken;\\n        uint8 supplyDecimals;\\n        uint8 borrowDecimals;\\n        uint vaultId;\\n        bytes32 liquiditySupplyExchangePriceSlot;\\n        bytes32 liquidityBorrowExchangePriceSlot;\\n        bytes32 liquidityUserSupplySlot;\\n        bytes32 liquidityUserBorrowSlot;\\n    }\\n\\n    /// @notice returns all Vault constants\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    /// @notice fetches the latest user position after a liquidation\\n    function fetchLatestPosition(\\n        int256 positionTick_,\\n        uint256 positionTickId_,\\n        uint256 positionRawDebt_,\\n        uint256 tickData_\\n    )\\n        external\\n        view\\n        returns (\\n            int256, // tick\\n            uint256, // raw debt\\n            uint256, // raw collateral\\n            uint256, // branchID_\\n            uint256 // branchData_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices\\n    function updateExchangePrices(\\n        uint256 vaultVariables2_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices and writes them to storage\\n    function updateExchangePricesOnStorage()\\n        external\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice returns the liquidity contract address\\n    function LIQUIDITY() external view returns (address);\\n\\n    function operate(\\n        uint256 nftId_, // if 0 then new position\\n        int256 newCol_, // if negative then withdraw\\n        int256 newDebt_, // if negative then payback\\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256, // nftId_\\n            int256, // final supply amount. if - then withdraw\\n            int256 // final borrow amount. if - then payback\\n        );\\n    \\n    function liquidate(\\n        uint256 debtAmt_,\\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\\n        address to_,\\n        bool absorb_\\n    ) external payable returns (uint actualDebtAmt_, uint actualColAmt_);\\n\\n    function absorb() external;\\n\\n    function rebalance() external payable returns (int supplyAmt_, int borrowAmt_);\\n\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n}\\n\",\"keccak256\":\"0xe0ec40a4531ecbcd7b8db25b4cd8529e0c284bb20eb40b7cf909fb8af0e3ca8b\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b50604051620027d0380380620027d0833981016040819052620000349162000068565b6001600160a01b038116608081905262000061576040516365b1d2ef60e11b815260040160405180910390fd5b506200009a565b6000602082840312156200007b57600080fd5b81516001600160a01b03811681146200009357600080fd5b9392505050565b6080516126ce620001026000396000818160e40152818161029d015281816104b6015281816105f5015281816107160152818161094501528181610b9b01528181610ef8015281816110c90152818161127f015281816113b401526119bc01526126ce6000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c80637f3e2b481161005b5780637f3e2b48146100df578063a12a377a1461012b578063d17ac4a81461014b578063f2c8e5421461016b57600080fd5b80633009c6ba146100825780636791522f146100ab5780637cec0866146100be575b600080fd5b610095610090366004611ea9565b610173565b6040516100a29190611f85565b60405180910390f35b6100956100b936600461207b565b610297565b6100d16100cc366004612094565b61045d565b6040516100a29291906120c9565b6101067f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100a2565b61013e610139366004612147565b610808565b6040516100a29190612268565b61015e610159366004612094565b6108fa565b6040516100a291906122f0565b61013e610b95565b82516060908067ffffffffffffffff81111561019157610191611d13565b6040519080825280602002602001820160405280156101d757816020015b6040805180820190915260608152600060208201528152602001906001900390816101af5790505b50915060005b8181101561028e5761023b8682815181106101fa576101fa612303565b602002602001015186838151811061021457610214612303565b602002602001015186848151811061022e5761022e612303565b602002602001015161045d565b84838151811061024d5761024d612303565b602002602001015160000185848151811061026a5761026a612303565b6020908102919091018101510191909152528061028681612361565b9150506101dd565b50509392505050565b606060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a8d9f4936040518163ffffffff1660e01b8152600401600060405180830381865afa158015610306573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261034c9190810190612399565b80519091508067ffffffffffffffff81111561036a5761036a611d13565b6040519080825280602002602001820160405280156103b057816020015b6040805180820190915260608152600060208201528152602001906001900390816103885790505b50925060005b81811015610455576104028382815181106103d3576103d3612303565b60200260200101517f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8761045d565b85838151811061041457610414612303565b602002602001015160000186848151811061043157610431612303565b6020908102919091018101510191909152528061044d81612361565b9150506103b6565b505050919050565b6040517f03e883e000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8481166004830152606091600091829161052991620fffff916002917f000000000000000000000000000000000000000000000000000000000000000016906303e883e090602401602060405180830381865afa1580156104fd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105219190612428565b901c16610d31565b9050848112610538578461053a565b805b94507f80000000000000000000000000000000000000000000000000000000000000008513156107ff57600080861261057e5761057961010087612470565b6105a1565b600161010061058d88836124d8565b6105979190612470565b6105a19190612500565b6040517fa8bc069300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff89811660048301526024820183905291925060009182917f00000000000000000000000000000000000000000000000000000000000000009091169063a8bc069390604401602060405180830381865afa15801561063e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106629190612428565b9050600061067284610100612527565b61067d9060ff6124d8565b6106868a612573565b61069091906124d8565b91821b90911c91506106a490508688612500565b6106af9060016124d8565b935060006106bf89868585610dff565b6040517feb1db01800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff808c1660048301819052929350600092839290916309f0d8cb917f00000000000000000000000000000000000000000000000000000000000000009091169063eb1db01890602401602060405180830381865afa15801561075f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107839190612428565b6040518263ffffffff1660e01b81526004016107a191815260200190565b608060405180830381865afa1580156107be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107e291906125ab565b9350935050506107f78b888787878787610f75565b975050505050505b50935093915050565b82516060908067ffffffffffffffff81111561082657610826611d13565b60405190808252806020026020018201604052801561086657816020015b6040805160208101909152606081528152602001906001900390816108445790505b50915060005b8181101561028e576108ca86828151811061088957610889612303565b60200260200101518683815181106108a3576108a3612303565b60200260200101518684815181106108bd576108bd612303565b60200260200101516108fa565b8382815181106108dc576108dc612303565b602090810291909101015152806108f281612361565b91505061086c565b6040517f03e883e000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84811660048301526060916000917f000000000000000000000000000000000000000000000000000000000000000016906303e883e090602401602060405180830381865afa15801561098c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b09190612428565b9050603481901c633fffffff1683156109c957836109cc565b60015b93508481106109db57846109dd565b805b945083851015610a74576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f66726f6d4272616e636849645f206d757374206265206772656174657220746860448201527f616e206f7220657175616c20746f20746f4272616e636849645f00000000000060648201526084015b60405180910390fd5b610a7e84866125e1565b610a899060016125f4565b67ffffffffffffffff811115610aa157610aa1611d13565b604051908082528060200260200182016040528015610b3657816020015b610b236040518061018001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b815260200190600190039081610abf5790505b5092506000855b858110610b8a57610b4f888583611301565b8583610b5a81612361565b945081518110610b6c57610b6c612303565b60200260200101819052508080610b8290612607565b915050610b3d565b505050509392505050565b606060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a8d9f4936040518163ffffffff1660e01b8152600401600060405180830381865afa158015610c04573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052610c4a9190810190612399565b80519091508067ffffffffffffffff811115610c6857610c68611d13565b604051908082528060200260200182016040528015610ca857816020015b604080516020810190915260608152815260200190600190039081610c865790505b50925060005b81811015610d2b57610cfb838281518110610ccb57610ccb612303565b60200260200101517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60006108fa565b848281518110610d0d57610d0d612303565b60209081029190910101515280610d2381612361565b915050610cae565b50505090565b6000620fffff8210610d9f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f696e76616c69642d6e756d6265720000000000000000000000000000000000006044820152606401610a6b565b8115610dd85781600116600114610dc757610dc2600183901c6207ffff16612573565b610dd2565b6207ffff600183901c165b92915050565b507f8000000000000000000000000000000000000000000000000000000000000000919050565b60008060005b8315610e7a57610e1484611483565b9150610e22826101016125e1565b610e2e836101016125e1565b9490941b90931c92610e416001836125e1565b610e4d86610100612527565b610e5791906124d8565b905085811215610e68575050610f6d565b82610e7281612361565b935050610e05565b610e838561263c565b94507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f8514610f6a576040517fa8bc069300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8881166004830152602482018790527f0000000000000000000000000000000000000000000000000000000000000000169063a8bc069390604401602060405180830381865afa158015610f3f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f639190612428565b9350610e05565b50505b949350505050565b60608367ffffffffffffffff811115610f9057610f90611d13565b604051908082528060200260200182016040528015610ffa57816020015b610fe76040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b815260200190600190039081610fae5790505b509050600093506000806000805b88156112015760006110198a611483565b9050611027816101016125e1565b611033826101016125e1565b9a909a1b90991c986110466001826125e1565b6110528c610100612527565b61105c91906124d8565b9450508a84121561107057505050506112f6565b6040517f168a11c200000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8d811660048301526024820186905267ffffffffffffffff916019917f0000000000000000000000000000000000000000000000000000000000000000169063168a11c290604401602060405180830381865afa158015611110573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111349190612428565b901c16600881901c60ff9091161b925061114d84611539565b915081611167846c0100000000000000000000000061266d565b6111719190612684565b90506040518060c0016040528084815260200182815260200164e8d4a51000888661119c919061266d565b6111a69190612684565b815260200164e8d4a510006111bb8a8561266d565b6111c59190612684565b81526020810184905260400185905285896111df81612361565b9a50815181106111f1576111f1612303565b6020026020010181905250611008565b61120a8a61263c565b99507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f8a146112f1576040517fa8bc069300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8d81166004830152602482018c90527f0000000000000000000000000000000000000000000000000000000000000000169063a8bc069390604401602060405180830381865afa1580156112c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112ea9190612428565b9850611008565b505050505b979650505050505050565b6113656040518061018001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6040517fbf518f5f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8581166004830152602482018490526000917f00000000000000000000000000000000000000000000000000000000000000009091169063bf518f5f90604401602060405180830381865afa1580156113fd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114219190612428565b90506000611437620fffff600284901c16610d31565b905060038216600081900361145c576114528684878461179b565b935050505061147c565b806001036114715761145287848784866118d9565b611452838683611b49565b9392505050565b6000816fffffffffffffffffffffffffffffffff8311156114a55760809150811c5b67ffffffffffffffff8111156114bd576040918201911c5b63ffffffff8111156114d1576020918201911c5b61ffff8111156114e3576010918201911c5b60ff8111156114f4576008918201911c5b600f811115611505576004918201911c5b6003811115611516576002918201911c5b6001811115611526576001820191505b8015611533576001820191505b50919050565b600060ff82901d80831803617fff81111561155357600080fd5b700100000000000000000000000000000000600182161561158157506fff9dd7de423466c20352b1246ce4856f5b60028216156115a0576fff3bd55f4488ad277531fa1c725a66d00260801c5b60048216156115bf576ffe78410fd6498b73cb96a6917f8532590260801c5b60088216156115de576ffcf2d9987c9be178ad5bfeffaa1232730260801c5b60108216156115fd576ff9ef02c4529258b057769680fc6601b30260801c5b602082161561161c576ff402d288133a85a17784a411f7aba0820260801c5b604082161561163b576fe895615b5beb6386553757b0352bda900260801c5b608082161561165a576fd34f17a00ffa00a8309940a15930391a0260801c5b61010082161561167a576fae6b7961714e20548d88ea5123f9a0ff0260801c5b61020082161561169a576f76d6461f27082d74e0feed3b388c0ca10260801c5b6104008216156116ba576f372a3bfe0745d8b6b19d985d9a8b85bb0260801c5b6108008216156116da576f0be32cbee48979763cf7247dd7bb539d0260801c5b6110008216156116f9576e8d4f70c9ff4924dac37612d1e2921e0260801c5b612000821615611717576d4e009ae5519380809a02ca7aec770260801c5b614000821615611733576b17c45e641b6e95dee056ff100260801c5b600091507f80000000000000000000000000000000000000000000000000000000000000008416611791577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0463ffffffff81161561179157600191505b60201c0192915050565b6117ff6040518061018001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000611813620fffff600288901c16610d31565b905060007f8000000000000000000000000000000000000000000000000000000000000000821361184557600061184e565b61184e82611539565b905060405180610180016040528060008152602001600081526020016000815260200160008152602001868152602001858152602001838152602001600081526020018281526020016603ffffffffffff607489901c168152602001633fffffff60a689901c1681526020016118cc620fffff60c48a901c16610d31565b9052979650505050505050565b61193d6040518061018001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b603c85901c66ffffffffffffff16603486901c60ff161b600080611962888487611c77565b6040517feb1db01800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff808d1660048301819052939550919350600092839290916309f0d8cb917f0000000000000000000000000000000000000000000000000000000000000000169063eb1db01890602401602060405180830381865afa158015611a03573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a279190612428565b6040518263ffffffff1660e01b8152600401611a4591815260200190565b608060405180830381865afa158015611a62573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a8691906125ab565b93509350505060405180610180016040528086815260200185815260200164e8d4a510008388611ab6919061266d565b611ac09190612684565b815260200164e8d4a51000611ad5858861266d565b611adf9190612684565b81526020018a8152602001898152602001888152602001600081526020018481526020016603ffffffffffff60748d901c168152602001633fffffff60a68d901c168152602001611b38620fffff60c48e901c16610d31565b90529b9a5050505050505050505050565b611bad6040518061018001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000611bc1620fffff60c487901c16610d31565b905060007f80000000000000000000000000000000000000000000000000000000000000008213611bf3576000611bfc565b611bfc82611539565b905060405180610180016040528060008152602001600081526020016000815260200160008152602001868152602001858152602001838152602001600081526020018281526020016603ffffffffffff607489901c168152602001633fffffff60a689901c16815260200183815250925050509392505050565b600080611c868360020b611539565b9050600061271f611c998361271061266d565b611ca39190612684565b90506000611cb182846125e1565b9050633fffffff601688901c811690600090611ccd838561266d565b611cd79190612684565b611ce190856125f4565b905080611cfb6c010000000000000000000000008a61266d565b611d059190612684565b955050505050935093915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715611d8957611d89611d13565b604052919050565b600067ffffffffffffffff821115611dab57611dab611d13565b5060051b60200190565b73ffffffffffffffffffffffffffffffffffffffff81168114611dd757600080fd5b50565b600082601f830112611deb57600080fd5b81356020611e00611dfb83611d91565b611d42565b82815260059290921b84018101918181019086841115611e1f57600080fd5b8286015b84811015611e43578035611e3681611db5565b8352918301918301611e23565b509695505050505050565b600082601f830112611e5f57600080fd5b81356020611e6f611dfb83611d91565b82815260059290921b84018101918181019086841115611e8e57600080fd5b8286015b84811015611e435780358352918301918301611e92565b600080600060608486031215611ebe57600080fd5b833567ffffffffffffffff80821115611ed657600080fd5b611ee287838801611dda565b9450602091508186013581811115611ef957600080fd5b8601601f81018813611f0a57600080fd5b8035611f18611dfb82611d91565b81815260059190911b8201840190848101908a831115611f3757600080fd5b928501925b82841015611f5557833582529285019290850190611f3c565b96505050506040860135915080821115611f6e57600080fd5b50611f7b86828701611e4e565b9150509250925092565b60006020808301818452808551808352604092508286019150828160051b8701018488016000805b8481101561206c578984037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0018652825180518886528051898701819052908a0190849060608801905b8083101561204d578351805183526020808201519084015260408082015190840152606080820151908401526080808201519084015260a0908101519083015260c0820191508c84019350600183019250611ff7565b50928b0151968b01969096525095880195935091870191600101611fad565b50919998505050505050505050565b60006020828403121561208d57600080fd5b5035919050565b6000806000606084860312156120a957600080fd5b83356120b481611db5565b95602085013595506040909401359392505050565b604080825283519082018190526000906020906060840190828701845b82811015612138578151805185526020808201519086015260408082015190860152606080820151908601526080808201519086015260a0908101519085015260c084019350908401906001016120e6565b50505092019290925292915050565b60008060006060848603121561215c57600080fd5b833567ffffffffffffffff8082111561217457600080fd5b61218087838801611dda565b9450602086013591508082111561219657600080fd5b6121a287838801611e4e565b93506040860135915080821115611f6e57600080fd5b600081518084526020808501945080840160005b8381101561225d57815180518852838101518489015260408082015190890152606080820151908901526080808201519089015260a0808201519089015260c0808201519089015260e08082015190890152610100808201519089015261012080820151908901526101408082015190890152610160908101519088015261018090960195908201906001016121cc565b509495945050505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b828110156122e3577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08886030184528151518686526122d0878701826121b8565b955050928501929085019060010161228f565b5092979650505050505050565b60208152600061147c60208301846121b8565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361239257612392612332565b5060010190565b600060208083850312156123ac57600080fd5b825167ffffffffffffffff8111156123c357600080fd5b8301601f810185136123d457600080fd5b80516123e2611dfb82611d91565b81815260059190911b8201830190838101908783111561240157600080fd5b928401925b828410156112f657835161241981611db5565b82529284019290840190612406565b60006020828403121561243a57600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008261247f5761247f612441565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83147f8000000000000000000000000000000000000000000000000000000000000000831416156124d3576124d3612332565b500590565b80820182811260008312801582168215821617156124f8576124f8612332565b505092915050565b818103600083128015838313168383128216171561252057612520612332565b5092915050565b808202600082127f80000000000000000000000000000000000000000000000000000000000000008414161561255f5761255f612332565b8181058314821517610dd257610dd2612332565b60007f800000000000000000000000000000000000000000000000000000000000000082036125a4576125a4612332565b5060000390565b600080600080608085870312156125c157600080fd5b505082516020840151604085015160609095015191969095509092509050565b81810381811115610dd257610dd2612332565b80820180821115610dd257610dd2612332565b60008161261657612616612332565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190565b60007f8000000000000000000000000000000000000000000000000000000000000000820361261657612616612332565b8082028115828204841417610dd257610dd2612332565b60008261269357612693612441565b50049056fea2646970667358221220efd800cfeda44c6ed15f6a0695cad51a4a0337f8d56624f25cc5c951c96a60be64736f6c63430008150033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061007d5760003560e01c80637f3e2b481161005b5780637f3e2b48146100df578063a12a377a1461012b578063d17ac4a81461014b578063f2c8e5421461016b57600080fd5b80633009c6ba146100825780636791522f146100ab5780637cec0866146100be575b600080fd5b610095610090366004611ea9565b610173565b6040516100a29190611f85565b60405180910390f35b6100956100b936600461207b565b610297565b6100d16100cc366004612094565b61045d565b6040516100a29291906120c9565b6101067f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100a2565b61013e610139366004612147565b610808565b6040516100a29190612268565b61015e610159366004612094565b6108fa565b6040516100a291906122f0565b61013e610b95565b82516060908067ffffffffffffffff81111561019157610191611d13565b6040519080825280602002602001820160405280156101d757816020015b6040805180820190915260608152600060208201528152602001906001900390816101af5790505b50915060005b8181101561028e5761023b8682815181106101fa576101fa612303565b602002602001015186838151811061021457610214612303565b602002602001015186848151811061022e5761022e612303565b602002602001015161045d565b84838151811061024d5761024d612303565b602002602001015160000185848151811061026a5761026a612303565b6020908102919091018101510191909152528061028681612361565b9150506101dd565b50509392505050565b606060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a8d9f4936040518163ffffffff1660e01b8152600401600060405180830381865afa158015610306573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261034c9190810190612399565b80519091508067ffffffffffffffff81111561036a5761036a611d13565b6040519080825280602002602001820160405280156103b057816020015b6040805180820190915260608152600060208201528152602001906001900390816103885790505b50925060005b81811015610455576104028382815181106103d3576103d3612303565b60200260200101517f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8761045d565b85838151811061041457610414612303565b602002602001015160000186848151811061043157610431612303565b6020908102919091018101510191909152528061044d81612361565b9150506103b6565b505050919050565b6040517f03e883e000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8481166004830152606091600091829161052991620fffff916002917f000000000000000000000000000000000000000000000000000000000000000016906303e883e090602401602060405180830381865afa1580156104fd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105219190612428565b901c16610d31565b9050848112610538578461053a565b805b94507f80000000000000000000000000000000000000000000000000000000000000008513156107ff57600080861261057e5761057961010087612470565b6105a1565b600161010061058d88836124d8565b6105979190612470565b6105a19190612500565b6040517fa8bc069300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff89811660048301526024820183905291925060009182917f00000000000000000000000000000000000000000000000000000000000000009091169063a8bc069390604401602060405180830381865afa15801561063e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106629190612428565b9050600061067284610100612527565b61067d9060ff6124d8565b6106868a612573565b61069091906124d8565b91821b90911c91506106a490508688612500565b6106af9060016124d8565b935060006106bf89868585610dff565b6040517feb1db01800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff808c1660048301819052929350600092839290916309f0d8cb917f00000000000000000000000000000000000000000000000000000000000000009091169063eb1db01890602401602060405180830381865afa15801561075f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107839190612428565b6040518263ffffffff1660e01b81526004016107a191815260200190565b608060405180830381865afa1580156107be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107e291906125ab565b9350935050506107f78b888787878787610f75565b975050505050505b50935093915050565b82516060908067ffffffffffffffff81111561082657610826611d13565b60405190808252806020026020018201604052801561086657816020015b6040805160208101909152606081528152602001906001900390816108445790505b50915060005b8181101561028e576108ca86828151811061088957610889612303565b60200260200101518683815181106108a3576108a3612303565b60200260200101518684815181106108bd576108bd612303565b60200260200101516108fa565b8382815181106108dc576108dc612303565b602090810291909101015152806108f281612361565b91505061086c565b6040517f03e883e000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84811660048301526060916000917f000000000000000000000000000000000000000000000000000000000000000016906303e883e090602401602060405180830381865afa15801561098c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b09190612428565b9050603481901c633fffffff1683156109c957836109cc565b60015b93508481106109db57846109dd565b805b945083851015610a74576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f66726f6d4272616e636849645f206d757374206265206772656174657220746860448201527f616e206f7220657175616c20746f20746f4272616e636849645f00000000000060648201526084015b60405180910390fd5b610a7e84866125e1565b610a899060016125f4565b67ffffffffffffffff811115610aa157610aa1611d13565b604051908082528060200260200182016040528015610b3657816020015b610b236040518061018001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b815260200190600190039081610abf5790505b5092506000855b858110610b8a57610b4f888583611301565b8583610b5a81612361565b945081518110610b6c57610b6c612303565b60200260200101819052508080610b8290612607565b915050610b3d565b505050509392505050565b606060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a8d9f4936040518163ffffffff1660e01b8152600401600060405180830381865afa158015610c04573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052610c4a9190810190612399565b80519091508067ffffffffffffffff811115610c6857610c68611d13565b604051908082528060200260200182016040528015610ca857816020015b604080516020810190915260608152815260200190600190039081610c865790505b50925060005b81811015610d2b57610cfb838281518110610ccb57610ccb612303565b60200260200101517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60006108fa565b848281518110610d0d57610d0d612303565b60209081029190910101515280610d2381612361565b915050610cae565b50505090565b6000620fffff8210610d9f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f696e76616c69642d6e756d6265720000000000000000000000000000000000006044820152606401610a6b565b8115610dd85781600116600114610dc757610dc2600183901c6207ffff16612573565b610dd2565b6207ffff600183901c165b92915050565b507f8000000000000000000000000000000000000000000000000000000000000000919050565b60008060005b8315610e7a57610e1484611483565b9150610e22826101016125e1565b610e2e836101016125e1565b9490941b90931c92610e416001836125e1565b610e4d86610100612527565b610e5791906124d8565b905085811215610e68575050610f6d565b82610e7281612361565b935050610e05565b610e838561263c565b94507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f8514610f6a576040517fa8bc069300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8881166004830152602482018790527f0000000000000000000000000000000000000000000000000000000000000000169063a8bc069390604401602060405180830381865afa158015610f3f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f639190612428565b9350610e05565b50505b949350505050565b60608367ffffffffffffffff811115610f9057610f90611d13565b604051908082528060200260200182016040528015610ffa57816020015b610fe76040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b815260200190600190039081610fae5790505b509050600093506000806000805b88156112015760006110198a611483565b9050611027816101016125e1565b611033826101016125e1565b9a909a1b90991c986110466001826125e1565b6110528c610100612527565b61105c91906124d8565b9450508a84121561107057505050506112f6565b6040517f168a11c200000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8d811660048301526024820186905267ffffffffffffffff916019917f0000000000000000000000000000000000000000000000000000000000000000169063168a11c290604401602060405180830381865afa158015611110573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111349190612428565b901c16600881901c60ff9091161b925061114d84611539565b915081611167846c0100000000000000000000000061266d565b6111719190612684565b90506040518060c0016040528084815260200182815260200164e8d4a51000888661119c919061266d565b6111a69190612684565b815260200164e8d4a510006111bb8a8561266d565b6111c59190612684565b81526020810184905260400185905285896111df81612361565b9a50815181106111f1576111f1612303565b6020026020010181905250611008565b61120a8a61263c565b99507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f8a146112f1576040517fa8bc069300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8d81166004830152602482018c90527f0000000000000000000000000000000000000000000000000000000000000000169063a8bc069390604401602060405180830381865afa1580156112c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112ea9190612428565b9850611008565b505050505b979650505050505050565b6113656040518061018001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6040517fbf518f5f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8581166004830152602482018490526000917f00000000000000000000000000000000000000000000000000000000000000009091169063bf518f5f90604401602060405180830381865afa1580156113fd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114219190612428565b90506000611437620fffff600284901c16610d31565b905060038216600081900361145c576114528684878461179b565b935050505061147c565b806001036114715761145287848784866118d9565b611452838683611b49565b9392505050565b6000816fffffffffffffffffffffffffffffffff8311156114a55760809150811c5b67ffffffffffffffff8111156114bd576040918201911c5b63ffffffff8111156114d1576020918201911c5b61ffff8111156114e3576010918201911c5b60ff8111156114f4576008918201911c5b600f811115611505576004918201911c5b6003811115611516576002918201911c5b6001811115611526576001820191505b8015611533576001820191505b50919050565b600060ff82901d80831803617fff81111561155357600080fd5b700100000000000000000000000000000000600182161561158157506fff9dd7de423466c20352b1246ce4856f5b60028216156115a0576fff3bd55f4488ad277531fa1c725a66d00260801c5b60048216156115bf576ffe78410fd6498b73cb96a6917f8532590260801c5b60088216156115de576ffcf2d9987c9be178ad5bfeffaa1232730260801c5b60108216156115fd576ff9ef02c4529258b057769680fc6601b30260801c5b602082161561161c576ff402d288133a85a17784a411f7aba0820260801c5b604082161561163b576fe895615b5beb6386553757b0352bda900260801c5b608082161561165a576fd34f17a00ffa00a8309940a15930391a0260801c5b61010082161561167a576fae6b7961714e20548d88ea5123f9a0ff0260801c5b61020082161561169a576f76d6461f27082d74e0feed3b388c0ca10260801c5b6104008216156116ba576f372a3bfe0745d8b6b19d985d9a8b85bb0260801c5b6108008216156116da576f0be32cbee48979763cf7247dd7bb539d0260801c5b6110008216156116f9576e8d4f70c9ff4924dac37612d1e2921e0260801c5b612000821615611717576d4e009ae5519380809a02ca7aec770260801c5b614000821615611733576b17c45e641b6e95dee056ff100260801c5b600091507f80000000000000000000000000000000000000000000000000000000000000008416611791577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0463ffffffff81161561179157600191505b60201c0192915050565b6117ff6040518061018001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000611813620fffff600288901c16610d31565b905060007f8000000000000000000000000000000000000000000000000000000000000000821361184557600061184e565b61184e82611539565b905060405180610180016040528060008152602001600081526020016000815260200160008152602001868152602001858152602001838152602001600081526020018281526020016603ffffffffffff607489901c168152602001633fffffff60a689901c1681526020016118cc620fffff60c48a901c16610d31565b9052979650505050505050565b61193d6040518061018001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b603c85901c66ffffffffffffff16603486901c60ff161b600080611962888487611c77565b6040517feb1db01800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff808d1660048301819052939550919350600092839290916309f0d8cb917f0000000000000000000000000000000000000000000000000000000000000000169063eb1db01890602401602060405180830381865afa158015611a03573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a279190612428565b6040518263ffffffff1660e01b8152600401611a4591815260200190565b608060405180830381865afa158015611a62573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a8691906125ab565b93509350505060405180610180016040528086815260200185815260200164e8d4a510008388611ab6919061266d565b611ac09190612684565b815260200164e8d4a51000611ad5858861266d565b611adf9190612684565b81526020018a8152602001898152602001888152602001600081526020018481526020016603ffffffffffff60748d901c168152602001633fffffff60a68d901c168152602001611b38620fffff60c48e901c16610d31565b90529b9a5050505050505050505050565b611bad6040518061018001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000611bc1620fffff60c487901c16610d31565b905060007f80000000000000000000000000000000000000000000000000000000000000008213611bf3576000611bfc565b611bfc82611539565b905060405180610180016040528060008152602001600081526020016000815260200160008152602001868152602001858152602001838152602001600081526020018281526020016603ffffffffffff607489901c168152602001633fffffff60a689901c16815260200183815250925050509392505050565b600080611c868360020b611539565b9050600061271f611c998361271061266d565b611ca39190612684565b90506000611cb182846125e1565b9050633fffffff601688901c811690600090611ccd838561266d565b611cd79190612684565b611ce190856125f4565b905080611cfb6c010000000000000000000000008a61266d565b611d059190612684565b955050505050935093915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715611d8957611d89611d13565b604052919050565b600067ffffffffffffffff821115611dab57611dab611d13565b5060051b60200190565b73ffffffffffffffffffffffffffffffffffffffff81168114611dd757600080fd5b50565b600082601f830112611deb57600080fd5b81356020611e00611dfb83611d91565b611d42565b82815260059290921b84018101918181019086841115611e1f57600080fd5b8286015b84811015611e43578035611e3681611db5565b8352918301918301611e23565b509695505050505050565b600082601f830112611e5f57600080fd5b81356020611e6f611dfb83611d91565b82815260059290921b84018101918181019086841115611e8e57600080fd5b8286015b84811015611e435780358352918301918301611e92565b600080600060608486031215611ebe57600080fd5b833567ffffffffffffffff80821115611ed657600080fd5b611ee287838801611dda565b9450602091508186013581811115611ef957600080fd5b8601601f81018813611f0a57600080fd5b8035611f18611dfb82611d91565b81815260059190911b8201840190848101908a831115611f3757600080fd5b928501925b82841015611f5557833582529285019290850190611f3c565b96505050506040860135915080821115611f6e57600080fd5b50611f7b86828701611e4e565b9150509250925092565b60006020808301818452808551808352604092508286019150828160051b8701018488016000805b8481101561206c578984037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0018652825180518886528051898701819052908a0190849060608801905b8083101561204d578351805183526020808201519084015260408082015190840152606080820151908401526080808201519084015260a0908101519083015260c0820191508c84019350600183019250611ff7565b50928b0151968b01969096525095880195935091870191600101611fad565b50919998505050505050505050565b60006020828403121561208d57600080fd5b5035919050565b6000806000606084860312156120a957600080fd5b83356120b481611db5565b95602085013595506040909401359392505050565b604080825283519082018190526000906020906060840190828701845b82811015612138578151805185526020808201519086015260408082015190860152606080820151908601526080808201519086015260a0908101519085015260c084019350908401906001016120e6565b50505092019290925292915050565b60008060006060848603121561215c57600080fd5b833567ffffffffffffffff8082111561217457600080fd5b61218087838801611dda565b9450602086013591508082111561219657600080fd5b6121a287838801611e4e565b93506040860135915080821115611f6e57600080fd5b600081518084526020808501945080840160005b8381101561225d57815180518852838101518489015260408082015190890152606080820151908901526080808201519089015260a0808201519089015260c0808201519089015260e08082015190890152610100808201519089015261012080820151908901526101408082015190890152610160908101519088015261018090960195908201906001016121cc565b509495945050505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b828110156122e3577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08886030184528151518686526122d0878701826121b8565b955050928501929085019060010161228f565b5092979650505050505050565b60208152600061147c60208301846121b8565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361239257612392612332565b5060010190565b600060208083850312156123ac57600080fd5b825167ffffffffffffffff8111156123c357600080fd5b8301601f810185136123d457600080fd5b80516123e2611dfb82611d91565b81815260059190911b8201830190838101908783111561240157600080fd5b928401925b828410156112f657835161241981611db5565b82529284019290840190612406565b60006020828403121561243a57600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008261247f5761247f612441565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83147f8000000000000000000000000000000000000000000000000000000000000000831416156124d3576124d3612332565b500590565b80820182811260008312801582168215821617156124f8576124f8612332565b505092915050565b818103600083128015838313168383128216171561252057612520612332565b5092915050565b808202600082127f80000000000000000000000000000000000000000000000000000000000000008414161561255f5761255f612332565b8181058314821517610dd257610dd2612332565b60007f800000000000000000000000000000000000000000000000000000000000000082036125a4576125a4612332565b5060000390565b600080600080608085870312156125c157600080fd5b505082516020840151604085015160609095015191969095509092509050565b81810381811115610dd257610dd2612332565b80820180821115610dd257610dd2612332565b60008161261657612616612332565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190565b60007f8000000000000000000000000000000000000000000000000000000000000000820361261657612616612332565b8082028115828204841417610dd257610dd2612332565b60008261269357612693612441565b50049056fea2646970667358221220efd800cfeda44c6ed15f6a0695cad51a4a0337f8d56624f25cc5c951c96a60be64736f6c63430008150033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "errors": {
      "FluidVaultTicksBranchesResolver__AddressZero()": [
        {
          "notice": "thrown if an input param address is zero"
        }
      ]
    },
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "constructor sets the immutable vault resolver address"
      }
    },
    "notice": "Fluid Vault protocol ticks & branches resolver",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}