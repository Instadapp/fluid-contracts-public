{
  "address": "0xaA21a86030EAa16546A759d2d10fd3bF9D053Bc7",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IFluidVaultFactory",
          "name": "vaultFactory_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "FluidVaultPositionsResolver__AddressZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FluidVaultPositionsResolver__InvalidParams",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FACTORY",
      "outputs": [
        {
          "internalType": "contract IFluidVaultFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "slot_",
          "type": "uint256"
        },
        {
          "internalType": "int256",
          "name": "key_",
          "type": "int256"
        }
      ],
      "name": "_calculateStorageSlotIntMapping",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getAllVaultNftIds",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "nftIds_",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "page_",
          "type": "uint256"
        }
      ],
      "name": "getAllVaultNftIdsPaged",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "nftIds_",
          "type": "uint256[]"
        },
        {
          "internalType": "bool",
          "name": "hasNextPage_",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getAllVaultPositions",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nftId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "supply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrow",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.UserPosition[]",
          "name": "positions_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "nftIds_",
          "type": "uint256[]"
        }
      ],
      "name": "getPositionsForNftIds",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nftId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "supply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrow",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.UserPosition[]",
          "name": "positions_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "nftIds_",
          "type": "uint256[]"
        },
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getVaultPositionsForNftIds",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nftId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "supply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrow",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.UserPosition[]",
          "name": "positions_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xc0a23fb3792c02e0b1afe1bc24eb0a96fd869b1bab1b1e810427615045ac0e6e",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x0Ed35B1609Ec45c7079E80d11149a52717e4859A",
    "contractAddress": null,
    "transactionIndex": 8,
    "gasUsed": "1759660",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x7df4fb08182291d367fbd12fbc69c486b860865923b624594d73085ed56db1d3",
    "transactionHash": "0xc0a23fb3792c02e0b1afe1bc24eb0a96fd869b1bab1b1e810427615045ac0e6e",
    "logs": [],
    "blockNumber": 427076636,
    "cumulativeGasUsed": "2394482",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x324c5Dc1fC42c7a4D43d92df1eBA58a54d13Bf2d"
  ],
  "numDeployments": 5,
  "solcInputHash": "b70748f66f921f0f7998bc99a17c07b8",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IFluidVaultFactory\",\"name\":\"vaultFactory_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FluidVaultPositionsResolver__AddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FluidVaultPositionsResolver__InvalidParams\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"contract IFluidVaultFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slot_\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"key_\",\"type\":\"int256\"}],\"name\":\"_calculateStorageSlotIntMapping\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getAllVaultNftIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"page_\",\"type\":\"uint256\"}],\"name\":\"getAllVaultNftIdsPaged\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"hasNextPage_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getAllVaultPositions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrow\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserPosition[]\",\"name\":\"positions_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds_\",\"type\":\"uint256[]\"}],\"name\":\"getPositionsForNftIds\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrow\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserPosition[]\",\"name\":\"positions_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getVaultPositionsForNftIds\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrow\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserPosition[]\",\"name\":\"positions_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"vaultFactory_\":\"The FluidVaultFactory contract address\"}},\"getAllVaultNftIds(address)\":{\"params\":{\"vault_\":\"The address of the vault.\"},\"returns\":{\"nftIds_\":\"Array of NFT token IDs belonging to the vault.\"}},\"getAllVaultNftIdsPaged(address,uint256)\":{\"details\":\"Use this method on chains where retrieving all token IDs at once may run out of gas.      Call this repeatedly with increasing page numbers until hasNextPage is false, then use `getVaultPositionsForNftIds`.\",\"params\":{\"page_\":\"The current page to fetch (pagination index). start with page 0.\",\"vault_\":\"The address of the vault.\"},\"returns\":{\"hasNextPage_\":\"True if there are more pages to fetch, false if this is the last page.\",\"nftIds_\":\"Array of NFT token IDs for the specified page.\"}},\"getAllVaultPositions(address)\":{\"params\":{\"vault_\":\"The address of the vault.\"},\"returns\":{\"positions_\":\"Array of UserPosition for each position in the vault.\"}},\"getPositionsForNftIds(uint256[])\":{\"params\":{\"nftIds_\":\"Array of NFT IDs. Split reading into chunks if this runs out of gas!\"},\"returns\":{\"positions_\":\"Array of UserPosition for each NFT ID.\"}},\"getVaultPositionsForNftIds(uint256[],address)\":{\"params\":{\"nftIds_\":\"Array of NFT IDs. Split reading into chunks if this runs out of gas!\",\"vault_\":\"The address of the vault.\"},\"returns\":{\"positions_\":\"Array of UserPosition for the NFT IDs.\"}}},\"title\":\"Fluid Vault protocol Positions Resolver for all vault types.\",\"version\":1},\"userdoc\":{\"errors\":{\"FluidVaultPositionsResolver__AddressZero()\":[{\"notice\":\"thrown if an input param address is zero\"}]},\"kind\":\"user\",\"methods\":{\"_calculateStorageSlotIntMapping(uint256,int256)\":{\"notice\":\"Calculating the slot ID for Liquidity contract for single mapping\"},\"constructor\":{\"notice\":\"constructor sets the immutable vault factory address\"},\"getAllVaultNftIds(address)\":{\"notice\":\"Returns all NFT token IDs for the specified vault. Use `getAllVaultNftIdsPaged` if this runs out of gas!\"},\"getAllVaultNftIdsPaged(address,uint256)\":{\"notice\":\"Returns the NFT token IDs for a given vault using a paged approach, reading 3000 nfts per page.\"},\"getAllVaultPositions(address)\":{\"notice\":\"Gets all positions for the given vault. Use `getAllVaultNftIds` first if this runs out of gas!\"},\"getPositionsForNftIds(uint256[])\":{\"notice\":\"Gets user positions for a set of NFT IDs.\"},\"getVaultPositionsForNftIds(uint256[],address)\":{\"notice\":\"Gets user positions for NFT IDs assumed to belong to a specific vault.\"}},\"notice\":\"This contract resolves positions for Fluid Vaults, providing functionality to retrieve NFT IDs and positions for a given vault.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/periphery/resolvers/vaultPositions/main.sol\":\"FluidVaultPositionsResolver\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xab28a56179c1db258c9bf5235b382698cb650debecb51b23d12be9e241374b68\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd1556954440b31c97a142c6ba07d5cade45f96fafd52091d33a14ebe365aecbf\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/libraries/tickMath.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\n/// @title library that calculates number \\\"tick\\\" and \\\"ratioX96\\\" from this: ratioX96 = (1.0015^tick) * 2^96\\n/// @notice this library is used in Fluid Vault protocol for optimiziation.\\n/// @dev \\\"tick\\\" supports between -32767 and 32767. \\\"ratioX96\\\" supports between 37075072 and 169307877264527972847801929085841449095838922544595\\nlibrary TickMath {\\n    /// The minimum tick that can be passed in getRatioAtTick. 1.0015**-32767\\n    int24 internal constant MIN_TICK = -32767;\\n    /// The maximum tick that can be passed in getRatioAtTick. 1.0015**32767\\n    int24 internal constant MAX_TICK = 32767;\\n\\n    uint256 internal constant FACTOR00 = 0x100000000000000000000000000000000;\\n    uint256 internal constant FACTOR01 = 0xff9dd7de423466c20352b1246ce4856f; // 2^128/1.0015**1 = 339772707859149738855091969477551883631\\n    uint256 internal constant FACTOR02 = 0xff3bd55f4488ad277531fa1c725a66d0; // 2^128/1.0015**2 = 339263812140938331358054887146831636176\\n    uint256 internal constant FACTOR03 = 0xfe78410fd6498b73cb96a6917f853259; // 2^128/1.0015**4 = 338248306163758188337119769319392490073\\n    uint256 internal constant FACTOR04 = 0xfcf2d9987c9be178ad5bfeffaa123273; // 2^128/1.0015**8 = 336226404141693512316971918999264834163\\n    uint256 internal constant FACTOR05 = 0xf9ef02c4529258b057769680fc6601b3; // 2^128/1.0015**16 = 332218786018727629051611634067491389875\\n    uint256 internal constant FACTOR06 = 0xf402d288133a85a17784a411f7aba082; // 2^128/1.0015**32 = 324346285652234375371948336458280706178\\n    uint256 internal constant FACTOR07 = 0xe895615b5beb6386553757b0352bda90; // 2^128/1.0015**64 = 309156521885964218294057947947195947664\\n    uint256 internal constant FACTOR08 = 0xd34f17a00ffa00a8309940a15930391a; // 2^128/1.0015**128 = 280877777739312896540849703637713172762 \\n    uint256 internal constant FACTOR09 = 0xae6b7961714e20548d88ea5123f9a0ff; // 2^128/1.0015**256 = 231843708922198649176471782639349113087\\n    uint256 internal constant FACTOR10 = 0x76d6461f27082d74e0feed3b388c0ca1; // 2^128/1.0015**512 = 157961477267171621126394973980180876449\\n    uint256 internal constant FACTOR11 = 0x372a3bfe0745d8b6b19d985d9a8b85bb; // 2^128/1.0015**1024 = 73326833024599564193373530205717235131\\n    uint256 internal constant FACTOR12 = 0x0be32cbee48979763cf7247dd7bb539d; // 2^128/1.0015**2048 = 15801066890623697521348224657638773661\\n    uint256 internal constant FACTOR13 = 0x8d4f70c9ff4924dac37612d1e2921e;   // 2^128/1.0015**4096 = 733725103481409245883800626999235102\\n    uint256 internal constant FACTOR14 = 0x4e009ae5519380809a02ca7aec77;     // 2^128/1.0015**8192 = 1582075887005588088019997442108535\\n    uint256 internal constant FACTOR15 = 0x17c45e641b6e95dee056ff10;         // 2^128/1.0015**16384 = 7355550435635883087458926352\\n\\n    /// The minimum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MIN_TICK). ~ Equivalent to `(1 << 96) * (1.0015**-32767)`\\n    uint256 internal constant MIN_RATIOX96 = 37075072;\\n    /// The maximum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MAX_TICK).\\n    /// ~ Equivalent to `(1 << 96) * (1.0015**32767)`, rounding etc. leading to minor difference\\n    uint256 internal constant MAX_RATIOX96 = 169307877264527972847801929085841449095838922544595;\\n\\n    uint256 internal constant ZERO_TICK_SCALED_RATIO = 0x1000000000000000000000000; // 1 << 96 // 79228162514264337593543950336\\n    uint256 internal constant _1E26 = 1e26;\\n\\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return ratioX96 ratio = (debt amount/collateral amount)\\n    function getRatioAtTick(int tick) internal pure returns (uint256 ratioX96) {\\n        assembly {\\n            let absTick_ := sub(xor(tick, sar(255, tick)), sar(255, tick))\\n\\n            if gt(absTick_, MAX_TICK) {\\n                revert(0, 0)\\n            }\\n            let factor_ := FACTOR00\\n            if and(absTick_, 0x1) {\\n                factor_ := FACTOR01\\n            }\\n            if and(absTick_, 0x2) {\\n                factor_ := shr(128, mul(factor_, FACTOR02))\\n            }\\n            if and(absTick_, 0x4) {\\n                factor_ := shr(128, mul(factor_, FACTOR03))\\n            }\\n            if and(absTick_, 0x8) {\\n                factor_ := shr(128, mul(factor_, FACTOR04))\\n            }\\n            if and(absTick_, 0x10) {\\n                factor_ := shr(128, mul(factor_, FACTOR05))\\n            }\\n            if and(absTick_, 0x20) {\\n                factor_ := shr(128, mul(factor_, FACTOR06))\\n            }\\n            if and(absTick_, 0x40) {\\n                factor_ := shr(128, mul(factor_, FACTOR07))\\n            }\\n            if and(absTick_, 0x80) {\\n                factor_ := shr(128, mul(factor_, FACTOR08))\\n            }\\n            if and(absTick_, 0x100) {\\n                factor_ := shr(128, mul(factor_, FACTOR09))\\n            }\\n            if and(absTick_, 0x200) {\\n                factor_ := shr(128, mul(factor_, FACTOR10))\\n            }\\n            if and(absTick_, 0x400) {\\n                factor_ := shr(128, mul(factor_, FACTOR11))\\n            }\\n            if and(absTick_, 0x800) {\\n                factor_ := shr(128, mul(factor_, FACTOR12))\\n            }\\n            if and(absTick_, 0x1000) {\\n                factor_ := shr(128, mul(factor_, FACTOR13))\\n            }\\n            if and(absTick_, 0x2000) {\\n                factor_ := shr(128, mul(factor_, FACTOR14))\\n            }\\n            if and(absTick_, 0x4000) {\\n                factor_ := shr(128, mul(factor_, FACTOR15))\\n            }\\n\\n            let precision_ := 0\\n            if iszero(and(tick, 0x8000000000000000000000000000000000000000000000000000000000000000)) {\\n                factor_ := div(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, factor_)\\n                // we round up in the division so getTickAtRatio of the output price is always consistent\\n                if mod(factor_, 0x100000000) {\\n                    precision_ := 1\\n                }\\n            }\\n            ratioX96 := add(shr(32, factor_), precision_)\\n        }\\n    }\\n\\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\\n    /// @dev Throws if ratioX96 > max ratio || ratioX96 < min ratio\\n    /// @param ratioX96 The input ratio; ratio = (debt amount/collateral amount)\\n    /// @return tick The output tick for the above formula. Returns in round down form. if tick is 123.23 then 123, if tick is -123.23 then returns -124\\n    /// @return perfectRatioX96 perfect ratio for the above tick\\n    function getTickAtRatio(uint256 ratioX96) internal pure returns (int tick, uint perfectRatioX96) {\\n        assembly {\\n            if or(gt(ratioX96, MAX_RATIOX96), lt(ratioX96, MIN_RATIOX96)) {\\n                revert(0, 0)\\n            }\\n\\n            let cond := lt(ratioX96, ZERO_TICK_SCALED_RATIO)\\n            let factor_\\n\\n            if iszero(cond) {\\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\\n                factor_ := div(mul(ratioX96, _1E26), ZERO_TICK_SCALED_RATIO)\\n            }\\n            if cond {\\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\\n                factor_ := div(mul(ZERO_TICK_SCALED_RATIO, _1E26), ratioX96)\\n            }\\n\\n            // put in https://www.wolframalpha.com/ whole equation: (1.0015^tick) * 2^96 * 10^26 / 79228162514264337593543950336\\n\\n            // for tick = 16384\\n            // ratioX96 = (1.0015^16384) * 2^96 = 3665252098134783297721995888537077351735\\n            // 3665252098134783297721995888537077351735 * 10^26 / 79228162514264337593543950336 =\\n            // 4626198540796508716348404308345255985.06131964639489434655721\\n            if iszero(lt(factor_, 4626198540796508716348404308345255985)) {\\n                tick := or(tick, 0x4000)\\n                factor_ := div(mul(factor_, _1E26), 4626198540796508716348404308345255985)\\n            }\\n            // for tick = 8192\\n            // ratioX96 = (1.0015^8192) * 2^96 = 17040868196391020479062776466509865\\n            // 17040868196391020479062776466509865 * 10^26 / 79228162514264337593543950336 =\\n            // 21508599537851153911767490449162.3037648642153898377655505172\\n            if iszero(lt(factor_, 21508599537851153911767490449162)) {\\n                tick := or(tick, 0x2000)\\n                factor_ := div(mul(factor_, _1E26), 21508599537851153911767490449162)\\n            }\\n            // for tick = 4096\\n            // ratioX96 = (1.0015^4096) * 2^96 = 36743933851015821532611831851150\\n            // 36743933851015821532611831851150 * 10^26 / 79228162514264337593543950336 =\\n            // 46377364670549310883002866648.9777607649742626173648716941385\\n            if iszero(lt(factor_, 46377364670549310883002866649)) {\\n                tick := or(tick, 0x1000)\\n                factor_ := div(mul(factor_, _1E26), 46377364670549310883002866649)\\n            }\\n            // for tick = 2048\\n            // ratioX96 = (1.0015^2048) * 2^96 = 1706210527034005899209104452335\\n            // 1706210527034005899209104452335 * 10^26 / 79228162514264337593543950336 =\\n            // 2153540449365864845468344760.06357108484096046743300420319322\\n            if iszero(lt(factor_, 2153540449365864845468344760)) {\\n                tick := or(tick, 0x800)\\n                factor_ := div(mul(factor_, _1E26), 2153540449365864845468344760)\\n            }\\n            // for tick = 1024\\n            // ratioX96 = (1.0015^1024) * 2^96 = 367668226692760093024536487236\\n            // 367668226692760093024536487236 * 10^26 / 79228162514264337593543950336 =\\n            // 464062544207767844008185024.950588990554136265212906454481127\\n            if iszero(lt(factor_, 464062544207767844008185025)) {\\n                tick := or(tick, 0x400)\\n                factor_ := div(mul(factor_, _1E26), 464062544207767844008185025)\\n            }\\n            // for tick = 512\\n            // ratioX96 = (1.0015^512) * 2^96 = 170674186729409605620119663668\\n            // 170674186729409605620119663668 * 10^26 / 79228162514264337593543950336 =\\n            // 215421109505955298802281577.031879604792139232258508172947569\\n            if iszero(lt(factor_, 215421109505955298802281577)) {\\n                tick := or(tick, 0x200)\\n                factor_ := div(mul(factor_, _1E26), 215421109505955298802281577)\\n            }\\n            // for tick = 256\\n            // ratioX96 = (1.0015^256) * 2^96 = 116285004205991934861656513301\\n            // 116285004205991934861656513301 * 10^26 / 79228162514264337593543950336 =\\n            // 146772309890508740607270614.667650899656438875541505058062410\\n            if iszero(lt(factor_, 146772309890508740607270615)) {\\n                tick := or(tick, 0x100)\\n                factor_ := div(mul(factor_, _1E26), 146772309890508740607270615)\\n            }\\n            // for tick = 128\\n            // ratioX96 = (1.0015^128) * 2^96 = 95984619659632141743747099590\\n            // 95984619659632141743747099590 * 10^26 / 79228162514264337593543950336 =\\n            // 121149622323187099817270416.157248837742741760456796835775887\\n            if iszero(lt(factor_, 121149622323187099817270416)) {\\n                tick := or(tick, 0x80)\\n                factor_ := div(mul(factor_, _1E26), 121149622323187099817270416)\\n            }\\n            // for tick = 64\\n            // ratioX96 = (1.0015^64) * 2^96 = 87204845308406958006717891124\\n            // 87204845308406958006717891124 * 10^26 / 79228162514264337593543950336 =\\n            // 110067989135437147685980801.568068573422377364214113968609839\\n            if iszero(lt(factor_, 110067989135437147685980801)) {\\n                tick := or(tick, 0x40)\\n                factor_ := div(mul(factor_, _1E26), 110067989135437147685980801)\\n            }\\n            // for tick = 32\\n            // ratioX96 = (1.0015^32) * 2^96 = 83120873769022354029916374475\\n            // 83120873769022354029916374475 * 10^26 / 79228162514264337593543950336 =\\n            // 104913292358707887270979599.831816586773651266562785765558183\\n            if iszero(lt(factor_, 104913292358707887270979600)) {\\n                tick := or(tick, 0x20)\\n                factor_ := div(mul(factor_, _1E26), 104913292358707887270979600)\\n            }\\n            // for tick = 16\\n            // ratioX96 = (1.0015^16) * 2^96 = 81151180492336368327184716176\\n            // 81151180492336368327184716176 * 10^26 / 79228162514264337593543950336 =\\n            // 102427189924701091191840927.762844039579442328381455567932128\\n            if iszero(lt(factor_, 102427189924701091191840928)) {\\n                tick := or(tick, 0x10)\\n                factor_ := div(mul(factor_, _1E26), 102427189924701091191840928)\\n            }\\n            // for tick = 8\\n            // ratioX96 = (1.0015^8) * 2^96 = 80183906840906820640659903620\\n            // 80183906840906820640659903620 * 10^26 / 79228162514264337593543950336 =\\n            // 101206318935480056907421312.890625\\n            if iszero(lt(factor_, 101206318935480056907421313)) {\\n                tick := or(tick, 0x8)\\n                factor_ := div(mul(factor_, _1E26), 101206318935480056907421313)\\n            }\\n            // for tick = 4\\n            // ratioX96 = (1.0015^4) * 2^96 = 79704602139525152702959747603\\n            // 79704602139525152702959747603 * 10^26 / 79228162514264337593543950336 =\\n            // 100601351350506250000000000\\n            if iszero(lt(factor_, 100601351350506250000000000)) {\\n                tick := or(tick, 0x4)\\n                factor_ := div(mul(factor_, _1E26), 100601351350506250000000000)\\n            }\\n            // for tick = 2\\n            // ratioX96 = (1.0015^2) * 2^96 = 79466025265172787701084167660\\n            // 79466025265172787701084167660 * 10^26 / 79228162514264337593543950336 =\\n            // 100300225000000000000000000\\n            if iszero(lt(factor_, 100300225000000000000000000)) {\\n                tick := or(tick, 0x2)\\n                factor_ := div(mul(factor_, _1E26), 100300225000000000000000000)\\n            }\\n            // for tick = 1\\n            // ratioX96 = (1.0015^1) * 2^96 = 79347004758035734099934266261\\n            // 79347004758035734099934266261 * 10^26 / 79228162514264337593543950336 =\\n            // 100150000000000000000000000\\n            if iszero(lt(factor_, 100150000000000000000000000)) {\\n                tick := or(tick, 0x1)\\n                factor_ := div(mul(factor_, _1E26), 100150000000000000000000000)\\n            }\\n            if iszero(cond) {\\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\\n                perfectRatioX96 := div(mul(ratioX96, _1E26), factor_)\\n            }\\n            if cond {\\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\\n                tick := not(tick)\\n                perfectRatioX96 := div(mul(ratioX96, factor_), 100150000000000000000000000)\\n            }\\n            // perfect ratio should always be <= ratioX96\\n            // not sure if it can ever be bigger but better to have extra checks\\n            if gt(perfectRatioX96, ratioX96) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ec1c1ecb5c506f2264675fa56dbb28481c2df15e4064d545d78e387f7c95b69\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/adminModule/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\nabstract contract Structs {\\n    struct AddressBool {\\n        address addr;\\n        bool value;\\n    }\\n\\n    struct AddressUint256 {\\n        address addr;\\n        uint256 value;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 1\\n    struct RateDataV1Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\\n        uint256 kink;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink;\\n        ///\\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 2\\n    struct RateDataV2Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\\n        uint256 kink1;\\n        ///\\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\\n        uint256 kink2;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink1;\\n        ///\\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\\n        uint256 rateAtUtilizationKink2;\\n        ///\\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set token config\\n    struct TokenConfig {\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 fee;\\n        ///\\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 threshold;\\n        ///\\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\\n        uint256 maxUtilization;\\n    }\\n\\n    /// @notice struct to set user supply & withdrawal config\\n    struct UserSupplyConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration withdrawal limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseWithdrawalLimit;\\n    }\\n\\n    /// @notice struct to set user borrow & payback config\\n    struct UserBorrowConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which debt limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration debt limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseDebtCeiling;\\n        ///\\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 maxDebtCeiling;\\n    }\\n}\\n\",\"keccak256\":\"0xfa7cbe07b97f45acd0460deaff1ef54de9473164249e5527ee4da6efb6bf7e65\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/liquidity/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\nimport { Structs as AdminModuleStructs } from \\\"../../../liquidity/adminModule/structs.sol\\\";\\n\\nabstract contract Structs {\\n    struct RateData {\\n        uint256 version;\\n        AdminModuleStructs.RateDataV1Params rateDataV1;\\n        AdminModuleStructs.RateDataV2Params rateDataV2;\\n    }\\n\\n    struct OverallTokenData {\\n        uint256 borrowRate;\\n        uint256 supplyRate;\\n        uint256 fee; // revenue fee\\n        uint256 lastStoredUtilization;\\n        uint256 storageUpdateThreshold;\\n        uint256 lastUpdateTimestamp;\\n        uint256 supplyExchangePrice;\\n        uint256 borrowExchangePrice;\\n        uint256 supplyRawInterest;\\n        uint256 supplyInterestFree;\\n        uint256 borrowRawInterest;\\n        uint256 borrowInterestFree;\\n        uint256 totalSupply;\\n        uint256 totalBorrow;\\n        uint256 revenue;\\n        uint256 maxUtilization; // maximum allowed utilization\\n        RateData rateData;\\n    }\\n\\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\\n    struct UserSupplyData {\\n        bool modeWithInterest; // true if mode = with interest, false = without interest\\n        uint256 supply; // user supply amount\\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\\n        uint256 withdrawalLimit;\\n        uint256 lastUpdateTimestamp;\\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\\n        uint256 baseWithdrawalLimit;\\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\\n        uint256 withdrawableUntilLimit;\\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\\n        // internal decay limit values\\n        uint256 decayEndTimestamp; // computed from last update timestamp + decay duration. when decay will fully end.\\n        uint256 decayAmount; // as in storage adjusted for decayed time leftover\\n    }\\n\\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\\n    struct UserBorrowData {\\n        bool modeWithInterest; // true if mode = with interest, false = without interest\\n        uint256 borrow; // user borrow amount\\n        uint256 borrowLimit;\\n        uint256 lastUpdateTimestamp;\\n        uint256 expandPercent;\\n        uint256 expandDuration;\\n        uint256 baseBorrowLimit;\\n        uint256 maxBorrowLimit;\\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\\n    }\\n}\\n\",\"keccak256\":\"0xf3099e1e6ee1729f65abf63214af0884e49bc800ccf05b79c4fcd44e90a33add\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vault/iVaultResolver.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { Structs } from \\\"./structs.sol\\\";\\n\\ninterface IFluidVaultResolver {\\n    function vaultByNftId(uint nftId_) external view returns (address vault_);\\n\\n    function positionByNftId(\\n        uint nftId_\\n    ) external view returns (Structs.UserPosition memory userPosition_, Structs.VaultEntireData memory vaultData_);\\n\\n    function getVaultVariablesRaw(address vault_) external view returns (uint);\\n\\n    function getVaultVariables2Raw(address vault_) external view returns (uint);\\n\\n    function getTickHasDebtRaw(address vault_, int key_) external view returns (uint);\\n\\n    function getTickDataRaw(address vault_, int tick_) external view returns (uint);\\n\\n    function getBranchDataRaw(address vault_, uint branch_) external view returns (uint);\\n\\n    function getPositionDataRaw(address vault_, uint positionId_) external view returns (uint);\\n\\n    function getAllVaultsAddresses() external view returns (address[] memory vaults_);\\n\\n    function getVaultLiquidation(\\n        address vault_,\\n        uint tokenInAmt_\\n    ) external returns (Structs.LiquidationStruct memory liquidationData_);\\n\\n    function getVaultEntireData(address vault_) external view returns (Structs.VaultEntireData memory vaultData_);\\n}\\n\",\"keccak256\":\"0x8db2ba8c10b3f2a624ad2924ec5b59dbb805b42357eb98e9df6835963fff0634\",\"license\":\"MIT\"},\"contracts/periphery/resolvers/vault/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidVault } from \\\"../../../protocols/vault/interfaces/iVault.sol\\\";\\nimport { Structs as FluidLiquidityResolverStructs } from \\\"../liquidity/structs.sol\\\";\\n\\n// @dev Amounts are always in token amount for normal col / normal debt or in\\n// shares for Dex smart col / smart debt.\\ncontract Structs {\\n    struct Configs {\\n        // can be supplyRate instead if Vault Type is smart col. in that case if 1st bit == 1 then positive else negative\\n        uint16 supplyRateMagnifier;\\n        // can be borrowRate instead if Vault Type is smart debt. in that case if 1st bit == 1 then positive else negative\\n        uint16 borrowRateMagnifier;\\n        uint16 collateralFactor;\\n        uint16 liquidationThreshold;\\n        uint16 liquidationMaxLimit;\\n        uint16 withdrawalGap;\\n        uint16 liquidationPenalty;\\n        uint16 borrowFee;\\n        address oracle;\\n        // Oracle price is always debt per col, i.e. amount of debt for 1 col.\\n        // In case of Dex this price can be used to resolve shares values w.r.t. token0 or token1:\\n        // - T2: debt token per 1 col share\\n        // - T3: debt shares per 1 col token\\n        // - T4: debt shares per 1 col share\\n        uint oraclePriceOperate;\\n        uint oraclePriceLiquidate;\\n        address rebalancer;\\n        uint lastUpdateTimestamp;\\n    }\\n\\n    struct ExchangePricesAndRates {\\n        uint lastStoredLiquiditySupplyExchangePrice; // 0 in case of smart col\\n        uint lastStoredLiquidityBorrowExchangePrice; // 0 in case of smart debt\\n        uint lastStoredVaultSupplyExchangePrice;\\n        uint lastStoredVaultBorrowExchangePrice;\\n        uint liquiditySupplyExchangePrice; // set to 1e12 in case of smart col\\n        uint liquidityBorrowExchangePrice; // set to 1e12 in case of smart debt\\n        uint vaultSupplyExchangePrice;\\n        uint vaultBorrowExchangePrice;\\n        uint supplyRateLiquidity; // set to 0 in case of smart col. Must get per token through DexEntireData\\n        uint borrowRateLiquidity; // set to 0 in case of smart debt. Must get per token through DexEntireData\\n        // supplyRateVault or borrowRateVault:\\n        // - when normal col / debt: rate at liquidity + diff rewards or fee through magnifier (rewardsOrFeeRate below)\\n        // - when smart col / debt: rewards or fee rate at the vault itself. always == rewardsOrFeeRate below.\\n        // to get the full rates for vault when smart col / debt, combine with data from DexResolver:\\n        // - rateAtLiquidity for token0 or token1 (DexResolver)\\n        // - the rewards or fee rate at the vault (VaultResolver)\\n        // - the Dex APR (currently off-chain compiled through tracking swap events at the DEX)\\n        int supplyRateVault; // can be negative in case of smart col (meaning pay to supply)\\n        int borrowRateVault; // can be negative in case of smart debt (meaning get paid to borrow)\\n        // rewardsOrFeeRateSupply: rewards or fee rate in percent 1e2 precision (1% = 100, 100% = 10000).\\n        // positive rewards, negative fee.\\n        // for smart col vaults: absolute percent, supplyRateVault == rewardsOrFeeRateSupply.\\n        // for normal col vaults: relative percent to supplyRateLiquidity, e.g.:\\n        // when rewards: supplyRateLiquidity = 4%, rewardsOrFeeRateSupply = 20%, supplyRateVault = 4.8%.\\n        // when fee: supplyRateLiquidity = 4%, rewardsOrFeeRateSupply = -30%, supplyRateVault = 2.8%.\\n        int rewardsOrFeeRateSupply;\\n        // rewardsOrFeeRateBorrow: rewards or fee rate in percent 1e2 precision (1% = 100, 100% = 10000).\\n        // negative rewards, positive fee.\\n        // for smart debt vaults: absolute percent, borrowRateVault == rewardsOrFeeRateBorrow.\\n        // for normal debt vaults: relative percent to borrowRateLiquidity, e.g.:\\n        // when rewards: borrowRateLiquidity = 4%, rewardsOrFeeRateBorrow = -20%, borrowRateVault = 3.2%.\\n        // when fee: borrowRateLiquidity = 4%, rewardsOrFeeRateBorrow = 30%, borrowRateVault = 5.2%.\\n        int rewardsOrFeeRateBorrow;\\n    }\\n\\n    struct TotalSupplyAndBorrow {\\n        uint totalSupplyVault;\\n        uint totalBorrowVault;\\n        uint totalSupplyLiquidityOrDex;\\n        uint totalBorrowLiquidityOrDex;\\n        uint absorbedSupply;\\n        uint absorbedBorrow;\\n    }\\n\\n    struct LimitsAndAvailability {\\n        // in case of DEX: withdrawable / borrowable amount of vault at DEX, BUT there could be that DEX can not withdraw\\n        // that much at Liquidity! So for DEX this must be combined with returned data in DexResolver.\\n        uint withdrawLimit;\\n        uint withdrawableUntilLimit;\\n        uint withdrawable;\\n        uint borrowLimit;\\n        uint borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\\n        uint borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\\n        uint borrowLimitUtilization; // borrow limit for `maxUtilization` config at Liquidity\\n        uint minimumBorrowing;\\n    }\\n\\n    struct CurrentBranchState {\\n        uint status; // if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\\n        int minimaTick;\\n        uint debtFactor;\\n        uint partials;\\n        uint debtLiquidity;\\n        uint baseBranchId;\\n        int baseBranchMinima;\\n    }\\n\\n    struct VaultState {\\n        uint totalPositions;\\n        int topTick;\\n        uint currentBranch;\\n        uint totalBranch;\\n        uint totalBorrow;\\n        uint totalSupply;\\n        CurrentBranchState currentBranchState;\\n    }\\n\\n    struct VaultEntireData {\\n        address vault;\\n        bool isSmartCol; // true if col token is a Fluid Dex\\n        bool isSmartDebt; // true if debt token is a Fluid Dex\\n        IFluidVault.ConstantViews constantVariables;\\n        Configs configs;\\n        ExchangePricesAndRates exchangePricesAndRates;\\n        TotalSupplyAndBorrow totalSupplyAndBorrow;\\n        LimitsAndAvailability limitsAndAvailability;\\n        VaultState vaultState;\\n        // liquidity related data such as supply amount, limits, expansion etc.\\n        // Also set for Dex, limits are in shares and same things apply as noted for LimitsAndAvailability above!\\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyData;\\n        // liquidity related data such as borrow amount, limits, expansion etc.\\n        // Also set for Dex, limits are in shares and same things apply as noted for LimitsAndAvailability above!\\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowData;\\n    }\\n\\n    struct UserPosition {\\n        uint nftId;\\n        address owner;\\n        bool isLiquidated;\\n        bool isSupplyPosition; // if true that means borrowing is 0\\n        int tick;\\n        uint tickId;\\n        uint beforeSupply;\\n        uint beforeBorrow;\\n        uint beforeDustBorrow;\\n        uint supply;\\n        uint borrow;\\n        uint dustBorrow;\\n    }\\n\\n    /// @dev liquidation related data\\n    /// @param vault address of vault\\n    /// @param token0In address of token in\\n    /// @param token0Out address of token out\\n    /// @param token1In address of token in (if smart debt)\\n    /// @param token1Out address of token out (if smart col)\\n    /// @param inAmt (without absorb liquidity) minimum of available liquidation\\n    /// @param outAmt (without absorb liquidity) expected token out, collateral to withdraw\\n    /// @param inAmtWithAbsorb (absorb liquidity included) minimum of available liquidation. In most cases it'll be same as inAmt but sometimes can be bigger.\\n    /// @param outAmtWithAbsorb (absorb liquidity included) expected token out, collateral to withdraw. In most cases it'll be same as outAmt but sometimes can be bigger.\\n    /// @param absorbAvailable true if absorb is available\\n    /// @dev Liquidity in with absirb will always be >= without asborb. Sometimes without asborb can provide better swaps,\\n    ///      sometimes with absirb can provide better swaps. But available in with absirb will always be >= One\\n    struct LiquidationStruct {\\n        address vault;\\n        address token0In;\\n        address token0Out;\\n        address token1In;\\n        address token1Out;\\n        // amounts in case of smart debt are in shares, otherwise token amounts.\\n        // smart col can not be liquidated so to exchange inAmt always use DexResolver DexState.tokenPerDebtShare\\n        // and tokenPerColShare for outAmt when Vault is smart col.\\n        uint inAmt;\\n        uint outAmt;\\n        uint inAmtWithAbsorb;\\n        uint outAmtWithAbsorb;\\n        bool absorbAvailable;\\n    }\\n\\n    struct AbsorbStruct {\\n        address vault;\\n        bool absorbAvailable;\\n    }\\n}\\n\",\"keccak256\":\"0x6ec605175cdfdb288da55c2a94f2ed17ea57ac689c81e702f761a696b0f73e8a\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vaultPositions/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Variables } from \\\"./variables.sol\\\";\\nimport { Structs } from \\\"./structs.sol\\\";\\nimport { IFluidVaultFactory } from \\\"../../../protocols/vault/interfaces/iVaultFactory.sol\\\";\\nimport { IFluidVaultResolver } from \\\"../vault/iVaultResolver.sol\\\";\\nimport { IFluidVault } from \\\"../../../protocols/vault/interfaces/iVault.sol\\\";\\nimport { TickMath } from \\\"../../../libraries/tickMath.sol\\\";\\n\\n/// @title Fluid Vault protocol Positions Resolver for all vault types.\\n/// @notice This contract resolves positions for Fluid Vaults, providing functionality to retrieve NFT IDs and positions for a given vault.\\ncontract FluidVaultPositionsResolver is Variables, Structs {\\n    /// @notice thrown if an input param address is zero\\n    error FluidVaultPositionsResolver__AddressZero();\\n    error FluidVaultPositionsResolver__InvalidParams();\\n\\n    uint internal constant PAGE_SIZE = 3000;\\n\\n    /// @notice constructor sets the immutable vault factory address\\n    /// @param vaultFactory_ The FluidVaultFactory contract address\\n    constructor(IFluidVaultFactory vaultFactory_) Variables(vaultFactory_) {\\n        if (address(vaultFactory_) == address(0)) {\\n            revert FluidVaultPositionsResolver__AddressZero();\\n        }\\n    }\\n\\n    /// @notice Returns the NFT token IDs for a given vault using a paged approach, reading 3000 nfts per page.\\n    /// @dev Use this method on chains where retrieving all token IDs at once may run out of gas.\\n    ///      Call this repeatedly with increasing page numbers until hasNextPage is false, then use `getVaultPositionsForNftIds`.\\n    /// @param vault_ The address of the vault.\\n    /// @param page_ The current page to fetch (pagination index). start with page 0.\\n    /// @return nftIds_ Array of NFT token IDs for the specified page.\\n    /// @return hasNextPage_ True if there are more pages to fetch, false if this is the last page.\\n    function getAllVaultNftIdsPaged(\\n        address vault_,\\n        uint256 page_\\n    ) public view returns (uint256[] memory nftIds_, bool hasNextPage_) {\\n        uint256 totalPositions_ = FACTORY.totalSupply();\\n\\n        uint256 startIndex_ = page_ * PAGE_SIZE;\\n        uint256 endIndex_ = startIndex_ + PAGE_SIZE;\\n        if (endIndex_ > totalPositions_) {\\n            endIndex_ = totalPositions_;\\n            hasNextPage_ = false;\\n        } else {\\n            hasNextPage_ = true;\\n        }\\n\\n        uint256[] memory tempNftIds_ = new uint256[](endIndex_ - startIndex_);\\n        uint256 nftId_;\\n        uint256 j;\\n        for (uint256 i = startIndex_; i < endIndex_; ) {\\n            nftId_ = _tokenByIndex(i);\\n            unchecked {\\n                ++i;\\n            }\\n            if (_vaultByNftId(nftId_) == vault_) {\\n                tempNftIds_[j] = nftId_;\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n        }\\n\\n        // adjust the array length based on how many were actually found\\n        nftIds_ = new uint256[](j);\\n        for (uint256 k; k < j; ++k) {\\n            nftIds_[k] = tempNftIds_[k];\\n        }\\n    }\\n\\n    /// @notice Returns all NFT token IDs for the specified vault. Use `getAllVaultNftIdsPaged` if this runs out of gas!\\n    /// @param vault_ The address of the vault.\\n    /// @return nftIds_ Array of NFT token IDs belonging to the vault.\\n    function getAllVaultNftIds(address vault_) public view returns (uint256[] memory nftIds_) {\\n        uint256 totalPositions_ = FACTORY.totalSupply();\\n\\n        /// get total positions for vault: Next 32 bits => 210-241 => Total positions\\n        uint256 totalVaultPositions_ = (_getVaultVariablesRaw(vault_) >> 210) & 0xFFFFFFFF;\\n        nftIds_ = new uint256[](totalVaultPositions_);\\n\\n        // get nft Ids belonging to the vault_\\n        uint256 nftId_;\\n        uint256 j;\\n        for (uint256 i; i < totalPositions_; ) {\\n            nftId_ = _tokenByIndex(i);\\n            unchecked {\\n                ++i;\\n            }\\n            if (_vaultByNftId(nftId_) == vault_) {\\n                nftIds_[j] = nftId_;\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Gets user positions for NFT IDs assumed to belong to a specific vault.\\n    /// @param nftIds_ Array of NFT IDs. Split reading into chunks if this runs out of gas!\\n    /// @param vault_ The address of the vault.\\n    /// @return positions_ Array of UserPosition for the NFT IDs.\\n    function getVaultPositionsForNftIds(\\n        uint256[] memory nftIds_,\\n        address vault_\\n    ) public view returns (UserPosition[] memory positions_) {\\n        if (vault_ == address(0)) {\\n            revert FluidVaultPositionsResolver__InvalidParams();\\n        }\\n        positions_ = new UserPosition[](nftIds_.length);\\n\\n        // exchange prices are always the same for the same vault\\n        (, , uint vaultSupplyExchangePrice_, uint vaultBorrowExchangePrice_) = IFluidVault(vault_).updateExchangePrices(\\n            _getVaultVariables2Raw(vault_)\\n        );\\n\\n        address vaultCheck_;\\n        address nftOwner_;\\n        for (uint256 i; i < nftIds_.length; ++i) {\\n            (vaultCheck_, nftOwner_) = _vaultAndOwnerByNftId(nftIds_[i]);\\n            if (vault_ != vaultCheck_) {\\n                revert FluidVaultPositionsResolver__InvalidParams();\\n            }\\n            positions_[i] = _getVaultPosition(\\n                vault_,\\n                nftIds_[i],\\n                vaultSupplyExchangePrice_,\\n                vaultBorrowExchangePrice_,\\n                nftOwner_\\n            );\\n        }\\n    }\\n\\n    /// @notice Gets user positions for a set of NFT IDs.\\n    /// @param nftIds_ Array of NFT IDs. Split reading into chunks if this runs out of gas!\\n    /// @return positions_ Array of UserPosition for each NFT ID.\\n    function getPositionsForNftIds(uint256[] memory nftIds_) public view returns (UserPosition[] memory positions_) {\\n        positions_ = new UserPosition[](nftIds_.length);\\n\\n        address vault_;\\n        address nftOwner_;\\n        for (uint256 i; i < nftIds_.length; ++i) {\\n            (vault_, nftOwner_) = _vaultAndOwnerByNftId(nftIds_[i]);\\n            if (vault_ == address(0)) {\\n                // should never happen but make sure it wouldn't lead to a revert\\n                positions_[i] = UserPosition({ nftId: nftIds_[i], owner: address(0), supply: 0, borrow: 0 });\\n            } else {\\n                (, , uint vaultSupplyExchangePrice_, uint vaultBorrowExchangePrice_) = IFluidVault(vault_)\\n                    .updateExchangePrices(_getVaultVariables2Raw(vault_));\\n\\n                positions_[i] = _getVaultPosition(\\n                    vault_,\\n                    nftIds_[i],\\n                    vaultSupplyExchangePrice_,\\n                    vaultBorrowExchangePrice_,\\n                    nftOwner_\\n                );\\n            }\\n        }\\n    }\\n\\n    /// @notice Gets all positions for the given vault. Use `getAllVaultNftIds` first if this runs out of gas!\\n    /// @param vault_ The address of the vault.\\n    /// @return positions_ Array of UserPosition for each position in the vault.\\n    function getAllVaultPositions(address vault_) public view returns (UserPosition[] memory positions_) {\\n        if (vault_ == address(0)) {\\n            revert FluidVaultPositionsResolver__InvalidParams();\\n        }\\n        // exchange prices are always the same for the same vault\\n        (, , uint vaultSupplyExchangePrice_, uint vaultBorrowExchangePrice_) = IFluidVault(vault_).updateExchangePrices(\\n            _getVaultVariables2Raw(vault_)\\n        );\\n\\n        uint256 totalPositions_ = FACTORY.totalSupply();\\n\\n        // get total positions for vault: Next 32 bits => 210-241 => Total positions\\n        uint256 totalVaultPositions_ = (_getVaultVariablesRaw(vault_) >> 210) & 0xFFFFFFFF;\\n        positions_ = new UserPosition[](totalVaultPositions_);\\n\\n        uint256 nftId_;\\n        uint256 j;\\n        address vaultCheck_;\\n        address nftOwner_;\\n        for (uint256 i; i < totalPositions_; ) {\\n            nftId_ = _tokenByIndex(i);\\n            unchecked {\\n                ++i;\\n            }\\n\\n            (vaultCheck_, nftOwner_) = _vaultAndOwnerByNftId(nftId_);\\n            if (vaultCheck_ == vault_) {\\n                positions_[j] = _getVaultPosition(\\n                    vault_,\\n                    nftId_,\\n                    vaultSupplyExchangePrice_,\\n                    vaultBorrowExchangePrice_,\\n                    nftOwner_\\n                );\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Get the raw variables of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @return The raw variables of the vault.\\n    function _getVaultVariablesRaw(address vault_) internal view returns (uint) {\\n        return IFluidVault(vault_).readFromStorage(bytes32(uint256(0)));\\n    }\\n\\n    /// @notice Get the raw variables of a vault (slot 1).\\n    /// @param vault_ The address of the vault.\\n    /// @return The raw variables of the vault (slot 1).\\n    function _getVaultVariables2Raw(address vault_) internal view returns (uint) {\\n        return IFluidVault(vault_).readFromStorage(bytes32(uint256(1)));\\n    }\\n\\n    /// @notice Calculates the storage slot for a mapping.\\n    /// @param slot_ The slot index.\\n    /// @param key_ The mapping key.\\n    /// @return The calculated storage slot.\\n    function _calculateStorageSlotUintMapping(uint256 slot_, uint key_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping\\n    function _calculateStorageSlotIntMapping(uint256 slot_, int key_) public pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Get the position data of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @param positionId_ The ID of the position.\\n    /// @return The position data of the vault.\\n    function _getPositionDataRaw(address vault_, uint positionId_) internal view returns (uint) {\\n        return IFluidVault(vault_).readFromStorage(_calculateStorageSlotUintMapping(3, positionId_));\\n    }\\n\\n    /// @notice Get the raw tick data of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @param tick_ The tick value.\\n    /// @return The raw tick data of the vault.\\n    // if tick > 0 then key_ = tick / 256\\n    // if tick < 0 then key_ = (tick / 256) - 1\\n    function _getTickDataRaw(address vault_, int tick_) internal view returns (uint) {\\n        return IFluidVault(vault_).readFromStorage(_calculateStorageSlotIntMapping(5, tick_));\\n    }\\n\\n    /// @notice Returns a token ID at a given index.\\n    /// @param index_ The index to fetch.\\n    /// @return The tokenId at the given index.\\n    function _tokenByIndex(uint256 index_) internal pure returns (uint256) {\\n        return index_ + 1;\\n    }\\n\\n    /// @notice Computes the address of a vault based on its given ID.\\n    /// @param vaultId_ The ID of the vault.\\n    /// @return vault_ The computed vault address.\\n    function _getVaultAddress(uint256 vaultId_) internal view returns (address vault_) {\\n        // @dev based on https://ethereum.stackexchange.com/a/61413\\n\\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\\n        // hence, nonce of vault deployment starts with 1.\\n        bytes memory data;\\n        if (vaultId_ == 0x00) {\\n            return address(0);\\n        } else if (vaultId_ <= 0x7f) {\\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), address(FACTORY), uint8(vaultId_));\\n        } else if (vaultId_ <= 0xff) {\\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), address(FACTORY), bytes1(0x81), uint8(vaultId_));\\n        } else if (vaultId_ <= 0xffff) {\\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), address(FACTORY), bytes1(0x82), uint16(vaultId_));\\n        } else if (vaultId_ <= 0xffffff) {\\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), address(FACTORY), bytes1(0x83), uint24(vaultId_));\\n        } else {\\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), address(FACTORY), bytes1(0x84), uint32(vaultId_));\\n        }\\n\\n        return address(uint160(uint256(keccak256(data))));\\n    }\\n\\n    /// @notice Returns the vault address for a given NFT ID.\\n    /// @param nftId_ The NFT ID.\\n    /// @return vault_ The vault address associated with the NFT ID.\\n    function _vaultByNftId(uint nftId_) internal view returns (address vault_) {\\n        uint tokenConfig_ = FACTORY.readFromStorage(keccak256(abi.encode(nftId_, 3)));\\n        vault_ = _getVaultAddress((tokenConfig_ >> 192) & X32);\\n    }\\n\\n    /// @notice Returns the vault address and NFT owner for a given NFT ID.\\n    /// @param nftId_ The NFT ID.\\n    /// @return vault_ The vault address.\\n    /// @return nftOwner_ The NFT owner address.\\n    function _vaultAndOwnerByNftId(uint nftId_) internal view returns (address vault_, address nftOwner_) {\\n        uint tokenConfig_ = FACTORY.readFromStorage(keccak256(abi.encode(nftId_, 3)));\\n        vault_ = _getVaultAddress((tokenConfig_ >> 192) & X32);\\n        nftOwner_ = address(uint160(tokenConfig_));\\n    }\\n\\n    /// @notice Gets the vault position for a given vault, NFT, and exchange prices.\\n    /// @param vault_ The vault address.\\n    /// @param nftId_ The NFT ID.\\n    /// @param vaultSupplyExchangePrice_ The vault supply exchange price.\\n    /// @param vaultBorrowExchangePrice_ The vault borrow exchange price.\\n    /// @param nftOwner_ The NFT owner.\\n    /// @return userPosition_ The UserPosition struct with the decoded position.\\n    function _getVaultPosition(\\n        address vault_,\\n        uint nftId_,\\n        uint vaultSupplyExchangePrice_,\\n        uint vaultBorrowExchangePrice_,\\n        address nftOwner_\\n    ) internal view returns (UserPosition memory userPosition_) {\\n        // @dev code below based on VaultResolver `positionByNftId()`\\n        userPosition_.nftId = nftId_;\\n        userPosition_.owner = nftOwner_;\\n\\n        uint positionData_ = _getPositionDataRaw(vault_, nftId_);\\n\\n        userPosition_.supply = (positionData_ >> 45) & X64;\\n        // Converting big number into normal number\\n        userPosition_.supply = (userPosition_.supply >> 8) << (userPosition_.supply & X8);\\n\\n        if ((positionData_ & 1) != 1) {\\n            // not just a supply position\\n\\n            int tick_ = (positionData_ & 2) == 2 ? int((positionData_ >> 2) & X19) : -int((positionData_ >> 2) & X19);\\n            userPosition_.borrow = (TickMath.getRatioAtTick(int24(tick_)) * userPosition_.supply) >> 96;\\n\\n            uint tickData_ = _getTickDataRaw(vault_, tick_);\\n            uint tickId_ = (positionData_ >> 21) & X24;\\n            if (((tickData_ & 1) == 1) || (((tickData_ >> 1) & X24) > tickId_)) {\\n                (tick_, userPosition_.borrow, userPosition_.supply, , ) = IFluidVault(vault_).fetchLatestPosition(\\n                    tick_,\\n                    tickId_,\\n                    userPosition_.borrow,\\n                    tickData_\\n                );\\n            }\\n\\n            uint dustBorrow_ = (positionData_ >> 109) & X64;\\n            // Converting big number into normal number\\n            dustBorrow_ = (dustBorrow_ >> 8) << (dustBorrow_ & X8);\\n\\n            if (userPosition_.borrow > dustBorrow_) {\\n                unchecked {\\n                    userPosition_.borrow = userPosition_.borrow - dustBorrow_;\\n                }\\n            } else {\\n                userPosition_.borrow = 0;\\n            }\\n\\n            userPosition_.borrow = (userPosition_.borrow * vaultBorrowExchangePrice_) / 1e12;\\n        }\\n\\n        userPosition_.supply = (userPosition_.supply * vaultSupplyExchangePrice_) / 1e12;\\n    }\\n}\\n\",\"keccak256\":\"0x4aa82189603cfe9f3111c0fbe10de5ecfcde25a2f50a5fe04aabce304f183103\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vaultPositions/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ncontract Structs {\\n    struct UserPosition {\\n        uint nftId;\\n        address owner;\\n        uint supply;\\n        uint borrow;\\n    }\\n}\\n\",\"keccak256\":\"0x7c7d70501ec27863eab620195f377c69bc08e833f8bc1a028e7d56438a27ebfa\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vaultPositions/variables.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidVaultResolver } from \\\"../vault/iVaultResolver.sol\\\";\\nimport { IFluidVaultFactory } from \\\"../../../protocols/vault/interfaces/iVaultFactory.sol\\\";\\n\\ncontract Variables {\\n    IFluidVaultFactory public immutable FACTORY;\\n\\n    // 30 bits (used for partials mainly)\\n    uint internal constant X8 = 0xff;\\n    uint internal constant X19 = 0x7ffff;\\n    uint internal constant X24 = 0xffffff;\\n    uint internal constant X32 = 0xffffffff;\\n    uint internal constant X64 = 0xffffffffffffffff;\\n\\n    constructor(IFluidVaultFactory vaultFactory_) {\\n        FACTORY = vaultFactory_;\\n    }\\n}\\n\",\"keccak256\":\"0x5011a3db6245ec5ed93bc5ee67575a932aef0b543bf5573f1fb6ec40a184f508\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/interfaces/iVault.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\\ninterface IFluidVault {\\n    /// @notice returns the vault id\\n    function VAULT_ID() external view returns (uint256);\\n\\n    /// @notice returns the vault id\\n    function TYPE() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct Tokens {\\n        address token0;\\n        address token1;\\n    }\\n\\n    struct ConstantViews {\\n        address liquidity;\\n        address factory;\\n        address operateImplementation;\\n        address adminImplementation;\\n        address secondaryImplementation;\\n        address deployer; // address which deploys oracle\\n        address supply; // either liquidity layer or DEX protocol\\n        address borrow; // either liquidity layer or DEX protocol\\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\\n        uint256 vaultId;\\n        uint256 vaultType;\\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n    }\\n\\n    /// @notice returns all Vault constants\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    /// @notice fetches the latest user position after a liquidation\\n    function fetchLatestPosition(\\n        int256 positionTick_,\\n        uint256 positionTickId_,\\n        uint256 positionRawDebt_,\\n        uint256 tickData_\\n    )\\n        external\\n        view\\n        returns (\\n            int256, // tick\\n            uint256, // raw debt\\n            uint256, // raw collateral\\n            uint256, // branchID_\\n            uint256 // branchData_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices\\n    function updateExchangePrices(\\n        uint256 vaultVariables2_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices and writes them to storage\\n    function updateExchangePricesOnStorage()\\n        external\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice returns the liquidity contract address\\n    function LIQUIDITY() external view returns (address);\\n\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n\\n    function rebalance(\\n        int colToken0MinMax_,\\n        int colToken1MinMax_,\\n        int debtToken0MinMax_,\\n        int debtToken1MinMax_\\n    ) external payable returns (int supplyAmt_, int borrowAmt_);\\n\\n    /// @notice reverts with FluidLiquidateResult\\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\\n}\\n\",\"keccak256\":\"0xdd764652f8451a71d2f2006b2572fccd9c21f1d64196869bfc291d10f151f0c6\",\"license\":\"MIT\"},\"contracts/protocols/vault/interfaces/iVaultFactory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { IERC721Enumerable } from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\ninterface IFluidVaultFactory is IERC721Enumerable {\\n    /// @notice Minting an NFT Vault for the user\\n    function mint(uint256 vaultId_, address user_) external returns (uint256 tokenId_);\\n\\n    /// @notice returns owner of Vault which is also an NFT\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /// @notice Global auth is auth for all vaults\\n    function isGlobalAuth(address auth_) external view returns (bool);\\n\\n    /// @notice Vault auth is auth for a specific vault\\n    function isVaultAuth(address vault_, address auth_) external view returns (bool);\\n\\n    /// @notice Total vaults deployed.\\n    function totalVaults() external view returns (uint256);\\n\\n    /// @notice Compute vaultAddress\\n    function getVaultAddress(uint256 vaultId) external view returns (address);\\n\\n    /// @notice read uint256 `result_` for a storage `slot_` key\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n}\\n\",\"keccak256\":\"0xc4a0caed89a8670e1ccf159d03fa23bb29f69c579f522bb0e33b1b5cb106c40d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405162001fe338038062001fe383398101604081905261003191610063565b6001600160a01b038116608081905261005d576040516302fdcc4f60e31b815260040160405180910390fd5b50610093565b60006020828403121561007557600080fd5b81516001600160a01b038116811461008c57600080fd5b9392505050565b608051611eef620000f4600039600081816087015281816106090152818161087c01528181610ad301528181610c9f0152818161109e0152818161126e01528181611356015281816114530152818161155101526116450152611eef6000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c8063978f281f1161005b578063978f281f14610106578063b7bb891d14610127578063bd7b630d14610148578063f752d7571461016857600080fd5b80632dd31000146100825780635bbf0e14146100d35780636970693c146100f3575b600080fd5b6100a97f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b6100e66100e1366004611add565b61017b565b6040516100ca9190611b1a565b6100e6610101366004611bbd565b6103bd565b610119610114366004611c0b565b610602565b6040516100ca929190611c70565b61013a610135366004611c94565b610847565b6040519081526020016100ca565b61015b610156366004611cb6565b610876565b6040516100ca9190611cd1565b6100e6610176366004611cb6565b6109f3565b6060815167ffffffffffffffff811115610197576101976119f5565b60405190808252806020026020018201604052801561020957816020015b6101f6604051806080016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b8152602001906001900390816101b55790505b50905060008060005b84518110156103b55761023d85828151811061023057610230611ce4565b6020026020010151610c98565b909350915073ffffffffffffffffffffffffffffffffffffffff83166102d257604051806080016040528086838151811061027a5761027a611ce4565b60200260200101518152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152508482815181106102c2576102c2611ce4565b60200260200101819052506103a5565b6000808473ffffffffffffffffffffffffffffffffffffffff166309f0d8cb6102fa87610d8c565b6040518263ffffffff1660e01b815260040161031891815260200190565b608060405180830381865afa158015610335573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103599190611d13565b9350935050506103858588858151811061037557610375611ce4565b6020026020010151848488610e1f565b86848151811061039757610397611ce4565b602002602001018190525050505b6103ae81611d78565b9050610212565b505050919050565b606073ffffffffffffffffffffffffffffffffffffffff821661040c576040517f7da745a000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b825167ffffffffffffffff811115610426576104266119f5565b60405190808252806020026020018201604052801561049857816020015b610485604051806080016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b8152602001906001900390816104445790505b5090506000808373ffffffffffffffffffffffffffffffffffffffff166309f0d8cb6104c386610d8c565b6040518263ffffffff1660e01b81526004016104e191815260200190565b608060405180830381865afa1580156104fe573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105229190611d13565b93509350505060008060005b87518110156105f75761054c88828151811061023057610230611ce4565b909350915073ffffffffffffffffffffffffffffffffffffffff878116908416146105a3576040517f7da745a000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6105c9878983815181106105b9576105b9611ce4565b6020026020010151878786610e1f565b8682815181106105db576105db611ce4565b6020026020010181905250806105f090611d78565b905061052e565b505050505092915050565b60606000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610672573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106969190611db0565b905060006106a6610bb886611dc9565b905060006106b6610bb883611de0565b9050828111156106cb575060009250816106d0565b600193505b60006106dc8383611df3565b67ffffffffffffffff8111156106f4576106f46119f5565b60405190808252806020026020018201604052801561071d578160200160208202803683370190505b509050600080845b848110156107a1576107368161108c565b925060010173ffffffffffffffffffffffffffffffffffffffff8b1661075b84611099565b73ffffffffffffffffffffffffffffffffffffffff160361079c578284838151811061078957610789611ce4565b6020026020010181815250508160010191505b610725565b508067ffffffffffffffff8111156107bb576107bb6119f5565b6040519080825280602002602001820160405280156107e4578160200160208202803683370190505b50975060005b818110156108395783818151811061080457610804611ce4565b602002602001015189828151811061081e5761081e611ce4565b602090810291909101015261083281611d78565b90506107ea565b505050505050509250929050565b604080516020808201849052818301859052825180830384018152606090920190925280519101205b92915050565b606060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156108e5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109099190611db0565b9050600060d261091885611189565b901c63ffffffff1690508067ffffffffffffffff81111561093b5761093b6119f5565b604051908082528060200260200182016040528015610964578160200160208202803683370190505b50925060008060005b848110156109e95761097e8161108c565b925060010173ffffffffffffffffffffffffffffffffffffffff87166109a384611099565b73ffffffffffffffffffffffffffffffffffffffff16036109e457828683815181106109d1576109d1611ce4565b6020026020010181815250508160010191505b61096d565b5050505050919050565b606073ffffffffffffffffffffffffffffffffffffffff8216610a42576040517f7da745a000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000808373ffffffffffffffffffffffffffffffffffffffff166309f0d8cb610a6a86610d8c565b6040518263ffffffff1660e01b8152600401610a8891815260200190565b608060405180830381865afa158015610aa5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ac99190611d13565b93509350505060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b3c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b609190611db0565b9050600060d2610b6f87611189565b901c63ffffffff1690508067ffffffffffffffff811115610b9257610b926119f5565b604051908082528060200260200182016040528015610c0457816020015b610bf1604051806080016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b815260200190600190039081610bb05790505b50945060008060008060005b86811015610c8a57610c218161108c565b9450600101610c2f85610c98565b909350915073ffffffffffffffffffffffffffffffffffffffff808c1690841603610c8557610c618b868b8b86610e1f565b8a8581518110610c7357610c73611ce4565b60200260200101819052508360010193505b610c10565b505050505050505050919050565b60008060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b5c736e4856003604051602001610cf992919091825260ff16602082015260400190565b604051602081830303815290604052805190602001206040518263ffffffff1660e01b8152600401610d2d91815260200190565b602060405180830381865afa158015610d4a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d6e9190611db0565b9050610d8363ffffffff60c083901c166111df565b94909350915050565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009073ffffffffffffffffffffffffffffffffffffffff83169063b5c736e4906024015b602060405180830381865afa158015610dfb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108709190611db0565b610e60604051806080016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b84815273ffffffffffffffffffffffffffffffffffffffff821660208201526000610e8b87876116e2565b66ffffffffffffff603582901c1660ff602d83901c161b6040840152905060018082161461105d57600081600216600214610ed757610ed2600283901c6207ffff16611e06565b610ee2565b6207ffff600283901c165b905060608360400151610ef78360020b61176a565b610f019190611dc9565b901c60608401526000610f1489836119cc565b9050601583901c62ffffff1660018083161480610f3957508062ffffff600184901c16115b15610ff75760608501516040517f22348cc7000000000000000000000000000000000000000000000000000000008152600481018590526024810183905260448101919091526064810183905273ffffffffffffffffffffffffffffffffffffffff8b16906322348cc79060840160a060405180830381865afa158015610fc4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fe89190611e3e565b50506040880152606087015292505b606085015166ffffffffffffff607586901c1660ff606d87901c161b9081101561102b576060860180518290039052611033565b600060608701525b64e8d4a510008887606001516110499190611dc9565b6110539190611e7e565b6060870152505050505b64e8d4a510008583604001516110739190611dc9565b61107d9190611e7e565b60408301525095945050505050565b6000610870826001611de0565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b5c736e48460036040516020016110f892919091825260ff16602082015260400190565b604051602081830303815290604052805190602001206040518263ffffffff1660e01b815260040161112c91815260200190565b602060405180830381865afa158015611149573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061116d9190611db0565b905061118263ffffffff60c083901c166111df565b9392505050565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526000600482018190529073ffffffffffffffffffffffffffffffffffffffff83169063b5c736e490602401610dde565b60006060826000036111f45750600092915050565b607f83116112dc576040517fd60000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000060601b16602282015260f884901b7fff000000000000000000000000000000000000000000000000000000000000001660368201526037015b60405160208183030381529060405290506116d4565b60ff83116113d8576040517fd70000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000060601b1660228201527f8100000000000000000000000000000000000000000000000000000000000000603682015260f884901b7fff000000000000000000000000000000000000000000000000000000000000001660378201526038016112c6565b61ffff83116114d5576040517fd80000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000060601b1660228201527f820000000000000000000000000000000000000000000000000000000000000060368201527fffff00000000000000000000000000000000000000000000000000000000000060f085901b1660378201526039016112c6565b62ffffff83116115d3576040517fd90000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000060601b1660228201527f830000000000000000000000000000000000000000000000000000000000000060368201527fffffff000000000000000000000000000000000000000000000000000000000060e885901b166037820152603a016112c6565b6040517fda0000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000060601b1660228201527f840000000000000000000000000000000000000000000000000000000000000060368201527fffffffff0000000000000000000000000000000000000000000000000000000060e085901b166037820152603b0160405160208183030381529060405290505b805160209091012092915050565b60008273ffffffffffffffffffffffffffffffffffffffff1663b5c736e461170b600385610847565b6040518263ffffffff1660e01b815260040161172991815260200190565b602060405180830381865afa158015611746573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111829190611db0565b600060ff82901d80831803617fff81111561178457600080fd5b70010000000000000000000000000000000060018216156117b257506fff9dd7de423466c20352b1246ce4856f5b60028216156117d1576fff3bd55f4488ad277531fa1c725a66d00260801c5b60048216156117f0576ffe78410fd6498b73cb96a6917f8532590260801c5b600882161561180f576ffcf2d9987c9be178ad5bfeffaa1232730260801c5b601082161561182e576ff9ef02c4529258b057769680fc6601b30260801c5b602082161561184d576ff402d288133a85a17784a411f7aba0820260801c5b604082161561186c576fe895615b5beb6386553757b0352bda900260801c5b608082161561188b576fd34f17a00ffa00a8309940a15930391a0260801c5b6101008216156118ab576fae6b7961714e20548d88ea5123f9a0ff0260801c5b6102008216156118cb576f76d6461f27082d74e0feed3b388c0ca10260801c5b6104008216156118eb576f372a3bfe0745d8b6b19d985d9a8b85bb0260801c5b61080082161561190b576f0be32cbee48979763cf7247dd7bb539d0260801c5b61100082161561192a576e8d4f70c9ff4924dac37612d1e2921e0260801c5b612000821615611948576d4e009ae5519380809a02ca7aec770260801c5b614000821615611964576b17c45e641b6e95dee056ff100260801c5b600091507f800000000000000000000000000000000000000000000000000000000000000084166119c2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0463ffffffff8116156119c257600191505b60201c0192915050565b60008273ffffffffffffffffffffffffffffffffffffffff1663b5c736e461170b600585610847565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112611a3557600080fd5b8135602067ffffffffffffffff80831115611a5257611a526119f5565b8260051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f83011681018181108482111715611a9557611a956119f5565b604052938452858101830193838101925087851115611ab357600080fd5b83870191505b84821015611ad257813583529183019190830190611ab9565b979650505050505050565b600060208284031215611aef57600080fd5b813567ffffffffffffffff811115611b0657600080fd5b611b1284828501611a24565b949350505050565b602080825282518282018190526000919060409081850190868401855b82811015611b87578151805185528681015173ffffffffffffffffffffffffffffffffffffffff168786015285810151868601526060908101519085015260809093019290850190600101611b37565b5091979650505050505050565b803573ffffffffffffffffffffffffffffffffffffffff81168114611bb857600080fd5b919050565b60008060408385031215611bd057600080fd5b823567ffffffffffffffff811115611be757600080fd5b611bf385828601611a24565b925050611c0260208401611b94565b90509250929050565b60008060408385031215611c1e57600080fd5b611c2783611b94565b946020939093013593505050565b600081518084526020808501945080840160005b83811015611c6557815187529582019590820190600101611c49565b509495945050505050565b604081526000611c836040830185611c35565b905082151560208301529392505050565b60008060408385031215611ca757600080fd5b50508035926020909101359150565b600060208284031215611cc857600080fd5b61118282611b94565b6020815260006111826020830184611c35565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60008060008060808587031215611d2957600080fd5b505082516020840151604085015160609095015191969095509092509050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611da957611da9611d49565b5060010190565b600060208284031215611dc257600080fd5b5051919050565b808202811582820484141761087057610870611d49565b8082018082111561087057610870611d49565b8181038181111561087057610870611d49565b60007f80000000000000000000000000000000000000000000000000000000000000008203611e3757611e37611d49565b5060000390565b600080600080600060a08688031215611e5657600080fd5b5050835160208501516040860151606087015160809097015192989197509594509092509050565b600082611eb4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b50049056fea2646970667358221220c87b63d0cf5e3c82ec81d39c2f427d6ad2226f843a8eaddb105ae3a87983b92464736f6c63430008150033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061007d5760003560e01c8063978f281f1161005b578063978f281f14610106578063b7bb891d14610127578063bd7b630d14610148578063f752d7571461016857600080fd5b80632dd31000146100825780635bbf0e14146100d35780636970693c146100f3575b600080fd5b6100a97f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b6100e66100e1366004611add565b61017b565b6040516100ca9190611b1a565b6100e6610101366004611bbd565b6103bd565b610119610114366004611c0b565b610602565b6040516100ca929190611c70565b61013a610135366004611c94565b610847565b6040519081526020016100ca565b61015b610156366004611cb6565b610876565b6040516100ca9190611cd1565b6100e6610176366004611cb6565b6109f3565b6060815167ffffffffffffffff811115610197576101976119f5565b60405190808252806020026020018201604052801561020957816020015b6101f6604051806080016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b8152602001906001900390816101b55790505b50905060008060005b84518110156103b55761023d85828151811061023057610230611ce4565b6020026020010151610c98565b909350915073ffffffffffffffffffffffffffffffffffffffff83166102d257604051806080016040528086838151811061027a5761027a611ce4565b60200260200101518152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152508482815181106102c2576102c2611ce4565b60200260200101819052506103a5565b6000808473ffffffffffffffffffffffffffffffffffffffff166309f0d8cb6102fa87610d8c565b6040518263ffffffff1660e01b815260040161031891815260200190565b608060405180830381865afa158015610335573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103599190611d13565b9350935050506103858588858151811061037557610375611ce4565b6020026020010151848488610e1f565b86848151811061039757610397611ce4565b602002602001018190525050505b6103ae81611d78565b9050610212565b505050919050565b606073ffffffffffffffffffffffffffffffffffffffff821661040c576040517f7da745a000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b825167ffffffffffffffff811115610426576104266119f5565b60405190808252806020026020018201604052801561049857816020015b610485604051806080016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b8152602001906001900390816104445790505b5090506000808373ffffffffffffffffffffffffffffffffffffffff166309f0d8cb6104c386610d8c565b6040518263ffffffff1660e01b81526004016104e191815260200190565b608060405180830381865afa1580156104fe573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105229190611d13565b93509350505060008060005b87518110156105f75761054c88828151811061023057610230611ce4565b909350915073ffffffffffffffffffffffffffffffffffffffff878116908416146105a3576040517f7da745a000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6105c9878983815181106105b9576105b9611ce4565b6020026020010151878786610e1f565b8682815181106105db576105db611ce4565b6020026020010181905250806105f090611d78565b905061052e565b505050505092915050565b60606000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610672573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106969190611db0565b905060006106a6610bb886611dc9565b905060006106b6610bb883611de0565b9050828111156106cb575060009250816106d0565b600193505b60006106dc8383611df3565b67ffffffffffffffff8111156106f4576106f46119f5565b60405190808252806020026020018201604052801561071d578160200160208202803683370190505b509050600080845b848110156107a1576107368161108c565b925060010173ffffffffffffffffffffffffffffffffffffffff8b1661075b84611099565b73ffffffffffffffffffffffffffffffffffffffff160361079c578284838151811061078957610789611ce4565b6020026020010181815250508160010191505b610725565b508067ffffffffffffffff8111156107bb576107bb6119f5565b6040519080825280602002602001820160405280156107e4578160200160208202803683370190505b50975060005b818110156108395783818151811061080457610804611ce4565b602002602001015189828151811061081e5761081e611ce4565b602090810291909101015261083281611d78565b90506107ea565b505050505050509250929050565b604080516020808201849052818301859052825180830384018152606090920190925280519101205b92915050565b606060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156108e5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109099190611db0565b9050600060d261091885611189565b901c63ffffffff1690508067ffffffffffffffff81111561093b5761093b6119f5565b604051908082528060200260200182016040528015610964578160200160208202803683370190505b50925060008060005b848110156109e95761097e8161108c565b925060010173ffffffffffffffffffffffffffffffffffffffff87166109a384611099565b73ffffffffffffffffffffffffffffffffffffffff16036109e457828683815181106109d1576109d1611ce4565b6020026020010181815250508160010191505b61096d565b5050505050919050565b606073ffffffffffffffffffffffffffffffffffffffff8216610a42576040517f7da745a000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000808373ffffffffffffffffffffffffffffffffffffffff166309f0d8cb610a6a86610d8c565b6040518263ffffffff1660e01b8152600401610a8891815260200190565b608060405180830381865afa158015610aa5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ac99190611d13565b93509350505060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b3c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b609190611db0565b9050600060d2610b6f87611189565b901c63ffffffff1690508067ffffffffffffffff811115610b9257610b926119f5565b604051908082528060200260200182016040528015610c0457816020015b610bf1604051806080016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b815260200190600190039081610bb05790505b50945060008060008060005b86811015610c8a57610c218161108c565b9450600101610c2f85610c98565b909350915073ffffffffffffffffffffffffffffffffffffffff808c1690841603610c8557610c618b868b8b86610e1f565b8a8581518110610c7357610c73611ce4565b60200260200101819052508360010193505b610c10565b505050505050505050919050565b60008060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b5c736e4856003604051602001610cf992919091825260ff16602082015260400190565b604051602081830303815290604052805190602001206040518263ffffffff1660e01b8152600401610d2d91815260200190565b602060405180830381865afa158015610d4a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d6e9190611db0565b9050610d8363ffffffff60c083901c166111df565b94909350915050565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009073ffffffffffffffffffffffffffffffffffffffff83169063b5c736e4906024015b602060405180830381865afa158015610dfb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108709190611db0565b610e60604051806080016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001600081525090565b84815273ffffffffffffffffffffffffffffffffffffffff821660208201526000610e8b87876116e2565b66ffffffffffffff603582901c1660ff602d83901c161b6040840152905060018082161461105d57600081600216600214610ed757610ed2600283901c6207ffff16611e06565b610ee2565b6207ffff600283901c165b905060608360400151610ef78360020b61176a565b610f019190611dc9565b901c60608401526000610f1489836119cc565b9050601583901c62ffffff1660018083161480610f3957508062ffffff600184901c16115b15610ff75760608501516040517f22348cc7000000000000000000000000000000000000000000000000000000008152600481018590526024810183905260448101919091526064810183905273ffffffffffffffffffffffffffffffffffffffff8b16906322348cc79060840160a060405180830381865afa158015610fc4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fe89190611e3e565b50506040880152606087015292505b606085015166ffffffffffffff607586901c1660ff606d87901c161b9081101561102b576060860180518290039052611033565b600060608701525b64e8d4a510008887606001516110499190611dc9565b6110539190611e7e565b6060870152505050505b64e8d4a510008583604001516110739190611dc9565b61107d9190611e7e565b60408301525095945050505050565b6000610870826001611de0565b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b5c736e48460036040516020016110f892919091825260ff16602082015260400190565b604051602081830303815290604052805190602001206040518263ffffffff1660e01b815260040161112c91815260200190565b602060405180830381865afa158015611149573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061116d9190611db0565b905061118263ffffffff60c083901c166111df565b9392505050565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526000600482018190529073ffffffffffffffffffffffffffffffffffffffff83169063b5c736e490602401610dde565b60006060826000036111f45750600092915050565b607f83116112dc576040517fd60000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000060601b16602282015260f884901b7fff000000000000000000000000000000000000000000000000000000000000001660368201526037015b60405160208183030381529060405290506116d4565b60ff83116113d8576040517fd70000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000060601b1660228201527f8100000000000000000000000000000000000000000000000000000000000000603682015260f884901b7fff000000000000000000000000000000000000000000000000000000000000001660378201526038016112c6565b61ffff83116114d5576040517fd80000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000060601b1660228201527f820000000000000000000000000000000000000000000000000000000000000060368201527fffff00000000000000000000000000000000000000000000000000000000000060f085901b1660378201526039016112c6565b62ffffff83116115d3576040517fd90000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000060601b1660228201527f830000000000000000000000000000000000000000000000000000000000000060368201527fffffff000000000000000000000000000000000000000000000000000000000060e885901b166037820152603a016112c6565b6040517fda0000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000060601b1660228201527f840000000000000000000000000000000000000000000000000000000000000060368201527fffffffff0000000000000000000000000000000000000000000000000000000060e085901b166037820152603b0160405160208183030381529060405290505b805160209091012092915050565b60008273ffffffffffffffffffffffffffffffffffffffff1663b5c736e461170b600385610847565b6040518263ffffffff1660e01b815260040161172991815260200190565b602060405180830381865afa158015611746573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111829190611db0565b600060ff82901d80831803617fff81111561178457600080fd5b70010000000000000000000000000000000060018216156117b257506fff9dd7de423466c20352b1246ce4856f5b60028216156117d1576fff3bd55f4488ad277531fa1c725a66d00260801c5b60048216156117f0576ffe78410fd6498b73cb96a6917f8532590260801c5b600882161561180f576ffcf2d9987c9be178ad5bfeffaa1232730260801c5b601082161561182e576ff9ef02c4529258b057769680fc6601b30260801c5b602082161561184d576ff402d288133a85a17784a411f7aba0820260801c5b604082161561186c576fe895615b5beb6386553757b0352bda900260801c5b608082161561188b576fd34f17a00ffa00a8309940a15930391a0260801c5b6101008216156118ab576fae6b7961714e20548d88ea5123f9a0ff0260801c5b6102008216156118cb576f76d6461f27082d74e0feed3b388c0ca10260801c5b6104008216156118eb576f372a3bfe0745d8b6b19d985d9a8b85bb0260801c5b61080082161561190b576f0be32cbee48979763cf7247dd7bb539d0260801c5b61100082161561192a576e8d4f70c9ff4924dac37612d1e2921e0260801c5b612000821615611948576d4e009ae5519380809a02ca7aec770260801c5b614000821615611964576b17c45e641b6e95dee056ff100260801c5b600091507f800000000000000000000000000000000000000000000000000000000000000084166119c2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0463ffffffff8116156119c257600191505b60201c0192915050565b60008273ffffffffffffffffffffffffffffffffffffffff1663b5c736e461170b600585610847565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112611a3557600080fd5b8135602067ffffffffffffffff80831115611a5257611a526119f5565b8260051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f83011681018181108482111715611a9557611a956119f5565b604052938452858101830193838101925087851115611ab357600080fd5b83870191505b84821015611ad257813583529183019190830190611ab9565b979650505050505050565b600060208284031215611aef57600080fd5b813567ffffffffffffffff811115611b0657600080fd5b611b1284828501611a24565b949350505050565b602080825282518282018190526000919060409081850190868401855b82811015611b87578151805185528681015173ffffffffffffffffffffffffffffffffffffffff168786015285810151868601526060908101519085015260809093019290850190600101611b37565b5091979650505050505050565b803573ffffffffffffffffffffffffffffffffffffffff81168114611bb857600080fd5b919050565b60008060408385031215611bd057600080fd5b823567ffffffffffffffff811115611be757600080fd5b611bf385828601611a24565b925050611c0260208401611b94565b90509250929050565b60008060408385031215611c1e57600080fd5b611c2783611b94565b946020939093013593505050565b600081518084526020808501945080840160005b83811015611c6557815187529582019590820190600101611c49565b509495945050505050565b604081526000611c836040830185611c35565b905082151560208301529392505050565b60008060408385031215611ca757600080fd5b50508035926020909101359150565b600060208284031215611cc857600080fd5b61118282611b94565b6020815260006111826020830184611c35565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60008060008060808587031215611d2957600080fd5b505082516020840151604085015160609095015191969095509092509050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611da957611da9611d49565b5060010190565b600060208284031215611dc257600080fd5b5051919050565b808202811582820484141761087057610870611d49565b8082018082111561087057610870611d49565b8181038181111561087057610870611d49565b60007f80000000000000000000000000000000000000000000000000000000000000008203611e3757611e37611d49565b5060000390565b600080600080600060a08688031215611e5657600080fd5b5050835160208501516040860151606087015160809097015192989197509594509092509050565b600082611eb4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b50049056fea2646970667358221220c87b63d0cf5e3c82ec81d39c2f427d6ad2226f843a8eaddb105ae3a87983b92464736f6c63430008150033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "vaultFactory_": "The FluidVaultFactory contract address"
        }
      },
      "getAllVaultNftIds(address)": {
        "params": {
          "vault_": "The address of the vault."
        },
        "returns": {
          "nftIds_": "Array of NFT token IDs belonging to the vault."
        }
      },
      "getAllVaultNftIdsPaged(address,uint256)": {
        "details": "Use this method on chains where retrieving all token IDs at once may run out of gas.      Call this repeatedly with increasing page numbers until hasNextPage is false, then use `getVaultPositionsForNftIds`.",
        "params": {
          "page_": "The current page to fetch (pagination index). start with page 0.",
          "vault_": "The address of the vault."
        },
        "returns": {
          "hasNextPage_": "True if there are more pages to fetch, false if this is the last page.",
          "nftIds_": "Array of NFT token IDs for the specified page."
        }
      },
      "getAllVaultPositions(address)": {
        "params": {
          "vault_": "The address of the vault."
        },
        "returns": {
          "positions_": "Array of UserPosition for each position in the vault."
        }
      },
      "getPositionsForNftIds(uint256[])": {
        "params": {
          "nftIds_": "Array of NFT IDs. Split reading into chunks if this runs out of gas!"
        },
        "returns": {
          "positions_": "Array of UserPosition for each NFT ID."
        }
      },
      "getVaultPositionsForNftIds(uint256[],address)": {
        "params": {
          "nftIds_": "Array of NFT IDs. Split reading into chunks if this runs out of gas!",
          "vault_": "The address of the vault."
        },
        "returns": {
          "positions_": "Array of UserPosition for the NFT IDs."
        }
      }
    },
    "title": "Fluid Vault protocol Positions Resolver for all vault types.",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "FluidVaultPositionsResolver__AddressZero()": [
        {
          "notice": "thrown if an input param address is zero"
        }
      ]
    },
    "kind": "user",
    "methods": {
      "_calculateStorageSlotIntMapping(uint256,int256)": {
        "notice": "Calculating the slot ID for Liquidity contract for single mapping"
      },
      "constructor": {
        "notice": "constructor sets the immutable vault factory address"
      },
      "getAllVaultNftIds(address)": {
        "notice": "Returns all NFT token IDs for the specified vault. Use `getAllVaultNftIdsPaged` if this runs out of gas!"
      },
      "getAllVaultNftIdsPaged(address,uint256)": {
        "notice": "Returns the NFT token IDs for a given vault using a paged approach, reading 3000 nfts per page."
      },
      "getAllVaultPositions(address)": {
        "notice": "Gets all positions for the given vault. Use `getAllVaultNftIds` first if this runs out of gas!"
      },
      "getPositionsForNftIds(uint256[])": {
        "notice": "Gets user positions for a set of NFT IDs."
      },
      "getVaultPositionsForNftIds(uint256[],address)": {
        "notice": "Gets user positions for NFT IDs assumed to belong to a specific vault."
      }
    },
    "notice": "This contract resolves positions for Fluid Vaults, providing functionality to retrieve NFT IDs and positions for a given vault.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}