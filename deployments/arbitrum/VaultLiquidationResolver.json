{
  "address": "0x27F0Cb52138e97A66295Eeed523c9698E1125Fa9",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IFluidVaultResolver",
          "name": "vaultResolver_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "FluidVaultLiquidationsResolver__AddressZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FluidVaultLiquidationsResolver__InvalidParams",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "VAULT_RESOLVER",
      "outputs": [
        {
          "internalType": "contract IFluidVaultResolver",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenIn_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenOut_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "outAmt_",
          "type": "uint256"
        }
      ],
      "name": "approxOutput",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "inAmt_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "approxOutAmt_",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenIn_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenOut_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "inAmt_",
          "type": "uint256"
        }
      ],
      "name": "exactInput",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "actualInAmt_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "outAmt_",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "targetApproxOutAmt_",
          "type": "uint256"
        }
      ],
      "name": "filterToApproxOutAmt",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "filteredSwaps_",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "actualInAmt_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "approxOutAmt_",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "targetInAmt_",
          "type": "uint256"
        }
      ],
      "name": "filterToTargetInAmt",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "filteredSwaps_",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "actualInAmt_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "approxOutAmt_",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllSwapPaths",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "protocol",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            }
          ],
          "internalType": "struct Structs.SwapPath[]",
          "name": "paths_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllVaultsSwap",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllVaultsSwapData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "inAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmt",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "withAbsorb",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "ratio",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.SwapData[]",
          "name": "withoutAbsorb_",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "inAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmt",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "withAbsorb",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "ratio",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.SwapData[]",
          "name": "withAbsorb_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllVaultsSwapRaw",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "tokensIn_",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "tokensOut_",
          "type": "address[]"
        }
      ],
      "name": "getAnySwapPaths",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "protocol",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            }
          ],
          "internalType": "struct Structs.SwapPath[]",
          "name": "paths_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "tokensIn_",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "tokensOut_",
          "type": "address[]"
        }
      ],
      "name": "getAnySwaps",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "tokensIn_",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "tokensOut_",
          "type": "address[]"
        }
      ],
      "name": "getAnySwapsRaw",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "protocol_",
          "type": "address"
        }
      ],
      "name": "getSwapForProtocol",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap",
          "name": "swap_",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenIn_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenOut_",
          "type": "address"
        }
      ],
      "name": "getSwapPaths",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "protocol",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            }
          ],
          "internalType": "struct Structs.SwapPath[]",
          "name": "paths_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap",
          "name": "swap_",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "receiver_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "slippage_",
          "type": "uint256"
        }
      ],
      "name": "getSwapTx",
      "outputs": [
        {
          "internalType": "address",
          "name": "target_",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "calldata_",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        },
        {
          "internalType": "address",
          "name": "receiver_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "slippage_",
          "type": "uint256"
        }
      ],
      "name": "getSwapTxs",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "targets_",
          "type": "address[]"
        },
        {
          "internalType": "bytes[]",
          "name": "calldatas_",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenIn_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenOut_",
          "type": "address"
        }
      ],
      "name": "getSwaps",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "protocol",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            }
          ],
          "internalType": "struct Structs.SwapPath[]",
          "name": "paths_",
          "type": "tuple[]"
        }
      ],
      "name": "getSwapsForPaths",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "protocol",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            }
          ],
          "internalType": "struct Structs.SwapPath[]",
          "name": "paths_",
          "type": "tuple[]"
        }
      ],
      "name": "getSwapsForPathsRaw",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenIn_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenOut_",
          "type": "address"
        }
      ],
      "name": "getSwapsRaw",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getVaultSwapData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "inAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmt",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "withAbsorb",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "ratio",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.SwapData",
          "name": "withoutAbsorb_",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "inAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmt",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "withAbsorb",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "ratio",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.SwapData",
          "name": "withAbsorb_",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "vaults_",
          "type": "address[]"
        }
      ],
      "name": "getVaultsSwap",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "vaults_",
          "type": "address[]"
        }
      ],
      "name": "getVaultsSwapData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "inAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmt",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "withAbsorb",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "ratio",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.SwapData[]",
          "name": "withoutAbsorb_",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "inAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmt",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "withAbsorb",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "ratio",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.SwapData[]",
          "name": "withAbsorb_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "vaults_",
          "type": "address[]"
        }
      ],
      "name": "getVaultsSwapRaw",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "protocol",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenIn",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "tokenOut",
                  "type": "address"
                }
              ],
              "internalType": "struct Structs.SwapPath",
              "name": "path",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "inAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outAmt",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "withAbsorb",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "ratio",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.SwapData",
              "name": "data",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.Swap[]",
          "name": "swaps_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x1c3aa16e87fcc13ee7a24ffed29bfa5529f99fdc23a15ca7054820f0b58370c3",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x0Ed35B1609Ec45c7079E80d11149a52717e4859A",
    "contractAddress": null,
    "transactionIndex": 1,
    "gasUsed": "4843424",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5d93cebfc347ab45792e9a90f008421e394658ee0390261cce31d570d4297b2a",
    "transactionHash": "0x1c3aa16e87fcc13ee7a24ffed29bfa5529f99fdc23a15ca7054820f0b58370c3",
    "logs": [],
    "blockNumber": 234986332,
    "cumulativeGasUsed": "4843424",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x77648D39be25a1422467060e11E5b979463bEA3d"
  ],
  "numDeployments": 1,
  "solcInputHash": "6e9273a846cc3b4989a896bbeef201ae",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IFluidVaultResolver\",\"name\":\"vaultResolver_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FluidVaultLiquidationsResolver__AddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FluidVaultLiquidationsResolver__InvalidParams\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VAULT_RESOLVER\",\"outputs\":[{\"internalType\":\"contract IFluidVaultResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outAmt_\",\"type\":\"uint256\"}],\"name\":\"approxOutput\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"inAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approxOutAmt_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmt_\",\"type\":\"uint256\"}],\"name\":\"exactInput\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"actualInAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"targetApproxOutAmt_\",\"type\":\"uint256\"}],\"name\":\"filterToApproxOutAmt\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"filteredSwaps_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"actualInAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approxOutAmt_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"targetInAmt_\",\"type\":\"uint256\"}],\"name\":\"filterToTargetInAmt\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"filteredSwaps_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"actualInAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approxOutAmt_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllSwapPaths\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath[]\",\"name\":\"paths_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllVaultsSwap\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllVaultsSwapData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData[]\",\"name\":\"withoutAbsorb_\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData[]\",\"name\":\"withAbsorb_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllVaultsSwapRaw\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensIn_\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokensOut_\",\"type\":\"address[]\"}],\"name\":\"getAnySwapPaths\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath[]\",\"name\":\"paths_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensIn_\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokensOut_\",\"type\":\"address[]\"}],\"name\":\"getAnySwaps\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensIn_\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokensOut_\",\"type\":\"address[]\"}],\"name\":\"getAnySwapsRaw\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol_\",\"type\":\"address\"}],\"name\":\"getSwapForProtocol\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap\",\"name\":\"swap_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut_\",\"type\":\"address\"}],\"name\":\"getSwapPaths\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath[]\",\"name\":\"paths_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap\",\"name\":\"swap_\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slippage_\",\"type\":\"uint256\"}],\"name\":\"getSwapTx\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"target_\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"calldata_\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slippage_\",\"type\":\"uint256\"}],\"name\":\"getSwapTxs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"targets_\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas_\",\"type\":\"bytes[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut_\",\"type\":\"address\"}],\"name\":\"getSwaps\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath[]\",\"name\":\"paths_\",\"type\":\"tuple[]\"}],\"name\":\"getSwapsForPaths\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath[]\",\"name\":\"paths_\",\"type\":\"tuple[]\"}],\"name\":\"getSwapsForPathsRaw\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut_\",\"type\":\"address\"}],\"name\":\"getSwapsRaw\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getVaultSwapData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"withoutAbsorb_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"withAbsorb_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaults_\",\"type\":\"address[]\"}],\"name\":\"getVaultsSwap\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaults_\",\"type\":\"address[]\"}],\"name\":\"getVaultsSwapData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData[]\",\"name\":\"withoutAbsorb_\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData[]\",\"name\":\"withAbsorb_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaults_\",\"type\":\"address[]\"}],\"name\":\"getVaultsSwapRaw\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"internalType\":\"struct Structs.SwapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withAbsorb\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.SwapData\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.Swap[]\",\"name\":\"swaps_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Note that on the same protocol, if \\\"withAbsorb = true\\\" is executed, this also consumes the swap         that would be on the same protocol with \\\"withAbsorb = false\\\". So the total available swap amount         at a protocol if both a swap with and without absorb is available is not `with inAmt + without inAmt`         but rather `with inAmt`.         Sometimes with absorb can provide better swaps, sometimes without absorb can provide better swaps.         But available liquidity for \\\"withAbsorb\\\" amounts will always be >= without absorb amounts.The \\\"Raw\\\" methods return both the with and without absorb swaps for the same Fluid Vault, the non-\\\"Raw\\\"         methods automatically filter by the better ratio swap. For same cases a better optimization of ratios         is possible with custom logic based on the \\\"Raw\\\" methods, see details in comments.for native token, send 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE.returned swaps Struct can be fed into `getSwapTx` to prepare the tx that executes the swaps.non-view methods in this contract are expected to be called with callStatic,         although they would anyway not do any actual state changes.\",\"kind\":\"dev\",\"methods\":{\"approxOutput(address,address,uint256)\":{\"details\":\"The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better but the target swap amount is more than the available without absorb liquidity. For this currently the available withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity. The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing amount up to the target amount with the worse ratio with absorb liquidity.\",\"params\":{\"outAmt_\":\"exact output token amount that should be swapped to from input token\",\"tokenIn_\":\"input token\",\"tokenOut_\":\"output token\"},\"returns\":{\"approxOutAmt_\":\"approximate output token amount. Can be less than `outAmt_` if all available swaps can not cover                       the target amount.\",\"inAmt_\":\"input token amount needed to receive `actualOutAmt_`\",\"swaps_\":\"swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\"}},\"exactInput(address,address,uint256)\":{\"details\":\"The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better but the target swap amount is more than the available without absorb liquidity. For this, currently the available withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity. The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing amount up to the target amount with the worse ratio with absorb liquidity.\",\"params\":{\"inAmt_\":\"exact input token amount that should be swapped to output token\",\"tokenIn_\":\"input token\",\"tokenOut_\":\"output token\"},\"returns\":{\"actualInAmt_\":\"actual input token amount. Can be less than inAmt_ if all available swaps can not cover                      the target amount.\",\"outAmt_\":\"output token amount received for `actualInAmt_`\",\"swaps_\":\"swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\"}},\"filterToApproxOutAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)\":{\"returns\":{\"actualInAmt_\":\"actual input amount.\",\"approxOutAmt_\":\"APPROXIMATE actual output amount. Can be less than targetOutAmt_ if all available swaps                      can not cover the target amount.\",\"filteredSwaps_\":\"swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\"}},\"filterToTargetInAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)\":{\"returns\":{\"actualInAmt_\":\"actual input amount. Can be less than targetInAmt_ if all available swaps can not cover                      the target amount.\",\"approxOutAmt_\":\"actual estimated output amount.\",\"filteredSwaps_\":\"swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\"}},\"getSwapTx(((address,address,address),(uint256,uint256,bool,uint256)),address,uint256)\":{\"params\":{\"receiver_\":\"receiver address that the output token is sent to\",\"slippage_\":\"maximum allowed slippage for the expected output token amount. Reverts iIf received token out                  amount is lower than this. in 1e4 percentage, e.g. 1% = 10000, 0.3% = 3000, 0.01% = 100, 0.0001% = 1.\",\"swap_\":\"Swap struct as returned by other methods\"},\"returns\":{\"calldata_\":\"the calldata that can be used to trigger the liquidation call, resulting in the desired swap.\",\"target_\":\"target address where `calldata_` must be executed\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"FluidVaultLiquidationsResolver__AddressZero()\":[{\"notice\":\"thrown if an input param address is zero\"}],\"FluidVaultLiquidationsResolver__InvalidParams()\":[{\"notice\":\"thrown if an invalid param is given to a method\"}]},\"kind\":\"user\",\"methods\":{\"approxOutput(address,address,uint256)\":{\"notice\":\"finds all swaps from `tokenIn_` to `tokenOut_` for an APPROXIMATE output amount `outAmt_`.         filters the available swaps and sorts them by ratio, so the returned swaps are the best available         swaps to reach the target `outAmt_`.         If the full available amount is less than the target `outAmt_`, the available amount is returned as `actualOutAmt_`.         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to         approximately estimate the required input amounts to reach a certain output amount. This         will change until execution and should be controlled with a maximum slippage.         Recommended to use exact input methods instead.\"},\"constructor\":{\"notice\":\"constructor sets the immutable vault resolver address\"},\"exactInput(address,address,uint256)\":{\"notice\":\"finds all swaps from `tokenIn_` to `tokenOut_` for an exact input amount `inAmt_`.         filters the available swaps and sorts them by ratio, so the returned swaps are the best available         swaps to reach the target `inAmt_`.         If the full available amount is less than the target `inAmt_`, the available amount is returned as `actualInAmt_`.\"},\"filterToApproxOutAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)\":{\"notice\":\"filters the `swaps_` to the point where APPROXIMATELY `targetOutAmt_` is reached.         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to         approximately estimate the required input amounts to reach a certain output amount. This         will change until execution and should be controlled with a maximum slippage.         Recommended to use exact input methods instead.         This is best used in combination with the \\\"Raw\\\" methods, as the `targetInAmt_` allows for more optimized         filtering than otherwise done with the non-\\\"Raw\\\" methods.\"},\"filterToTargetInAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)\":{\"notice\":\"filters the `swaps_` to the point where `targetInAmt_` is reached.         This is best used in combination with the \\\"Raw\\\" methods, as the `targetInAmt_` allows for more optimized         filtering than otherwise done with the non-\\\"Raw\\\" methods.\"},\"getAllSwapPaths()\":{\"notice\":\"returns all available token swap paths\"},\"getAllVaultsSwap()\":{\"notice\":\"returns all available `swaps_` for all Fluid vaults. Only returns non-zero swaps.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio.\"},\"getAllVaultsSwapData()\":{\"notice\":\"returns the swap data for with and without absorb for all Fluid vaults.\"},\"getAllVaultsSwapRaw()\":{\"notice\":\"returns all available `swaps_` for all Fluid vaults raw. Only returns non-zero swaps.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\"},\"getAnySwapPaths(address[],address[])\":{\"notice\":\"returns all available swap paths for any `tokensIn_` to any `tokensOut_`.\"},\"getAnySwaps(address[],address[])\":{\"notice\":\"finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.         Token pairs that are not available or where available swap amounts are zero         will not be present in the returned `swaps_` array.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio.\"},\"getAnySwapsRaw(address[],address[])\":{\"notice\":\"finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.         Token pairs that are not available or where available swap amounts are zero         will not be present in the returned `swaps_` array.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\"},\"getSwapForProtocol(address)\":{\"notice\":\"returns the available swap amounts at a certain `protocol_`. Only returns non-zero swaps.         For vault protocol considering both a swap that uses liquidation with absorb and without absorb.\"},\"getSwapPaths(address,address)\":{\"notice\":\"returns all swap paths for a certain `tokenIn_` swapped to a `tokenOut_`.         returns empty array if no swap path is available for a given pair.\"},\"getSwapTx(((address,address,address),(uint256,uint256,bool,uint256)),address,uint256)\":{\"notice\":\"returns the calldata to execute a swap as returned by the other methods in this contract.         `swap_.data.inAmt` must come from msg.sender, `swap_.data.outAmt` goes to `receiver_`. If the input token         is the native token, msg.value must be sent along when triggering the actual call with the returned calldata         which should be `swap_.data.inAmt`.\"},\"getSwapTxs(((address,address,address),(uint256,uint256,bool,uint256))[],address,uint256)\":{\"notice\":\"returns the same data as `getSwapTx` for an array of input `swaps_` at once.\"},\"getSwaps(address,address)\":{\"notice\":\"finds all available `swaps_` for `tokenIn_` to `tokenOut_`.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio.\"},\"getSwapsForPaths((address,address,address)[])\":{\"notice\":\"returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio.\"},\"getSwapsForPathsRaw((address,address,address)[])\":{\"notice\":\"returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\"},\"getSwapsRaw(address,address)\":{\"notice\":\"finds all available `swaps_` for `tokenIn_` to `tokenOut_`.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\"},\"getVaultSwapData(address)\":{\"notice\":\"returns the swap data for with and without absorb for a Fluid `vault_`.\"},\"getVaultsSwap(address[])\":{\"notice\":\"returns all available `swaps_` for multiple Fluid `vaults_`. Only returns non-zero swaps.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio.\"},\"getVaultsSwapData(address[])\":{\"notice\":\"returns the swap data for with and without absorb for multiple Fluid `vaults_`.\"},\"getVaultsSwapRaw(address[])\":{\"notice\":\"returns all available `swaps_` for multiple Fluid `vaults_` raw. Only returns non-zero swaps.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\"}},\"notice\":\"Resolver contract that helps in finding available token swaps available in Fluid.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/periphery/resolvers/vaultLiquidation/main.sol\":\"FluidVaultLiquidationResolver\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[]},\"sources\":{\"contracts/libraries/fluidProtocolTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ninterface IFluidProtocol {\\n    function TYPE() external view returns (uint256);\\n}\\n\\n/// @notice implements helper methods to filter Fluid protocols by a certain type\\nlibrary FluidProtocolTypes {\\n    uint256 internal constant VAULT_T1_TYPE = 10000; // VaultT1 borrow protocol type vaults\\n    uint256 internal constant VAULT_T2_TYPE = 20000; // DEX protocol type vaults\\n\\n    /// @dev filters input `addresses_` by protocol `type_`. Input addresses must be actual Fluid protocols, otherwise\\n    ///      they would be wrongly assumed to be VaultT1 even if they are not Fluid VaultT1 smart contracts.\\n    ///      `type_` must be a listed constant type of this library.\\n    ///      Example usage is to filter all vault addresses at the Vault factory by a certain type, e.g. to not include\\n    ///      DEX protocol type vaults.\\n    function filterBy(address[] memory addresses_, uint256 type_) internal view returns (address[] memory filtered_) {\\n        uint256 curType_;\\n        uint256 filteredProtocols_ = addresses_.length;\\n        for (uint256 i; i < addresses_.length; ) {\\n            try IFluidProtocol(addresses_[i]).TYPE() returns (uint256 protocolType_) {\\n                curType_ = protocolType_;\\n            } catch {\\n                curType_ = VAULT_T1_TYPE;\\n            }\\n\\n            if (curType_ != type_) {\\n                addresses_[i] = address(0);\\n                --filteredProtocols_;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        filtered_ = new address[](filteredProtocols_);\\n        uint256 index_;\\n        unchecked {\\n            for (uint256 i; i < addresses_.length; ) {\\n                if (addresses_[i] != address(0)) {\\n                    filtered_[index_] = addresses_[i];\\n                    ++index_;\\n                }\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0dde4bd20b0abaa94a920e3de45e259179ee79d6b3c30e8c102068e36b5d23d9\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/adminModule/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Structs {\\n    struct AddressBool {\\n        address addr;\\n        bool value;\\n    }\\n\\n    struct AddressUint256 {\\n        address addr;\\n        uint256 value;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 1\\n    struct RateDataV1Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\\n        uint256 kink;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink;\\n        ///\\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 2\\n    struct RateDataV2Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\\n        uint256 kink1;\\n        ///\\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\\n        uint256 kink2;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink1;\\n        ///\\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\\n        uint256 rateAtUtilizationKink2;\\n        ///\\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set token config\\n    struct TokenConfig {\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 fee;\\n        ///\\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 threshold;\\n        ///\\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\\n        uint256 maxUtilization;\\n    }\\n\\n    /// @notice struct to set user supply & withdrawal config\\n    struct UserSupplyConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration withdrawal limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseWithdrawalLimit;\\n    }\\n\\n    /// @notice struct to set user borrow & payback config\\n    struct UserBorrowConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which debt limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration debt limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseDebtCeiling;\\n        ///\\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 maxDebtCeiling;\\n    }\\n}\\n\",\"keccak256\":\"0x10353c70015f27b880125cefab806dbed24a4458f187da66964f3ef60488f757\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/liquidity/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Structs as AdminModuleStructs } from \\\"../../../liquidity/adminModule/structs.sol\\\";\\n\\nabstract contract Structs {\\n    struct RateData {\\n        uint256 version;\\n        AdminModuleStructs.RateDataV1Params rateDataV1;\\n        AdminModuleStructs.RateDataV2Params rateDataV2;\\n    }\\n\\n    struct OverallTokenData {\\n        uint256 borrowRate;\\n        uint256 supplyRate;\\n        uint256 fee; // revenue fee\\n        uint256 lastStoredUtilization;\\n        uint256 storageUpdateThreshold;\\n        uint256 lastUpdateTimestamp;\\n        uint256 supplyExchangePrice;\\n        uint256 borrowExchangePrice;\\n        uint256 supplyRawInterest;\\n        uint256 supplyInterestFree;\\n        uint256 borrowRawInterest;\\n        uint256 borrowInterestFree;\\n        uint256 totalSupply;\\n        uint256 totalBorrow;\\n        uint256 revenue;\\n        uint256 maxUtilization; // maximum allowed utilization\\n        RateData rateData;\\n    }\\n\\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\\n    struct UserSupplyData {\\n        bool modeWithInterest; // true if mode = with interest, false = without interest\\n        uint256 supply; // user supply amount\\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\\n        uint256 withdrawalLimit;\\n        uint256 lastUpdateTimestamp;\\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\\n        uint256 baseWithdrawalLimit;\\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\\n        uint256 withdrawableUntilLimit;\\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\\n    }\\n\\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\\n    struct UserBorrowData {\\n        bool modeWithInterest; // true if mode = with interest, false = without interest\\n        uint256 borrow; // user borrow amount\\n        uint256 borrowLimit;\\n        uint256 lastUpdateTimestamp;\\n        uint256 expandPercent;\\n        uint256 expandDuration;\\n        uint256 baseBorrowLimit;\\n        uint256 maxBorrowLimit;\\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\\n    }\\n}\\n\",\"keccak256\":\"0xf8a59b6c7963d0bd43be07db0c594e278f97e6dfa498dee8436e3707dd9f574e\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vault/iVaultResolver.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { Structs } from \\\"./structs.sol\\\";\\n\\ninterface IFluidVaultResolver {\\n    function vaultByNftId(uint nftId_) external view returns (address vault_);\\n\\n    function positionByNftId(\\n        uint nftId_\\n    ) external view returns (Structs.UserPosition memory userPosition_, Structs.VaultEntireData memory vaultData_);\\n\\n    function getVaultVariablesRaw(address vault_) external view returns (uint);\\n\\n    function getVaultVariables2Raw(address vault_) external view returns (uint);\\n\\n    function getTickHasDebtRaw(address vault_, int key_) external view returns (uint);\\n\\n    function getTickDataRaw(address vault_, int tick_) external view returns (uint);\\n\\n    function getBranchDataRaw(address vault_, uint branch_) external view returns (uint);\\n\\n    function getPositionDataRaw(address vault_, uint positionId_) external view returns (uint);\\n\\n    function getAllVaultsAddresses() external view returns (address[] memory vaults_);\\n\\n    function getVaultLiquidation(\\n        address vault_,\\n        uint tokenInAmt_\\n    ) external returns (Structs.LiquidationStruct memory liquidationData_);\\n\\n    function getVaultEntireData(address vault_) external view returns (Structs.VaultEntireData memory vaultData_);\\n}\\n\",\"keccak256\":\"0x8db2ba8c10b3f2a624ad2924ec5b59dbb805b42357eb98e9df6835963fff0634\",\"license\":\"MIT\"},\"contracts/periphery/resolvers/vault/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidVaultT1 } from \\\"../../../protocols/vault/interfaces/iVaultT1.sol\\\";\\nimport { Structs as FluidLiquidityResolverStructs } from \\\"../liquidity/structs.sol\\\";\\n\\ncontract Structs {\\n    struct Configs {\\n        uint16 supplyRateMagnifier;\\n        uint16 borrowRateMagnifier;\\n        uint16 collateralFactor;\\n        uint16 liquidationThreshold;\\n        uint16 liquidationMaxLimit;\\n        uint16 withdrawalGap;\\n        uint16 liquidationPenalty;\\n        uint16 borrowFee;\\n        address oracle;\\n        uint oraclePriceOperate;\\n        uint oraclePriceLiquidate;\\n        address rebalancer;\\n    }\\n\\n    struct ExchangePricesAndRates {\\n        uint lastStoredLiquiditySupplyExchangePrice;\\n        uint lastStoredLiquidityBorrowExchangePrice;\\n        uint lastStoredVaultSupplyExchangePrice;\\n        uint lastStoredVaultBorrowExchangePrice;\\n        uint liquiditySupplyExchangePrice;\\n        uint liquidityBorrowExchangePrice;\\n        uint vaultSupplyExchangePrice;\\n        uint vaultBorrowExchangePrice;\\n        uint supplyRateVault;\\n        uint borrowRateVault;\\n        uint supplyRateLiquidity;\\n        uint borrowRateLiquidity;\\n        uint rewardsRate; // rewards rate in percent 1e2 precision (1% = 100, 100% = 10000)\\n    }\\n\\n    struct TotalSupplyAndBorrow {\\n        uint totalSupplyVault;\\n        uint totalBorrowVault;\\n        uint totalSupplyLiquidity;\\n        uint totalBorrowLiquidity;\\n        uint absorbedSupply;\\n        uint absorbedBorrow;\\n    }\\n\\n    struct LimitsAndAvailability {\\n        uint withdrawLimit;\\n        uint withdrawableUntilLimit;\\n        uint withdrawable;\\n        uint borrowLimit;\\n        uint borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\\n        uint borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\\n        uint borrowLimitUtilization; // borrow limit for `maxUtilization` config at Liquidity\\n        uint minimumBorrowing;\\n    }\\n\\n    struct CurrentBranchState {\\n        uint status; // if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\\n        int minimaTick;\\n        uint debtFactor;\\n        uint partials;\\n        uint debtLiquidity;\\n        uint baseBranchId;\\n        int baseBranchMinima;\\n    }\\n\\n    struct VaultState {\\n        uint totalPositions;\\n        int topTick;\\n        uint currentBranch;\\n        uint totalBranch;\\n        uint totalBorrow;\\n        uint totalSupply;\\n        CurrentBranchState currentBranchState;\\n    }\\n\\n    struct VaultEntireData {\\n        address vault;\\n        IFluidVaultT1.ConstantViews constantVariables;\\n        Configs configs;\\n        ExchangePricesAndRates exchangePricesAndRates;\\n        TotalSupplyAndBorrow totalSupplyAndBorrow;\\n        LimitsAndAvailability limitsAndAvailability;\\n        VaultState vaultState;\\n        // liquidity related data such as supply amount, limits, expansion etc.\\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyData;\\n        // liquidity related data such as borrow amount, limits, expansion etc.\\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowData;\\n    }\\n\\n    struct UserPosition {\\n        uint nftId;\\n        address owner;\\n        bool isLiquidated;\\n        bool isSupplyPosition; // if true that means borrowing is 0\\n        int tick;\\n        uint tickId;\\n        uint beforeSupply;\\n        uint beforeBorrow;\\n        uint beforeDustBorrow;\\n        uint supply;\\n        uint borrow;\\n        uint dustBorrow;\\n    }\\n\\n    /// @dev liquidation related data\\n    /// @param vault address of vault\\n    /// @param tokenIn_ address of token in\\n    /// @param tokenOut_ address of token out\\n    /// @param tokenInAmtOne_ (without absorb liquidity) minimum of available liquidation & tokenInAmt_\\n    /// @param tokenOutAmtOne_ (without absorb liquidity) expected token out, collateral to withdraw\\n    /// @param tokenInAmtTwo_ (absorb liquidity included) minimum of available liquidation & tokenInAmt_. In most cases it'll be same as tokenInAmtOne_ but sometimes can be bigger.\\n    /// @param tokenOutAmtTwo_ (absorb liquidity included) expected token out, collateral to withdraw. In most cases it'll be same as tokenOutAmtOne_ but sometimes can be bigger.\\n    /// @dev Liquidity in Two will always be >= One. Sometimes One can provide better swaps, sometimes Two can provide better swaps. But available in Two will always be >= One\\n    struct LiquidationStruct {\\n        address vault;\\n        address tokenIn;\\n        address tokenOut;\\n        uint tokenInAmtOne;\\n        uint tokenOutAmtOne;\\n        uint tokenInAmtTwo;\\n        uint tokenOutAmtTwo;\\n    }\\n\\n    struct AbsorbStruct {\\n        address vault;\\n        bool absorbAvailable;\\n    }\\n}\\n\",\"keccak256\":\"0x7bfd2c661ed85a4bce5b66b6261254f28bb0eb975847ba1eda8b40d0a46e7584\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vaultLiquidation/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Variables } from \\\"./variables.sol\\\";\\nimport { Structs } from \\\"./structs.sol\\\";\\nimport { FluidProtocolTypes } from \\\"../../../libraries/fluidProtocolTypes.sol\\\";\\nimport { Structs as VaultResolverStructs } from \\\"../vault/structs.sol\\\";\\nimport { IFluidVaultResolver } from \\\"../vault/iVaultResolver.sol\\\";\\nimport { IFluidVaultT1 } from \\\"../../../protocols/vault/interfaces/iVaultT1.sol\\\";\\n\\n/// @notice Resolver contract that helps in finding available token swaps available in Fluid.\\n/// @dev    Note that on the same protocol, if \\\"withAbsorb = true\\\" is executed, this also consumes the swap\\n///         that would be on the same protocol with \\\"withAbsorb = false\\\". So the total available swap amount\\n///         at a protocol if both a swap with and without absorb is available is not `with inAmt + without inAmt`\\n///         but rather `with inAmt`.\\n///         Sometimes with absorb can provide better swaps, sometimes without absorb can provide better swaps.\\n///         But available liquidity for \\\"withAbsorb\\\" amounts will always be >= without absorb amounts.\\n/// @dev    The \\\"Raw\\\" methods return both the with and without absorb swaps for the same Fluid Vault, the non-\\\"Raw\\\"\\n///         methods automatically filter by the better ratio swap. For same cases a better optimization of ratios\\n///         is possible with custom logic based on the \\\"Raw\\\" methods, see details in comments.\\n/// @dev    for native token, send 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE.\\n/// @dev    returned swaps Struct can be fed into `getSwapTx` to prepare the tx that executes the swaps.\\n/// @dev    non-view methods in this contract are expected to be called with callStatic,\\n///         although they would anyway not do any actual state changes.\\ncontract FluidVaultLiquidationResolver is Variables, Structs {\\n    /// @notice thrown if an input param address is zero\\n    error FluidVaultLiquidationsResolver__AddressZero();\\n    /// @notice thrown if an invalid param is given to a method\\n    error FluidVaultLiquidationsResolver__InvalidParams();\\n\\n    /// @notice constructor sets the immutable vault resolver address\\n    constructor(IFluidVaultResolver vaultResolver_) Variables(vaultResolver_) {\\n        if (address(vaultResolver_) == address(0)) {\\n            revert FluidVaultLiquidationsResolver__AddressZero();\\n        }\\n    }\\n\\n    /// @notice returns all available token swap paths\\n    function getAllSwapPaths() public view returns (SwapPath[] memory paths_) {\\n        address[] memory vaultAddresses_ = _getVaultT1s();\\n        paths_ = new SwapPath[](vaultAddresses_.length);\\n\\n        address borrowToken_;\\n        address supplyToken_;\\n        for (uint256 i; i < vaultAddresses_.length; ++i) {\\n            (borrowToken_, supplyToken_) = _getVaultTokens(vaultAddresses_[i]);\\n            paths_[i] = SwapPath({ protocol: vaultAddresses_[i], tokenIn: borrowToken_, tokenOut: supplyToken_ });\\n        }\\n    }\\n\\n    /// @notice returns all swap paths for a certain `tokenIn_` swapped to a `tokenOut_`.\\n    ///         returns empty array if no swap path is available for a given pair.\\n    function getSwapPaths(address tokenIn_, address tokenOut_) public view returns (SwapPath[] memory paths_) {\\n        address[] memory vaultAddresses_ = _getVaultT1s();\\n\\n        uint256 foundVaultsCount_;\\n        address[] memory foundVaults_ = new address[](vaultAddresses_.length);\\n\\n        address borrowToken_;\\n        address supplyToken_;\\n        for (uint256 i; i < vaultAddresses_.length; ++i) {\\n            (borrowToken_, supplyToken_) = _getVaultTokens(vaultAddresses_[i]);\\n\\n            if (borrowToken_ == tokenIn_ && supplyToken_ == tokenOut_) {\\n                foundVaults_[foundVaultsCount_] = vaultAddresses_[i];\\n                ++foundVaultsCount_;\\n            }\\n        }\\n\\n        paths_ = new SwapPath[](foundVaultsCount_);\\n        for (uint256 i; i < foundVaultsCount_; ++i) {\\n            paths_[i] = SwapPath({ protocol: foundVaults_[i], tokenIn: tokenIn_, tokenOut: tokenOut_ });\\n        }\\n    }\\n\\n    /// @notice returns all available swap paths for any `tokensIn_` to any `tokensOut_`.\\n    function getAnySwapPaths(\\n        address[] calldata tokensIn_,\\n        address[] calldata tokensOut_\\n    ) public view returns (SwapPath[] memory paths_) {\\n        SwapPath[] memory maxPaths_ = new SwapPath[](tokensIn_.length * tokensOut_.length);\\n\\n        address[] memory vaultAddresses_ = _getVaultT1s();\\n\\n        uint256 matches_;\\n\\n        address borrowToken_;\\n        address supplyToken_;\\n        unchecked {\\n            for (uint256 vi; vi < vaultAddresses_.length; ++vi) {\\n                (borrowToken_, supplyToken_) = _getVaultTokens(vaultAddresses_[vi]);\\n\\n                // for each vault, iterate over all possible input params token combinations\\n                for (uint256 i; i < tokensIn_.length; ++i) {\\n                    for (uint256 j; j < tokensOut_.length; ++j) {\\n                        if (borrowToken_ == tokensIn_[i] && supplyToken_ == tokensOut_[j]) {\\n                            maxPaths_[matches_] = SwapPath({\\n                                protocol: vaultAddresses_[vi],\\n                                tokenIn: borrowToken_,\\n                                tokenOut: supplyToken_\\n                            });\\n                            ++matches_;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            paths_ = new SwapPath[](matches_);\\n            for (uint256 i; i < matches_; ++i) {\\n                paths_[i] = maxPaths_[i];\\n            }\\n        }\\n    }\\n\\n    /// @notice returns the swap data for with and without absorb for a Fluid `vault_`.\\n    function getVaultSwapData(\\n        address vault_\\n    ) public returns (SwapData memory withoutAbsorb_, SwapData memory withAbsorb_) {\\n        VaultResolverStructs.LiquidationStruct memory liquidationData_ = VAULT_RESOLVER.getVaultLiquidation(vault_, 0);\\n\\n        withoutAbsorb_ = SwapData({\\n            inAmt: liquidationData_.tokenInAmtOne,\\n            outAmt: liquidationData_.tokenOutAmtOne,\\n            withAbsorb: false,\\n            ratio: _calcRatio(liquidationData_.tokenInAmtOne, liquidationData_.tokenOutAmtOne)\\n        });\\n\\n        withAbsorb_ = SwapData({\\n            inAmt: liquidationData_.tokenInAmtTwo,\\n            outAmt: liquidationData_.tokenOutAmtTwo,\\n            withAbsorb: true,\\n            ratio: _calcRatio(liquidationData_.tokenInAmtTwo, liquidationData_.tokenOutAmtTwo)\\n        });\\n    }\\n\\n    /// @notice returns the swap data for with and without absorb for multiple Fluid `vaults_`.\\n    function getVaultsSwapData(\\n        address[] memory vaults_\\n    ) public returns (SwapData[] memory withoutAbsorb_, SwapData[] memory withAbsorb_) {\\n        withoutAbsorb_ = new SwapData[](vaults_.length);\\n        withAbsorb_ = new SwapData[](vaults_.length);\\n        for (uint256 i; i < vaults_.length; ++i) {\\n            (withoutAbsorb_[i], withAbsorb_[i]) = getVaultSwapData(vaults_[i]);\\n        }\\n    }\\n\\n    /// @notice returns the swap data for with and without absorb for all Fluid vaults.\\n    function getAllVaultsSwapData() public returns (SwapData[] memory withoutAbsorb_, SwapData[] memory withAbsorb_) {\\n        return getVaultsSwapData(_getVaultT1s());\\n    }\\n\\n    /// @notice returns the available swap amounts at a certain `protocol_`. Only returns non-zero swaps.\\n    ///         For vault protocol considering both a swap that uses liquidation with absorb and without absorb.\\n    function getSwapForProtocol(address protocol_) public returns (Swap memory swap_) {\\n        if (protocol_ == address(0)) {\\n            return swap_;\\n        }\\n\\n        (address borrowToken_, address supplyToken_) = _getVaultTokens(protocol_);\\n        (SwapData memory withoutAbsorb_, SwapData memory withAbsorb_) = getVaultSwapData(protocol_);\\n        return\\n            Swap({\\n                path: SwapPath({ protocol: protocol_, tokenIn: borrowToken_, tokenOut: supplyToken_ }),\\n                data: _getBetterRatioSwapData(withoutAbsorb_, withAbsorb_)\\n            });\\n    }\\n\\n    /// @notice returns all available `swaps_` for multiple Fluid `vaults_` raw. Only returns non-zero swaps.\\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\\n    function getVaultsSwapRaw(address[] memory vaults_) public returns (Swap[] memory swaps_) {\\n        unchecked {\\n            uint256 nonZeroSwaps_;\\n            Swap[] memory allSwaps_ = new Swap[](vaults_.length * 2);\\n\\n            SwapData memory withoutAbsorb_;\\n            SwapData memory withAbsorb_;\\n            address borrowToken_;\\n            address supplyToken_;\\n            for (uint256 i; i < vaults_.length; ++i) {\\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(vaults_[i]);\\n                if (withAbsorb_.inAmt == 0) {\\n                    // if with absorb is 0, then without absorb can only be 0 too\\n                    continue;\\n                }\\n                ++nonZeroSwaps_;\\n                if (withAbsorb_.inAmt == withoutAbsorb_.inAmt) {\\n                    // with absorb has the same liquidity as without absorb.\\n                    // running liquidate() with absorb in that case only costs extra gas. return only without absorb swap\\n                    withAbsorb_.inAmt = 0;\\n                } else if (withoutAbsorb_.inAmt > 0) {\\n                    // both with and without absorb swaps\\n                    ++nonZeroSwaps_;\\n                }\\n\\n                (borrowToken_, supplyToken_) = _getVaultTokens(vaults_[i]);\\n\\n                allSwaps_[i * 2] = Swap({\\n                    path: SwapPath({ protocol: vaults_[i], tokenIn: borrowToken_, tokenOut: supplyToken_ }),\\n                    data: withoutAbsorb_\\n                });\\n                allSwaps_[i * 2 + 1] = Swap({\\n                    path: SwapPath({ protocol: vaults_[i], tokenIn: borrowToken_, tokenOut: supplyToken_ }),\\n                    data: withAbsorb_\\n                });\\n            }\\n\\n            return _getNonZeroSwaps(allSwaps_, nonZeroSwaps_);\\n        }\\n    }\\n\\n    /// @notice returns all available `swaps_` for all Fluid vaults raw. Only returns non-zero swaps.\\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\\n    function getAllVaultsSwapRaw() public returns (Swap[] memory swaps_) {\\n        return getVaultsSwapRaw(_getVaultT1s());\\n    }\\n\\n    /// @notice returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.\\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\\n    function getSwapsForPathsRaw(SwapPath[] memory paths_) public returns (Swap[] memory swaps_) {\\n        unchecked {\\n            Swap[] memory allSwaps_ = new Swap[](paths_.length * 2);\\n\\n            uint256 nonZeroSwaps_;\\n            SwapData memory withoutAbsorb_;\\n            SwapData memory withAbsorb_;\\n            for (uint256 i; i < paths_.length; ++i) {\\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(paths_[i].protocol);\\n\\n                if (withAbsorb_.inAmt == 0) {\\n                    // if with absorb is 0, then without absorb can only be 0 too\\n                    continue;\\n                }\\n                ++nonZeroSwaps_;\\n                if (withAbsorb_.inAmt == withoutAbsorb_.inAmt) {\\n                    // with absorb has the same liquidity as without absorb.\\n                    // running liquidate() with absorb in that case only costs extra gas. return only without absorb swap\\n                    withAbsorb_.inAmt = 0;\\n                } else if (withoutAbsorb_.inAmt > 0) {\\n                    // both with and without absorb swaps\\n                    ++nonZeroSwaps_;\\n                }\\n\\n                allSwaps_[i * 2] = Swap({ path: paths_[i], data: withoutAbsorb_ });\\n\\n                allSwaps_[i * 2 + 1] = Swap({ path: paths_[i], data: withAbsorb_ });\\n            }\\n\\n            swaps_ = new Swap[](nonZeroSwaps_);\\n            uint256 index_;\\n            for (uint256 i; i < allSwaps_.length; ++i) {\\n                if (allSwaps_[i].data.inAmt > 0) {\\n                    swaps_[index_] = allSwaps_[i];\\n                    ++index_;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice finds all available `swaps_` for `tokenIn_` to `tokenOut_`.\\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\\n    function getSwapsRaw(address tokenIn_, address tokenOut_) public returns (Swap[] memory swaps_) {\\n        return getSwapsForPathsRaw(getSwapPaths(tokenIn_, tokenOut_));\\n    }\\n\\n    /// @notice finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.\\n    ///         Token pairs that are not available or where available swap amounts are zero\\n    ///         will not be present in the returned `swaps_` array.\\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\\n    function getAnySwapsRaw(\\n        address[] calldata tokensIn_,\\n        address[] calldata tokensOut_\\n    ) public returns (Swap[] memory swaps_) {\\n        return getSwapsForPathsRaw(getAnySwapPaths(tokensIn_, tokensOut_));\\n    }\\n\\n    /// @notice returns all available `swaps_` for multiple Fluid `vaults_`. Only returns non-zero swaps.\\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\\n    ///         better ratio.\\n    function getVaultsSwap(address[] memory vaults_) public returns (Swap[] memory swaps_) {\\n        unchecked {\\n            uint256 nonZeroSwaps_;\\n            Swap[] memory allSwaps_ = new Swap[](vaults_.length);\\n\\n            SwapData memory withoutAbsorb_;\\n            SwapData memory withAbsorb_;\\n            Swap memory swap_;\\n            for (uint256 i; i < vaults_.length; ++i) {\\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(vaults_[i]);\\n                swap_ = Swap({\\n                    path: SwapPath({ protocol: vaults_[i], tokenIn: address(0), tokenOut: address(0) }),\\n                    data: _getBetterRatioSwapData(withoutAbsorb_, withAbsorb_)\\n                });\\n\\n                if (swap_.data.inAmt == 0) {\\n                    // no swap available on this vault\\n                    continue;\\n                }\\n\\n                ++nonZeroSwaps_;\\n\\n                (swap_.path.tokenIn, swap_.path.tokenOut) = _getVaultTokens(vaults_[i]);\\n\\n                allSwaps_[i] = swap_;\\n            }\\n\\n            return _getNonZeroSwaps(allSwaps_, nonZeroSwaps_);\\n        }\\n    }\\n\\n    /// @notice returns all available `swaps_` for all Fluid vaults. Only returns non-zero swaps.\\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\\n    ///         better ratio.\\n    function getAllVaultsSwap() public returns (Swap[] memory swaps_) {\\n        return getVaultsSwap(_getVaultT1s());\\n    }\\n\\n    /// @notice returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.\\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\\n    ///         better ratio.\\n    function getSwapsForPaths(SwapPath[] memory paths_) public returns (Swap[] memory swaps_) {\\n        unchecked {\\n            Swap[] memory allSwaps_ = new Swap[](paths_.length);\\n\\n            uint256 nonZeroSwaps_;\\n            Swap memory swap_;\\n            SwapData memory withoutAbsorb_;\\n            SwapData memory withAbsorb_;\\n            for (uint256 i; i < paths_.length; ++i) {\\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(paths_[i].protocol);\\n                swap_ = Swap({ path: paths_[i], data: _getBetterRatioSwapData(withoutAbsorb_, withAbsorb_) });\\n\\n                if (swap_.data.inAmt == 0) {\\n                    // no swap available on this vault\\n                    continue;\\n                }\\n\\n                ++nonZeroSwaps_;\\n\\n                allSwaps_[i] = swap_;\\n            }\\n\\n            return _getNonZeroSwaps(allSwaps_, nonZeroSwaps_);\\n        }\\n    }\\n\\n    /// @notice finds all available `swaps_` for `tokenIn_` to `tokenOut_`.\\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\\n    ///         better ratio.\\n    function getSwaps(address tokenIn_, address tokenOut_) public returns (Swap[] memory swaps_) {\\n        return getSwapsForPaths(getSwapPaths(tokenIn_, tokenOut_));\\n    }\\n\\n    /// @notice finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.\\n    ///         Token pairs that are not available or where available swap amounts are zero\\n    ///         will not be present in the returned `swaps_` array.\\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\\n    ///         better ratio.\\n    function getAnySwaps(\\n        address[] calldata tokensIn_,\\n        address[] calldata tokensOut_\\n    ) public returns (Swap[] memory swaps_) {\\n        return getSwapsForPaths(getAnySwapPaths(tokensIn_, tokensOut_));\\n    }\\n\\n    /// @notice returns the calldata to execute a swap as returned by the other methods in this contract.\\n    ///         `swap_.data.inAmt` must come from msg.sender, `swap_.data.outAmt` goes to `receiver_`. If the input token\\n    ///         is the native token, msg.value must be sent along when triggering the actual call with the returned calldata\\n    ///         which should be `swap_.data.inAmt`.\\n    /// @param swap_ Swap struct as returned by other methods\\n    /// @param receiver_ receiver address that the output token is sent to\\n    /// @param slippage_ maximum allowed slippage for the expected output token amount. Reverts iIf received token out\\n    ///                  amount is lower than this. in 1e4 percentage, e.g. 1% = 10000, 0.3% = 3000, 0.01% = 100, 0.0001% = 1.\\n    /// @return target_ target address where `calldata_` must be executed\\n    /// @return calldata_ the calldata that can be used to trigger the liquidation call, resulting in the desired swap.\\n    function getSwapTx(\\n        Swap calldata swap_,\\n        address receiver_,\\n        uint256 slippage_\\n    ) public pure returns (address target_, bytes memory calldata_) {\\n        if (swap_.path.protocol == address(0) || receiver_ == address(0)) {\\n            revert FluidVaultLiquidationsResolver__AddressZero();\\n        }\\n        if (slippage_ >= 1e6 || swap_.data.inAmt == 0 || swap_.data.outAmt == 0) {\\n            revert FluidVaultLiquidationsResolver__InvalidParams();\\n        }\\n\\n        uint256 colPerUnitDebt_ = (swap_.data.outAmt * 1e18) / swap_.data.inAmt;\\n        colPerUnitDebt_ = (colPerUnitDebt_ * (1e6 - slippage_)) / 1e6; // e.g. 50 * 99% / 100% = 49.5\\n\\n        calldata_ = abi.encodeWithSelector(\\n            IFluidVaultT1(swap_.path.protocol).liquidate.selector,\\n            swap_.data.inAmt,\\n            colPerUnitDebt_,\\n            receiver_,\\n            swap_.data.withAbsorb\\n        );\\n        target_ = swap_.path.protocol;\\n    }\\n\\n    /// @notice returns the same data as `getSwapTx` for an array of input `swaps_` at once.\\n    function getSwapTxs(\\n        Swap[] calldata swaps_,\\n        address receiver_,\\n        uint256 slippage_\\n    ) public pure returns (address[] memory targets_, bytes[] memory calldatas_) {\\n        targets_ = new address[](swaps_.length);\\n        calldatas_ = new bytes[](swaps_.length);\\n        for (uint256 i; i < swaps_.length; ++i) {\\n            (targets_[i], calldatas_[i]) = getSwapTx(swaps_[i], receiver_, slippage_);\\n        }\\n    }\\n\\n    /// @notice finds all swaps from `tokenIn_` to `tokenOut_` for an exact input amount `inAmt_`.\\n    ///         filters the available swaps and sorts them by ratio, so the returned swaps are the best available\\n    ///         swaps to reach the target `inAmt_`.\\n    ///         If the full available amount is less than the target `inAmt_`, the available amount is returned as `actualInAmt_`.\\n    /// @dev The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better\\n    /// but the target swap amount is more than the available without absorb liquidity. For this, currently the available\\n    /// withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity.\\n    /// The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false\\n    /// to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing\\n    /// amount up to the target amount with the worse ratio with absorb liquidity.\\n    /// @param tokenIn_ input token\\n    /// @param tokenOut_ output token\\n    /// @param inAmt_ exact input token amount that should be swapped to output token\\n    /// @return swaps_ swaps to reach the target amount, sorted by ratio in descending order\\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\\n    /// @return actualInAmt_ actual input token amount. Can be less than inAmt_ if all available swaps can not cover\\n    ///                      the target amount.\\n    /// @return outAmt_ output token amount received for `actualInAmt_`\\n    function exactInput(\\n        address tokenIn_,\\n        address tokenOut_,\\n        uint256 inAmt_\\n    ) public returns (Swap[] memory swaps_, uint256 actualInAmt_, uint256 outAmt_) {\\n        return filterToTargetInAmt(getSwapsRaw(tokenIn_, tokenOut_), inAmt_);\\n    }\\n\\n    /// @notice finds all swaps from `tokenIn_` to `tokenOut_` for an APPROXIMATE output amount `outAmt_`.\\n    ///         filters the available swaps and sorts them by ratio, so the returned swaps are the best available\\n    ///         swaps to reach the target `outAmt_`.\\n    ///         If the full available amount is less than the target `outAmt_`, the available amount is returned as `actualOutAmt_`.\\n    ///         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to\\n    ///         approximately estimate the required input amounts to reach a certain output amount. This\\n    ///         will change until execution and should be controlled with a maximum slippage.\\n    ///         Recommended to use exact input methods instead.\\n    /// @dev The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better\\n    /// but the target swap amount is more than the available without absorb liquidity. For this currently the available\\n    /// withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity.\\n    /// The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false\\n    /// to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing\\n    /// amount up to the target amount with the worse ratio with absorb liquidity.\\n    /// @param tokenIn_ input token\\n    /// @param tokenOut_ output token\\n    /// @param outAmt_ exact output token amount that should be swapped to from input token\\n    /// @return swaps_ swaps to reach the target amount, sorted by ratio in descending order\\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\\n    /// @return inAmt_ input token amount needed to receive `actualOutAmt_`\\n    /// @return approxOutAmt_ approximate output token amount. Can be less than `outAmt_` if all available swaps can not cover\\n    ///                       the target amount.\\n    function approxOutput(\\n        address tokenIn_,\\n        address tokenOut_,\\n        uint256 outAmt_\\n    ) public returns (Swap[] memory swaps_, uint256 inAmt_, uint256 approxOutAmt_) {\\n        return filterToApproxOutAmt(getSwapsRaw(tokenIn_, tokenOut_), outAmt_);\\n    }\\n\\n    /// @notice filters the `swaps_` to the point where `targetInAmt_` is reached.\\n    ///         This is best used in combination with the \\\"Raw\\\" methods, as the `targetInAmt_` allows for more optimized\\n    ///         filtering than otherwise done with the non-\\\"Raw\\\" methods.\\n    /// @return filteredSwaps_ swaps to reach the target amount, sorted by ratio in descending order\\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\\n    /// @return actualInAmt_ actual input amount. Can be less than targetInAmt_ if all available swaps can not cover\\n    ///                      the target amount.\\n    /// @return approxOutAmt_ actual estimated output amount.\\n    function filterToTargetInAmt(\\n        Swap[] memory swaps_,\\n        uint256 targetInAmt_\\n    ) public returns (Swap[] memory filteredSwaps_, uint256 actualInAmt_, uint256 approxOutAmt_) {\\n        return _filterToTarget(swaps_, targetInAmt_, type(uint256).max);\\n    }\\n\\n    /// @notice filters the `swaps_` to the point where APPROXIMATELY `targetOutAmt_` is reached.\\n    ///         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to\\n    ///         approximately estimate the required input amounts to reach a certain output amount. This\\n    ///         will change until execution and should be controlled with a maximum slippage.\\n    ///         Recommended to use exact input methods instead.\\n    ///         This is best used in combination with the \\\"Raw\\\" methods, as the `targetInAmt_` allows for more optimized\\n    ///         filtering than otherwise done with the non-\\\"Raw\\\" methods.\\n    /// @return filteredSwaps_ swaps to reach the target amount, sorted by ratio in descending order\\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\\n    /// @return actualInAmt_ actual input amount.\\n    /// @return approxOutAmt_ APPROXIMATE actual output amount. Can be less than targetOutAmt_ if all available swaps\\n    ///                      can not cover the target amount.\\n    function filterToApproxOutAmt(\\n        Swap[] memory swaps_,\\n        uint256 targetApproxOutAmt_\\n    ) public returns (Swap[] memory filteredSwaps_, uint256 actualInAmt_, uint256 approxOutAmt_) {\\n        return _filterToTarget(swaps_, type(uint256).max, targetApproxOutAmt_);\\n    }\\n\\n    /// @dev filters the `swaps_` to the point where either `targetInAmt_` or `targetOutAmt_` is reached.\\n    ///         To filter only by in or only by out amount, send `type(uint256).max` for the other param.\\n    /// @return filteredSwaps_ swaps to reach the target amount, sorted by ratio in descending order\\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\\n    /// @return actualInAmt_ actual input amount. Can be less than targetInAmt_ if all available swaps can not cover\\n    ///                      the target amount.\\n    /// @return actualOutAmt_ actual output amount. Can be less than targetOutAmt_ if all available swaps can not cover\\n    ///                      the target amount.\\n    function _filterToTarget(\\n        Swap[] memory swaps_,\\n        uint256 targetInAmt_,\\n        uint256 targetOutAmt_\\n    ) internal returns (Swap[] memory filteredSwaps_, uint256 actualInAmt_, uint256 actualOutAmt_) {\\n        swaps_ = _sortByRatio(swaps_);\\n        (filteredSwaps_, actualInAmt_, actualOutAmt_) = _filterSwapsUntilTarget(swaps_, targetInAmt_, targetOutAmt_);\\n\\n        if (actualInAmt_ > targetInAmt_ || actualOutAmt_ > targetOutAmt_) {\\n            // reduce last swap in amt to match target in amt\\n            uint256 lastSwapIndex_ = filteredSwaps_.length - 1;\\n\\n            uint256 missingInAmt_;\\n            if (actualInAmt_ > targetInAmt_) {\\n                // swaps_[i].data.inAmt is causing that we over reach targetInAmt_\\n                // so to get missing account from here until targetInAmt_, we only want\\n                // swaps_[i].data.inAmt minus whatever is too much (actualInAmt_ - targetInAmt_)\\n                missingInAmt_ = filteredSwaps_[lastSwapIndex_].data.inAmt + 1 - (actualInAmt_ - targetInAmt_);\\n            } else {\\n                // get missing in amt to use for liquidation call input param based on missing out amt and ratio\\n                uint256 missingOutAmt_ = filteredSwaps_[lastSwapIndex_].data.outAmt - (actualOutAmt_ - targetOutAmt_);\\n\\n                // get total available liquidation and the ratios for with absorb vs without absorb\\n                VaultResolverStructs.LiquidationStruct memory liquidationDataAvailable_ = VAULT_RESOLVER\\n                    .getVaultLiquidation(filteredSwaps_[lastSwapIndex_].path.protocol, 0);\\n\\n                uint256 withoutAbsorbRatio_ = _calcRatio(\\n                    liquidationDataAvailable_.tokenInAmtOne,\\n                    liquidationDataAvailable_.tokenOutAmtOne\\n                );\\n                // calculate the ratio of the absorb only liquidity part\\n                uint256 absorbOnlyRatio_ = _calcRatio(\\n                    liquidationDataAvailable_.tokenInAmtTwo - liquidationDataAvailable_.tokenInAmtOne,\\n                    liquidationDataAvailable_.tokenOutAmtTwo - liquidationDataAvailable_.tokenOutAmtOne\\n                );\\n                if (\\n                    absorbOnlyRatio_ > withoutAbsorbRatio_ || liquidationDataAvailable_.tokenOutAmtOne < missingOutAmt_\\n                ) {\\n                    // with absorb has the better ratio than without absorb or without absorb can not fully cover\\n                    // the missing out amount. So with absorb has to be run.\\n                    // Note for the case liquidationDataAvailable_.tokenOutAmtOne < missingOutAmt_:\\n                    // missing in amt would ideally be a combination of the whole without absorb liquidity +\\n                    // some left over which has the different (worse) with absorb ratio.\\n                    // when running withAbsorb = true, always the whole with absorb liquidity is taken first.\\n                    // so to profit of the better without absorb liquidity, this would have to be turned into 2 swaps.\\n                    // but this might not always be better because of gas usage etc., so for simplicity we just\\n                    // take the whole absorb liquidity first.\\n\\n                    // check if absorb only liquidity covers the missing out amount, if so then the swap ratio is already known\\n                    // as absorbOnlyRatio_ which can be used to derive the required inAmt\\n                    uint256 asborbOnlyLiquidity_ = liquidationDataAvailable_.tokenOutAmtTwo -\\n                        liquidationDataAvailable_.tokenOutAmtOne;\\n                    if (asborbOnlyLiquidity_ >= missingOutAmt_) {\\n                        missingInAmt_ = (missingOutAmt_ * 1e27) / absorbOnlyRatio_ + 1;\\n                    } else {\\n                        // missing in amt is a combination of the whole absorb liquidity + some left over\\n                        // which has the different without absorb ratio\\n                        missingInAmt_ = (asborbOnlyLiquidity_ * 1e27) / absorbOnlyRatio_ + 1;\\n                        missingInAmt_ += ((missingOutAmt_ - asborbOnlyLiquidity_) * 1e27) / withoutAbsorbRatio_ + 1;\\n                    }\\n                } else {\\n                    // without absorb has the better ratio AND missing out amount can be covered by without absorb liquidity\\n                    missingInAmt_ = (missingOutAmt_ * 1e27) / withoutAbsorbRatio_ + 1;\\n                }\\n            }\\n\\n            VaultResolverStructs.LiquidationStruct memory liquidationData_ = VAULT_RESOLVER.getVaultLiquidation(\\n                filteredSwaps_[lastSwapIndex_].path.protocol,\\n                missingInAmt_\\n            );\\n\\n            actualInAmt_ -= filteredSwaps_[lastSwapIndex_].data.inAmt;\\n            actualOutAmt_ -= filteredSwaps_[lastSwapIndex_].data.outAmt;\\n\\n            if (filteredSwaps_[lastSwapIndex_].data.withAbsorb) {\\n                filteredSwaps_[lastSwapIndex_].data.inAmt = liquidationData_.tokenInAmtTwo;\\n                filteredSwaps_[lastSwapIndex_].data.outAmt = liquidationData_.tokenOutAmtTwo;\\n                filteredSwaps_[lastSwapIndex_].data.ratio = _calcRatio(\\n                    liquidationData_.tokenInAmtTwo,\\n                    liquidationData_.tokenOutAmtTwo\\n                );\\n            } else {\\n                filteredSwaps_[lastSwapIndex_].data.inAmt = liquidationData_.tokenInAmtOne;\\n                filteredSwaps_[lastSwapIndex_].data.outAmt = liquidationData_.tokenOutAmtOne;\\n                filteredSwaps_[lastSwapIndex_].data.ratio = _calcRatio(\\n                    liquidationData_.tokenInAmtOne,\\n                    liquidationData_.tokenOutAmtOne\\n                );\\n            }\\n\\n            actualInAmt_ += filteredSwaps_[lastSwapIndex_].data.inAmt;\\n            actualOutAmt_ += filteredSwaps_[lastSwapIndex_].data.outAmt;\\n        }\\n    }\\n\\n    /// @dev sorts `swaps_` by ratio descending. Higher ratio is better (getting more output for input).\\n    ///      Best ratio swap will be at pos 0, second best at pos 1 and so on\\n    function _sortByRatio(Swap[] memory swaps_) internal pure returns (Swap[] memory) {\\n        bool swapped_;\\n        Swap memory helper_;\\n        for (uint256 i = 1; i < swaps_.length; i++) {\\n            swapped_ = false;\\n            for (uint256 j = 0; j < swaps_.length - i; j++) {\\n                if (swaps_[j + 1].data.ratio > swaps_[j].data.ratio) {\\n                    helper_ = swaps_[j];\\n                    swaps_[j] = swaps_[j + 1];\\n                    swaps_[j + 1] = helper_;\\n                    swapped_ = true;\\n                }\\n            }\\n            if (!swapped_) {\\n                return swaps_;\\n            }\\n        }\\n\\n        return swaps_;\\n    }\\n\\n    /// @dev filters `swaps_` to exactly reach `targetInAmt_`. Takes into consideration to filter out any swaps\\n    ///      where both the withAbsorb and withoutAbsorb swap would be present for the same protocol, only\\n    ///      leaving the withAbsorb swap (as that includes withoutAbsorb).\\n    ///      Also returns the total in `sumInAmt_` and out `sumOutAmt_` amounts, which will be less than `targetInAmt_`\\n    ///      in the case that the target amount can not be reached even with all swaps.\\n    function _filterSwapsUntilTarget(\\n        Swap[] memory swaps_,\\n        uint256 targetInAmt_,\\n        uint256 targetOutAmt_\\n    ) internal returns (Swap[] memory filteredSwaps_, uint256 sumInAmt_, uint256 sumOutAmt_) {\\n        if (swaps_.length == 0) {\\n            return (swaps_, 0, 0);\\n        }\\n        uint256 filteredCount_;\\n        // find swaps needed until target in amt\\n        while (sumInAmt_ < targetInAmt_ && sumOutAmt_ < targetOutAmt_ && filteredCount_ < swaps_.length) {\\n            sumInAmt_ += swaps_[filteredCount_].data.inAmt;\\n            sumOutAmt_ += swaps_[filteredCount_].data.outAmt;\\n            ++filteredCount_;\\n        }\\n\\n        // must not double count without absorb when with absorb is already present\\n        // until filteredCount, for any protocol where with absorb is present,\\n        // filter out the without absorb if that swap is present too.\\n        // if any is found then the while to find swaps until targetAmt must be run again\\n        // as it will be less with the filtered out element deducted.\\n        uint256 duplicatesCount_;\\n        for (uint256 i; i < filteredCount_ - 1; ++i) {\\n            for (uint256 j = i + 1; j < filteredCount_; ++j) {\\n                if (swaps_[i].path.protocol == swaps_[j].path.protocol) {\\n                    // same protocol present twice (with and without absorb).\\n                    // mark without absorb to be removed by setting the inAmt to 0\\n                    if (swaps_[i].data.withAbsorb) {\\n                        swaps_[j].data.inAmt = 0;\\n                    } else {\\n                        swaps_[i].data.inAmt = 0;\\n                    }\\n                    duplicatesCount_++;\\n                }\\n            }\\n        }\\n\\n        if (duplicatesCount_ > 0) {\\n            uint256 index_;\\n            // filter swaps that are set to 0\\n            filteredSwaps_ = new Swap[](swaps_.length - duplicatesCount_);\\n            for (uint256 i; i < swaps_.length; ++i) {\\n                if (swaps_[i].data.inAmt > 0) {\\n                    filteredSwaps_[index_] = swaps_[i];\\n                    ++index_;\\n                }\\n            }\\n\\n            // recursive call again to reach target amount as planned.\\n            return _filterSwapsUntilTarget(filteredSwaps_, targetInAmt_, targetOutAmt_);\\n        }\\n\\n        // when clean of duplicates -> finished, return filtered swaps and total sumInAmt\\n        filteredSwaps_ = new Swap[](filteredCount_);\\n        for (uint256 i; i < filteredCount_; ++i) {\\n            filteredSwaps_[i] = swaps_[i];\\n        }\\n        return (filteredSwaps_, sumInAmt_, sumOutAmt_);\\n    }\\n\\n    /// @dev gets the better swap based on ratio of with vs without absorb swap data.\\n    function _getBetterRatioSwapData(\\n        SwapData memory withoutAbsorb_,\\n        SwapData memory withAbsorb_\\n    ) internal pure returns (SwapData memory swap_) {\\n        if (withAbsorb_.inAmt == 0) {\\n            // if ratio == 0, meaning inAmt is 0, then the with absorb swap is returned.\\n            return withAbsorb_;\\n        }\\n\\n        if (withAbsorb_.ratio > withoutAbsorb_.ratio) {\\n            // If (ratio of withAbsorb > ratio of withoutAbsorb) then always absorb should be true.\\n            return withAbsorb_;\\n        }\\n\\n        if (withAbsorb_.ratio == withoutAbsorb_.ratio) {\\n            if (withAbsorb_.inAmt == withoutAbsorb_.inAmt) {\\n                // with absorb has the same liquidity as without absorb.\\n                // running liquidate() with absorb in that case only costs extra gas. return only without absorb swap\\n                return withoutAbsorb_;\\n            }\\n\\n            // with absorb has more liquidity, but same ratio -> return with absorb\\n            return withAbsorb_;\\n        }\\n\\n        // ratio of without absorb is better.\\n        // todo: case where with absorb has worse ratio. but it could have significant more liquidity -> will not be\\n        // returned here as long as there is without absorb liquidity...\\n        return withoutAbsorb_;\\n    }\\n\\n    /// @dev filters `allSwaps_` to the non zero amount `swaps_`, knowing the `nonZeroSwapsCount_`\\n    function _getNonZeroSwaps(\\n        Swap[] memory allSwaps_,\\n        uint256 nonZeroSwapsCount_\\n    ) internal pure returns (Swap[] memory swaps_) {\\n        unchecked {\\n            swaps_ = new Swap[](nonZeroSwapsCount_);\\n            uint256 index_;\\n            for (uint256 i; i < allSwaps_.length; ++i) {\\n                if (allSwaps_[i].data.inAmt > 0) {\\n                    swaps_[index_] = allSwaps_[i];\\n                    ++index_;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev gets the `vault_` token in (borrow token) and token out (supply token)\\n    function _getVaultTokens(address vault_) internal view returns (address tokenIn_, address tokenOut_) {\\n        IFluidVaultT1.ConstantViews memory constants_ = IFluidVaultT1(vault_).constantsView();\\n        return (constants_.borrowToken, constants_.supplyToken);\\n    }\\n\\n    /// @dev returns ratio for how much outAmt_ am I getting for inAmt_. scaled by 1e27\\n    function _calcRatio(uint256 inAmt_, uint256 outAmt_) internal pure returns (uint256) {\\n        if (outAmt_ == 0) {\\n            return 0;\\n        }\\n        return (outAmt_ * 1e27) / inAmt_;\\n    }\\n\\n    /// @dev returns all VaultT1 type protocols at the Fluid VaultFactory\\n    function _getVaultT1s() internal view returns (address[] memory) {\\n        return FluidProtocolTypes.filterBy(VAULT_RESOLVER.getAllVaultsAddresses(), FluidProtocolTypes.VAULT_T1_TYPE);\\n    }\\n}\\n\",\"keccak256\":\"0x0601b68accc3fde72851cce4e5858ac52fd805986e4fb35ac5454a4030d12eb7\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vaultLiquidation/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ncontract Structs {\\n    struct SwapPath {\\n        ///\\n        /// @param protocol vault address at which the token pair is available\\n        address protocol;\\n        ///\\n        /// @param tokenIn input token, borrow token at the vault\\n        address tokenIn;\\n        ///\\n        /// @param tokenOut output token, collateral token at the vault\\n        address tokenOut;\\n    }\\n\\n    struct SwapData {\\n        ///\\n        /// @param inAmt total input token amount\\n        uint256 inAmt;\\n        ///\\n        /// @param outAmt total output token amount received\\n        uint256 outAmt;\\n        ///\\n        /// @param withAbsorb flag for using mode \\\"withAbsorb\\\" when calling liquidate() on the Vault.\\n        ///                   Is set to true if a) liquidity without absorb would not\\n        ///                   cover the desired `inAmt_` or if b) the rate of with absorb is better than without absorb.\\n        bool withAbsorb;\\n        ///\\n        /// @param ratio ratio of outAmt / inAmt scaled by 1e27\\n        uint256 ratio;\\n    }\\n\\n    struct Swap {\\n        ///\\n        /// @param path swap path struct info such as protocol where the swap is available\\n        SwapPath path;\\n        ///\\n        /// @param data swap data struct info such as amounts\\n        SwapData data;\\n    }\\n}\\n\",\"keccak256\":\"0x439f4df12cb5893807641f807551cf068275f3e027b43d56f0538c717d4c795b\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vaultLiquidation/variables.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidVaultResolver } from \\\"../vault/iVaultResolver.sol\\\";\\n\\ncontract Variables {\\n    IFluidVaultResolver public immutable VAULT_RESOLVER;\\n\\n    constructor(IFluidVaultResolver vaultResolver_) {\\n        VAULT_RESOLVER = vaultResolver_;\\n    }\\n}\\n\",\"keccak256\":\"0xb95342bc4a9cad312e81216b005baa93a5aea18c3fd60715d83e14258ec51e51\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/interfaces/iVaultT1.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IFluidVaultT1 {\\n    /// @notice returns the vault id\\n    function VAULT_ID() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct ConstantViews {\\n        address liquidity;\\n        address factory;\\n        address adminImplementation;\\n        address secondaryImplementation;\\n        address supplyToken;\\n        address borrowToken;\\n        uint8 supplyDecimals;\\n        uint8 borrowDecimals;\\n        uint vaultId;\\n        bytes32 liquiditySupplyExchangePriceSlot;\\n        bytes32 liquidityBorrowExchangePriceSlot;\\n        bytes32 liquidityUserSupplySlot;\\n        bytes32 liquidityUserBorrowSlot;\\n    }\\n\\n    /// @notice returns all Vault constants\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    /// @notice fetches the latest user position after a liquidation\\n    function fetchLatestPosition(\\n        int256 positionTick_,\\n        uint256 positionTickId_,\\n        uint256 positionRawDebt_,\\n        uint256 tickData_\\n    )\\n        external\\n        view\\n        returns (\\n            int256, // tick\\n            uint256, // raw debt\\n            uint256, // raw collateral\\n            uint256, // branchID_\\n            uint256 // branchData_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices\\n    function updateExchangePrices(\\n        uint256 vaultVariables2_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices and writes them to storage\\n    function updateExchangePricesOnStorage()\\n        external\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice returns the liquidity contract address\\n    function LIQUIDITY() external view returns (address);\\n\\n    function operate(\\n        uint256 nftId_, // if 0 then new position\\n        int256 newCol_, // if negative then withdraw\\n        int256 newDebt_, // if negative then payback\\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256, // nftId_\\n            int256, // final supply amount. if - then withdraw\\n            int256 // final borrow amount. if - then payback\\n        );\\n    \\n    function liquidate(\\n        uint256 debtAmt_,\\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\\n        address to_,\\n        bool absorb_\\n    ) external payable returns (uint actualDebtAmt_, uint actualColAmt_);\\n\\n    function absorb() external;\\n\\n    function rebalance() external payable returns (int supplyAmt_, int borrowAmt_);\\n\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n}\\n\",\"keccak256\":\"0xe0ec40a4531ecbcd7b8db25b4cd8529e0c284bb20eb40b7cf909fb8af0e3ca8b\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b5060405162003b5d38038062003b5d833981016040819052620000349162000068565b6001600160a01b038116608081905262000061576040516303c99f9d60e61b815260040160405180910390fd5b506200009a565b6000602082840312156200007b57600080fd5b81516001600160a01b03811681146200009357600080fd5b9392505050565b608051613a8b620000d2600039600081816102b3015281816113ea01528181611c2d01528181611e4601526120980152613a8b6000f3fe608060405234801561001057600080fd5b50600436106101985760003560e01c80637f3e2b48116100e35780639f5de8751161008c578063e082bca211610066578063e082bca2146103bb578063e979e874146103ce578063ed6bf8bc146103d657600080fd5b80639f5de87514610375578063aa822df614610395578063c5f8b2e5146103a857600080fd5b8063861d3ac4116100bd578063861d3ac4146103205780638651d5ec146103415780638953b9d61461035457600080fd5b80637f3e2b48146102ae5780638011ba33146102fa578063838fef5c1461030d57600080fd5b80635a980a9f116101455780636c8559621161011f5780636c855962146102755780637119484a146102885780637bfb86ff1461029b57600080fd5b80635a980a9f1461023c5780635e47ec031461024f57806365eb6bd41461026257600080fd5b8063404fcab211610176578063404fcab2146101f15780634296bdff146102135780634c6fdc1a1461022957600080fd5b806321d3b7f41461019d578063232306ea146101bb5780633c199241146101dc575b600080fd5b6101a56103e9565b6040516101b29190612d77565b60405180910390f35b6101ce6101c9366004612daf565b6103fb565b6040516101b2929190612e9f565b6101e4610541565b6040516101b29190612f6b565b6102046101ff366004612fe8565b6106b9565b6040516101b293929190613029565b61021b6106e1565b6040516101b29291906130ab565b61021b6102373660046131e2565b6106f7565b6101e461024a3660046132c2565b61086f565b61020461025d3660046133b9565b610b96565b610204610270366004612fe8565b610bd3565b6101a56102833660046132c2565b610beb565b6101a56102963660046131e2565b610c05565b6101a56102a93660046131e2565b610ea7565b6102d57f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101b2565b6101a56103083660046134e2565b6110b1565b6101a561031b3660046134e2565b6110c9565b61033361032e36600461351b565b6110d8565b6040516101b2929190613564565b61020461034f3660046133b9565b611311565b61036761036236600461359b565b611341565b6040516101b29291906135bf565b61038861038336600461359b565b6114df565b6040516101b2919061360f565b6101e46103a33660046134e2565b61157c565b6101a56103b63660046132c2565b611802565b6101a56103c936600461361d565b611813565b6101a5611ab6565b6101a56103e436600461361d565b611ac3565b60606103f66102a9611c26565b905090565b6060808467ffffffffffffffff811115610417576104176130d0565b604051908082528060200260200182016040528015610440578160200160208202803683370190505b5091508467ffffffffffffffff81111561045c5761045c6130d0565b60405190808252806020026020018201604052801561048f57816020015b606081526020019060019003908161047a5790505b50905060005b85811015610537576104bf8787838181106104b2576104b26136b7565b905060e0020186866110d8565b8483815181106104d1576104d16136b7565b602002602001018484815181106104ea576104ea6136b7565b602002602001018290528273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681525050508061053090613715565b9050610495565b5094509492505050565b6060600061054d611c26565b9050805167ffffffffffffffff811115610569576105696130d0565b6040519080825280602002602001820160405280156105d257816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9092019101816105875790505b50915060008060005b83518110156106b2576106068482815181106105f9576105f96136b7565b6020026020010151611ce4565b8093508194505050604051806060016040528085838151811061062b5761062b6136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018473ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff16815250858281518110610696576106966136b7565b6020026020010181905250806106ab90613715565b90506105db565b5050505090565b60606000806106d16106cb87876110c9565b85610b96565b9250925092505b93509350939050565b6060806106ef610237611c26565b915091509091565b606080825167ffffffffffffffff811115610714576107146130d0565b60405190808252806020026020018201604052801561077257816020015b61075f60405180608001604052806000815260200160008152602001600015158152602001600081525090565b8152602001906001900390816107325790505b509150825167ffffffffffffffff81111561078f5761078f6130d0565b6040519080825280602002602001820160405280156107ed57816020015b6107da60405180608001604052806000815260200160008152602001600015158152602001600081525090565b8152602001906001900390816107ad5790505b50905060005b83518110156108695761081e848281518110610811576108116136b7565b6020026020010151611341565b848381518110610830576108306136b7565b60200260200101848481518110610849576108496136b7565b6020026020010182905282905250508061086290613715565b90506107f3565b50915091565b6060600061087d838661374d565b67ffffffffffffffff811115610895576108956130d0565b6040519080825280602002602001820160405280156108fe57816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9092019101816108b35790505b509050600061090b611c26565b90506000806000805b8451811015610ab8576109328582815181106105f9576105f96136b7565b909350915060005b8a811015610aaf5760005b89811015610aa6578c8c8381811061095f5761095f6136b7565b9050602002016020810190610974919061359b565b73ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff161480156109ff57508a8a828181106109bb576109bb6136b7565b90506020020160208101906109d0919061359b565b73ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16145b15610a9e576040518060600160405280888581518110610a2157610a216136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff16815250888781518110610a8c57610a8c6136b7565b60200260200101819052508560010195505b600101610945565b5060010161093a565b50600101610914565b508267ffffffffffffffff811115610ad257610ad26130d0565b604051908082528060200260200182016040528015610b3b57816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff909201910181610af05790505b50955060005b83811015610b8857858181518110610b5b57610b5b6136b7565b6020026020010151878281518110610b7557610b756136b7565b6020908102919091010152600101610b41565b505050505050949350505050565b6060600080610bc685857fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff611d6f565b9250925092509250925092565b60606000806106d1610be587876110c9565b85611311565b6060610bfc6103c98686868661086f565b95945050505050565b6060600080835160020267ffffffffffffffff811115610c2757610c276130d0565b604051908082528060200260200182016040528015610c6057816020015b610c4d612c63565b815260200190600190039081610c455790505b509050610c9060405180608001604052806000815260200160008152602001600015158152602001600081525090565b610cbd60405180608001604052806000815260200160008152602001600015158152602001600081525090565b60008060005b8851811015610e9057610ce1898281518110610811576108116136b7565b8051919650945015610e88578451845160019098019703610d055760008452610d13565b845115610d13578660010196505b610d288982815181106105f9576105f96136b7565b8093508194505050604051806040016040528060405180606001604052808c8581518110610d5857610d586136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff16815250815260200186815250868260020281518110610dcf57610dcf6136b7565b6020026020010181905250604051806040016040528060405180606001604052808c8581518110610e0257610e026136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff16815250815260200185815250868260020260010181518110610e7c57610e7c6136b7565b60200260200101819052505b600101610cc3565b50610e9b858761239a565b98975050505050505050565b6060600080835167ffffffffffffffff811115610ec657610ec66130d0565b604051908082528060200260200182016040528015610eff57816020015b610eec612c63565b815260200190600190039081610ee45790505b509050610f2f60405180608001604052806000815260200160008152602001600015158152602001600081525090565b610f5c60405180608001604052806000815260200160008152602001600015158152602001600081525090565b610f64612c63565b60005b875181101561109b57610f85888281518110610811576108116136b7565b8094508195505050604051806040016040528060405180606001604052808b8581518110610fb557610fb56136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff16815250815260200161101f8686612476565b9052602081015151909250156110935785600101955061104a8882815181106105f9576105f96136b7565b835173ffffffffffffffffffffffffffffffffffffffff9182166040820152911660209091015284518290869083908110611087576110876136b7565b60200260200101819052505b600101610f67565b506110a6848661239a565b979650505050505050565b60606110c06103e4848461157c565b90505b92915050565b60606110c06103c9848461157c565b60006060816110ea602087018761359b565b73ffffffffffffffffffffffffffffffffffffffff161480611120575073ffffffffffffffffffffffffffffffffffffffff8416155b15611157576040517ff267e74000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b620f42408310158061116b57506060850135155b8061117857506080850135155b156111af576040517fb55de08000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600060608601356111cc6080880135670de0b6b3a764000061374d565b6111d69190613764565b9050620f42406111e6858261379f565b6111f0908361374d565b6111fa9190613764565b9050611209602087018761359b565b507f8433ea22000000000000000000000000000000000000000000000000000000006060870135828761124260c08b0160a08c016137b2565b6040516024810194909452604484019290925273ffffffffffffffffffffffffffffffffffffffff1660648301521515608482015260a401604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052602080820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009094169390931790925292506113069087018761359b565b925050935093915050565b6060600080610bc6857fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff86611d6f565b61136e60405180608001604052806000815260200160008152602001600015158152602001600081525090565b61139b60405180608001604052806000815260200160008152602001600015158152602001600081525090565b6040517f1fcd364900000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8481166004830152600060248301819052917f000000000000000000000000000000000000000000000000000000000000000090911690631fcd36499060440160e0604051808303816000875af1158015611435573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061145991906137d8565b905060405180608001604052808260600151815260200182608001518152602001600015158152602001611495836060015184608001516124f7565b815250925060405180608001604052808260a0015181526020018260c0015181526020016001151581526020016114d48360a001518460c001516124f7565b815250915050915091565b6114e7612c63565b73ffffffffffffffffffffffffffffffffffffffff821661150757919050565b60008061151384611ce4565b9150915060008061152386611341565b6040805160a08101825273ffffffffffffffffffffffffffffffffffffffff808b169282019283528881166060830152871660808201529081529193509150602081016115708484612476565b90529695505050505050565b60606000611588611c26565b9050600080825167ffffffffffffffff8111156115a7576115a76130d0565b6040519080825280602002602001820160405280156115d0578160200160208202803683370190505b50905060008060005b85518110156116c1576115f78682815181106105f9576105f96136b7565b909350915073ffffffffffffffffffffffffffffffffffffffff808416908a1614801561164f57508773ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b156116b157858181518110611666576116666136b7565b6020026020010151848681518110611680576116806136b7565b73ffffffffffffffffffffffffffffffffffffffff909216602092830291909101909101526116ae85613715565b94505b6116ba81613715565b90506115d9565b508367ffffffffffffffff8111156116db576116db6130d0565b60405190808252806020026020018201604052801561174457816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9092019101816116f95790505b50955060005b848110156117f657604051806060016040528085838151811061176f5761176f6136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018a73ffffffffffffffffffffffffffffffffffffffff1681526020018973ffffffffffffffffffffffffffffffffffffffff168152508782815181106117da576117da6136b7565b6020026020010181905250806117ef90613715565b905061174a565b50505050505092915050565b6060610bfc6103e48686868661086f565b60606000825160020267ffffffffffffffff811115611834576118346130d0565b60405190808252806020026020018201604052801561186d57816020015b61185a612c63565b8152602001906001900390816118525790505b509050600061189f60405180608001604052806000815260200160008152602001600015158152602001600081525090565b6118cc60405180608001604052806000815260200160008152602001600015158152602001600081525090565b60005b86518110156119d8576118fe8782815181106118ed576118ed6136b7565b602002602001015160000151611341565b80519194509250156119d05782518251600190950194036119225760008252611930565b825115611930578360010193505b604051806040016040528088838151811061194d5761194d6136b7565b6020026020010151815260200184815250858260020281518110611973576119736136b7565b6020026020010181905250604051806040016040528088838151811061199b5761199b6136b7565b60200260200101518152602001838152508582600202600101815181106119c4576119c46136b7565b60200260200101819052505b6001016118cf565b508267ffffffffffffffff8111156119f2576119f26130d0565b604051908082528060200260200182016040528015611a2b57816020015b611a18612c63565b815260200190600190039081611a105790505b5094506000805b8551811015611aab576000868281518110611a4f57611a4f6136b7565b602002602001015160200151600001511115611aa357858181518110611a7757611a776136b7565b6020026020010151878381518110611a9157611a916136b7565b60200260200101819052508160010191505b600101611a32565b505050505050919050565b60606103f6610296611c26565b60606000825167ffffffffffffffff811115611ae157611ae16130d0565b604051908082528060200260200182016040528015611b1a57816020015b611b07612c63565b815260200190600190039081611aff5790505b5090506000611b27612c63565b611b5460405180608001604052806000815260200160008152602001600015158152602001600081525090565b611b8160405180608001604052806000815260200160008152602001600015158152602001600081525090565b60005b8751811015611c1b57611ba28882815181106118ed576118ed6136b7565b80935081945050506040518060400160405280898381518110611bc757611bc76136b7565b60200260200101518152602001611bde8585612476565b905260208101515190945015611c135784600101945083868281518110611c0757611c076136b7565b60200260200101819052505b600101611b84565b506110a6858561239a565b60606103f67f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a8d9f4936040518163ffffffff1660e01b8152600401600060405180830381865afa158015611c96573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052611cdc9190810190613877565b61271061252a565b60008060008373ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b81526004016101a060405180830381865afa158015611d35573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d599190613917565b90508060a0015181608001519250925050915091565b6060600080611d7d8661275f565b9550611d8a8686866128b0565b9194509250905084821180611d9e57508381115b156106d857600060018451611db3919061379f565b9050600086841115611e0857611dc9878561379f565b858381518110611ddb57611ddb6136b7565b602002602001015160200151600001516001611df791906139f4565b611e01919061379f565b9050612094565b6000611e14878561379f565b868481518110611e2657611e266136b7565b60200260200101516020015160200151611e40919061379f565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631fcd3649888681518110611e9257611e926136b7565b602090810291909101015151516040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff90911660048201526000602482015260440160e0604051808303816000875af1158015611f11573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f3591906137d8565b90506000611f4b826060015183608001516124f7565b90506000611f7f83606001518460a00151611f66919061379f565b84608001518560c00151611f7a919061379f565b6124f7565b905081811180611f925750838360800151105b1561206057600083608001518460c00151611fad919061379f565b9050848110611fe95781611fcd866b033b2e3c9fd0803ce800000061374d565b611fd79190613764565b611fe29060016139f4565b955061205a565b81612000826b033b2e3c9fd0803ce800000061374d565b61200a9190613764565b6120159060016139f4565b955082612022828761379f565b612038906b033b2e3c9fd0803ce800000061374d565b6120429190613764565b61204d9060016139f4565b61205790876139f4565b95505b5061208f565b81612077856b033b2e3c9fd0803ce800000061374d565b6120819190613764565b61208c9060016139f4565b94505b505050505b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631fcd36498785815181106120e4576120e46136b7565b602090810291909101015151516040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff90911660048201526024810185905260440160e0604051808303816000875af1158015612163573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061218791906137d8565b905085838151811061219b5761219b6136b7565b60200260200101516020015160000151856121b6919061379f565b94508583815181106121ca576121ca6136b7565b60200260200101516020015160200151846121e5919061379f565b93508583815181106121f9576121f96136b7565b60200260200101516020015160400151156122a1578060a00151868481518110612225576122256136b7565b60200260200101516020015160000181815250508060c00151868481518110612250576122506136b7565b60200260200101516020015160200181815250506122768160a001518260c001516124f7565b868481518110612288576122886136b7565b6020026020010151602001516060018181525050612330565b80606001518684815181106122b8576122b86136b7565b602002602001015160200151600001818152505080608001518684815181106122e3576122e36136b7565b6020026020010151602001516020018181525050612309816060015182608001516124f7565b86848151811061231b5761231b6136b7565b60200260200101516020015160600181815250505b858381518110612342576123426136b7565b602002602001015160200151600001518561235d91906139f4565b9450858381518110612371576123716136b7565b602002602001015160200151602001518461238c91906139f4565b935050505093509350939050565b60608167ffffffffffffffff8111156123b5576123b56130d0565b6040519080825280602002602001820160405280156123ee57816020015b6123db612c63565b8152602001906001900390816123d35790505b5090506000805b845181101561246e576000858281518110612412576124126136b7565b6020026020010151602001516000015111156124665784818151811061243a5761243a6136b7565b6020026020010151838381518110612454576124546136b7565b60200260200101819052508160010191505b6001016123f5565b505092915050565b6124a360405180608001604052806000815260200160008152602001600015158152602001600081525090565b81516000036124b35750806110c3565b8260600151826060015111156124ca5750806110c3565b82606001518260600151036124f05782518251036124e95750816110c3565b50806110c3565b5090919050565b600081600003612509575060006110c3565b82612520836b033b2e3c9fd0803ce800000061374d565b6110c09190613764565b8151606090600090815b85518110156126405785818151811061254f5761254f6136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1663bb24fe8a6040518163ffffffff1660e01b8152600401602060405180830381865afa9250505080156125db575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526125d891810190613a07565b60015b6125e95761271092506125ec565b92505b848314612638576000868281518110612607576126076136b7565b73ffffffffffffffffffffffffffffffffffffffff9092166020928302919091019091015261263582613a20565b91505b600101612534565b508067ffffffffffffffff81111561265a5761265a6130d0565b604051908082528060200260200182016040528015612683578160200160208202803683370190505b5092506000805b865181101561275557600073ffffffffffffffffffffffffffffffffffffffff168782815181106126bd576126bd6136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff161461274d578681815181106126f2576126f26136b7565b602002602001015185838151811061270c5761270c6136b7565b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508160010191505b60010161268a565b5050505092915050565b6060600061276b612c63565b60015b84518110156128a7576000925060005b81865161278b919061379f565b811015612886578581815181106127a4576127a46136b7565b60200260200101516020015160600151868260016127c291906139f4565b815181106127d2576127d26136b7565b602002602001015160200151606001511115612874578581815181106127fa576127fa6136b7565b602002602001015192508581600161281291906139f4565b81518110612822576128226136b7565b602002602001015186828151811061283c5761283c6136b7565b602090810291909101015282866128548360016139f4565b81518110612864576128646136b7565b6020026020010181905250600193505b8061287e81613715565b91505061277e565b50826128955750929392505050565b8061289f81613715565b91505061276e565b50929392505050565b606060008085516000036128cc575084915060009050806106d8565b60005b85831080156128dd57508482105b80156128e95750865181105b1561295c57868181518110612900576129006136b7565b602002602001015160200151600001518361291b91906139f4565b925086818151811061292f5761292f6136b7565b602002602001015160200151602001518261294a91906139f4565b915061295581613715565b90506128cf565b6000805b61296b60018461379f565b811015612aa157600061297f8260016139f4565b90505b83811015612a905789818151811061299c5761299c6136b7565b6020026020010151600001516000015173ffffffffffffffffffffffffffffffffffffffff168a83815181106129d4576129d46136b7565b6020026020010151600001516000015173ffffffffffffffffffffffffffffffffffffffff1603612a8057898281518110612a1157612a116136b7565b6020026020010151602001516040015115612a4e5760008a8281518110612a3a57612a3a6136b7565b602090810291909101810151015152612a72565b60008a8381518110612a6257612a626136b7565b6020908102919091018101510151525b82612a7c81613715565b9350505b612a8981613715565b9050612982565b50612a9a81613715565b9050612960565b508015612baf576000818951612ab7919061379f565b67ffffffffffffffff811115612acf57612acf6130d0565b604051908082528060200260200182016040528015612b0857816020015b612af5612c63565b815260200190600190039081612aed5790505b50955060005b8951811015612b955760008a8281518110612b2b57612b2b6136b7565b602002602001015160200151600001511115612b8557898181518110612b5357612b536136b7565b6020026020010151878381518110612b6d57612b6d6136b7565b602002602001018190525081612b8290613715565b91505b612b8e81613715565b9050612b0e565b50612ba18689896128b0565b9550955095505050506106d8565b8167ffffffffffffffff811115612bc857612bc86130d0565b604051908082528060200260200182016040528015612c0157816020015b612bee612c63565b815260200190600190039081612be65790505b50945060005b82811015612c5757888181518110612c2157612c216136b7565b6020026020010151868281518110612c3b57612c3b6136b7565b602002602001018190525080612c5090613715565b9050612c07565b50505093509350939050565b6040805160a08101825260009181018281526060820183905260808201929092529081908152602001612cb960405180608001604052806000815260200160008152602001600015158152602001600081525090565b905290565b612cf8828251805173ffffffffffffffffffffffffffffffffffffffff908116835260208083015182169084015260409182015116910152565b6020810151612d2d60608401828051825260208101516020830152604081015115156040830152606081015160608301525050565b505050565b600081518084526020808501945080840160005b83811015612d6c57612d59878351612cbe565b60e0969096019590820190600101612d46565b509495945050505050565b6020815260006110c06020830184612d32565b73ffffffffffffffffffffffffffffffffffffffff81168114612dac57600080fd5b50565b60008060008060608587031215612dc557600080fd5b843567ffffffffffffffff80821115612ddd57600080fd5b818701915087601f830112612df157600080fd5b813581811115612e0057600080fd5b88602060e083028501011115612e1557600080fd5b60209283019650945050850135612e2b81612d8a565b9396929550929360400135925050565b6000815180845260005b81811015612e6157602081850181015186830182015201612e45565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b604080825283519082018190526000906020906060840190828701845b82811015612eee57815173ffffffffffffffffffffffffffffffffffffffff1684529284019290840190600101612ebc565b50505083810382850152845180825282820190600581901b8301840187850160005b83811015612f5c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0868403018552612f4a838351612e3b565b94870194925090860190600101612f10565b50909998505050505050505050565b6020808252825182820181905260009190848201906040850190845b81811015612fdc57612fc9838551805173ffffffffffffffffffffffffffffffffffffffff908116835260208083015182169084015260409182015116910152565b9284019260609290920191600101612f87565b50909695505050505050565b600080600060608486031215612ffd57600080fd5b833561300881612d8a565b9250602084013561301881612d8a565b929592945050506040919091013590565b60608152600061303c6060830186612d32565b60208301949094525060400152919050565b600081518084526020808501945080840160005b83811015612d6c576130988783518051825260208101516020830152604081015115156040830152606081015160608301525050565b6080969096019590820190600101613062565b6040815260006130be604083018561304e565b8281036020840152610bfc818561304e565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff81118282101715613122576131226130d0565b60405290565b6040516080810167ffffffffffffffff81118282101715613122576131226130d0565b6040516101a0810167ffffffffffffffff81118282101715613122576131226130d0565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156131b6576131b66130d0565b604052919050565b600067ffffffffffffffff8211156131d8576131d86130d0565b5060051b60200190565b600060208083850312156131f557600080fd5b823567ffffffffffffffff81111561320c57600080fd5b8301601f8101851361321d57600080fd5b803561323061322b826131be565b61316f565b81815260059190911b8201830190838101908783111561324f57600080fd5b928401925b828410156110a657833561326781612d8a565b82529284019290840190613254565b60008083601f84011261328857600080fd5b50813567ffffffffffffffff8111156132a057600080fd5b6020830191508360208260051b85010111156132bb57600080fd5b9250929050565b600080600080604085870312156132d857600080fd5b843567ffffffffffffffff808211156132f057600080fd5b6132fc88838901613276565b9096509450602087013591508082111561331557600080fd5b5061332287828801613276565b95989497509550505050565b60006060828403121561334057600080fd5b6040516060810181811067ffffffffffffffff82111715613363576133636130d0565b604052905080823561337481612d8a565b8152602083013561338481612d8a565b6020820152604083013561339781612d8a565b6040919091015292915050565b803580151581146133b457600080fd5b919050565b60008060408084860312156133cd57600080fd5b833567ffffffffffffffff8111156133e457600080fd5b8401601f810186136133f557600080fd5b8035602061340561322b836131be565b82815260e0928302840182019282820191908a85111561342457600080fd5b948301945b848610156134d157858b03818112156134425760008081fd5b61344a6130ff565b6134548d8961332e565b815260606080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08501121561348a5760008081fd5b613492613128565b8a8301358152908a01358882015292506134ae60a08a016133a4565b838b015260c0890135908301528086019190915283529485019491830191613429565b509997909101359750505050505050565b600080604083850312156134f557600080fd5b823561350081612d8a565b9150602083013561351081612d8a565b809150509250929050565b600080600083850361012081121561353257600080fd5b60e081121561354057600080fd5b5083925060e084013561355281612d8a565b92959294505050610100919091013590565b73ffffffffffffffffffffffffffffffffffffffff831681526040602082015260006135936040830184612e3b565b949350505050565b6000602082840312156135ad57600080fd5b81356135b881612d8a565b9392505050565b825181526020808401518183015260408085015115158184015260608086015181850152845160808501529184015160a0840152830151151560c083015282015160e082015261010081016135b8565b60e081016110c38284612cbe565b6000602080838503121561363057600080fd5b823567ffffffffffffffff81111561364757600080fd5b8301601f8101851361365857600080fd5b803561366661322b826131be565b8181526060918202830184019184820191908884111561368557600080fd5b938501935b838510156136ab5761369c898661332e565b8352938401939185019161368a565b50979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203613746576137466136e6565b5060010190565b80820281158282048414176110c3576110c36136e6565b60008261379a577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b818103818111156110c3576110c36136e6565b6000602082840312156137c457600080fd5b6110c0826133a4565b80516133b481612d8a565b600060e082840312156137ea57600080fd5b60405160e0810181811067ffffffffffffffff8211171561380d5761380d6130d0565b604052825161381b81612d8a565b8152602083015161382b81612d8a565b6020820152604083015161383e81612d8a565b80604083015250606083015160608201526080830151608082015260a083015160a082015260c083015160c08201528091505092915050565b6000602080838503121561388a57600080fd5b825167ffffffffffffffff8111156138a157600080fd5b8301601f810185136138b257600080fd5b80516138c061322b826131be565b81815260059190911b820183019083810190878311156138df57600080fd5b928401925b828410156110a65783516138f781612d8a565b825292840192908401906138e4565b805160ff811681146133b457600080fd5b60006101a0828403121561392a57600080fd5b61393261314b565b61393b836137cd565b8152613949602084016137cd565b602082015261395a604084016137cd565b604082015261396b606084016137cd565b606082015261397c608084016137cd565b608082015261398d60a084016137cd565b60a082015261399e60c08401613906565b60c08201526139af60e08401613906565b60e08201526101008381015190820152610120808401519082015261014080840151908201526101608084015190820152610180928301519281019290925250919050565b808201808211156110c3576110c36136e6565b600060208284031215613a1957600080fd5b5051919050565b600081613a2f57613a2f6136e6565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019056fea2646970667358221220e00923e2fdee1f8fdc6d49f91a14562277ed9aa39b5dec3382e6f5eb60bb8ff464736f6c63430008150033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101985760003560e01c80637f3e2b48116100e35780639f5de8751161008c578063e082bca211610066578063e082bca2146103bb578063e979e874146103ce578063ed6bf8bc146103d657600080fd5b80639f5de87514610375578063aa822df614610395578063c5f8b2e5146103a857600080fd5b8063861d3ac4116100bd578063861d3ac4146103205780638651d5ec146103415780638953b9d61461035457600080fd5b80637f3e2b48146102ae5780638011ba33146102fa578063838fef5c1461030d57600080fd5b80635a980a9f116101455780636c8559621161011f5780636c855962146102755780637119484a146102885780637bfb86ff1461029b57600080fd5b80635a980a9f1461023c5780635e47ec031461024f57806365eb6bd41461026257600080fd5b8063404fcab211610176578063404fcab2146101f15780634296bdff146102135780634c6fdc1a1461022957600080fd5b806321d3b7f41461019d578063232306ea146101bb5780633c199241146101dc575b600080fd5b6101a56103e9565b6040516101b29190612d77565b60405180910390f35b6101ce6101c9366004612daf565b6103fb565b6040516101b2929190612e9f565b6101e4610541565b6040516101b29190612f6b565b6102046101ff366004612fe8565b6106b9565b6040516101b293929190613029565b61021b6106e1565b6040516101b29291906130ab565b61021b6102373660046131e2565b6106f7565b6101e461024a3660046132c2565b61086f565b61020461025d3660046133b9565b610b96565b610204610270366004612fe8565b610bd3565b6101a56102833660046132c2565b610beb565b6101a56102963660046131e2565b610c05565b6101a56102a93660046131e2565b610ea7565b6102d57f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101b2565b6101a56103083660046134e2565b6110b1565b6101a561031b3660046134e2565b6110c9565b61033361032e36600461351b565b6110d8565b6040516101b2929190613564565b61020461034f3660046133b9565b611311565b61036761036236600461359b565b611341565b6040516101b29291906135bf565b61038861038336600461359b565b6114df565b6040516101b2919061360f565b6101e46103a33660046134e2565b61157c565b6101a56103b63660046132c2565b611802565b6101a56103c936600461361d565b611813565b6101a5611ab6565b6101a56103e436600461361d565b611ac3565b60606103f66102a9611c26565b905090565b6060808467ffffffffffffffff811115610417576104176130d0565b604051908082528060200260200182016040528015610440578160200160208202803683370190505b5091508467ffffffffffffffff81111561045c5761045c6130d0565b60405190808252806020026020018201604052801561048f57816020015b606081526020019060019003908161047a5790505b50905060005b85811015610537576104bf8787838181106104b2576104b26136b7565b905060e0020186866110d8565b8483815181106104d1576104d16136b7565b602002602001018484815181106104ea576104ea6136b7565b602002602001018290528273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681525050508061053090613715565b9050610495565b5094509492505050565b6060600061054d611c26565b9050805167ffffffffffffffff811115610569576105696130d0565b6040519080825280602002602001820160405280156105d257816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9092019101816105875790505b50915060008060005b83518110156106b2576106068482815181106105f9576105f96136b7565b6020026020010151611ce4565b8093508194505050604051806060016040528085838151811061062b5761062b6136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018473ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff16815250858281518110610696576106966136b7565b6020026020010181905250806106ab90613715565b90506105db565b5050505090565b60606000806106d16106cb87876110c9565b85610b96565b9250925092505b93509350939050565b6060806106ef610237611c26565b915091509091565b606080825167ffffffffffffffff811115610714576107146130d0565b60405190808252806020026020018201604052801561077257816020015b61075f60405180608001604052806000815260200160008152602001600015158152602001600081525090565b8152602001906001900390816107325790505b509150825167ffffffffffffffff81111561078f5761078f6130d0565b6040519080825280602002602001820160405280156107ed57816020015b6107da60405180608001604052806000815260200160008152602001600015158152602001600081525090565b8152602001906001900390816107ad5790505b50905060005b83518110156108695761081e848281518110610811576108116136b7565b6020026020010151611341565b848381518110610830576108306136b7565b60200260200101848481518110610849576108496136b7565b6020026020010182905282905250508061086290613715565b90506107f3565b50915091565b6060600061087d838661374d565b67ffffffffffffffff811115610895576108956130d0565b6040519080825280602002602001820160405280156108fe57816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9092019101816108b35790505b509050600061090b611c26565b90506000806000805b8451811015610ab8576109328582815181106105f9576105f96136b7565b909350915060005b8a811015610aaf5760005b89811015610aa6578c8c8381811061095f5761095f6136b7565b9050602002016020810190610974919061359b565b73ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff161480156109ff57508a8a828181106109bb576109bb6136b7565b90506020020160208101906109d0919061359b565b73ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16145b15610a9e576040518060600160405280888581518110610a2157610a216136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff16815250888781518110610a8c57610a8c6136b7565b60200260200101819052508560010195505b600101610945565b5060010161093a565b50600101610914565b508267ffffffffffffffff811115610ad257610ad26130d0565b604051908082528060200260200182016040528015610b3b57816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff909201910181610af05790505b50955060005b83811015610b8857858181518110610b5b57610b5b6136b7565b6020026020010151878281518110610b7557610b756136b7565b6020908102919091010152600101610b41565b505050505050949350505050565b6060600080610bc685857fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff611d6f565b9250925092509250925092565b60606000806106d1610be587876110c9565b85611311565b6060610bfc6103c98686868661086f565b95945050505050565b6060600080835160020267ffffffffffffffff811115610c2757610c276130d0565b604051908082528060200260200182016040528015610c6057816020015b610c4d612c63565b815260200190600190039081610c455790505b509050610c9060405180608001604052806000815260200160008152602001600015158152602001600081525090565b610cbd60405180608001604052806000815260200160008152602001600015158152602001600081525090565b60008060005b8851811015610e9057610ce1898281518110610811576108116136b7565b8051919650945015610e88578451845160019098019703610d055760008452610d13565b845115610d13578660010196505b610d288982815181106105f9576105f96136b7565b8093508194505050604051806040016040528060405180606001604052808c8581518110610d5857610d586136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff16815250815260200186815250868260020281518110610dcf57610dcf6136b7565b6020026020010181905250604051806040016040528060405180606001604052808c8581518110610e0257610e026136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff16815250815260200185815250868260020260010181518110610e7c57610e7c6136b7565b60200260200101819052505b600101610cc3565b50610e9b858761239a565b98975050505050505050565b6060600080835167ffffffffffffffff811115610ec657610ec66130d0565b604051908082528060200260200182016040528015610eff57816020015b610eec612c63565b815260200190600190039081610ee45790505b509050610f2f60405180608001604052806000815260200160008152602001600015158152602001600081525090565b610f5c60405180608001604052806000815260200160008152602001600015158152602001600081525090565b610f64612c63565b60005b875181101561109b57610f85888281518110610811576108116136b7565b8094508195505050604051806040016040528060405180606001604052808b8581518110610fb557610fb56136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff16815250815260200161101f8686612476565b9052602081015151909250156110935785600101955061104a8882815181106105f9576105f96136b7565b835173ffffffffffffffffffffffffffffffffffffffff9182166040820152911660209091015284518290869083908110611087576110876136b7565b60200260200101819052505b600101610f67565b506110a6848661239a565b979650505050505050565b60606110c06103e4848461157c565b90505b92915050565b60606110c06103c9848461157c565b60006060816110ea602087018761359b565b73ffffffffffffffffffffffffffffffffffffffff161480611120575073ffffffffffffffffffffffffffffffffffffffff8416155b15611157576040517ff267e74000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b620f42408310158061116b57506060850135155b8061117857506080850135155b156111af576040517fb55de08000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600060608601356111cc6080880135670de0b6b3a764000061374d565b6111d69190613764565b9050620f42406111e6858261379f565b6111f0908361374d565b6111fa9190613764565b9050611209602087018761359b565b507f8433ea22000000000000000000000000000000000000000000000000000000006060870135828761124260c08b0160a08c016137b2565b6040516024810194909452604484019290925273ffffffffffffffffffffffffffffffffffffffff1660648301521515608482015260a401604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052602080820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009094169390931790925292506113069087018761359b565b925050935093915050565b6060600080610bc6857fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff86611d6f565b61136e60405180608001604052806000815260200160008152602001600015158152602001600081525090565b61139b60405180608001604052806000815260200160008152602001600015158152602001600081525090565b6040517f1fcd364900000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8481166004830152600060248301819052917f000000000000000000000000000000000000000000000000000000000000000090911690631fcd36499060440160e0604051808303816000875af1158015611435573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061145991906137d8565b905060405180608001604052808260600151815260200182608001518152602001600015158152602001611495836060015184608001516124f7565b815250925060405180608001604052808260a0015181526020018260c0015181526020016001151581526020016114d48360a001518460c001516124f7565b815250915050915091565b6114e7612c63565b73ffffffffffffffffffffffffffffffffffffffff821661150757919050565b60008061151384611ce4565b9150915060008061152386611341565b6040805160a08101825273ffffffffffffffffffffffffffffffffffffffff808b169282019283528881166060830152871660808201529081529193509150602081016115708484612476565b90529695505050505050565b60606000611588611c26565b9050600080825167ffffffffffffffff8111156115a7576115a76130d0565b6040519080825280602002602001820160405280156115d0578160200160208202803683370190505b50905060008060005b85518110156116c1576115f78682815181106105f9576105f96136b7565b909350915073ffffffffffffffffffffffffffffffffffffffff808416908a1614801561164f57508773ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b156116b157858181518110611666576116666136b7565b6020026020010151848681518110611680576116806136b7565b73ffffffffffffffffffffffffffffffffffffffff909216602092830291909101909101526116ae85613715565b94505b6116ba81613715565b90506115d9565b508367ffffffffffffffff8111156116db576116db6130d0565b60405190808252806020026020018201604052801561174457816020015b60408051606081018252600080825260208083018290529282015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9092019101816116f95790505b50955060005b848110156117f657604051806060016040528085838151811061176f5761176f6136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1681526020018a73ffffffffffffffffffffffffffffffffffffffff1681526020018973ffffffffffffffffffffffffffffffffffffffff168152508782815181106117da576117da6136b7565b6020026020010181905250806117ef90613715565b905061174a565b50505050505092915050565b6060610bfc6103e48686868661086f565b60606000825160020267ffffffffffffffff811115611834576118346130d0565b60405190808252806020026020018201604052801561186d57816020015b61185a612c63565b8152602001906001900390816118525790505b509050600061189f60405180608001604052806000815260200160008152602001600015158152602001600081525090565b6118cc60405180608001604052806000815260200160008152602001600015158152602001600081525090565b60005b86518110156119d8576118fe8782815181106118ed576118ed6136b7565b602002602001015160000151611341565b80519194509250156119d05782518251600190950194036119225760008252611930565b825115611930578360010193505b604051806040016040528088838151811061194d5761194d6136b7565b6020026020010151815260200184815250858260020281518110611973576119736136b7565b6020026020010181905250604051806040016040528088838151811061199b5761199b6136b7565b60200260200101518152602001838152508582600202600101815181106119c4576119c46136b7565b60200260200101819052505b6001016118cf565b508267ffffffffffffffff8111156119f2576119f26130d0565b604051908082528060200260200182016040528015611a2b57816020015b611a18612c63565b815260200190600190039081611a105790505b5094506000805b8551811015611aab576000868281518110611a4f57611a4f6136b7565b602002602001015160200151600001511115611aa357858181518110611a7757611a776136b7565b6020026020010151878381518110611a9157611a916136b7565b60200260200101819052508160010191505b600101611a32565b505050505050919050565b60606103f6610296611c26565b60606000825167ffffffffffffffff811115611ae157611ae16130d0565b604051908082528060200260200182016040528015611b1a57816020015b611b07612c63565b815260200190600190039081611aff5790505b5090506000611b27612c63565b611b5460405180608001604052806000815260200160008152602001600015158152602001600081525090565b611b8160405180608001604052806000815260200160008152602001600015158152602001600081525090565b60005b8751811015611c1b57611ba28882815181106118ed576118ed6136b7565b80935081945050506040518060400160405280898381518110611bc757611bc76136b7565b60200260200101518152602001611bde8585612476565b905260208101515190945015611c135784600101945083868281518110611c0757611c076136b7565b60200260200101819052505b600101611b84565b506110a6858561239a565b60606103f67f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a8d9f4936040518163ffffffff1660e01b8152600401600060405180830381865afa158015611c96573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052611cdc9190810190613877565b61271061252a565b60008060008373ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b81526004016101a060405180830381865afa158015611d35573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d599190613917565b90508060a0015181608001519250925050915091565b6060600080611d7d8661275f565b9550611d8a8686866128b0565b9194509250905084821180611d9e57508381115b156106d857600060018451611db3919061379f565b9050600086841115611e0857611dc9878561379f565b858381518110611ddb57611ddb6136b7565b602002602001015160200151600001516001611df791906139f4565b611e01919061379f565b9050612094565b6000611e14878561379f565b868481518110611e2657611e266136b7565b60200260200101516020015160200151611e40919061379f565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631fcd3649888681518110611e9257611e926136b7565b602090810291909101015151516040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff90911660048201526000602482015260440160e0604051808303816000875af1158015611f11573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f3591906137d8565b90506000611f4b826060015183608001516124f7565b90506000611f7f83606001518460a00151611f66919061379f565b84608001518560c00151611f7a919061379f565b6124f7565b905081811180611f925750838360800151105b1561206057600083608001518460c00151611fad919061379f565b9050848110611fe95781611fcd866b033b2e3c9fd0803ce800000061374d565b611fd79190613764565b611fe29060016139f4565b955061205a565b81612000826b033b2e3c9fd0803ce800000061374d565b61200a9190613764565b6120159060016139f4565b955082612022828761379f565b612038906b033b2e3c9fd0803ce800000061374d565b6120429190613764565b61204d9060016139f4565b61205790876139f4565b95505b5061208f565b81612077856b033b2e3c9fd0803ce800000061374d565b6120819190613764565b61208c9060016139f4565b94505b505050505b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16631fcd36498785815181106120e4576120e46136b7565b602090810291909101015151516040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff90911660048201526024810185905260440160e0604051808303816000875af1158015612163573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061218791906137d8565b905085838151811061219b5761219b6136b7565b60200260200101516020015160000151856121b6919061379f565b94508583815181106121ca576121ca6136b7565b60200260200101516020015160200151846121e5919061379f565b93508583815181106121f9576121f96136b7565b60200260200101516020015160400151156122a1578060a00151868481518110612225576122256136b7565b60200260200101516020015160000181815250508060c00151868481518110612250576122506136b7565b60200260200101516020015160200181815250506122768160a001518260c001516124f7565b868481518110612288576122886136b7565b6020026020010151602001516060018181525050612330565b80606001518684815181106122b8576122b86136b7565b602002602001015160200151600001818152505080608001518684815181106122e3576122e36136b7565b6020026020010151602001516020018181525050612309816060015182608001516124f7565b86848151811061231b5761231b6136b7565b60200260200101516020015160600181815250505b858381518110612342576123426136b7565b602002602001015160200151600001518561235d91906139f4565b9450858381518110612371576123716136b7565b602002602001015160200151602001518461238c91906139f4565b935050505093509350939050565b60608167ffffffffffffffff8111156123b5576123b56130d0565b6040519080825280602002602001820160405280156123ee57816020015b6123db612c63565b8152602001906001900390816123d35790505b5090506000805b845181101561246e576000858281518110612412576124126136b7565b6020026020010151602001516000015111156124665784818151811061243a5761243a6136b7565b6020026020010151838381518110612454576124546136b7565b60200260200101819052508160010191505b6001016123f5565b505092915050565b6124a360405180608001604052806000815260200160008152602001600015158152602001600081525090565b81516000036124b35750806110c3565b8260600151826060015111156124ca5750806110c3565b82606001518260600151036124f05782518251036124e95750816110c3565b50806110c3565b5090919050565b600081600003612509575060006110c3565b82612520836b033b2e3c9fd0803ce800000061374d565b6110c09190613764565b8151606090600090815b85518110156126405785818151811061254f5761254f6136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1663bb24fe8a6040518163ffffffff1660e01b8152600401602060405180830381865afa9250505080156125db575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526125d891810190613a07565b60015b6125e95761271092506125ec565b92505b848314612638576000868281518110612607576126076136b7565b73ffffffffffffffffffffffffffffffffffffffff9092166020928302919091019091015261263582613a20565b91505b600101612534565b508067ffffffffffffffff81111561265a5761265a6130d0565b604051908082528060200260200182016040528015612683578160200160208202803683370190505b5092506000805b865181101561275557600073ffffffffffffffffffffffffffffffffffffffff168782815181106126bd576126bd6136b7565b602002602001015173ffffffffffffffffffffffffffffffffffffffff161461274d578681815181106126f2576126f26136b7565b602002602001015185838151811061270c5761270c6136b7565b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508160010191505b60010161268a565b5050505092915050565b6060600061276b612c63565b60015b84518110156128a7576000925060005b81865161278b919061379f565b811015612886578581815181106127a4576127a46136b7565b60200260200101516020015160600151868260016127c291906139f4565b815181106127d2576127d26136b7565b602002602001015160200151606001511115612874578581815181106127fa576127fa6136b7565b602002602001015192508581600161281291906139f4565b81518110612822576128226136b7565b602002602001015186828151811061283c5761283c6136b7565b602090810291909101015282866128548360016139f4565b81518110612864576128646136b7565b6020026020010181905250600193505b8061287e81613715565b91505061277e565b50826128955750929392505050565b8061289f81613715565b91505061276e565b50929392505050565b606060008085516000036128cc575084915060009050806106d8565b60005b85831080156128dd57508482105b80156128e95750865181105b1561295c57868181518110612900576129006136b7565b602002602001015160200151600001518361291b91906139f4565b925086818151811061292f5761292f6136b7565b602002602001015160200151602001518261294a91906139f4565b915061295581613715565b90506128cf565b6000805b61296b60018461379f565b811015612aa157600061297f8260016139f4565b90505b83811015612a905789818151811061299c5761299c6136b7565b6020026020010151600001516000015173ffffffffffffffffffffffffffffffffffffffff168a83815181106129d4576129d46136b7565b6020026020010151600001516000015173ffffffffffffffffffffffffffffffffffffffff1603612a8057898281518110612a1157612a116136b7565b6020026020010151602001516040015115612a4e5760008a8281518110612a3a57612a3a6136b7565b602090810291909101810151015152612a72565b60008a8381518110612a6257612a626136b7565b6020908102919091018101510151525b82612a7c81613715565b9350505b612a8981613715565b9050612982565b50612a9a81613715565b9050612960565b508015612baf576000818951612ab7919061379f565b67ffffffffffffffff811115612acf57612acf6130d0565b604051908082528060200260200182016040528015612b0857816020015b612af5612c63565b815260200190600190039081612aed5790505b50955060005b8951811015612b955760008a8281518110612b2b57612b2b6136b7565b602002602001015160200151600001511115612b8557898181518110612b5357612b536136b7565b6020026020010151878381518110612b6d57612b6d6136b7565b602002602001018190525081612b8290613715565b91505b612b8e81613715565b9050612b0e565b50612ba18689896128b0565b9550955095505050506106d8565b8167ffffffffffffffff811115612bc857612bc86130d0565b604051908082528060200260200182016040528015612c0157816020015b612bee612c63565b815260200190600190039081612be65790505b50945060005b82811015612c5757888181518110612c2157612c216136b7565b6020026020010151868281518110612c3b57612c3b6136b7565b602002602001018190525080612c5090613715565b9050612c07565b50505093509350939050565b6040805160a08101825260009181018281526060820183905260808201929092529081908152602001612cb960405180608001604052806000815260200160008152602001600015158152602001600081525090565b905290565b612cf8828251805173ffffffffffffffffffffffffffffffffffffffff908116835260208083015182169084015260409182015116910152565b6020810151612d2d60608401828051825260208101516020830152604081015115156040830152606081015160608301525050565b505050565b600081518084526020808501945080840160005b83811015612d6c57612d59878351612cbe565b60e0969096019590820190600101612d46565b509495945050505050565b6020815260006110c06020830184612d32565b73ffffffffffffffffffffffffffffffffffffffff81168114612dac57600080fd5b50565b60008060008060608587031215612dc557600080fd5b843567ffffffffffffffff80821115612ddd57600080fd5b818701915087601f830112612df157600080fd5b813581811115612e0057600080fd5b88602060e083028501011115612e1557600080fd5b60209283019650945050850135612e2b81612d8a565b9396929550929360400135925050565b6000815180845260005b81811015612e6157602081850181015186830182015201612e45565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b604080825283519082018190526000906020906060840190828701845b82811015612eee57815173ffffffffffffffffffffffffffffffffffffffff1684529284019290840190600101612ebc565b50505083810382850152845180825282820190600581901b8301840187850160005b83811015612f5c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0868403018552612f4a838351612e3b565b94870194925090860190600101612f10565b50909998505050505050505050565b6020808252825182820181905260009190848201906040850190845b81811015612fdc57612fc9838551805173ffffffffffffffffffffffffffffffffffffffff908116835260208083015182169084015260409182015116910152565b9284019260609290920191600101612f87565b50909695505050505050565b600080600060608486031215612ffd57600080fd5b833561300881612d8a565b9250602084013561301881612d8a565b929592945050506040919091013590565b60608152600061303c6060830186612d32565b60208301949094525060400152919050565b600081518084526020808501945080840160005b83811015612d6c576130988783518051825260208101516020830152604081015115156040830152606081015160608301525050565b6080969096019590820190600101613062565b6040815260006130be604083018561304e565b8281036020840152610bfc818561304e565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff81118282101715613122576131226130d0565b60405290565b6040516080810167ffffffffffffffff81118282101715613122576131226130d0565b6040516101a0810167ffffffffffffffff81118282101715613122576131226130d0565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156131b6576131b66130d0565b604052919050565b600067ffffffffffffffff8211156131d8576131d86130d0565b5060051b60200190565b600060208083850312156131f557600080fd5b823567ffffffffffffffff81111561320c57600080fd5b8301601f8101851361321d57600080fd5b803561323061322b826131be565b61316f565b81815260059190911b8201830190838101908783111561324f57600080fd5b928401925b828410156110a657833561326781612d8a565b82529284019290840190613254565b60008083601f84011261328857600080fd5b50813567ffffffffffffffff8111156132a057600080fd5b6020830191508360208260051b85010111156132bb57600080fd5b9250929050565b600080600080604085870312156132d857600080fd5b843567ffffffffffffffff808211156132f057600080fd5b6132fc88838901613276565b9096509450602087013591508082111561331557600080fd5b5061332287828801613276565b95989497509550505050565b60006060828403121561334057600080fd5b6040516060810181811067ffffffffffffffff82111715613363576133636130d0565b604052905080823561337481612d8a565b8152602083013561338481612d8a565b6020820152604083013561339781612d8a565b6040919091015292915050565b803580151581146133b457600080fd5b919050565b60008060408084860312156133cd57600080fd5b833567ffffffffffffffff8111156133e457600080fd5b8401601f810186136133f557600080fd5b8035602061340561322b836131be565b82815260e0928302840182019282820191908a85111561342457600080fd5b948301945b848610156134d157858b03818112156134425760008081fd5b61344a6130ff565b6134548d8961332e565b815260606080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08501121561348a5760008081fd5b613492613128565b8a8301358152908a01358882015292506134ae60a08a016133a4565b838b015260c0890135908301528086019190915283529485019491830191613429565b509997909101359750505050505050565b600080604083850312156134f557600080fd5b823561350081612d8a565b9150602083013561351081612d8a565b809150509250929050565b600080600083850361012081121561353257600080fd5b60e081121561354057600080fd5b5083925060e084013561355281612d8a565b92959294505050610100919091013590565b73ffffffffffffffffffffffffffffffffffffffff831681526040602082015260006135936040830184612e3b565b949350505050565b6000602082840312156135ad57600080fd5b81356135b881612d8a565b9392505050565b825181526020808401518183015260408085015115158184015260608086015181850152845160808501529184015160a0840152830151151560c083015282015160e082015261010081016135b8565b60e081016110c38284612cbe565b6000602080838503121561363057600080fd5b823567ffffffffffffffff81111561364757600080fd5b8301601f8101851361365857600080fd5b803561366661322b826131be565b8181526060918202830184019184820191908884111561368557600080fd5b938501935b838510156136ab5761369c898661332e565b8352938401939185019161368a565b50979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203613746576137466136e6565b5060010190565b80820281158282048414176110c3576110c36136e6565b60008261379a577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b818103818111156110c3576110c36136e6565b6000602082840312156137c457600080fd5b6110c0826133a4565b80516133b481612d8a565b600060e082840312156137ea57600080fd5b60405160e0810181811067ffffffffffffffff8211171561380d5761380d6130d0565b604052825161381b81612d8a565b8152602083015161382b81612d8a565b6020820152604083015161383e81612d8a565b80604083015250606083015160608201526080830151608082015260a083015160a082015260c083015160c08201528091505092915050565b6000602080838503121561388a57600080fd5b825167ffffffffffffffff8111156138a157600080fd5b8301601f810185136138b257600080fd5b80516138c061322b826131be565b81815260059190911b820183019083810190878311156138df57600080fd5b928401925b828410156110a65783516138f781612d8a565b825292840192908401906138e4565b805160ff811681146133b457600080fd5b60006101a0828403121561392a57600080fd5b61393261314b565b61393b836137cd565b8152613949602084016137cd565b602082015261395a604084016137cd565b604082015261396b606084016137cd565b606082015261397c608084016137cd565b608082015261398d60a084016137cd565b60a082015261399e60c08401613906565b60c08201526139af60e08401613906565b60e08201526101008381015190820152610120808401519082015261014080840151908201526101608084015190820152610180928301519281019290925250919050565b808201808211156110c3576110c36136e6565b600060208284031215613a1957600080fd5b5051919050565b600081613a2f57613a2f6136e6565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019056fea2646970667358221220e00923e2fdee1f8fdc6d49f91a14562277ed9aa39b5dec3382e6f5eb60bb8ff464736f6c63430008150033",
  "devdoc": {
    "details": "Note that on the same protocol, if \"withAbsorb = true\" is executed, this also consumes the swap         that would be on the same protocol with \"withAbsorb = false\". So the total available swap amount         at a protocol if both a swap with and without absorb is available is not `with inAmt + without inAmt`         but rather `with inAmt`.         Sometimes with absorb can provide better swaps, sometimes without absorb can provide better swaps.         But available liquidity for \"withAbsorb\" amounts will always be >= without absorb amounts.The \"Raw\" methods return both the with and without absorb swaps for the same Fluid Vault, the non-\"Raw\"         methods automatically filter by the better ratio swap. For same cases a better optimization of ratios         is possible with custom logic based on the \"Raw\" methods, see details in comments.for native token, send 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE.returned swaps Struct can be fed into `getSwapTx` to prepare the tx that executes the swaps.non-view methods in this contract are expected to be called with callStatic,         although they would anyway not do any actual state changes.",
    "kind": "dev",
    "methods": {
      "approxOutput(address,address,uint256)": {
        "details": "The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better but the target swap amount is more than the available without absorb liquidity. For this currently the available withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity. The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing amount up to the target amount with the worse ratio with absorb liquidity.",
        "params": {
          "outAmt_": "exact output token amount that should be swapped to from input token",
          "tokenIn_": "input token",
          "tokenOut_": "output token"
        },
        "returns": {
          "approxOutAmt_": "approximate output token amount. Can be less than `outAmt_` if all available swaps can not cover                       the target amount.",
          "inAmt_": "input token amount needed to receive `actualOutAmt_`",
          "swaps_": "swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on."
        }
      },
      "exactInput(address,address,uint256)": {
        "details": "The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better but the target swap amount is more than the available without absorb liquidity. For this, currently the available withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity. The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing amount up to the target amount with the worse ratio with absorb liquidity.",
        "params": {
          "inAmt_": "exact input token amount that should be swapped to output token",
          "tokenIn_": "input token",
          "tokenOut_": "output token"
        },
        "returns": {
          "actualInAmt_": "actual input token amount. Can be less than inAmt_ if all available swaps can not cover                      the target amount.",
          "outAmt_": "output token amount received for `actualInAmt_`",
          "swaps_": "swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on."
        }
      },
      "filterToApproxOutAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)": {
        "returns": {
          "actualInAmt_": "actual input amount.",
          "approxOutAmt_": "APPROXIMATE actual output amount. Can be less than targetOutAmt_ if all available swaps                      can not cover the target amount.",
          "filteredSwaps_": "swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on."
        }
      },
      "filterToTargetInAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)": {
        "returns": {
          "actualInAmt_": "actual input amount. Can be less than targetInAmt_ if all available swaps can not cover                      the target amount.",
          "approxOutAmt_": "actual estimated output amount.",
          "filteredSwaps_": "swaps to reach the target amount, sorted by ratio in descending order         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on."
        }
      },
      "getSwapTx(((address,address,address),(uint256,uint256,bool,uint256)),address,uint256)": {
        "params": {
          "receiver_": "receiver address that the output token is sent to",
          "slippage_": "maximum allowed slippage for the expected output token amount. Reverts iIf received token out                  amount is lower than this. in 1e4 percentage, e.g. 1% = 10000, 0.3% = 3000, 0.01% = 100, 0.0001% = 1.",
          "swap_": "Swap struct as returned by other methods"
        },
        "returns": {
          "calldata_": "the calldata that can be used to trigger the liquidation call, resulting in the desired swap.",
          "target_": "target address where `calldata_` must be executed"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "FluidVaultLiquidationsResolver__AddressZero()": [
        {
          "notice": "thrown if an input param address is zero"
        }
      ],
      "FluidVaultLiquidationsResolver__InvalidParams()": [
        {
          "notice": "thrown if an invalid param is given to a method"
        }
      ]
    },
    "kind": "user",
    "methods": {
      "approxOutput(address,address,uint256)": {
        "notice": "finds all swaps from `tokenIn_` to `tokenOut_` for an APPROXIMATE output amount `outAmt_`.         filters the available swaps and sorts them by ratio, so the returned swaps are the best available         swaps to reach the target `outAmt_`.         If the full available amount is less than the target `outAmt_`, the available amount is returned as `actualOutAmt_`.         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to         approximately estimate the required input amounts to reach a certain output amount. This         will change until execution and should be controlled with a maximum slippage.         Recommended to use exact input methods instead."
      },
      "constructor": {
        "notice": "constructor sets the immutable vault resolver address"
      },
      "exactInput(address,address,uint256)": {
        "notice": "finds all swaps from `tokenIn_` to `tokenOut_` for an exact input amount `inAmt_`.         filters the available swaps and sorts them by ratio, so the returned swaps are the best available         swaps to reach the target `inAmt_`.         If the full available amount is less than the target `inAmt_`, the available amount is returned as `actualInAmt_`."
      },
      "filterToApproxOutAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)": {
        "notice": "filters the `swaps_` to the point where APPROXIMATELY `targetOutAmt_` is reached.         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to         approximately estimate the required input amounts to reach a certain output amount. This         will change until execution and should be controlled with a maximum slippage.         Recommended to use exact input methods instead.         This is best used in combination with the \"Raw\" methods, as the `targetInAmt_` allows for more optimized         filtering than otherwise done with the non-\"Raw\" methods."
      },
      "filterToTargetInAmt(((address,address,address),(uint256,uint256,bool,uint256))[],uint256)": {
        "notice": "filters the `swaps_` to the point where `targetInAmt_` is reached.         This is best used in combination with the \"Raw\" methods, as the `targetInAmt_` allows for more optimized         filtering than otherwise done with the non-\"Raw\" methods."
      },
      "getAllSwapPaths()": {
        "notice": "returns all available token swap paths"
      },
      "getAllVaultsSwap()": {
        "notice": "returns all available `swaps_` for all Fluid vaults. Only returns non-zero swaps.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio."
      },
      "getAllVaultsSwapData()": {
        "notice": "returns the swap data for with and without absorb for all Fluid vaults."
      },
      "getAllVaultsSwapRaw()": {
        "notice": "returns all available `swaps_` for all Fluid vaults raw. Only returns non-zero swaps.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault."
      },
      "getAnySwapPaths(address[],address[])": {
        "notice": "returns all available swap paths for any `tokensIn_` to any `tokensOut_`."
      },
      "getAnySwaps(address[],address[])": {
        "notice": "finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.         Token pairs that are not available or where available swap amounts are zero         will not be present in the returned `swaps_` array.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio."
      },
      "getAnySwapsRaw(address[],address[])": {
        "notice": "finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.         Token pairs that are not available or where available swap amounts are zero         will not be present in the returned `swaps_` array.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault."
      },
      "getSwapForProtocol(address)": {
        "notice": "returns the available swap amounts at a certain `protocol_`. Only returns non-zero swaps.         For vault protocol considering both a swap that uses liquidation with absorb and without absorb."
      },
      "getSwapPaths(address,address)": {
        "notice": "returns all swap paths for a certain `tokenIn_` swapped to a `tokenOut_`.         returns empty array if no swap path is available for a given pair."
      },
      "getSwapTx(((address,address,address),(uint256,uint256,bool,uint256)),address,uint256)": {
        "notice": "returns the calldata to execute a swap as returned by the other methods in this contract.         `swap_.data.inAmt` must come from msg.sender, `swap_.data.outAmt` goes to `receiver_`. If the input token         is the native token, msg.value must be sent along when triggering the actual call with the returned calldata         which should be `swap_.data.inAmt`."
      },
      "getSwapTxs(((address,address,address),(uint256,uint256,bool,uint256))[],address,uint256)": {
        "notice": "returns the same data as `getSwapTx` for an array of input `swaps_` at once."
      },
      "getSwaps(address,address)": {
        "notice": "finds all available `swaps_` for `tokenIn_` to `tokenOut_`.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio."
      },
      "getSwapsForPaths((address,address,address)[])": {
        "notice": "returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio."
      },
      "getSwapsForPathsRaw((address,address,address)[])": {
        "notice": "returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault."
      },
      "getSwapsRaw(address,address)": {
        "notice": "finds all available `swaps_` for `tokenIn_` to `tokenOut_`.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault."
      },
      "getVaultSwapData(address)": {
        "notice": "returns the swap data for with and without absorb for a Fluid `vault_`."
      },
      "getVaultsSwap(address[])": {
        "notice": "returns all available `swaps_` for multiple Fluid `vaults_`. Only returns non-zero swaps.         returns only either the with absorb swap or without absorb swap for each vault, whichever has the         better ratio."
      },
      "getVaultsSwapData(address[])": {
        "notice": "returns the swap data for with and without absorb for multiple Fluid `vaults_`."
      },
      "getVaultsSwapRaw(address[])": {
        "notice": "returns all available `swaps_` for multiple Fluid `vaults_` raw. Only returns non-zero swaps.         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault."
      }
    },
    "notice": "Resolver contract that helps in finding available token swaps available in Fluid.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}