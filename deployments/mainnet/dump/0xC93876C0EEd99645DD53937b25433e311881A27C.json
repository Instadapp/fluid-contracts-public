{
  "address": "0xC93876C0EEd99645DD53937b25433e311881A27C",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "factory_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "liquidity_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "liquidityResolver_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "FACTORY",
      "outputs": [
        {
          "internalType": "contract IFluidDexFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "LIQUIDITY",
      "outputs": [
        {
          "internalType": "contract IFluidLiquidity",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "LIQUIDITY_RESOLVER",
      "outputs": [
        {
          "internalType": "contract IFluidLiquidityResolver",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "dex_",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "swap0to1_",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "amountIn_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountOutMin_",
          "type": "uint256"
        }
      ],
      "name": "estimateSwapIn",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountOut_",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "dex_",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "swap0to1_",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "amountOut_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountInMax_",
          "type": "uint256"
        }
      ],
      "name": "estimateSwapOut",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountIn_",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllPoolAddresses",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "pools_",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllPools",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "pool",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token0",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token1",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "fee",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.Pool[]",
          "name": "pools_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllPoolsReserves",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "pool",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token0",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token1",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "fee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "centerPrice",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "token0RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0ImaginaryReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1ImaginaryReserves",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IFluidDexT1.CollateralReserves",
              "name": "collateralReserves",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "token0Debt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1Debt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0ImaginaryReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1ImaginaryReserves",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IFluidDexT1.DebtReserves",
              "name": "debtReserves",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "withdrawableToken0",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "withdrawableToken1",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "borrowableToken0",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "borrowableToken1",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Structs.DexLimits",
              "name": "limits",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.PoolWithReserves[]",
          "name": "poolsReserves_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllPoolsReservesAdjusted",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "pool",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token0",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token1",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "fee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "centerPrice",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "token0RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0ImaginaryReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1ImaginaryReserves",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IFluidDexT1.CollateralReserves",
              "name": "collateralReserves",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "token0Debt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1Debt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0ImaginaryReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1ImaginaryReserves",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IFluidDexT1.DebtReserves",
              "name": "debtReserves",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "withdrawableToken0",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "withdrawableToken1",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "borrowableToken0",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "borrowableToken1",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Structs.DexLimits",
              "name": "limits",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.PoolWithReserves[]",
          "name": "poolsReserves_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "dex_",
          "type": "address"
        }
      ],
      "name": "getDexCollateralReserves",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "token0RealReserves",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token1RealReserves",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token0ImaginaryReserves",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token1ImaginaryReserves",
              "type": "uint256"
            }
          ],
          "internalType": "struct IFluidDexT1.CollateralReserves",
          "name": "reserves_",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "dex_",
          "type": "address"
        }
      ],
      "name": "getDexCollateralReservesAdjusted",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "token0RealReserves",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token1RealReserves",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token0ImaginaryReserves",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token1ImaginaryReserves",
              "type": "uint256"
            }
          ],
          "internalType": "struct IFluidDexT1.CollateralReserves",
          "name": "reserves_",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "dex_",
          "type": "address"
        }
      ],
      "name": "getDexDebtReserves",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "token0Debt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token1Debt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token0RealReserves",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token1RealReserves",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token0ImaginaryReserves",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token1ImaginaryReserves",
              "type": "uint256"
            }
          ],
          "internalType": "struct IFluidDexT1.DebtReserves",
          "name": "reserves_",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "dex_",
          "type": "address"
        }
      ],
      "name": "getDexDebtReservesAdjusted",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "token0Debt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token1Debt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token0RealReserves",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token1RealReserves",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token0ImaginaryReserves",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token1ImaginaryReserves",
              "type": "uint256"
            }
          ],
          "internalType": "struct IFluidDexT1.DebtReserves",
          "name": "reserves_",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "dex_",
          "type": "address"
        }
      ],
      "name": "getDexLimits",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "available",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandsTo",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandDuration",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.TokenLimit",
              "name": "withdrawableToken0",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "available",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandsTo",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandDuration",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.TokenLimit",
              "name": "withdrawableToken1",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "available",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandsTo",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandDuration",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.TokenLimit",
              "name": "borrowableToken0",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "available",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandsTo",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandDuration",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.TokenLimit",
              "name": "borrowableToken1",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.DexLimits",
          "name": "limits_",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "dex_",
          "type": "address"
        }
      ],
      "name": "getDexPricesAndExchangePrices",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "lastStoredPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "centerPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "upperRange",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "lowerRange",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "geometricMean",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "supplyToken0ExchangePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowToken0ExchangePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "supplyToken1ExchangePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowToken1ExchangePrice",
              "type": "uint256"
            }
          ],
          "internalType": "struct IFluidDexT1.PricesAndExchangePrice",
          "name": "pex_",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "poolId_",
          "type": "uint256"
        }
      ],
      "name": "getPool",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "pool",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token0",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token1",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "fee",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.Pool",
          "name": "pool_",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "poolId_",
          "type": "uint256"
        }
      ],
      "name": "getPoolAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "pool_",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool_",
          "type": "address"
        }
      ],
      "name": "getPoolConstantsView",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "dexId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "liquidity",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "factory",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "shift",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "admin",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "colOperations",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "debtOperations",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "perfectOperationsAndOracle",
                  "type": "address"
                }
              ],
              "internalType": "struct IFluidDexT1.Implementations",
              "name": "implementations",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "deployerContract",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token0",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token1",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "supplyToken0Slot",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "borrowToken0Slot",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "supplyToken1Slot",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "borrowToken1Slot",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "exchangePriceToken0Slot",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "exchangePriceToken1Slot",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "oracleMapping",
              "type": "uint256"
            }
          ],
          "internalType": "struct IFluidDexT1.ConstantViews",
          "name": "constantsView_",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool_",
          "type": "address"
        }
      ],
      "name": "getPoolConstantsView2",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "token0NumeratorPrecision",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token0DenominatorPrecision",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token1NumeratorPrecision",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "token1DenominatorPrecision",
              "type": "uint256"
            }
          ],
          "internalType": "struct IFluidDexT1.ConstantViews2",
          "name": "constantsView2_",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool_",
          "type": "address"
        }
      ],
      "name": "getPoolFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "fee_",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool_",
          "type": "address"
        }
      ],
      "name": "getPoolReserves",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "pool",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token0",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token1",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "fee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "centerPrice",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "token0RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0ImaginaryReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1ImaginaryReserves",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IFluidDexT1.CollateralReserves",
              "name": "collateralReserves",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "token0Debt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1Debt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0ImaginaryReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1ImaginaryReserves",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IFluidDexT1.DebtReserves",
              "name": "debtReserves",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "withdrawableToken0",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "withdrawableToken1",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "borrowableToken0",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "borrowableToken1",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Structs.DexLimits",
              "name": "limits",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.PoolWithReserves",
          "name": "poolReserves_",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool_",
          "type": "address"
        }
      ],
      "name": "getPoolReservesAdjusted",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "pool",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token0",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token1",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "fee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "centerPrice",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "token0RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0ImaginaryReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1ImaginaryReserves",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IFluidDexT1.CollateralReserves",
              "name": "collateralReserves",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "token0Debt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1Debt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0ImaginaryReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1ImaginaryReserves",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IFluidDexT1.DebtReserves",
              "name": "debtReserves",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "withdrawableToken0",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "withdrawableToken1",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "borrowableToken0",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "borrowableToken1",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Structs.DexLimits",
              "name": "limits",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.PoolWithReserves",
          "name": "poolReserves_",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool_",
          "type": "address"
        }
      ],
      "name": "getPoolTokens",
      "outputs": [
        {
          "internalType": "address",
          "name": "token0_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "token1_",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "pools_",
          "type": "address[]"
        }
      ],
      "name": "getPoolsReserves",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "pool",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token0",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token1",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "fee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "centerPrice",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "token0RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0ImaginaryReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1ImaginaryReserves",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IFluidDexT1.CollateralReserves",
              "name": "collateralReserves",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "token0Debt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1Debt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0ImaginaryReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1ImaginaryReserves",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IFluidDexT1.DebtReserves",
              "name": "debtReserves",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "withdrawableToken0",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "withdrawableToken1",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "borrowableToken0",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "borrowableToken1",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Structs.DexLimits",
              "name": "limits",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.PoolWithReserves[]",
          "name": "poolsReserves_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "pools_",
          "type": "address[]"
        }
      ],
      "name": "getPoolsReservesAdjusted",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "pool",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token0",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token1",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "fee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "centerPrice",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "token0RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0ImaginaryReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1ImaginaryReserves",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IFluidDexT1.CollateralReserves",
              "name": "collateralReserves",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "token0Debt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1Debt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1RealReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token0ImaginaryReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "token1ImaginaryReserves",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IFluidDexT1.DebtReserves",
              "name": "debtReserves",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "withdrawableToken0",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "withdrawableToken1",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "borrowableToken0",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "available",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandsTo",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expandDuration",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Structs.TokenLimit",
                  "name": "borrowableToken1",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Structs.DexLimits",
              "name": "limits",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.PoolWithReserves[]",
          "name": "poolsReserves_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTotalPools",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x1b4456ab71dfd15a56d64a33dbf9ec012083bbdbe3570b4e3b68dbe2012c4300",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x0Ed35B1609Ec45c7079E80d11149a52717e4859A",
    "contractAddress": null,
    "transactionIndex": 69,
    "gasUsed": "5310764",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x8664636d382f53ef5a30f09208d07386aa0a432a588395e60d1977111993135a",
    "transactionHash": "0x1b4456ab71dfd15a56d64a33dbf9ec012083bbdbe3570b4e3b68dbe2012c4300",
    "logs": [],
    "blockNumber": 22487434,
    "cumulativeGasUsed": "12637328",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x91716C4EDA1Fb55e84Bf8b4c7085f84285c19085",
    "0x52Aa899454998Be5b000Ad077a46Bbe360F4e497",
    "0xF82111c4354622AB12b9803cD3F6164FCE52e847"
  ],
  "numDeployments": 9,
  "solcInputHash": "92006aa8d5c82aa58f83fd52d83a07f2",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidity_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityResolver_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"contract IFluidDexFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY\",\"outputs\":[{\"internalType\":\"contract IFluidLiquidity\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY_RESOLVER\",\"outputs\":[{\"internalType\":\"contract IFluidLiquidityResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dex_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"swap0to1_\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountIn_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin_\",\"type\":\"uint256\"}],\"name\":\"estimateSwapIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut_\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dex_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"swap0to1_\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountOut_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax_\",\"type\":\"uint256\"}],\"name\":\"estimateSwapOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn_\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPoolAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"pools_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPools\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.Pool[]\",\"name\":\"pools_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPoolsReserves\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"centerPrice\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.CollateralReserves\",\"name\":\"collateralReserves\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.DebtReserves\",\"name\":\"debtReserves\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"withdrawableToken0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"withdrawableToken1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"borrowableToken0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"borrowableToken1\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.DexLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.PoolWithReserves[]\",\"name\":\"poolsReserves_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPoolsReservesAdjusted\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"centerPrice\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.CollateralReserves\",\"name\":\"collateralReserves\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.DebtReserves\",\"name\":\"debtReserves\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"withdrawableToken0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"withdrawableToken1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"borrowableToken0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"borrowableToken1\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.DexLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.PoolWithReserves[]\",\"name\":\"poolsReserves_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dex_\",\"type\":\"address\"}],\"name\":\"getDexCollateralReserves\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.CollateralReserves\",\"name\":\"reserves_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dex_\",\"type\":\"address\"}],\"name\":\"getDexCollateralReservesAdjusted\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.CollateralReserves\",\"name\":\"reserves_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dex_\",\"type\":\"address\"}],\"name\":\"getDexDebtReserves\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.DebtReserves\",\"name\":\"reserves_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dex_\",\"type\":\"address\"}],\"name\":\"getDexDebtReservesAdjusted\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.DebtReserves\",\"name\":\"reserves_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dex_\",\"type\":\"address\"}],\"name\":\"getDexLimits\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"withdrawableToken0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"withdrawableToken1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"borrowableToken0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"borrowableToken1\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.DexLimits\",\"name\":\"limits_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dex_\",\"type\":\"address\"}],\"name\":\"getDexPricesAndExchangePrices\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lastStoredPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"centerPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upperRange\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lowerRange\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"geometricMean\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyToken0ExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowToken0ExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyToken1ExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowToken1ExchangePrice\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.PricesAndExchangePrice\",\"name\":\"pex_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId_\",\"type\":\"uint256\"}],\"name\":\"getPool\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.Pool\",\"name\":\"pool_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId_\",\"type\":\"uint256\"}],\"name\":\"getPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"}],\"name\":\"getPoolConstantsView\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dexId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"liquidity\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"shift\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"colOperations\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"debtOperations\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"perfectOperationsAndOracle\",\"type\":\"address\"}],\"internalType\":\"struct IFluidDexT1.Implementations\",\"name\":\"implementations\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"deployerContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"supplyToken0Slot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"borrowToken0Slot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"supplyToken1Slot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"borrowToken1Slot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"exchangePriceToken0Slot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"exchangePriceToken1Slot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"oracleMapping\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.ConstantViews\",\"name\":\"constantsView_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"}],\"name\":\"getPoolConstantsView2\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0NumeratorPrecision\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0DenominatorPrecision\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1NumeratorPrecision\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1DenominatorPrecision\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.ConstantViews2\",\"name\":\"constantsView2_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"}],\"name\":\"getPoolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"}],\"name\":\"getPoolReserves\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"centerPrice\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.CollateralReserves\",\"name\":\"collateralReserves\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.DebtReserves\",\"name\":\"debtReserves\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"withdrawableToken0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"withdrawableToken1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"borrowableToken0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"borrowableToken1\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.DexLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.PoolWithReserves\",\"name\":\"poolReserves_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"}],\"name\":\"getPoolReservesAdjusted\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"centerPrice\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.CollateralReserves\",\"name\":\"collateralReserves\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.DebtReserves\",\"name\":\"debtReserves\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"withdrawableToken0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"withdrawableToken1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"borrowableToken0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"borrowableToken1\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.DexLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.PoolWithReserves\",\"name\":\"poolReserves_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"}],\"name\":\"getPoolTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token0_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools_\",\"type\":\"address[]\"}],\"name\":\"getPoolsReserves\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"centerPrice\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.CollateralReserves\",\"name\":\"collateralReserves\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.DebtReserves\",\"name\":\"debtReserves\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"withdrawableToken0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"withdrawableToken1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"borrowableToken0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"borrowableToken1\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.DexLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.PoolWithReserves[]\",\"name\":\"poolsReserves_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools_\",\"type\":\"address[]\"}],\"name\":\"getPoolsReservesAdjusted\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"centerPrice\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.CollateralReserves\",\"name\":\"collateralReserves\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"token0Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1Debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1RealReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0ImaginaryReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1ImaginaryReserves\",\"type\":\"uint256\"}],\"internalType\":\"struct IFluidDexT1.DebtReserves\",\"name\":\"debtReserves\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"withdrawableToken0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"withdrawableToken1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"borrowableToken0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandsTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TokenLimit\",\"name\":\"borrowableToken1\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.DexLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.PoolWithReserves[]\",\"name\":\"poolsReserves_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"estimateSwapIn(address,bool,uint256,uint256)\":{\"params\":{\"amountIn_\":\"The exact amount of input tokens to swap\",\"amountOutMin_\":\"The minimum amount of output tokens the user is willing to accept\",\"dex_\":\"Dex pool\",\"swap0to1_\":\"Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\"},\"returns\":{\"amountOut_\":\"The amount of output tokens received from the swap\"}},\"estimateSwapOut(address,bool,uint256,uint256)\":{\"params\":{\"amountInMax_\":\"Maximum amount of tokens to swap in\",\"amountOut_\":\"The exact amount of tokens to receive after swap\",\"dex_\":\"Dex pool\",\"swap0to1_\":\"Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\"},\"returns\":{\"amountIn_\":\"The amount of input tokens used for the swap\"}},\"getAllPoolAddresses()\":{\"returns\":{\"pools_\":\"An array containing all Pool addresses\"}},\"getAllPools()\":{\"returns\":{\"pools_\":\"An array containing all Pool data\"}},\"getAllPoolsReserves()\":{\"details\":\"expected to be called via callStatic\",\"returns\":{\"poolsReserves_\":\"An array containing all Pool data with reserves\"}},\"getAllPoolsReservesAdjusted()\":{\"details\":\"expected to be called via callStatic\",\"returns\":{\"poolsReserves_\":\"An array containing all Pool data with adjusted reserves scaled to 1e12\"}},\"getDexCollateralReserves(address)\":{\"details\":\"expected to be called via callStatic\",\"params\":{\"dex_\":\"The address of the DEX\"},\"returns\":{\"reserves_\":\"A struct containing collateral reserve information\"}},\"getDexCollateralReservesAdjusted(address)\":{\"details\":\"expected to be called via callStatic\",\"params\":{\"dex_\":\"The address of the DEX\"},\"returns\":{\"reserves_\":\"A struct containing collateral reserve information\"}},\"getDexDebtReserves(address)\":{\"details\":\"expected to be called via callStatic\",\"params\":{\"dex_\":\"The address of the DEX\"},\"returns\":{\"reserves_\":\"A struct containing debt reserve information\"}},\"getDexDebtReservesAdjusted(address)\":{\"details\":\"expected to be called via callStatic\",\"params\":{\"dex_\":\"The address of the DEX\"},\"returns\":{\"reserves_\":\"A struct containing debt reserve information\"}},\"getDexLimits(address)\":{\"params\":{\"dex_\":\"The address of the DEX\"},\"returns\":{\"limits_\":\"A struct containing the swap limits for the DEX\"}},\"getDexPricesAndExchangePrices(address)\":{\"details\":\"expected to be called via callStatic\",\"params\":{\"dex_\":\"The address of the DEX\"},\"returns\":{\"pex_\":\"A struct containing prices and exchange prices\"}},\"getPool(uint256)\":{\"params\":{\"poolId_\":\"The ID of the Pool\"},\"returns\":{\"pool_\":\"The Pool data\"}},\"getPoolAddress(uint256)\":{\"params\":{\"poolId_\":\"The ID of the Pool\"},\"returns\":{\"pool_\":\"The address of the Pool\"}},\"getPoolFee(address)\":{\"params\":{\"pool_\":\"The Pool address\"},\"returns\":{\"fee_\":\"The Pool fee as 1% = 10000\"}},\"getPoolReserves(address)\":{\"details\":\"expected to be called via callStatic\",\"params\":{\"pool_\":\"The Pool address\"},\"returns\":{\"poolReserves_\":\"The Pool data with reserves.\"}},\"getPoolReservesAdjusted(address)\":{\"details\":\"expected to be called via callStatic\",\"params\":{\"pool_\":\"The Pool address\"},\"returns\":{\"poolReserves_\":\"The Pool data with adjusted reserves scaled to 1e12. balanceTokens are in token decimals.\"}},\"getPoolTokens(address)\":{\"params\":{\"pool_\":\"The address of the Pool\"},\"returns\":{\"token0_\":\"The address of token0 in the Pool\",\"token1_\":\"The address of token1 in the Pool\"}},\"getPoolsReserves(address[])\":{\"details\":\"expected to be called via callStatic\",\"params\":{\"pools_\":\"The array of Pool addresses\"},\"returns\":{\"poolsReserves_\":\"An array containing all Pool data with reserves\"}},\"getPoolsReservesAdjusted(address[])\":{\"details\":\"expected to be called via callStatic\",\"params\":{\"pools_\":\"The array of Pool addresses\"},\"returns\":{\"poolsReserves_\":\"An array containing all Pool data with adjusted reserves scaled to 1e12\"}},\"getTotalPools()\":{\"returns\":{\"_0\":\"The total number of Pools\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"estimateSwapIn(address,bool,uint256,uint256)\":{\"notice\":\"estimates swap IN tokens execution\"},\"estimateSwapOut(address,bool,uint256,uint256)\":{\"notice\":\"estimates swap OUT tokens execution\"},\"getAllPoolAddresses()\":{\"notice\":\"Get an array of all Pool addresses\"},\"getAllPools()\":{\"notice\":\"Get an array of all Pool addresses and their token addresses\"},\"getAllPoolsReserves()\":{\"notice\":\"Get an array of all Pool addresses, their token addresses, collateral reserves, and debt reserves\"},\"getAllPoolsReservesAdjusted()\":{\"notice\":\"Get an array of all Pool addresses, their token addresses, adjusted collateral reserves, and adjusted debt reserves\"},\"getDexCollateralReserves(address)\":{\"notice\":\"Get the collateral reserves for a DEX in token decimals amounts\"},\"getDexCollateralReservesAdjusted(address)\":{\"notice\":\"Get the collateral reserves for a DEX scaled to 1e12\"},\"getDexDebtReserves(address)\":{\"notice\":\"Get the debt reserves for a DEX in token decimals amounts\"},\"getDexDebtReservesAdjusted(address)\":{\"notice\":\"Get the debt reserves for a DEX scaled to 1e12\"},\"getDexLimits(address)\":{\"notice\":\"get the swap limits for a DEX\"},\"getDexPricesAndExchangePrices(address)\":{\"notice\":\"Get the prices and exchange prices for a DEX\"},\"getPool(uint256)\":{\"notice\":\"Get a Pool's address and its token addresses\"},\"getPoolAddress(uint256)\":{\"notice\":\"Get the address of a Pool given its ID\"},\"getPoolConstantsView(address)\":{\"notice\":\"returns all Pool constants\"},\"getPoolConstantsView2(address)\":{\"notice\":\"returns all Pool constants 2\"},\"getPoolFee(address)\":{\"notice\":\"Get a Pool's fee\"},\"getPoolReserves(address)\":{\"notice\":\"Get the token addresses, collateral reserves, and debt reserves for a given Pool address\"},\"getPoolReservesAdjusted(address)\":{\"notice\":\"Get the token addresses, adjusted collateral reserves, and adjusted debt reserves for a given Pool address\"},\"getPoolTokens(address)\":{\"notice\":\"Get the addresses of the tokens in a Pool\"},\"getPoolsReserves(address[])\":{\"notice\":\"Get an array of Pool addresses, their token addresses, collateral reserves, and debt reserves for a given array of Pool addresses\"},\"getPoolsReservesAdjusted(address[])\":{\"notice\":\"Get an array of Pool addresses, their token addresses, adjusted collateral reserves, and adjusted debt reserves for a given array of Pool addresses\"},\"getTotalPools()\":{\"notice\":\"Get the total number of Pools\"}},\"notice\":\"Fluid Dex Reserves resolver Implements various view-only methods to give easy access to Dex protocol reserves data.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/periphery/resolvers/dexReserves/main.sol\":\"FluidDexReservesResolver\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[]},\"sources\":{\"contracts/libraries/addressCalcs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice implements calculation of address for contracts deployed through CREATE.\\n/// Accepts contract deployed from which address & nonce\\nlibrary AddressCalcs {\\n\\n    /// @notice                         Computes the address of a contract based\\n    /// @param deployedFrom_            Address from which the contract was deployed\\n    /// @param nonce_                   Nonce at which the contract was deployed\\n    /// @return contract_               Address of deployed contract\\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\\n        // @dev based on https://ethereum.stackexchange.com/a/61413\\n\\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\\n        // hence, nonce of vault deployment starts with 1.\\n        bytes memory data;\\n        if (nonce_ == 0x00) {\\n            return address(0);\\n        } else if (nonce_ <= 0x7f) {\\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\\n        } else if (nonce_ <= 0xff) {\\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\\n        } else if (nonce_ <= 0xffff) {\\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\\n        } else if (nonce_ <= 0xffffff) {\\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\\n        } else {\\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\\n        }\\n\\n        return address(uint160(uint256(keccak256(data))));\\n    }\\n\\n}\",\"keccak256\":\"0xca389bcfef035463ff43939ac5eccab07ab74cbb053e201541f9bcd846b3105a\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/bytesSliceAndConcat.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary BytesSliceAndConcat {\\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\\n    function bytesConcat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    ) internal pure returns (bytes memory tempBytes) {\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(\\n                0x40,\\n                and(\\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n                    not(31) // Round down to the nearest 32 bytes.\\n                )\\n            )\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\\n    function bytesSlice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory tempBytes) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n}\\n\",\"keccak256\":\"0x42966896926a24dc7645ebf4679e6d701cb991144ef4d710d87738165d4024c7\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/dexSlotsLink.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\\nlibrary DexSlotsLink {\\n    /// @dev storage slot for variables at Dex\\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\\n    /// @dev storage slot for variables2 at Dex\\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\\n    /// @dev storage slot for total supply shares at Dex\\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\\n    /// @dev storage slot for user supply mapping at Dex\\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\\n    /// @dev storage slot for total borrow shares at Dex\\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\\n    /// @dev storage slot for user borrow mapping at Dex\\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\\n    /// @dev storage slot for oracle mapping at Dex\\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\\n    /// @dev storage slot for range and threshold shifts at Dex\\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\\n    /// @dev storage slot for center price shift at Dex\\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\\n\\n    // --------------------------------\\n    // @dev stacked uint256 storage slots bits position data for each:\\n\\n    // UserSupplyData\\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\\n\\n    // UserBorrowData\\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\\n\\n    // --------------------------------\\n\\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\\n    function calculateDoubleMappingStorageSlot(\\n        uint256 slot_,\\n        address key1_,\\n        address key2_\\n    ) internal pure returns (bytes32) {\\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\\n        return keccak256(abi.encode(key2_, intermediateSlot_));\\n    }\\n}\\n\",\"keccak256\":\"0xf1d6550d83fb0155a26655234922c9bdf4a1bbcf7a3ca767e9123d367a795307\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/adminModule/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Structs {\\n    struct AddressBool {\\n        address addr;\\n        bool value;\\n    }\\n\\n    struct AddressUint256 {\\n        address addr;\\n        uint256 value;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 1\\n    struct RateDataV1Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\\n        uint256 kink;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink;\\n        ///\\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 2\\n    struct RateDataV2Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\\n        uint256 kink1;\\n        ///\\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\\n        uint256 kink2;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink1;\\n        ///\\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\\n        uint256 rateAtUtilizationKink2;\\n        ///\\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set token config\\n    struct TokenConfig {\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 fee;\\n        ///\\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 threshold;\\n        ///\\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\\n        uint256 maxUtilization;\\n    }\\n\\n    /// @notice struct to set user supply & withdrawal config\\n    struct UserSupplyConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration withdrawal limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseWithdrawalLimit;\\n    }\\n\\n    /// @notice struct to set user borrow & payback config\\n    struct UserBorrowConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which debt limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration debt limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseDebtCeiling;\\n        ///\\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 maxDebtCeiling;\\n    }\\n}\\n\",\"keccak256\":\"0x10353c70015f27b880125cefab806dbed24a4458f187da66964f3ef60488f757\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/dexReserves/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { AddressCalcs } from \\\"../../../libraries/addressCalcs.sol\\\";\\nimport { DexSlotsLink } from \\\"../../../libraries/dexSlotsLink.sol\\\";\\nimport { BytesSliceAndConcat } from \\\"../../../libraries/bytesSliceAndConcat.sol\\\";\\nimport { Structs as FluidLiquidityResolverStructs } from \\\"../liquidity/structs.sol\\\";\\nimport { IFluidDexT1 } from \\\"../../../protocols/dex/interfaces/iDexT1.sol\\\";\\nimport { Variables } from \\\"./variables.sol\\\";\\nimport { Structs } from \\\"./structs.sol\\\";\\nimport { FixedPointMathLib } from \\\"solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\ninterface TokenInterface {\\n    function balanceOf(address) external view returns (uint);\\n}\\n\\ninterface IZtakingPool {\\n    function balance(address token_, address staker_) external view returns (uint256);\\n}\\n\\n/// @title DexFactoryViews\\n/// @notice Abstract contract providing view functions for DEX factory-related operations\\nabstract contract DexFactoryViews is Variables {\\n    /// @notice Get the address of a Pool given its ID\\n    /// @param poolId_ The ID of the Pool\\n    /// @return pool_ The address of the Pool\\n    function getPoolAddress(uint256 poolId_) public view returns (address pool_) {\\n        return AddressCalcs.addressCalc(address(FACTORY), poolId_);\\n    }\\n\\n    /// @notice Get the total number of Pools\\n    /// @return The total number of Pools\\n    function getTotalPools() public view returns (uint) {\\n        return FACTORY.totalDexes();\\n    }\\n\\n    /// @notice Get an array of all Pool addresses\\n    /// @return pools_ An array containing all Pool addresses\\n    function getAllPoolAddresses() public view returns (address[] memory pools_) {\\n        uint totalPools_ = getTotalPools();\\n        pools_ = new address[](totalPools_);\\n        for (uint i = 0; i < totalPools_; i++) {\\n            pools_[i] = getPoolAddress((i + 1));\\n        }\\n    }\\n}\\n\\n/// @title DexPublicViews\\n/// @notice Abstract contract providing view functions for DEX public data\\nabstract contract DexPublicViews {\\n    /// @notice Get the prices and exchange prices for a DEX\\n    /// @param dex_ The address of the DEX\\n    /// @return pex_ A struct containing prices and exchange prices\\n    /// @dev expected to be called via callStatic\\n    function getDexPricesAndExchangePrices(\\n        address dex_\\n    ) public returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\\n        try IFluidDexT1(dex_).getPricesAndExchangePrices() {} catch (bytes memory lowLevelData_) {\\n            bytes4 errorSelector_;\\n            assembly {\\n                // Extract the selector from the error data\\n                errorSelector_ := mload(add(lowLevelData_, 0x20))\\n            }\\n            if (errorSelector_ == IFluidDexT1.FluidDexPricesAndExchangeRates.selector) {\\n                pex_ = abi.decode(\\n                    BytesSliceAndConcat.bytesSlice(lowLevelData_, 4, lowLevelData_.length - 4),\\n                    (IFluidDexT1.PricesAndExchangePrice)\\n                );\\n            }\\n        }\\n    }\\n\\n    /// @notice Get the collateral reserves for a DEX in token decimals amounts\\n    /// @param dex_ The address of the DEX\\n    /// @return reserves_ A struct containing collateral reserve information\\n    /// @dev expected to be called via callStatic\\n    function getDexCollateralReserves(address dex_) public returns (IFluidDexT1.CollateralReserves memory reserves_) {\\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\\n        if ((dexVariables2_ & 1) != 1) {\\n            // smart col not enabled\\n            return IFluidDexT1.CollateralReserves(0, 0, 0, 0);\\n        }\\n\\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\\n            reserves_ = _getDexCollateralReserves(dex_, pex_);\\n        } catch {\\n            reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\\n        }\\n    }\\n\\n    /// @notice Get the collateral reserves for a DEX scaled to 1e12\\n    /// @param dex_ The address of the DEX\\n    /// @return reserves_ A struct containing collateral reserve information\\n    /// @dev expected to be called via callStatic\\n    function getDexCollateralReservesAdjusted(\\n        address dex_\\n    ) public returns (IFluidDexT1.CollateralReserves memory reserves_) {\\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\\n        if ((dexVariables2_ & 1) != 1) {\\n            // smart col not enabled\\n            return IFluidDexT1.CollateralReserves(0, 0, 0, 0);\\n        }\\n\\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\\n            reserves_ = _getDexCollateralReservesAdjusted(dex_, pex_);\\n        } catch {\\n            reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\\n        }\\n    }\\n\\n    /// @notice Get the debt reserves for a DEX in token decimals amounts\\n    /// @param dex_ The address of the DEX\\n    /// @return reserves_ A struct containing debt reserve information\\n    /// @dev expected to be called via callStatic\\n    function getDexDebtReserves(address dex_) public returns (IFluidDexT1.DebtReserves memory reserves_) {\\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\\n        if ((dexVariables2_ & 2) != 2) {\\n            // smart debt not enabled\\n            return IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\\n        }\\n\\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\\n            reserves_ = _getDexDebtReserves(dex_, pex_);\\n        } catch {\\n            reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\\n        }\\n    }\\n\\n    /// @notice Get the debt reserves for a DEX scaled to 1e12\\n    /// @param dex_ The address of the DEX\\n    /// @return reserves_ A struct containing debt reserve information\\n    /// @dev expected to be called via callStatic\\n    function getDexDebtReservesAdjusted(address dex_) public returns (IFluidDexT1.DebtReserves memory reserves_) {\\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\\n        if ((dexVariables2_ & 2) != 2) {\\n            // smart debt not enabled\\n            return IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\\n        }\\n\\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\\n            reserves_ = _getDexDebtReservesAdjusted(dex_, pex_);\\n        } catch {\\n            reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\\n        }\\n    }\\n\\n    /// @dev Retrieves and normalizes the collateral reserves for a given DEX.\\n    /// @param dex_ The address of the DEX.\\n    /// @param pex_ A struct containing price and exchange price information.\\n    /// @return reserves_ A struct containing the normalized collateral reserves.\\n    function _getDexCollateralReserves(\\n        address dex_,\\n        IFluidDexT1.PricesAndExchangePrice memory pex_\\n    ) internal view returns (IFluidDexT1.CollateralReserves memory reserves_) {\\n        reserves_ = _getDexCollateralReservesAdjusted(dex_, pex_);\\n\\n        IFluidDexT1.ConstantViews2 memory constantsView2_ = IFluidDexT1(dex_).constantsView2();\\n\\n        // returned reserves are in 1e12 decimals -> normalize to token decimals\\n        reserves_.token0RealReserves =\\n            (reserves_.token0RealReserves * constantsView2_.token0DenominatorPrecision) /\\n            constantsView2_.token0NumeratorPrecision;\\n        reserves_.token0ImaginaryReserves =\\n            (reserves_.token0ImaginaryReserves * constantsView2_.token0DenominatorPrecision) /\\n            constantsView2_.token0NumeratorPrecision;\\n        reserves_.token1RealReserves =\\n            (reserves_.token1RealReserves * constantsView2_.token1DenominatorPrecision) /\\n            constantsView2_.token1NumeratorPrecision;\\n        reserves_.token1ImaginaryReserves =\\n            (reserves_.token1ImaginaryReserves * constantsView2_.token1DenominatorPrecision) /\\n            constantsView2_.token1NumeratorPrecision;\\n    }\\n\\n    /// @dev Retrieves the adjusted collateral reserves for a given DEX.\\n    /// @param dex_ The address of the DEX.\\n    /// @param pex_ A struct containing price and exchange price information.\\n    /// @return reserves_ A struct containing the adjusted collateral reserves.\\n    function _getDexCollateralReservesAdjusted(\\n        address dex_,\\n        IFluidDexT1.PricesAndExchangePrice memory pex_\\n    ) internal view returns (IFluidDexT1.CollateralReserves memory reserves_) {\\n        try\\n            IFluidDexT1(dex_).getCollateralReserves(\\n                pex_.geometricMean,\\n                pex_.upperRange,\\n                pex_.lowerRange,\\n                pex_.supplyToken0ExchangePrice,\\n                pex_.supplyToken1ExchangePrice\\n            )\\n        returns (IFluidDexT1.CollateralReserves memory colReserves_) {\\n            // returned reserves are in 1e12 decimals -> normalize to token decimals\\n            reserves_ = colReserves_;\\n        } catch {\\n            reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\\n        }\\n    }\\n\\n    /// @dev Retrieves and normalizes the debt reserves for a given DEX.\\n    /// @param dex_ The address of the DEX.\\n    /// @param pex_ A struct containing price and exchange price information.\\n    /// @return reserves_ A struct containing the normalized debt reserves.\\n    function _getDexDebtReserves(\\n        address dex_,\\n        IFluidDexT1.PricesAndExchangePrice memory pex_\\n    ) internal view returns (IFluidDexT1.DebtReserves memory reserves_) {\\n        reserves_ = _getDexDebtReservesAdjusted(dex_, pex_);\\n\\n        IFluidDexT1.ConstantViews2 memory constantsView2_ = IFluidDexT1(dex_).constantsView2();\\n\\n        // returned reserves are in 1e12 decimals -> normalize to token decimals\\n        reserves_.token0Debt =\\n            (reserves_.token0Debt * constantsView2_.token0DenominatorPrecision) /\\n            constantsView2_.token0NumeratorPrecision;\\n        reserves_.token0RealReserves =\\n            (reserves_.token0RealReserves * constantsView2_.token0DenominatorPrecision) /\\n            constantsView2_.token0NumeratorPrecision;\\n        reserves_.token0ImaginaryReserves =\\n            (reserves_.token0ImaginaryReserves * constantsView2_.token0DenominatorPrecision) /\\n            constantsView2_.token0NumeratorPrecision;\\n        reserves_.token1Debt =\\n            (reserves_.token1Debt * constantsView2_.token1DenominatorPrecision) /\\n            constantsView2_.token1NumeratorPrecision;\\n        reserves_.token1RealReserves =\\n            (reserves_.token1RealReserves * constantsView2_.token1DenominatorPrecision) /\\n            constantsView2_.token1NumeratorPrecision;\\n        reserves_.token1ImaginaryReserves =\\n            (reserves_.token1ImaginaryReserves * constantsView2_.token1DenominatorPrecision) /\\n            constantsView2_.token1NumeratorPrecision;\\n    }\\n\\n    /// @dev Retrieves the adjusted debt reserves for a given DEX.\\n    /// @param dex_ The address of the DEX.\\n    /// @param pex_ A struct containing price and exchange price information.\\n    /// @return reserves_ A struct containing the adjusted debt reserves.\\n    function _getDexDebtReservesAdjusted(\\n        address dex_,\\n        IFluidDexT1.PricesAndExchangePrice memory pex_\\n    ) internal view returns (IFluidDexT1.DebtReserves memory reserves_) {\\n        try\\n            IFluidDexT1(dex_).getDebtReserves(\\n                pex_.geometricMean,\\n                pex_.upperRange,\\n                pex_.lowerRange,\\n                pex_.borrowToken0ExchangePrice,\\n                pex_.borrowToken1ExchangePrice\\n            )\\n        returns (IFluidDexT1.DebtReserves memory debtReserves_) {\\n            // returned reserves are in 1e12 decimals -> normalize to token decimals\\n            reserves_ = debtReserves_;\\n        } catch {\\n            reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\\n        }\\n    }\\n}\\n\\n/// @title DexConstantsViews\\n/// @notice Abstract contract providing view functions for DEX constants\\nabstract contract DexConstantsViews {\\n    /// @notice returns all Pool constants\\n    function getPoolConstantsView(address pool_) public view returns (IFluidDexT1.ConstantViews memory constantsView_) {\\n        return IFluidDexT1(pool_).constantsView();\\n    }\\n\\n    /// @notice returns all Pool constants 2\\n    function getPoolConstantsView2(\\n        address pool_\\n    ) public view returns (IFluidDexT1.ConstantViews2 memory constantsView2_) {\\n        return IFluidDexT1(pool_).constantsView2();\\n    }\\n\\n    /// @notice Get the addresses of the tokens in a Pool\\n    /// @param pool_ The address of the Pool\\n    /// @return token0_ The address of token0 in the Pool\\n    /// @return token1_ The address of token1 in the Pool\\n    function getPoolTokens(address pool_) public view returns (address token0_, address token1_) {\\n        IFluidDexT1.ConstantViews memory constantsView_ = IFluidDexT1(pool_).constantsView();\\n        return (constantsView_.token0, constantsView_.token1);\\n    }\\n}\\n\\nabstract contract DexSwapLimits is Variables, Structs, DexConstantsViews {\\n    address private constant WEETH = 0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee;\\n    address private constant WEETHS = 0x917ceE801a67f933F2e6b33fC0cD1ED2d5909D88;\\n    IZtakingPool private constant ZIRCUIT = IZtakingPool(0xF047ab4c75cebf0eB9ed34Ae2c186f3611aEAfa6);\\n\\n    /// @notice get the swap limits for a DEX\\n    /// @param dex_ The address of the DEX\\n    /// @return limits_ A struct containing the swap limits for the DEX\\n    function getDexLimits(address dex_) public view returns (DexLimits memory limits_) {\\n        // additional liquidity related data such as supply amount, limits, expansion etc.\\n        FluidLiquidityResolverStructs.UserSupplyData memory liquidityUserSupplyDataToken0_;\\n        FluidLiquidityResolverStructs.UserSupplyData memory liquidityUserSupplyDataToken1_;\\n        // liquidity token related data\\n        FluidLiquidityResolverStructs.OverallTokenData memory liquidityTokenData0_;\\n        FluidLiquidityResolverStructs.OverallTokenData memory liquidityTokenData1_;\\n        // additional liquidity related data such as borrow amount, limits, expansion etc.\\n        FluidLiquidityResolverStructs.UserBorrowData memory liquidityUserBorrowDataToken0_;\\n        FluidLiquidityResolverStructs.UserBorrowData memory liquidityUserBorrowDataToken1_;\\n\\n        {\\n            (address token0_, address token1_) = getPoolTokens(dex_);\\n            (liquidityUserSupplyDataToken0_, liquidityTokenData0_) = LIQUIDITY_RESOLVER.getUserSupplyData(\\n                dex_,\\n                token0_\\n            );\\n            (liquidityUserSupplyDataToken1_, liquidityTokenData1_) = LIQUIDITY_RESOLVER.getUserSupplyData(\\n                dex_,\\n                token1_\\n            );\\n            (liquidityUserBorrowDataToken0_, ) = LIQUIDITY_RESOLVER.getUserBorrowData(dex_, token0_);\\n            (liquidityUserBorrowDataToken1_, ) = LIQUIDITY_RESOLVER.getUserBorrowData(dex_, token1_);\\n\\n            // ----------------------- 1. UTILIZATION LIMITS (include liquidity layer balances) -----------------------\\n            // for dex, utilization limit check is not just after borrow but also after withdraw (after any swap).\\n            // for liquidity, utilization limit check is only after borrow.\\n            // so for borrow, use utilization config of either liquidity or dex, whatever is smaller. for withdraw, use dex.\\n\\n            uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\\n            /// Next 10 bits => 228-237 => utilization limit of token0. Max value 1000 = 100%, if 100% then no need to check the utilization.\\n            /// Next 10 bits => 238-247 => utilization limit of token1. Max value 1000 = 100%, if 100% then no need to check the utilization.\\n            {\\n                // TOKEN 0\\n                uint256 maxUtilizationToken0Dex_ = ((dexVariables2_ >> 228) & X10) * 10; // bring to 1e2 same as liquidity layer\\n                // check if max utilization at liquidity layer is smaller for combined config\\n                uint256 maxUtilizationToken0Combined_ = maxUtilizationToken0Dex_;\\n                if (liquidityTokenData0_.maxUtilization < maxUtilizationToken0Combined_) {\\n                    maxUtilizationToken0Combined_ = liquidityTokenData0_.maxUtilization;\\n                }\\n\\n                // calculate utilization limit amount % of total supply (with combined config for borrow)\\n                uint256 maxUtilizationToken0_ = (liquidityTokenData0_.totalSupply * maxUtilizationToken0Combined_) /\\n                    1e4;\\n\\n                if (liquidityTokenData0_.totalBorrow < maxUtilizationToken0_) {\\n                    // expands to & available: amount until utilization max\\n                    // get amount where currently borrowed = utilization limit of total supply. for withdraw only dex config counts.\\n                    limits_.withdrawableToken0.available = maxUtilizationToken0Dex_ == 0\\n                        ? 0\\n                        : (1e4 * liquidityTokenData0_.totalBorrow) / maxUtilizationToken0Dex_;\\n                    limits_.withdrawableToken0.available = liquidityTokenData0_.totalSupply >\\n                        limits_.withdrawableToken0.available\\n                        ? liquidityTokenData0_.totalSupply - limits_.withdrawableToken0.available\\n                        : 0;\\n                    // no expansion on utilization\\n                    limits_.withdrawableToken0.expandsTo = limits_.withdrawableToken0.available;\\n\\n                    limits_.borrowableToken0.available = maxUtilizationToken0_ - liquidityTokenData0_.totalBorrow;\\n                    // no expansion on utilization\\n                    limits_.borrowableToken0.expandsTo = limits_.borrowableToken0.available;\\n\\n                    // balance at liquidity layer is a hard limit that can not be expanded beyond\\n                    uint balanceLiquidity_ = token0_ == NATIVE_TOKEN_ADDRESS\\n                        ? address(LIQUIDITY).balance\\n                        : TokenInterface(token0_).balanceOf(address(LIQUIDITY));\\n                    if (token0_ == WEETH) {\\n                        balanceLiquidity_ += ZIRCUIT.balance(WEETH, address(LIQUIDITY));\\n                    }\\n                    if (token0_ == WEETHS) {\\n                        balanceLiquidity_ += ZIRCUIT.balance(WEETHS, address(LIQUIDITY));\\n                    }\\n                    if (limits_.withdrawableToken0.expandsTo > balanceLiquidity_) {\\n                        limits_.withdrawableToken0.expandsTo = balanceLiquidity_;\\n                    }\\n                    if (limits_.borrowableToken0.expandsTo > balanceLiquidity_) {\\n                        limits_.borrowableToken0.expandsTo = balanceLiquidity_;\\n                    }\\n                }\\n            }\\n\\n            {\\n                // TOKEN 1\\n                uint256 maxUtilizationToken1Dex_ = ((dexVariables2_ >> 238) & X10) * 10;\\n                uint256 maxUtilizationToken1Combined_ = maxUtilizationToken1Dex_;\\n                if (liquidityTokenData1_.maxUtilization < maxUtilizationToken1Combined_) {\\n                    maxUtilizationToken1Combined_ = liquidityTokenData1_.maxUtilization;\\n                }\\n                uint256 maxUtilizationToken1_ = (liquidityTokenData1_.totalSupply * maxUtilizationToken1Combined_) /\\n                    1e4;\\n                if (liquidityTokenData1_.totalBorrow < maxUtilizationToken1_) {\\n                    // expands to & available: amount until utilization max\\n                    // get amount where currently borrowed = utilization limit of total supply. for withdraw only dex config counts.\\n                    limits_.withdrawableToken1.available = maxUtilizationToken1Dex_ == 0\\n                        ? 0\\n                        : (1e4 * liquidityTokenData1_.totalBorrow) / maxUtilizationToken1Dex_;\\n                    limits_.withdrawableToken1.available = liquidityTokenData1_.totalSupply >\\n                        limits_.withdrawableToken1.available\\n                        ? liquidityTokenData1_.totalSupply - limits_.withdrawableToken1.available\\n                        : 0;\\n                    // no expansion on utilization\\n                    limits_.withdrawableToken1.expandsTo = limits_.withdrawableToken1.available;\\n\\n                    limits_.borrowableToken1.available = maxUtilizationToken1_ - liquidityTokenData1_.totalBorrow;\\n                    // no expansion on utilization\\n                    limits_.borrowableToken1.expandsTo = limits_.borrowableToken1.available;\\n\\n                    // balance at liquidity layer is a hard limit that can not be expanded beyond\\n                    uint balanceLiquidity_ = token1_ == NATIVE_TOKEN_ADDRESS\\n                        ? address(LIQUIDITY).balance\\n                        : TokenInterface(token1_).balanceOf(address(LIQUIDITY));\\n                    if (token1_ == WEETH) {\\n                        balanceLiquidity_ += ZIRCUIT.balance(WEETH, address(LIQUIDITY));\\n                    }\\n                    if (token1_ == WEETHS) {\\n                        balanceLiquidity_ += ZIRCUIT.balance(WEETHS, address(LIQUIDITY));\\n                    }\\n                    if (limits_.withdrawableToken1.expandsTo > balanceLiquidity_) {\\n                        limits_.withdrawableToken1.expandsTo = balanceLiquidity_;\\n                    }\\n                    if (limits_.borrowableToken1.expandsTo > balanceLiquidity_) {\\n                        limits_.borrowableToken1.expandsTo = balanceLiquidity_;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // ----------------------- 2. WITHDRAW AND BORROW LIMITS (include liquidity layer balances) -----------------------\\n\\n        // expandsTo = max possible amount at full expansion\\n        // expandDuration = time of expandDuration config left until maxExpansion is reached\\n\\n        // TOKEN 0 WITHDRAWABLE\\n        {\\n            uint256 expandTimeLeft_ = liquidityUserSupplyDataToken0_.lastUpdateTimestamp +\\n                liquidityUserSupplyDataToken0_.expandDuration;\\n            expandTimeLeft_ = block.timestamp > expandTimeLeft_ ? 0 : expandTimeLeft_ - block.timestamp;\\n\\n            uint256 maxWithdrawable_ = (liquidityUserSupplyDataToken0_.expandPercent *\\n                liquidityUserSupplyDataToken0_.supply) / 1e4;\\n            if (liquidityUserSupplyDataToken0_.withdrawable > maxWithdrawable_) {\\n                // max expansion already reached or below base limit\\n                maxWithdrawable_ = liquidityUserSupplyDataToken0_.withdrawable;\\n                expandTimeLeft_ = 0;\\n            }\\n\\n            if (maxWithdrawable_ <= limits_.withdrawableToken0.expandsTo) {\\n                // if max withdrawable until limit is less than utilization limit, then set max withdrawable until limit as expansion limit.\\n                limits_.withdrawableToken0.expandsTo = maxWithdrawable_;\\n\\n                expandTimeLeft_ = maxWithdrawable_ == 0\\n                    ? 0\\n                    : ((limits_.withdrawableToken0.expandsTo - liquidityUserSupplyDataToken0_.withdrawable) *\\n                        liquidityUserSupplyDataToken0_.expandDuration) / maxWithdrawable_;\\n            } else {\\n                // max withdrawable expansion is limited by utilization or liquidity layer balance.\\n                // recalculate the duration until that earlier limit is hit.\\n                if (liquidityUserSupplyDataToken0_.withdrawable > limits_.withdrawableToken0.expandsTo) {\\n                    // withdrawable amount at LiquidityResolver does not have dex utilization limit included\\n                    // so this case could actually happen. if so, then adjust withdrawable and expansion is already\\n                    // max reached so duration left is 0.\\n                    expandTimeLeft_ = 0;\\n                    liquidityUserSupplyDataToken0_.withdrawable = limits_.withdrawableToken0.expandsTo;\\n                } else {\\n                    // expansionPerSecond_ = maxWithdrawable_ / expandDuration;\\n                    // withdrawable + expansionPerSecond_ * x = expandsTo;\\n                    // so x = (expandsTo - withdrawable) / expansionPerSecond_;\\n                    // so x = (expandsTo - withdrawable) / (maxWithdrawable_ / expandDuration);\\n                    // so x = (expandsTo - withdrawable) * expandDuration / maxWithdrawable_;\\n                    expandTimeLeft_ = maxWithdrawable_ == 0\\n                        ? 0\\n                        : ((limits_.withdrawableToken0.expandsTo - liquidityUserSupplyDataToken0_.withdrawable) *\\n                            liquidityUserSupplyDataToken0_.expandDuration) / maxWithdrawable_;\\n                }\\n            }\\n            limits_.withdrawableToken0.expandDuration = expandTimeLeft_;\\n        }\\n\\n        // TOKEN 1 WITHDRAWABLE\\n        {\\n            uint256 expandTimeLeft_ = liquidityUserSupplyDataToken1_.lastUpdateTimestamp +\\n                liquidityUserSupplyDataToken1_.expandDuration;\\n            expandTimeLeft_ = block.timestamp > expandTimeLeft_ ? 0 : expandTimeLeft_ - block.timestamp;\\n\\n            uint256 maxWithdrawable_ = (liquidityUserSupplyDataToken1_.expandPercent *\\n                liquidityUserSupplyDataToken1_.supply) / 1e4;\\n            if (liquidityUserSupplyDataToken1_.withdrawable > maxWithdrawable_) {\\n                // max expansion already reached or below base limit\\n                maxWithdrawable_ = liquidityUserSupplyDataToken1_.withdrawable;\\n                expandTimeLeft_ = 0;\\n            }\\n\\n            if (maxWithdrawable_ <= limits_.withdrawableToken1.expandsTo) {\\n                // if max withdrawable until limit is less than utilization limit, then set max withdrawable until limit as expansion limit.\\n                limits_.withdrawableToken1.expandsTo = maxWithdrawable_;\\n\\n                expandTimeLeft_ = maxWithdrawable_ == 0\\n                    ? 0\\n                    : ((limits_.withdrawableToken1.expandsTo - liquidityUserSupplyDataToken1_.withdrawable) *\\n                        liquidityUserSupplyDataToken1_.expandDuration) / maxWithdrawable_;\\n            } else {\\n                // max withdrawable expansion is limited by utilization or liquidity layer balance.\\n                // recalculate the duration until that earlier limit is hit.\\n                if (liquidityUserSupplyDataToken1_.withdrawable > limits_.withdrawableToken1.expandsTo) {\\n                    // withdrawable amount at LiquidityResolver does not have dex utilization limit included\\n                    // so this case could actually happen. if so, then adjust withdrawable and expansion is already\\n                    // max reached so duration left is 0.\\n                    expandTimeLeft_ = 0;\\n                    liquidityUserSupplyDataToken1_.withdrawable = limits_.withdrawableToken1.expandsTo;\\n                } else {\\n                    expandTimeLeft_ = maxWithdrawable_ == 0\\n                        ? 0\\n                        : ((limits_.withdrawableToken1.expandsTo - liquidityUserSupplyDataToken1_.withdrawable) *\\n                            liquidityUserSupplyDataToken1_.expandDuration) / maxWithdrawable_;\\n                }\\n            }\\n            limits_.withdrawableToken1.expandDuration = expandTimeLeft_;\\n        }\\n\\n        // TOKEN 0 BORROWABLE\\n        {\\n            uint256 expandTimeLeft_ = liquidityUserBorrowDataToken0_.lastUpdateTimestamp +\\n                liquidityUserBorrowDataToken0_.expandDuration;\\n            expandTimeLeft_ = block.timestamp > expandTimeLeft_ ? 0 : expandTimeLeft_ - block.timestamp;\\n\\n            uint256 maxBorrowable_ = (liquidityUserBorrowDataToken0_.expandPercent *\\n                liquidityUserBorrowDataToken0_.borrow) / 1e4;\\n            {\\n                // consider max hard borrow limit\\n                uint256 maxBorrowableUntilHardLimit_ = liquidityUserBorrowDataToken0_.maxBorrowLimit >\\n                    liquidityUserBorrowDataToken0_.borrow\\n                    ? liquidityUserBorrowDataToken0_.maxBorrowLimit - liquidityUserBorrowDataToken0_.borrow\\n                    : 0;\\n                if (limits_.borrowableToken0.expandsTo > maxBorrowableUntilHardLimit_) {\\n                    limits_.borrowableToken0.expandsTo = maxBorrowableUntilHardLimit_;\\n                }\\n            }\\n            if (liquidityUserBorrowDataToken0_.borrowable > maxBorrowable_) {\\n                // max expansion already reached or below base limit\\n                maxBorrowable_ = liquidityUserBorrowDataToken0_.borrowable;\\n                expandTimeLeft_ = 0;\\n            }\\n\\n            if (maxBorrowable_ <= limits_.borrowableToken0.expandsTo) {\\n                // if max borrowable until limit is less than utilization limit, then set max borrowable until limit as expansion limit.\\n                limits_.borrowableToken0.expandsTo = maxBorrowable_;\\n\\n                // expansionPerSecond_ = maxBorrowable_ / expandDuration;\\n                // borrowable + expansionPerSecond_ * x = expandsTo;\\n                expandTimeLeft_ = maxBorrowable_ == 0\\n                    ? 0\\n                    : ((limits_.borrowableToken0.expandsTo - liquidityUserBorrowDataToken0_.borrowable) *\\n                        liquidityUserBorrowDataToken0_.expandDuration) / maxBorrowable_;\\n            } else {\\n                // max borrowable expansion is limited by utilization or liquidity layer balance.\\n                // recalculate the duration until that earlier limit is hit.\\n                if (liquidityUserBorrowDataToken0_.borrowable > limits_.borrowableToken0.expandsTo) {\\n                    // borrowable amount at LiquidityResolver does not have dex utilization limit included\\n                    // so this case could actually happen. if so, then adjust borrowable and expansion is already\\n                    // max reached so duration left is 0.\\n                    expandTimeLeft_ = 0;\\n                    liquidityUserBorrowDataToken0_.borrowable = limits_.borrowableToken0.expandsTo;\\n                } else {\\n                    expandTimeLeft_ = maxBorrowable_ == 0\\n                        ? 0\\n                        : ((limits_.borrowableToken0.expandsTo - liquidityUserBorrowDataToken0_.borrowable) *\\n                            liquidityUserBorrowDataToken0_.expandDuration) / maxBorrowable_;\\n                }\\n            }\\n            limits_.borrowableToken0.expandDuration = expandTimeLeft_;\\n        }\\n\\n        // TOKEN 1 BORROWABLE\\n        {\\n            uint256 expandTimeLeft_ = liquidityUserBorrowDataToken1_.lastUpdateTimestamp +\\n                liquidityUserBorrowDataToken1_.expandDuration;\\n            expandTimeLeft_ = block.timestamp > expandTimeLeft_ ? 0 : expandTimeLeft_ - block.timestamp;\\n\\n            uint256 maxBorrowable_ = (liquidityUserBorrowDataToken1_.expandPercent *\\n                liquidityUserBorrowDataToken1_.borrow) / 1e4;\\n            {\\n                // consider max hard borrow limit\\n                uint256 maxBorrowableUntilHardLimit_ = liquidityUserBorrowDataToken1_.maxBorrowLimit >\\n                    liquidityUserBorrowDataToken1_.borrow\\n                    ? liquidityUserBorrowDataToken1_.maxBorrowLimit - liquidityUserBorrowDataToken1_.borrow\\n                    : 0;\\n                if (limits_.borrowableToken1.expandsTo > maxBorrowableUntilHardLimit_) {\\n                    limits_.borrowableToken1.expandsTo = maxBorrowableUntilHardLimit_;\\n                }\\n            }\\n            if (liquidityUserBorrowDataToken1_.borrowable > maxBorrowable_) {\\n                // max expansion already reached or below base limit\\n                maxBorrowable_ = liquidityUserBorrowDataToken1_.borrowable;\\n                expandTimeLeft_ = 0;\\n            }\\n\\n            if (maxBorrowable_ <= limits_.borrowableToken1.expandsTo) {\\n                // if max borrowable until limit is less than utilization limit, then set max borrowable until limit as expansion limit.\\n                limits_.borrowableToken1.expandsTo = maxBorrowable_;\\n\\n                // expansionPerSecond_ = maxBorrowable_ / expandDuration;\\n                // borrowable + expansionPerSecond_ * x = expandsTo;\\n                expandTimeLeft_ = maxBorrowable_ == 0\\n                    ? 0\\n                    : ((limits_.borrowableToken1.expandsTo - liquidityUserBorrowDataToken1_.borrowable) *\\n                        liquidityUserBorrowDataToken1_.expandDuration) / maxBorrowable_;\\n            } else {\\n                // max borrowable expansion is limited by utilization or liquidity layer balance.\\n                // recalculate the duration until that earlier limit is hit.\\n                if (liquidityUserBorrowDataToken1_.borrowable > limits_.borrowableToken1.expandsTo) {\\n                    // borrowable amount at LiquidityResolver does not have dex utilization limit included\\n                    // so this case could actually happen. if so, then adjust borrowable and expansion is already\\n                    // max reached so duration left is 0.\\n                    expandTimeLeft_ = 0;\\n                    liquidityUserBorrowDataToken1_.borrowable = limits_.borrowableToken1.expandsTo;\\n                } else {\\n                    expandTimeLeft_ = maxBorrowable_ == 0\\n                        ? 0\\n                        : ((limits_.borrowableToken1.expandsTo - liquidityUserBorrowDataToken1_.borrowable) *\\n                            liquidityUserBorrowDataToken1_.expandDuration) / maxBorrowable_;\\n                }\\n            }\\n            limits_.borrowableToken1.expandDuration = expandTimeLeft_;\\n        }\\n\\n        // for available amounts, set withdrawable / borrowable (incl. liquidity balances) if less than available until utilization\\n        if (liquidityUserSupplyDataToken1_.withdrawable < limits_.withdrawableToken0.available) {\\n            limits_.withdrawableToken0.available = liquidityUserSupplyDataToken0_.withdrawable;\\n        }\\n        if (liquidityUserSupplyDataToken1_.withdrawable < limits_.withdrawableToken1.available) {\\n            limits_.withdrawableToken1.available = liquidityUserSupplyDataToken1_.withdrawable;\\n        }\\n        if (liquidityUserBorrowDataToken0_.borrowable < limits_.borrowableToken0.available) {\\n            limits_.borrowableToken0.available = liquidityUserBorrowDataToken0_.borrowable;\\n        }\\n        if (liquidityUserBorrowDataToken1_.borrowable < limits_.borrowableToken1.available) {\\n            limits_.borrowableToken1.available = liquidityUserBorrowDataToken1_.borrowable;\\n        }\\n    }\\n}\\n\\nabstract contract DexActionEstimates is DexPublicViews, DexSwapLimits {\\n    address private constant ADDRESS_DEAD = 0x000000000000000000000000000000000000dEaD;\\n\\n    /// @param t total amount in\\n    /// @param x imaginary reserves of token out of collateral\\n    /// @param y imaginary reserves of token in of collateral\\n    /// @param x2 imaginary reserves of token out of debt\\n    /// @param y2 imaginary reserves of token in of debt\\n    /// @return a_ how much swap should go through collateral pool. Remaining will go from debt\\n    /// note if a < 0 then entire trade route through debt pool and debt pool arbitrage with col pool\\n    /// note if a > t then entire trade route through col pool and col pool arbitrage with debt pool\\n    /// note if a > 0 & a < t then swap will route through both pools\\n    function _swapRoutingIn(uint t, uint x, uint y, uint x2, uint y2) private pure returns (int a_) {\\n        // Main equations:\\n        // 1. out = x * a / (y + a)\\n        // 2. out2 = x2 * (t - a) / (y2 + (t - a))\\n        // final price should be same\\n        // 3. (y + a) / (x - out) = (y2 + (t - a)) / (x2 - out2)\\n        // derivation: https://chatgpt.com/share/dce6f381-ee5f-4d5f-b6ea-5996e84d5b57\\n\\n        // adding 1e18 precision\\n        uint xyRoot_ = FixedPointMathLib.sqrt(x * y * 1e18);\\n        uint x2y2Root_ = FixedPointMathLib.sqrt(x2 * y2 * 1e18);\\n\\n        a_ = (int(y2 * xyRoot_ + t * xyRoot_) - int(y * x2y2Root_)) / int(xyRoot_ + x2y2Root_);\\n    }\\n\\n    /// @param t total amount out\\n    /// @param x imaginary reserves of token in of collateral\\n    /// @param y imaginary reserves of token out of collateral\\n    /// @param x2 imaginary reserves of token in of debt\\n    /// @param y2 imaginary reserves of token out of debt\\n    /// @return a_ how much swap should go through collateral pool. Remaining will go from debt\\n    /// note if a < 0 then entire trade route through debt pool and debt pool arbitrage with col pool\\n    /// note if a > t then entire trade route through col pool and col pool arbitrage with debt pool\\n    /// note if a > 0 & a < t then swap will route through both pools\\n    function _swapRoutingOut(uint t, uint x, uint y, uint x2, uint y2) private pure returns (int a_) {\\n        // Main equations:\\n        // 1. in = (x * a) / (y - a)\\n        // 2. in2 = (x2 * (t - a)) / (y2 - (t - a))\\n        // final price should be same\\n        // 3. (y - a) / (x + in) = (y2 - (t - a)) / (x2 + in2)\\n        // derivation: https://chatgpt.com/share/6585bc28-841f-49ec-aea2-1e5c5b7f4fa9\\n\\n        // adding 1e18 precision\\n        uint xyRoot_ = FixedPointMathLib.sqrt(x * y * 1e18);\\n        uint x2y2Root_ = FixedPointMathLib.sqrt(x2 * y2 * 1e18);\\n\\n        // 1e18 precision gets cancelled out in division\\n        a_ = (int(t * xyRoot_ + y * x2y2Root_) - int(y2 * xyRoot_)) / int(xyRoot_ + x2y2Root_);\\n    }\\n\\n    /// @dev Given an input amount of asset and pair reserves, returns the maximum output amount of the other asset\\n    /// @param amountIn_ The amount of input asset.\\n    /// @param iReserveIn_ Imaginary token reserve with input amount.\\n    /// @param iReserveOut_ Imaginary token reserve of output amount.\\n    function _getAmountOut(\\n        uint256 amountIn_,\\n        uint iReserveIn_,\\n        uint iReserveOut_\\n    ) private pure returns (uint256 amountOut_) {\\n        unchecked {\\n            // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\\n            uint256 numerator_ = amountIn_ * iReserveOut_;\\n            uint256 denominator_ = iReserveIn_ + amountIn_;\\n\\n            // Using the swap formula: (AmountIn * iReserveY) / (iReserveX + AmountIn)\\n            amountOut_ = numerator_ / denominator_;\\n        }\\n    }\\n\\n    /// @dev Given an output amount of asset and pair reserves, returns the input amount of the other asset\\n    /// @param amountOut_ Desired output amount of the asset.\\n    /// @param iReserveIn_ Imaginary token reserve of input amount.\\n    /// @param iReserveOut_ Imaginary token reserve of output amount.\\n    function _getAmountIn(\\n        uint256 amountOut_,\\n        uint iReserveIn_,\\n        uint iReserveOut_\\n    ) private pure returns (uint256 amountIn_) {\\n        // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\\n        uint256 numerator_ = amountOut_ * iReserveIn_;\\n        uint256 denominator_ = iReserveOut_ - amountOut_;\\n\\n        // Using the swap formula: (AmountOut * iReserveX) / (iReserveY - AmountOut)\\n        amountIn_ = numerator_ / denominator_;\\n    }\\n\\n    struct EstimateMemoryVars {\\n        uint256 colTokenInImaginaryReserves;\\n        uint256 colTokenOutImaginaryReserves;\\n        uint256 debtTokenInImaginaryReserves;\\n        uint256 debtTokenOutImaginaryReserves;\\n        uint256 amountOutCollateralAdjusted;\\n        uint256 amountOutDebtAdjusted;\\n        uint256 amountInCollateralAdjusted;\\n        uint256 amountInDebtAdjusted;\\n    }\\n\\n    /// @notice estimates swap IN tokens execution\\n    /// @param dex_ Dex pool\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountIn_ The exact amount of input tokens to swap\\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\\n    /// @return amountOut_ The amount of output tokens received from the swap\\n    function estimateSwapIn(\\n        address dex_,\\n        bool swap0to1_,\\n        uint256 amountIn_,\\n        uint256 amountOutMin_\\n    ) public payable returns (uint256 amountOut_) {\\n        try IFluidDexT1(dex_).swapIn{ value: msg.value }(swap0to1_, amountIn_, amountOutMin_, ADDRESS_DEAD) {} catch (\\n            bytes memory lowLevelData_\\n        ) {\\n            (amountOut_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSwapResult.selector);\\n        }\\n\\n        EstimateMemoryVars memory e_;\\n        {\\n            IFluidDexT1.CollateralReserves memory colReserves_ = getDexCollateralReservesAdjusted(dex_);\\n            IFluidDexT1.DebtReserves memory debtReserves_ = getDexDebtReservesAdjusted(dex_);\\n            if (swap0to1_) {\\n                e_.colTokenInImaginaryReserves = colReserves_.token0ImaginaryReserves;\\n                e_.colTokenOutImaginaryReserves = colReserves_.token1ImaginaryReserves;\\n                e_.debtTokenInImaginaryReserves = debtReserves_.token0ImaginaryReserves;\\n                e_.debtTokenOutImaginaryReserves = debtReserves_.token1ImaginaryReserves;\\n            } else {\\n                e_.colTokenInImaginaryReserves = colReserves_.token1ImaginaryReserves;\\n                e_.colTokenOutImaginaryReserves = colReserves_.token0ImaginaryReserves;\\n                e_.debtTokenInImaginaryReserves = debtReserves_.token1ImaginaryReserves;\\n                e_.debtTokenOutImaginaryReserves = debtReserves_.token0ImaginaryReserves;\\n            }\\n        }\\n\\n        IFluidDexT1.ConstantViews2 memory constantsView2_ = IFluidDexT1(dex_).constantsView2();\\n\\n        {\\n            int256 swapRoutingAmt_;\\n            uint256 poolFee_;\\n            uint256 amountInAdjusted_;\\n            // bring amount in to 1e12 decimals adjusted\\n            if (swap0to1_) {\\n                amountInAdjusted_ =\\n                    (amountIn_ * constantsView2_.token0NumeratorPrecision) /\\n                    constantsView2_.token0DenominatorPrecision;\\n            } else {\\n                amountInAdjusted_ =\\n                    (amountIn_ * constantsView2_.token1NumeratorPrecision) /\\n                    constantsView2_.token1DenominatorPrecision;\\n            }\\n\\n            {\\n                uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\\n                poolFee_ = (dexVariables2_ >> 2) & X17;\\n                bool colPoolEnabled_ = (dexVariables2_ & 1) == 1;\\n                bool debtPoolEnabled_ = (dexVariables2_ & 2) == 2;\\n                if (colPoolEnabled_ && debtPoolEnabled_) {\\n                    swapRoutingAmt_ = _swapRoutingIn(\\n                        amountInAdjusted_,\\n                        e_.colTokenOutImaginaryReserves,\\n                        e_.colTokenInImaginaryReserves,\\n                        e_.debtTokenOutImaginaryReserves,\\n                        e_.debtTokenInImaginaryReserves\\n                    );\\n                } else if (debtPoolEnabled_) {\\n                    swapRoutingAmt_ = -1; // Route from debt pool\\n                } else if (colPoolEnabled_) {\\n                    swapRoutingAmt_ = int256(amountInAdjusted_) + 1; // Route from collateral pool\\n                } else {\\n                    revert(\\\"No pools are enabled\\\");\\n                }\\n            }\\n\\n            if (swapRoutingAmt_ <= 0) {\\n                // Entire trade routes through debt pool\\n                e_.amountInDebtAdjusted = amountInAdjusted_;\\n                e_.amountOutDebtAdjusted = _getAmountOut(\\n                    ((amountInAdjusted_ * (1e6 - poolFee_)) / 1e6),\\n                    e_.debtTokenInImaginaryReserves,\\n                    e_.debtTokenOutImaginaryReserves\\n                );\\n            } else if (swapRoutingAmt_ >= int256(amountInAdjusted_)) {\\n                // Entire trade routes through collateral pool\\n                e_.amountInCollateralAdjusted = amountInAdjusted_;\\n                e_.amountOutCollateralAdjusted = _getAmountOut(\\n                    ((amountInAdjusted_ * (1e6 - poolFee_)) / 1e6),\\n                    e_.colTokenInImaginaryReserves,\\n                    e_.colTokenOutImaginaryReserves\\n                );\\n            } else {\\n                // Trade routes through both pools\\n                e_.amountInCollateralAdjusted = uint(swapRoutingAmt_);\\n                e_.amountInDebtAdjusted = amountInAdjusted_ - e_.amountInCollateralAdjusted;\\n\\n                e_.amountOutCollateralAdjusted = _getAmountOut(\\n                    ((e_.amountInCollateralAdjusted * (1e6 - poolFee_)) / 1e6),\\n                    e_.colTokenInImaginaryReserves,\\n                    e_.colTokenOutImaginaryReserves\\n                );\\n\\n                e_.amountOutDebtAdjusted = _getAmountOut(\\n                    ((e_.amountInDebtAdjusted * (1e6 - poolFee_)) / 1e6),\\n                    e_.debtTokenInImaginaryReserves,\\n                    e_.debtTokenOutImaginaryReserves\\n                );\\n            }\\n        }\\n\\n        {\\n            uint256 borrowableAdjusted_;\\n            uint256 withdrawableAdjusted_;\\n            DexLimits memory limits_ = getDexLimits(dex_);\\n\\n            // bring amount to 1e12 decimals adjusted\\n            if (swap0to1_) {\\n                borrowableAdjusted_ =\\n                    (limits_.borrowableToken1.available * constantsView2_.token1NumeratorPrecision) /\\n                    constantsView2_.token1DenominatorPrecision;\\n                withdrawableAdjusted_ =\\n                    (limits_.withdrawableToken1.available * constantsView2_.token1NumeratorPrecision) /\\n                    constantsView2_.token1DenominatorPrecision;\\n            } else {\\n                borrowableAdjusted_ =\\n                    (limits_.borrowableToken0.available * constantsView2_.token0NumeratorPrecision) /\\n                    constantsView2_.token0DenominatorPrecision;\\n                withdrawableAdjusted_ =\\n                    (limits_.withdrawableToken0.available * constantsView2_.token0NumeratorPrecision) /\\n                    constantsView2_.token0DenominatorPrecision;\\n            }\\n\\n            if (e_.amountOutDebtAdjusted > borrowableAdjusted_) {\\n                return 0;\\n            }\\n            if (e_.amountOutCollateralAdjusted > withdrawableAdjusted_) {\\n                return 0;\\n            }\\n        }\\n\\n        uint256 oldPrice_;\\n        uint256 newPrice_;\\n        // from whatever pool higher amount of swap is routing we are taking that as final price, does not matter much because both pools final price should be same\\n        if (e_.amountInCollateralAdjusted > e_.amountInDebtAdjusted) {\\n            // new pool price from col pool\\n            oldPrice_ = swap0to1_\\n                ? (e_.colTokenOutImaginaryReserves * 1e27) / (e_.colTokenInImaginaryReserves)\\n                : (e_.colTokenInImaginaryReserves * 1e27) / (e_.colTokenOutImaginaryReserves);\\n            newPrice_ = swap0to1_\\n                ? ((e_.colTokenOutImaginaryReserves - e_.amountOutCollateralAdjusted) * 1e27) /\\n                    (e_.colTokenInImaginaryReserves + e_.amountInCollateralAdjusted)\\n                : ((e_.colTokenInImaginaryReserves + e_.amountInCollateralAdjusted) * 1e27) /\\n                    (e_.colTokenOutImaginaryReserves - e_.amountOutCollateralAdjusted);\\n        } else {\\n            // new pool price from debt pool\\n            oldPrice_ = swap0to1_\\n                ? (e_.debtTokenOutImaginaryReserves * 1e27) / (e_.debtTokenInImaginaryReserves)\\n                : (e_.debtTokenInImaginaryReserves * 1e27) / (e_.debtTokenOutImaginaryReserves);\\n            newPrice_ = swap0to1_\\n                ? ((e_.debtTokenOutImaginaryReserves - e_.amountOutDebtAdjusted) * 1e27) /\\n                    (e_.debtTokenInImaginaryReserves + e_.amountInDebtAdjusted)\\n                : ((e_.debtTokenInImaginaryReserves + e_.amountInDebtAdjusted) * 1e27) /\\n                    (e_.debtTokenOutImaginaryReserves - e_.amountOutDebtAdjusted);\\n        }\\n\\n        uint256 priceDiff_ = oldPrice_ > newPrice_ ? oldPrice_ - newPrice_ : newPrice_ - oldPrice_;\\n        if (priceDiff_ > ((oldPrice_ * ORACLE_LIMIT) / 1e18)) {\\n            // if price diff is > 5% then swap would revert.\\n            return 0;\\n        }\\n\\n        return amountOut_;\\n    }\\n\\n    /// @notice estimates swap OUT tokens execution\\n    /// @param dex_ Dex pool\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountOut_ The exact amount of tokens to receive after swap\\n    /// @param amountInMax_ Maximum amount of tokens to swap in\\n    /// @return amountIn_ The amount of input tokens used for the swap\\n    function estimateSwapOut(\\n        address dex_,\\n        bool swap0to1_,\\n        uint256 amountOut_,\\n        uint256 amountInMax_\\n    ) public payable returns (uint256 amountIn_) {\\n        try IFluidDexT1(dex_).swapOut{ value: msg.value }(swap0to1_, amountOut_, amountInMax_, ADDRESS_DEAD) {} catch (\\n            bytes memory lowLevelData_\\n        ) {\\n            (amountIn_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSwapResult.selector);\\n        }\\n\\n        EstimateMemoryVars memory e_;\\n        {\\n            IFluidDexT1.CollateralReserves memory colReserves_ = getDexCollateralReservesAdjusted(dex_);\\n            IFluidDexT1.DebtReserves memory debtReserves_ = getDexDebtReservesAdjusted(dex_);\\n            if (swap0to1_) {\\n                e_.colTokenInImaginaryReserves = colReserves_.token0ImaginaryReserves;\\n                e_.colTokenOutImaginaryReserves = colReserves_.token1ImaginaryReserves;\\n                e_.debtTokenInImaginaryReserves = debtReserves_.token0ImaginaryReserves;\\n                e_.debtTokenOutImaginaryReserves = debtReserves_.token1ImaginaryReserves;\\n            } else {\\n                e_.colTokenInImaginaryReserves = colReserves_.token1ImaginaryReserves;\\n                e_.colTokenOutImaginaryReserves = colReserves_.token0ImaginaryReserves;\\n                e_.debtTokenInImaginaryReserves = debtReserves_.token1ImaginaryReserves;\\n                e_.debtTokenOutImaginaryReserves = debtReserves_.token0ImaginaryReserves;\\n            }\\n        }\\n\\n        IFluidDexT1.ConstantViews2 memory constantsView2_ = IFluidDexT1(dex_).constantsView2();\\n\\n        {\\n            int256 swapRoutingAmt_;\\n            uint256 poolFee_;\\n            uint256 amountOutAdjusted_;\\n            // bring amount in to 1e12 decimals adjusted\\n            if (swap0to1_) {\\n                amountOutAdjusted_ =\\n                    (amountOut_ * constantsView2_.token1NumeratorPrecision) /\\n                    constantsView2_.token1DenominatorPrecision;\\n            } else {\\n                amountOutAdjusted_ =\\n                    (amountOut_ * constantsView2_.token0NumeratorPrecision) /\\n                    constantsView2_.token0DenominatorPrecision;\\n            }\\n\\n            {\\n                uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\\n                poolFee_ = (dexVariables2_ >> 2) & X17;\\n                bool colPoolEnabled_ = (dexVariables2_ & 1) == 1;\\n                bool debtPoolEnabled_ = (dexVariables2_ & 2) == 2;\\n                if (colPoolEnabled_ && debtPoolEnabled_) {\\n                    swapRoutingAmt_ = _swapRoutingOut(\\n                        amountOutAdjusted_,\\n                        e_.colTokenInImaginaryReserves,\\n                        e_.colTokenOutImaginaryReserves,\\n                        e_.debtTokenInImaginaryReserves,\\n                        e_.debtTokenOutImaginaryReserves\\n                    );\\n                } else if (debtPoolEnabled_) {\\n                    swapRoutingAmt_ = -1; // Route from debt pool\\n                } else if (colPoolEnabled_) {\\n                    swapRoutingAmt_ = int256(amountOutAdjusted_) + 1; // Route from collateral pool\\n                } else {\\n                    revert(\\\"No pools are enabled\\\");\\n                }\\n            }\\n\\n            if (swapRoutingAmt_ <= 0) {\\n                // Entire trade routes through debt pool\\n                e_.amountOutDebtAdjusted = amountOutAdjusted_;\\n                e_.amountInDebtAdjusted = _getAmountIn(\\n                    e_.amountOutDebtAdjusted,\\n                    e_.debtTokenInImaginaryReserves,\\n                    e_.debtTokenOutImaginaryReserves\\n                );\\n                e_.amountInDebtAdjusted = (e_.amountInDebtAdjusted * 1e6) / (1e6 - poolFee_);\\n            } else if (swapRoutingAmt_ >= int256(amountOutAdjusted_)) {\\n                // Entire trade routes through collateral pool\\n                e_.amountOutCollateralAdjusted = amountOutAdjusted_;\\n                e_.amountInCollateralAdjusted = _getAmountIn(\\n                    e_.amountOutCollateralAdjusted,\\n                    e_.colTokenInImaginaryReserves,\\n                    e_.colTokenOutImaginaryReserves\\n                );\\n                e_.amountInCollateralAdjusted = (e_.amountInCollateralAdjusted * 1e6) / (1e6 - poolFee_);\\n            } else {\\n                // Trade routes through both pools\\n                e_.amountOutCollateralAdjusted = uint(swapRoutingAmt_);\\n                e_.amountOutDebtAdjusted = amountOutAdjusted_ - e_.amountOutCollateralAdjusted;\\n\\n                e_.amountInCollateralAdjusted = _getAmountIn(\\n                    e_.amountOutCollateralAdjusted,\\n                    e_.colTokenInImaginaryReserves,\\n                    e_.colTokenOutImaginaryReserves\\n                );\\n                e_.amountInCollateralAdjusted = (e_.amountInCollateralAdjusted * 1e6) / (1e6 - poolFee_);\\n\\n                e_.amountInDebtAdjusted = _getAmountIn(\\n                    e_.amountOutDebtAdjusted,\\n                    e_.debtTokenInImaginaryReserves,\\n                    e_.debtTokenOutImaginaryReserves\\n                );\\n                e_.amountInDebtAdjusted = (e_.amountInDebtAdjusted * 1e6) / (1e6 - poolFee_);\\n            }\\n        }\\n\\n        {\\n            uint256 borrowableAdjusted_;\\n            uint256 withdrawableAdjusted_;\\n            DexLimits memory limits_ = getDexLimits(dex_);\\n\\n            // bring amount to 1e12 decimals adjusted\\n            if (swap0to1_) {\\n                borrowableAdjusted_ =\\n                    (limits_.borrowableToken1.available * constantsView2_.token1NumeratorPrecision) /\\n                    constantsView2_.token1DenominatorPrecision;\\n                withdrawableAdjusted_ =\\n                    (limits_.withdrawableToken1.available * constantsView2_.token1NumeratorPrecision) /\\n                    constantsView2_.token1DenominatorPrecision;\\n            } else {\\n                borrowableAdjusted_ =\\n                    (limits_.borrowableToken0.available * constantsView2_.token0NumeratorPrecision) /\\n                    constantsView2_.token0DenominatorPrecision;\\n                withdrawableAdjusted_ =\\n                    (limits_.withdrawableToken0.available * constantsView2_.token0NumeratorPrecision) /\\n                    constantsView2_.token0DenominatorPrecision;\\n            }\\n\\n            if (e_.amountOutDebtAdjusted > borrowableAdjusted_) {\\n                return type(uint256).max;\\n            }\\n            if (e_.amountOutCollateralAdjusted > withdrawableAdjusted_) {\\n                return type(uint256).max;\\n            }\\n        }\\n\\n        uint256 oldPrice_;\\n        uint256 newPrice_;\\n        // from whatever pool higher amount of swap is routing we are taking that as final price, does not matter much because both pools final price should be same\\n        if (e_.amountOutCollateralAdjusted > e_.amountOutDebtAdjusted) {\\n            // new pool price from col pool\\n            oldPrice_ = swap0to1_\\n                ? (e_.colTokenOutImaginaryReserves * 1e27) / (e_.colTokenInImaginaryReserves)\\n                : (e_.colTokenInImaginaryReserves * 1e27) / (e_.colTokenOutImaginaryReserves);\\n            newPrice_ = swap0to1_\\n                ? ((e_.colTokenOutImaginaryReserves - e_.amountOutCollateralAdjusted) * 1e27) /\\n                    (e_.colTokenInImaginaryReserves + e_.amountInCollateralAdjusted)\\n                : ((e_.colTokenInImaginaryReserves + e_.amountInCollateralAdjusted) * 1e27) /\\n                    (e_.colTokenOutImaginaryReserves - e_.amountOutCollateralAdjusted);\\n        } else {\\n            // new pool price from debt pool\\n            oldPrice_ = swap0to1_\\n                ? (e_.debtTokenOutImaginaryReserves * 1e27) / (e_.debtTokenInImaginaryReserves)\\n                : (e_.debtTokenInImaginaryReserves * 1e27) / (e_.debtTokenOutImaginaryReserves);\\n            newPrice_ = swap0to1_\\n                ? ((e_.debtTokenOutImaginaryReserves - e_.amountOutDebtAdjusted) * 1e27) /\\n                    (e_.debtTokenInImaginaryReserves + e_.amountInDebtAdjusted)\\n                : ((e_.debtTokenInImaginaryReserves + e_.amountInDebtAdjusted) * 1e27) /\\n                    (e_.debtTokenOutImaginaryReserves - e_.amountOutDebtAdjusted);\\n        }\\n\\n        uint256 priceDiff_ = oldPrice_ > newPrice_ ? oldPrice_ - newPrice_ : newPrice_ - oldPrice_;\\n        if (priceDiff_ > ((oldPrice_ * ORACLE_LIMIT) / 1e18)) {\\n            // if price diff is > 5% then swap would revert.\\n            return type(uint256).max;\\n        }\\n\\n        return amountIn_;\\n    }\\n\\n    function _decodeLowLevelUint1x(\\n        bytes memory lowLevelData_,\\n        bytes4 targetErrorSelector_\\n    ) internal pure returns (uint value1_) {\\n        if (lowLevelData_.length < 36) {\\n            return 0;\\n        }\\n\\n        bytes4 errorSelector_;\\n        assembly {\\n            // Extract the selector from the error data\\n            errorSelector_ := mload(add(lowLevelData_, 0x20))\\n        }\\n        if (errorSelector_ == targetErrorSelector_) {\\n            assembly {\\n                value1_ := mload(add(lowLevelData_, 36))\\n            }\\n        }\\n        // else => values remain 0\\n    }\\n}\\n\\n/// @notice Fluid Dex Reserves resolver\\n/// Implements various view-only methods to give easy access to Dex protocol reserves data.\\ncontract FluidDexReservesResolver is DexFactoryViews, DexActionEstimates {\\n    constructor(\\n        address factory_,\\n        address liquidity_,\\n        address liquidityResolver_\\n    ) Variables(factory_, liquidity_, liquidityResolver_) {}\\n\\n    /// @notice Get a Pool's address and its token addresses\\n    /// @param poolId_ The ID of the Pool\\n    /// @return pool_ The Pool data\\n    function getPool(uint256 poolId_) public view returns (Pool memory pool_) {\\n        address poolAddress_ = getPoolAddress(poolId_);\\n        (address token0_, address token1_) = getPoolTokens(poolAddress_);\\n        return Pool(poolAddress_, token0_, token1_, getPoolFee(poolAddress_));\\n    }\\n\\n    /// @notice Get a Pool's fee\\n    /// @param pool_ The Pool address\\n    /// @return fee_ The Pool fee as 1% = 10000\\n    function getPoolFee(address pool_) public view returns (uint256 fee_) {\\n        uint256 dexVariables2_ = IFluidDexT1(pool_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\\n        return (dexVariables2_ >> 2) & X17;\\n    }\\n\\n    /// @notice Get an array of all Pool addresses and their token addresses\\n    /// @return pools_ An array containing all Pool data\\n    function getAllPools() public view returns (Pool[] memory pools_) {\\n        uint256 totalPools_ = getTotalPools();\\n        pools_ = new Pool[](totalPools_);\\n        for (uint256 i; i < totalPools_; i++) {\\n            pools_[i] = getPool(i + 1);\\n        }\\n    }\\n\\n    /// @notice Get the token addresses, collateral reserves, and debt reserves for a given Pool address\\n    /// @param pool_ The Pool address\\n    /// @return poolReserves_ The Pool data with reserves.\\n    /// @dev expected to be called via callStatic\\n    function getPoolReserves(address pool_) public returns (PoolWithReserves memory poolReserves_) {\\n        (poolReserves_.token0, poolReserves_.token1) = getPoolTokens(pool_);\\n\\n        try this.getDexPricesAndExchangePrices(pool_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\\n            poolReserves_.centerPrice = pex_.centerPrice;\\n            poolReserves_.collateralReserves = _getDexCollateralReserves(pool_, pex_);\\n            poolReserves_.debtReserves = _getDexDebtReserves(pool_, pex_);\\n        } catch {\\n            poolReserves_.collateralReserves = getDexCollateralReserves(pool_);\\n            poolReserves_.debtReserves = getDexDebtReserves(pool_);\\n        }\\n\\n        poolReserves_.pool = pool_;\\n        poolReserves_.fee = getPoolFee(pool_);\\n\\n        poolReserves_.limits = getDexLimits(pool_);\\n    }\\n\\n    /// @notice Get an array of Pool addresses, their token addresses, collateral reserves, and debt reserves for a given array of Pool addresses\\n    /// @param pools_ The array of Pool addresses\\n    /// @return poolsReserves_ An array containing all Pool data with reserves\\n    /// @dev expected to be called via callStatic\\n    function getPoolsReserves(address[] memory pools_) public returns (PoolWithReserves[] memory poolsReserves_) {\\n        poolsReserves_ = new PoolWithReserves[](pools_.length);\\n        for (uint256 i; i < pools_.length; i++) {\\n            poolsReserves_[i] = getPoolReserves(pools_[i]);\\n        }\\n    }\\n\\n    /// @notice Get an array of all Pool addresses, their token addresses, collateral reserves, and debt reserves\\n    /// @return poolsReserves_ An array containing all Pool data with reserves\\n    /// @dev expected to be called via callStatic\\n    function getAllPoolsReserves() public returns (PoolWithReserves[] memory poolsReserves_) {\\n        return getPoolsReserves(getAllPoolAddresses());\\n    }\\n\\n    /// @notice Get the token addresses, adjusted collateral reserves, and adjusted debt reserves for a given Pool address\\n    /// @param pool_ The Pool address\\n    /// @return poolReserves_ The Pool data with adjusted reserves scaled to 1e12. balanceTokens are in token decimals.\\n    /// @dev expected to be called via callStatic\\n    function getPoolReservesAdjusted(address pool_) public returns (PoolWithReserves memory poolReserves_) {\\n        (poolReserves_.token0, poolReserves_.token1) = getPoolTokens(pool_);\\n\\n        try this.getDexPricesAndExchangePrices(pool_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\\n            poolReserves_.centerPrice = pex_.centerPrice;\\n            poolReserves_.collateralReserves = _getDexCollateralReservesAdjusted(pool_, pex_);\\n            poolReserves_.debtReserves = _getDexDebtReservesAdjusted(pool_, pex_);\\n        } catch {\\n            poolReserves_.collateralReserves = getDexCollateralReservesAdjusted(pool_);\\n            poolReserves_.debtReserves = getDexDebtReservesAdjusted(pool_);\\n        }\\n\\n        poolReserves_.pool = pool_;\\n        poolReserves_.fee = getPoolFee(pool_);\\n\\n        poolReserves_.limits = getDexLimits(pool_);\\n    }\\n\\n    /// @notice Get an array of Pool addresses, their token addresses, adjusted collateral reserves, and adjusted debt reserves for a given array of Pool addresses\\n    /// @param pools_ The array of Pool addresses\\n    /// @return poolsReserves_ An array containing all Pool data with adjusted reserves scaled to 1e12\\n    /// @dev expected to be called via callStatic\\n    function getPoolsReservesAdjusted(\\n        address[] memory pools_\\n    ) public returns (PoolWithReserves[] memory poolsReserves_) {\\n        poolsReserves_ = new PoolWithReserves[](pools_.length);\\n        for (uint256 i; i < pools_.length; i++) {\\n            poolsReserves_[i] = getPoolReservesAdjusted(pools_[i]);\\n        }\\n    }\\n\\n    /// @notice Get an array of all Pool addresses, their token addresses, adjusted collateral reserves, and adjusted debt reserves\\n    /// @return poolsReserves_ An array containing all Pool data with adjusted reserves scaled to 1e12\\n    /// @dev expected to be called via callStatic\\n    function getAllPoolsReservesAdjusted() public returns (PoolWithReserves[] memory poolsReserves_) {\\n        return getPoolsReservesAdjusted(getAllPoolAddresses());\\n    }\\n}\\n\",\"keccak256\":\"0xafdefe65e958bfdf927427a39abe97373f9b7b1dd84b44a4aa19048f232b2cf9\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/dexReserves/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidDexT1 } from \\\"../../../protocols/dex/interfaces/iDexT1.sol\\\";\\n\\nabstract contract Structs {\\n    struct Pool {\\n        address pool;\\n        address token0;\\n        address token1;\\n        uint256 fee;\\n    }\\n\\n    struct PoolWithReserves {\\n        address pool;\\n        address token0;\\n        address token1;\\n        uint256 fee;\\n        uint256 centerPrice;\\n        IFluidDexT1.CollateralReserves collateralReserves;\\n        IFluidDexT1.DebtReserves debtReserves;\\n        DexLimits limits;\\n    }\\n\\n    struct TokenLimit {\\n        // both `available` and `expandsTo` limits consider:\\n        // - max utilization (at Liquidity layer and at Dex, for withdrawable only dex)\\n        // - withdraw limits / borrow limits\\n        // - balances at liquidity layer\\n        uint256 available; // maximum available swap amount\\n        uint256 expandsTo; // maximum amount the available swap amount expands to\\n        uint256 expandDuration; // duration for `available` to grow to `expandsTo`\\n    }\\n\\n    struct DexLimits {\\n        TokenLimit withdrawableToken0;\\n        TokenLimit withdrawableToken1;\\n        TokenLimit borrowableToken0;\\n        TokenLimit borrowableToken1;\\n    }\\n}\\n\",\"keccak256\":\"0x0bab8d3344e507c595dcec8590277f87c90c8c2582c785b8bdde99345a7eb749\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/dexReserves/variables.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidDexFactory } from \\\"../../../protocols/dex/interfaces/iDexFactory.sol\\\";\\nimport { IFluidLiquidityResolver } from \\\"../liquidity/iLiquidityResolver.sol\\\";\\n\\ninterface IFluidLiquidity {\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n}\\n\\nabstract contract Variables {\\n    uint256 internal constant X10 = 0x3ff;\\n    uint256 internal constant X17 = 0x1ffff;\\n\\n    uint256 internal constant ORACLE_LIMIT = 5 * 1e16; // 5%\\n\\n    /// @dev address that is mapped to the chain native token\\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    IFluidDexFactory public immutable FACTORY;\\n    IFluidLiquidity public immutable LIQUIDITY;\\n    IFluidLiquidityResolver public immutable LIQUIDITY_RESOLVER;\\n\\n    constructor(address factory_, address liquidity_, address liquidityResolver_) {\\n        FACTORY = IFluidDexFactory(factory_);\\n        LIQUIDITY = IFluidLiquidity(liquidity_);\\n        LIQUIDITY_RESOLVER = IFluidLiquidityResolver(liquidityResolver_);\\n    }\\n}\\n\",\"keccak256\":\"0x766e526c1f5c332e398602fc26a8adec74fcf02e1bc7df9af495bd3f85057e09\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/liquidity/iLiquidityResolver.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { Structs as LiquidityStructs } from \\\"../../../periphery/resolvers/liquidity/structs.sol\\\";\\n\\ninterface IFluidLiquidityResolver {\\n    /// @notice gets the `revenueAmount_` for a `token_`.\\n    function getRevenue(address token_) external view returns (uint256 revenueAmount_);\\n\\n    /// @notice address of contract that gets sent the revenue. Configurable by governance\\n    function getRevenueCollector() external view returns (address);\\n\\n    /// @notice Liquidity contract paused status: status = 1 -> normal. status = 2 -> paused.\\n    function getStatus() external view returns (uint256);\\n\\n    /// @notice checks if `auth_` is an allowed auth on Liquidity.\\n    /// Auths can set most config values. E.g. contracts that automate certain flows like e.g. adding a new fToken.\\n    /// Governance can add/remove auths. Governance is auth by default.\\n    function isAuth(address auth_) external view returns (uint256);\\n\\n    /// @notice checks if `guardian_` is an allowed Guardian on Liquidity.\\n    /// Guardians can pause lower class users.\\n    /// Governance can add/remove guardians. Governance is guardian by default.\\n    function isGuardian(address guardian_) external view returns (uint256);\\n\\n    /// @notice gets user class for `user_`. Class defines which protocols can be paused by guardians.\\n    /// Currently there are 2 classes: 0 can be paused by guardians. 1 cannot be paused by guardians.\\n    /// New protocols are added as class 0 and will be upgraded to 1 over time.\\n    function getUserClass(address user_) external view returns (uint256);\\n\\n    /// @notice gets exchangePricesAndConfig packed uint256 storage slot for `token_`.\\n    function getExchangePricesAndConfig(address token_) external view returns (uint256);\\n\\n    /// @notice gets rateConfig packed uint256 storage slot for `token_`.\\n    function getRateConfig(address token_) external view returns (uint256);\\n\\n    /// @notice gets totalAmounts packed uint256 storage slot for `token_`.\\n    function getTotalAmounts(address token_) external view returns (uint256);\\n\\n    /// @notice gets configs2 packed uint256 storage slot for `token_`.\\n    function getConfigs2(address token_) external view returns (uint256);\\n\\n    /// @notice gets userSupply data packed uint256 storage slot for `user_` and `token_`.\\n    function getUserSupply(address user_, address token_) external view returns (uint256);\\n\\n    /// @notice gets userBorrow data packed uint256 storage slot for `user_` and `token_`.\\n    function getUserBorrow(address user_, address token_) external view returns (uint256);\\n\\n    /// @notice returns all `listedTokens_` at the Liquidity contract. Once configured, a token can never be removed.\\n    function listedTokens() external view returns (address[] memory listedTokens_);\\n\\n    /// @notice get the Rate config data `rateData_` for a `token_` compiled from the packed uint256 rateConfig storage slot\\n    function getTokenRateData(address token_) external view returns (LiquidityStructs.RateData memory rateData_);\\n\\n    /// @notice get the Rate config datas `rateDatas_` for multiple `tokens_` compiled from the packed uint256 rateConfig storage slot\\n    function getTokensRateData(\\n        address[] calldata tokens_\\n    ) external view returns (LiquidityStructs.RateData[] memory rateDatas_);\\n\\n    /// @notice returns general data for `token_` such as rates, exchange prices, utilization, fee, total amounts etc.\\n    function getOverallTokenData(\\n        address token_\\n    ) external view returns (LiquidityStructs.OverallTokenData memory overallTokenData_);\\n\\n    /// @notice returns general data for multiple `tokens_` such as rates, exchange prices, utilization, fee, total amounts etc.\\n    function getOverallTokensData(\\n        address[] calldata tokens_\\n    ) external view returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\\n\\n    /// @notice returns general data for all `listedTokens()` such as rates, exchange prices, utilization, fee, total amounts etc.\\n    function getAllOverallTokensData()\\n        external\\n        view\\n        returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\\n\\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\\n    function getUserSupplyData(\\n        address user_,\\n        address token_\\n    )\\n        external\\n        view\\n        returns (\\n            LiquidityStructs.UserSupplyData memory userSupplyData_,\\n            LiquidityStructs.OverallTokenData memory overallTokenData_\\n        );\\n\\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\\n    function getUserMultipleSupplyData(\\n        address user_,\\n        address[] calldata tokens_\\n    )\\n        external\\n        view\\n        returns (\\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\\n        );\\n\\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\\n    function getUserBorrowData(\\n        address user_,\\n        address token_\\n    )\\n        external\\n        view\\n        returns (\\n            LiquidityStructs.UserBorrowData memory userBorrowData_,\\n            LiquidityStructs.OverallTokenData memory overallTokenData_\\n        );\\n\\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\\n    function getUserMultipleBorrowData(\\n        address user_,\\n        address[] calldata tokens_\\n    )\\n        external\\n        view\\n        returns (\\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\\n        );\\n\\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `supplyTokens_`\\n    ///     and returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `borrowTokens_`\\n    function getUserMultipleBorrowSupplyData(\\n        address user_,\\n        address[] calldata supplyTokens_,\\n        address[] calldata borrowTokens_\\n    )\\n        external\\n        view\\n        returns (\\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\\n            LiquidityStructs.OverallTokenData[] memory overallSupplyTokensData_,\\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\\n            LiquidityStructs.OverallTokenData[] memory overallBorrowTokensData_\\n        );\\n}\\n\",\"keccak256\":\"0x241d94b63793c9fb2111bb4ec04035e1fa14ee7e0551683ea05460baa6000189\",\"license\":\"MIT\"},\"contracts/periphery/resolvers/liquidity/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Structs as AdminModuleStructs } from \\\"../../../liquidity/adminModule/structs.sol\\\";\\n\\nabstract contract Structs {\\n    struct RateData {\\n        uint256 version;\\n        AdminModuleStructs.RateDataV1Params rateDataV1;\\n        AdminModuleStructs.RateDataV2Params rateDataV2;\\n    }\\n\\n    struct OverallTokenData {\\n        uint256 borrowRate;\\n        uint256 supplyRate;\\n        uint256 fee; // revenue fee\\n        uint256 lastStoredUtilization;\\n        uint256 storageUpdateThreshold;\\n        uint256 lastUpdateTimestamp;\\n        uint256 supplyExchangePrice;\\n        uint256 borrowExchangePrice;\\n        uint256 supplyRawInterest;\\n        uint256 supplyInterestFree;\\n        uint256 borrowRawInterest;\\n        uint256 borrowInterestFree;\\n        uint256 totalSupply;\\n        uint256 totalBorrow;\\n        uint256 revenue;\\n        uint256 maxUtilization; // maximum allowed utilization\\n        RateData rateData;\\n    }\\n\\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\\n    struct UserSupplyData {\\n        bool modeWithInterest; // true if mode = with interest, false = without interest\\n        uint256 supply; // user supply amount\\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\\n        uint256 withdrawalLimit;\\n        uint256 lastUpdateTimestamp;\\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\\n        uint256 baseWithdrawalLimit;\\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\\n        uint256 withdrawableUntilLimit;\\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\\n    }\\n\\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\\n    struct UserBorrowData {\\n        bool modeWithInterest; // true if mode = with interest, false = without interest\\n        uint256 borrow; // user borrow amount\\n        uint256 borrowLimit;\\n        uint256 lastUpdateTimestamp;\\n        uint256 expandPercent;\\n        uint256 expandDuration;\\n        uint256 baseBorrowLimit;\\n        uint256 maxBorrowLimit;\\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\\n    }\\n}\\n\",\"keccak256\":\"0xf8a59b6c7963d0bd43be07db0c594e278f97e6dfa498dee8436e3707dd9f574e\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/interfaces/iDexFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IFluidDexFactory {\\n    /// @notice Global auth is auth for all dexes\\n    function isGlobalAuth(address auth_) external view returns (bool);\\n\\n    /// @notice Dex auth is auth for a specific dex\\n    function isDexAuth(address vault_, address auth_) external view returns (bool);\\n\\n    /// @notice Total dexes deployed.\\n    function totalDexes() external view returns (uint256);\\n\\n    /// @notice Compute dexAddress\\n    function getDexAddress(uint256 dexId_) external view returns (address);\\n\\n    /// @notice read uint256 `result_` for a storage `slot_` key\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n}\\n\",\"keccak256\":\"0xfc81e2f8de72dcf84022b69495996f59fe560cac430767f504de1064c32f550e\",\"license\":\"MIT\"},\"contracts/protocols/dex/interfaces/iDexT1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IFluidDexT1 {\\n    error FluidDexError(uint256 errorId);\\n\\n    /// @notice used to simulate swap to find the output amount\\n    error FluidDexSwapResult(uint256 amountOut);\\n\\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\\n\\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\\n\\n    error FluidDexLiquidityOutput(uint256 shares);\\n\\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\\n\\n    /// @notice returns the dex id\\n    function DEX_ID() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct Implementations {\\n        address shift;\\n        address admin;\\n        address colOperations;\\n        address debtOperations;\\n        address perfectOperationsAndOracle;\\n    }\\n\\n    struct ConstantViews {\\n        uint256 dexId;\\n        address liquidity;\\n        address factory;\\n        Implementations implementations;\\n        address deployerContract;\\n        address token0;\\n        address token1;\\n        bytes32 supplyToken0Slot;\\n        bytes32 borrowToken0Slot;\\n        bytes32 supplyToken1Slot;\\n        bytes32 borrowToken1Slot;\\n        bytes32 exchangePriceToken0Slot;\\n        bytes32 exchangePriceToken1Slot;\\n        uint256 oracleMapping;\\n    }\\n\\n    struct ConstantViews2 {\\n        uint token0NumeratorPrecision;\\n        uint token0DenominatorPrecision;\\n        uint token1NumeratorPrecision;\\n        uint token1DenominatorPrecision;\\n    }\\n\\n    struct PricesAndExchangePrice {\\n        uint lastStoredPrice; // last stored price in 1e27 decimals\\n        uint centerPrice; // last stored price in 1e27 decimals\\n        uint upperRange; // price at upper range in 1e27 decimals\\n        uint lowerRange; // price at lower range in 1e27 decimals\\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\\n        uint supplyToken0ExchangePrice;\\n        uint borrowToken0ExchangePrice;\\n        uint supplyToken1ExchangePrice;\\n        uint borrowToken1ExchangePrice;\\n    }\\n\\n    struct CollateralReserves {\\n        uint token0RealReserves;\\n        uint token1RealReserves;\\n        uint token0ImaginaryReserves;\\n        uint token1ImaginaryReserves;\\n    }\\n\\n    struct DebtReserves {\\n        uint token0Debt;\\n        uint token1Debt;\\n        uint token0RealReserves;\\n        uint token1RealReserves;\\n        uint token0ImaginaryReserves;\\n        uint token1ImaginaryReserves;\\n    }\\n\\n    function getCollateralReserves(\\n        uint geometricMean_,\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint token0SupplyExchangePrice_,\\n        uint token1SupplyExchangePrice_\\n    ) external view returns (CollateralReserves memory c_);\\n\\n    function getDebtReserves(\\n        uint geometricMean_,\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint token0BorrowExchangePrice_,\\n        uint token1BorrowExchangePrice_\\n    ) external view returns (DebtReserves memory d_);\\n\\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\\n    function getPricesAndExchangePrices() external;\\n\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\\n\\n    struct Oracle {\\n        uint twap1by0; // TWAP price\\n        uint lowestPrice1by0; // lowest price point\\n        uint highestPrice1by0; // highest price point\\n        uint twap0by1; // TWAP price\\n        uint lowestPrice0by1; // lowest price point\\n        uint highestPrice0by1; // highest price point\\n    }\\n\\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountIn_ The exact amount of input tokens to swap\\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\\n    /// @return amountOut_ The amount of output tokens received from the swap\\n    function swapIn(\\n        bool swap0to1_,\\n        uint256 amountIn_,\\n        uint256 amountOutMin_,\\n        address to_\\n    ) external payable returns (uint256 amountOut_);\\n\\n    /// @dev Swap tokens with perfect amount in and callback functionality\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountIn_ The exact amount of tokens to swap in\\n    /// @param amountOutMin_ The minimum amount of tokens to receive after swap\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\\n    /// @return amountOut_ The amount of output tokens received from the swap\\n    function swapInWithCallback(\\n        bool swap0to1_,\\n        uint256 amountIn_,\\n        uint256 amountOutMin_,\\n        address to_\\n    ) external payable returns (uint256 amountOut_);\\n\\n    /// @dev Swap tokens with perfect amount out\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountOut_ The exact amount of tokens to receive after swap\\n    /// @param amountInMax_ Maximum amount of tokens to swap in\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\\n    /// @return amountIn_ The amount of input tokens used for the swap\\n    function swapOut(\\n        bool swap0to1_,\\n        uint256 amountOut_,\\n        uint256 amountInMax_,\\n        address to_\\n    ) external payable returns (uint256 amountIn_);\\n\\n    /// @dev Swap tokens with perfect amount out and callback functionality\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountOut_ The exact amount of tokens to receive after swap\\n    /// @param amountInMax_ Maximum amount of tokens to swap in\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\\n    /// @return amountIn_ The amount of input tokens used for the swap\\n    function swapOutWithCallback(\\n        bool swap0to1_,\\n        uint256 amountOut_,\\n        uint256 amountInMax_,\\n        address to_\\n    ) external payable returns (uint256 amountIn_);\\n\\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\\n    /// @param shares_ The number of shares to mint\\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\\n    /// @return token0Amt_ Amount of token0 deposited\\n    /// @return token1Amt_ Amount of token1 deposited\\n    function depositPerfect(\\n        uint shares_,\\n        uint maxToken0Deposit_,\\n        uint maxToken1Deposit_,\\n        bool estimate_\\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\\n    /// @param shares_ The number of shares to withdraw\\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\\n    /// @return token0Amt_ The amount of token0 withdrawn\\n    /// @return token1Amt_ The amount of token1 withdrawn\\n    function withdrawPerfect(\\n        uint shares_,\\n        uint minToken0Withdraw_,\\n        uint minToken1Withdraw_,\\n        address to_\\n    ) external returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\\n    /// @param shares_ The number of shares to borrow\\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\\n    /// @return token0Amt_ Amount of token0 borrowed\\n    /// @return token1Amt_ Amount of token1 borrowed\\n    function borrowPerfect(\\n        uint shares_,\\n        uint minToken0Borrow_,\\n        uint minToken1Borrow_,\\n        address to_\\n    ) external returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\\n    /// @param shares_ The number of shares to pay back\\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\\n    /// @return token0Amt_ Amount of token0 paid back\\n    /// @return token1Amt_ Amount of token1 paid back\\n    function paybackPerfect(\\n        uint shares_,\\n        uint maxToken0Payback_,\\n        uint maxToken1Payback_,\\n        bool estimate_\\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\\n    /// @param token0Amt_ The amount of token0 to deposit\\n    /// @param token1Amt_ The amount of token1 to deposit\\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\\n    /// @return shares_ The amount of shares minted for the deposit\\n    function deposit(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint minSharesAmt_,\\n        bool estimate_\\n    ) external payable returns (uint shares_);\\n\\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\\n    /// @param token0Amt_ The amount of token0 to withdraw\\n    /// @param token1Amt_ The amount of token1 to withdraw\\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\\n    /// @return shares_ The number of shares burned for the withdrawal\\n    function withdraw(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint maxSharesAmt_,\\n        address to_\\n    ) external returns (uint shares_);\\n\\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\\n    /// @param token0Amt_ The amount of token0 to borrow\\n    /// @param token1Amt_ The amount of token1 to borrow\\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\\n    function borrow(uint token0Amt_, uint token1Amt_, uint maxSharesAmt_, address to_) external returns (uint shares_);\\n\\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\\n    /// @param token0Amt_ The amount of token0 to payback\\n    /// @param token1Amt_ The amount of token1 to payback\\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\\n    /// @return shares_ The amount of borrow shares burned for the payback\\n    function payback(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint minSharesAmt_,\\n        bool estimate_\\n    ) external payable returns (uint shares_);\\n\\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\\n    /// @param shares_ The number of shares to burn for withdrawal\\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\\n    function withdrawPerfectInOneToken(\\n        uint shares_,\\n        uint minToken0_,\\n        uint minToken1_,\\n        address to_\\n    ) external returns (uint withdrawAmt_);\\n\\n    /// @dev This function allows users to payback their debt with perfect shares in one token\\n    /// @param shares_ The number of shares to burn for payback\\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\\n    function paybackPerfectInOneToken(\\n        uint shares_,\\n        uint maxToken0_,\\n        uint maxToken1_,\\n        bool estimate_\\n    ) external payable returns (uint paybackAmt_);\\n\\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\\n    /// but the difference due to interest will be super low so this difference is ignored\\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\\n    /// @return currentPrice_ price of pool after the most recent swap\\n    function oraclePrice(uint[] memory secondsAgos_) external view returns (Oracle[] memory twaps_, uint currentPrice_);\\n}\\n\",\"keccak256\":\"0xd48834505ffcaa7523bf84e5c2da27e585b865f11d4fd75d6088696bfc40d47f\",\"license\":\"MIT\"},\"solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1b62af9baf5b8e991ed7531bc87f45550ba9d61e8dbff5caf237ccaf3a3fd843\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x60e06040523480156200001157600080fd5b50604051620060953803806200609583398101604081905262000034916200006f565b6001600160a01b0392831660805290821660a0521660c052620000b9565b80516001600160a01b03811681146200006a57600080fd5b919050565b6000806000606084860312156200008557600080fd5b620000908462000052565b9250620000a06020850162000052565b9150620000b06040850162000052565b90509250925092565b60805160a05160c051615f4a6200014b6000396000818161046701528181610a3201528181610af301528181610bb40152610c730152600081816102e801528181610ed001528181610f4a015281816110170152818161113d0152818161136d015281816113e7015281816114b401526115da01526000818161031c0152818161061e0152613ac20152615f4a6000f3fe6080604052600436106101a05760003560e01c80636902f79f116100e1578063c0eec0e81161008a578063d3ffe67a11610064578063d3ffe67a146105a0578063d88ff1f4146105b5578063dde04706146105d7578063fccca03c146105f757600080fd5b8063c0eec0e814610511578063c56f1b4414610531578063ca4f28031461055357600080fd5b8063a5973763116100bb578063a5973763146104be578063bb39e3a1146104de578063bd964d38146104f157600080fd5b80636902f79f146104555780636e38c02314610489578063957755e61461049e57600080fd5b8063333d01a91161014e578063425711371161012857806342571137146103ba57806342fcc6fb146103db5780634bee9395146103fb57806355181f111461042857600080fd5b8063333d01a91461033e5780633973a11b146103605780633ec841e41461038d57600080fd5b8063180f4c651161017f578063180f4c65146102a95780632861c7d1146102d65780632dd310001461030a57600080fd5b8062a5ae21146101a5578063015f6cfa146101ef578063068bcd8d1461027c575b600080fd5b3480156101b157600080fd5b506101c56101c0366004614f41565b610617565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b3480156101fb57600080fd5b5061020f61020a366004614f7f565b610649565b6040516101e69190600061012082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015261010080840151818401525092915050565b34801561028857600080fd5b5061029c610297366004614f41565b6107a9565b6040516101e69190614f9c565b3480156102b557600080fd5b506102c96102c4366004614f7f565b61085b565b6040516101e69190615072565b3480156102e257600080fd5b506101c57f000000000000000000000000000000000000000000000000000000000000000081565b34801561031657600080fd5b506101c57f000000000000000000000000000000000000000000000000000000000000000081565b34801561034a57600080fd5b50610353611ce4565b6040516101e69190615153565b34801561036c57600080fd5b5061038061037b366004614f7f565b611cf6565b6040516101e691906151a2565b34801561039957600080fd5b506103ad6103a8366004614f7f565b611e03565b6040516101e69190615334565b6103cd6103c836600461536d565b611e9d565b6040519081526020016101e6565b3480156103e757600080fd5b506103cd6103f6366004614f7f565b6127eb565b34801561040757600080fd5b5061041b610416366004614f7f565b61288e565b6040516101e691906153b3565b34801561043457600080fd5b50610448610443366004614f7f565b6129e3565b6040516101e691906153c2565b34801561046157600080fd5b506101c57f000000000000000000000000000000000000000000000000000000000000000081565b34801561049557600080fd5b50610353612beb565b3480156104aa57600080fd5b506103ad6104b9366004614f7f565b612bf8565b3480156104ca57600080fd5b506103536104d936600461555f565b612dd0565b6103cd6104ec36600461536d565b612e86565b3480156104fd57600080fd5b5061041b61050c366004614f7f565b613697565b34801561051d57600080fd5b506103ad61052c366004614f7f565b6137a1565b34801561053d57600080fd5b50610546613979565b6040516101e69190615605565b34801561055f57600080fd5b5061057361056e366004614f7f565b613a33565b6040805173ffffffffffffffffffffffffffffffffffffffff9384168152929091166020830152016101e6565b3480156105ac57600080fd5b506103cd613abe565b3480156105c157600080fd5b506105ca613b4f565b6040516101e69190615653565b3480156105e357600080fd5b506104486105f2366004614f7f565b613c32565b34801561060357600080fd5b5061035361061236600461555f565b613e34565b60006106437f000000000000000000000000000000000000000000000000000000000000000083613eea565b92915050565b6106986040518061012001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b8173ffffffffffffffffffffffffffffffffffffffff1663916cef4e6040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156106e057600080fd5b505af19250505080156106f1575060015b6107a4573d80801561071f576040519150601f19603f3d011682016040523d82523d6000602084013e610724565b606091505b5060208101517fdc4022c5000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008216016107a15761078b8260048085516107869190615701565b614354565b80602001905181019061079e9190615714565b92505b50505b919050565b6040805160808101825260008082526020820181905291810182905260608101829052906107d683610617565b90506000806107e483613a33565b9150915060405180608001604052808473ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff168152602001610850856127eb565b905295945050505050565b610863614c72565b6108b460405180610120016040528060001515815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b61090560405180610120016040528060001515815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b61090d614d21565b610915614d21565b610974604051806101600160405280600015158152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6109d3604051806101600160405280600015158152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000806109df8a613a33565b6040517fe72ef91b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8d8116600483015280841660248301529294509092507f00000000000000000000000000000000000000000000000000000000000000009091169063e72ef91b906044016104c060405180830381865afa158015610a7c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aa091906159c0565b6040517fe72ef91b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8d811660048301528481166024830152929a509097507f00000000000000000000000000000000000000000000000000000000000000009091169063e72ef91b906044016104c060405180830381865afa158015610b3d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6191906159c0565b6040517f967915d600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8d8116600483015285811660248301529299509096507f00000000000000000000000000000000000000000000000000000000000000009091169063967915d69060440161050060405180830381865afa158015610bfe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c229190615a66565b506040517f967915d600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8c8116600483015283811660248301529195507f00000000000000000000000000000000000000000000000000000000000000009091169063967915d69060440161050060405180830381865afa158015610cbd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ce19190615a66565b506040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015290935060009073ffffffffffffffffffffffffffffffffffffffff8c169063b5c736e490602401602060405180830381865afa158015610d53573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d779190615b19565b90506000610d8e60e483901c6103ff16600a615b32565b9050600081905080896101e001511015610daa57506101e08801515b6000612710828b6101800151610dc09190615b32565b610dca9190615b78565b9050808a6101a001511015611203578215610e0257828a6101a00151612710610df39190615b32565b610dfd9190615b78565b610e05565b60005b8d51528c51516101808b015111610e1d576000610e30565b8c51516101808b0151610e309190615701565b8d51528c5180516020909101526101a08a0151610e4d9082615701565b60408e01805191909152518051602090910152600073ffffffffffffffffffffffffffffffffffffffff871673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14610f48576040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000811660048301528816906370a0823190602401602060405180830381865afa158015610f1f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f439190615b19565b610f81565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16315b90507fffffffffffffffffffffffff32a01dc37a7df0848d2f6d90364fa4bc1ca6481273ffffffffffffffffffffffffffffffffffffffff8816016110a9576040517fb203bb9900000000000000000000000000000000000000000000000000000000815273cd5fe23c85820f7b72d0926fc9b05b43e359b7ee600482015273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016602482015273f047ab4c75cebf0eb9ed34ae2c186f3611aeafa69063b203bb9990604401602060405180830381865afa158015611078573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061109c9190615b19565b6110a69082615b8c565b90505b7fffffffffffffffffffffffff6e83117fe59806cc0d194cc03f32e12d2a6f627873ffffffffffffffffffffffffffffffffffffffff8816016111cf576040517fb203bb9900000000000000000000000000000000000000000000000000000000815273917cee801a67f933f2e6b33fc0cd1ed2d5909d88600482015273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016602482015273f047ab4c75cebf0eb9ed34ae2c186f3611aeafa69063b203bb9990604401602060405180830381865afa15801561119e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111c29190615b19565b6111cc9082615b8c565b90505b8d51602001518110156111e5578d516020018190525b808e604001516020015111156112015760408e01516020018190525b505b50505060006103ff60ee83901c16600a61121d9190615b32565b9050600081905080886101e00151101561123957506101e08701515b6000612710828a610180015161124f9190615b32565b6112599190615b78565b905080896101a0015110156116a55782156112915782896101a001516127106112829190615b32565b61128c9190615b78565b611294565b60005b60208e0180519190915251516101808a0151116112b25760006112c8565b60208d0151516101808a01516112c89190615701565b6020808f01805192909252905180519101526101a08901516112ea9082615701565b60608e01805191909152518051602090910152600073ffffffffffffffffffffffffffffffffffffffff861673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee146113e5576040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000811660048301528716906370a0823190602401602060405180830381865afa1580156113bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113e09190615b19565b61141e565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16315b90507fffffffffffffffffffffffff32a01dc37a7df0848d2f6d90364fa4bc1ca6481273ffffffffffffffffffffffffffffffffffffffff871601611546576040517fb203bb9900000000000000000000000000000000000000000000000000000000815273cd5fe23c85820f7b72d0926fc9b05b43e359b7ee600482015273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016602482015273f047ab4c75cebf0eb9ed34ae2c186f3611aeafa69063b203bb9990604401602060405180830381865afa158015611515573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115399190615b19565b6115439082615b8c565b90505b7fffffffffffffffffffffffff6e83117fe59806cc0d194cc03f32e12d2a6f627873ffffffffffffffffffffffffffffffffffffffff87160161166c576040517fb203bb9900000000000000000000000000000000000000000000000000000000815273917cee801a67f933f2e6b33fc0cd1ed2d5909d88600482015273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016602482015273f047ab4c75cebf0eb9ed34ae2c186f3611aeafa69063b203bb9990604401602060405180830381865afa15801561163b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061165f9190615b19565b6116699082615b8c565b90505b808e60200151602001511115611687576020808f0151018190525b808e606001516020015111156116a35760608e01516020018190525b505b50505050505060008660a0015187606001516116c19190615b8c565b90508042116116d9576116d44282615701565b6116dc565b60005b90506000612710886020015189608001516116f79190615b32565b6117019190615b78565b905080886101000151111561171c5750506101008601516000905b8851602001518111611776578851602001819052801561176c5760a08801516101008901518a516020015183929161175391615701565b61175d9190615b32565b6117679190615b78565b61176f565b60005b91506117df565b885160200151610100890151111561179d57885160200151610100890152600091506117df565b80156117d95760a08801516101008901518a51602001518392916117c091615701565b6117ca9190615b32565b6117d49190615b78565b6117dc565b60005b91505b5087516040015260a085015160608601516000916117fc91615b8c565b90508042116118145761180f4282615701565b611817565b60005b90506000612710876020015188608001516118329190615b32565b61183c9190615b78565b90508087610100015111156118575750506101008501516000905b88602001516020015181116118b8576020808a01510181905280156118ae57808760a001518861010001518b60200151602001516118959190615701565b61189f9190615b32565b6118a99190615b78565b6118b1565b60005b9150611928565b88602001516020015187610100015111156118e4576020808a0151015161010088015260009150611928565b801561192257808760a001518861010001518b60200151602001516119099190615701565b6119139190615b32565b61191d9190615b78565b611925565b60005b91505b5060208801516040015260a0820151606083015160009161194891615b8c565b90508042116119605761195b4282615701565b611963565b60005b905060006127108460200151856080015161197e9190615b32565b6119889190615b78565b9050600084602001518560e00151116119a25760006119b6565b84602001518560e001516119b69190615701565b9050808a604001516020015111156119d45760408a01516020018190525b508084610120015111156119ee5750506101208201516000905b8860400151602001518111611a505760408901516020018190528015611a4657808460a001518561012001518b6040015160200151611a2d9190615701565b611a379190615b32565b611a419190615b78565b611a49565b60005b9150611ac1565b8860400151602001518461012001511115611a7d5760408901516020015161012085015260009150611ac1565b8015611abb57808460a001518561012001518b6040015160200151611aa29190615701565b611aac9190615b32565b611ab69190615b78565b611abe565b60005b91505b50604080890151015260a08101516060820151600091611ae091615b8c565b9050804211611af857611af34282615701565b611afb565b60005b9050600061271083602001518460800151611b169190615b32565b611b209190615b78565b9050600083602001518460e0015111611b3a576000611b4e565b83602001518460e00151611b4e9190615701565b9050808a60600151602001511115611b6c5760608a01516020018190525b50808361012001511115611b865750506101208101516000905b8860600151602001518111611be85760608901516020018190528015611bde57808360a001518461012001518b6060015160200151611bc59190615701565b611bcf9190615b32565b611bd99190615b78565b611be1565b60005b9150611c59565b8860600151602001518361012001511115611c155760608901516020015161012084015260009150611c59565b8015611c5357808360a001518461012001518b6060015160200151611c3a9190615701565b611c449190615b32565b611c4e9190615b78565b611c56565b60005b91505b506060880151604001528651516101008601511015611c7c576101008601518751525b6020870151516101008601511015611c9b576101008501516020880151525b6040870151516101208301511015611cba576101208201516040880151525b6060870151516101208201511015611cd9576101208101516060880151525b505050505050919050565b6060611cf1610612613979565b905090565b611d93604080516101c08101825260008082526020808301829052828401829052835160a08101855282815290810182905292830181905260608381018290526080840191909152909190820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c0820181905260e08201819052610100820181905261012082018190526101409091015290565b8173ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa158015611ddf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106439190615c1a565b611e2e6040518060800160405280600081526020016000815260200160008152602001600081525090565b8173ffffffffffffffffffffffffffffffffffffffff16631595cbd36040518163ffffffff1660e01b8152600401608060405180830381865afa158015611e79573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106439190615d67565b6040517f286f0e610000000000000000000000000000000000000000000000000000000081528315156004820152602481018390526044810182905261dead606482015260009073ffffffffffffffffffffffffffffffffffffffff86169063286f0e6190349060840160206040518083038185885af193505050508015611f60575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252611f5d91810190615b19565b60015b611fc6573d808015611f8e576040519150601f19603f3d011682016040523d82523d6000602084013e611f93565b606091505b50611fbe817fb3bfda99000000000000000000000000000000000000000000000000000000006144cb565b915050611fc8565b505b61201060405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b600061201b876137a1565b9050600061202888613c32565b9050861561205d576040808301518452606080840151602086015260808301519185019190915260a082015190840152612083565b6060808301518452604080840151602086015260a0830151908501526080820151908401525b505060008673ffffffffffffffffffffffffffffffffffffffff16631595cbd36040518163ffffffff1660e01b8152600401608060405180830381865afa1580156120d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120f69190615d67565b9050600080600088156121285760608401516040850151612117908a615b32565b6121219190615b78565b9050612146565b60208401518451612139908a615b32565b6121439190615b78565b90505b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009073ffffffffffffffffffffffffffffffffffffffff8c169063b5c736e490602401602060405180830381865afa1580156121b4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121d89190615b19565b600281811c6201ffff16945090915060018083161490808316148180156121fc5750805b156122255761221e8489600001518a602001518b604001518c6060015161451f565b95506122cb565b8015612253577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff95506122cb565b81156122645761221e846001615d83565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f4e6f20706f6f6c732061726520656e61626c656400000000000000000000000060448201526064015b60405180910390fd5b5050506000831361232a5760a08501819052604085015160608601516122f29183916145ab565b60e086015261230482620f4240615701565b60e086015161231690620f4240615b32565b6123209190615b78565b60e0860152612430565b80831261238257608085018190528451602086015161234a9183916145ab565b60c086015261235c82620f4240615701565b60c086015161236e90620f4240615b32565b6123789190615b78565b60c0860152612430565b608085018390526123938382615701565b60a08601526080850151855160208701516123af9291906145ab565b60c08601526123c182620f4240615701565b60c08601516123d390620f4240615b32565b6123dd9190615b78565b60c086015260a0850151604086015160608701516123fc9291906145ab565b60e086015261240e82620f4240615701565b60e086015161242090620f4240615b32565b61242a9190615b78565b60e08601525b50505060008060006124418a61085b565b905088156124a057836060015184604001518260600151600001516124669190615b32565b6124709190615b78565b92508360600151846040015182602001516000015161248f9190615b32565b6124999190615b78565b91506124e7565b602084015184516040830151516124b79190615b32565b6124c19190615b78565b6020850151855183515192955090916124da9190615b32565b6124e49190615b78565b91505b828560a001511115612520577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff955050505050506127e3565b8185608001511115612559577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff955050505050506127e3565b5050506000808360a001518460800151111561266457876125a05760208401518451612591906b033b2e3c9fd0803ce8000000615b32565b61259b9190615b78565b6125c7565b835160208501516125bd906b033b2e3c9fd0803ce8000000615b32565b6125c79190615b78565b91508761261857836080015184602001516125e29190615701565b60c085015185516125f39190615b8c565b612609906b033b2e3c9fd0803ce8000000615b32565b6126139190615b78565b61265d565b60c084015184516126299190615b8c565b8460800151856020015161263d9190615701565b612653906b033b2e3c9fd0803ce8000000615b32565b61265d9190615b78565b9050612761565b876126985760608401516040850151612689906b033b2e3c9fd0803ce8000000615b32565b6126939190615b78565b6126c2565b604084015160608501516126b8906b033b2e3c9fd0803ce8000000615b32565b6126c29190615b78565b915087612716578360a0015184606001516126dd9190615701565b8460e0015185604001516126f19190615b8c565b612707906b033b2e3c9fd0803ce8000000615b32565b6127119190615b78565b61275e565b8360e00151846040015161272a9190615b8c565b8460a00151856060015161273e9190615701565b612754906b033b2e3c9fd0803ce8000000615b32565b61275e9190615b78565b90505b6000818311612779576127748383615701565b612783565b6127838284615701565b9050670de0b6b3a764000061279f66b1a2bc2ec5000085615b32565b6127a99190615b78565b8111156127dd577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff955050505050506127e3565b50505050505b949350505050565b6040517fb5c736e400000000000000000000000000000000000000000000000000000000815260016004820152600090819073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490602401602060405180830381865afa15801561285b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061287f9190615b19565b60021c6201ffff169392505050565b612896614da5565b61289f82613a33565b73ffffffffffffffffffffffffffffffffffffffff908116604084810191909152918116602084015290517f015f6cfa0000000000000000000000000000000000000000000000000000000081529083166004820152309063015f6cfa90602401610120604051808303816000875af192505050801561295a575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261295791810190615714565b60015b61297f5761296782612bf8565b60a0820152612975826129e3565b60c08201526129a9565b6020810151608083015261299383826145dc565b60a08301526129a28382614726565b60c0830152505b73ffffffffffffffffffffffffffffffffffffffff821681526129cb826127eb565b60608201526129d98261085b565b60e0820152919050565b612a1c6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490602401602060405180830381865afa158015612a8a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612aae9190615b19565b905080600216600214612af6576040518060c0016040528060008152602001600081526020016000815260200160008152602001600081526020016000815250915050919050565b6040517f015f6cfa00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152309063015f6cfa90602401610120604051808303816000875af1925050508015612b9d575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612b9a91810190615714565b60015b612bdb576040518060c00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152509150612be5565b61079e8482614726565b50919050565b6060611cf16104d9613979565b612c236040518060800160405280600081526020016000815260200160008152602001600081525090565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490602401602060405180830381865afa158015612c91573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612cb59190615b19565b905080600116600114612cef5760405180608001604052806000815260200160008152602001600081526020016000815250915050919050565b6040517f015f6cfa00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152309063015f6cfa90602401610120604051808303816000875af1925050508015612d96575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612d9391810190615714565b60015b612dc657604051806080016040528060008152602001600081526020016000815260200160008152509150612be5565b61079e84826145dc565b6060815167ffffffffffffffff811115612dec57612dec615405565b604051908082528060200260200182016040528015612e2557816020015b612e12614da5565b815260200190600190039081612e0a5790505b50905060005b8251811015612be557612e56838281518110612e4957612e49615dab565b602002602001015161288e565b828281518110612e6857612e68615dab565b60200260200101819052508080612e7e90615dda565b915050612e2b565b6040517f2668dfaa0000000000000000000000000000000000000000000000000000000081528315156004820152602481018390526044810182905261dead606482015260009073ffffffffffffffffffffffffffffffffffffffff861690632668dfaa90349060840160206040518083038185885af193505050508015612f49575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612f4691810190615b19565b60015b612faf573d808015612f77576040519150601f19603f3d011682016040523d82523d6000602084013e612f7c565b606091505b50612fa7817fb3bfda99000000000000000000000000000000000000000000000000000000006144cb565b915050612fb1565b505b612ff960405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000613004876137a1565b9050600061301188613c32565b90508615613046576040808301518452606080840151602086015260808301519185019190915260a08201519084015261306c565b6060808301518452604080840151602086015260a0830151908501526080820151908401525b505060008673ffffffffffffffffffffffffffffffffffffffff16631595cbd36040518163ffffffff1660e01b8152600401608060405180830381865afa1580156130bb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906130df9190615d67565b90506000806000881561310e57602084015184516130fd908a615b32565b6131079190615b78565b905061312f565b60608401516040850151613122908a615b32565b61312c9190615b78565b90505b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009073ffffffffffffffffffffffffffffffffffffffff8c169063b5c736e490602401602060405180830381865afa15801561319d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131c19190615b19565b600281811c6201ffff16945090915060018083161490808316148180156131e55750805b1561320e576132078489602001518a600001518b606001518c604001516148cd565b955061324d565b801561323c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff955061324d565b811561226457613207846001615d83565b5050506000831361329d5760e08501819052613293620f42406132708482615701565b61327a9084615b32565b6132849190615b78565b86604001518760600151614918565b60a0860152613347565b8083126132e65760c085018190526132dc620f42406132bc8482615701565b6132c69084615b32565b6132d09190615b78565b86516020880151614918565b6080860152613347565b60c085018390526132f78382615701565b60e086015261331c620f424061330d8482615701565b8760c001516132c69190615b32565b6080860152613341620f42406133328482615701565b8760e0015161327a9190615b32565b60a08601525b50505060008060006133588a61085b565b905088156133b7578360600151846040015182606001516000015161337d9190615b32565b6133879190615b78565b9250836060015184604001518260200151600001516133a69190615b32565b6133b09190615b78565b91506133fe565b602084015184516040830151516133ce9190615b32565b6133d89190615b78565b6020850151855183515192955090916133f19190615b32565b6133fb9190615b78565b91505b828560a001511115613418576000955050505050506127e3565b8185608001511115613432576000955050505050506127e3565b5050506000808360e001518460c00151111561353d5787613479576020840151845161346a906b033b2e3c9fd0803ce8000000615b32565b6134749190615b78565b6134a0565b83516020850151613496906b033b2e3c9fd0803ce8000000615b32565b6134a09190615b78565b9150876134f157836080015184602001516134bb9190615701565b60c085015185516134cc9190615b8c565b6134e2906b033b2e3c9fd0803ce8000000615b32565b6134ec9190615b78565b613536565b60c084015184516135029190615b8c565b846080015185602001516135169190615701565b61352c906b033b2e3c9fd0803ce8000000615b32565b6135369190615b78565b905061363a565b876135715760608401516040850151613562906b033b2e3c9fd0803ce8000000615b32565b61356c9190615b78565b61359b565b60408401516060850151613591906b033b2e3c9fd0803ce8000000615b32565b61359b9190615b78565b9150876135ef578360a0015184606001516135b69190615701565b8460e0015185604001516135ca9190615b8c565b6135e0906b033b2e3c9fd0803ce8000000615b32565b6135ea9190615b78565b613637565b8360e0015184604001516136039190615b8c565b8460a0015185606001516136179190615701565b61362d906b033b2e3c9fd0803ce8000000615b32565b6136379190615b78565b90505b60008183116136525761364d8383615701565b61365c565b61365c8284615701565b9050670de0b6b3a764000061367866b1a2bc2ec5000085615b32565b6136829190615b78565b8111156127dd576000955050505050506127e3565b61369f614da5565b6136a882613a33565b73ffffffffffffffffffffffffffffffffffffffff908116604084810191909152918116602084015290517f015f6cfa0000000000000000000000000000000000000000000000000000000081529083166004820152309063015f6cfa90602401610120604051808303816000875af1925050508015613763575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261376091810190615714565b60015b61377e57613770826137a1565b60a082015261297582613c32565b60208101516080830152613792838261493a565b60a08301526129a28382614a72565b6137cc6040518060800160405280600081526020016000815260200160008152602001600081525090565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490602401602060405180830381865afa15801561383a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061385e9190615b19565b9050806001166001146138985760405180608001604052806000815260200160008152602001600081526020016000815250915050919050565b6040517f015f6cfa00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152309063015f6cfa90602401610120604051808303816000875af192505050801561393f575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261393c91810190615714565b60015b61396f57604051806080016040528060008152602001600081526020016000815260200160008152509150612be5565b61079e848261493a565b60606000613985613abe565b90508067ffffffffffffffff8111156139a0576139a0615405565b6040519080825280602002602001820160405280156139c9578160200160208202803683370190505b50915060005b81811015613a2e576139e56101c0826001615b8c565b8382815181106139f7576139f7615dab565b73ffffffffffffffffffffffffffffffffffffffff9092166020928302919091019091015280613a2681615dda565b9150506139cf565b505090565b60008060008373ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa158015613a84573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613aa89190615c1a565b90508060a001518160c001519250925050915091565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166393656c176040518163ffffffff1660e01b8152600401602060405180830381865afa158015613b2b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cf19190615b19565b60606000613b5b613abe565b90508067ffffffffffffffff811115613b7657613b76615405565b604051908082528060200260200182016040528015613be657816020015b6040805160808101825260008082526020808301829052928201819052606082015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff909201910181613b945790505b50915060005b81811015613a2e57613c02610297826001615b8c565b838281518110613c1457613c14615dab565b60200260200101819052508080613c2a90615dda565b915050613bec565b613c6b6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490602401602060405180830381865afa158015613cd9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613cfd9190615b19565b905080600216600214613d45576040518060c0016040528060008152602001600081526020016000815260200160008152602001600081526020016000815250915050919050565b6040517f015f6cfa00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152309063015f6cfa90602401610120604051808303816000875af1925050508015613dec575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252613de991810190615714565b60015b613e2a576040518060c00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152509150612be5565b61079e8482614a72565b6060815167ffffffffffffffff811115613e5057613e50615405565b604051908082528060200260200182016040528015613e8957816020015b613e76614da5565b815260200190600190039081613e6e5790505b50905060005b8251811015612be557613eba838281518110613ead57613ead615dab565b6020026020010151613697565b828281518110613ecc57613ecc615dab565b60200260200101819052508080613ee290615dda565b915050613e8f565b6000606082600003613f00576000915050610643565b607f8311613fc9576040517fd60000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b16602282015260f884901b7fff000000000000000000000000000000000000000000000000000000000000001660368201526037015b6040516020818303038152906040529050614345565b60ff83116140a6576040517fd70000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f8100000000000000000000000000000000000000000000000000000000000000603682015260f884901b7fff00000000000000000000000000000000000000000000000000000000000000166037820152603801613fb3565b61ffff8311614184576040517fd80000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f820000000000000000000000000000000000000000000000000000000000000060368201527fffff00000000000000000000000000000000000000000000000000000000000060f085901b166037820152603901613fb3565b62ffffff8311614263576040517fd90000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f830000000000000000000000000000000000000000000000000000000000000060368201527fffffff000000000000000000000000000000000000000000000000000000000060e885901b166037820152603a01613fb3565b6040517fda0000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f840000000000000000000000000000000000000000000000000000000000000060368201527fffffffff0000000000000000000000000000000000000000000000000000000060e085901b166037820152603b0160405160208183030381529060405290505b80516020909101209392505050565b60608161436281601f615b8c565b10156143ca576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f7700000000000000000000000000000000000060448201526064016122c2565b6143d48284615b8c565b8451101561443e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f736c6963655f6f75744f66426f756e647300000000000000000000000000000060448201526064016122c2565b8115801561445b57604051915060008252602082016040526144c3565b6040519150601f8316801560200281840101848101868315602002848a0101015b8183101561449457805183526020928301920161447c565b5050848452601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016604052505b509392505050565b60006024835110156144df57506000610643565b60208301517fffffffff000000000000000000000000000000000000000000000000000000008084169082160361451857602484015191505b5092915050565b60008061454661452f8688615b32565b61454190670de0b6b3a7640000615b32565b614bc0565b9050600061455761452f8587615b32565b90506145638183615b8c565b61456d8386615b32565b6145778389615b32565b614581858c615b32565b61458b9190615b8c565b6145959190615e12565b61459f9190615e32565b98975050505050505050565b6000806145b88486615b32565b905060006145c68685615701565b90506145d28183615b78565b9695505050505050565b6146076040518060800160405280600081526020016000815260200160008152602001600081525090565b614611838361493a565b905060008373ffffffffffffffffffffffffffffffffffffffff16631595cbd36040518163ffffffff1660e01b8152600401608060405180830381865afa158015614660573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906146849190615d67565b805160208201518451929350909161469c9190615b32565b6146a69190615b78565b82528051602082015160408401516146be9190615b32565b6146c89190615b78565b604080840191909152810151606082015160208401516146e89190615b32565b6146f29190615b78565b60208301526040810151606080830151908401516147109190615b32565b61471a9190615b78565b60608301525092915050565b61475f6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6147698383614a72565b905060008373ffffffffffffffffffffffffffffffffffffffff16631595cbd36040518163ffffffff1660e01b8152600401608060405180830381865afa1580156147b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906147dc9190615d67565b80516020820151845192935090916147f49190615b32565b6147fe9190615b78565b82528051602082015160408401516148169190615b32565b6148209190615b78565b604083015280516020820151608084015161483b9190615b32565b6148459190615b78565b60808301526040810151606082015160208401516148639190615b32565b61486d9190615b78565b602083015260408101516060808301519084015161488b9190615b32565b6148959190615b78565b826060018181525050806040015181606001518360a001516148b79190615b32565b6148c19190615b78565b60a08301525092915050565b6000806148dd61452f8688615b32565b905060006148ee61452f8587615b32565b90506148fa8183615b8c565b6149048288615b32565b61490e848b615b32565b6145818588615b32565b600083820283850180828161492f5761492f615b49565b049695505050505050565b6149656040518060800160405280600081526020016000815260200160008152602001600081525090565b6080820151604080840151606085015160a086015160e087015193517f6560abaa0000000000000000000000000000000000000000000000000000000081526004810195909552602485019290925260448401526064830152608482015273ffffffffffffffffffffffffffffffffffffffff841690636560abaa9060a401608060405180830381865afa925050508015614a3b575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252614a3891810190615d67565b60015b614a6b57604051806080016040528060008152602001600081526020016000815260200160008152509050610643565b9392505050565b614aab6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6080820151604080840151606085015160c086015161010087015193517f05d455a90000000000000000000000000000000000000000000000000000000081526004810195909552602485019290925260448401526064830152608482015273ffffffffffffffffffffffffffffffffffffffff8416906305d455a99060a40160c060405180830381865afa925050508015614b82575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252614b7f91810190615e9a565b60015b614a6b576040518060c00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152509050610643565b60b581710100000000000000000000000000000000008110614be75760409190911b9060801c5b69010000000000000000008110614c035760209190911b9060401c5b650100000000008110614c1b5760109190911b9060201c5b63010000008110614c315760089190911b9060101c5b62010000010260121c80820401600190811c80830401811c80830401811c80830401811c80830401811c80830401811c80830401901c908190048111900390565b6040518060800160405280614ca160405180606001604052806000815260200160008152602001600081525090565b8152602001614cca60405180606001604052806000815260200160008152602001600081525090565b8152602001614cf360405180606001604052806000815260200160008152602001600081525090565b8152602001614d1c60405180606001604052806000815260200160008152602001600081525090565b905290565b60405180610220016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001614d1c614e8c565b604051806101000160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152602001614e416040518060800160405280600081526020016000815260200160008152602001600081525090565b8152602001614e7f6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b8152602001614d1c614c72565b604051806060016040528060008152602001614ee66040518060a00160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600081526020016000815260200160008152602001600081525090565b8152602001614d1c6040518060e00160405280600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b600060208284031215614f5357600080fd5b5035919050565b73ffffffffffffffffffffffffffffffffffffffff81168114614f7c57600080fd5b50565b600060208284031215614f9157600080fd5b8135614a6b81614f5a565b60808101610643828473ffffffffffffffffffffffffffffffffffffffff80825116835280602083015116602084015280604083015116604084015250606081015160608301525050565b6150068282518051825260208082015190830152604090810151910152565b60208181015180516060850152908101516080840152604081015160a084015250604081810151805160c0850152602081015160e0850152908101516101008401525060600151805161012083015260208101516101408301526040015161016090910152565b505050565b61018081016106438284614fe7565b73ffffffffffffffffffffffffffffffffffffffff80825116835280602083015116602084015280604083015116604084015250606081015160608301526080810151608083015260a08101516150fc60a0840182805182526020810151602083015260408101516040830152606081015160608301525050565b5060c0810151805161012084015260208101516101408401526040810151610160840152606081015161018084015260808101516101a084015260a001516101c083015260e081015161506d6101e0840182614fe7565b6020808252825182820181905260009190848201906040850190845b8181101561519657615182838551615081565b92840192610360929092019160010161516f565b50909695505050505050565b815181526020808301516102408301916151d39084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060408301516151fb604084018273ffffffffffffffffffffffffffffffffffffffff169052565b506060830151615259606084018273ffffffffffffffffffffffffffffffffffffffff808251168352806020830151166020840152806040830151166040840152806060830151166060840152806080830151166080840152505050565b5060808301516101006152838185018373ffffffffffffffffffffffffffffffffffffffff169052565b60a085015191506101206152ae8186018473ffffffffffffffffffffffffffffffffffffffff169052565b60c086015192506101406152d98187018573ffffffffffffffffffffffffffffffffffffffff169052565b60e0870151610160878101919091529287015161018080880191909152918701516101a080880191909152908701516101c0870152918601516101e08601528501516102008501529093015161022090920191909152919050565b8151815260208083015190820152604080830151908201526060808301519082015260808101610643565b8015158114614f7c57600080fd5b6000806000806080858703121561538357600080fd5b843561538e81614f5a565b9350602085013561539e8161535f565b93969395505050506040820135916060013590565b61036081016106438284615081565b60c081016106438284805182526020810151602083015260408101516040830152606081015160608301526080810151608083015260a081015160a08301525050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051610120810167ffffffffffffffff8111828210171561545857615458615405565b60405290565b6040516060810167ffffffffffffffff8111828210171561545857615458615405565b60405160a0810167ffffffffffffffff8111828210171561545857615458615405565b604051610220810167ffffffffffffffff8111828210171561545857615458615405565b604051610160810167ffffffffffffffff8111828210171561545857615458615405565b6040516101c0810167ffffffffffffffff8111828210171561545857615458615405565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561555757615557615405565b604052919050565b6000602080838503121561557257600080fd5b823567ffffffffffffffff8082111561558a57600080fd5b818501915085601f83011261559e57600080fd5b8135818111156155b0576155b0615405565b8060051b91506155c1848301615510565b81815291830184019184810190888411156155db57600080fd5b938501935b8385101561459f57843592506155f583614f5a565b82825293850193908501906155e0565b6020808252825182820181905260009190848201906040850190845b8181101561519657835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101615621565b6020808252825182820181905260009190848201906040850190845b81811015615196576156bf83855173ffffffffffffffffffffffffffffffffffffffff80825116835280602083015116602084015280604083015116604084015250606081015160608301525050565b928401926080929092019160010161566f565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b81810381811115610643576106436156d2565b6000610120828403121561572757600080fd5b61572f615434565b825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e08201526101008084015181830152508091505092915050565b80516107a48161535f565b80516107a481614f5a565b600060e082840312156157b757600080fd5b60405160e0810181811067ffffffffffffffff821117156157da576157da615405565b806040525080915082516157ed81614f5a565b808252506020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c08201525092915050565b60008183036101a081121561584857600080fd5b61585061545e565b91508251825260a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08201121561588657600080fd5b5061588f615481565b602083015161589d81614f5a565b8082525060408301516020820152606083015160408201526080830151606082015260a08301516080820152806020830152506158dd8360c084016157a5565b604082015292915050565b60006103a082840312156158fb57600080fd5b6159036154a4565b825181526020808401519082015260408084015190820152606080840151908201526080808401519082015260a0808401519082015260c0808401519082015260e08084015190820152610100808401519082015261012080840151908201526101408084015190820152610160808401519082015261018080840151908201526101a080840151908201526101c080840151908201526101e0808401519082015290506102006159b684828501615834565b9082015292915050565b6000808284036104c08112156159d557600080fd5b610120808212156159e557600080fd5b6159ed615434565b91506159f88561578f565b82526020850151602083015260408501516040830152606085015160608301526080850151608083015260a085015160a083015260c085015160c083015260e085015160e0830152610100808601518184015250819350615a5b868287016158e8565b925050509250929050565b600080828403610500811215615a7b57600080fd5b61016080821215615a8b57600080fd5b615a936154c8565b9150615a9e8561578f565b82526020850151602083015260408501516040830152606085015160608301526080850151608083015260a085015160a083015260c085015160c083015260e085015160e0830152610100808601518184015250610120808601518184015250610140808601518184015250819350615a5b868287016158e8565b600060208284031215615b2b57600080fd5b5051919050565b8082028115828204841417610643576106436156d2565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600082615b8757615b87615b49565b500490565b80820180821115610643576106436156d2565b600060a08284031215615bb157600080fd5b615bb9615481565b90508151615bc681614f5a565b81526020820151615bd681614f5a565b60208201526040820151615be981614f5a565b60408201526060820151615bfc81614f5a565b60608201526080820151615c0f81614f5a565b608082015292915050565b60006102408284031215615c2d57600080fd5b615c356154ec565b82518152615c456020840161579a565b6020820152615c566040840161579a565b6040820152615c688460608501615b9f565b6060820152610100615c7b81850161579a565b6080830152610120615c8e81860161579a565b60a0840152610140615ca181870161579a565b60c08501526101608087015160e086015261018080880151858701526101a0945084880151848701526101c0880151838701526101e088015182870152610200880151818701525050505061022084015181830152508091505092915050565b600060808284031215615d1357600080fd5b6040516080810181811067ffffffffffffffff82111715615d3657615d36615405565b8060405250809150825181526020830151602082015260408301516040820152606083015160608201525092915050565b600060808284031215615d7957600080fd5b614a6b8383615d01565b8082018281126000831280158216821582161715615da357615da36156d2565b505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203615e0b57615e0b6156d2565b5060010190565b8181036000831280158383131683831282161715614518576145186156d2565b600082615e4157615e41615b49565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83147f800000000000000000000000000000000000000000000000000000000000000083141615615e9557615e956156d2565b500590565b600060c08284031215615eac57600080fd5b60405160c0810181811067ffffffffffffffff82111715615ecf57615ecf615405565b8060405250825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a0820152809150509291505056fea264697066735822122053932a8c86ddcb6349a232196dc284caac6830305446d3c5b116f2439075cd1664736f6c63430008150033",
  "deployedBytecode": "0x6080604052600436106101a05760003560e01c80636902f79f116100e1578063c0eec0e81161008a578063d3ffe67a11610064578063d3ffe67a146105a0578063d88ff1f4146105b5578063dde04706146105d7578063fccca03c146105f757600080fd5b8063c0eec0e814610511578063c56f1b4414610531578063ca4f28031461055357600080fd5b8063a5973763116100bb578063a5973763146104be578063bb39e3a1146104de578063bd964d38146104f157600080fd5b80636902f79f146104555780636e38c02314610489578063957755e61461049e57600080fd5b8063333d01a91161014e578063425711371161012857806342571137146103ba57806342fcc6fb146103db5780634bee9395146103fb57806355181f111461042857600080fd5b8063333d01a91461033e5780633973a11b146103605780633ec841e41461038d57600080fd5b8063180f4c651161017f578063180f4c65146102a95780632861c7d1146102d65780632dd310001461030a57600080fd5b8062a5ae21146101a5578063015f6cfa146101ef578063068bcd8d1461027c575b600080fd5b3480156101b157600080fd5b506101c56101c0366004614f41565b610617565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b3480156101fb57600080fd5b5061020f61020a366004614f7f565b610649565b6040516101e69190600061012082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015261010080840151818401525092915050565b34801561028857600080fd5b5061029c610297366004614f41565b6107a9565b6040516101e69190614f9c565b3480156102b557600080fd5b506102c96102c4366004614f7f565b61085b565b6040516101e69190615072565b3480156102e257600080fd5b506101c57f000000000000000000000000000000000000000000000000000000000000000081565b34801561031657600080fd5b506101c57f000000000000000000000000000000000000000000000000000000000000000081565b34801561034a57600080fd5b50610353611ce4565b6040516101e69190615153565b34801561036c57600080fd5b5061038061037b366004614f7f565b611cf6565b6040516101e691906151a2565b34801561039957600080fd5b506103ad6103a8366004614f7f565b611e03565b6040516101e69190615334565b6103cd6103c836600461536d565b611e9d565b6040519081526020016101e6565b3480156103e757600080fd5b506103cd6103f6366004614f7f565b6127eb565b34801561040757600080fd5b5061041b610416366004614f7f565b61288e565b6040516101e691906153b3565b34801561043457600080fd5b50610448610443366004614f7f565b6129e3565b6040516101e691906153c2565b34801561046157600080fd5b506101c57f000000000000000000000000000000000000000000000000000000000000000081565b34801561049557600080fd5b50610353612beb565b3480156104aa57600080fd5b506103ad6104b9366004614f7f565b612bf8565b3480156104ca57600080fd5b506103536104d936600461555f565b612dd0565b6103cd6104ec36600461536d565b612e86565b3480156104fd57600080fd5b5061041b61050c366004614f7f565b613697565b34801561051d57600080fd5b506103ad61052c366004614f7f565b6137a1565b34801561053d57600080fd5b50610546613979565b6040516101e69190615605565b34801561055f57600080fd5b5061057361056e366004614f7f565b613a33565b6040805173ffffffffffffffffffffffffffffffffffffffff9384168152929091166020830152016101e6565b3480156105ac57600080fd5b506103cd613abe565b3480156105c157600080fd5b506105ca613b4f565b6040516101e69190615653565b3480156105e357600080fd5b506104486105f2366004614f7f565b613c32565b34801561060357600080fd5b5061035361061236600461555f565b613e34565b60006106437f000000000000000000000000000000000000000000000000000000000000000083613eea565b92915050565b6106986040518061012001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b8173ffffffffffffffffffffffffffffffffffffffff1663916cef4e6040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156106e057600080fd5b505af19250505080156106f1575060015b6107a4573d80801561071f576040519150601f19603f3d011682016040523d82523d6000602084013e610724565b606091505b5060208101517fdc4022c5000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008216016107a15761078b8260048085516107869190615701565b614354565b80602001905181019061079e9190615714565b92505b50505b919050565b6040805160808101825260008082526020820181905291810182905260608101829052906107d683610617565b90506000806107e483613a33565b9150915060405180608001604052808473ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff168152602001610850856127eb565b905295945050505050565b610863614c72565b6108b460405180610120016040528060001515815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b61090560405180610120016040528060001515815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b61090d614d21565b610915614d21565b610974604051806101600160405280600015158152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6109d3604051806101600160405280600015158152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000806109df8a613a33565b6040517fe72ef91b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8d8116600483015280841660248301529294509092507f00000000000000000000000000000000000000000000000000000000000000009091169063e72ef91b906044016104c060405180830381865afa158015610a7c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aa091906159c0565b6040517fe72ef91b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8d811660048301528481166024830152929a509097507f00000000000000000000000000000000000000000000000000000000000000009091169063e72ef91b906044016104c060405180830381865afa158015610b3d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6191906159c0565b6040517f967915d600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8d8116600483015285811660248301529299509096507f00000000000000000000000000000000000000000000000000000000000000009091169063967915d69060440161050060405180830381865afa158015610bfe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c229190615a66565b506040517f967915d600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8c8116600483015283811660248301529195507f00000000000000000000000000000000000000000000000000000000000000009091169063967915d69060440161050060405180830381865afa158015610cbd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ce19190615a66565b506040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015290935060009073ffffffffffffffffffffffffffffffffffffffff8c169063b5c736e490602401602060405180830381865afa158015610d53573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d779190615b19565b90506000610d8e60e483901c6103ff16600a615b32565b9050600081905080896101e001511015610daa57506101e08801515b6000612710828b6101800151610dc09190615b32565b610dca9190615b78565b9050808a6101a001511015611203578215610e0257828a6101a00151612710610df39190615b32565b610dfd9190615b78565b610e05565b60005b8d51528c51516101808b015111610e1d576000610e30565b8c51516101808b0151610e309190615701565b8d51528c5180516020909101526101a08a0151610e4d9082615701565b60408e01805191909152518051602090910152600073ffffffffffffffffffffffffffffffffffffffff871673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14610f48576040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000811660048301528816906370a0823190602401602060405180830381865afa158015610f1f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f439190615b19565b610f81565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16315b90507fffffffffffffffffffffffff32a01dc37a7df0848d2f6d90364fa4bc1ca6481273ffffffffffffffffffffffffffffffffffffffff8816016110a9576040517fb203bb9900000000000000000000000000000000000000000000000000000000815273cd5fe23c85820f7b72d0926fc9b05b43e359b7ee600482015273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016602482015273f047ab4c75cebf0eb9ed34ae2c186f3611aeafa69063b203bb9990604401602060405180830381865afa158015611078573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061109c9190615b19565b6110a69082615b8c565b90505b7fffffffffffffffffffffffff6e83117fe59806cc0d194cc03f32e12d2a6f627873ffffffffffffffffffffffffffffffffffffffff8816016111cf576040517fb203bb9900000000000000000000000000000000000000000000000000000000815273917cee801a67f933f2e6b33fc0cd1ed2d5909d88600482015273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016602482015273f047ab4c75cebf0eb9ed34ae2c186f3611aeafa69063b203bb9990604401602060405180830381865afa15801561119e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111c29190615b19565b6111cc9082615b8c565b90505b8d51602001518110156111e5578d516020018190525b808e604001516020015111156112015760408e01516020018190525b505b50505060006103ff60ee83901c16600a61121d9190615b32565b9050600081905080886101e00151101561123957506101e08701515b6000612710828a610180015161124f9190615b32565b6112599190615b78565b905080896101a0015110156116a55782156112915782896101a001516127106112829190615b32565b61128c9190615b78565b611294565b60005b60208e0180519190915251516101808a0151116112b25760006112c8565b60208d0151516101808a01516112c89190615701565b6020808f01805192909252905180519101526101a08901516112ea9082615701565b60608e01805191909152518051602090910152600073ffffffffffffffffffffffffffffffffffffffff861673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee146113e5576040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000811660048301528716906370a0823190602401602060405180830381865afa1580156113bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113e09190615b19565b61141e565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16315b90507fffffffffffffffffffffffff32a01dc37a7df0848d2f6d90364fa4bc1ca6481273ffffffffffffffffffffffffffffffffffffffff871601611546576040517fb203bb9900000000000000000000000000000000000000000000000000000000815273cd5fe23c85820f7b72d0926fc9b05b43e359b7ee600482015273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016602482015273f047ab4c75cebf0eb9ed34ae2c186f3611aeafa69063b203bb9990604401602060405180830381865afa158015611515573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115399190615b19565b6115439082615b8c565b90505b7fffffffffffffffffffffffff6e83117fe59806cc0d194cc03f32e12d2a6f627873ffffffffffffffffffffffffffffffffffffffff87160161166c576040517fb203bb9900000000000000000000000000000000000000000000000000000000815273917cee801a67f933f2e6b33fc0cd1ed2d5909d88600482015273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016602482015273f047ab4c75cebf0eb9ed34ae2c186f3611aeafa69063b203bb9990604401602060405180830381865afa15801561163b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061165f9190615b19565b6116699082615b8c565b90505b808e60200151602001511115611687576020808f0151018190525b808e606001516020015111156116a35760608e01516020018190525b505b50505050505060008660a0015187606001516116c19190615b8c565b90508042116116d9576116d44282615701565b6116dc565b60005b90506000612710886020015189608001516116f79190615b32565b6117019190615b78565b905080886101000151111561171c5750506101008601516000905b8851602001518111611776578851602001819052801561176c5760a08801516101008901518a516020015183929161175391615701565b61175d9190615b32565b6117679190615b78565b61176f565b60005b91506117df565b885160200151610100890151111561179d57885160200151610100890152600091506117df565b80156117d95760a08801516101008901518a51602001518392916117c091615701565b6117ca9190615b32565b6117d49190615b78565b6117dc565b60005b91505b5087516040015260a085015160608601516000916117fc91615b8c565b90508042116118145761180f4282615701565b611817565b60005b90506000612710876020015188608001516118329190615b32565b61183c9190615b78565b90508087610100015111156118575750506101008501516000905b88602001516020015181116118b8576020808a01510181905280156118ae57808760a001518861010001518b60200151602001516118959190615701565b61189f9190615b32565b6118a99190615b78565b6118b1565b60005b9150611928565b88602001516020015187610100015111156118e4576020808a0151015161010088015260009150611928565b801561192257808760a001518861010001518b60200151602001516119099190615701565b6119139190615b32565b61191d9190615b78565b611925565b60005b91505b5060208801516040015260a0820151606083015160009161194891615b8c565b90508042116119605761195b4282615701565b611963565b60005b905060006127108460200151856080015161197e9190615b32565b6119889190615b78565b9050600084602001518560e00151116119a25760006119b6565b84602001518560e001516119b69190615701565b9050808a604001516020015111156119d45760408a01516020018190525b508084610120015111156119ee5750506101208201516000905b8860400151602001518111611a505760408901516020018190528015611a4657808460a001518561012001518b6040015160200151611a2d9190615701565b611a379190615b32565b611a419190615b78565b611a49565b60005b9150611ac1565b8860400151602001518461012001511115611a7d5760408901516020015161012085015260009150611ac1565b8015611abb57808460a001518561012001518b6040015160200151611aa29190615701565b611aac9190615b32565b611ab69190615b78565b611abe565b60005b91505b50604080890151015260a08101516060820151600091611ae091615b8c565b9050804211611af857611af34282615701565b611afb565b60005b9050600061271083602001518460800151611b169190615b32565b611b209190615b78565b9050600083602001518460e0015111611b3a576000611b4e565b83602001518460e00151611b4e9190615701565b9050808a60600151602001511115611b6c5760608a01516020018190525b50808361012001511115611b865750506101208101516000905b8860600151602001518111611be85760608901516020018190528015611bde57808360a001518461012001518b6060015160200151611bc59190615701565b611bcf9190615b32565b611bd99190615b78565b611be1565b60005b9150611c59565b8860600151602001518361012001511115611c155760608901516020015161012084015260009150611c59565b8015611c5357808360a001518461012001518b6060015160200151611c3a9190615701565b611c449190615b32565b611c4e9190615b78565b611c56565b60005b91505b506060880151604001528651516101008601511015611c7c576101008601518751525b6020870151516101008601511015611c9b576101008501516020880151525b6040870151516101208301511015611cba576101208201516040880151525b6060870151516101208201511015611cd9576101208101516060880151525b505050505050919050565b6060611cf1610612613979565b905090565b611d93604080516101c08101825260008082526020808301829052828401829052835160a08101855282815290810182905292830181905260608381018290526080840191909152909190820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c0820181905260e08201819052610100820181905261012082018190526101409091015290565b8173ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa158015611ddf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106439190615c1a565b611e2e6040518060800160405280600081526020016000815260200160008152602001600081525090565b8173ffffffffffffffffffffffffffffffffffffffff16631595cbd36040518163ffffffff1660e01b8152600401608060405180830381865afa158015611e79573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106439190615d67565b6040517f286f0e610000000000000000000000000000000000000000000000000000000081528315156004820152602481018390526044810182905261dead606482015260009073ffffffffffffffffffffffffffffffffffffffff86169063286f0e6190349060840160206040518083038185885af193505050508015611f60575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252611f5d91810190615b19565b60015b611fc6573d808015611f8e576040519150601f19603f3d011682016040523d82523d6000602084013e611f93565b606091505b50611fbe817fb3bfda99000000000000000000000000000000000000000000000000000000006144cb565b915050611fc8565b505b61201060405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b600061201b876137a1565b9050600061202888613c32565b9050861561205d576040808301518452606080840151602086015260808301519185019190915260a082015190840152612083565b6060808301518452604080840151602086015260a0830151908501526080820151908401525b505060008673ffffffffffffffffffffffffffffffffffffffff16631595cbd36040518163ffffffff1660e01b8152600401608060405180830381865afa1580156120d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120f69190615d67565b9050600080600088156121285760608401516040850151612117908a615b32565b6121219190615b78565b9050612146565b60208401518451612139908a615b32565b6121439190615b78565b90505b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009073ffffffffffffffffffffffffffffffffffffffff8c169063b5c736e490602401602060405180830381865afa1580156121b4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121d89190615b19565b600281811c6201ffff16945090915060018083161490808316148180156121fc5750805b156122255761221e8489600001518a602001518b604001518c6060015161451f565b95506122cb565b8015612253577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff95506122cb565b81156122645761221e846001615d83565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f4e6f20706f6f6c732061726520656e61626c656400000000000000000000000060448201526064015b60405180910390fd5b5050506000831361232a5760a08501819052604085015160608601516122f29183916145ab565b60e086015261230482620f4240615701565b60e086015161231690620f4240615b32565b6123209190615b78565b60e0860152612430565b80831261238257608085018190528451602086015161234a9183916145ab565b60c086015261235c82620f4240615701565b60c086015161236e90620f4240615b32565b6123789190615b78565b60c0860152612430565b608085018390526123938382615701565b60a08601526080850151855160208701516123af9291906145ab565b60c08601526123c182620f4240615701565b60c08601516123d390620f4240615b32565b6123dd9190615b78565b60c086015260a0850151604086015160608701516123fc9291906145ab565b60e086015261240e82620f4240615701565b60e086015161242090620f4240615b32565b61242a9190615b78565b60e08601525b50505060008060006124418a61085b565b905088156124a057836060015184604001518260600151600001516124669190615b32565b6124709190615b78565b92508360600151846040015182602001516000015161248f9190615b32565b6124999190615b78565b91506124e7565b602084015184516040830151516124b79190615b32565b6124c19190615b78565b6020850151855183515192955090916124da9190615b32565b6124e49190615b78565b91505b828560a001511115612520577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff955050505050506127e3565b8185608001511115612559577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff955050505050506127e3565b5050506000808360a001518460800151111561266457876125a05760208401518451612591906b033b2e3c9fd0803ce8000000615b32565b61259b9190615b78565b6125c7565b835160208501516125bd906b033b2e3c9fd0803ce8000000615b32565b6125c79190615b78565b91508761261857836080015184602001516125e29190615701565b60c085015185516125f39190615b8c565b612609906b033b2e3c9fd0803ce8000000615b32565b6126139190615b78565b61265d565b60c084015184516126299190615b8c565b8460800151856020015161263d9190615701565b612653906b033b2e3c9fd0803ce8000000615b32565b61265d9190615b78565b9050612761565b876126985760608401516040850151612689906b033b2e3c9fd0803ce8000000615b32565b6126939190615b78565b6126c2565b604084015160608501516126b8906b033b2e3c9fd0803ce8000000615b32565b6126c29190615b78565b915087612716578360a0015184606001516126dd9190615701565b8460e0015185604001516126f19190615b8c565b612707906b033b2e3c9fd0803ce8000000615b32565b6127119190615b78565b61275e565b8360e00151846040015161272a9190615b8c565b8460a00151856060015161273e9190615701565b612754906b033b2e3c9fd0803ce8000000615b32565b61275e9190615b78565b90505b6000818311612779576127748383615701565b612783565b6127838284615701565b9050670de0b6b3a764000061279f66b1a2bc2ec5000085615b32565b6127a99190615b78565b8111156127dd577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff955050505050506127e3565b50505050505b949350505050565b6040517fb5c736e400000000000000000000000000000000000000000000000000000000815260016004820152600090819073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490602401602060405180830381865afa15801561285b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061287f9190615b19565b60021c6201ffff169392505050565b612896614da5565b61289f82613a33565b73ffffffffffffffffffffffffffffffffffffffff908116604084810191909152918116602084015290517f015f6cfa0000000000000000000000000000000000000000000000000000000081529083166004820152309063015f6cfa90602401610120604051808303816000875af192505050801561295a575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261295791810190615714565b60015b61297f5761296782612bf8565b60a0820152612975826129e3565b60c08201526129a9565b6020810151608083015261299383826145dc565b60a08301526129a28382614726565b60c0830152505b73ffffffffffffffffffffffffffffffffffffffff821681526129cb826127eb565b60608201526129d98261085b565b60e0820152919050565b612a1c6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490602401602060405180830381865afa158015612a8a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612aae9190615b19565b905080600216600214612af6576040518060c0016040528060008152602001600081526020016000815260200160008152602001600081526020016000815250915050919050565b6040517f015f6cfa00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152309063015f6cfa90602401610120604051808303816000875af1925050508015612b9d575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612b9a91810190615714565b60015b612bdb576040518060c00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152509150612be5565b61079e8482614726565b50919050565b6060611cf16104d9613979565b612c236040518060800160405280600081526020016000815260200160008152602001600081525090565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490602401602060405180830381865afa158015612c91573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612cb59190615b19565b905080600116600114612cef5760405180608001604052806000815260200160008152602001600081526020016000815250915050919050565b6040517f015f6cfa00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152309063015f6cfa90602401610120604051808303816000875af1925050508015612d96575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612d9391810190615714565b60015b612dc657604051806080016040528060008152602001600081526020016000815260200160008152509150612be5565b61079e84826145dc565b6060815167ffffffffffffffff811115612dec57612dec615405565b604051908082528060200260200182016040528015612e2557816020015b612e12614da5565b815260200190600190039081612e0a5790505b50905060005b8251811015612be557612e56838281518110612e4957612e49615dab565b602002602001015161288e565b828281518110612e6857612e68615dab565b60200260200101819052508080612e7e90615dda565b915050612e2b565b6040517f2668dfaa0000000000000000000000000000000000000000000000000000000081528315156004820152602481018390526044810182905261dead606482015260009073ffffffffffffffffffffffffffffffffffffffff861690632668dfaa90349060840160206040518083038185885af193505050508015612f49575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612f4691810190615b19565b60015b612faf573d808015612f77576040519150601f19603f3d011682016040523d82523d6000602084013e612f7c565b606091505b50612fa7817fb3bfda99000000000000000000000000000000000000000000000000000000006144cb565b915050612fb1565b505b612ff960405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000613004876137a1565b9050600061301188613c32565b90508615613046576040808301518452606080840151602086015260808301519185019190915260a08201519084015261306c565b6060808301518452604080840151602086015260a0830151908501526080820151908401525b505060008673ffffffffffffffffffffffffffffffffffffffff16631595cbd36040518163ffffffff1660e01b8152600401608060405180830381865afa1580156130bb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906130df9190615d67565b90506000806000881561310e57602084015184516130fd908a615b32565b6131079190615b78565b905061312f565b60608401516040850151613122908a615b32565b61312c9190615b78565b90505b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009073ffffffffffffffffffffffffffffffffffffffff8c169063b5c736e490602401602060405180830381865afa15801561319d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131c19190615b19565b600281811c6201ffff16945090915060018083161490808316148180156131e55750805b1561320e576132078489602001518a600001518b606001518c604001516148cd565b955061324d565b801561323c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff955061324d565b811561226457613207846001615d83565b5050506000831361329d5760e08501819052613293620f42406132708482615701565b61327a9084615b32565b6132849190615b78565b86604001518760600151614918565b60a0860152613347565b8083126132e65760c085018190526132dc620f42406132bc8482615701565b6132c69084615b32565b6132d09190615b78565b86516020880151614918565b6080860152613347565b60c085018390526132f78382615701565b60e086015261331c620f424061330d8482615701565b8760c001516132c69190615b32565b6080860152613341620f42406133328482615701565b8760e0015161327a9190615b32565b60a08601525b50505060008060006133588a61085b565b905088156133b7578360600151846040015182606001516000015161337d9190615b32565b6133879190615b78565b9250836060015184604001518260200151600001516133a69190615b32565b6133b09190615b78565b91506133fe565b602084015184516040830151516133ce9190615b32565b6133d89190615b78565b6020850151855183515192955090916133f19190615b32565b6133fb9190615b78565b91505b828560a001511115613418576000955050505050506127e3565b8185608001511115613432576000955050505050506127e3565b5050506000808360e001518460c00151111561353d5787613479576020840151845161346a906b033b2e3c9fd0803ce8000000615b32565b6134749190615b78565b6134a0565b83516020850151613496906b033b2e3c9fd0803ce8000000615b32565b6134a09190615b78565b9150876134f157836080015184602001516134bb9190615701565b60c085015185516134cc9190615b8c565b6134e2906b033b2e3c9fd0803ce8000000615b32565b6134ec9190615b78565b613536565b60c084015184516135029190615b8c565b846080015185602001516135169190615701565b61352c906b033b2e3c9fd0803ce8000000615b32565b6135369190615b78565b905061363a565b876135715760608401516040850151613562906b033b2e3c9fd0803ce8000000615b32565b61356c9190615b78565b61359b565b60408401516060850151613591906b033b2e3c9fd0803ce8000000615b32565b61359b9190615b78565b9150876135ef578360a0015184606001516135b69190615701565b8460e0015185604001516135ca9190615b8c565b6135e0906b033b2e3c9fd0803ce8000000615b32565b6135ea9190615b78565b613637565b8360e0015184604001516136039190615b8c565b8460a0015185606001516136179190615701565b61362d906b033b2e3c9fd0803ce8000000615b32565b6136379190615b78565b90505b60008183116136525761364d8383615701565b61365c565b61365c8284615701565b9050670de0b6b3a764000061367866b1a2bc2ec5000085615b32565b6136829190615b78565b8111156127dd576000955050505050506127e3565b61369f614da5565b6136a882613a33565b73ffffffffffffffffffffffffffffffffffffffff908116604084810191909152918116602084015290517f015f6cfa0000000000000000000000000000000000000000000000000000000081529083166004820152309063015f6cfa90602401610120604051808303816000875af1925050508015613763575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261376091810190615714565b60015b61377e57613770826137a1565b60a082015261297582613c32565b60208101516080830152613792838261493a565b60a08301526129a28382614a72565b6137cc6040518060800160405280600081526020016000815260200160008152602001600081525090565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490602401602060405180830381865afa15801561383a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061385e9190615b19565b9050806001166001146138985760405180608001604052806000815260200160008152602001600081526020016000815250915050919050565b6040517f015f6cfa00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152309063015f6cfa90602401610120604051808303816000875af192505050801561393f575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261393c91810190615714565b60015b61396f57604051806080016040528060008152602001600081526020016000815260200160008152509150612be5565b61079e848261493a565b60606000613985613abe565b90508067ffffffffffffffff8111156139a0576139a0615405565b6040519080825280602002602001820160405280156139c9578160200160208202803683370190505b50915060005b81811015613a2e576139e56101c0826001615b8c565b8382815181106139f7576139f7615dab565b73ffffffffffffffffffffffffffffffffffffffff9092166020928302919091019091015280613a2681615dda565b9150506139cf565b505090565b60008060008373ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa158015613a84573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613aa89190615c1a565b90508060a001518160c001519250925050915091565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166393656c176040518163ffffffff1660e01b8152600401602060405180830381865afa158015613b2b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cf19190615b19565b60606000613b5b613abe565b90508067ffffffffffffffff811115613b7657613b76615405565b604051908082528060200260200182016040528015613be657816020015b6040805160808101825260008082526020808301829052928201819052606082015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff909201910181613b945790505b50915060005b81811015613a2e57613c02610297826001615b8c565b838281518110613c1457613c14615dab565b60200260200101819052508080613c2a90615dda565b915050613bec565b613c6b6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490602401602060405180830381865afa158015613cd9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613cfd9190615b19565b905080600216600214613d45576040518060c0016040528060008152602001600081526020016000815260200160008152602001600081526020016000815250915050919050565b6040517f015f6cfa00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152309063015f6cfa90602401610120604051808303816000875af1925050508015613dec575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252613de991810190615714565b60015b613e2a576040518060c00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152509150612be5565b61079e8482614a72565b6060815167ffffffffffffffff811115613e5057613e50615405565b604051908082528060200260200182016040528015613e8957816020015b613e76614da5565b815260200190600190039081613e6e5790505b50905060005b8251811015612be557613eba838281518110613ead57613ead615dab565b6020026020010151613697565b828281518110613ecc57613ecc615dab565b60200260200101819052508080613ee290615dda565b915050613e8f565b6000606082600003613f00576000915050610643565b607f8311613fc9576040517fd60000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b16602282015260f884901b7fff000000000000000000000000000000000000000000000000000000000000001660368201526037015b6040516020818303038152906040529050614345565b60ff83116140a6576040517fd70000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f8100000000000000000000000000000000000000000000000000000000000000603682015260f884901b7fff00000000000000000000000000000000000000000000000000000000000000166037820152603801613fb3565b61ffff8311614184576040517fd80000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f820000000000000000000000000000000000000000000000000000000000000060368201527fffff00000000000000000000000000000000000000000000000000000000000060f085901b166037820152603901613fb3565b62ffffff8311614263576040517fd90000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f830000000000000000000000000000000000000000000000000000000000000060368201527fffffff000000000000000000000000000000000000000000000000000000000060e885901b166037820152603a01613fb3565b6040517fda0000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f840000000000000000000000000000000000000000000000000000000000000060368201527fffffffff0000000000000000000000000000000000000000000000000000000060e085901b166037820152603b0160405160208183030381529060405290505b80516020909101209392505050565b60608161436281601f615b8c565b10156143ca576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f7700000000000000000000000000000000000060448201526064016122c2565b6143d48284615b8c565b8451101561443e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f736c6963655f6f75744f66426f756e647300000000000000000000000000000060448201526064016122c2565b8115801561445b57604051915060008252602082016040526144c3565b6040519150601f8316801560200281840101848101868315602002848a0101015b8183101561449457805183526020928301920161447c565b5050848452601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016604052505b509392505050565b60006024835110156144df57506000610643565b60208301517fffffffff000000000000000000000000000000000000000000000000000000008084169082160361451857602484015191505b5092915050565b60008061454661452f8688615b32565b61454190670de0b6b3a7640000615b32565b614bc0565b9050600061455761452f8587615b32565b90506145638183615b8c565b61456d8386615b32565b6145778389615b32565b614581858c615b32565b61458b9190615b8c565b6145959190615e12565b61459f9190615e32565b98975050505050505050565b6000806145b88486615b32565b905060006145c68685615701565b90506145d28183615b78565b9695505050505050565b6146076040518060800160405280600081526020016000815260200160008152602001600081525090565b614611838361493a565b905060008373ffffffffffffffffffffffffffffffffffffffff16631595cbd36040518163ffffffff1660e01b8152600401608060405180830381865afa158015614660573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906146849190615d67565b805160208201518451929350909161469c9190615b32565b6146a69190615b78565b82528051602082015160408401516146be9190615b32565b6146c89190615b78565b604080840191909152810151606082015160208401516146e89190615b32565b6146f29190615b78565b60208301526040810151606080830151908401516147109190615b32565b61471a9190615b78565b60608301525092915050565b61475f6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6147698383614a72565b905060008373ffffffffffffffffffffffffffffffffffffffff16631595cbd36040518163ffffffff1660e01b8152600401608060405180830381865afa1580156147b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906147dc9190615d67565b80516020820151845192935090916147f49190615b32565b6147fe9190615b78565b82528051602082015160408401516148169190615b32565b6148209190615b78565b604083015280516020820151608084015161483b9190615b32565b6148459190615b78565b60808301526040810151606082015160208401516148639190615b32565b61486d9190615b78565b602083015260408101516060808301519084015161488b9190615b32565b6148959190615b78565b826060018181525050806040015181606001518360a001516148b79190615b32565b6148c19190615b78565b60a08301525092915050565b6000806148dd61452f8688615b32565b905060006148ee61452f8587615b32565b90506148fa8183615b8c565b6149048288615b32565b61490e848b615b32565b6145818588615b32565b600083820283850180828161492f5761492f615b49565b049695505050505050565b6149656040518060800160405280600081526020016000815260200160008152602001600081525090565b6080820151604080840151606085015160a086015160e087015193517f6560abaa0000000000000000000000000000000000000000000000000000000081526004810195909552602485019290925260448401526064830152608482015273ffffffffffffffffffffffffffffffffffffffff841690636560abaa9060a401608060405180830381865afa925050508015614a3b575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252614a3891810190615d67565b60015b614a6b57604051806080016040528060008152602001600081526020016000815260200160008152509050610643565b9392505050565b614aab6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6080820151604080840151606085015160c086015161010087015193517f05d455a90000000000000000000000000000000000000000000000000000000081526004810195909552602485019290925260448401526064830152608482015273ffffffffffffffffffffffffffffffffffffffff8416906305d455a99060a40160c060405180830381865afa925050508015614b82575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252614b7f91810190615e9a565b60015b614a6b576040518060c00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152509050610643565b60b581710100000000000000000000000000000000008110614be75760409190911b9060801c5b69010000000000000000008110614c035760209190911b9060401c5b650100000000008110614c1b5760109190911b9060201c5b63010000008110614c315760089190911b9060101c5b62010000010260121c80820401600190811c80830401811c80830401811c80830401811c80830401811c80830401811c80830401901c908190048111900390565b6040518060800160405280614ca160405180606001604052806000815260200160008152602001600081525090565b8152602001614cca60405180606001604052806000815260200160008152602001600081525090565b8152602001614cf360405180606001604052806000815260200160008152602001600081525090565b8152602001614d1c60405180606001604052806000815260200160008152602001600081525090565b905290565b60405180610220016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001614d1c614e8c565b604051806101000160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152602001614e416040518060800160405280600081526020016000815260200160008152602001600081525090565b8152602001614e7f6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b8152602001614d1c614c72565b604051806060016040528060008152602001614ee66040518060a00160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600081526020016000815260200160008152602001600081525090565b8152602001614d1c6040518060e00160405280600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b600060208284031215614f5357600080fd5b5035919050565b73ffffffffffffffffffffffffffffffffffffffff81168114614f7c57600080fd5b50565b600060208284031215614f9157600080fd5b8135614a6b81614f5a565b60808101610643828473ffffffffffffffffffffffffffffffffffffffff80825116835280602083015116602084015280604083015116604084015250606081015160608301525050565b6150068282518051825260208082015190830152604090810151910152565b60208181015180516060850152908101516080840152604081015160a084015250604081810151805160c0850152602081015160e0850152908101516101008401525060600151805161012083015260208101516101408301526040015161016090910152565b505050565b61018081016106438284614fe7565b73ffffffffffffffffffffffffffffffffffffffff80825116835280602083015116602084015280604083015116604084015250606081015160608301526080810151608083015260a08101516150fc60a0840182805182526020810151602083015260408101516040830152606081015160608301525050565b5060c0810151805161012084015260208101516101408401526040810151610160840152606081015161018084015260808101516101a084015260a001516101c083015260e081015161506d6101e0840182614fe7565b6020808252825182820181905260009190848201906040850190845b8181101561519657615182838551615081565b92840192610360929092019160010161516f565b50909695505050505050565b815181526020808301516102408301916151d39084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060408301516151fb604084018273ffffffffffffffffffffffffffffffffffffffff169052565b506060830151615259606084018273ffffffffffffffffffffffffffffffffffffffff808251168352806020830151166020840152806040830151166040840152806060830151166060840152806080830151166080840152505050565b5060808301516101006152838185018373ffffffffffffffffffffffffffffffffffffffff169052565b60a085015191506101206152ae8186018473ffffffffffffffffffffffffffffffffffffffff169052565b60c086015192506101406152d98187018573ffffffffffffffffffffffffffffffffffffffff169052565b60e0870151610160878101919091529287015161018080880191909152918701516101a080880191909152908701516101c0870152918601516101e08601528501516102008501529093015161022090920191909152919050565b8151815260208083015190820152604080830151908201526060808301519082015260808101610643565b8015158114614f7c57600080fd5b6000806000806080858703121561538357600080fd5b843561538e81614f5a565b9350602085013561539e8161535f565b93969395505050506040820135916060013590565b61036081016106438284615081565b60c081016106438284805182526020810151602083015260408101516040830152606081015160608301526080810151608083015260a081015160a08301525050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051610120810167ffffffffffffffff8111828210171561545857615458615405565b60405290565b6040516060810167ffffffffffffffff8111828210171561545857615458615405565b60405160a0810167ffffffffffffffff8111828210171561545857615458615405565b604051610220810167ffffffffffffffff8111828210171561545857615458615405565b604051610160810167ffffffffffffffff8111828210171561545857615458615405565b6040516101c0810167ffffffffffffffff8111828210171561545857615458615405565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561555757615557615405565b604052919050565b6000602080838503121561557257600080fd5b823567ffffffffffffffff8082111561558a57600080fd5b818501915085601f83011261559e57600080fd5b8135818111156155b0576155b0615405565b8060051b91506155c1848301615510565b81815291830184019184810190888411156155db57600080fd5b938501935b8385101561459f57843592506155f583614f5a565b82825293850193908501906155e0565b6020808252825182820181905260009190848201906040850190845b8181101561519657835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101615621565b6020808252825182820181905260009190848201906040850190845b81811015615196576156bf83855173ffffffffffffffffffffffffffffffffffffffff80825116835280602083015116602084015280604083015116604084015250606081015160608301525050565b928401926080929092019160010161566f565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b81810381811115610643576106436156d2565b6000610120828403121561572757600080fd5b61572f615434565b825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e08201526101008084015181830152508091505092915050565b80516107a48161535f565b80516107a481614f5a565b600060e082840312156157b757600080fd5b60405160e0810181811067ffffffffffffffff821117156157da576157da615405565b806040525080915082516157ed81614f5a565b808252506020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c08201525092915050565b60008183036101a081121561584857600080fd5b61585061545e565b91508251825260a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08201121561588657600080fd5b5061588f615481565b602083015161589d81614f5a565b8082525060408301516020820152606083015160408201526080830151606082015260a08301516080820152806020830152506158dd8360c084016157a5565b604082015292915050565b60006103a082840312156158fb57600080fd5b6159036154a4565b825181526020808401519082015260408084015190820152606080840151908201526080808401519082015260a0808401519082015260c0808401519082015260e08084015190820152610100808401519082015261012080840151908201526101408084015190820152610160808401519082015261018080840151908201526101a080840151908201526101c080840151908201526101e0808401519082015290506102006159b684828501615834565b9082015292915050565b6000808284036104c08112156159d557600080fd5b610120808212156159e557600080fd5b6159ed615434565b91506159f88561578f565b82526020850151602083015260408501516040830152606085015160608301526080850151608083015260a085015160a083015260c085015160c083015260e085015160e0830152610100808601518184015250819350615a5b868287016158e8565b925050509250929050565b600080828403610500811215615a7b57600080fd5b61016080821215615a8b57600080fd5b615a936154c8565b9150615a9e8561578f565b82526020850151602083015260408501516040830152606085015160608301526080850151608083015260a085015160a083015260c085015160c083015260e085015160e0830152610100808601518184015250610120808601518184015250610140808601518184015250819350615a5b868287016158e8565b600060208284031215615b2b57600080fd5b5051919050565b8082028115828204841417610643576106436156d2565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600082615b8757615b87615b49565b500490565b80820180821115610643576106436156d2565b600060a08284031215615bb157600080fd5b615bb9615481565b90508151615bc681614f5a565b81526020820151615bd681614f5a565b60208201526040820151615be981614f5a565b60408201526060820151615bfc81614f5a565b60608201526080820151615c0f81614f5a565b608082015292915050565b60006102408284031215615c2d57600080fd5b615c356154ec565b82518152615c456020840161579a565b6020820152615c566040840161579a565b6040820152615c688460608501615b9f565b6060820152610100615c7b81850161579a565b6080830152610120615c8e81860161579a565b60a0840152610140615ca181870161579a565b60c08501526101608087015160e086015261018080880151858701526101a0945084880151848701526101c0880151838701526101e088015182870152610200880151818701525050505061022084015181830152508091505092915050565b600060808284031215615d1357600080fd5b6040516080810181811067ffffffffffffffff82111715615d3657615d36615405565b8060405250809150825181526020830151602082015260408301516040820152606083015160608201525092915050565b600060808284031215615d7957600080fd5b614a6b8383615d01565b8082018281126000831280158216821582161715615da357615da36156d2565b505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203615e0b57615e0b6156d2565b5060010190565b8181036000831280158383131683831282161715614518576145186156d2565b600082615e4157615e41615b49565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83147f800000000000000000000000000000000000000000000000000000000000000083141615615e9557615e956156d2565b500590565b600060c08284031215615eac57600080fd5b60405160c0810181811067ffffffffffffffff82111715615ecf57615ecf615405565b8060405250825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a0820152809150509291505056fea264697066735822122053932a8c86ddcb6349a232196dc284caac6830305446d3c5b116f2439075cd1664736f6c63430008150033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "estimateSwapIn(address,bool,uint256,uint256)": {
        "params": {
          "amountIn_": "The exact amount of input tokens to swap",
          "amountOutMin_": "The minimum amount of output tokens the user is willing to accept",
          "dex_": "Dex pool",
          "swap0to1_": "Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0"
        },
        "returns": {
          "amountOut_": "The amount of output tokens received from the swap"
        }
      },
      "estimateSwapOut(address,bool,uint256,uint256)": {
        "params": {
          "amountInMax_": "Maximum amount of tokens to swap in",
          "amountOut_": "The exact amount of tokens to receive after swap",
          "dex_": "Dex pool",
          "swap0to1_": "Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0"
        },
        "returns": {
          "amountIn_": "The amount of input tokens used for the swap"
        }
      },
      "getAllPoolAddresses()": {
        "returns": {
          "pools_": "An array containing all Pool addresses"
        }
      },
      "getAllPools()": {
        "returns": {
          "pools_": "An array containing all Pool data"
        }
      },
      "getAllPoolsReserves()": {
        "details": "expected to be called via callStatic",
        "returns": {
          "poolsReserves_": "An array containing all Pool data with reserves"
        }
      },
      "getAllPoolsReservesAdjusted()": {
        "details": "expected to be called via callStatic",
        "returns": {
          "poolsReserves_": "An array containing all Pool data with adjusted reserves scaled to 1e12"
        }
      },
      "getDexCollateralReserves(address)": {
        "details": "expected to be called via callStatic",
        "params": {
          "dex_": "The address of the DEX"
        },
        "returns": {
          "reserves_": "A struct containing collateral reserve information"
        }
      },
      "getDexCollateralReservesAdjusted(address)": {
        "details": "expected to be called via callStatic",
        "params": {
          "dex_": "The address of the DEX"
        },
        "returns": {
          "reserves_": "A struct containing collateral reserve information"
        }
      },
      "getDexDebtReserves(address)": {
        "details": "expected to be called via callStatic",
        "params": {
          "dex_": "The address of the DEX"
        },
        "returns": {
          "reserves_": "A struct containing debt reserve information"
        }
      },
      "getDexDebtReservesAdjusted(address)": {
        "details": "expected to be called via callStatic",
        "params": {
          "dex_": "The address of the DEX"
        },
        "returns": {
          "reserves_": "A struct containing debt reserve information"
        }
      },
      "getDexLimits(address)": {
        "params": {
          "dex_": "The address of the DEX"
        },
        "returns": {
          "limits_": "A struct containing the swap limits for the DEX"
        }
      },
      "getDexPricesAndExchangePrices(address)": {
        "details": "expected to be called via callStatic",
        "params": {
          "dex_": "The address of the DEX"
        },
        "returns": {
          "pex_": "A struct containing prices and exchange prices"
        }
      },
      "getPool(uint256)": {
        "params": {
          "poolId_": "The ID of the Pool"
        },
        "returns": {
          "pool_": "The Pool data"
        }
      },
      "getPoolAddress(uint256)": {
        "params": {
          "poolId_": "The ID of the Pool"
        },
        "returns": {
          "pool_": "The address of the Pool"
        }
      },
      "getPoolFee(address)": {
        "params": {
          "pool_": "The Pool address"
        },
        "returns": {
          "fee_": "The Pool fee as 1% = 10000"
        }
      },
      "getPoolReserves(address)": {
        "details": "expected to be called via callStatic",
        "params": {
          "pool_": "The Pool address"
        },
        "returns": {
          "poolReserves_": "The Pool data with reserves."
        }
      },
      "getPoolReservesAdjusted(address)": {
        "details": "expected to be called via callStatic",
        "params": {
          "pool_": "The Pool address"
        },
        "returns": {
          "poolReserves_": "The Pool data with adjusted reserves scaled to 1e12. balanceTokens are in token decimals."
        }
      },
      "getPoolTokens(address)": {
        "params": {
          "pool_": "The address of the Pool"
        },
        "returns": {
          "token0_": "The address of token0 in the Pool",
          "token1_": "The address of token1 in the Pool"
        }
      },
      "getPoolsReserves(address[])": {
        "details": "expected to be called via callStatic",
        "params": {
          "pools_": "The array of Pool addresses"
        },
        "returns": {
          "poolsReserves_": "An array containing all Pool data with reserves"
        }
      },
      "getPoolsReservesAdjusted(address[])": {
        "details": "expected to be called via callStatic",
        "params": {
          "pools_": "The array of Pool addresses"
        },
        "returns": {
          "poolsReserves_": "An array containing all Pool data with adjusted reserves scaled to 1e12"
        }
      },
      "getTotalPools()": {
        "returns": {
          "_0": "The total number of Pools"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "estimateSwapIn(address,bool,uint256,uint256)": {
        "notice": "estimates swap IN tokens execution"
      },
      "estimateSwapOut(address,bool,uint256,uint256)": {
        "notice": "estimates swap OUT tokens execution"
      },
      "getAllPoolAddresses()": {
        "notice": "Get an array of all Pool addresses"
      },
      "getAllPools()": {
        "notice": "Get an array of all Pool addresses and their token addresses"
      },
      "getAllPoolsReserves()": {
        "notice": "Get an array of all Pool addresses, their token addresses, collateral reserves, and debt reserves"
      },
      "getAllPoolsReservesAdjusted()": {
        "notice": "Get an array of all Pool addresses, their token addresses, adjusted collateral reserves, and adjusted debt reserves"
      },
      "getDexCollateralReserves(address)": {
        "notice": "Get the collateral reserves for a DEX in token decimals amounts"
      },
      "getDexCollateralReservesAdjusted(address)": {
        "notice": "Get the collateral reserves for a DEX scaled to 1e12"
      },
      "getDexDebtReserves(address)": {
        "notice": "Get the debt reserves for a DEX in token decimals amounts"
      },
      "getDexDebtReservesAdjusted(address)": {
        "notice": "Get the debt reserves for a DEX scaled to 1e12"
      },
      "getDexLimits(address)": {
        "notice": "get the swap limits for a DEX"
      },
      "getDexPricesAndExchangePrices(address)": {
        "notice": "Get the prices and exchange prices for a DEX"
      },
      "getPool(uint256)": {
        "notice": "Get a Pool's address and its token addresses"
      },
      "getPoolAddress(uint256)": {
        "notice": "Get the address of a Pool given its ID"
      },
      "getPoolConstantsView(address)": {
        "notice": "returns all Pool constants"
      },
      "getPoolConstantsView2(address)": {
        "notice": "returns all Pool constants 2"
      },
      "getPoolFee(address)": {
        "notice": "Get a Pool's fee"
      },
      "getPoolReserves(address)": {
        "notice": "Get the token addresses, collateral reserves, and debt reserves for a given Pool address"
      },
      "getPoolReservesAdjusted(address)": {
        "notice": "Get the token addresses, adjusted collateral reserves, and adjusted debt reserves for a given Pool address"
      },
      "getPoolTokens(address)": {
        "notice": "Get the addresses of the tokens in a Pool"
      },
      "getPoolsReserves(address[])": {
        "notice": "Get an array of Pool addresses, their token addresses, collateral reserves, and debt reserves for a given array of Pool addresses"
      },
      "getPoolsReservesAdjusted(address[])": {
        "notice": "Get an array of Pool addresses, their token addresses, adjusted collateral reserves, and adjusted debt reserves for a given array of Pool addresses"
      },
      "getTotalPools()": {
        "notice": "Get the total number of Pools"
      }
    },
    "notice": "Fluid Dex Reserves resolver Implements various view-only methods to give easy access to Dex protocol reserves data.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}