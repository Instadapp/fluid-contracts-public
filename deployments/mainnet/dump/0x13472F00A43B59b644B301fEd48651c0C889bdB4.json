{
  "address": "0x13472F00A43B59b644B301fEd48651c0C889bdB4",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "liquidity_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vaultFactory_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "deployer_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vaultAdminImplementation_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vaultSecondaryImplementation_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vaultOperateImplementation_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vaultMainImplementation1_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vaultMainImplementation2_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "colLiquidated",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "debtLiquidated",
          "type": "uint256"
        }
      ],
      "name": "FluidLiquidateResult",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "errorId_",
          "type": "uint256"
        }
      ],
      "name": "FluidVaultError",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "vaultId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "smartCol",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "smartDebt",
          "type": "address"
        }
      ],
      "name": "VaultT4Deployed",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "ADDRESS_THIS",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ADMIN_IMPLEMENTATION",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DEPLOYER",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "LIQUIDITY",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MINI_DEPLOYER",
      "outputs": [
        {
          "internalType": "contract MiniDeployer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SECONDARY_IMPLEMENTATION",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VAULT_T4_CREATIONCODE_MAIN_OPERATE",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "mainCreationCode",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "operateCreationCode",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartCol_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "smartDebt_",
          "type": "address"
        }
      ],
      "name": "vaultT4",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "vaultCreationBytecode_",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x524987a4f1de3c2356145cc0be5005bb46e8f52c86b5e6a845f9cf8b000285ec",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x0Ed35B1609Ec45c7079E80d11149a52717e4859A",
    "contractAddress": null,
    "transactionIndex": 124,
    "gasUsed": "1293811",
    "logsBloom": "0x00000000000000000000000080000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000400000000000800000000000000000000004000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000020000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000001",
    "blockHash": "0xb30b4e567a2409cb1bcf908707ae19f850dee8a3bb904bddc022c04b880edd6c",
    "transactionHash": "0x524987a4f1de3c2356145cc0be5005bb46e8f52c86b5e6a845f9cf8b000285ec",
    "logs": [
      {
        "transactionIndex": 124,
        "blockNumber": 20948203,
        "transactionHash": "0x524987a4f1de3c2356145cc0be5005bb46e8f52c86b5e6a845f9cf8b000285ec",
        "address": "0xe9cad1355c3db4cCa0349148dA544233702c3709",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000324c5dc1fc42c7a4d43d92df1eba58a54d13bf2d"
        ],
        "data": "0x",
        "logIndex": 360,
        "blockHash": "0xb30b4e567a2409cb1bcf908707ae19f850dee8a3bb904bddc022c04b880edd6c"
      }
    ],
    "blockNumber": 20948203,
    "cumulativeGasUsed": "12044195",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x52Aa899454998Be5b000Ad077a46Bbe360F4e497",
    "0x324c5Dc1fC42c7a4D43d92df1eBA58a54d13Bf2d",
    "0x4EC7b668BAF70d4A4b0FC7941a7708A07b6d45Be",
    "0x644E0b92Ef00847184acB0679D2F116d1fA66659",
    "0xf38478d055020bbC173734Dc62d88b749Eb99b59",
    "0x6B2A7aa04362e1D1952782258cAA349F4cB888FC",
    "0x20ac1A454dBfe3cD580f4A3a4A5b285D32840759",
    "0xF413651fa6D122bf89Ca9b327D5Ac5691a9F51B8"
  ],
  "numDeployments": 1,
  "solcInputHash": "ddfeecb7a58f311ff27917b834ddaf99",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidity_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultFactory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deployer_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultAdminImplementation_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultSecondaryImplementation_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultOperateImplementation_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultMainImplementation1_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultMainImplementation2_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"colLiquidated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtLiquidated\",\"type\":\"uint256\"}],\"name\":\"FluidLiquidateResult\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorId_\",\"type\":\"uint256\"}],\"name\":\"FluidVaultError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"smartCol\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"smartDebt\",\"type\":\"address\"}],\"name\":\"VaultT4Deployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADDRESS_THIS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ADMIN_IMPLEMENTATION\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPLOYER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINI_DEPLOYER\",\"outputs\":[{\"internalType\":\"contract MiniDeployer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDARY_IMPLEMENTATION\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT_T4_CREATIONCODE_MAIN_OPERATE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainCreationCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operateCreationCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartCol_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"smartDebt_\",\"type\":\"address\"}],\"name\":\"vaultT4\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"vaultCreationBytecode_\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"VaultT4Deployed(address,uint256,address,address)\":{\"params\":{\"smartCol\":\"The address of the dex for which the smart collateral is used.\",\"smartDebt\":\"The address of the dex for which the smart debt is used.\",\"vault\":\"The address of the newly deployed vault.\",\"vaultId\":\"The id of the newly deployed vault.\"}}},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"each vault type has different vaultAdminImplementation but same vaultSecondaryImplementatio\"},\"operateCreationCode()\":{\"details\":\"Retrieves the creation code for the Operate contract\"}},\"stateVariables\":{\"VAULT_T4_CREATIONCODE_MAIN_ADDRESS_1\":{\"details\":\"SSTORE2 pointer for the VaultT4 creation code. Stored externally to reduce factory bytecode (in 2 parts)\"}},\"version\":1},\"userdoc\":{\"errors\":{\"FluidLiquidateResult(uint256,uint256)\":[{\"notice\":\"used to simulate liquidation to find the maximum liquidatable amounts\"}]},\"events\":{\"VaultT4Deployed(address,uint256,address,address)\":{\"notice\":\"Emitted when a new vaultT4 is deployed.\"}},\"kind\":\"user\",\"methods\":{\"ADDRESS_THIS()\":{\"notice\":\"address of this contract\"},\"ADMIN_IMPLEMENTATION()\":{\"notice\":\"address of Admin implementation\"},\"LIQUIDITY()\":{\"notice\":\"address of liquidity contract\"},\"MINI_DEPLOYER()\":{\"notice\":\"address of MiniDeployer Contract\"},\"SECONDARY_IMPLEMENTATION()\":{\"notice\":\"address of Secondary implementation\"},\"mainCreationCode()\":{\"notice\":\"returns the stored DexT1 creation bytecode\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocols/vault/factory/deploymentLogics/vaultT4Logic.sol\":\"FluidVaultT4DeploymentLogic\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xab28a56179c1db258c9bf5235b382698cb650debecb51b23d12be9e241374b68\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd1556954440b31c97a142c6ba07d5cade45f96fafd52091d33a14ebe365aecbf\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/libraries/bytesSliceAndConcat.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary BytesSliceAndConcat {\\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\\n    function bytesConcat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    ) internal pure returns (bytes memory tempBytes) {\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(\\n                0x40,\\n                and(\\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n                    not(31) // Round down to the nearest 32 bytes.\\n                )\\n            )\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\\n    function bytesSlice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory tempBytes) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n}\\n\",\"keccak256\":\"0x42966896926a24dc7645ebf4679e6d701cb991144ef4d710d87738165d4024c7\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/dexSlotsLink.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\\nlibrary DexSlotsLink {\\n    /// @dev storage slot for variables at Dex\\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\\n    /// @dev storage slot for variables2 at Dex\\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\\n    /// @dev storage slot for total supply shares at Dex\\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\\n    /// @dev storage slot for user supply mapping at Dex\\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\\n    /// @dev storage slot for total borrow shares at Dex\\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\\n    /// @dev storage slot for user borrow mapping at Dex\\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\\n    /// @dev storage slot for oracle mapping at Dex\\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\\n    /// @dev storage slot for range and threshold shifts at Dex\\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\\n    /// @dev storage slot for center price shift at Dex\\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\\n\\n    // --------------------------------\\n    // @dev stacked uint256 storage slots bits position data for each:\\n\\n    // UserSupplyData\\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\\n\\n    // UserBorrowData\\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\\n\\n    // --------------------------------\\n\\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\\n    function calculateDoubleMappingStorageSlot(\\n        uint256 slot_,\\n        address key1_,\\n        address key2_\\n    ) internal pure returns (bytes32) {\\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\\n        return keccak256(abi.encode(key2_, intermediateSlot_));\\n    }\\n}\\n\",\"keccak256\":\"0xf1d6550d83fb0155a26655234922c9bdf4a1bbcf7a3ca767e9123d367a795307\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/fluidProtocolTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ninterface IFluidProtocol {\\n    function TYPE() external view returns (uint256);\\n}\\n\\n/// @notice implements helper methods to filter Fluid protocols by a certain type\\nlibrary FluidProtocolTypes {\\n    uint256 internal constant VAULT_T1_TYPE = 10000; // VaultT1 borrow protocol type vaults\\n    uint256 internal constant VAULT_T2_SMART_COL_TYPE = 20000; // DEX protocol type vault\\n    uint256 internal constant VAULT_T3_SMART_DEBT_TYPE = 30000; // DEX protocol type vault\\n    uint256 internal constant VAULT_T4_SMART_COL_SMART_DEBT_TYPE = 40000; // DEX protocol type vault\\n\\n    /// @dev filters input `addresses_` by protocol `type_`. Input addresses must be actual Fluid protocols, otherwise\\n    ///      they would be wrongly assumed to be VaultT1 even if they are not Fluid VaultT1 smart contracts.\\n    ///      `type_` must be a listed constant type of this library.\\n    ///      Example usage is to filter all vault addresses at the Vault factory by a certain type, e.g. to not include\\n    ///      DEX protocol type vaults.\\n    function filterBy(address[] memory addresses_, uint256 type_) internal view returns (address[] memory filtered_) {\\n        uint256 curType_;\\n        uint256 filteredProtocols_ = addresses_.length;\\n        for (uint256 i; i < addresses_.length; ) {\\n            try IFluidProtocol(addresses_[i]).TYPE() returns (uint256 protocolType_) {\\n                curType_ = protocolType_;\\n            } catch {\\n                curType_ = VAULT_T1_TYPE;\\n            }\\n\\n            if (curType_ != type_) {\\n                addresses_[i] = address(0);\\n                --filteredProtocols_;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        filtered_ = new address[](filteredProtocols_);\\n        uint256 index_;\\n        unchecked {\\n            for (uint256 i; i < addresses_.length; ) {\\n                if (addresses_[i] != address(0)) {\\n                    filtered_[index_] = addresses_[i];\\n                    ++index_;\\n                }\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x98868cc272fea53dbd4504e02df4f4fcd709a4144a8b37a85513edd638bd073b\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/interfaces/iDexT1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IFluidDexT1 {\\n    error FluidDexError(uint256 errorId);\\n\\n    /// @notice used to simulate swap to find the output amount\\n    error FluidDexSwapResult(uint256 amountOut);\\n\\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\\n\\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\\n\\n    error FluidDexLiquidityOutput(uint256 shares);\\n\\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\\n\\n    /// @notice returns the dex id\\n    function DEX_ID() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct Implementations {\\n        address shift;\\n        address admin;\\n        address colOperations;\\n        address debtOperations;\\n        address perfectOperationsAndOracle;\\n    }\\n\\n    struct ConstantViews {\\n        uint256 dexId;\\n        address liquidity;\\n        address factory;\\n        Implementations implementations;\\n        address deployerContract;\\n        address token0;\\n        address token1;\\n        bytes32 supplyToken0Slot;\\n        bytes32 borrowToken0Slot;\\n        bytes32 supplyToken1Slot;\\n        bytes32 borrowToken1Slot;\\n        bytes32 exchangePriceToken0Slot;\\n        bytes32 exchangePriceToken1Slot;\\n        uint256 oracleMapping;\\n    }\\n\\n    struct ConstantViews2 {\\n        uint token0NumeratorPrecision;\\n        uint token0DenominatorPrecision;\\n        uint token1NumeratorPrecision;\\n        uint token1DenominatorPrecision;\\n    }\\n\\n    struct PricesAndExchangePrice {\\n        uint lastStoredPrice; // last stored price in 1e27 decimals\\n        uint centerPrice; // last stored price in 1e27 decimals\\n        uint upperRange; // price at upper range in 1e27 decimals\\n        uint lowerRange; // price at lower range in 1e27 decimals\\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\\n        uint supplyToken0ExchangePrice;\\n        uint borrowToken0ExchangePrice;\\n        uint supplyToken1ExchangePrice;\\n        uint borrowToken1ExchangePrice;\\n    }\\n\\n    struct CollateralReserves {\\n        uint token0RealReserves;\\n        uint token1RealReserves;\\n        uint token0ImaginaryReserves;\\n        uint token1ImaginaryReserves;\\n    }\\n\\n    struct DebtReserves {\\n        uint token0Debt;\\n        uint token1Debt;\\n        uint token0RealReserves;\\n        uint token1RealReserves;\\n        uint token0ImaginaryReserves;\\n        uint token1ImaginaryReserves;\\n    }\\n\\n    function getCollateralReserves(\\n        uint geometricMean_,\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint token0SupplyExchangePrice_,\\n        uint token1SupplyExchangePrice_\\n    ) external view returns (CollateralReserves memory c_);\\n\\n    function getDebtReserves(\\n        uint geometricMean_,\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint token0BorrowExchangePrice_,\\n        uint token1BorrowExchangePrice_\\n    ) external view returns (DebtReserves memory d_);\\n\\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\\n    function getPricesAndExchangePrices() external;\\n\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\\n\\n    struct Oracle {\\n        uint twap1by0; // TWAP price\\n        uint lowestPrice1by0; // lowest price point\\n        uint highestPrice1by0; // highest price point\\n        uint twap0by1; // TWAP price\\n        uint lowestPrice0by1; // lowest price point\\n        uint highestPrice0by1; // highest price point\\n    }\\n\\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountIn_ The exact amount of input tokens to swap\\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\\n    /// @return amountOut_ The amount of output tokens received from the swap\\n    function swapIn(\\n        bool swap0to1_,\\n        uint256 amountIn_,\\n        uint256 amountOutMin_,\\n        address to_\\n    ) external payable returns (uint256 amountOut_);\\n\\n    /// @dev Swap tokens with perfect amount out\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountOut_ The exact amount of tokens to receive after swap\\n    /// @param amountInMax_ Maximum amount of tokens to swap in\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\\n    /// @return amountIn_ The amount of input tokens used for the swap\\n    function swapOut(\\n        bool swap0to1_,\\n        uint256 amountOut_,\\n        uint256 amountInMax_,\\n        address to_\\n    ) external payable returns (uint256 amountIn_);\\n\\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\\n    /// @param shares_ The number of shares to mint\\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\\n    /// @return token0Amt_ Amount of token0 deposited\\n    /// @return token1Amt_ Amount of token1 deposited\\n    function depositPerfect(\\n        uint shares_,\\n        uint maxToken0Deposit_,\\n        uint maxToken1Deposit_,\\n        bool estimate_\\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\\n    /// @param shares_ The number of shares to withdraw\\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\\n    /// @return token0Amt_ The amount of token0 withdrawn\\n    /// @return token1Amt_ The amount of token1 withdrawn\\n    function withdrawPerfect(\\n        uint shares_,\\n        uint minToken0Withdraw_,\\n        uint minToken1Withdraw_,\\n        address to_\\n    ) external returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\\n    /// @param shares_ The number of shares to borrow\\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\\n    /// @return token0Amt_ Amount of token0 borrowed\\n    /// @return token1Amt_ Amount of token1 borrowed\\n    function borrowPerfect(\\n        uint shares_,\\n        uint minToken0Borrow_,\\n        uint minToken1Borrow_,\\n        address to_\\n    ) external returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\\n    /// @param shares_ The number of shares to pay back\\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\\n    /// @return token0Amt_ Amount of token0 paid back\\n    /// @return token1Amt_ Amount of token1 paid back\\n    function paybackPerfect(\\n        uint shares_,\\n        uint maxToken0Payback_,\\n        uint maxToken1Payback_,\\n        bool estimate_\\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\\n    /// @param token0Amt_ The amount of token0 to deposit\\n    /// @param token1Amt_ The amount of token1 to deposit\\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\\n    /// @return shares_ The amount of shares minted for the deposit\\n    function deposit(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint minSharesAmt_,\\n        bool estimate_\\n    ) external payable returns (uint shares_);\\n\\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\\n    /// @param token0Amt_ The amount of token0 to withdraw\\n    /// @param token1Amt_ The amount of token1 to withdraw\\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\\n    /// @return shares_ The number of shares burned for the withdrawal\\n    function withdraw(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint maxSharesAmt_,\\n        address to_\\n    ) external returns (uint shares_);\\n\\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\\n    /// @param token0Amt_ The amount of token0 to borrow\\n    /// @param token1Amt_ The amount of token1 to borrow\\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\\n    function borrow(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint maxSharesAmt_,\\n        address to_\\n    ) external returns (uint shares_);\\n\\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\\n    /// @param token0Amt_ The amount of token0 to payback\\n    /// @param token1Amt_ The amount of token1 to payback\\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\\n    /// @return shares_ The amount of borrow shares burned for the payback\\n    function payback(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint minSharesAmt_,\\n        bool estimate_\\n    ) external payable returns (uint shares_);\\n\\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\\n    /// @param shares_ The number of shares to burn for withdrawal\\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\\n    function withdrawPerfectInOneToken(\\n        uint shares_,\\n        uint minToken0_,\\n        uint minToken1_,\\n        address to_\\n    ) external returns (\\n        uint withdrawAmt_\\n    );\\n\\n    /// @dev This function allows users to payback their debt with perfect shares in one token\\n    /// @param shares_ The number of shares to burn for payback\\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\\n    function paybackPerfectInOneToken(\\n        uint shares_,\\n        uint maxToken0_,\\n        uint maxToken1_,\\n        bool estimate_\\n    ) external payable returns (\\n        uint paybackAmt_\\n    );\\n\\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\\n    /// but the difference due to interest will be super low so this difference is ignored\\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\\n    /// @return currentPrice_ price of pool after the most recent swap\\n    function oraclePrice(\\n        uint[] memory secondsAgos_\\n    ) external view returns (\\n        Oracle[] memory twaps_,\\n        uint currentPrice_\\n    );\\n}\\n\",\"keccak256\":\"0xa405007cdd45409412ce0fe02a991cadbae17760bc15402c839375505f69d7b2\",\"license\":\"MIT\"},\"contracts/protocols/vault/error.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Error {\\n    error FluidVaultError(uint256 errorId_);\\n\\n    /// @notice used to simulate liquidation to find the maximum liquidatable amounts\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n}\\n\",\"keccak256\":\"0x3109fe35234c0428642d43e70b56bcdbbfeef1d9e5ca29f4c8b8a181d7b8d83c\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary ErrorTypes {\\n    /***********************************|\\n    |           Vault Factory           | \\n    |__________________________________*/\\n\\n    uint256 internal constant VaultFactory__InvalidOperation = 30001;\\n    uint256 internal constant VaultFactory__Unauthorized = 30002;\\n    uint256 internal constant VaultFactory__SameTokenNotAllowed = 30003;\\n    uint256 internal constant VaultFactory__InvalidParams = 30004;\\n    uint256 internal constant VaultFactory__InvalidVault = 30005;\\n    uint256 internal constant VaultFactory__InvalidVaultAddress = 30006;\\n    uint256 internal constant VaultFactory__OnlyDelegateCallAllowed = 30007;\\n\\n    /***********************************|\\n    |            Vault                  | \\n    |__________________________________*/\\n\\n    /// @notice thrown at reentrancy\\n    uint256 internal constant Vault__AlreadyEntered = 31001;\\n\\n    /// @notice thrown when user sends deposit & borrow amount as 0\\n    uint256 internal constant Vault__InvalidOperateAmount = 31002;\\n\\n    /// @notice thrown when msg.value is not in sync with native token deposit or payback\\n    uint256 internal constant Vault__InvalidMsgValueOperate = 31003;\\n\\n    /// @notice thrown when msg.sender is not the owner of the vault\\n    uint256 internal constant Vault__NotAnOwner = 31004;\\n\\n    /// @notice thrown when user's position does not exist. Sending the wrong index from the frontend\\n    uint256 internal constant Vault__TickIsEmpty = 31005;\\n\\n    /// @notice thrown when the user's position is above CF and the user tries to make it more risky by trying to withdraw or borrow\\n    uint256 internal constant Vault__PositionAboveCF = 31006;\\n\\n    /// @notice thrown when the top tick is not initialized. Happens if the vault is totally new or all the user's left\\n    uint256 internal constant Vault__TopTickDoesNotExist = 31007;\\n\\n    /// @notice thrown when msg.value in liquidate is not in sync payback\\n    uint256 internal constant Vault__InvalidMsgValueLiquidate = 31008;\\n\\n    /// @notice thrown when slippage is more on liquidation than what the liquidator sent\\n    uint256 internal constant Vault__ExcessSlippageLiquidation = 31009;\\n\\n    /// @notice thrown when msg.sender is not the rebalancer/reserve contract\\n    uint256 internal constant Vault__NotRebalancer = 31010;\\n\\n    /// @notice thrown when NFT of one vault interacts with the NFT of other vault\\n    uint256 internal constant Vault__NftNotOfThisVault = 31011;\\n\\n    /// @notice thrown when the token is not initialized on the liquidity contract\\n    uint256 internal constant Vault__TokenNotInitialized = 31012;\\n\\n    /// @notice thrown when admin updates fallback if a non-auth calls vault\\n    uint256 internal constant Vault__NotAnAuth = 31013;\\n\\n    /// @notice thrown in operate when user tries to witdhraw more collateral than deposited\\n    uint256 internal constant Vault__ExcessCollateralWithdrawal = 31014;\\n\\n    /// @notice thrown in operate when user tries to payback more debt than borrowed\\n    uint256 internal constant Vault__ExcessDebtPayback = 31015;\\n\\n    /// @notice thrown when user try to withdrawal more than operate's withdrawal limit\\n    uint256 internal constant Vault__WithdrawMoreThanOperateLimit = 31016;\\n\\n    /// @notice thrown when caller of liquidityCallback is not Liquidity\\n    uint256 internal constant Vault__InvalidLiquidityCallbackAddress = 31017;\\n\\n    /// @notice thrown when reentrancy is not already on\\n    uint256 internal constant Vault__NotEntered = 31018;\\n\\n    /// @notice thrown when someone directly calls operate or secondary implementation contract\\n    uint256 internal constant Vault__OnlyDelegateCallAllowed = 31019;\\n\\n    /// @notice thrown when the safeTransferFrom for a token amount failed\\n    uint256 internal constant Vault__TransferFromFailed = 31020;\\n\\n    /// @notice thrown when exchange price overflows while updating on storage\\n    uint256 internal constant Vault__ExchangePriceOverFlow = 31021;\\n\\n    /// @notice thrown when debt to liquidate amt is sent wrong\\n    uint256 internal constant Vault__InvalidLiquidationAmt = 31022;\\n\\n    /// @notice thrown when user debt or collateral goes above 2**128 or below -2**128\\n    uint256 internal constant Vault__UserCollateralDebtExceed = 31023;\\n\\n    /// @notice thrown if on liquidation branch debt becomes lower than 100\\n    uint256 internal constant Vault__BranchDebtTooLow = 31024;\\n\\n    /// @notice thrown when tick's debt is less than 10000\\n    uint256 internal constant Vault__TickDebtTooLow = 31025;\\n\\n    /// @notice thrown when the received new liquidity exchange price is of unexpected value (< than the old one)\\n    uint256 internal constant Vault__LiquidityExchangePriceUnexpected = 31026;\\n\\n    /// @notice thrown when user's debt is less than 10000\\n    uint256 internal constant Vault__UserDebtTooLow = 31027;\\n\\n    /// @notice thrown when on only payback and only deposit the ratio of position increases\\n    uint256 internal constant Vault__InvalidPaybackOrDeposit = 31028;\\n\\n    /// @notice thrown when liquidation just happens of a single partial or when there's nothing to liquidate\\n    uint256 internal constant Vault__InvalidLiquidation = 31029;\\n\\n    /// @notice thrown when msg.value is sent wrong in rebalance\\n    uint256 internal constant Vault__InvalidMsgValueInRebalance = 31030;\\n\\n    /// @notice thrown when nothing rebalanced\\n    uint256 internal constant Vault__NothingToRebalance = 31031;\\n\\n    /// @notice thrown on unforseen liquidation scenarios. Might never come in use.\\n    uint256 internal constant Vault__LiquidationReverts = 31032;\\n\\n    /// @notice thrown when oracle price is > 1e54\\n    uint256 internal constant Vault__InvalidOraclePrice = 31033;\\n\\n    /// @notice thrown when constants are not set properly via contructor\\n    uint256 internal constant Vault__ImproperConstantsSetup = 31034;\\n\\n    /// @notice thrown when externally calling fetchLatestPosition function\\n    uint256 internal constant Vault__FetchLatestPositionFailed = 31035;\\n\\n    /// @notice thrown when dex callback is not from dex\\n    uint256 internal constant Vault__InvalidDexCallbackAddress = 31036;\\n\\n    /// @notice thrown when dex callback is already set\\n    uint256 internal constant Vault__DexFromAddressAlreadySet = 31037;\\n\\n    /// @notice thrown when an invalid min / max amounts config is passed to rebalance()\\n    uint256 internal constant Vault__InvalidMinMaxInRebalance = 31038;\\n\\n    /***********************************|\\n    |              ERC721               | \\n    |__________________________________*/\\n\\n    uint256 internal constant ERC721__InvalidParams = 32001;\\n    uint256 internal constant ERC721__Unauthorized = 32002;\\n    uint256 internal constant ERC721__InvalidOperation = 32003;\\n    uint256 internal constant ERC721__UnsafeRecipient = 32004;\\n    uint256 internal constant ERC721__OutOfBoundsIndex = 32005;\\n\\n    /***********************************|\\n    |            Vault Admin            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when admin tries to setup invalid value which are crossing limits\\n    uint256 internal constant VaultAdmin__ValueAboveLimit = 33001;\\n\\n    /// @notice when someone directly calls admin implementation contract\\n    uint256 internal constant VaultAdmin__OnlyDelegateCallAllowed = 33002;\\n\\n    /// @notice thrown when auth sends NFT ID as 0 while collecting dust debt\\n    uint256 internal constant VaultAdmin__NftIdShouldBeNonZero = 33003;\\n\\n    /// @notice thrown when trying to collect dust debt of NFT which is not of this vault\\n    uint256 internal constant VaultAdmin__NftNotOfThisVault = 33004;\\n\\n    /// @notice thrown when dust debt of NFT is 0, meaning nothing to collect\\n    uint256 internal constant VaultAdmin__DustDebtIsZero = 33005;\\n\\n    /// @notice thrown when final debt after liquidation is not 0, meaning position 100% liquidated\\n    uint256 internal constant VaultAdmin__FinalDebtShouldBeZero = 33006;\\n\\n    /// @notice thrown when NFT is not liquidated state\\n    uint256 internal constant VaultAdmin__NftNotLiquidated = 33007;\\n\\n    /// @notice thrown when total absorbed dust debt is 0\\n    uint256 internal constant VaultAdmin__AbsorbedDustDebtIsZero = 33008;\\n\\n    /// @notice thrown when address is set as 0\\n    uint256 internal constant VaultAdmin__AddressZeroNotAllowed = 33009;\\n\\n    /***********************************|\\n    |            Vault Rewards          | \\n    |__________________________________*/\\n\\n    uint256 internal constant VaultRewards__Unauthorized = 34001;\\n    uint256 internal constant VaultRewards__AddressZero = 34002;\\n    uint256 internal constant VaultRewards__InvalidParams = 34003;\\n    uint256 internal constant VaultRewards__NewMagnifierSameAsOldMagnifier = 34004;\\n    uint256 internal constant VaultRewards__NotTheInitiator = 34005;\\n    uint256 internal constant VaultRewards__AlreadyStarted = 34006;\\n    uint256 internal constant VaultRewards__RewardsNotStartedOrEnded = 34007;\\n\\n    /***********************************|\\n    |          Vault DEX Types          | \\n    |__________________________________*/\\n\\n    uint256 internal constant VaultDex__InvalidOperateAmount = 35001;\\n    uint256 internal constant VaultDex__DebtSharesPaidMoreThanAvailableLiquidation = 35002;\\n}\\n\",\"keccak256\":\"0x52d25ef0fa2c50b104b029d48681e51289499abfbd4bbb82346d3fab4f3f9978\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/factory/deploymentHelpers/miniDeployer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Owned } from \\\"solmate/src/auth/Owned.sol\\\";\\n\\n/// @title MiniDeployer\\n/// @notice A contract that allows deployers to deploy any contract by passing the contract data in bytes\\n/// @dev The main objective of this contract is to avoid storing contract addresses in our protocols which requires 160 bits of storage\\n///      Instead, we can just store the nonce & deployment of this address to calculate the address realtime using \\\"AddressCalcs\\\" library\\ncontract MiniDeployer is Owned {\\n    /// @notice Thrown when an invalid operation is attempted\\n    error MiniDeployer__InvalidOperation();\\n\\n    /// @notice Emitted when a new contract is deployed\\n    event LogContractDeployed(address indexed contractAddress);\\n\\n    /// @notice Constructor to initialize the contract\\n    /// @param owner_ The address of the contract owner\\n    constructor(address owner_) Owned(owner_) {}\\n\\n    /// @notice Internal function to deploy a contract\\n    /// @param bytecode_ The bytecode of the contract to deploy\\n    /// @return address_ The address of the deployed contract\\n    /// @dev Uses inline assembly for efficient deployment\\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\\n        if (bytecode_.length == 0) {\\n            revert MiniDeployer__InvalidOperation();\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\\n        }\\n        if (address_ == address(0)) {\\n            revert MiniDeployer__InvalidOperation();\\n        }\\n    }\\n\\n    /// @notice Deploys a new contract\\n    /// @param contractCode_ The bytecode of the contract to deploy\\n    /// @return contractAddress_ The address of the deployed contract\\n    /// @dev Decrements the deployer's allowed deployments count if not the owner\\n    function deployContract(bytes calldata contractCode_) external onlyOwner returns (address contractAddress_) {\\n        contractAddress_ = _deploy(contractCode_);\\n\\n        emit LogContractDeployed(contractAddress_);\\n    }\\n}\\n\",\"keccak256\":\"0xe2477b35f959992a710b8eb589baa5d346799e524adaeb5a03abe5ac469b1ca3\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/factory/deploymentLogics/vaultT4Logic.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { SSTORE2 } from \\\"solmate/src/utils/SSTORE2.sol\\\";\\nimport { MiniDeployer } from \\\"../deploymentHelpers/miniDeployer.sol\\\";\\nimport { ErrorTypes } from \\\"../../errorTypes.sol\\\";\\nimport { Error } from \\\"../../error.sol\\\";\\nimport { IFluidVaultFactory } from \\\"../../interfaces/iVaultFactory.sol\\\";\\nimport { DexSlotsLink } from \\\"../../../../libraries/dexSlotsLink.sol\\\";\\nimport { FluidProtocolTypes } from \\\"../../../../libraries/fluidProtocolTypes.sol\\\";\\nimport { IFluidVaultT4 } from \\\"../../interfaces/iVaultT4.sol\\\";\\nimport { IFluidDexT1 } from \\\"../../../dex/interfaces/iDexT1.sol\\\";\\nimport { BytesSliceAndConcat } from \\\"../../../../libraries/bytesSliceAndConcat.sol\\\";\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n}\\n\\ncontract FluidVaultT4DeploymentLogic is Error {\\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @notice address of liquidity contract\\n    address public immutable LIQUIDITY;\\n\\n    address public immutable DEPLOYER;\\n\\n    /// @notice address of MiniDeployer Contract\\n    MiniDeployer public immutable MINI_DEPLOYER;\\n\\n    /// @notice address of Admin implementation\\n    address public immutable ADMIN_IMPLEMENTATION;\\n\\n    /// @notice address of Secondary implementation\\n    address public immutable SECONDARY_IMPLEMENTATION;\\n\\n    address public immutable VAULT_T4_CREATIONCODE_MAIN_OPERATE;\\n\\n    /// @dev SSTORE2 pointer for the VaultT4 creation code. Stored externally to reduce factory bytecode (in 2 parts)\\n    address internal immutable VAULT_T4_CREATIONCODE_MAIN_ADDRESS_1;\\n    address internal immutable VAULT_T4_CREATIONCODE_MAIN_ADDRESS_2;\\n\\n    /// @notice address of this contract\\n    address public immutable ADDRESS_THIS;\\n\\n    /// @notice Emitted when a new vaultT4 is deployed.\\n    /// @param vault The address of the newly deployed vault.\\n    /// @param vaultId The id of the newly deployed vault.\\n    /// @param smartCol The address of the dex for which the smart collateral is used.\\n    /// @param smartDebt The address of the dex for which the smart debt is used.\\n    event VaultT4Deployed(address indexed vault, uint256 vaultId, address indexed smartCol, address indexed smartDebt);\\n\\n    /// @dev each vault type has different vaultAdminImplementation but same vaultSecondaryImplementatio\\n    constructor(\\n        address liquidity_,\\n        address vaultFactory_,\\n        address deployer_,\\n        address vaultAdminImplementation_,\\n        address vaultSecondaryImplementation_,\\n        address vaultOperateImplementation_,\\n        address vaultMainImplementation1_,\\n        address vaultMainImplementation2_\\n    ) {\\n        LIQUIDITY = liquidity_;\\n        DEPLOYER = deployer_;\\n        ADMIN_IMPLEMENTATION = vaultAdminImplementation_;\\n        SECONDARY_IMPLEMENTATION = vaultSecondaryImplementation_;\\n\\n        // Deploy mini deployer\\n        MINI_DEPLOYER = new MiniDeployer(vaultFactory_);\\n\\n        VAULT_T4_CREATIONCODE_MAIN_OPERATE = vaultOperateImplementation_;\\n\\n        VAULT_T4_CREATIONCODE_MAIN_ADDRESS_1 = vaultMainImplementation1_;\\n        VAULT_T4_CREATIONCODE_MAIN_ADDRESS_2 = vaultMainImplementation2_;\\n\\n        ADDRESS_THIS = address(this);\\n    }\\n\\n    function vaultT4(address smartCol_, address smartDebt_) external returns (bytes memory vaultCreationBytecode_) {\\n        if (address(this) == ADDRESS_THIS) revert FluidVaultError(ErrorTypes.VaultFactory__OnlyDelegateCallAllowed);\\n\\n        // verifying that dex address are valid\\n        IFluidDexT1.ConstantViews memory smartColConstants_ = IFluidDexT1(smartCol_).constantsView();\\n        IFluidDexT1.ConstantViews memory smartDebtConstants_ = IFluidDexT1(smartDebt_).constantsView();\\n\\n        IFluidVaultT4.ConstantViews memory constants_;\\n        constants_.liquidity = LIQUIDITY;\\n        constants_.factory = address(this);\\n        constants_.deployer = DEPLOYER;\\n        constants_.adminImplementation = ADMIN_IMPLEMENTATION;\\n        constants_.secondaryImplementation = SECONDARY_IMPLEMENTATION;\\n        constants_.supply = smartCol_;\\n        constants_.supplyToken.token0 = smartColConstants_.token0;\\n        constants_.supplyToken.token1 = smartColConstants_.token1;\\n        constants_.borrow = smartDebt_;\\n        constants_.borrowToken.token0 = smartDebtConstants_.token0;\\n        constants_.borrowToken.token1 = smartDebtConstants_.token1;\\n        constants_.vaultId = IFluidVaultFactory(address(this)).totalVaults();\\n        constants_.vaultType = FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE;\\n\\n        address vault_ = IFluidVaultFactory(address(this)).getVaultAddress(constants_.vaultId);\\n\\n        constants_ = _calculateVaultSlots(constants_, vault_);\\n\\n        vaultCreationBytecode_ = abi.encodePacked(\\n            SSTORE2.read(VAULT_T4_CREATIONCODE_MAIN_OPERATE),\\n            abi.encode(constants_)\\n        );\\n\\n        address operateImplementation_ = MINI_DEPLOYER.deployContract(vaultCreationBytecode_);\\n\\n        constants_.operateImplementation = operateImplementation_;\\n\\n        vaultCreationBytecode_ = abi.encodePacked(mainCreationCode(), abi.encode(constants_));\\n\\n        emit VaultT4Deployed(vault_, constants_.vaultId, smartCol_, smartDebt_);\\n\\n        return vaultCreationBytecode_;\\n    }\\n\\n    /// @dev Retrieves the creation code for the Operate contract\\n    function operateCreationCode() public view returns (bytes memory) {\\n        return SSTORE2.read(VAULT_T4_CREATIONCODE_MAIN_OPERATE);\\n    }\\n\\n    /// @notice returns the stored DexT1 creation bytecode\\n    function mainCreationCode() public view returns (bytes memory) {\\n        return\\n            BytesSliceAndConcat.bytesConcat(\\n                SSTORE2.read(VAULT_T4_CREATIONCODE_MAIN_ADDRESS_1),\\n                SSTORE2.read(VAULT_T4_CREATIONCODE_MAIN_ADDRESS_2)\\n            );\\n    }\\n\\n    function _calculateVaultSlots(\\n        IFluidVaultT4.ConstantViews memory constants_,\\n        address vault_\\n    ) private pure returns (IFluidVaultT4.ConstantViews memory) {\\n        constants_.supplyExchangePriceSlot = bytes32(0);\\n        constants_.borrowExchangePriceSlot = bytes32(0);\\n        constants_.userSupplySlot = DexSlotsLink.calculateMappingStorageSlot(\\n            DexSlotsLink.DEX_USER_SUPPLY_MAPPING_SLOT,\\n            vault_\\n        );\\n        constants_.userBorrowSlot = DexSlotsLink.calculateMappingStorageSlot(\\n            DexSlotsLink.DEX_USER_BORROW_MAPPING_SLOT,\\n            vault_\\n        );\\n        return constants_;\\n    }\\n}\\n\",\"keccak256\":\"0x3c876f1ebae38e9fb66804400e83e91989b935f46445c9a5ccd9856798c1f780\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/interfaces/iVault.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\\ninterface IFluidVault {\\n    /// @notice returns the vault id\\n    function VAULT_ID() external view returns (uint256);\\n\\n    /// @notice returns the vault id\\n    function TYPE() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct Tokens {\\n        address token0;\\n        address token1;\\n    }\\n\\n    struct ConstantViews {\\n        address liquidity;\\n        address factory;\\n        address operateImplementation;\\n        address adminImplementation;\\n        address secondaryImplementation;\\n        address deployer; // address which deploys oracle\\n        address supply; // either liquidity layer or DEX protocol\\n        address borrow; // either liquidity layer or DEX protocol\\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\\n        uint256 vaultId;\\n        uint256 vaultType;\\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n    }\\n\\n    /// @notice returns all Vault constants\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    /// @notice fetches the latest user position after a liquidation\\n    function fetchLatestPosition(\\n        int256 positionTick_,\\n        uint256 positionTickId_,\\n        uint256 positionRawDebt_,\\n        uint256 tickData_\\n    )\\n        external\\n        view\\n        returns (\\n            int256, // tick\\n            uint256, // raw debt\\n            uint256, // raw collateral\\n            uint256, // branchID_\\n            uint256 // branchData_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices\\n    function updateExchangePrices(\\n        uint256 vaultVariables2_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices and writes them to storage\\n    function updateExchangePricesOnStorage()\\n        external\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice returns the liquidity contract address\\n    function LIQUIDITY() external view returns (address);\\n\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n\\n    function rebalance(\\n        int colToken0MinMax_,\\n        int colToken1MinMax_,\\n        int debtToken0MinMax_,\\n        int debtToken1MinMax_\\n    ) external returns (int supplyAmt_, int borrowAmt_);\\n\\n    /// @notice reverts with FluidLiquidateResult\\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\\n}\\n\",\"keccak256\":\"0x9eb8e92c52e2ee7222a07a6e995b6bf7604a3e9a7ff1053722aef762948fd4bd\",\"license\":\"MIT\"},\"contracts/protocols/vault/interfaces/iVaultFactory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { IERC721Enumerable } from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\ninterface IFluidVaultFactory is IERC721Enumerable {\\n    /// @notice Minting an NFT Vault for the user\\n    function mint(uint256 vaultId_, address user_) external returns (uint256 tokenId_);\\n\\n    /// @notice returns owner of Vault which is also an NFT\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /// @notice Global auth is auth for all vaults\\n    function isGlobalAuth(address auth_) external view returns (bool);\\n\\n    /// @notice Vault auth is auth for a specific vault\\n    function isVaultAuth(address vault_, address auth_) external view returns (bool);\\n\\n    /// @notice Total vaults deployed.\\n    function totalVaults() external view returns (uint256);\\n\\n    /// @notice Compute vaultAddress\\n    function getVaultAddress(uint256 vaultId) external view returns (address);\\n\\n    /// @notice read uint256 `result_` for a storage `slot_` key\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n}\\n\",\"keccak256\":\"0xc4a0caed89a8670e1ccf159d03fa23bb29f69c579f522bb0e33b1b5cb106c40d\",\"license\":\"MIT\"},\"contracts/protocols/vault/interfaces/iVaultT4.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { IFluidVault } from \\\"./iVault.sol\\\";\\n\\ninterface IFluidVaultT4 is IFluidVault {\\n    function operate(\\n        uint nftId_,\\n        int newColToken0_,\\n        int newColToken1_,\\n        int colSharesMinMax_,\\n        int newDebtToken0_,\\n        int newDebtToken1_,\\n        int debtSharesMinMax_,\\n        address to_\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256, // nftId_\\n            int256, // final supply amount. if - then withdraw\\n            int256 // final borrow amount. if - then payback\\n        );\\n\\n    function operatePerfect(\\n        uint nftId_,\\n        int perfectColShares_,\\n        int colToken0MinMax_,\\n        int colToken1MinMax_,\\n        int perfectDebtShares_,\\n        int debtToken0MinMax_,\\n        int debtToken1MinMax_,\\n        address to_\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256, // nftId_\\n            int256[] memory r_\\n        );\\n\\n    function liquidate(\\n        uint256 token0DebtAmt_,\\n        uint256 token1DebtAmt_,\\n        uint256 debtSharesMin_,\\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\\n        address to_,\\n        bool absorb_\\n    )\\n        external\\n        payable\\n        returns (uint256 actualDebtShares_, uint256 actualColShares_, uint256 token0Col_, uint256 token1Col_);\\n\\n    function liquidatePerfect(\\n        uint256 debtShares_,\\n        uint256 token0DebtAmtPerUnitShares_,\\n        uint256 token1DebtAmtPerUnitShares_,\\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\\n        address to_,\\n        bool absorb_\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 actualDebtShares_,\\n            uint256 token0Debt_,\\n            uint256 token1Debt_,\\n            uint256 actualColShares_,\\n            uint256 token0Col_,\\n            uint256 token1Col_\\n        );\\n}\\n\",\"keccak256\":\"0x7e46e73d0c597cdcf846f7330c52b1c14ec3f52ee55967617afcd40fb238940b\",\"license\":\"MIT\"},\"solmate/src/auth/Owned.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xfedb27d14c508342c33eb067c9a02eabcdb0f9dcf93b04ded1001f580d12d0ea\",\"license\":\"AGPL-3.0-only\"},\"solmate/src/utils/SSTORE2.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Read and write to persistent storage at a fraction of the cost.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\\nlibrary SSTORE2 {\\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               WRITE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function write(bytes memory data) internal returns (address pointer) {\\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\\n        bytes memory runtimeCode = abi.encodePacked(hex\\\"00\\\", data);\\n\\n        bytes memory creationCode = abi.encodePacked(\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            hex\\\"60_0B_59_81_38_03_80_92_59_39_F3\\\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\\n        );\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Deploy a new contract with the generated creation code.\\n            // We start 32 bytes into the code to avoid copying the byte length.\\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\\n        }\\n\\n        require(pointer != address(0), \\\"DEPLOYMENT_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               READ LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function read(address pointer) internal view returns (bytes memory) {\\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\\n    }\\n\\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n\\n        return readBytecode(pointer, start, pointer.code.length - start);\\n    }\\n\\n    function read(\\n        address pointer,\\n        uint256 start,\\n        uint256 end\\n    ) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n        end += DATA_OFFSET;\\n\\n        require(pointer.code.length >= end, \\\"OUT_OF_BOUNDS\\\");\\n\\n        return readBytecode(pointer, start, end - start);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function readBytecode(\\n        address pointer,\\n        uint256 start,\\n        uint256 size\\n    ) private view returns (bytes memory data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            data := mload(0x40)\\n\\n            // Update the free memory pointer to prevent overriding our data.\\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\\n            // Adding 31 to size and running the result through the logic above ensures\\n            // the memory pointer remains word-aligned, following the Solidity convention.\\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\\n\\n            // Store the size of the data in the first 32 byte chunk of free memory.\\n            mstore(data, size)\\n\\n            // Copy the code into memory right after the 32 bytes we used to store the size.\\n            extcodecopy(pointer, add(data, 32), start, size)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc5359c92365c550c418725fc534a538426ea8f6e7f6c06c0a9d66647d864469d\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x6101a06040523480156200001257600080fd5b5060405162001846380380620018468339810160408190526200003591620000f0565b6001600160a01b0380891660805286811660a05285811660e05284166101005260405187906200006590620000c5565b6001600160a01b039091168152602001604051809103906000f08015801562000092573d6000803e3d6000fd5b506001600160a01b0390811660c05292831661012052908216610140521661016052505030610180525062000198915050565b6104f4806200135283390190565b80516001600160a01b0381168114620000eb57600080fd5b919050565b600080600080600080600080610100898b0312156200010e57600080fd5b6200011989620000d3565b97506200012960208a01620000d3565b96506200013960408a01620000d3565b95506200014960608a01620000d3565b94506200015960808a01620000d3565b93506200016960a08a01620000d3565b92506200017960c08a01620000d3565b91506200018960e08a01620000d3565b90509295985092959890939650565b60805160a05160c05160e051610100516101205161014051610160516101805161111262000240600039600081816101e901526102d7015260006102950152600061026c01526000818161019b0152818161023901526106e90152600081816101740152610557015260008181610210015261052f01526000818161013a01526107c80152600081816101c2015261050301526000818160e601526104d501526111126000f3fe608060405234801561001057600080fd5b50600436106100be5760003560e01c8063a07ddc1711610076578063c1b8411a1161005b578063c1b8411a146101bd578063cc025f7c146101e4578063cc2fe94b1461020b57600080fd5b8063a07ddc171461016f578063ba21b9c51461019657600080fd5b80636b171774116100a75780636b1717741461012d5780638cb1b071146101355780639f690ff11461015c57600080fd5b80630e09956a146100c35780632861c7d1146100e1575b600080fd5b6100cb610232565b6040516100d89190610b82565b60405180910390f35b6101087f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100d8565b6100cb610262565b6101087f000000000000000000000000000000000000000000000000000000000000000081565b6100cb61016a366004610bf8565b6102be565b6101087f000000000000000000000000000000000000000000000000000000000000000081565b6101087f000000000000000000000000000000000000000000000000000000000000000081565b6101087f000000000000000000000000000000000000000000000000000000000000000081565b6101087f000000000000000000000000000000000000000000000000000000000000000081565b6101087f000000000000000000000000000000000000000000000000000000000000000081565b606061025d7f0000000000000000000000000000000000000000000000000000000000000000610953565b905090565b606061025d6102907f0000000000000000000000000000000000000000000000000000000000000000610953565b6102b97f0000000000000000000000000000000000000000000000000000000000000000610953565b610981565b606073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610337576040517f60121cca000000000000000000000000000000000000000000000000000000008152617537600482015260240160405180910390fd5b60008373ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa158015610385573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a99190610d57565b905060008373ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa1580156103f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041d9190610d57565b90506104be604080516102008101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905260c0830182905260e0830182905283518085018552828152808201839052610100840152835180850190945281845283015290610120820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c09091015290565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000811682523060208084018290527f0000000000000000000000000000000000000000000000000000000000000000831660a0808601919091527f0000000000000000000000000000000000000000000000000000000000000000841660608601527f00000000000000000000000000000000000000000000000000000000000000008416608086015289841660c08087019190915287820151610100870180519187169091528882015190519086169084015289851660e08701529086015161012086018051918616909152908601519051931692810192909252604080517f8d65402300000000000000000000000000000000000000000000000000000000815290519192638d654023926004808401938290030181865afa15801561061f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106439190610e3e565b6101408201819052619c406101608301526040517fe6bd26a2000000000000000000000000000000000000000000000000000000008152600091309163e6bd26a2916106959160040190815260200190565b602060405180830381865afa1580156106b2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106d69190610e57565b90506106e282826109f9565b915061070d7f0000000000000000000000000000000000000000000000000000000000000000610953565b8260405160200161071e9190610e7b565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529082905261075a9291602001611073565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290527f798133dd000000000000000000000000000000000000000000000000000000008252955060009073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063798133dd906107fd908990600401610b82565b6020604051808303816000875af115801561081c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108409190610e57565b73ffffffffffffffffffffffffffffffffffffffff811660408501529050610866610262565b836040516020016108779190610e7b565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290526108b39291602001611073565b60405160208183030381529060405295508673ffffffffffffffffffffffffffffffffffffffff168873ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f4b2bfb33ad24dcef9319f290b974e50081def081b7a43561ade90d78d068514e86610140015160405161093f91815260200190565b60405180910390a450505050505b92915050565b606061094d82600161097c8173ffffffffffffffffffffffffffffffffffffffff84163b6110a2565b610b1d565b60606040519050825180825260208201818101602086015b818310156109b1578051835260209283019201610999565b50845184518101855292509050808201602085015b818310156109de5780518352602092830192016109c6565b50601f19601f87518501158301011660405250505092915050565b610a98604080516102008101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905260c0830182905260e0830182905283518085018552828152808201839052610100840152835180850190945281845283015290610120820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c09091015290565b50600061018083018190526101a08301526040805173ffffffffffffffffffffffffffffffffffffffff929092166020808401829052600384840152825180850384018152606094850184528051908201206101c08601528251808201929092526005828401528251808303840181529190930190915280519101206101e082015290565b60408051603f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168101909152818152818360208301863c9392505050565b60005b83811015610b79578181015183820152602001610b61565b50506000910152565b6020815260008251806020840152610ba1816040850160208701610b5e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b73ffffffffffffffffffffffffffffffffffffffff81168114610bf557600080fd5b50565b60008060408385031215610c0b57600080fd5b8235610c1681610bd3565b91506020830135610c2681610bd3565b809150509250929050565b6040516101c0810167ffffffffffffffff81118282101715610c7c577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405290565b8051610c8d81610bd3565b919050565b600060a08284031215610ca457600080fd5b60405160a0810181811067ffffffffffffffff82111715610cee577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b80604052508091508251610d0181610bd3565b81526020830151610d1181610bd3565b60208201526040830151610d2481610bd3565b60408201526060830151610d3781610bd3565b60608201526080830151610d4a81610bd3565b6080919091015292915050565b60006102408284031215610d6a57600080fd5b610d72610c31565b82518152610d8260208401610c82565b6020820152610d9360408401610c82565b6040820152610da58460608501610c92565b6060820152610100610db8818501610c82565b6080830152610120610dcb818601610c82565b60a0840152610140610dde818701610c82565b60c08501526101608087015160e086015261018080880151858701526101a0945084880151848701526101c0880151838701526101e088015182870152610200880151818701525050505061022084015181830152508091505092915050565b600060208284031215610e5057600080fd5b5051919050565b600060208284031215610e6957600080fd5b8151610e7481610bd3565b9392505050565b815173ffffffffffffffffffffffffffffffffffffffff16815261024081016020830151610ec1602084018273ffffffffffffffffffffffffffffffffffffffff169052565b506040830151610ee9604084018273ffffffffffffffffffffffffffffffffffffffff169052565b506060830151610f11606084018273ffffffffffffffffffffffffffffffffffffffff169052565b506080830151610f39608084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060a0830151610f6160a084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060c0830151610f8960c084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060e0830151610fb160e084018273ffffffffffffffffffffffffffffffffffffffff169052565b5061010083810151805173ffffffffffffffffffffffffffffffffffffffff90811685840152602082015116610120850152505061012083015161014061101d81850183805173ffffffffffffffffffffffffffffffffffffffff908116835260209182015116910152565b840151610180848101919091526101608501516101a080860191909152908501516101c080860191909152908501516101e080860191909152908501516102008501529093015161022090920191909152919050565b60008351611085818460208801610b5e565b835190830190611099818360208801610b5e565b01949350505050565b8181038181111561094d577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fdfea26469706673582212202ecbed70521904f71cd015ffe5b114390552ae05e140c5304dba9b877266354164736f6c63430008150033608060405234801561001057600080fd5b506040516104f43803806104f483398101604081905261002f9161007e565b600080546001600160a01b0319166001600160a01b03831690811782556040518392907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a350506100ae565b60006020828403121561009057600080fd5b81516001600160a01b03811681146100a757600080fd5b9392505050565b610437806100bd6000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063798133dd146100465780638da5cb5b14610082578063f2fde38b146100a2575b600080fd5b610059610054366004610352565b6100b7565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b6000546100599073ffffffffffffffffffffffffffffffffffffffff1681565b6100b56100b03660046103c4565b6101c7565b005b6000805473ffffffffffffffffffffffffffffffffffffffff16331461013e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f554e415554484f52495a4544000000000000000000000000000000000000000060448201526064015b60405180910390fd5b61017d83838080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506102b892505050565b60405190915073ffffffffffffffffffffffffffffffffffffffff8216907ff40020e78c6e173ba88aa2c344ed520fab87fe67b9e5aa34626af9d86a3cd47b90600090a292915050565b60005473ffffffffffffffffffffffffffffffffffffffff163314610248576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f554e415554484f52495a454400000000000000000000000000000000000000006044820152606401610135565b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081178255604051909133917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a350565b600081516000036102f5576040517f830297c900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8151602083016000f0905073ffffffffffffffffffffffffffffffffffffffff811661034d576040517f830297c900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b919050565b6000806020838503121561036557600080fd5b823567ffffffffffffffff8082111561037d57600080fd5b818501915085601f83011261039157600080fd5b8135818111156103a057600080fd5b8660208285010111156103b257600080fd5b60209290920196919550909350505050565b6000602082840312156103d657600080fd5b813573ffffffffffffffffffffffffffffffffffffffff811681146103fa57600080fd5b939250505056fea26469706673582212201bc75243187841bf004ccfd8c2e19e986902002ceb1c8c6119f0fb68cfeed79364736f6c63430008150033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100be5760003560e01c8063a07ddc1711610076578063c1b8411a1161005b578063c1b8411a146101bd578063cc025f7c146101e4578063cc2fe94b1461020b57600080fd5b8063a07ddc171461016f578063ba21b9c51461019657600080fd5b80636b171774116100a75780636b1717741461012d5780638cb1b071146101355780639f690ff11461015c57600080fd5b80630e09956a146100c35780632861c7d1146100e1575b600080fd5b6100cb610232565b6040516100d89190610b82565b60405180910390f35b6101087f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100d8565b6100cb610262565b6101087f000000000000000000000000000000000000000000000000000000000000000081565b6100cb61016a366004610bf8565b6102be565b6101087f000000000000000000000000000000000000000000000000000000000000000081565b6101087f000000000000000000000000000000000000000000000000000000000000000081565b6101087f000000000000000000000000000000000000000000000000000000000000000081565b6101087f000000000000000000000000000000000000000000000000000000000000000081565b6101087f000000000000000000000000000000000000000000000000000000000000000081565b606061025d7f0000000000000000000000000000000000000000000000000000000000000000610953565b905090565b606061025d6102907f0000000000000000000000000000000000000000000000000000000000000000610953565b6102b97f0000000000000000000000000000000000000000000000000000000000000000610953565b610981565b606073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610337576040517f60121cca000000000000000000000000000000000000000000000000000000008152617537600482015260240160405180910390fd5b60008373ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa158015610385573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a99190610d57565b905060008373ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa1580156103f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041d9190610d57565b90506104be604080516102008101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905260c0830182905260e0830182905283518085018552828152808201839052610100840152835180850190945281845283015290610120820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c09091015290565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000811682523060208084018290527f0000000000000000000000000000000000000000000000000000000000000000831660a0808601919091527f0000000000000000000000000000000000000000000000000000000000000000841660608601527f00000000000000000000000000000000000000000000000000000000000000008416608086015289841660c08087019190915287820151610100870180519187169091528882015190519086169084015289851660e08701529086015161012086018051918616909152908601519051931692810192909252604080517f8d65402300000000000000000000000000000000000000000000000000000000815290519192638d654023926004808401938290030181865afa15801561061f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106439190610e3e565b6101408201819052619c406101608301526040517fe6bd26a2000000000000000000000000000000000000000000000000000000008152600091309163e6bd26a2916106959160040190815260200190565b602060405180830381865afa1580156106b2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106d69190610e57565b90506106e282826109f9565b915061070d7f0000000000000000000000000000000000000000000000000000000000000000610953565b8260405160200161071e9190610e7b565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529082905261075a9291602001611073565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290527f798133dd000000000000000000000000000000000000000000000000000000008252955060009073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063798133dd906107fd908990600401610b82565b6020604051808303816000875af115801561081c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108409190610e57565b73ffffffffffffffffffffffffffffffffffffffff811660408501529050610866610262565b836040516020016108779190610e7b565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290526108b39291602001611073565b60405160208183030381529060405295508673ffffffffffffffffffffffffffffffffffffffff168873ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f4b2bfb33ad24dcef9319f290b974e50081def081b7a43561ade90d78d068514e86610140015160405161093f91815260200190565b60405180910390a450505050505b92915050565b606061094d82600161097c8173ffffffffffffffffffffffffffffffffffffffff84163b6110a2565b610b1d565b60606040519050825180825260208201818101602086015b818310156109b1578051835260209283019201610999565b50845184518101855292509050808201602085015b818310156109de5780518352602092830192016109c6565b50601f19601f87518501158301011660405250505092915050565b610a98604080516102008101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905260c0830182905260e0830182905283518085018552828152808201839052610100840152835180850190945281845283015290610120820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c09091015290565b50600061018083018190526101a08301526040805173ffffffffffffffffffffffffffffffffffffffff929092166020808401829052600384840152825180850384018152606094850184528051908201206101c08601528251808201929092526005828401528251808303840181529190930190915280519101206101e082015290565b60408051603f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168101909152818152818360208301863c9392505050565b60005b83811015610b79578181015183820152602001610b61565b50506000910152565b6020815260008251806020840152610ba1816040850160208701610b5e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b73ffffffffffffffffffffffffffffffffffffffff81168114610bf557600080fd5b50565b60008060408385031215610c0b57600080fd5b8235610c1681610bd3565b91506020830135610c2681610bd3565b809150509250929050565b6040516101c0810167ffffffffffffffff81118282101715610c7c577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405290565b8051610c8d81610bd3565b919050565b600060a08284031215610ca457600080fd5b60405160a0810181811067ffffffffffffffff82111715610cee577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b80604052508091508251610d0181610bd3565b81526020830151610d1181610bd3565b60208201526040830151610d2481610bd3565b60408201526060830151610d3781610bd3565b60608201526080830151610d4a81610bd3565b6080919091015292915050565b60006102408284031215610d6a57600080fd5b610d72610c31565b82518152610d8260208401610c82565b6020820152610d9360408401610c82565b6040820152610da58460608501610c92565b6060820152610100610db8818501610c82565b6080830152610120610dcb818601610c82565b60a0840152610140610dde818701610c82565b60c08501526101608087015160e086015261018080880151858701526101a0945084880151848701526101c0880151838701526101e088015182870152610200880151818701525050505061022084015181830152508091505092915050565b600060208284031215610e5057600080fd5b5051919050565b600060208284031215610e6957600080fd5b8151610e7481610bd3565b9392505050565b815173ffffffffffffffffffffffffffffffffffffffff16815261024081016020830151610ec1602084018273ffffffffffffffffffffffffffffffffffffffff169052565b506040830151610ee9604084018273ffffffffffffffffffffffffffffffffffffffff169052565b506060830151610f11606084018273ffffffffffffffffffffffffffffffffffffffff169052565b506080830151610f39608084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060a0830151610f6160a084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060c0830151610f8960c084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060e0830151610fb160e084018273ffffffffffffffffffffffffffffffffffffffff169052565b5061010083810151805173ffffffffffffffffffffffffffffffffffffffff90811685840152602082015116610120850152505061012083015161014061101d81850183805173ffffffffffffffffffffffffffffffffffffffff908116835260209182015116910152565b840151610180848101919091526101608501516101a080860191909152908501516101c080860191909152908501516101e080860191909152908501516102008501529093015161022090920191909152919050565b60008351611085818460208801610b5e565b835190830190611099818360208801610b5e565b01949350505050565b8181038181111561094d577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fdfea26469706673582212202ecbed70521904f71cd015ffe5b114390552ae05e140c5304dba9b877266354164736f6c63430008150033",
  "devdoc": {
    "events": {
      "VaultT4Deployed(address,uint256,address,address)": {
        "params": {
          "smartCol": "The address of the dex for which the smart collateral is used.",
          "smartDebt": "The address of the dex for which the smart debt is used.",
          "vault": "The address of the newly deployed vault.",
          "vaultId": "The id of the newly deployed vault."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "constructor": {
        "details": "each vault type has different vaultAdminImplementation but same vaultSecondaryImplementatio"
      },
      "operateCreationCode()": {
        "details": "Retrieves the creation code for the Operate contract"
      }
    },
    "stateVariables": {
      "VAULT_T4_CREATIONCODE_MAIN_ADDRESS_1": {
        "details": "SSTORE2 pointer for the VaultT4 creation code. Stored externally to reduce factory bytecode (in 2 parts)"
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "FluidLiquidateResult(uint256,uint256)": [
        {
          "notice": "used to simulate liquidation to find the maximum liquidatable amounts"
        }
      ]
    },
    "events": {
      "VaultT4Deployed(address,uint256,address,address)": {
        "notice": "Emitted when a new vaultT4 is deployed."
      }
    },
    "kind": "user",
    "methods": {
      "ADDRESS_THIS()": {
        "notice": "address of this contract"
      },
      "ADMIN_IMPLEMENTATION()": {
        "notice": "address of Admin implementation"
      },
      "LIQUIDITY()": {
        "notice": "address of liquidity contract"
      },
      "MINI_DEPLOYER()": {
        "notice": "address of MiniDeployer Contract"
      },
      "SECONDARY_IMPLEMENTATION()": {
        "notice": "address of Secondary implementation"
      },
      "mainCreationCode()": {
        "notice": "returns the stored DexT1 creation bytecode"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}