{
  "address": "0xD7d5113e0BF6f95856433C047317719C70df0BC9",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "factory_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "liquidityResolver_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "FACTORY",
      "outputs": [
        {
          "internalType": "contract IFluidVaultFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "LIQUIDITY_RESOLVER",
      "outputs": [
        {
          "internalType": "contract IFluidLiquidityResolver",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "slot_",
          "type": "uint256"
        },
        {
          "internalType": "int256",
          "name": "key1_",
          "type": "int256"
        },
        {
          "internalType": "uint256",
          "name": "key2_",
          "type": "uint256"
        }
      ],
      "name": "calculateDoubleIntUintMapping",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "slot_",
          "type": "uint256"
        },
        {
          "internalType": "int256",
          "name": "key_",
          "type": "int256"
        }
      ],
      "name": "calculateStorageSlotIntMapping",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "slot_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "key_",
          "type": "uint256"
        }
      ],
      "name": "calculateStorageSlotUintMapping",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getAbsorbedDustDebt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getAbsorbedLiquidityRaw",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllVaultsAddresses",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "vaults_",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllVaultsLiquidation",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token0In",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token0Out",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token1In",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token1Out",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "inAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "inAmtWithAbsorb",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmtWithAbsorb",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "absorbAvailable",
              "type": "bool"
            }
          ],
          "internalType": "struct Structs.LiquidationStruct[]",
          "name": "liquidationsData_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "branch_",
          "type": "uint256"
        }
      ],
      "name": "getBranchDataRaw",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "index_",
          "type": "uint256"
        }
      ],
      "name": "getContractForDeployerIndex",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getDexFromAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "vaults_",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "tokensInAmt_",
          "type": "uint256[]"
        }
      ],
      "name": "getMultipleVaultsLiquidation",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token0In",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token0Out",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token1In",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token1Out",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "inAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "inAmtWithAbsorb",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmtWithAbsorb",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "absorbAvailable",
              "type": "bool"
            }
          ],
          "internalType": "struct Structs.LiquidationStruct[]",
          "name": "liquidationsData_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "positionId_",
          "type": "uint256"
        }
      ],
      "name": "getPositionDataRaw",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getRateRaw",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getRebalancer",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        },
        {
          "internalType": "int256",
          "name": "tick_",
          "type": "int256"
        }
      ],
      "name": "getTickDataRaw",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        },
        {
          "internalType": "int256",
          "name": "key_",
          "type": "int256"
        }
      ],
      "name": "getTickHasDebtRaw",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        },
        {
          "internalType": "int256",
          "name": "tick_",
          "type": "int256"
        },
        {
          "internalType": "uint256",
          "name": "id_",
          "type": "uint256"
        }
      ],
      "name": "getTickIdDataRaw",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "nftId_",
          "type": "uint256"
        }
      ],
      "name": "getTokenConfig",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTotalVaults",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getVaultAbsorb",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "absorbAvailable",
              "type": "bool"
            }
          ],
          "internalType": "struct Structs.AbsorbStruct",
          "name": "absorbData_",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "vaultId_",
          "type": "uint256"
        }
      ],
      "name": "getVaultAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getVaultEntireData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "liquidity",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "factory",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "operateImplementation",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "adminImplementation",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "secondaryImplementation",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "deployer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "supply",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "borrow",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token0",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "token1",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct IFluidVault.Tokens",
                  "name": "supplyToken",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token0",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "token1",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct IFluidVault.Tokens",
                  "name": "borrowToken",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultType",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "supplyExchangePriceSlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "borrowExchangePriceSlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "userSupplySlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "userBorrowSlot",
                  "type": "bytes32"
                }
              ],
              "internalType": "struct IFluidVault.ConstantViews",
              "name": "constantVariables",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16",
                  "name": "supplyRateMagnifier",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "borrowRateMagnifier",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "collateralFactor",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationThreshold",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationMaxLimit",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "withdrawalGap",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationPenalty",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "borrowFee",
                  "type": "uint16"
                },
                {
                  "internalType": "address",
                  "name": "oracle",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "oraclePriceOperate",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "oraclePriceLiquidate",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "rebalancer",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "lastUpdateTimestamp",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.Configs",
              "name": "configs",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "lastStoredLiquiditySupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastStoredLiquidityBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastStoredVaultSupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastStoredVaultBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "liquiditySupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "liquidityBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultSupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "supplyRateLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowRateLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "supplyRateVault",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "borrowRateVault",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "rewardsOrFeeRateSupply",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "rewardsOrFeeRateBorrow",
                  "type": "int256"
                }
              ],
              "internalType": "struct Structs.ExchangePricesAndRates",
              "name": "exchangePricesAndRates",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "totalSupplyVault",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrowVault",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalSupplyLiquidityOrDex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrowLiquidityOrDex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "absorbedSupply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "absorbedBorrow",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.TotalSupplyAndBorrow",
              "name": "totalSupplyAndBorrow",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "withdrawLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawable",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowable",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimitUtilization",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "minimumBorrowing",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.LimitsAndAvailability",
              "name": "limitsAndAvailability",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "totalPositions",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "topTick",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "currentBranch",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBranch",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrow",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "status",
                      "type": "uint256"
                    },
                    {
                      "internalType": "int256",
                      "name": "minimaTick",
                      "type": "int256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "debtFactor",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "partials",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "debtLiquidity",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "baseBranchId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "int256",
                      "name": "baseBranchMinima",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct Structs.CurrentBranchState",
                  "name": "currentBranchState",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Structs.VaultState",
              "name": "vaultState",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "bool",
                  "name": "modeWithInterest",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "supply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawalLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastUpdateTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandPercent",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "baseWithdrawalLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawable",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.UserSupplyData",
              "name": "liquidityUserSupplyData",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "bool",
                  "name": "modeWithInterest",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "borrow",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastUpdateTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandPercent",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "baseBorrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxBorrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowable",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimitUtilization",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.UserBorrowData",
              "name": "liquidityUserBorrowData",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.VaultEntireData",
          "name": "vaultData_",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getVaultId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "id_",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenInAmt_",
          "type": "uint256"
        }
      ],
      "name": "getVaultLiquidation",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token0In",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token0Out",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token1In",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token1Out",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "inAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "inAmtWithAbsorb",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outAmtWithAbsorb",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "absorbAvailable",
              "type": "bool"
            }
          ],
          "internalType": "struct Structs.LiquidationStruct",
          "name": "liquidationData_",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getVaultState",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "totalPositions",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "topTick",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "currentBranch",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalBranch",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalBorrow",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalSupply",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "status",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "minimaTick",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "debtFactor",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "partials",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "debtLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "baseBranchId",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "baseBranchMinima",
                  "type": "int256"
                }
              ],
              "internalType": "struct Structs.CurrentBranchState",
              "name": "currentBranchState",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.VaultState",
          "name": "vaultState_",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getVaultType",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "vaultType_",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getVaultVariables2Raw",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getVaultVariablesRaw",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getVaultsAbsorb",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "absorbAvailable",
              "type": "bool"
            }
          ],
          "internalType": "struct Structs.AbsorbStruct[]",
          "name": "absorbData_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "vaults_",
          "type": "address[]"
        }
      ],
      "name": "getVaultsAbsorb",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "absorbAvailable",
              "type": "bool"
            }
          ],
          "internalType": "struct Structs.AbsorbStruct[]",
          "name": "absorbData_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "vaults_",
          "type": "address[]"
        }
      ],
      "name": "getVaultsEntireData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "liquidity",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "factory",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "operateImplementation",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "adminImplementation",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "secondaryImplementation",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "deployer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "supply",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "borrow",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token0",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "token1",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct IFluidVault.Tokens",
                  "name": "supplyToken",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token0",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "token1",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct IFluidVault.Tokens",
                  "name": "borrowToken",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultType",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "supplyExchangePriceSlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "borrowExchangePriceSlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "userSupplySlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "userBorrowSlot",
                  "type": "bytes32"
                }
              ],
              "internalType": "struct IFluidVault.ConstantViews",
              "name": "constantVariables",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16",
                  "name": "supplyRateMagnifier",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "borrowRateMagnifier",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "collateralFactor",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationThreshold",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationMaxLimit",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "withdrawalGap",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationPenalty",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "borrowFee",
                  "type": "uint16"
                },
                {
                  "internalType": "address",
                  "name": "oracle",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "oraclePriceOperate",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "oraclePriceLiquidate",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "rebalancer",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "lastUpdateTimestamp",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.Configs",
              "name": "configs",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "lastStoredLiquiditySupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastStoredLiquidityBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastStoredVaultSupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastStoredVaultBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "liquiditySupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "liquidityBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultSupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "supplyRateLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowRateLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "supplyRateVault",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "borrowRateVault",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "rewardsOrFeeRateSupply",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "rewardsOrFeeRateBorrow",
                  "type": "int256"
                }
              ],
              "internalType": "struct Structs.ExchangePricesAndRates",
              "name": "exchangePricesAndRates",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "totalSupplyVault",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrowVault",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalSupplyLiquidityOrDex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrowLiquidityOrDex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "absorbedSupply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "absorbedBorrow",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.TotalSupplyAndBorrow",
              "name": "totalSupplyAndBorrow",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "withdrawLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawable",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowable",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimitUtilization",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "minimumBorrowing",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.LimitsAndAvailability",
              "name": "limitsAndAvailability",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "totalPositions",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "topTick",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "currentBranch",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBranch",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrow",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "status",
                      "type": "uint256"
                    },
                    {
                      "internalType": "int256",
                      "name": "minimaTick",
                      "type": "int256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "debtFactor",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "partials",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "debtLiquidity",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "baseBranchId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "int256",
                      "name": "baseBranchMinima",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct Structs.CurrentBranchState",
                  "name": "currentBranchState",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Structs.VaultState",
              "name": "vaultState",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "bool",
                  "name": "modeWithInterest",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "supply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawalLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastUpdateTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandPercent",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "baseWithdrawalLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawable",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.UserSupplyData",
              "name": "liquidityUserSupplyData",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "bool",
                  "name": "modeWithInterest",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "borrow",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastUpdateTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandPercent",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "baseBorrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxBorrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowable",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimitUtilization",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.UserBorrowData",
              "name": "liquidityUserBorrowData",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.VaultEntireData[]",
          "name": "vaultsData_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getVaultsEntireData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "liquidity",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "factory",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "operateImplementation",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "adminImplementation",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "secondaryImplementation",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "deployer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "supply",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "borrow",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token0",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "token1",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct IFluidVault.Tokens",
                  "name": "supplyToken",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token0",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "token1",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct IFluidVault.Tokens",
                  "name": "borrowToken",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultType",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "supplyExchangePriceSlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "borrowExchangePriceSlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "userSupplySlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "userBorrowSlot",
                  "type": "bytes32"
                }
              ],
              "internalType": "struct IFluidVault.ConstantViews",
              "name": "constantVariables",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16",
                  "name": "supplyRateMagnifier",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "borrowRateMagnifier",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "collateralFactor",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationThreshold",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationMaxLimit",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "withdrawalGap",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationPenalty",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "borrowFee",
                  "type": "uint16"
                },
                {
                  "internalType": "address",
                  "name": "oracle",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "oraclePriceOperate",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "oraclePriceLiquidate",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "rebalancer",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "lastUpdateTimestamp",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.Configs",
              "name": "configs",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "lastStoredLiquiditySupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastStoredLiquidityBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastStoredVaultSupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastStoredVaultBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "liquiditySupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "liquidityBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultSupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "supplyRateLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowRateLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "supplyRateVault",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "borrowRateVault",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "rewardsOrFeeRateSupply",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "rewardsOrFeeRateBorrow",
                  "type": "int256"
                }
              ],
              "internalType": "struct Structs.ExchangePricesAndRates",
              "name": "exchangePricesAndRates",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "totalSupplyVault",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrowVault",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalSupplyLiquidityOrDex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrowLiquidityOrDex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "absorbedSupply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "absorbedBorrow",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.TotalSupplyAndBorrow",
              "name": "totalSupplyAndBorrow",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "withdrawLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawable",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowable",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimitUtilization",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "minimumBorrowing",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.LimitsAndAvailability",
              "name": "limitsAndAvailability",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "totalPositions",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "topTick",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "currentBranch",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBranch",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrow",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "status",
                      "type": "uint256"
                    },
                    {
                      "internalType": "int256",
                      "name": "minimaTick",
                      "type": "int256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "debtFactor",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "partials",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "debtLiquidity",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "baseBranchId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "int256",
                      "name": "baseBranchMinima",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct Structs.CurrentBranchState",
                  "name": "currentBranchState",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Structs.VaultState",
              "name": "vaultState",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "bool",
                  "name": "modeWithInterest",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "supply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawalLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastUpdateTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandPercent",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "baseWithdrawalLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawable",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.UserSupplyData",
              "name": "liquidityUserSupplyData",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "bool",
                  "name": "modeWithInterest",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "borrow",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastUpdateTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandPercent",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "baseBorrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxBorrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowable",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimitUtilization",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.UserBorrowData",
              "name": "liquidityUserBorrowData",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.VaultEntireData[]",
          "name": "vaultsData_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "slot_",
          "type": "uint256"
        }
      ],
      "name": "normalSlot",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "nftId_",
          "type": "uint256"
        }
      ],
      "name": "positionByNftId",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nftId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "isLiquidated",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isSupplyPosition",
              "type": "bool"
            },
            {
              "internalType": "int256",
              "name": "tick",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "tickId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "beforeSupply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "beforeBorrow",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "beforeDustBorrow",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "supply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrow",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "dustBorrow",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.UserPosition",
          "name": "userPosition_",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "liquidity",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "factory",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "operateImplementation",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "adminImplementation",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "secondaryImplementation",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "deployer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "supply",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "borrow",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token0",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "token1",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct IFluidVault.Tokens",
                  "name": "supplyToken",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token0",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "token1",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct IFluidVault.Tokens",
                  "name": "borrowToken",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultType",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "supplyExchangePriceSlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "borrowExchangePriceSlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "userSupplySlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "userBorrowSlot",
                  "type": "bytes32"
                }
              ],
              "internalType": "struct IFluidVault.ConstantViews",
              "name": "constantVariables",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16",
                  "name": "supplyRateMagnifier",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "borrowRateMagnifier",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "collateralFactor",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationThreshold",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationMaxLimit",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "withdrawalGap",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationPenalty",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "borrowFee",
                  "type": "uint16"
                },
                {
                  "internalType": "address",
                  "name": "oracle",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "oraclePriceOperate",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "oraclePriceLiquidate",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "rebalancer",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "lastUpdateTimestamp",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.Configs",
              "name": "configs",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "lastStoredLiquiditySupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastStoredLiquidityBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastStoredVaultSupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastStoredVaultBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "liquiditySupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "liquidityBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultSupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "supplyRateLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowRateLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "supplyRateVault",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "borrowRateVault",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "rewardsOrFeeRateSupply",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "rewardsOrFeeRateBorrow",
                  "type": "int256"
                }
              ],
              "internalType": "struct Structs.ExchangePricesAndRates",
              "name": "exchangePricesAndRates",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "totalSupplyVault",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrowVault",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalSupplyLiquidityOrDex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrowLiquidityOrDex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "absorbedSupply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "absorbedBorrow",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.TotalSupplyAndBorrow",
              "name": "totalSupplyAndBorrow",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "withdrawLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawable",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowable",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimitUtilization",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "minimumBorrowing",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.LimitsAndAvailability",
              "name": "limitsAndAvailability",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "totalPositions",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "topTick",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "currentBranch",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBranch",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrow",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "status",
                      "type": "uint256"
                    },
                    {
                      "internalType": "int256",
                      "name": "minimaTick",
                      "type": "int256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "debtFactor",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "partials",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "debtLiquidity",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "baseBranchId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "int256",
                      "name": "baseBranchMinima",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct Structs.CurrentBranchState",
                  "name": "currentBranchState",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Structs.VaultState",
              "name": "vaultState",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "bool",
                  "name": "modeWithInterest",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "supply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawalLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastUpdateTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandPercent",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "baseWithdrawalLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawable",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.UserSupplyData",
              "name": "liquidityUserSupplyData",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "bool",
                  "name": "modeWithInterest",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "borrow",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastUpdateTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandPercent",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "baseBorrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxBorrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowable",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimitUtilization",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.UserBorrowData",
              "name": "liquidityUserBorrowData",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.VaultEntireData",
          "name": "vaultData_",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user_",
          "type": "address"
        }
      ],
      "name": "positionsByUser",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nftId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "isLiquidated",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isSupplyPosition",
              "type": "bool"
            },
            {
              "internalType": "int256",
              "name": "tick",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "tickId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "beforeSupply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "beforeBorrow",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "beforeDustBorrow",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "supply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrow",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "dustBorrow",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.UserPosition[]",
          "name": "userPositions_",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "liquidity",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "factory",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "operateImplementation",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "adminImplementation",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "secondaryImplementation",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "deployer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "supply",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "borrow",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token0",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "token1",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct IFluidVault.Tokens",
                  "name": "supplyToken",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token0",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "token1",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct IFluidVault.Tokens",
                  "name": "borrowToken",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultType",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "supplyExchangePriceSlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "borrowExchangePriceSlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "userSupplySlot",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "userBorrowSlot",
                  "type": "bytes32"
                }
              ],
              "internalType": "struct IFluidVault.ConstantViews",
              "name": "constantVariables",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16",
                  "name": "supplyRateMagnifier",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "borrowRateMagnifier",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "collateralFactor",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationThreshold",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationMaxLimit",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "withdrawalGap",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationPenalty",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "borrowFee",
                  "type": "uint16"
                },
                {
                  "internalType": "address",
                  "name": "oracle",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "oraclePriceOperate",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "oraclePriceLiquidate",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "rebalancer",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "lastUpdateTimestamp",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.Configs",
              "name": "configs",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "lastStoredLiquiditySupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastStoredLiquidityBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastStoredVaultSupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastStoredVaultBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "liquiditySupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "liquidityBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultSupplyExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultBorrowExchangePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "supplyRateLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowRateLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "supplyRateVault",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "borrowRateVault",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "rewardsOrFeeRateSupply",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "rewardsOrFeeRateBorrow",
                  "type": "int256"
                }
              ],
              "internalType": "struct Structs.ExchangePricesAndRates",
              "name": "exchangePricesAndRates",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "totalSupplyVault",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrowVault",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalSupplyLiquidityOrDex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrowLiquidityOrDex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "absorbedSupply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "absorbedBorrow",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.TotalSupplyAndBorrow",
              "name": "totalSupplyAndBorrow",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "withdrawLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawable",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowable",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimitUtilization",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "minimumBorrowing",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.LimitsAndAvailability",
              "name": "limitsAndAvailability",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "totalPositions",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "topTick",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "currentBranch",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBranch",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrow",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "status",
                      "type": "uint256"
                    },
                    {
                      "internalType": "int256",
                      "name": "minimaTick",
                      "type": "int256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "debtFactor",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "partials",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "debtLiquidity",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "baseBranchId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "int256",
                      "name": "baseBranchMinima",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct Structs.CurrentBranchState",
                  "name": "currentBranchState",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Structs.VaultState",
              "name": "vaultState",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "bool",
                  "name": "modeWithInterest",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "supply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawalLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastUpdateTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandPercent",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "baseWithdrawalLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawable",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.UserSupplyData",
              "name": "liquidityUserSupplyData",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "bool",
                  "name": "modeWithInterest",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "borrow",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lastUpdateTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandPercent",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expandDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "baseBorrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxBorrowLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowableUntilLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowable",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowLimitUtilization",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Structs.UserBorrowData",
              "name": "liquidityUserBorrowData",
              "type": "tuple"
            }
          ],
          "internalType": "struct Structs.VaultEntireData[]",
          "name": "vaultsData_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user_",
          "type": "address"
        }
      ],
      "name": "positionsNftIdOfUser",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "nftIds_",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tickRaw_",
          "type": "uint256"
        }
      ],
      "name": "tickHelper",
      "outputs": [
        {
          "internalType": "int256",
          "name": "tick",
          "type": "int256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalPositions",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "nftId_",
          "type": "uint256"
        }
      ],
      "name": "vaultByNftId",
      "outputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xda276a6ec0ed6b77ac83fb17cf3ace778d6de1cfefcf446bce8ceb03d3f5eb68",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x0Ed35B1609Ec45c7079E80d11149a52717e4859A",
    "contractAddress": null,
    "transactionIndex": 179,
    "gasUsed": "5346957",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x96ea8fdb645dc277aea3c9eaf7b35f0c2d815a456be177d4448425032e78e60f",
    "transactionHash": "0xda276a6ec0ed6b77ac83fb17cf3ace778d6de1cfefcf446bce8ceb03d3f5eb68",
    "logs": [],
    "blockNumber": 20994860,
    "cumulativeGasUsed": "19894244",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x324c5Dc1fC42c7a4D43d92df1eBA58a54d13Bf2d",
    "0xF82111c4354622AB12b9803cD3F6164FCE52e847"
  ],
  "numDeployments": 9,
  "solcInputHash": "546e9219ba85bff1bae359d2168693a3",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityResolver_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"contract IFluidVaultFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY_RESOLVER\",\"outputs\":[{\"internalType\":\"contract IFluidLiquidityResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slot_\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"key1_\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"key2_\",\"type\":\"uint256\"}],\"name\":\"calculateDoubleIntUintMapping\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slot_\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"key_\",\"type\":\"int256\"}],\"name\":\"calculateStorageSlotIntMapping\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slot_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"key_\",\"type\":\"uint256\"}],\"name\":\"calculateStorageSlotUintMapping\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getAbsorbedDustDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getAbsorbedLiquidityRaw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllVaultsAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"vaults_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllVaultsLiquidation\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0In\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0Out\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1In\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1Out\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inAmtWithAbsorb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmtWithAbsorb\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"absorbAvailable\",\"type\":\"bool\"}],\"internalType\":\"struct Structs.LiquidationStruct[]\",\"name\":\"liquidationsData_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"branch_\",\"type\":\"uint256\"}],\"name\":\"getBranchDataRaw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"}],\"name\":\"getContractForDeployerIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getDexFromAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaults_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokensInAmt_\",\"type\":\"uint256[]\"}],\"name\":\"getMultipleVaultsLiquidation\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0In\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0Out\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1In\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1Out\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inAmtWithAbsorb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmtWithAbsorb\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"absorbAvailable\",\"type\":\"bool\"}],\"internalType\":\"struct Structs.LiquidationStruct[]\",\"name\":\"liquidationsData_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"positionId_\",\"type\":\"uint256\"}],\"name\":\"getPositionDataRaw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getRateRaw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getRebalancer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"tick_\",\"type\":\"int256\"}],\"name\":\"getTickDataRaw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"key_\",\"type\":\"int256\"}],\"name\":\"getTickHasDebtRaw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"tick_\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"getTickIdDataRaw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getTokenConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalVaults\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getVaultAbsorb\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"absorbAvailable\",\"type\":\"bool\"}],\"internalType\":\"struct Structs.AbsorbStruct\",\"name\":\"absorbData_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId_\",\"type\":\"uint256\"}],\"name\":\"getVaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getVaultEntireData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"liquidity\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operateImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"adminImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"secondaryImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"supply\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrow\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct IFluidVault.Tokens\",\"name\":\"supplyToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct IFluidVault.Tokens\",\"name\":\"borrowToken\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultType\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"supplyExchangePriceSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"borrowExchangePriceSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"userSupplySlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"userBorrowSlot\",\"type\":\"bytes32\"}],\"internalType\":\"struct IFluidVault.ConstantViews\",\"name\":\"constantVariables\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"supplyRateMagnifier\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"borrowRateMagnifier\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"collateralFactor\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationThreshold\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationMaxLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"withdrawalGap\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationPenalty\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"borrowFee\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oraclePriceOperate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oraclePriceLiquidate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rebalancer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.Configs\",\"name\":\"configs\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lastStoredLiquiditySupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredLiquidityBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredVaultSupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredVaultBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquiditySupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultSupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyRateLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"supplyRateVault\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"borrowRateVault\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rewardsOrFeeRateSupply\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rewardsOrFeeRateBorrow\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.ExchangePricesAndRates\",\"name\":\"exchangePricesAndRates\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalSupplyVault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowVault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupplyLiquidityOrDex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowLiquidityOrDex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"absorbedSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"absorbedBorrow\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TotalSupplyAndBorrow\",\"name\":\"totalSupplyAndBorrow\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"withdrawLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitUtilization\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumBorrowing\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.LimitsAndAvailability\",\"name\":\"limitsAndAvailability\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalPositions\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"topTick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"currentBranch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBranch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"minimaTick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"debtFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBranchId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"baseBranchMinima\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.CurrentBranchState\",\"name\":\"currentBranchState\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.VaultState\",\"name\":\"vaultState\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"modeWithInterest\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseWithdrawalLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserSupplyData\",\"name\":\"liquidityUserSupplyData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"modeWithInterest\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"borrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBorrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBorrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitUtilization\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserBorrowData\",\"name\":\"liquidityUserBorrowData\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.VaultEntireData\",\"name\":\"vaultData_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getVaultId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenInAmt_\",\"type\":\"uint256\"}],\"name\":\"getVaultLiquidation\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0In\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0Out\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1In\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1Out\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inAmtWithAbsorb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmtWithAbsorb\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"absorbAvailable\",\"type\":\"bool\"}],\"internalType\":\"struct Structs.LiquidationStruct\",\"name\":\"liquidationData_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getVaultState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalPositions\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"topTick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"currentBranch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBranch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"minimaTick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"debtFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBranchId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"baseBranchMinima\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.CurrentBranchState\",\"name\":\"currentBranchState\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.VaultState\",\"name\":\"vaultState_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getVaultType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultType_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getVaultVariables2Raw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getVaultVariablesRaw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultsAbsorb\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"absorbAvailable\",\"type\":\"bool\"}],\"internalType\":\"struct Structs.AbsorbStruct[]\",\"name\":\"absorbData_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaults_\",\"type\":\"address[]\"}],\"name\":\"getVaultsAbsorb\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"absorbAvailable\",\"type\":\"bool\"}],\"internalType\":\"struct Structs.AbsorbStruct[]\",\"name\":\"absorbData_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaults_\",\"type\":\"address[]\"}],\"name\":\"getVaultsEntireData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"liquidity\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operateImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"adminImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"secondaryImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"supply\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrow\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct IFluidVault.Tokens\",\"name\":\"supplyToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct IFluidVault.Tokens\",\"name\":\"borrowToken\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultType\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"supplyExchangePriceSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"borrowExchangePriceSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"userSupplySlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"userBorrowSlot\",\"type\":\"bytes32\"}],\"internalType\":\"struct IFluidVault.ConstantViews\",\"name\":\"constantVariables\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"supplyRateMagnifier\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"borrowRateMagnifier\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"collateralFactor\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationThreshold\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationMaxLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"withdrawalGap\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationPenalty\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"borrowFee\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oraclePriceOperate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oraclePriceLiquidate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rebalancer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.Configs\",\"name\":\"configs\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lastStoredLiquiditySupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredLiquidityBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredVaultSupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredVaultBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquiditySupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultSupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyRateLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"supplyRateVault\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"borrowRateVault\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rewardsOrFeeRateSupply\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rewardsOrFeeRateBorrow\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.ExchangePricesAndRates\",\"name\":\"exchangePricesAndRates\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalSupplyVault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowVault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupplyLiquidityOrDex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowLiquidityOrDex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"absorbedSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"absorbedBorrow\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TotalSupplyAndBorrow\",\"name\":\"totalSupplyAndBorrow\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"withdrawLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitUtilization\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumBorrowing\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.LimitsAndAvailability\",\"name\":\"limitsAndAvailability\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalPositions\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"topTick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"currentBranch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBranch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"minimaTick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"debtFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBranchId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"baseBranchMinima\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.CurrentBranchState\",\"name\":\"currentBranchState\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.VaultState\",\"name\":\"vaultState\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"modeWithInterest\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseWithdrawalLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserSupplyData\",\"name\":\"liquidityUserSupplyData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"modeWithInterest\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"borrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBorrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBorrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitUtilization\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserBorrowData\",\"name\":\"liquidityUserBorrowData\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.VaultEntireData[]\",\"name\":\"vaultsData_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultsEntireData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"liquidity\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operateImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"adminImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"secondaryImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"supply\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrow\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct IFluidVault.Tokens\",\"name\":\"supplyToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct IFluidVault.Tokens\",\"name\":\"borrowToken\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultType\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"supplyExchangePriceSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"borrowExchangePriceSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"userSupplySlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"userBorrowSlot\",\"type\":\"bytes32\"}],\"internalType\":\"struct IFluidVault.ConstantViews\",\"name\":\"constantVariables\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"supplyRateMagnifier\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"borrowRateMagnifier\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"collateralFactor\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationThreshold\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationMaxLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"withdrawalGap\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationPenalty\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"borrowFee\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oraclePriceOperate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oraclePriceLiquidate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rebalancer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.Configs\",\"name\":\"configs\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lastStoredLiquiditySupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredLiquidityBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredVaultSupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredVaultBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquiditySupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultSupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyRateLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"supplyRateVault\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"borrowRateVault\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rewardsOrFeeRateSupply\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rewardsOrFeeRateBorrow\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.ExchangePricesAndRates\",\"name\":\"exchangePricesAndRates\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalSupplyVault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowVault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupplyLiquidityOrDex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowLiquidityOrDex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"absorbedSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"absorbedBorrow\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TotalSupplyAndBorrow\",\"name\":\"totalSupplyAndBorrow\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"withdrawLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitUtilization\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumBorrowing\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.LimitsAndAvailability\",\"name\":\"limitsAndAvailability\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalPositions\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"topTick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"currentBranch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBranch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"minimaTick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"debtFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBranchId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"baseBranchMinima\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.CurrentBranchState\",\"name\":\"currentBranchState\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.VaultState\",\"name\":\"vaultState\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"modeWithInterest\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseWithdrawalLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserSupplyData\",\"name\":\"liquidityUserSupplyData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"modeWithInterest\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"borrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBorrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBorrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitUtilization\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserBorrowData\",\"name\":\"liquidityUserBorrowData\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.VaultEntireData[]\",\"name\":\"vaultsData_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slot_\",\"type\":\"uint256\"}],\"name\":\"normalSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"positionByNftId\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLiquidated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSupplyPosition\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"tick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"tickId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beforeSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beforeBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beforeDustBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dustBorrow\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserPosition\",\"name\":\"userPosition_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"liquidity\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operateImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"adminImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"secondaryImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"supply\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrow\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct IFluidVault.Tokens\",\"name\":\"supplyToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct IFluidVault.Tokens\",\"name\":\"borrowToken\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultType\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"supplyExchangePriceSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"borrowExchangePriceSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"userSupplySlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"userBorrowSlot\",\"type\":\"bytes32\"}],\"internalType\":\"struct IFluidVault.ConstantViews\",\"name\":\"constantVariables\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"supplyRateMagnifier\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"borrowRateMagnifier\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"collateralFactor\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationThreshold\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationMaxLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"withdrawalGap\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationPenalty\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"borrowFee\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oraclePriceOperate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oraclePriceLiquidate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rebalancer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.Configs\",\"name\":\"configs\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lastStoredLiquiditySupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredLiquidityBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredVaultSupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredVaultBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquiditySupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultSupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyRateLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"supplyRateVault\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"borrowRateVault\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rewardsOrFeeRateSupply\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rewardsOrFeeRateBorrow\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.ExchangePricesAndRates\",\"name\":\"exchangePricesAndRates\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalSupplyVault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowVault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupplyLiquidityOrDex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowLiquidityOrDex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"absorbedSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"absorbedBorrow\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TotalSupplyAndBorrow\",\"name\":\"totalSupplyAndBorrow\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"withdrawLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitUtilization\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumBorrowing\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.LimitsAndAvailability\",\"name\":\"limitsAndAvailability\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalPositions\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"topTick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"currentBranch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBranch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"minimaTick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"debtFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBranchId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"baseBranchMinima\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.CurrentBranchState\",\"name\":\"currentBranchState\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.VaultState\",\"name\":\"vaultState\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"modeWithInterest\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseWithdrawalLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserSupplyData\",\"name\":\"liquidityUserSupplyData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"modeWithInterest\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"borrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBorrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBorrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitUtilization\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserBorrowData\",\"name\":\"liquidityUserBorrowData\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.VaultEntireData\",\"name\":\"vaultData_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"positionsByUser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLiquidated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSupplyPosition\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"tick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"tickId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beforeSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beforeBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beforeDustBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dustBorrow\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserPosition[]\",\"name\":\"userPositions_\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"liquidity\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operateImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"adminImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"secondaryImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"supply\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrow\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct IFluidVault.Tokens\",\"name\":\"supplyToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct IFluidVault.Tokens\",\"name\":\"borrowToken\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultType\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"supplyExchangePriceSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"borrowExchangePriceSlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"userSupplySlot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"userBorrowSlot\",\"type\":\"bytes32\"}],\"internalType\":\"struct IFluidVault.ConstantViews\",\"name\":\"constantVariables\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"supplyRateMagnifier\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"borrowRateMagnifier\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"collateralFactor\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationThreshold\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationMaxLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"withdrawalGap\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationPenalty\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"borrowFee\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oraclePriceOperate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oraclePriceLiquidate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rebalancer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.Configs\",\"name\":\"configs\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lastStoredLiquiditySupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredLiquidityBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredVaultSupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredVaultBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquiditySupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultSupplyExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultBorrowExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyRateLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"supplyRateVault\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"borrowRateVault\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rewardsOrFeeRateSupply\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"rewardsOrFeeRateBorrow\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.ExchangePricesAndRates\",\"name\":\"exchangePricesAndRates\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalSupplyVault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowVault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupplyLiquidityOrDex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowLiquidityOrDex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"absorbedSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"absorbedBorrow\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.TotalSupplyAndBorrow\",\"name\":\"totalSupplyAndBorrow\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"withdrawLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitUtilization\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumBorrowing\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.LimitsAndAvailability\",\"name\":\"limitsAndAvailability\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalPositions\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"topTick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"currentBranch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBranch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"minimaTick\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"debtFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBranchId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"baseBranchMinima\",\"type\":\"int256\"}],\"internalType\":\"struct Structs.CurrentBranchState\",\"name\":\"currentBranchState\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.VaultState\",\"name\":\"vaultState\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"modeWithInterest\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseWithdrawalLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserSupplyData\",\"name\":\"liquidityUserSupplyData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"modeWithInterest\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"borrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expandDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBorrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBorrowLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowableUntilLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitUtilization\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.UserBorrowData\",\"name\":\"liquidityUserBorrowData\",\"type\":\"tuple\"}],\"internalType\":\"struct Structs.VaultEntireData[]\",\"name\":\"vaultsData_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"positionsNftIdOfUser\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tickRaw_\",\"type\":\"uint256\"}],\"name\":\"tickHelper\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"tick\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPositions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"vaultByNftId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getAbsorbedDustDebt(address)\":{\"params\":{\"vault_\":\"The address of the vault.\"},\"returns\":{\"_0\":\"The absorbed dust debt of the vault.\"}},\"getAbsorbedLiquidityRaw(address)\":{\"params\":{\"vault_\":\"The address of the vault.\"},\"returns\":{\"_0\":\"The absorbed liquidity of the vault.\"}},\"getAllVaultsAddresses()\":{\"returns\":{\"vaults_\":\"The addresses of all the vaults.\"}},\"getAllVaultsLiquidation()\":{\"returns\":{\"liquidationsData_\":\"An array of LiquidationStruct containing the liquidation data for all vaults.\"}},\"getBranchDataRaw(address,uint256)\":{\"params\":{\"branch_\":\"The branch value.\",\"vault_\":\"The address of the vault.\"},\"returns\":{\"_0\":\"The raw branch data of the vault.\"}},\"getContractForDeployerIndex(address,uint256)\":{\"params\":{\"index_\":\"The index of the deployer.\",\"vault_\":\"The address of the vault.\"},\"returns\":{\"_0\":\"The contract for deployer index of the vault.\"}},\"getDexFromAddress(address)\":{\"params\":{\"vault_\":\"The address of the vault.\"},\"returns\":{\"_0\":\"The DEX from address of the vault.\"}},\"getMultipleVaultsLiquidation(address[],uint256[])\":{\"params\":{\"tokensInAmt_\":\"The array of token amounts to liquidate.\",\"vaults_\":\"The array of vault addresses.\"},\"returns\":{\"liquidationsData_\":\"An array of LiquidationStruct containing the liquidation data for each vault.\"}},\"getPositionDataRaw(address,uint256)\":{\"params\":{\"positionId_\":\"The ID of the position.\",\"vault_\":\"The address of the vault.\"},\"returns\":{\"_0\":\"The position data of the vault.\"}},\"getRateRaw(address)\":{\"params\":{\"vault_\":\"The address of the vault.\"},\"returns\":{\"_0\":\"The raw rate of the vault.\"}},\"getRebalancer(address)\":{\"params\":{\"vault_\":\"The address of the vault.\"},\"returns\":{\"_0\":\"The rebalancer of the vault.\"}},\"getTickDataRaw(address,int256)\":{\"params\":{\"tick_\":\"The tick value.\",\"vault_\":\"The address of the vault.\"},\"returns\":{\"_0\":\"The raw tick data of the vault.\"}},\"getTickHasDebtRaw(address,int256)\":{\"params\":{\"key_\":\"The tick key.\",\"vault_\":\"The address of the vault.\"},\"returns\":{\"_0\":\"The raw tick data of the vault.\"}},\"getTickIdDataRaw(address,int256,uint256)\":{\"params\":{\"id_\":\"The ID of the tick.\",\"tick_\":\"The tick value.\",\"vault_\":\"The address of the vault.\"},\"returns\":{\"_0\":\"The raw tick data of the vault.\"}},\"getTokenConfig(uint256)\":{\"params\":{\"nftId_\":\"The ID of the NFT.\"},\"returns\":{\"_0\":\"The token configuration.\"}},\"getTotalVaults()\":{\"returns\":{\"_0\":\"The total number of vaults.\"}},\"getVaultAbsorb(address)\":{\"params\":{\"vault_\":\"The address of the vault.\"},\"returns\":{\"absorbData_\":\"The AbsorbStruct containing the absorb data for the vault.\"}},\"getVaultAddress(uint256)\":{\"params\":{\"vaultId_\":\"The ID of the vault.\"},\"returns\":{\"vault_\":\"The address of the vault.\"}},\"getVaultEntireData(address)\":{\"params\":{\"vault_\":\"The address of the vault to retrieve the data for.\"},\"returns\":{\"vaultData_\":\"The entire data of the vault.\"}},\"getVaultId(address)\":{\"params\":{\"vault_\":\"The address of the vault.\"},\"returns\":{\"id_\":\"The ID of the vault.\"}},\"getVaultLiquidation(address,uint256)\":{\"params\":{\"tokenInAmt_\":\"token in aka debt to payback, leave 0 to get max\",\"vault_\":\"address of vault for which to fetch\"},\"returns\":{\"liquidationData_\":\"liquidation related data. Check out structs.sol\"}},\"getVaultState(address)\":{\"params\":{\"vault_\":\"The address of the vault to retrieve the state for.\"},\"returns\":{\"vaultState_\":\"The state of the vault, including top tick, current and total branches,                     total supply and borrow, total positions, and current branch state.\"}},\"getVaultType(address)\":{\"params\":{\"vault_\":\"The address of the vault.\"},\"returns\":{\"vaultType_\":\"The type of the vault. 0 if not a Fluid vault.\"}},\"getVaultVariables2Raw(address)\":{\"params\":{\"vault_\":\"The address of the vault.\"},\"returns\":{\"_0\":\"The raw variables of the vault.\"}},\"getVaultVariablesRaw(address)\":{\"params\":{\"vault_\":\"The address of the vault.\"},\"returns\":{\"_0\":\"The raw variables of the vault.\"}},\"getVaultsAbsorb()\":{\"returns\":{\"absorbData_\":\"An array of AbsorbStruct containing the absorb data for all vaults.\"}},\"getVaultsAbsorb(address[])\":{\"params\":{\"vaults_\":\"The array of vault addresses.\"},\"returns\":{\"absorbData_\":\"An array of AbsorbStruct containing the absorb data for each vault.\"}},\"getVaultsEntireData()\":{\"returns\":{\"vaultsData_\":\"An array of VaultEntireData structures containing the data for each vault.\"}},\"getVaultsEntireData(address[])\":{\"params\":{\"vaults_\":\"The list of vault addresses.\"},\"returns\":{\"vaultsData_\":\"An array of VaultEntireData structures containing the data for each vault.\"}},\"positionByNftId(uint256)\":{\"params\":{\"nftId_\":\"The NFT ID for which to retrieve the position data.\"},\"returns\":{\"userPosition_\":\"The UserPosition structure containing the position data.\",\"vaultData_\":\"The VaultEntireData structure containing the vault data.\"}},\"positionsByUser(address)\":{\"params\":{\"user_\":\"The address of the user for whom to fetch positions and vault data.\"},\"returns\":{\"userPositions_\":\"An array of UserPosition structs representing the user's positions.\",\"vaultsData_\":\"An array of VaultEntireData structs representing the vault data for each position.\"}},\"positionsNftIdOfUser(address)\":{\"params\":{\"user_\":\"The address of the user for whom to fetch positions.\"},\"returns\":{\"nftIds_\":\"An array of NFT IDs representing the user's positions.\"}},\"totalPositions()\":{\"returns\":{\"_0\":\"The total number of positions.\"}},\"vaultByNftId(uint256)\":{\"params\":{\"nftId_\":\"The NFT ID for which to fetch the vault address.\"},\"returns\":{\"vault_\":\"The address of the vault associated with the NFT ID.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"calculateDoubleIntUintMapping(uint256,int256,uint256)\":{\"notice\":\"Calculating the slot ID for Liquidity contract for double mapping\"},\"calculateStorageSlotIntMapping(uint256,int256)\":{\"notice\":\"Calculating the slot ID for Liquidity contract for single mapping\"},\"calculateStorageSlotUintMapping(uint256,uint256)\":{\"notice\":\"Calculating the slot ID for Liquidity contract for single mapping\"},\"getAbsorbedDustDebt(address)\":{\"notice\":\"Get the absorbed dust debt of a vault.\"},\"getAbsorbedLiquidityRaw(address)\":{\"notice\":\"Get the absorbed liquidity of a vault.\"},\"getAllVaultsAddresses()\":{\"notice\":\"Get the addresses of all the vaults.\"},\"getAllVaultsLiquidation()\":{\"notice\":\"Retrieves liquidation data for all vaults.\"},\"getBranchDataRaw(address,uint256)\":{\"notice\":\"Get the raw branch data of a vault.\"},\"getContractForDeployerIndex(address,uint256)\":{\"notice\":\"Get the contract for deployer index of a vault.\"},\"getDexFromAddress(address)\":{\"notice\":\"Get the DEX from address of a vault.\"},\"getMultipleVaultsLiquidation(address[],uint256[])\":{\"notice\":\"Retrieves liquidation data for multiple vaults.\"},\"getPositionDataRaw(address,uint256)\":{\"notice\":\"Get the position data of a vault.\"},\"getRateRaw(address)\":{\"notice\":\"Get the raw rate of a vault.\"},\"getRebalancer(address)\":{\"notice\":\"Get the rebalancer of a vault.\"},\"getTickDataRaw(address,int256)\":{\"notice\":\"Get the raw tick data of a vault.\"},\"getTickHasDebtRaw(address,int256)\":{\"notice\":\"Get the raw tick data of a vault.\"},\"getTickIdDataRaw(address,int256,uint256)\":{\"notice\":\"Get the raw tick data of a vault.\"},\"getTokenConfig(uint256)\":{\"notice\":\"Get the token configuration.\"},\"getTotalVaults()\":{\"notice\":\"Get the total number of vaults.\"},\"getVaultAbsorb(address)\":{\"notice\":\"DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for a single vault.\"},\"getVaultAddress(uint256)\":{\"notice\":\"Get the address of a vault.\"},\"getVaultEntireData(address)\":{\"notice\":\"Retrieves the entire data for a given vault.\"},\"getVaultId(address)\":{\"notice\":\"Get the ID of a vault.\"},\"getVaultLiquidation(address,uint256)\":{\"notice\":\"fetches available liquidations\"},\"getVaultState(address)\":{\"notice\":\"Retrieves the state of a given vault.\"},\"getVaultType(address)\":{\"notice\":\"Get the type of a vault.\"},\"getVaultVariables2Raw(address)\":{\"notice\":\"Get the raw variables of a vault.\"},\"getVaultVariablesRaw(address)\":{\"notice\":\"Get the raw variables of a vault.\"},\"getVaultsAbsorb()\":{\"notice\":\"DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for all vaults.\"},\"getVaultsAbsorb(address[])\":{\"notice\":\"DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for multiple vaults.\"},\"getVaultsEntireData()\":{\"notice\":\"Retrieves the entire data for all vaults.\"},\"getVaultsEntireData(address[])\":{\"notice\":\"Retrieves the entire data for a list of vaults.\"},\"positionByNftId(uint256)\":{\"notice\":\"Retrieves the position data for a given NFT ID and the corresponding vault data.\"},\"positionsByUser(address)\":{\"notice\":\"Fetches all positions and their corresponding vault data for a given user.\"},\"positionsNftIdOfUser(address)\":{\"notice\":\"Returns an array of NFT IDs for all positions of a given user.\"},\"totalPositions()\":{\"notice\":\"Returns the total number of positions across all users.\"},\"vaultByNftId(uint256)\":{\"notice\":\"Returns the vault address associated with a given NFT ID.\"}},\"notice\":\"Fluid Vault protocol resolver Implements various view-only methods to give easy access to Vault protocol data.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/periphery/resolvers/vault/main.sol\":\"FluidVaultResolver\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xab28a56179c1db258c9bf5235b382698cb650debecb51b23d12be9e241374b68\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd1556954440b31c97a142c6ba07d5cade45f96fafd52091d33a14ebe365aecbf\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/libraries/addressCalcs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice implements calculation of address for contracts deployed through CREATE.\\n/// Accepts contract deployed from which address & nonce\\nlibrary AddressCalcs {\\n\\n    /// @notice                         Computes the address of a contract based\\n    /// @param deployedFrom_            Address from which the contract was deployed\\n    /// @param nonce_                   Nonce at which the contract was deployed\\n    /// @return contract_               Address of deployed contract\\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\\n        // @dev based on https://ethereum.stackexchange.com/a/61413\\n\\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\\n        // hence, nonce of vault deployment starts with 1.\\n        bytes memory data;\\n        if (nonce_ == 0x00) {\\n            return address(0);\\n        } else if (nonce_ <= 0x7f) {\\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\\n        } else if (nonce_ <= 0xff) {\\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\\n        } else if (nonce_ <= 0xffff) {\\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\\n        } else if (nonce_ <= 0xffffff) {\\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\\n        } else {\\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\\n        }\\n\\n        return address(uint160(uint256(keccak256(data))));\\n    }\\n\\n}\",\"keccak256\":\"0xca389bcfef035463ff43939ac5eccab07ab74cbb053e201541f9bcd846b3105a\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/bigMathMinified.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\\n/// result in significant gas cost reduction due to storage space reduction.\\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\\nlibrary BigMathMinified {\\n    /// @dev constants to use for `roundUp` input param to increase readability\\n    bool internal constant ROUND_DOWN = false;\\n    bool internal constant ROUND_UP = true;\\n\\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\\n    /// e.g.:\\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\\n    /// exponent =                                            0011,0011     (51)\\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\\n    ///\\n    /// @param normal number which needs to be converted into Big Number\\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\\n    /// @param roundUp signals if result should be rounded down or up\\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\\n    function toBigNumber(\\n        uint256 normal,\\n        uint256 coefficientSize,\\n        uint256 exponentSize,\\n        bool roundUp\\n    ) internal pure returns (uint256 bigNumber) {\\n        assembly {\\n            let lastBit_\\n            let number_ := normal\\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x80, number_)\\n                lastBit_ := 0x80\\n            }\\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x40, number_)\\n                lastBit_ := add(lastBit_, 0x40)\\n            }\\n            if gt(number_, 0xFFFFFFFF) {\\n                number_ := shr(0x20, number_)\\n                lastBit_ := add(lastBit_, 0x20)\\n            }\\n            if gt(number_, 0xFFFF) {\\n                number_ := shr(0x10, number_)\\n                lastBit_ := add(lastBit_, 0x10)\\n            }\\n            if gt(number_, 0xFF) {\\n                number_ := shr(0x8, number_)\\n                lastBit_ := add(lastBit_, 0x8)\\n            }\\n            if gt(number_, 0xF) {\\n                number_ := shr(0x4, number_)\\n                lastBit_ := add(lastBit_, 0x4)\\n            }\\n            if gt(number_, 0x3) {\\n                number_ := shr(0x2, number_)\\n                lastBit_ := add(lastBit_, 0x2)\\n            }\\n            if gt(number_, 0x1) {\\n                lastBit_ := add(lastBit_, 1)\\n            }\\n            if gt(number_, 0) {\\n                lastBit_ := add(lastBit_, 1)\\n            }\\n            if lt(lastBit_, coefficientSize) {\\n                // for throw exception\\n                lastBit_ := coefficientSize\\n            }\\n            let exponent := sub(lastBit_, coefficientSize)\\n            let coefficient := shr(exponent, normal)\\n            if and(roundUp, gt(exponent, 0)) {\\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\\n                coefficient := add(coefficient, 1)\\n                if eq(shl(coefficientSize, 1), coefficient) {\\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\\n                    coefficient := shl(sub(coefficientSize, 1), 1)\\n                    exponent := add(exponent, 1)\\n                }\\n            }\\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\\n                // if exponent is >= exponentSize, the normal number is too big to fit within\\n                // BigNumber with too small sizes for coefficient and exponent\\n                revert(0, 0)\\n            }\\n            bigNumber := shl(exponentSize, coefficient)\\n            bigNumber := add(bigNumber, exponent)\\n        }\\n    }\\n\\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\\n    function fromBigNumber(\\n        uint256 bigNumber,\\n        uint256 exponentSize,\\n        uint256 exponentMask\\n    ) internal pure returns (uint256 normal) {\\n        assembly {\\n            let coefficient := shr(exponentSize, bigNumber)\\n            let exponent := and(bigNumber, exponentMask)\\n            normal := shl(exponent, coefficient)\\n        }\\n    }\\n\\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\\n    /// e.g.\\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\\n        assembly {\\n            let number_ := normal\\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x80, number_)\\n                lastBit := 0x80\\n            }\\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x40, number_)\\n                lastBit := add(lastBit, 0x40)\\n            }\\n            if gt(number_, 0xFFFFFFFF) {\\n                number_ := shr(0x20, number_)\\n                lastBit := add(lastBit, 0x20)\\n            }\\n            if gt(number_, 0xFFFF) {\\n                number_ := shr(0x10, number_)\\n                lastBit := add(lastBit, 0x10)\\n            }\\n            if gt(number_, 0xFF) {\\n                number_ := shr(0x8, number_)\\n                lastBit := add(lastBit, 0x8)\\n            }\\n            if gt(number_, 0xF) {\\n                number_ := shr(0x4, number_)\\n                lastBit := add(lastBit, 0x4)\\n            }\\n            if gt(number_, 0x3) {\\n                number_ := shr(0x2, number_)\\n                lastBit := add(lastBit, 0x2)\\n            }\\n            if gt(number_, 0x1) {\\n                lastBit := add(lastBit, 1)\\n            }\\n            if gt(number_, 0) {\\n                lastBit := add(lastBit, 1)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf0be1002909edf30aec3dc6623c2bd2407ed94064b62674c01032b844dec206a\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/dexCalcs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { BigMathMinified } from \\\"./bigMathMinified.sol\\\";\\nimport { DexSlotsLink } from \\\"./dexSlotsLink.sol\\\";\\n\\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n// @DEV ATTENTION: ON ANY CHANGES HERE, MAKE SURE THAT LOGIC IN VAULTS WILL STILL BE VALID.\\n// SOME CODE THERE ASSUMES DEXCALCS == LIQUIDITYCALCS.\\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\n/// @notice implements calculation methods used for Fluid Dex such as updated withdrawal / borrow limits.\\nlibrary DexCalcs {\\n    // constants used for BigMath conversion from and to storage\\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\\n\\n    uint256 internal constant FOUR_DECIMALS = 1e4;\\n    uint256 internal constant X14 = 0x3fff;\\n    uint256 internal constant X18 = 0x3ffff;\\n    uint256 internal constant X24 = 0xffffff;\\n    uint256 internal constant X33 = 0x1ffffffff;\\n    uint256 internal constant X64 = 0xffffffffffffffff;\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                      CALC LIMITS                       /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev calculates withdrawal limit before an operate execution:\\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\\n    /// @param userSupplyData_ user supply data packed uint256 from storage\\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\\n    function calcWithdrawalLimitBeforeOperate(\\n        uint256 userSupplyData_,\\n        uint256 userSupply_\\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\\n        // a deposit anyway. Important is that it would not revert.\\n\\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\\n        // is the fully expanded limit immediately.\\n\\n        // extract last set withdrawal limit\\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) &\\n            X64;\\n        lastWithdrawalLimit_ =\\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\\n        if (lastWithdrawalLimit_ == 0) {\\n            // withdrawal limit is not activated. Max withdrawal allowed\\n            return 0;\\n        }\\n\\n        uint256 maxWithdrawableLimit_;\\n        uint256 temp_;\\n        unchecked {\\n            // extract max withdrawable percent of user supply and\\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\\n\\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            maxWithdrawableLimit_ =\\n                (((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\\n                FOUR_DECIMALS;\\n\\n            // time elapsed since last withdrawal limit was set (in seconds)\\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\\n            // last timestamp can not be > current timestamp\\n            temp_ = block.timestamp - ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\\n        }\\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\\n        temp_ =\\n            (maxWithdrawableLimit_ * temp_) /\\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\\n            ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\\n        unchecked {\\n            // underflow explicitly checked & handled\\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\\n            temp_ = userSupply_ - maxWithdrawableLimit_;\\n        }\\n        // if withdrawal limit is decreased below minimum then set minimum\\n        // (e.g. when more than expandDuration time has elapsed)\\n        if (temp_ > currentWithdrawalLimit_) {\\n            currentWithdrawalLimit_ = temp_;\\n        }\\n    }\\n\\n    /// @dev calculates withdrawal limit after an operate execution:\\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\\n    /// @param userSupplyData_ user supply data packed uint256 from storage\\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\\n    ///                          raw for with interest mode, normal amount for interest free mode!\\n    function calcWithdrawalLimitAfterOperate(\\n        uint256 userSupplyData_,\\n        uint256 userSupply_,\\n        uint256 newWithdrawalLimit_\\n    ) internal pure returns (uint256) {\\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\\n        uint256 temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        // if user supply is below base limit then max withdrawals are allowed\\n        if (userSupply_ < temp_) {\\n            return 0;\\n        }\\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\\n        temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\\n        unchecked {\\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\\n        }\\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\\n        // increased deposit amount outpaces withrawals.\\n        if (temp_ > newWithdrawalLimit_) {\\n            return temp_;\\n        }\\n        return newWithdrawalLimit_;\\n    }\\n\\n    /// @dev calculates borrow limit before an operate execution:\\n    /// total amount user borrow can reach (not borrowable amount in current operation).\\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\\n    ///                             raw for with interest mode, normal amount for interest free mode!\\n    function calcBorrowLimitBeforeOperate(\\n        uint256 userBorrowData_,\\n        uint256 userBorrow_\\n    ) internal view returns (uint256 currentBorrowLimit_) {\\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\\n\\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\\n\\n        uint256 maxExpansionLimit_;\\n        uint256 maxExpandedBorrowLimit_;\\n        unchecked {\\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\\n\\n            // calculate max borrow limit: Max point limit can increase to since last interaction\\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\\n        }\\n\\n        // currentBorrowLimit_ = extract base borrow limit\\n        currentBorrowLimit_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\\n        currentBorrowLimit_ =\\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\\n            return currentBorrowLimit_;\\n        }\\n        // time elapsed since last borrow limit was set (in seconds)\\n        unchecked {\\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\\n            temp_ = block.timestamp - ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\\n        }\\n\\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\\n        currentBorrowLimit_ =\\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\\n            ((maxExpansionLimit_ * temp_) /\\n                ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\\n            //  extract last set borrow limit\\n            BigMathMinified.fromBigNumber(\\n                (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\\n                DEFAULT_EXPONENT_SIZE,\\n                DEFAULT_EXPONENT_MASK\\n            );\\n\\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\\n        // so set to `maxExpandedBorrowLimit_` in that case.\\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\\n        }\\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (currentBorrowLimit_ > temp_) {\\n            currentBorrowLimit_ = temp_;\\n        }\\n    }\\n\\n    /// @dev calculates borrow limit after an operate execution:\\n    /// total amount user borrow can reach (not borrowable amount in current operation).\\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\\n    function calcBorrowLimitAfterOperate(\\n        uint256 userBorrowData_,\\n        uint256 userBorrow_,\\n        uint256 newBorrowLimit_\\n    ) internal pure returns (uint256 borrowLimit_) {\\n        // temp_ = extract borrow expand percent\\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\\n\\n        unchecked {\\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\\n        }\\n\\n        // temp_ = extract base borrow limit\\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (borrowLimit_ < temp_) {\\n            // below base limit, borrow limit is always base limit\\n            return temp_;\\n        }\\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        // make sure fully expanded borrow limit is not above hard max borrow limit\\n        if (borrowLimit_ > temp_) {\\n            borrowLimit_ = temp_;\\n        }\\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\\n        if (newBorrowLimit_ > borrowLimit_) {\\n            return borrowLimit_;\\n        }\\n        return newBorrowLimit_;\\n    }\\n}\\n\",\"keccak256\":\"0xd033a77bd57f4a608e693fdf6147ddd3bbfa0d80d86c1097d24e428c886c0d5e\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/dexSlotsLink.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\\nlibrary DexSlotsLink {\\n    /// @dev storage slot for variables at Dex\\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\\n    /// @dev storage slot for variables2 at Dex\\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\\n    /// @dev storage slot for total supply shares at Dex\\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\\n    /// @dev storage slot for user supply mapping at Dex\\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\\n    /// @dev storage slot for total borrow shares at Dex\\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\\n    /// @dev storage slot for user borrow mapping at Dex\\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\\n    /// @dev storage slot for oracle mapping at Dex\\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\\n    /// @dev storage slot for range and threshold shifts at Dex\\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\\n    /// @dev storage slot for center price shift at Dex\\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\\n\\n    // --------------------------------\\n    // @dev stacked uint256 storage slots bits position data for each:\\n\\n    // UserSupplyData\\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\\n\\n    // UserBorrowData\\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\\n\\n    // --------------------------------\\n\\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\\n    function calculateDoubleMappingStorageSlot(\\n        uint256 slot_,\\n        address key1_,\\n        address key2_\\n    ) internal pure returns (bytes32) {\\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\\n        return keccak256(abi.encode(key2_, intermediateSlot_));\\n    }\\n}\\n\",\"keccak256\":\"0xf1d6550d83fb0155a26655234922c9bdf4a1bbcf7a3ca767e9123d367a795307\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary LibsErrorTypes {\\n    /***********************************|\\n    |         LiquidityCalcs            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\\n\\n    /// @notice thrown when rate data is set to a version that is not implemented\\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\\n\\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\\n\\n    /***********************************|\\n    |           SafeTransfer            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when safe transfer from for an ERC20 fails\\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\\n\\n    /// @notice thrown when safe transfer for an ERC20 fails\\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\\n}\\n\",\"keccak256\":\"0xaf7732f30d00dd38082d37aa37887be485fc94b0c76ff302aff615d03381674f\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/fluidProtocolTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ninterface IFluidProtocol {\\n    function TYPE() external view returns (uint256);\\n}\\n\\n/// @notice implements helper methods to filter Fluid protocols by a certain type\\nlibrary FluidProtocolTypes {\\n    uint256 internal constant VAULT_T1_TYPE = 10000; // VaultT1 borrow protocol type vaults\\n    uint256 internal constant VAULT_T2_SMART_COL_TYPE = 20000; // DEX protocol type vault\\n    uint256 internal constant VAULT_T3_SMART_DEBT_TYPE = 30000; // DEX protocol type vault\\n    uint256 internal constant VAULT_T4_SMART_COL_SMART_DEBT_TYPE = 40000; // DEX protocol type vault\\n\\n    /// @dev filters input `addresses_` by protocol `type_`. Input addresses must be actual Fluid protocols, otherwise\\n    ///      they would be wrongly assumed to be VaultT1 even if they are not Fluid VaultT1 smart contracts.\\n    ///      `type_` must be a listed constant type of this library.\\n    ///      Example usage is to filter all vault addresses at the Vault factory by a certain type, e.g. to not include\\n    ///      DEX protocol type vaults.\\n    function filterBy(address[] memory addresses_, uint256 type_) internal view returns (address[] memory filtered_) {\\n        uint256 curType_;\\n        uint256 filteredProtocols_ = addresses_.length;\\n        for (uint256 i; i < addresses_.length; ) {\\n            try IFluidProtocol(addresses_[i]).TYPE() returns (uint256 protocolType_) {\\n                curType_ = protocolType_;\\n            } catch {\\n                curType_ = VAULT_T1_TYPE;\\n            }\\n\\n            if (curType_ != type_) {\\n                addresses_[i] = address(0);\\n                --filteredProtocols_;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        filtered_ = new address[](filteredProtocols_);\\n        uint256 index_;\\n        unchecked {\\n            for (uint256 i; i < addresses_.length; ) {\\n                if (addresses_[i] != address(0)) {\\n                    filtered_[index_] = addresses_[i];\\n                    ++index_;\\n                }\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x98868cc272fea53dbd4504e02df4f4fcd709a4144a8b37a85513edd638bd073b\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/liquidityCalcs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { LibsErrorTypes as ErrorTypes } from \\\"./errorTypes.sol\\\";\\nimport { LiquiditySlotsLink } from \\\"./liquiditySlotsLink.sol\\\";\\nimport { BigMathMinified } from \\\"./bigMathMinified.sol\\\";\\n\\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\\n/// borrow rate, withdrawal / borrow limits, revenue amount.\\nlibrary LiquidityCalcs {\\n    error FluidLiquidityCalcsError(uint256 errorId_);\\n\\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\\n    event BorrowRateMaxCap();\\n\\n    /// @dev constants as from Liquidity variables.sol\\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\\n\\n    /// @dev Ignoring leap years\\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\\n    // constants used for BigMath conversion from and to storage\\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\\n\\n    uint256 internal constant FOUR_DECIMALS = 1e4;\\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\\n    uint256 internal constant X14 = 0x3fff;\\n    uint256 internal constant X15 = 0x7fff;\\n    uint256 internal constant X16 = 0xffff;\\n    uint256 internal constant X18 = 0x3ffff;\\n    uint256 internal constant X24 = 0xffffff;\\n    uint256 internal constant X33 = 0x1ffffffff;\\n    uint256 internal constant X64 = 0xffffffffffffffff;\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                  CALC EXCHANGE PRICES                  /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\\n    function calcExchangePrices(\\n        uint256 exchangePricesAndConfig_\\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\\n        // Extracting exchange prices\\n        supplyExchangePrice_ =\\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\\n            X64;\\n        borrowExchangePrice_ =\\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\\n            X64;\\n\\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\\n        }\\n\\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\\n\\n        unchecked {\\n            // last timestamp can not be > current timestamp\\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\\n\\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\\n                X15;\\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\\n                return (supplyExchangePrice_, borrowExchangePrice_);\\n            }\\n\\n            // calculate new borrow exchange price.\\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\\n            borrowExchangePrice_ +=\\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\\n\\n            // FOR SUPPLY EXCHANGE PRICE:\\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\\n            //\\n            // Example:\\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\\n            // yield is 10 (so half a year must have passed).\\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 20%) = 62,5%\\n            // supplyRate = (40% * (100% - 10%)) * = 36% * 62,5% = 22.5%\\n            // increase in supplyExchangePrice, assuming 100 as previous price.\\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\\n\\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\\n\\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\\n\\n            if (temp_ == 1) {\\n                // if no raw supply: no exchange price update needed\\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\\n                return (supplyExchangePrice_, borrowExchangePrice_);\\n            }\\n\\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\\n            if (temp_ & 1 == 1) {\\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\\n                temp_ = temp_ >> 1;\\n\\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\\n                // in the if statement a little above.\\n\\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\\n                // so ratioSupplyYield must come out as 2.5 (250%).\\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\\n                temp_ =\\n                    // utilization * (100% + 100% / supplyRatio)\\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\\n                    (FOUR_DECIMALS);\\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\\n            } else {\\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\\n                temp_ = temp_ >> 1;\\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\\n\\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\\n                temp_ =\\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\\n                    (1e27 *\\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\\n                        (FOUR_DECIMALS + temp_)) /\\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\\n            }\\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\\n\\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\\n            if (borrowRatio_ & 1 == 1) {\\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\\n                borrowRatio_ = borrowRatio_ >> 1;\\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\\n\\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\\n\\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\\n            } else {\\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\\n                borrowRatio_ = borrowRatio_ >> 1;\\n\\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\\n            }\\n\\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\\n\\n            // 2. calculate supply rate\\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\\n            // but more suppliers not earning interest.\\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\\n                temp_ * // ratioSupplyYield\\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\\n\\n            // 3. calculate increase in supply exchange price\\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                     CALC REVENUE                       /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\\n    /// and the current balance of the Fluid liquidity contract for the token.\\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\\n    /// @return revenueAmount_ collectable revenue amount\\n    function calcRevenue(\\n        uint256 totalAmounts_,\\n        uint256 exchangePricesAndConfig_,\\n        uint256 liquidityTokenBalance_\\n    ) internal view returns (uint256 revenueAmount_) {\\n        // @dev no need to super-optimize this method as it is only used by admin\\n\\n        // calculate the new exchange prices based on earned interest\\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\\n\\n        // total supply = interest free + with interest converted from raw\\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\\n\\n        if (totalSupply_ > 0) {\\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\\n            // ensure there is no possible case because of rounding etc. where this would revert,\\n            // explicitly check if >\\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\\n            // can only be revenue.\\n        } else {\\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\\n            revenueAmount_ = liquidityTokenBalance_;\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                      CALC LIMITS                       /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev calculates withdrawal limit before an operate execution:\\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\\n    /// @param userSupplyData_ user supply data packed uint256 from storage\\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\\n    function calcWithdrawalLimitBeforeOperate(\\n        uint256 userSupplyData_,\\n        uint256 userSupply_\\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\\n        // a deposit anyway. Important is that it would not revert.\\n\\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\\n        // is the fully expanded limit immediately.\\n\\n        // extract last set withdrawal limit\\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\\n        lastWithdrawalLimit_ =\\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\\n        if (lastWithdrawalLimit_ == 0) {\\n            // withdrawal limit is not activated. Max withdrawal allowed\\n            return 0;\\n        }\\n\\n        uint256 maxWithdrawableLimit_;\\n        uint256 temp_;\\n        unchecked {\\n            // extract max withdrawable percent of user supply and\\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\\n\\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            maxWithdrawableLimit_ =\\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\\n                FOUR_DECIMALS;\\n\\n            // time elapsed since last withdrawal limit was set (in seconds)\\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\\n            // last timestamp can not be > current timestamp\\n            temp_ =\\n                block.timestamp -\\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\\n        }\\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\\n        temp_ =\\n            (maxWithdrawableLimit_ * temp_) /\\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\\n        unchecked {\\n            // underflow explicitly checked & handled\\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\\n            temp_ = userSupply_ - maxWithdrawableLimit_;\\n        }\\n        // if withdrawal limit is decreased below minimum then set minimum\\n        // (e.g. when more than expandDuration time has elapsed)\\n        if (temp_ > currentWithdrawalLimit_) {\\n            currentWithdrawalLimit_ = temp_;\\n        }\\n    }\\n\\n    /// @dev calculates withdrawal limit after an operate execution:\\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\\n    /// @param userSupplyData_ user supply data packed uint256 from storage\\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\\n    ///                          raw for with interest mode, normal amount for interest free mode!\\n    function calcWithdrawalLimitAfterOperate(\\n        uint256 userSupplyData_,\\n        uint256 userSupply_,\\n        uint256 newWithdrawalLimit_\\n    ) internal pure returns (uint256) {\\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        // if user supply is below base limit then max withdrawals are allowed\\n        if (userSupply_ < temp_) {\\n            return 0;\\n        }\\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\\n        unchecked {\\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\\n        }\\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\\n        // increased deposit amount outpaces withrawals.\\n        if (temp_ > newWithdrawalLimit_) {\\n            return temp_;\\n        }\\n        return newWithdrawalLimit_;\\n    }\\n\\n    /// @dev calculates borrow limit before an operate execution:\\n    /// total amount user borrow can reach (not borrowable amount in current operation).\\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\\n    ///                             raw for with interest mode, normal amount for interest free mode!\\n    function calcBorrowLimitBeforeOperate(\\n        uint256 userBorrowData_,\\n        uint256 userBorrow_\\n    ) internal view returns (uint256 currentBorrowLimit_) {\\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\\n\\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\\n\\n        uint256 maxExpansionLimit_;\\n        uint256 maxExpandedBorrowLimit_;\\n        unchecked {\\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\\n\\n            // calculate max borrow limit: Max point limit can increase to since last interaction\\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\\n        }\\n\\n        // currentBorrowLimit_ = extract base borrow limit\\n        currentBorrowLimit_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\\n        currentBorrowLimit_ =\\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\\n            return currentBorrowLimit_;\\n        }\\n        // time elapsed since last borrow limit was set (in seconds)\\n        unchecked {\\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\\n            temp_ =\\n                block.timestamp -\\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\\n        }\\n\\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\\n        currentBorrowLimit_ =\\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\\n            ((maxExpansionLimit_ * temp_) /\\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\\n            //  extract last set borrow limit\\n            BigMathMinified.fromBigNumber(\\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\\n                DEFAULT_EXPONENT_SIZE,\\n                DEFAULT_EXPONENT_MASK\\n            );\\n\\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\\n        // so set to `maxExpandedBorrowLimit_` in that case.\\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\\n        }\\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (currentBorrowLimit_ > temp_) {\\n            currentBorrowLimit_ = temp_;\\n        }\\n    }\\n\\n    /// @dev calculates borrow limit after an operate execution:\\n    /// total amount user borrow can reach (not borrowable amount in current operation).\\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\\n    function calcBorrowLimitAfterOperate(\\n        uint256 userBorrowData_,\\n        uint256 userBorrow_,\\n        uint256 newBorrowLimit_\\n    ) internal pure returns (uint256 borrowLimit_) {\\n        // temp_ = extract borrow expand percent\\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\\n\\n        unchecked {\\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\\n        }\\n\\n        // temp_ = extract base borrow limit\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (borrowLimit_ < temp_) {\\n            // below base limit, borrow limit is always base limit\\n            return temp_;\\n        }\\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        // make sure fully expanded borrow limit is not above hard max borrow limit\\n        if (borrowLimit_ > temp_) {\\n            borrowLimit_ = temp_;\\n        }\\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\\n        if (newBorrowLimit_ > borrowLimit_) {\\n            return borrowLimit_;\\n        }\\n        return newBorrowLimit_;\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                      CALC RATES                        /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev Calculates new borrow rate from utilization for a token\\n    /// @param rateData_ rate data packed uint256 from storage for the token\\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\\n        // extract rate version: 4 bits (0xF) starting from bit 0\\n        uint256 rateVersion_ = (rateData_ & 0xF);\\n\\n        if (rateVersion_ == 1) {\\n            rate_ = calcRateV1(rateData_, utilization_);\\n        } else if (rateVersion_ == 2) {\\n            rate_ = calcRateV2(rateData_, utilization_);\\n        } else {\\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\\n        }\\n\\n        if (rate_ > X16) {\\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\\n            // this is unlikely to ever happen if configs stay within expected levels.\\n            rate_ = X16;\\n            // emit event to more easily become aware\\n            emit BorrowRateMaxCap();\\n        }\\n    }\\n\\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\\n    /// @param rateData_ rate data packed uint256 from storage for the token\\n    /// @param utilization_  in 1e2 (100% = 1e4)\\n    /// @return rate_ rate in 1e2 precision\\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\\n        /// For rate v1 (one kink) ------------------------------------------------------\\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\\n\\n        // y = mx + c.\\n        // y is borrow rate\\n        // x is utilization\\n        // m = slope (m can also be negative for declining rates)\\n        // c is constant (c can be negative)\\n\\n        uint256 y1_;\\n        uint256 y2_;\\n        uint256 x1_;\\n        uint256 x2_;\\n\\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\\n        if (utilization_ < kink1_) {\\n            // if utilization is less than kink\\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\\n            x1_ = 0; // 0%\\n            x2_ = kink1_;\\n        } else {\\n            // else utilization is greater than kink\\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\\n            x1_ = kink1_;\\n            x2_ = FOUR_DECIMALS; // 100%\\n        }\\n\\n        int256 constant_;\\n        int256 slope_;\\n        unchecked {\\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\\n\\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\\n\\n            // calculating new borrow rate\\n            // - slope_ max value is 65535 * 1e12,\\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\\n            // - constant max value is 65535 * 1e12\\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\\n            // divisor TWELVE_DECIMALS can not be 0\\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\\n            if (slope_ < 0) {\\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\\n            }\\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\\n        }\\n    }\\n\\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\\n    /// @param rateData_ rate data packed uint256 from storage for the token\\n    /// @param utilization_  in 1e2 (100% = 1e4)\\n    /// @return rate_ rate in 1e4 precision\\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\\n        /// For rate v2 (two kinks) -----------------------------------------------------\\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Last 156 bits => 100-255 => blank, might come in use in future\\n\\n        // y = mx + c.\\n        // y is borrow rate\\n        // x is utilization\\n        // m = slope (m can also be negative for declining rates)\\n        // c is constant (c can be negative)\\n\\n        uint256 y1_;\\n        uint256 y2_;\\n        uint256 x1_;\\n        uint256 x2_;\\n\\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\\n        if (utilization_ < kink1_) {\\n            // if utilization is less than kink1\\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\\n            x1_ = 0; // 0%\\n            x2_ = kink1_;\\n        } else {\\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\\n            if (utilization_ < kink2_) {\\n                // if utilization is less than kink2\\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\\n                x1_ = kink1_;\\n                x2_ = kink2_;\\n            } else {\\n                // else utilization is greater than kink2\\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\\n                x1_ = kink2_;\\n                x2_ = FOUR_DECIMALS;\\n            }\\n        }\\n\\n        int256 constant_;\\n        int256 slope_;\\n        unchecked {\\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\\n\\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\\n\\n            // calculating new borrow rate\\n            // - slope_ max value is 65535 * 1e12,\\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\\n            // - constant max value is 65535 * 1e12\\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\\n            // divisor TWELVE_DECIMALS can not be 0\\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\\n            if (slope_ < 0) {\\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\\n            }\\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\\n        }\\n    }\\n\\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\\n    function getTotalSupply(\\n        uint256 totalAmounts_,\\n        uint256 supplyExchangePrice_\\n    ) internal pure returns (uint256 totalSupply_) {\\n        // totalSupply_ => supplyInterestFree\\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\\n\\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\\n\\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\\n    }\\n\\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\\n    function getTotalBorrow(\\n        uint256 totalAmounts_,\\n        uint256 borrowExchangePrice_\\n    ) internal pure returns (uint256 totalBorrow_) {\\n        // totalBorrow_ => borrowInterestFree\\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\\n\\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\\n\\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\\n    }\\n}\\n\",\"keccak256\":\"0xa65e2f84b2c33769ceb6b28fbd3221be29da2f8ac96e4d8b8cea91948d81a707\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/liquiditySlotsLink.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\\nlibrary LiquiditySlotsLink {\\n    /// @dev storage slot for status at Liquidity\\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\\n    /// @dev storage slot for auths mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\\n    /// @dev storage slot for guardians mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\\n    /// @dev storage slot for user class mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\\n    /// @dev storage slot for rateData mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\\n    /// @dev storage slot for totalAmounts mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\\n    /// @dev storage slot for user supply double mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\\n    /// @dev storage slot for user borrow double mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\\n    /// @dev storage slot for listed tokens array at Liquidity\\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\\n    /// @dev storage slot for listed tokens array at Liquidity\\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\\n\\n    // --------------------------------\\n    // @dev stacked uint256 storage slots bits position data for each:\\n\\n    // ExchangePricesAndConfig\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\\n\\n    // RateData:\\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\\n    // RateData: V1\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\\n    // RateData: V2\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\\n\\n    // TotalAmounts\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\\n\\n    // UserSupplyData\\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\\n\\n    // UserBorrowData\\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\\n\\n    // Configs2\\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\\n\\n    // --------------------------------\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\\n    function calculateDoubleMappingStorageSlot(\\n        uint256 slot_,\\n        address key1_,\\n        address key2_\\n    ) internal pure returns (bytes32) {\\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\\n        return keccak256(abi.encode(key2_, intermediateSlot_));\\n    }\\n}\\n\",\"keccak256\":\"0x0ae3e1d231bb6c14b54fc1f5ffa306edc0ac827a6a92279c77c0c09627fe08ae\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/tickMath.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @title library that calculates number \\\"tick\\\" and \\\"ratioX96\\\" from this: ratioX96 = (1.0015^tick) * 2^96\\n/// @notice this library is used in Fluid Vault protocol for optimiziation.\\n/// @dev \\\"tick\\\" supports between -32767 and 32767. \\\"ratioX96\\\" supports between 37075072 and 169307877264527972847801929085841449095838922544595\\nlibrary TickMath {\\n    /// The minimum tick that can be passed in getRatioAtTick. 1.0015**-32767\\n    int24 internal constant MIN_TICK = -32767;\\n    /// The maximum tick that can be passed in getRatioAtTick. 1.0015**32767\\n    int24 internal constant MAX_TICK = 32767;\\n\\n    uint256 internal constant FACTOR00 = 0x100000000000000000000000000000000;\\n    uint256 internal constant FACTOR01 = 0xff9dd7de423466c20352b1246ce4856f; // 2^128/1.0015**1 = 339772707859149738855091969477551883631\\n    uint256 internal constant FACTOR02 = 0xff3bd55f4488ad277531fa1c725a66d0; // 2^128/1.0015**2 = 339263812140938331358054887146831636176\\n    uint256 internal constant FACTOR03 = 0xfe78410fd6498b73cb96a6917f853259; // 2^128/1.0015**4 = 338248306163758188337119769319392490073\\n    uint256 internal constant FACTOR04 = 0xfcf2d9987c9be178ad5bfeffaa123273; // 2^128/1.0015**8 = 336226404141693512316971918999264834163\\n    uint256 internal constant FACTOR05 = 0xf9ef02c4529258b057769680fc6601b3; // 2^128/1.0015**16 = 332218786018727629051611634067491389875\\n    uint256 internal constant FACTOR06 = 0xf402d288133a85a17784a411f7aba082; // 2^128/1.0015**32 = 324346285652234375371948336458280706178\\n    uint256 internal constant FACTOR07 = 0xe895615b5beb6386553757b0352bda90; // 2^128/1.0015**64 = 309156521885964218294057947947195947664\\n    uint256 internal constant FACTOR08 = 0xd34f17a00ffa00a8309940a15930391a; // 2^128/1.0015**128 = 280877777739312896540849703637713172762 \\n    uint256 internal constant FACTOR09 = 0xae6b7961714e20548d88ea5123f9a0ff; // 2^128/1.0015**256 = 231843708922198649176471782639349113087\\n    uint256 internal constant FACTOR10 = 0x76d6461f27082d74e0feed3b388c0ca1; // 2^128/1.0015**512 = 157961477267171621126394973980180876449\\n    uint256 internal constant FACTOR11 = 0x372a3bfe0745d8b6b19d985d9a8b85bb; // 2^128/1.0015**1024 = 73326833024599564193373530205717235131\\n    uint256 internal constant FACTOR12 = 0x0be32cbee48979763cf7247dd7bb539d; // 2^128/1.0015**2048 = 15801066890623697521348224657638773661\\n    uint256 internal constant FACTOR13 = 0x8d4f70c9ff4924dac37612d1e2921e;   // 2^128/1.0015**4096 = 733725103481409245883800626999235102\\n    uint256 internal constant FACTOR14 = 0x4e009ae5519380809a02ca7aec77;     // 2^128/1.0015**8192 = 1582075887005588088019997442108535\\n    uint256 internal constant FACTOR15 = 0x17c45e641b6e95dee056ff10;         // 2^128/1.0015**16384 = 7355550435635883087458926352\\n\\n    /// The minimum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MIN_TICK). ~ Equivalent to `(1 << 96) * (1.0015**-32767)`\\n    uint256 internal constant MIN_RATIOX96 = 37075072;\\n    /// The maximum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MAX_TICK).\\n    /// ~ Equivalent to `(1 << 96) * (1.0015**32767)`, rounding etc. leading to minor difference\\n    uint256 internal constant MAX_RATIOX96 = 169307877264527972847801929085841449095838922544595;\\n\\n    uint256 internal constant ZERO_TICK_SCALED_RATIO = 0x1000000000000000000000000; // 1 << 96 // 79228162514264337593543950336\\n    uint256 internal constant _1E26 = 1e26;\\n\\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return ratioX96 ratio = (debt amount/collateral amount)\\n    function getRatioAtTick(int tick) internal pure returns (uint256 ratioX96) {\\n        assembly {\\n            let absTick_ := sub(xor(tick, sar(255, tick)), sar(255, tick))\\n\\n            if gt(absTick_, MAX_TICK) {\\n                revert(0, 0)\\n            }\\n            let factor_ := FACTOR00\\n            if and(absTick_, 0x1) {\\n                factor_ := FACTOR01\\n            }\\n            if and(absTick_, 0x2) {\\n                factor_ := shr(128, mul(factor_, FACTOR02))\\n            }\\n            if and(absTick_, 0x4) {\\n                factor_ := shr(128, mul(factor_, FACTOR03))\\n            }\\n            if and(absTick_, 0x8) {\\n                factor_ := shr(128, mul(factor_, FACTOR04))\\n            }\\n            if and(absTick_, 0x10) {\\n                factor_ := shr(128, mul(factor_, FACTOR05))\\n            }\\n            if and(absTick_, 0x20) {\\n                factor_ := shr(128, mul(factor_, FACTOR06))\\n            }\\n            if and(absTick_, 0x40) {\\n                factor_ := shr(128, mul(factor_, FACTOR07))\\n            }\\n            if and(absTick_, 0x80) {\\n                factor_ := shr(128, mul(factor_, FACTOR08))\\n            }\\n            if and(absTick_, 0x100) {\\n                factor_ := shr(128, mul(factor_, FACTOR09))\\n            }\\n            if and(absTick_, 0x200) {\\n                factor_ := shr(128, mul(factor_, FACTOR10))\\n            }\\n            if and(absTick_, 0x400) {\\n                factor_ := shr(128, mul(factor_, FACTOR11))\\n            }\\n            if and(absTick_, 0x800) {\\n                factor_ := shr(128, mul(factor_, FACTOR12))\\n            }\\n            if and(absTick_, 0x1000) {\\n                factor_ := shr(128, mul(factor_, FACTOR13))\\n            }\\n            if and(absTick_, 0x2000) {\\n                factor_ := shr(128, mul(factor_, FACTOR14))\\n            }\\n            if and(absTick_, 0x4000) {\\n                factor_ := shr(128, mul(factor_, FACTOR15))\\n            }\\n\\n            let precision_ := 0\\n            if iszero(and(tick, 0x8000000000000000000000000000000000000000000000000000000000000000)) {\\n                factor_ := div(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, factor_)\\n                // we round up in the division so getTickAtRatio of the output price is always consistent\\n                if mod(factor_, 0x100000000) {\\n                    precision_ := 1\\n                }\\n            }\\n            ratioX96 := add(shr(32, factor_), precision_)\\n        }\\n    }\\n\\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\\n    /// @dev Throws if ratioX96 > max ratio || ratioX96 < min ratio\\n    /// @param ratioX96 The input ratio; ratio = (debt amount/collateral amount)\\n    /// @return tick The output tick for the above formula. Returns in round down form. if tick is 123.23 then 123, if tick is -123.23 then returns -124\\n    /// @return perfectRatioX96 perfect ratio for the above tick\\n    function getTickAtRatio(uint256 ratioX96) internal pure returns (int tick, uint perfectRatioX96) {\\n        assembly {\\n            if or(gt(ratioX96, MAX_RATIOX96), lt(ratioX96, MIN_RATIOX96)) {\\n                revert(0, 0)\\n            }\\n\\n            let cond := lt(ratioX96, ZERO_TICK_SCALED_RATIO)\\n            let factor_\\n\\n            if iszero(cond) {\\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\\n                factor_ := div(mul(ratioX96, _1E26), ZERO_TICK_SCALED_RATIO)\\n            }\\n            if cond {\\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\\n                factor_ := div(mul(ZERO_TICK_SCALED_RATIO, _1E26), ratioX96)\\n            }\\n\\n            // put in https://www.wolframalpha.com/ whole equation: (1.0015^tick) * 2^96 * 10^26 / 79228162514264337593543950336\\n\\n            // for tick = 16384\\n            // ratioX96 = (1.0015^16384) * 2^96 = 3665252098134783297721995888537077351735\\n            // 3665252098134783297721995888537077351735 * 10^26 / 79228162514264337593543950336 =\\n            // 4626198540796508716348404308345255985.06131964639489434655721\\n            if iszero(lt(factor_, 4626198540796508716348404308345255985)) {\\n                tick := or(tick, 0x4000)\\n                factor_ := div(mul(factor_, _1E26), 4626198540796508716348404308345255985)\\n            }\\n            // for tick = 8192\\n            // ratioX96 = (1.0015^8192) * 2^96 = 17040868196391020479062776466509865\\n            // 17040868196391020479062776466509865 * 10^26 / 79228162514264337593543950336 =\\n            // 21508599537851153911767490449162.3037648642153898377655505172\\n            if iszero(lt(factor_, 21508599537851153911767490449162)) {\\n                tick := or(tick, 0x2000)\\n                factor_ := div(mul(factor_, _1E26), 21508599537851153911767490449162)\\n            }\\n            // for tick = 4096\\n            // ratioX96 = (1.0015^4096) * 2^96 = 36743933851015821532611831851150\\n            // 36743933851015821532611831851150 * 10^26 / 79228162514264337593543950336 =\\n            // 46377364670549310883002866648.9777607649742626173648716941385\\n            if iszero(lt(factor_, 46377364670549310883002866649)) {\\n                tick := or(tick, 0x1000)\\n                factor_ := div(mul(factor_, _1E26), 46377364670549310883002866649)\\n            }\\n            // for tick = 2048\\n            // ratioX96 = (1.0015^2048) * 2^96 = 1706210527034005899209104452335\\n            // 1706210527034005899209104452335 * 10^26 / 79228162514264337593543950336 =\\n            // 2153540449365864845468344760.06357108484096046743300420319322\\n            if iszero(lt(factor_, 2153540449365864845468344760)) {\\n                tick := or(tick, 0x800)\\n                factor_ := div(mul(factor_, _1E26), 2153540449365864845468344760)\\n            }\\n            // for tick = 1024\\n            // ratioX96 = (1.0015^1024) * 2^96 = 367668226692760093024536487236\\n            // 367668226692760093024536487236 * 10^26 / 79228162514264337593543950336 =\\n            // 464062544207767844008185024.950588990554136265212906454481127\\n            if iszero(lt(factor_, 464062544207767844008185025)) {\\n                tick := or(tick, 0x400)\\n                factor_ := div(mul(factor_, _1E26), 464062544207767844008185025)\\n            }\\n            // for tick = 512\\n            // ratioX96 = (1.0015^512) * 2^96 = 170674186729409605620119663668\\n            // 170674186729409605620119663668 * 10^26 / 79228162514264337593543950336 =\\n            // 215421109505955298802281577.031879604792139232258508172947569\\n            if iszero(lt(factor_, 215421109505955298802281577)) {\\n                tick := or(tick, 0x200)\\n                factor_ := div(mul(factor_, _1E26), 215421109505955298802281577)\\n            }\\n            // for tick = 256\\n            // ratioX96 = (1.0015^256) * 2^96 = 116285004205991934861656513301\\n            // 116285004205991934861656513301 * 10^26 / 79228162514264337593543950336 =\\n            // 146772309890508740607270614.667650899656438875541505058062410\\n            if iszero(lt(factor_, 146772309890508740607270615)) {\\n                tick := or(tick, 0x100)\\n                factor_ := div(mul(factor_, _1E26), 146772309890508740607270615)\\n            }\\n            // for tick = 128\\n            // ratioX96 = (1.0015^128) * 2^96 = 95984619659632141743747099590\\n            // 95984619659632141743747099590 * 10^26 / 79228162514264337593543950336 =\\n            // 121149622323187099817270416.157248837742741760456796835775887\\n            if iszero(lt(factor_, 121149622323187099817270416)) {\\n                tick := or(tick, 0x80)\\n                factor_ := div(mul(factor_, _1E26), 121149622323187099817270416)\\n            }\\n            // for tick = 64\\n            // ratioX96 = (1.0015^64) * 2^96 = 87204845308406958006717891124\\n            // 87204845308406958006717891124 * 10^26 / 79228162514264337593543950336 =\\n            // 110067989135437147685980801.568068573422377364214113968609839\\n            if iszero(lt(factor_, 110067989135437147685980801)) {\\n                tick := or(tick, 0x40)\\n                factor_ := div(mul(factor_, _1E26), 110067989135437147685980801)\\n            }\\n            // for tick = 32\\n            // ratioX96 = (1.0015^32) * 2^96 = 83120873769022354029916374475\\n            // 83120873769022354029916374475 * 10^26 / 79228162514264337593543950336 =\\n            // 104913292358707887270979599.831816586773651266562785765558183\\n            if iszero(lt(factor_, 104913292358707887270979600)) {\\n                tick := or(tick, 0x20)\\n                factor_ := div(mul(factor_, _1E26), 104913292358707887270979600)\\n            }\\n            // for tick = 16\\n            // ratioX96 = (1.0015^16) * 2^96 = 81151180492336368327184716176\\n            // 81151180492336368327184716176 * 10^26 / 79228162514264337593543950336 =\\n            // 102427189924701091191840927.762844039579442328381455567932128\\n            if iszero(lt(factor_, 102427189924701091191840928)) {\\n                tick := or(tick, 0x10)\\n                factor_ := div(mul(factor_, _1E26), 102427189924701091191840928)\\n            }\\n            // for tick = 8\\n            // ratioX96 = (1.0015^8) * 2^96 = 80183906840906820640659903620\\n            // 80183906840906820640659903620 * 10^26 / 79228162514264337593543950336 =\\n            // 101206318935480056907421312.890625\\n            if iszero(lt(factor_, 101206318935480056907421313)) {\\n                tick := or(tick, 0x8)\\n                factor_ := div(mul(factor_, _1E26), 101206318935480056907421313)\\n            }\\n            // for tick = 4\\n            // ratioX96 = (1.0015^4) * 2^96 = 79704602139525152702959747603\\n            // 79704602139525152702959747603 * 10^26 / 79228162514264337593543950336 =\\n            // 100601351350506250000000000\\n            if iszero(lt(factor_, 100601351350506250000000000)) {\\n                tick := or(tick, 0x4)\\n                factor_ := div(mul(factor_, _1E26), 100601351350506250000000000)\\n            }\\n            // for tick = 2\\n            // ratioX96 = (1.0015^2) * 2^96 = 79466025265172787701084167660\\n            // 79466025265172787701084167660 * 10^26 / 79228162514264337593543950336 =\\n            // 100300225000000000000000000\\n            if iszero(lt(factor_, 100300225000000000000000000)) {\\n                tick := or(tick, 0x2)\\n                factor_ := div(mul(factor_, _1E26), 100300225000000000000000000)\\n            }\\n            // for tick = 1\\n            // ratioX96 = (1.0015^1) * 2^96 = 79347004758035734099934266261\\n            // 79347004758035734099934266261 * 10^26 / 79228162514264337593543950336 =\\n            // 100150000000000000000000000\\n            if iszero(lt(factor_, 100150000000000000000000000)) {\\n                tick := or(tick, 0x1)\\n                factor_ := div(mul(factor_, _1E26), 100150000000000000000000000)\\n            }\\n            if iszero(cond) {\\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\\n                perfectRatioX96 := div(mul(ratioX96, _1E26), factor_)\\n            }\\n            if cond {\\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\\n                tick := not(tick)\\n                perfectRatioX96 := div(mul(ratioX96, factor_), 100150000000000000000000000)\\n            }\\n            // perfect ratio should always be <= ratioX96\\n            // not sure if it can ever be bigger but better to have extra checks\\n            if gt(perfectRatioX96, ratioX96) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc5c13deaa16bb036a4370c0e38c33445712e8e7da1c792018dd3dc4a641ea0c0\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/adminModule/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Structs {\\n    struct AddressBool {\\n        address addr;\\n        bool value;\\n    }\\n\\n    struct AddressUint256 {\\n        address addr;\\n        uint256 value;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 1\\n    struct RateDataV1Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\\n        uint256 kink;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink;\\n        ///\\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 2\\n    struct RateDataV2Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\\n        uint256 kink1;\\n        ///\\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\\n        uint256 kink2;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink1;\\n        ///\\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\\n        uint256 rateAtUtilizationKink2;\\n        ///\\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set token config\\n    struct TokenConfig {\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 fee;\\n        ///\\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 threshold;\\n        ///\\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\\n        uint256 maxUtilization;\\n    }\\n\\n    /// @notice struct to set user supply & withdrawal config\\n    struct UserSupplyConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration withdrawal limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseWithdrawalLimit;\\n    }\\n\\n    /// @notice struct to set user borrow & payback config\\n    struct UserBorrowConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which debt limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration debt limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseDebtCeiling;\\n        ///\\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 maxDebtCeiling;\\n    }\\n}\\n\",\"keccak256\":\"0x10353c70015f27b880125cefab806dbed24a4458f187da66964f3ef60488f757\",\"license\":\"BUSL-1.1\"},\"contracts/oracle/error.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ncontract Error {\\n    error FluidOracleError(uint256 errorId_);\\n}\\n\",\"keccak256\":\"0xc7b7e945238168d216c480e9dd4fbaaf8780645d58c47f9abdaa4f29910568fe\",\"license\":\"BUSL-1.1\"},\"contracts/oracle/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary ErrorTypes {\\n    /***********************************|\\n    |           FluidOracleL2           | \\n    |__________________________________*/\\n\\n    /// @notice thrown when sequencer on a L2 has an outage and grace period has not yet passed.\\n    uint256 internal constant FluidOracleL2__SequencerOutage = 60000;\\n\\n    /***********************************|\\n    |     UniV3CheckCLRSOracle          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when the delta between main price source and check rate source is exceeding the allowed delta\\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidPrice = 60001;\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidParams = 60002;\\n\\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\\n    uint256 internal constant UniV3CheckCLRSOracle__ExchangeRateZero = 60003;\\n\\n    /***********************************|\\n    |           FluidOracle             | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid info name is passed into a fluid oracle (e.g. not set or too long)\\n    uint256 internal constant FluidOracle__InvalidInfoName = 60010;\\n\\n    /***********************************|\\n    |            sUSDe Oracle           | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant SUSDeOracle__InvalidParams = 60102;\\n\\n    /***********************************|\\n    |           Pendle Oracle           | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant PendleOracle__InvalidParams = 60201;\\n\\n    /// @notice thrown when the Pendle market Oracle has not been initialized yet\\n    uint256 internal constant PendleOracle__MarketNotInitialized = 60202;\\n\\n    /// @notice thrown when the Pendle market does not have 18 decimals\\n    uint256 internal constant PendleOracle__MarketInvalidDecimals = 60203;\\n\\n    /// @notice thrown when the Pendle market returns an unexpected price\\n    uint256 internal constant PendleOracle__InvalidPrice = 60204;\\n\\n    /***********************************|\\n    |    CLRS2UniV3CheckCLRSOracleL2    | \\n    |__________________________________*/\\n\\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\\n    uint256 internal constant CLRS2UniV3CheckCLRSOracleL2__ExchangeRateZero = 60301;\\n\\n    /***********************************|\\n    |    Ratio2xFallbackCLRSOracleL2    | \\n    |__________________________________*/\\n\\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\\n    uint256 internal constant Ratio2xFallbackCLRSOracleL2__ExchangeRateZero = 60311;\\n\\n    /***********************************|\\n    |            WeETHsOracle           | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant WeETHsOracle__InvalidParams = 60321;\\n\\n    /***********************************|\\n    |          Chainlink Oracle         | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant ChainlinkOracle__InvalidParams = 61001;\\n\\n    /***********************************|\\n    |          UniswapV3 Oracle         | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant UniV3Oracle__InvalidParams = 62001;\\n\\n    /// @notice thrown when constructor is called with invalid ordered seconds agos values\\n    uint256 internal constant UniV3Oracle__InvalidSecondsAgos = 62002;\\n\\n    /// @notice thrown when constructor is called with invalid delta values > 100%\\n    uint256 internal constant UniV3Oracle__InvalidDeltas = 62003;\\n\\n    /***********************************|\\n    |            WstETh Oracle          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant WstETHOracle__InvalidParams = 63001;\\n\\n    /***********************************|\\n    |           Redstone Oracle         | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant RedstoneOracle__InvalidParams = 64001;\\n\\n    /***********************************|\\n    |          Fallback Oracle          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant FallbackOracle__InvalidParams = 65001;\\n\\n    /***********************************|\\n    |       FallbackCLRSOracle          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\\n    uint256 internal constant FallbackCLRSOracle__ExchangeRateZero = 66001;\\n\\n    /***********************************|\\n    |         WstETHCLRSOracle          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\\n    uint256 internal constant WstETHCLRSOracle__ExchangeRateZero = 67001;\\n\\n    /***********************************|\\n    |        CLFallbackUniV3Oracle      | \\n    |__________________________________*/\\n\\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\\n    uint256 internal constant CLFallbackUniV3Oracle__ExchangeRateZero = 68001;\\n\\n    /***********************************|\\n    |  WstETHCLRS2UniV3CheckCLRSOracle  | \\n    |__________________________________*/\\n\\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\\n    uint256 internal constant WstETHCLRS2UniV3CheckCLRSOracle__ExchangeRateZero = 69001;\\n\\n    /***********************************|\\n    |             WeETh Oracle          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant WeETHOracle__InvalidParams = 70001;\\n}\\n\",\"keccak256\":\"0x06ace30df91ca3848a99ee29faf9ea93197074f41b9bf25564e8d80c84339f77\",\"license\":\"BUSL-1.1\"},\"contracts/oracle/fluidOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidOracle } from \\\"./interfaces/iFluidOracle.sol\\\";\\nimport { ErrorTypes } from \\\"./errorTypes.sol\\\";\\nimport { Error as OracleError } from \\\"./error.sol\\\";\\n\\n/// @title   FluidOracle\\n/// @notice  Base contract that any Fluid Oracle must implement\\nabstract contract FluidOracle is IFluidOracle, OracleError {\\n    /// @dev short helper string to easily identify the oracle. E.g. token symbols\\n    //\\n    // using a bytes32 because string can not be immutable.\\n    bytes32 private immutable _infoName;\\n\\n    constructor(string memory infoName_) {\\n        if (bytes(infoName_).length > 32 || bytes(infoName_).length == 0) {\\n            revert FluidOracleError(ErrorTypes.FluidOracle__InvalidInfoName);\\n        }\\n\\n        // convert string to bytes32\\n        bytes32 infoNameBytes32_;\\n        assembly {\\n            infoNameBytes32_ := mload(add(infoName_, 32))\\n        }\\n        _infoName = infoNameBytes32_;\\n    }\\n\\n    /// @inheritdoc IFluidOracle\\n    function infoName() external view returns (string memory) {\\n        // convert bytes32 to string\\n        uint256 length_;\\n        while (length_ < 32 && _infoName[length_] != 0) {\\n            length_++;\\n        }\\n        bytes memory infoNameBytes_ = new bytes(length_);\\n        for (uint256 i; i < length_; i++) {\\n            infoNameBytes_[i] = _infoName[i];\\n        }\\n        return string(infoNameBytes_);\\n    }\\n\\n    /// @inheritdoc IFluidOracle\\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_);\\n\\n    /// @inheritdoc IFluidOracle\\n    function getExchangeRateOperate() external view virtual returns (uint256 exchangeRate_);\\n\\n    /// @inheritdoc IFluidOracle\\n    function getExchangeRateLiquidate() external view virtual returns (uint256 exchangeRate_);\\n}\\n\",\"keccak256\":\"0x2b56537a18379b4d7f69b9d95ebdb39e302951dbcaca882c27b4405bf1ea784b\",\"license\":\"BUSL-1.1\"},\"contracts/oracle/interfaces/iFluidOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IFluidOracle {\\n    /// @dev Deprecated. Use `getExchangeRateOperate()` and `getExchangeRateLiquidate()` instead. Only implemented for\\n    ///      backwards compatibility.\\n    function getExchangeRate() external view returns (uint256 exchangeRate_);\\n\\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for operates\\n    function getExchangeRateOperate() external view returns (uint256 exchangeRate_);\\n\\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for liquidations\\n    function getExchangeRateLiquidate() external view returns (uint256 exchangeRate_);\\n\\n    /// @notice helper string to easily identify the oracle. E.g. token symbols\\n    function infoName() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xeba2e991e41f8b68e2d639935931aadf39e15ea94ea7aa65b2fb3039d27dca63\",\"license\":\"MIT\"},\"contracts/periphery/resolvers/liquidity/iLiquidityResolver.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { Structs as LiquidityStructs } from \\\"../../../periphery/resolvers/liquidity/structs.sol\\\";\\n\\ninterface IFluidLiquidityResolver {\\n    /// @notice gets the `revenueAmount_` for a `token_`.\\n    function getRevenue(address token_) external view returns (uint256 revenueAmount_);\\n\\n    /// @notice address of contract that gets sent the revenue. Configurable by governance\\n    function getRevenueCollector() external view returns (address);\\n\\n    /// @notice Liquidity contract paused status: status = 1 -> normal. status = 2 -> paused.\\n    function getStatus() external view returns (uint256);\\n\\n    /// @notice checks if `auth_` is an allowed auth on Liquidity.\\n    /// Auths can set most config values. E.g. contracts that automate certain flows like e.g. adding a new fToken.\\n    /// Governance can add/remove auths. Governance is auth by default.\\n    function isAuth(address auth_) external view returns (uint256);\\n\\n    /// @notice checks if `guardian_` is an allowed Guardian on Liquidity.\\n    /// Guardians can pause lower class users.\\n    /// Governance can add/remove guardians. Governance is guardian by default.\\n    function isGuardian(address guardian_) external view returns (uint256);\\n\\n    /// @notice gets user class for `user_`. Class defines which protocols can be paused by guardians.\\n    /// Currently there are 2 classes: 0 can be paused by guardians. 1 cannot be paused by guardians.\\n    /// New protocols are added as class 0 and will be upgraded to 1 over time.\\n    function getUserClass(address user_) external view returns (uint256);\\n\\n    /// @notice gets exchangePricesAndConfig packed uint256 storage slot for `token_`.\\n    function getExchangePricesAndConfig(address token_) external view returns (uint256);\\n\\n    /// @notice gets rateConfig packed uint256 storage slot for `token_`.\\n    function getRateConfig(address token_) external view returns (uint256);\\n\\n    /// @notice gets totalAmounts packed uint256 storage slot for `token_`.\\n    function getTotalAmounts(address token_) external view returns (uint256);\\n\\n    /// @notice gets configs2 packed uint256 storage slot for `token_`.\\n    function getConfigs2(address token_) external view returns (uint256);\\n\\n    /// @notice gets userSupply data packed uint256 storage slot for `user_` and `token_`.\\n    function getUserSupply(address user_, address token_) external view returns (uint256);\\n\\n    /// @notice gets userBorrow data packed uint256 storage slot for `user_` and `token_`.\\n    function getUserBorrow(address user_, address token_) external view returns (uint256);\\n\\n    /// @notice returns all `listedTokens_` at the Liquidity contract. Once configured, a token can never be removed.\\n    function listedTokens() external view returns (address[] memory listedTokens_);\\n\\n    /// @notice get the Rate config data `rateData_` for a `token_` compiled from the packed uint256 rateConfig storage slot\\n    function getTokenRateData(address token_) external view returns (LiquidityStructs.RateData memory rateData_);\\n\\n    /// @notice get the Rate config datas `rateDatas_` for multiple `tokens_` compiled from the packed uint256 rateConfig storage slot\\n    function getTokensRateData(\\n        address[] calldata tokens_\\n    ) external view returns (LiquidityStructs.RateData[] memory rateDatas_);\\n\\n    /// @notice returns general data for `token_` such as rates, exchange prices, utilization, fee, total amounts etc.\\n    function getOverallTokenData(\\n        address token_\\n    ) external view returns (LiquidityStructs.OverallTokenData memory overallTokenData_);\\n\\n    /// @notice returns general data for multiple `tokens_` such as rates, exchange prices, utilization, fee, total amounts etc.\\n    function getOverallTokensData(\\n        address[] calldata tokens_\\n    ) external view returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\\n\\n    /// @notice returns general data for all `listedTokens()` such as rates, exchange prices, utilization, fee, total amounts etc.\\n    function getAllOverallTokensData()\\n        external\\n        view\\n        returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\\n\\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\\n    function getUserSupplyData(\\n        address user_,\\n        address token_\\n    )\\n        external\\n        view\\n        returns (\\n            LiquidityStructs.UserSupplyData memory userSupplyData_,\\n            LiquidityStructs.OverallTokenData memory overallTokenData_\\n        );\\n\\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\\n    function getUserMultipleSupplyData(\\n        address user_,\\n        address[] calldata tokens_\\n    )\\n        external\\n        view\\n        returns (\\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\\n        );\\n\\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\\n    function getUserBorrowData(\\n        address user_,\\n        address token_\\n    )\\n        external\\n        view\\n        returns (\\n            LiquidityStructs.UserBorrowData memory userBorrowData_,\\n            LiquidityStructs.OverallTokenData memory overallTokenData_\\n        );\\n\\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\\n    function getUserMultipleBorrowData(\\n        address user_,\\n        address[] calldata tokens_\\n    )\\n        external\\n        view\\n        returns (\\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\\n        );\\n\\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `supplyTokens_`\\n    ///     and returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `borrowTokens_`\\n    function getUserMultipleBorrowSupplyData(\\n        address user_,\\n        address[] calldata supplyTokens_,\\n        address[] calldata borrowTokens_\\n    )\\n        external\\n        view\\n        returns (\\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\\n            LiquidityStructs.OverallTokenData[] memory overallSupplyTokensData_,\\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\\n            LiquidityStructs.OverallTokenData[] memory overallBorrowTokensData_\\n        );\\n}\\n\",\"keccak256\":\"0x241d94b63793c9fb2111bb4ec04035e1fa14ee7e0551683ea05460baa6000189\",\"license\":\"MIT\"},\"contracts/periphery/resolvers/liquidity/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Structs as AdminModuleStructs } from \\\"../../../liquidity/adminModule/structs.sol\\\";\\n\\nabstract contract Structs {\\n    struct RateData {\\n        uint256 version;\\n        AdminModuleStructs.RateDataV1Params rateDataV1;\\n        AdminModuleStructs.RateDataV2Params rateDataV2;\\n    }\\n\\n    struct OverallTokenData {\\n        uint256 borrowRate;\\n        uint256 supplyRate;\\n        uint256 fee; // revenue fee\\n        uint256 lastStoredUtilization;\\n        uint256 storageUpdateThreshold;\\n        uint256 lastUpdateTimestamp;\\n        uint256 supplyExchangePrice;\\n        uint256 borrowExchangePrice;\\n        uint256 supplyRawInterest;\\n        uint256 supplyInterestFree;\\n        uint256 borrowRawInterest;\\n        uint256 borrowInterestFree;\\n        uint256 totalSupply;\\n        uint256 totalBorrow;\\n        uint256 revenue;\\n        uint256 maxUtilization; // maximum allowed utilization\\n        RateData rateData;\\n    }\\n\\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\\n    struct UserSupplyData {\\n        bool modeWithInterest; // true if mode = with interest, false = without interest\\n        uint256 supply; // user supply amount\\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\\n        uint256 withdrawalLimit;\\n        uint256 lastUpdateTimestamp;\\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\\n        uint256 baseWithdrawalLimit;\\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\\n        uint256 withdrawableUntilLimit;\\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\\n    }\\n\\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\\n    struct UserBorrowData {\\n        bool modeWithInterest; // true if mode = with interest, false = without interest\\n        uint256 borrow; // user borrow amount\\n        uint256 borrowLimit;\\n        uint256 lastUpdateTimestamp;\\n        uint256 expandPercent;\\n        uint256 expandDuration;\\n        uint256 baseBorrowLimit;\\n        uint256 maxBorrowLimit;\\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\\n    }\\n}\\n\",\"keccak256\":\"0xf8a59b6c7963d0bd43be07db0c594e278f97e6dfa498dee8436e3707dd9f574e\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vault/helpers.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Variables } from \\\"./variables.sol\\\";\\nimport { Structs } from \\\"./structs.sol\\\";\\nimport { TickMath } from \\\"../../../libraries/tickMath.sol\\\";\\nimport { BigMathMinified } from \\\"../../../libraries/bigMathMinified.sol\\\";\\n\\ncontract Helpers is Variables, Structs {\\n    function normalSlot(uint256 slot_) public pure returns (bytes32) {\\n        return bytes32(slot_);\\n    }\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping\\n    function calculateStorageSlotUintMapping(uint256 slot_, uint key_) public pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping\\n    function calculateStorageSlotIntMapping(uint256 slot_, int key_) public pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping\\n    function calculateDoubleIntUintMapping(uint256 slot_, int key1_, uint key2_) public pure returns (bytes32) {\\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\\n        return keccak256(abi.encode(key2_, intermediateSlot_));\\n    }\\n\\n    function tickHelper(uint tickRaw_) public pure returns (int tick) {\\n        require(tickRaw_ < X20, \\\"invalid-number\\\");\\n        if (tickRaw_ > 0) {\\n            tick = tickRaw_ & 1 == 1 ? int((tickRaw_ >> 1) & X19) : -int((tickRaw_ >> 1) & X19);\\n        } else {\\n            tick = type(int).min;\\n        }\\n    }\\n\\n    constructor(address factory_, address liquidityResolver_) Variables(factory_, liquidityResolver_) {}\\n}\\n\",\"keccak256\":\"0xe700c75c1f242f802b7bc429d1dc1bef84b93976c0d40fec83b39b41a0bd8ccf\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vault/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Helpers } from \\\"./helpers.sol\\\";\\nimport { TickMath } from \\\"../../../libraries/tickMath.sol\\\";\\nimport { BigMathMinified } from \\\"../../../libraries/bigMathMinified.sol\\\";\\nimport { IFluidOracle } from \\\"../../../oracle/fluidOracle.sol\\\";\\nimport { IFluidVault } from \\\"../../../protocols/vault/interfaces/iVault.sol\\\";\\nimport { IFluidVaultT1 } from \\\"../../../protocols/vault/interfaces/iVaultT1.sol\\\";\\nimport { Structs as FluidLiquidityResolverStructs } from \\\"../liquidity/structs.sol\\\";\\nimport { LiquiditySlotsLink } from \\\"../../../libraries/liquiditySlotsLink.sol\\\";\\nimport { LiquidityCalcs } from \\\"../../../libraries/liquidityCalcs.sol\\\";\\nimport { DexCalcs } from \\\"../../../libraries/dexCalcs.sol\\\";\\nimport { DexSlotsLink } from \\\"../../../libraries/dexSlotsLink.sol\\\";\\nimport { AddressCalcs } from \\\"../../../libraries/addressCalcs.sol\\\";\\nimport { IFluidStorageReadable } from \\\"./variables.sol\\\";\\nimport { FluidProtocolTypes } from \\\"../../../libraries/fluidProtocolTypes.sol\\\";\\n\\ninterface TokenInterface {\\n    function balanceOf(address) external view returns (uint);\\n}\\n\\ninterface IZtakingPool {\\n    function balance(address token_, address staker_) external view returns (uint256);\\n}\\n\\n/// @notice Fluid Vault protocol resolver\\n/// Implements various view-only methods to give easy access to Vault protocol data.\\ncontract FluidVaultResolver is Helpers {\\n    constructor(address factory_, address liquidityResolver_) Helpers(factory_, liquidityResolver_) {}\\n\\n    /// @notice Get the address of a vault.\\n    /// @param vaultId_ The ID of the vault.\\n    /// @return vault_ The address of the vault.\\n    function getVaultAddress(uint vaultId_) public view returns (address vault_) {\\n        return AddressCalcs.addressCalc(address(FACTORY), vaultId_);\\n    }\\n\\n    /// @notice Get the type of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @return vaultType_ The type of the vault. 0 if not a Fluid vault.\\n    function getVaultType(address vault_) public view returns (uint vaultType_) {\\n        if (vault_.code.length == 0) {\\n            return 0;\\n        }\\n        try IFluidVault(vault_).TYPE() returns (uint type_) {\\n            return type_;\\n        } catch {\\n            if (getVaultAddress(getVaultId(vault_)) != vault_) {\\n                return 0;\\n            }\\n            // if TYPE() is not available but address is valid vault id, it must be vault T1\\n            return FluidProtocolTypes.VAULT_T1_TYPE;\\n        }\\n    }\\n\\n    /// @notice Get the ID of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @return id_ The ID of the vault.\\n    function getVaultId(address vault_) public view returns (uint id_) {\\n        id_ = IFluidVault(vault_).VAULT_ID();\\n    }\\n\\n    /// @notice Get the token configuration.\\n    /// @param nftId_ The ID of the NFT.\\n    /// @return The token configuration.\\n    function getTokenConfig(uint nftId_) public view returns (uint) {\\n        return FACTORY.readFromStorage(calculateStorageSlotUintMapping(3, nftId_));\\n    }\\n\\n    /// @notice Get the raw variables of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @return The raw variables of the vault.\\n    function getVaultVariablesRaw(address vault_) public view returns (uint) {\\n        return IFluidVault(vault_).readFromStorage(normalSlot(0));\\n    }\\n\\n    /// @notice Get the raw variables of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @return The raw variables of the vault.\\n    function getVaultVariables2Raw(address vault_) public view returns (uint) {\\n        return IFluidVault(vault_).readFromStorage(normalSlot(1));\\n    }\\n\\n    /// @notice Get the absorbed liquidity of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @return The absorbed liquidity of the vault.\\n    function getAbsorbedLiquidityRaw(address vault_) public view returns (uint) {\\n        return IFluidVault(vault_).readFromStorage(normalSlot(2));\\n    }\\n\\n    /// @notice Get the position data of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @param positionId_ The ID of the position.\\n    /// @return The position data of the vault.\\n    function getPositionDataRaw(address vault_, uint positionId_) public view returns (uint) {\\n        return IFluidVault(vault_).readFromStorage(calculateStorageSlotUintMapping(3, positionId_));\\n    }\\n\\n    /// @notice Get the raw tick data of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @param tick_ The tick value.\\n    /// @return The raw tick data of the vault.\\n    // if tick > 0 then key_ = tick / 256\\n    // if tick < 0 then key_ = (tick / 256) - 1\\n    function getTickDataRaw(address vault_, int tick_) public view returns (uint) {\\n        return IFluidVault(vault_).readFromStorage(calculateStorageSlotIntMapping(5, tick_));\\n    }\\n\\n    /// @notice Get the raw tick data of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @param key_ The tick key.\\n    /// @return The raw tick data of the vault.\\n    function getTickHasDebtRaw(address vault_, int key_) public view returns (uint) {\\n        return IFluidVault(vault_).readFromStorage(calculateStorageSlotIntMapping(4, key_));\\n    }\\n\\n    /// @notice Get the raw tick data of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @param tick_ The tick value.\\n    /// @param id_ The ID of the tick.\\n    /// @return The raw tick data of the vault.\\n    // id_ = (realId_ / 3) + 1\\n    function getTickIdDataRaw(address vault_, int tick_, uint id_) public view returns (uint) {\\n        return IFluidVault(vault_).readFromStorage(calculateDoubleIntUintMapping(6, tick_, id_));\\n    }\\n\\n    /// @notice Get the raw branch data of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @param branch_ The branch value.\\n    /// @return The raw branch data of the vault.\\n    function getBranchDataRaw(address vault_, uint branch_) public view returns (uint) {\\n        return IFluidVault(vault_).readFromStorage(calculateStorageSlotUintMapping(7, branch_));\\n    }\\n\\n    /// @notice Get the raw rate of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @return The raw rate of the vault.\\n    function getRateRaw(address vault_) public view returns (uint) {\\n        return IFluidVault(vault_).readFromStorage(normalSlot(8));\\n    }\\n\\n    /// @notice Get the rebalancer of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @return The rebalancer of the vault.\\n    function getRebalancer(address vault_) public view returns (address) {\\n        return address(uint160(IFluidVault(vault_).readFromStorage(normalSlot(9))));\\n    }\\n\\n    /// @notice Get the absorbed dust debt of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @return The absorbed dust debt of the vault.\\n    function getAbsorbedDustDebt(address vault_) public view returns (uint) {\\n        return IFluidVault(vault_).readFromStorage(normalSlot(10));\\n    }\\n\\n    /// @notice Get the DEX from address of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @return The DEX from address of the vault.\\n    function getDexFromAddress(address vault_) public view returns (address) {\\n        return address(uint160(IFluidVault(vault_).readFromStorage(normalSlot(11))));\\n    }\\n\\n    /// @notice Get the total number of vaults.\\n    /// @return The total number of vaults.\\n    function getTotalVaults() public view returns (uint) {\\n        return FACTORY.totalVaults();\\n    }\\n\\n    /// @notice Get the addresses of all the vaults.\\n    /// @return vaults_ The addresses of all the vaults.\\n    function getAllVaultsAddresses() public view returns (address[] memory vaults_) {\\n        uint totalVaults_ = getTotalVaults();\\n        vaults_ = new address[](totalVaults_);\\n        for (uint i = 0; i < totalVaults_; i++) {\\n            vaults_[i] = getVaultAddress((i + 1));\\n        }\\n    }\\n\\n    /// @notice Get the contract for deployer index of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @param index_ The index of the deployer.\\n    /// @return The contract for deployer index of the vault.\\n    function getContractForDeployerIndex(address vault_, uint index_) public view returns (address) {\\n        IFluidVault.ConstantViews memory constants_ = _getVaultConstants(vault_, getVaultType(vault_));\\n        if (constants_.deployer == address(0) || index_ == 0) {\\n            return address(0);\\n        }\\n        return AddressCalcs.addressCalc(constants_.deployer, index_);\\n    }\\n\\n    /// @dev Get the constants of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @param vaultType_ The type of the vault.\\n    /// @return constants_ The constants of the vault.\\n    function _getVaultConstants(\\n        address vault_,\\n        uint vaultType_\\n    ) internal view returns (IFluidVault.ConstantViews memory constants_) {\\n        if (vaultType_ == FluidProtocolTypes.VAULT_T1_TYPE) {\\n            try IFluidVaultT1(vault_).constantsView() returns (IFluidVaultT1.ConstantViews memory constantsT1_) {\\n                constants_.liquidity = constantsT1_.liquidity;\\n                constants_.factory = constantsT1_.factory;\\n                constants_.operateImplementation = address(vault_);\\n                constants_.adminImplementation = constantsT1_.adminImplementation;\\n                constants_.secondaryImplementation = constantsT1_.secondaryImplementation;\\n                constants_.deployer = address(0);\\n                constants_.supply = constantsT1_.liquidity;\\n                constants_.borrow = constantsT1_.liquidity;\\n                constants_.supplyToken.token0 = constantsT1_.supplyToken;\\n                constants_.supplyToken.token1 = address(0);\\n                constants_.borrowToken.token0 = constantsT1_.borrowToken;\\n                constants_.borrowToken.token1 = address(0);\\n                constants_.vaultId = constantsT1_.vaultId;\\n                constants_.vaultType = FluidProtocolTypes.VAULT_T1_TYPE;\\n                constants_.supplyExchangePriceSlot = constantsT1_.liquiditySupplyExchangePriceSlot;\\n                constants_.borrowExchangePriceSlot = constantsT1_.liquidityBorrowExchangePriceSlot;\\n                constants_.userSupplySlot = constantsT1_.liquidityUserSupplySlot;\\n                constants_.userBorrowSlot = constantsT1_.liquidityUserBorrowSlot;\\n            } catch {\\n                // vault address is likely not a fluid vault or not deployed yet etc.\\n                // vault type is detected as being T1 when TYPE() is not present, which could also happen\\n                // on non-Fluid-vault contracts\\n            }\\n        } else {\\n            constants_ = IFluidVault(vault_).constantsView();\\n        }\\n    }\\n\\n    /// @dev Get the configuration of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @param vaultType_ The type of the vault.\\n    /// @return configs_ The configuration of the vault.\\n    function _getVaultConfig(address vault_, uint vaultType_) internal view returns (Configs memory configs_) {\\n        uint vaultVariables2_ = getVaultVariables2Raw(vault_);\\n        configs_.supplyRateMagnifier = uint16(vaultVariables2_ & X16);\\n        configs_.borrowRateMagnifier = uint16((vaultVariables2_ >> 16) & X16);\\n        configs_.collateralFactor = (uint16((vaultVariables2_ >> 32) & X10)) * 10;\\n        configs_.liquidationThreshold = (uint16((vaultVariables2_ >> 42) & X10)) * 10;\\n        configs_.liquidationMaxLimit = (uint16((vaultVariables2_ >> 52) & X10) * 10);\\n        configs_.withdrawalGap = uint16((vaultVariables2_ >> 62) & X10) * 10;\\n        configs_.liquidationPenalty = uint16((vaultVariables2_ >> 72) & X10);\\n        configs_.borrowFee = uint16((vaultVariables2_ >> 82) & X10);\\n\\n        if (vaultType_ == FluidProtocolTypes.VAULT_T1_TYPE) {\\n            configs_.oracle = address(uint160(vaultVariables2_ >> 96));\\n        } else {\\n            /// Next 30 bits => 92-121 => bits to calculate address of oracle\\n            uint index_ = (vaultVariables2_ >> 92) & X30;\\n            if (index_ > 0) {\\n                configs_.oracle = getContractForDeployerIndex(vault_, index_);\\n            }\\n            /// Next 33 bits => 122-154 => last update timestamp\\n            configs_.lastUpdateTimestamp = uint((vaultVariables2_ >> 122) & X33);\\n        }\\n\\n        if (configs_.oracle != address(0)) {\\n            try IFluidOracle(configs_.oracle).getExchangeRateOperate() returns (uint exchangeRate_) {\\n                configs_.oraclePriceOperate = exchangeRate_;\\n                configs_.oraclePriceLiquidate = IFluidOracle(configs_.oracle).getExchangeRateLiquidate();\\n            } catch {\\n                // deprecated backward compatible for older vaults oracles\\n                configs_.oraclePriceOperate = IFluidOracle(configs_.oracle).getExchangeRate();\\n                configs_.oraclePriceLiquidate = configs_.oraclePriceOperate;\\n            }\\n        }\\n\\n        configs_.rebalancer = getRebalancer(vault_);\\n    }\\n\\n    /// @dev Get the exchange prices and rates of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @param vaultType_ The type of the vault.\\n    /// @param configs_ The configuration of the vault.\\n    /// @param liquiditySupplyRate_ The liquidity supply rate, only set in case of NOT smart collateral.\\n    /// @param liquidityBorrowRate_ The liquidity borrow rate, only set in case of NOT smart debt.\\n    /// @return exchangePricesAndRates_ The exchange prices and rates of the vault.\\n    function _getExchangePricesAndRates(\\n        address vault_,\\n        uint vaultType_,\\n        Configs memory configs_,\\n        uint liquiditySupplyRate_,\\n        uint liquidityBorrowRate_\\n    ) internal view returns (ExchangePricesAndRates memory exchangePricesAndRates_) {\\n        uint exchangePrices_ = getRateRaw(vault_);\\n        exchangePricesAndRates_.lastStoredLiquiditySupplyExchangePrice = exchangePrices_ & X64;\\n        exchangePricesAndRates_.lastStoredLiquidityBorrowExchangePrice = (exchangePrices_ >> 64) & X64;\\n        exchangePricesAndRates_.lastStoredVaultSupplyExchangePrice = (exchangePrices_ >> 128) & X64;\\n        exchangePricesAndRates_.lastStoredVaultBorrowExchangePrice = (exchangePrices_ >> 192) & X64;\\n\\n        (\\n            exchangePricesAndRates_.liquiditySupplyExchangePrice,\\n            exchangePricesAndRates_.liquidityBorrowExchangePrice,\\n            exchangePricesAndRates_.vaultSupplyExchangePrice,\\n            exchangePricesAndRates_.vaultBorrowExchangePrice\\n        ) = IFluidVault(vault_).updateExchangePrices(getVaultVariables2Raw(vault_));\\n\\n        exchangePricesAndRates_.supplyRateLiquidity = liquiditySupplyRate_;\\n        exchangePricesAndRates_.borrowRateLiquidity = liquidityBorrowRate_;\\n\\n        if (\\n            vaultType_ == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE ||\\n            vaultType_ == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\\n        ) {\\n            // in case of smart collateral supply magnifier bits stores supply interest rate positive or negative\\n            // negative meaning charging users, positive means incentivizing users\\n            exchangePricesAndRates_.supplyRateVault = int256((configs_.supplyRateMagnifier >> 1) & X15);\\n            // if first bit == 1 then positive else negative\\n            if ((configs_.supplyRateMagnifier & 1) == 0) {\\n                exchangePricesAndRates_.supplyRateVault = -exchangePricesAndRates_.supplyRateVault;\\n            }\\n            exchangePricesAndRates_.rewardsOrFeeRateSupply = exchangePricesAndRates_.supplyRateVault;\\n        } else {\\n            // NOT smart col\\n            unchecked {\\n                exchangePricesAndRates_.supplyRateVault = int256(\\n                    (liquiditySupplyRate_ * configs_.supplyRateMagnifier) / 10000\\n                );\\n                exchangePricesAndRates_.rewardsOrFeeRateSupply = int256(uint(configs_.supplyRateMagnifier)) - 10000;\\n            }\\n        }\\n\\n        if (\\n            vaultType_ == FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE ||\\n            vaultType_ == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\\n        ) {\\n            // in case of smart debt borrow magnifier bits stores borrow interest rate positive or negative\\n            // negative meaning incentivizing users, positive means charging users\\n            exchangePricesAndRates_.borrowRateVault = int256((configs_.borrowRateMagnifier >> 1) & X15);\\n            // if first bit == 1 then positive else negative\\n            if ((configs_.borrowRateMagnifier & 1) == 0) {\\n                exchangePricesAndRates_.borrowRateVault = -exchangePricesAndRates_.borrowRateVault;\\n            }\\n            exchangePricesAndRates_.rewardsOrFeeRateBorrow = exchangePricesAndRates_.borrowRateVault;\\n        } else {\\n            unchecked {\\n                // NOT smart debt\\n                exchangePricesAndRates_.borrowRateVault = int256(\\n                    (liquidityBorrowRate_ * configs_.borrowRateMagnifier) / 10000\\n                );\\n                exchangePricesAndRates_.rewardsOrFeeRateBorrow = int256(uint(configs_.borrowRateMagnifier)) - 10000;\\n            }\\n        }\\n    }\\n\\n    /// @dev Get the total supply and borrow of a vault.\\n    /// @param vault_ The address of the vault.\\n    /// @param exchangePricesAndRates_ The exchange prices and rates of the vault.\\n    /// @param constantsVariables_ The constants and variables of the vault.\\n    /// @return totalSupplyAndBorrow_ The total supply and borrow of the vault.\\n    function _getTotalSupplyAndBorrow(\\n        address vault_,\\n        ExchangePricesAndRates memory exchangePricesAndRates_,\\n        IFluidVault.ConstantViews memory constantsVariables_\\n    ) internal view returns (TotalSupplyAndBorrow memory totalSupplyAndBorrow_) {\\n        uint vaultVariables_ = getVaultVariablesRaw(vault_);\\n        uint absorbedLiquidity_ = getAbsorbedLiquidityRaw(vault_);\\n        uint totalSupplyLiquidityOrDex_ = IFluidStorageReadable(constantsVariables_.supply).readFromStorage(\\n            constantsVariables_.userSupplySlot\\n        );\\n        // extracting user's supply\\n        if (constantsVariables_.supplyToken.token1 == address(0)) {\\n            totalSupplyLiquidityOrDex_ =\\n                (totalSupplyLiquidityOrDex_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) &\\n                X64;\\n        } else {\\n            totalSupplyLiquidityOrDex_ = (totalSupplyLiquidityOrDex_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\\n        }\\n        // converting big number into normal number\\n        totalSupplyLiquidityOrDex_ = (totalSupplyLiquidityOrDex_ >> 8) << (totalSupplyLiquidityOrDex_ & X8);\\n\\n        uint totalBorrowLiquidityOrDex_ = IFluidStorageReadable(constantsVariables_.borrow).readFromStorage(\\n            constantsVariables_.userBorrowSlot\\n        );\\n        // extracting user's borrow\\n        if (constantsVariables_.borrowToken.token1 == address(0)) {\\n            totalBorrowLiquidityOrDex_ =\\n                (totalBorrowLiquidityOrDex_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) &\\n                X64;\\n        } else {\\n            totalBorrowLiquidityOrDex_ = (totalBorrowLiquidityOrDex_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\\n        }\\n        // converting big number into normal number\\n        totalBorrowLiquidityOrDex_ = (totalBorrowLiquidityOrDex_ >> 8) << (totalBorrowLiquidityOrDex_ & X8);\\n\\n        totalSupplyAndBorrow_.totalSupplyVault = (vaultVariables_ >> 82) & X64;\\n        // Converting bignumber into normal number\\n        totalSupplyAndBorrow_.totalSupplyVault =\\n            (totalSupplyAndBorrow_.totalSupplyVault >> 8) <<\\n            (totalSupplyAndBorrow_.totalSupplyVault & X8);\\n        totalSupplyAndBorrow_.totalBorrowVault = (vaultVariables_ >> 146) & X64;\\n        // Converting bignumber into normal number\\n        totalSupplyAndBorrow_.totalBorrowVault =\\n            (totalSupplyAndBorrow_.totalBorrowVault >> 8) <<\\n            (totalSupplyAndBorrow_.totalBorrowVault & X8);\\n\\n        totalSupplyAndBorrow_.totalSupplyLiquidityOrDex = totalSupplyLiquidityOrDex_;\\n        totalSupplyAndBorrow_.totalBorrowLiquidityOrDex = totalBorrowLiquidityOrDex_;\\n\\n        totalSupplyAndBorrow_.absorbedBorrow = absorbedLiquidity_ & X128;\\n        totalSupplyAndBorrow_.absorbedSupply = absorbedLiquidity_ >> 128;\\n\\n        unchecked {\\n            // converting raw total supply & total borrow into normal amounts\\n            totalSupplyAndBorrow_.totalSupplyVault =\\n                (totalSupplyAndBorrow_.totalSupplyVault * exchangePricesAndRates_.vaultSupplyExchangePrice) /\\n                EXCHANGE_PRICES_PRECISION;\\n            totalSupplyAndBorrow_.totalBorrowVault =\\n                (totalSupplyAndBorrow_.totalBorrowVault * exchangePricesAndRates_.vaultBorrowExchangePrice) /\\n                EXCHANGE_PRICES_PRECISION;\\n\\n            // below logic multiply with liquidity exchange price also works for case of smart debt / smart col because\\n            // liquiditySupplyExchangePrice and liquidityBorrowExchangePrice will be EXCHANGE_PRICES_PRECISION\\n            totalSupplyAndBorrow_.totalSupplyLiquidityOrDex =\\n                (totalSupplyAndBorrow_.totalSupplyLiquidityOrDex *\\n                    exchangePricesAndRates_.liquiditySupplyExchangePrice) /\\n                EXCHANGE_PRICES_PRECISION;\\n            totalSupplyAndBorrow_.totalBorrowLiquidityOrDex =\\n                (totalSupplyAndBorrow_.totalBorrowLiquidityOrDex *\\n                    exchangePricesAndRates_.liquidityBorrowExchangePrice) /\\n                EXCHANGE_PRICES_PRECISION;\\n\\n            totalSupplyAndBorrow_.absorbedSupply =\\n                (totalSupplyAndBorrow_.absorbedSupply * exchangePricesAndRates_.vaultSupplyExchangePrice) /\\n                EXCHANGE_PRICES_PRECISION;\\n            totalSupplyAndBorrow_.absorbedBorrow =\\n                (totalSupplyAndBorrow_.absorbedBorrow * exchangePricesAndRates_.vaultBorrowExchangePrice) /\\n                EXCHANGE_PRICES_PRECISION;\\n        }\\n    }\\n\\n    address private constant WEETH = 0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee;\\n    address private constant WEETHS = 0x917ceE801a67f933F2e6b33fC0cD1ED2d5909D88;\\n    IZtakingPool private constant ZIRCUIT = IZtakingPool(0xF047ab4c75cebf0eB9ed34Ae2c186f3611aEAfa6);\\n\\n    /// @dev Calculates limits and availability for a user's vault operations.\\n    /// @param exchangePricesAndRates_ Exchange prices and rates for the vault.\\n    /// @param constantsVariables_ Constants and variables for the vault.\\n    /// @param withdrawalGapConfig_ Configuration for the withdrawal gap.\\n    /// @param borrowLimit_ The borrow limit for the user. Only set if not smart debt.\\n    /// @param borrowLimitUtilization_ The utilization of the borrow limit. Only set if not smart debt.\\n    /// @param borrowableUntilLimit_ The limit until which borrowing is allowed. Only set if not smart debt.\\n    /// @return limitsAndAvailability_ The calculated limits and availability for the user's vault operations.\\n    function _getLimitsAndAvailability(\\n        ExchangePricesAndRates memory exchangePricesAndRates_,\\n        IFluidVault.ConstantViews memory constantsVariables_,\\n        uint withdrawalGapConfig_,\\n        uint borrowLimit_,\\n        uint borrowLimitUtilization_,\\n        uint borrowableUntilLimit_\\n    ) internal view returns (LimitsAndAvailability memory limitsAndAvailability_) {\\n        // fetching user's supply slot data\\n        uint userSupplyLiquidityOrDexData_ = IFluidStorageReadable(constantsVariables_.supply).readFromStorage(\\n            constantsVariables_.userSupplySlot\\n        );\\n        if (userSupplyLiquidityOrDexData_ > 0) {\\n            uint userSupply_;\\n            uint supplyLimitRaw_;\\n            if (constantsVariables_.supply == address(constantsVariables_.liquidity)) {\\n                userSupply_ = (userSupplyLiquidityOrDexData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\\n                userSupply_ = (userSupply_ >> 8) << (userSupply_ & X8);\\n\\n                supplyLimitRaw_ = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(\\n                    userSupplyLiquidityOrDexData_,\\n                    userSupply_\\n                );\\n            } else {\\n                // smart col -> using Dex libraries\\n                userSupply_ = (userSupplyLiquidityOrDexData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\\n                userSupply_ = (userSupply_ >> 8) << (userSupply_ & X8);\\n\\n                supplyLimitRaw_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyLiquidityOrDexData_, userSupply_);\\n            }\\n\\n            unchecked {\\n                // liquiditySupplyExchangePrice is EXCHANGE_PRICES_PRECISION in case of smart col\\n                limitsAndAvailability_.withdrawLimit =\\n                    (supplyLimitRaw_ * exchangePricesAndRates_.liquiditySupplyExchangePrice) /\\n                    EXCHANGE_PRICES_PRECISION;\\n\\n                // totalSupplyLiquidityOrDex = user supply\\n                limitsAndAvailability_.withdrawableUntilLimit = userSupply_ > limitsAndAvailability_.withdrawLimit\\n                    ? userSupply_ - limitsAndAvailability_.withdrawLimit\\n                    : 0;\\n\\n                uint withdrawalGap_ = limitsAndAvailability_.withdrawLimit == 0\\n                    ? 0 // apply withdrawal gap only if withdraw limit is actually active (not below base limit)\\n                    : (userSupply_ * withdrawalGapConfig_) / 1e4;\\n\\n                limitsAndAvailability_.withdrawableUntilLimit = (limitsAndAvailability_.withdrawableUntilLimit >\\n                    withdrawalGap_)\\n                    ? (((limitsAndAvailability_.withdrawableUntilLimit - withdrawalGap_) * 999999) / 1000000)\\n                    : 0;\\n            }\\n\\n            limitsAndAvailability_.withdrawable = limitsAndAvailability_.withdrawableUntilLimit;\\n            if (constantsVariables_.supplyToken.token1 == address(0)) {\\n                // NOT smart col -> check withdrawableUntilLimit against available balance at Liquidity\\n                // if smart col -> must check manually against balances using data returned at DexResolver\\n                uint balanceOf_;\\n                if (constantsVariables_.supplyToken.token0 == NATIVE_TOKEN_ADDRESS) {\\n                    balanceOf_ = address(constantsVariables_.liquidity).balance;\\n                } else {\\n                    balanceOf_ = TokenInterface(constantsVariables_.supplyToken.token0).balanceOf(\\n                        address(constantsVariables_.liquidity)\\n                    );\\n                    if (constantsVariables_.supplyToken.token0 == WEETH) {\\n                        unchecked {\\n                            balanceOf_ += ZIRCUIT.balance(WEETH, address(constantsVariables_.liquidity));\\n                        }\\n                    }\\n                    if (constantsVariables_.supplyToken.token0 == WEETHS) {\\n                        unchecked {\\n                            balanceOf_ += ZIRCUIT.balance(WEETHS, address(constantsVariables_.liquidity));\\n                        }\\n                    }\\n                }\\n                if (balanceOf_ < limitsAndAvailability_.withdrawableUntilLimit) {\\n                    limitsAndAvailability_.withdrawable = balanceOf_;\\n                }\\n            }\\n        }\\n\\n        uint userBorrowLiquidityOrDexData_ = IFluidStorageReadable(constantsVariables_.borrow).readFromStorage(\\n            constantsVariables_.userBorrowSlot\\n        );\\n        if (userBorrowLiquidityOrDexData_ > 0) {\\n            if (constantsVariables_.borrowToken.token1 == address(0)) {\\n                // NOT smart debt. fetch limit from LiquidityResolver\\n\\n                limitsAndAvailability_.borrowLimit = borrowLimit_;\\n                limitsAndAvailability_.borrowLimitUtilization = borrowLimitUtilization_;\\n\\n                unchecked {\\n                    limitsAndAvailability_.borrowableUntilLimit = (borrowableUntilLimit_ * 999999) / 1000000;\\n                }\\n\\n                uint balanceOf_;\\n                if (constantsVariables_.borrowToken.token0 == NATIVE_TOKEN_ADDRESS) {\\n                    balanceOf_ = address(constantsVariables_.liquidity).balance;\\n                } else {\\n                    balanceOf_ = TokenInterface(constantsVariables_.borrowToken.token0).balanceOf(\\n                        address(constantsVariables_.liquidity)\\n                    );\\n                }\\n                limitsAndAvailability_.borrowable = balanceOf_ > limitsAndAvailability_.borrowableUntilLimit\\n                    ? limitsAndAvailability_.borrowableUntilLimit\\n                    : balanceOf_;\\n            } else {\\n                // smart debt -> using Dex libraries\\n                uint userBorrow_ = (userBorrowLiquidityOrDexData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\\n                userBorrow_ = (userBorrow_ >> 8) << (userBorrow_ & X8);\\n\\n                limitsAndAvailability_.borrowLimit = DexCalcs.calcBorrowLimitBeforeOperate(\\n                    userBorrowLiquidityOrDexData_,\\n                    userBorrow_\\n                );\\n\\n                unchecked {\\n                    limitsAndAvailability_.borrowableUntilLimit = limitsAndAvailability_.borrowLimit > userBorrow_\\n                        ? limitsAndAvailability_.borrowLimit - userBorrow_\\n                        : 0;\\n\\n                    limitsAndAvailability_.borrowableUntilLimit =\\n                        (limitsAndAvailability_.borrowableUntilLimit * 999999) /\\n                        1000000;\\n                }\\n\\n                limitsAndAvailability_.borrowable = limitsAndAvailability_.borrowableUntilLimit;\\n            }\\n        }\\n\\n        limitsAndAvailability_.minimumBorrowing =\\n            (10001 * exchangePricesAndRates_.vaultBorrowExchangePrice) /\\n            EXCHANGE_PRICES_PRECISION;\\n    }\\n\\n    /// @notice Retrieves the state of a given vault.\\n    /// @param vault_ The address of the vault to retrieve the state for.\\n    /// @return vaultState_ The state of the vault, including top tick, current and total branches,\\n    ///                     total supply and borrow, total positions, and current branch state.\\n    function getVaultState(address vault_) public view returns (VaultState memory vaultState_) {\\n        uint vaultVariables_ = getVaultVariablesRaw(vault_);\\n\\n        vaultState_.topTick = tickHelper(((vaultVariables_ >> 2) & X20));\\n        vaultState_.currentBranch = (vaultVariables_ >> 22) & X30;\\n        vaultState_.totalBranch = (vaultVariables_ >> 52) & X30;\\n        vaultState_.totalSupply = BigMathMinified.fromBigNumber((vaultVariables_ >> 82) & X64, 8, X8);\\n        vaultState_.totalBorrow = BigMathMinified.fromBigNumber((vaultVariables_ >> 146) & X64, 8, X8);\\n        vaultState_.totalPositions = (vaultVariables_ >> 210) & X32;\\n\\n        uint currentBranchData_ = getBranchDataRaw(vault_, vaultState_.currentBranch);\\n        vaultState_.currentBranchState.status = currentBranchData_ & 3;\\n        vaultState_.currentBranchState.minimaTick = tickHelper(((currentBranchData_ >> 2) & X20));\\n        vaultState_.currentBranchState.debtFactor = (currentBranchData_ >> 116) & X50;\\n        vaultState_.currentBranchState.partials = (currentBranchData_ >> 22) & X30;\\n        vaultState_.currentBranchState.debtLiquidity = BigMathMinified.fromBigNumber(\\n            (currentBranchData_ >> 52) & X64,\\n            8,\\n            X8\\n        );\\n        vaultState_.currentBranchState.baseBranchId = (currentBranchData_ >> 166) & X30;\\n        vaultState_.currentBranchState.baseBranchMinima = tickHelper(((currentBranchData_ >> 196) & X20));\\n    }\\n\\n    /// @notice Retrieves the entire data for a given vault.\\n    /// @param vault_ The address of the vault to retrieve the data for.\\n    /// @return vaultData_ The entire data of the vault.\\n    function getVaultEntireData(address vault_) public view returns (VaultEntireData memory vaultData_) {\\n        vaultData_.vault = vault_;\\n        uint vaultType_ = getVaultType(vault_);\\n\\n        if (vaultType_ != 0) {\\n            vaultData_.constantVariables = _getVaultConstants(vault_, vaultType_);\\n\\n            // in case of NOT smart debt, the borrow limits are fetched from liquidity resolver\\n            uint borrowLimit_;\\n            uint borrowLimitUtilization_;\\n            uint borrowableUntilLimit_;\\n\\n            {\\n                uint liquiditySupplyRate_;\\n                uint liquidityBorrowRate_;\\n                if (vaultData_.constantVariables.supplyToken.token1 == address(0)) {\\n                    // NOT smart col\\n                    (\\n                        FluidLiquidityResolverStructs.UserSupplyData memory liquidityUserSupplyData_,\\n                        FluidLiquidityResolverStructs.OverallTokenData memory liquiditySupplyTokenData_\\n                    ) = LIQUIDITY_RESOLVER.getUserSupplyData(vault_, vaultData_.constantVariables.supplyToken.token0);\\n\\n                    vaultData_.liquidityUserSupplyData = liquidityUserSupplyData_;\\n\\n                    liquiditySupplyRate_ = liquiditySupplyTokenData_.supplyRate;\\n                }\\n\\n                if (vaultData_.constantVariables.borrowToken.token1 == address(0)) {\\n                    // NOT smart debt\\n                    (\\n                        FluidLiquidityResolverStructs.UserBorrowData memory liquidityUserBorrowData_,\\n                        FluidLiquidityResolverStructs.OverallTokenData memory liquidityBorrowTokenData_\\n                    ) = LIQUIDITY_RESOLVER.getUserBorrowData(vault_, vaultData_.constantVariables.borrowToken.token0);\\n\\n                    vaultData_.liquidityUserBorrowData = liquidityUserBorrowData_;\\n\\n                    liquidityBorrowRate_ = liquidityBorrowTokenData_.borrowRate;\\n\\n                    borrowLimit_ = liquidityUserBorrowData_.borrowLimit;\\n                    borrowLimitUtilization_ = liquidityUserBorrowData_.borrowLimitUtilization;\\n                    borrowableUntilLimit_ = liquidityUserBorrowData_.borrowableUntilLimit;\\n                }\\n\\n                vaultData_.configs = _getVaultConfig(vault_, vaultData_.constantVariables.vaultType);\\n                vaultData_.exchangePricesAndRates = _getExchangePricesAndRates(\\n                    vault_,\\n                    vaultType_,\\n                    vaultData_.configs,\\n                    liquiditySupplyRate_,\\n                    liquidityBorrowRate_\\n                );\\n            }\\n            vaultData_.totalSupplyAndBorrow = _getTotalSupplyAndBorrow(\\n                vault_,\\n                vaultData_.exchangePricesAndRates,\\n                vaultData_.constantVariables\\n            );\\n            vaultData_.limitsAndAvailability = _getLimitsAndAvailability(\\n                vaultData_.exchangePricesAndRates,\\n                vaultData_.constantVariables,\\n                vaultData_.configs.withdrawalGap,\\n                borrowLimit_,\\n                borrowLimitUtilization_,\\n                borrowableUntilLimit_\\n            );\\n            vaultData_.vaultState = getVaultState(vault_);\\n        }\\n    }\\n\\n    /// @notice Retrieves the entire data for a list of vaults.\\n    /// @param vaults_ The list of vault addresses.\\n    /// @return vaultsData_ An array of VaultEntireData structures containing the data for each vault.\\n    function getVaultsEntireData(\\n        address[] memory vaults_\\n    ) external view returns (VaultEntireData[] memory vaultsData_) {\\n        uint length_ = vaults_.length;\\n        vaultsData_ = new VaultEntireData[](length_);\\n        for (uint i; i < length_; i++) {\\n            vaultsData_[i] = getVaultEntireData(vaults_[i]);\\n        }\\n    }\\n\\n    /// @notice Retrieves the entire data for all vaults.\\n    /// @return vaultsData_ An array of VaultEntireData structures containing the data for each vault.\\n    function getVaultsEntireData() external view returns (VaultEntireData[] memory vaultsData_) {\\n        address[] memory vaults_ = getAllVaultsAddresses();\\n        uint length_ = vaults_.length;\\n        vaultsData_ = new VaultEntireData[](length_);\\n        for (uint i; i < length_; i++) {\\n            vaultsData_[i] = getVaultEntireData(vaults_[i]);\\n        }\\n    }\\n\\n    /// @notice Retrieves the position data for a given NFT ID and the corresponding vault data.\\n    /// @param nftId_ The NFT ID for which to retrieve the position data.\\n    /// @return userPosition_ The UserPosition structure containing the position data.\\n    /// @return vaultData_ The VaultEntireData structure containing the vault data.\\n    function positionByNftId(\\n        uint nftId_\\n    ) public view returns (UserPosition memory userPosition_, VaultEntireData memory vaultData_) {\\n        userPosition_.nftId = nftId_;\\n        address vault_ = vaultByNftId(nftId_);\\n        if (vault_ != address(0)) {\\n            uint positionData_ = getPositionDataRaw(vault_, nftId_);\\n            vaultData_ = getVaultEntireData(vault_);\\n\\n            userPosition_.owner = FACTORY.ownerOf(nftId_);\\n            userPosition_.isSupplyPosition = (positionData_ & 1) == 1;\\n            userPosition_.supply = (positionData_ >> 45) & X64;\\n            // Converting big number into normal number\\n            userPosition_.supply = (userPosition_.supply >> 8) << (userPosition_.supply & X8);\\n            userPosition_.beforeSupply = userPosition_.supply;\\n            userPosition_.dustBorrow = (positionData_ >> 109) & X64;\\n            // Converting big number into normal number\\n            userPosition_.dustBorrow = (userPosition_.dustBorrow >> 8) << (userPosition_.dustBorrow & X8);\\n            userPosition_.beforeDustBorrow = userPosition_.dustBorrow;\\n            if (!userPosition_.isSupplyPosition) {\\n                userPosition_.tick = (positionData_ & 2) == 2\\n                    ? int((positionData_ >> 2) & X19)\\n                    : -int((positionData_ >> 2) & X19);\\n                userPosition_.tickId = (positionData_ >> 21) & X24;\\n                userPosition_.borrow =\\n                    (TickMath.getRatioAtTick(int24(userPosition_.tick)) * userPosition_.supply) >>\\n                    96;\\n                userPosition_.beforeBorrow = userPosition_.borrow - userPosition_.beforeDustBorrow;\\n\\n                uint tickData_ = getTickDataRaw(vault_, userPosition_.tick);\\n\\n                if (((tickData_ & 1) == 1) || (((tickData_ >> 1) & X24) > userPosition_.tickId)) {\\n                    // user got liquidated\\n                    userPosition_.isLiquidated = true;\\n                    (userPosition_.tick, userPosition_.borrow, userPosition_.supply, , ) = IFluidVault(vault_)\\n                        .fetchLatestPosition(userPosition_.tick, userPosition_.tickId, userPosition_.borrow, tickData_);\\n                }\\n\\n                if (userPosition_.borrow > userPosition_.dustBorrow) {\\n                    userPosition_.borrow = userPosition_.borrow - userPosition_.dustBorrow;\\n                } else {\\n                    userPosition_.borrow = 0;\\n                    userPosition_.dustBorrow = 0;\\n                }\\n            }\\n\\n            // converting raw amounts into normal\\n            userPosition_.beforeSupply =\\n                (userPosition_.beforeSupply * vaultData_.exchangePricesAndRates.vaultSupplyExchangePrice) /\\n                EXCHANGE_PRICES_PRECISION;\\n            userPosition_.beforeBorrow =\\n                (userPosition_.beforeBorrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\\n                EXCHANGE_PRICES_PRECISION;\\n            userPosition_.beforeDustBorrow =\\n                (userPosition_.beforeDustBorrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\\n                EXCHANGE_PRICES_PRECISION;\\n            userPosition_.supply =\\n                (userPosition_.supply * vaultData_.exchangePricesAndRates.vaultSupplyExchangePrice) /\\n                EXCHANGE_PRICES_PRECISION;\\n            userPosition_.borrow =\\n                (userPosition_.borrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\\n                EXCHANGE_PRICES_PRECISION;\\n            userPosition_.dustBorrow =\\n                (userPosition_.dustBorrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\\n                EXCHANGE_PRICES_PRECISION;\\n        }\\n    }\\n\\n    /// @notice Returns an array of NFT IDs for all positions of a given user.\\n    /// @param user_ The address of the user for whom to fetch positions.\\n    /// @return nftIds_ An array of NFT IDs representing the user's positions.\\n    function positionsNftIdOfUser(address user_) public view returns (uint[] memory nftIds_) {\\n        uint totalPositions_ = FACTORY.balanceOf(user_);\\n        nftIds_ = new uint[](totalPositions_);\\n        for (uint i; i < totalPositions_; i++) {\\n            nftIds_[i] = FACTORY.tokenOfOwnerByIndex(user_, i);\\n        }\\n    }\\n\\n    /// @notice Returns the vault address associated with a given NFT ID.\\n    /// @param nftId_ The NFT ID for which to fetch the vault address.\\n    /// @return vault_ The address of the vault associated with the NFT ID.\\n    function vaultByNftId(uint nftId_) public view returns (address vault_) {\\n        uint tokenConfig_ = getTokenConfig(nftId_);\\n        vault_ = FACTORY.getVaultAddress((tokenConfig_ >> 192) & X32);\\n    }\\n\\n    /// @notice Fetches all positions and their corresponding vault data for a given user.\\n    /// @param user_ The address of the user for whom to fetch positions and vault data.\\n    /// @return userPositions_ An array of UserPosition structs representing the user's positions.\\n    /// @return vaultsData_ An array of VaultEntireData structs representing the vault data for each position.\\n    function positionsByUser(\\n        address user_\\n    ) external view returns (UserPosition[] memory userPositions_, VaultEntireData[] memory vaultsData_) {\\n        uint[] memory nftIds_ = positionsNftIdOfUser(user_);\\n        uint length_ = nftIds_.length;\\n        userPositions_ = new UserPosition[](length_);\\n        vaultsData_ = new VaultEntireData[](length_);\\n        for (uint i = 0; i < length_; i++) {\\n            (userPositions_[i], vaultsData_[i]) = positionByNftId(nftIds_[i]);\\n        }\\n    }\\n\\n    /// @notice Returns the total number of positions across all users.\\n    /// @return The total number of positions.\\n    function totalPositions() external view returns (uint) {\\n        return FACTORY.totalSupply();\\n    }\\n\\n    /// @notice fetches available liquidations\\n    /// @param vault_ address of vault for which to fetch\\n    /// @param tokenInAmt_ token in aka debt to payback, leave 0 to get max\\n    /// @return liquidationData_ liquidation related data. Check out structs.sol\\n    function getVaultLiquidation(\\n        address vault_,\\n        uint tokenInAmt_\\n    ) public returns (LiquidationStruct memory liquidationData_) {\\n        tokenInAmt_ = tokenInAmt_ == 0 ? X128 : tokenInAmt_;\\n\\n        uint vaultType_ = getVaultType(vault_);\\n        if (vaultType_ != 0) {\\n            liquidationData_.vault = vault_;\\n            IFluidVault.ConstantViews memory constants_ = _getVaultConstants(vault_, vaultType_);\\n\\n            if (constants_.vaultType == FluidProtocolTypes.VAULT_T1_TYPE) {\\n                liquidationData_.token0In = constants_.borrowToken.token0;\\n                liquidationData_.token0Out = constants_.supplyToken.token0;\\n\\n                // running without absorb\\n                try IFluidVaultT1(vault_).liquidate(tokenInAmt_, 0, 0x000000000000000000000000000000000000dEaD, false) {\\n                    // Handle successful execution\\n                } catch Error(string memory) {\\n                    // Handle generic errors with a reason\\n                } catch (bytes memory lowLevelData_) {\\n                    (liquidationData_.inAmt, liquidationData_.outAmt) = _decodeLiquidationResult(lowLevelData_);\\n                }\\n\\n                // running with absorb\\n                try IFluidVaultT1(vault_).liquidate(tokenInAmt_, 0, 0x000000000000000000000000000000000000dEaD, true) {\\n                    // Handle successful execution\\n                } catch Error(string memory) {\\n                    // Handle generic errors with a reason\\n                } catch (bytes memory lowLevelData_) {\\n                    (liquidationData_.inAmtWithAbsorb, liquidationData_.outAmtWithAbsorb) = _decodeLiquidationResult(\\n                        lowLevelData_\\n                    );\\n                }\\n            } else {\\n                liquidationData_.token0In = constants_.borrowToken.token0;\\n                liquidationData_.token0Out = constants_.supplyToken.token0;\\n                liquidationData_.token1In = constants_.borrowToken.token1;\\n                liquidationData_.token1Out = constants_.supplyToken.token1;\\n\\n                // running without absorb\\n                try IFluidVault(vault_).simulateLiquidate(0, false) {\\n                    // Handle successful execution\\n                } catch Error(string memory) {\\n                    // Handle generic errors with a reason\\n                } catch (bytes memory lowLevelData_) {\\n                    (liquidationData_.inAmt, liquidationData_.outAmt) = _decodeLiquidationResult(lowLevelData_);\\n                }\\n\\n                // running with absorb\\n                try IFluidVault(vault_).simulateLiquidate(0, true) {\\n                    // Handle successful execution\\n                } catch Error(string memory) {\\n                    // Handle generic errors with a reason\\n                } catch (bytes memory lowLevelData_) {\\n                    (liquidationData_.inAmtWithAbsorb, liquidationData_.outAmtWithAbsorb) = _decodeLiquidationResult(\\n                        lowLevelData_\\n                    );\\n                }\\n            }\\n\\n            liquidationData_.absorbAvailable =\\n                liquidationData_.inAmtWithAbsorb > liquidationData_.inAmt ||\\n                liquidationData_.outAmtWithAbsorb > liquidationData_.outAmt;\\n        }\\n    }\\n\\n    /// @dev helper method to decode liquidation result revert data\\n    function _decodeLiquidationResult(bytes memory lowLevelData_) internal pure returns (uint amtIn_, uint amtOut_) {\\n        // Check if the error data is long enough to contain a selector\\n        if (lowLevelData_.length >= 68) {\\n            bytes4 errorSelector_;\\n            assembly {\\n                // Extract the selector from the error data\\n                errorSelector_ := mload(add(lowLevelData_, 0x20))\\n            }\\n            if (errorSelector_ == IFluidVault.FluidLiquidateResult.selector) {\\n                assembly {\\n                    amtOut_ := mload(add(lowLevelData_, 36))\\n                    amtIn_ := mload(add(lowLevelData_, 68))\\n                }\\n            } // else -> tokenInAmtTwo & tokenOutAmtTwo remains 0\\n        }\\n    }\\n\\n    /// @notice Retrieves liquidation data for multiple vaults.\\n    /// @param vaults_ The array of vault addresses.\\n    /// @param tokensInAmt_ The array of token amounts to liquidate.\\n    /// @return liquidationsData_ An array of LiquidationStruct containing the liquidation data for each vault.\\n    function getMultipleVaultsLiquidation(\\n        address[] memory vaults_,\\n        uint[] memory tokensInAmt_\\n    ) external returns (LiquidationStruct[] memory liquidationsData_) {\\n        uint length_ = vaults_.length;\\n        liquidationsData_ = new LiquidationStruct[](length_);\\n        for (uint i = 0; i < length_; i++) {\\n            liquidationsData_[i] = getVaultLiquidation(vaults_[i], tokensInAmt_[i]);\\n        }\\n    }\\n\\n    /// @notice Retrieves liquidation data for all vaults.\\n    /// @return liquidationsData_ An array of LiquidationStruct containing the liquidation data for all vaults.\\n    function getAllVaultsLiquidation() external returns (LiquidationStruct[] memory liquidationsData_) {\\n        address[] memory vaults_ = getAllVaultsAddresses();\\n        uint length_ = vaults_.length;\\n\\n        liquidationsData_ = new LiquidationStruct[](length_);\\n        for (uint i = 0; i < length_; i++) {\\n            liquidationsData_[i] = getVaultLiquidation(vaults_[i], 0);\\n        }\\n    }\\n\\n    /// @notice DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for a single vault.\\n    /// @param vault_ The address of the vault.\\n    /// @return absorbData_ The AbsorbStruct containing the absorb data for the vault.\\n    function getVaultAbsorb(address vault_) public returns (AbsorbStruct memory absorbData_) {\\n        absorbData_.vault = vault_;\\n        uint absorbedLiquidity_ = getAbsorbedLiquidityRaw(vault_);\\n        try IFluidVaultT1(vault_).absorb() {\\n            // Handle successful execution\\n            uint newAbsorbedLiquidity_ = getAbsorbedLiquidityRaw(vault_);\\n            if (newAbsorbedLiquidity_ != absorbedLiquidity_) {\\n                absorbData_.absorbAvailable = true;\\n            }\\n        } catch Error(string memory) {} catch (bytes memory) {}\\n    }\\n\\n    /// @notice DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for multiple vaults.\\n    /// @param vaults_ The array of vault addresses.\\n    /// @return absorbData_ An array of AbsorbStruct containing the absorb data for each vault.\\n    function getVaultsAbsorb(address[] memory vaults_) public returns (AbsorbStruct[] memory absorbData_) {\\n        uint length_ = vaults_.length;\\n        absorbData_ = new AbsorbStruct[](length_);\\n        for (uint i = 0; i < length_; i++) {\\n            absorbData_[i] = getVaultAbsorb(vaults_[i]);\\n        }\\n    }\\n\\n    /// @notice DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for all vaults.\\n    /// @return absorbData_ An array of AbsorbStruct containing the absorb data for all vaults.\\n    function getVaultsAbsorb() public returns (AbsorbStruct[] memory absorbData_) {\\n        return getVaultsAbsorb(getAllVaultsAddresses());\\n    }\\n}\\n\",\"keccak256\":\"0x158c883b38bb508fe11c9f880098cfd50cf68f0a18d17035df70bc8cf41f306b\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vault/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidVault } from \\\"../../../protocols/vault/interfaces/iVault.sol\\\";\\nimport { Structs as FluidLiquidityResolverStructs } from \\\"../liquidity/structs.sol\\\";\\n\\ncontract Structs {\\n    struct Configs {\\n        // can be supplyRate instead if Vault Type is smart col. in that case if 1st bit == 1 then positive else negative\\n        uint16 supplyRateMagnifier;\\n        // can be borrowRate instead if Vault Type is smart debt. in that case if 1st bit == 1 then positive else negative\\n        uint16 borrowRateMagnifier;\\n        uint16 collateralFactor;\\n        uint16 liquidationThreshold;\\n        uint16 liquidationMaxLimit;\\n        uint16 withdrawalGap;\\n        uint16 liquidationPenalty;\\n        uint16 borrowFee;\\n        address oracle;\\n        uint oraclePriceOperate;\\n        uint oraclePriceLiquidate;\\n        address rebalancer;\\n        uint lastUpdateTimestamp;\\n    }\\n\\n    struct ExchangePricesAndRates {\\n        uint lastStoredLiquiditySupplyExchangePrice; // 0 in case of smart col\\n        uint lastStoredLiquidityBorrowExchangePrice; // 0 in case of smart debt\\n        uint lastStoredVaultSupplyExchangePrice;\\n        uint lastStoredVaultBorrowExchangePrice;\\n        uint liquiditySupplyExchangePrice; // set to 1e12 in case of smart col\\n        uint liquidityBorrowExchangePrice; // set to 1e12 in case of smart debt\\n        uint vaultSupplyExchangePrice;\\n        uint vaultBorrowExchangePrice;\\n        uint supplyRateLiquidity; // set to 0 in case of smart col\\n        uint borrowRateLiquidity; // set to 0 in case of smart debt\\n        int supplyRateVault; // can be negative in case of smart col (meaning pay to supply)\\n        int borrowRateVault; // can be negative in case of smart debt (meaning get paid to borrow)\\n        // rewardsOrFeeRateSupply: rewards or fee rate in percent 1e2 precision (1% = 100, 100% = 10000).\\n        // positive rewards, negative fee.\\n        // for smart col vaults: supplyRateVault == supplyRateLiquidity.\\n        // for normal col vaults: relative percent to supplyRateLiquidity, e.g.:\\n        // when rewards: supplyRateLiquidity = 4%, rewardsOrFeeRateSupply = 20%, supplyRateVault = 4.8%.\\n        // when fee: supplyRateLiquidity = 4%, rewardsOrFeeRateSupply = -30%, supplyRateVault = 2.8%.\\n        int rewardsOrFeeRateSupply;\\n        // rewardsOrFeeRateBorrow: rewards or fee rate in percent 1e2 precision (1% = 100, 100% = 10000).\\n        // negative rewards, positive fee.\\n        // for smart debt vaults: borrowRateVault == borrowRateLiquidity.\\n        // for normal debt vaults: relative percent to borrowRateLiquidity, e.g.:\\n        // when rewards: borrowRateLiquidity = 4%, rewardsOrFeeRateBorrow = -20%, borrowRateVault = 3.2%.\\n        // when fee: borrowRateLiquidity = 4%, rewardsOrFeeRateBorrow = 30%, borrowRateVault = 5.2%.\\n        int rewardsOrFeeRateBorrow;\\n    }\\n\\n    struct TotalSupplyAndBorrow {\\n        uint totalSupplyVault;\\n        uint totalBorrowVault;\\n        uint totalSupplyLiquidityOrDex;\\n        uint totalBorrowLiquidityOrDex;\\n        uint absorbedSupply;\\n        uint absorbedBorrow;\\n    }\\n\\n    struct LimitsAndAvailability {\\n        // in case of DEX: withdrawable / borrowable amount of vault at DEX, BUT there could be that DEX can not withdraw\\n        // that much at Liquidity! So for DEX this must be combined with returned data in DexResolver.\\n        uint withdrawLimit;\\n        uint withdrawableUntilLimit;\\n        uint withdrawable;\\n        uint borrowLimit;\\n        uint borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\\n        uint borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\\n        uint borrowLimitUtilization; // borrow limit for `maxUtilization` config at Liquidity\\n        uint minimumBorrowing;\\n    }\\n\\n    struct CurrentBranchState {\\n        uint status; // if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\\n        int minimaTick;\\n        uint debtFactor;\\n        uint partials;\\n        uint debtLiquidity;\\n        uint baseBranchId;\\n        int baseBranchMinima;\\n    }\\n\\n    struct VaultState {\\n        uint totalPositions;\\n        int topTick;\\n        uint currentBranch;\\n        uint totalBranch;\\n        uint totalBorrow;\\n        uint totalSupply;\\n        CurrentBranchState currentBranchState;\\n    }\\n\\n    struct VaultEntireData {\\n        address vault;\\n        IFluidVault.ConstantViews constantVariables;\\n        Configs configs;\\n        ExchangePricesAndRates exchangePricesAndRates;\\n        TotalSupplyAndBorrow totalSupplyAndBorrow;\\n        LimitsAndAvailability limitsAndAvailability;\\n        VaultState vaultState;\\n        // liquidity related data such as supply amount, limits, expansion etc.\\n        // only set if not smart col!\\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyData;\\n        // liquidity related data such as borrow amount, limits, expansion etc.\\n        // only set if not smart debt!\\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowData;\\n    }\\n\\n    struct UserPosition {\\n        uint nftId;\\n        address owner;\\n        bool isLiquidated;\\n        bool isSupplyPosition; // if true that means borrowing is 0\\n        int tick;\\n        uint tickId;\\n        uint beforeSupply;\\n        uint beforeBorrow;\\n        uint beforeDustBorrow;\\n        uint supply;\\n        uint borrow;\\n        uint dustBorrow;\\n    }\\n\\n    /// @dev liquidation related data\\n    /// @param vault address of vault\\n    /// @param token0In address of token in\\n    /// @param token0Out address of token out\\n    /// @param token1In address of token in (if smart debt)\\n    /// @param token1Out address of token out (if smart col)\\n    /// @param inAmt (without absorb liquidity) minimum of available liquidation\\n    /// @param outAmt (without absorb liquidity) expected token out, collateral to withdraw\\n    /// @param inAmtWithAbsorb (absorb liquidity included) minimum of available liquidation. In most cases it'll be same as inAmt but sometimes can be bigger.\\n    /// @param outAmtWithAbsorb (absorb liquidity included) expected token out, collateral to withdraw. In most cases it'll be same as outAmt but sometimes can be bigger.\\n    /// @param absorbAvailable true if absorb is available\\n    /// @dev Liquidity in with absirb will always be >= without asborb. Sometimes without asborb can provide better swaps,\\n    ///      sometimes with absirb can provide better swaps. But available in with absirb will always be >= One\\n    struct LiquidationStruct {\\n        address vault;\\n        address token0In;\\n        address token0Out;\\n        address token1In;\\n        address token1Out;\\n        // amounts in case of smart col / smart debt are in shares, otherwise token amounts\\n        uint inAmt;\\n        uint outAmt;\\n        uint inAmtWithAbsorb;\\n        uint outAmtWithAbsorb;\\n        bool absorbAvailable;\\n    }\\n\\n    struct AbsorbStruct {\\n        address vault;\\n        bool absorbAvailable;\\n    }\\n}\\n\",\"keccak256\":\"0xd4e74643eb8005ef7e045874f4bb99cbe41a05359a5b78b5c583c09684c8209c\",\"license\":\"BUSL-1.1\"},\"contracts/periphery/resolvers/vault/variables.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidLiquidityResolver } from \\\"../liquidity/iLiquidityResolver.sol\\\";\\nimport { IFluidVaultFactory } from \\\"../../../protocols/vault/interfaces/iVaultFactory.sol\\\";\\n\\ninterface IFluidStorageReadable {\\n    function readFromStorage(bytes32 slot_) external view returns (uint result_);\\n}\\n\\ncontract Variables {\\n    IFluidVaultFactory public immutable FACTORY;\\n    IFluidLiquidityResolver public immutable LIQUIDITY_RESOLVER;\\n\\n    // 30 bits (used for partials mainly)\\n    uint internal constant X8 = 0xff;\\n    uint internal constant X10 = 0x3ff;\\n    uint internal constant X14 = 0x3fff;\\n    uint internal constant X15 = 0x7fff;\\n    uint internal constant X16 = 0xffff;\\n    uint internal constant X19 = 0x7ffff;\\n    uint internal constant X20 = 0xfffff;\\n    uint internal constant X24 = 0xffffff;\\n    uint internal constant X25 = 0x1ffffff;\\n    uint internal constant X30 = 0x3fffffff;\\n    uint internal constant X32 = 0xffffffff;\\n    uint internal constant X33 = 0x1ffffffff;\\n    uint internal constant X35 = 0x7ffffffff;\\n    uint internal constant X40 = 0xffffffffff;\\n    uint internal constant X50 = 0x3ffffffffffff;\\n    uint internal constant X64 = 0xffffffffffffffff;\\n    uint internal constant X96 = 0xffffffffffffffffffffffff;\\n    uint internal constant X128 = 0xffffffffffffffffffffffffffffffff;\\n    /// @dev address that is mapped to the chain native token\\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    uint internal constant EXCHANGE_PRICES_PRECISION = 1e12;\\n\\n    constructor(address factory_, address liquidityResolver_) {\\n        FACTORY = IFluidVaultFactory(factory_);\\n        LIQUIDITY_RESOLVER = IFluidLiquidityResolver(liquidityResolver_);\\n    }\\n}\\n\",\"keccak256\":\"0x5d515a5d23aacff40b0ec32acbaeb92729a51f2484a27801df39fbcf999d6162\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/interfaces/iVault.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\\ninterface IFluidVault {\\n    /// @notice returns the vault id\\n    function VAULT_ID() external view returns (uint256);\\n\\n    /// @notice returns the vault id\\n    function TYPE() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct Tokens {\\n        address token0;\\n        address token1;\\n    }\\n\\n    struct ConstantViews {\\n        address liquidity;\\n        address factory;\\n        address operateImplementation;\\n        address adminImplementation;\\n        address secondaryImplementation;\\n        address deployer; // address which deploys oracle\\n        address supply; // either liquidity layer or DEX protocol\\n        address borrow; // either liquidity layer or DEX protocol\\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\\n        uint256 vaultId;\\n        uint256 vaultType;\\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n    }\\n\\n    /// @notice returns all Vault constants\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    /// @notice fetches the latest user position after a liquidation\\n    function fetchLatestPosition(\\n        int256 positionTick_,\\n        uint256 positionTickId_,\\n        uint256 positionRawDebt_,\\n        uint256 tickData_\\n    )\\n        external\\n        view\\n        returns (\\n            int256, // tick\\n            uint256, // raw debt\\n            uint256, // raw collateral\\n            uint256, // branchID_\\n            uint256 // branchData_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices\\n    function updateExchangePrices(\\n        uint256 vaultVariables2_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices and writes them to storage\\n    function updateExchangePricesOnStorage()\\n        external\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice returns the liquidity contract address\\n    function LIQUIDITY() external view returns (address);\\n\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n\\n    function rebalance(\\n        int colToken0MinMax_,\\n        int colToken1MinMax_,\\n        int debtToken0MinMax_,\\n        int debtToken1MinMax_\\n    ) external returns (int supplyAmt_, int borrowAmt_);\\n\\n    /// @notice reverts with FluidLiquidateResult\\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\\n}\\n\",\"keccak256\":\"0x9eb8e92c52e2ee7222a07a6e995b6bf7604a3e9a7ff1053722aef762948fd4bd\",\"license\":\"MIT\"},\"contracts/protocols/vault/interfaces/iVaultFactory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { IERC721Enumerable } from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\ninterface IFluidVaultFactory is IERC721Enumerable {\\n    /// @notice Minting an NFT Vault for the user\\n    function mint(uint256 vaultId_, address user_) external returns (uint256 tokenId_);\\n\\n    /// @notice returns owner of Vault which is also an NFT\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /// @notice Global auth is auth for all vaults\\n    function isGlobalAuth(address auth_) external view returns (bool);\\n\\n    /// @notice Vault auth is auth for a specific vault\\n    function isVaultAuth(address vault_, address auth_) external view returns (bool);\\n\\n    /// @notice Total vaults deployed.\\n    function totalVaults() external view returns (uint256);\\n\\n    /// @notice Compute vaultAddress\\n    function getVaultAddress(uint256 vaultId) external view returns (address);\\n\\n    /// @notice read uint256 `result_` for a storage `slot_` key\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n}\\n\",\"keccak256\":\"0xc4a0caed89a8670e1ccf159d03fa23bb29f69c579f522bb0e33b1b5cb106c40d\",\"license\":\"MIT\"},\"contracts/protocols/vault/interfaces/iVaultT1.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IFluidVaultT1 {\\n    /// @notice returns the vault id\\n    function VAULT_ID() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct ConstantViews {\\n        address liquidity;\\n        address factory;\\n        address adminImplementation;\\n        address secondaryImplementation;\\n        address supplyToken;\\n        address borrowToken;\\n        uint8 supplyDecimals;\\n        uint8 borrowDecimals;\\n        uint vaultId;\\n        bytes32 liquiditySupplyExchangePriceSlot;\\n        bytes32 liquidityBorrowExchangePriceSlot;\\n        bytes32 liquidityUserSupplySlot;\\n        bytes32 liquidityUserBorrowSlot;\\n    }\\n\\n    /// @notice returns all Vault constants\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    /// @notice fetches the latest user position after a liquidation\\n    function fetchLatestPosition(\\n        int256 positionTick_,\\n        uint256 positionTickId_,\\n        uint256 positionRawDebt_,\\n        uint256 tickData_\\n    )\\n        external\\n        view\\n        returns (\\n            int256, // tick\\n            uint256, // raw debt\\n            uint256, // raw collateral\\n            uint256, // branchID_\\n            uint256 // branchData_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices\\n    function updateExchangePrices(\\n        uint256 vaultVariables2_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices and writes them to storage\\n    function updateExchangePricesOnStorage()\\n        external\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice returns the liquidity contract address\\n    function LIQUIDITY() external view returns (address);\\n\\n    function operate(\\n        uint256 nftId_, // if 0 then new position\\n        int256 newCol_, // if negative then withdraw\\n        int256 newDebt_, // if negative then payback\\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256, // nftId_\\n            int256, // final supply amount. if - then withdraw\\n            int256 // final borrow amount. if - then payback\\n        );\\n\\n    function liquidate(\\n        uint256 debtAmt_,\\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\\n        address to_,\\n        bool absorb_\\n    ) external payable returns (uint actualDebtAmt_, uint actualColAmt_);\\n\\n    function absorb() external;\\n\\n    function rebalance() external payable returns (int supplyAmt_, int borrowAmt_);\\n\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n}\\n\",\"keccak256\":\"0x447e05743da212ce720baea2fabb6191ed1a7f3d1e737d4b1ce9bdcdd268d398\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c06040523480156200001157600080fd5b50604051620060e0380380620060e0833981016040819052620000349162000069565b6001600160a01b039182166080521660a052620000a1565b80516001600160a01b03811681146200006457600080fd5b919050565b600080604083850312156200007d57600080fd5b62000088836200004c565b915062000098602084016200004c565b90509250929050565b60805160a051615fd36200010d6000396000818161050d015281816107fa01526108fd01526000818161044a01528181610b170152818161101801528181611c8701528181611fa6015281816122c6015281816123cf015281816126a301526127d90152615fd36000f3fe608060405234801561001057600080fd5b50600436106102d35760003560e01c80637955fffd11610186578063a8d9f493116100e3578063e06a7b7111610097578063eb1db01811610071578063eb1db01814610676578063f70b198c14610689578063fda1fa5f1461069c57600080fd5b8063e06a7b7114610648578063e6bd26a214610650578063ea19ba111461066357600080fd5b8063c67b5093116100c8578063c67b50931461060d578063cbc7be651461062d578063dd19c0fe1461064057600080fd5b8063a8d9f493146105e5578063bf518f5f146105fa57600080fd5b80638a0038881161013a5780638f8b81f01161011f5780638f8b81f0146105ae5780639d7aeeb4146105c1578063a8bc0693146105d257600080fd5b80638a003888146105885780638bfbeda61461059b57600080fd5b8063816022b81161016b578063816022b8146105425780638530330414610555578063890a13911461056857600080fd5b80637955fffd1461052f5780637bbede431461046c57600080fd5b80632404a3f911610234578063347ca8bb116101e85780635486f100116101cd5780635486f100146104ed5780636463e94c146104f55780636902f79f1461050857600080fd5b8063347ca8bb146104b957806351971bf7146104da57600080fd5b80632dd31000116102195780632dd31000146104455780632f2612cf1461046c578063344bd722146104a657600080fd5b80632404a3f9146104105780632c44e1d11461042557600080fd5b80631949138e1161028b5780631f51fd93116102705780631f51fd93146103bd5780631fcd3649146103d057806320ee1e44146103f057600080fd5b80631949138e146103655780631ef8986d1461039d57600080fd5b8063144128e8116102bc578063144128e81461031e5780631579a46c1461033f578063168a11c21461035257600080fd5b806303e883e0146102d857806309c062e2146102fe575b600080fd5b6102eb6102e636600461481d565b6106a4565b6040519081526020015b60405180910390f35b61031161030c36600461481d565b610729565b6040516102f59190614e04565b61033161032c366004614e13565b610a1c565b6040516102f5929190614ed5565b6102eb61034d36600461481d565b610efc565b6102eb610360366004614ef2565b610f21565b610378610373366004614e13565b610fd1565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016102f5565b6103b06103ab366004615136565b611098565b6040516102f591906151b1565b6102eb6103cb36600461481d565b611156565b6103e36103de366004614ef2565b61125c565b6040516102f591906152c2565b6104036103fe36600461481d565b6117c1565b6040516102f591906152d1565b61041861190d565b6040516102f59190615354565b6104386104333660046153c3565b61191f565b6040516102f59190615489565b6103787f000000000000000000000000000000000000000000000000000000000000000081565b6102eb61047a3660046154d8565b604080516020808201939093528082019390935280518084038201815260609093019052815191012090565b6102eb6104b436600461481d565b611a5c565b6104cc6104c736600461481d565b611aa9565b6040516102f59291906154fa565b6102eb6104e836600461481d565b611c5e565b6102eb611c83565b61037861050336600461481d565b611d14565b6103787f000000000000000000000000000000000000000000000000000000000000000081565b61037861053d36600461481d565b611d39565b610378610550366004614ef2565b611d5e565b6102eb61056336600461555c565b611dc0565b61057b61057636600461481d565b611e49565b6040516102f59190615591565b6102eb610596366004614e13565b611f64565b6102eb6105a93660046155c0565b611fd2565b6102eb6105bc366004614e13565b612058565b6102eb6105cf366004614e13565b90565b6102eb6105e0366004614ef2565b612125565b6105ed612173565b6040516102f591906155ec565b6102eb610608366004614ef2565b61222d565b61062061061b36600461481d565b61227b565b6040516102f5919061563a565b6102eb61063b366004614ef2565b612469565b6104386124b7565b6103b06125e6565b61037861065e366004614e13565b61269c565b610418610671366004615136565b6126c8565b6102eb61068436600461481d565b61278b565b6102eb61069736600461481d565b6127b0565b6102eb6127d5565b600073ffffffffffffffffffffffffffffffffffffffff821663b5c736e4825b6040518263ffffffff1660e01b81526004016106e291815260200190565b602060405180830381865afa1580156106ff573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107239190615672565b92915050565b610731614481565b73ffffffffffffffffffffffffffffffffffffffff82168152600061075583611156565b90508015610a16576107678382612842565b6020808401829052610100909101510151600090819081908190819073ffffffffffffffffffffffffffffffffffffffff166108795760208701516101000151516040517fe72ef91b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8a81166004830152918216602482015260009182917f00000000000000000000000000000000000000000000000000000000000000009091169063e72ef91b906044016104c060405180830381865afa158015610844573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061086891906158cc565b60e08b019190915260200151935050505b6020808801516101200151015173ffffffffffffffffffffffffffffffffffffffff166109935760208701516101200151516040517f967915d600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8a81166004830152918216602482015260009182917f00000000000000000000000000000000000000000000000000000000000000009091169063967915d69060440161050060405180830381865afa158015610947573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061096b9190615972565b6101008b81018390529051604083015161014084015193909201519199509197509550925050505b6109a68888602001516101600151612acf565b604088018190526109bc90899088908585612e50565b6060880181905260208801516109d593508992506130fb565b85608001819052506109ff85606001518660200151876040015160a0015161ffff168686866133fc565b60a0860152610a0d866117c1565b60c08601525050505b50919050565b610a9a60405180610180016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160001515815260200160001515815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b610aa2614481565b8282526000610ab084610fd1565b905073ffffffffffffffffffffffffffffffffffffffff811615610ef6576000610ada8286612469565b9050610ae582610729565b6040517f6352211e000000000000000000000000000000000000000000000000000000008152600481018790529093507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690636352211e90602401602060405180830381865afa158015610b73573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b979190615a25565b73ffffffffffffffffffffffffffffffffffffffff1660208501526001808216146060850181905266ffffffffffffff603583901c811660ff602d85901c81169190911b610120880181905260c0880152607584901c909116606d84901c9091161b6101608601819052610100860152610ddb5780600216600214610c2d57610c28600282901c6207ffff16615a71565b610c38565b6207ffff600282901c165b60808501819052601582901c62ffffff1660a0860152610120850151606091610c639060020b613bfb565b610c6d9190615aa9565b901c6101408501819052610100850151610c8691615ac0565b60e08501526080840151600090610c9e908490610f21565b90508060011660011480610cbe57508460a0015162ffffff600183901c16115b15610d95576001604086810191909152608086015160a087015161014088015192517f22348cc70000000000000000000000000000000000000000000000000000000081526004810192909252602482015260448101919091526064810182905273ffffffffffffffffffffffffffffffffffffffff8416906322348cc79060840160a060405180830381865afa158015610d5d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d819190615ad3565b505061012088015261014087015260808601525b8461016001518561014001511115610dc857846101600151856101400151610dbd9190615ac0565b610140860152610dd9565b600061014086018190526101608601525b505b64e8d4a51000836060015160c001518560c00151610df99190615aa9565b610e039190615b42565b60c0850152606083015160e0908101519085015164e8d4a5100091610e2791615aa9565b610e319190615b42565b60e0808601919091526060840151015161010085015164e8d4a5100091610e5791615aa9565b610e619190615b42565b610100850152606083015160c0015161012085015164e8d4a5100091610e8691615aa9565b610e909190615b42565b610120850152606083015160e0015161014085015164e8d4a5100091610eb591615aa9565b610ebf9190615b42565b610140850152606083015160e0015161016085015164e8d4a5100091610ee491615aa9565b610eee9190615b42565b610160850152505b50915091565b600073ffffffffffffffffffffffffffffffffffffffff821663b5c736e460086106c4565b6040805160208082018490526005828401528251808303840181526060909201909252805191012060009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e4905b6040518263ffffffff1660e01b8152600401610f8991815260200190565b602060405180830381865afa158015610fa6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fca9190615672565b9392505050565b600080610fdd83611f64565b6040517fe6bd26a200000000000000000000000000000000000000000000000000000000815263ffffffff60c083901c1660048201529091507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063e6bd26a290602401602060405180830381865afa158015611074573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fca9190615a25565b80516060908067ffffffffffffffff8111156110b6576110b6614f1e565b6040519080825280602002602001820160405280156110ef57816020015b6110dc614481565b8152602001906001900390816110d45790505b50915060005b8181101561114f5761111f84828151811061111257611112615b7d565b6020026020010151610729565b83828151811061113157611131615b7d565b6020026020010181905250808061114790615bac565b9150506110f5565b5050919050565b60008173ffffffffffffffffffffffffffffffffffffffff163b60000361117f57506000919050565b8173ffffffffffffffffffffffffffffffffffffffff1663bb24fe8a6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015611204575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261120191810190615672565b60015b610723578173ffffffffffffffffffffffffffffffffffffffff1661122b61065e84611a5c565b73ffffffffffffffffffffffffffffffffffffffff161461124e57506000919050565b50612710919050565b919050565b6040805161014081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081019190915281156112b957816112cb565b6fffffffffffffffffffffffffffffffff5b915060006112d884611156565b905080156117ba5773ffffffffffffffffffffffffffffffffffffffff8416825260006113058583612842565b9050612710816101600151036115b0576101208101515173ffffffffffffffffffffffffffffffffffffffff9081166020850152610100820151518116604080860191909152517f8433ea220000000000000000000000000000000000000000000000000000000081526004810186905260006024820181905261dead6044830152606482015290861690638433ea229060840160408051808303816000875af19250505080156113f1575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526113ee91810190615be4565b60015b61146d576113fd615c08565b806308c379a0036114225750611411615c23565b8061141c5750611424565b50611470565b505b3d80801561144e576040519150601f19603f3d011682016040523d82523d6000602084013e611453565b606091505b5061145d81613e5d565b60c086015260a085015250611470565b50505b6040517f8433ea22000000000000000000000000000000000000000000000000000000008152600481018590526000602482015261dead60448201526001606482015273ffffffffffffffffffffffffffffffffffffffff861690638433ea229060840160408051808303816000875af192505050801561152c575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261152991810190615be4565b60015b6115a957611538615c08565b806308c379a00361155d575061154c615c23565b80611557575061155f565b50611792565b505b3d808015611589576040519150601f19603f3d011682016040523d82523d6000602084013e61158e565b606091505b5061159881613e5d565b61010086015260e085015250611792565b5050611792565b610120810180515173ffffffffffffffffffffffffffffffffffffffff908116602086810191909152610100840180515183166040808901919091529351820151831660608801525101518116608086015290517f3202937e000000000000000000000000000000000000000000000000000000008152600060048201819052602482015290861690633202937e90604401600060405180830381600087803b15801561165c57600080fd5b505af192505050801561166d575060015b6116e557611679615c08565b806308c379a00361169e575061168d615c23565b8061169857506116a0565b506116e5565b505b3d8080156116ca576040519150601f19603f3d011682016040523d82523d6000602084013e6116cf565b606091505b506116d981613e5d565b60c086015260a0850152505b6040517f3202937e000000000000000000000000000000000000000000000000000000008152600060048201526001602482015273ffffffffffffffffffffffffffffffffffffffff861690633202937e90604401600060405180830381600087803b15801561175457600080fd5b505af1925050508015611765575060015b61179257611771615c08565b806308c379a00361155d5750611785615c23565b80611790575061155f565b505b8260a001518360e0015111806117b057508260c00151836101000151115b1515610120840152505b5092915050565b6117c9614783565b60006117d4836106a4565b90506117e8620fffff600283901c16612058565b6020830152633fffffff601682901c81166040840152603482901c16606083015266ffffffffffffff605a82901c1660ff605283901c161b60a083015266ffffffffffffff609a82901c1660ff609283901c161b608083015260d281901c63ffffffff168252604082015160009061186190859061222d565b60c08401516003821690529050611880600282901c620fffff16612058565b60c0840180516020019190915280516603ffffffffffff607484901c1660409091015251633fffffff601683901c1660609091015266ffffffffffffff603c82901c1660ff603483901c161b60c084018051608001919091525160a682901c633fffffff1660a0909101526118fd60c482901c620fffff16612058565b60c0808501510152509092915050565b606061191a610671612173565b905090565b81516060908067ffffffffffffffff81111561193d5761193d614f1e565b6040519080825280602002602001820160405280156119da57816020015b604080516101408101825260008082526020808301829052928201819052606082018190526080820181905260a0820181905260c0820181905260e08201819052610100820181905261012082015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90920191018161195b5790505b50915060005b81811015611a5457611a248582815181106119fd576119fd615b7d565b6020026020010151858381518110611a1757611a17615b7d565b602002602001015161125c565b838281518110611a3657611a36615b7d565b60200260200101819052508080611a4c90615bac565b9150506119e0565b505092915050565b60008173ffffffffffffffffffffffffffffffffffffffff1663540acabc6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156106ff573d6000803e3d6000fd5b6060806000611ab78461227b565b80519091508067ffffffffffffffff811115611ad557611ad5614f1e565b604051908082528060200260200182016040528015611b8457816020015b611b7160405180610180016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160001515815260200160001515815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b815260200190600190039081611af35790505b5093508067ffffffffffffffff811115611ba057611ba0614f1e565b604051908082528060200260200182016040528015611bd957816020015b611bc6614481565b815260200190600190039081611bbe5790505b50925060005b81811015611c5657611c09838281518110611bfc57611bfc615b7d565b6020026020010151610a1c565b868381518110611c1b57611c1b615b7d565b60200260200101868481518110611c3457611c34615b7d565b6020026020010182905282905250508080611c4e90615bac565b915050611bdf565b505050915091565b600073ffffffffffffffffffffffffffffffffffffffff821663b5c736e4600a6106c4565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16638d6540236040518163ffffffff1660e01b8152600401602060405180830381865afa158015611cf0573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061191a9190615672565b600073ffffffffffffffffffffffffffffffffffffffff821663b5c736e460096106c4565b600073ffffffffffffffffffffffffffffffffffffffff821663b5c736e4600b6106c4565b600080611d7384611d6e86611156565b612842565b60a081015190915073ffffffffffffffffffffffffffffffffffffffff161580611d9b575082155b15611daa576000915050610723565b611db88160a0015184613ecb565b949350505050565b60008373ffffffffffffffffffffffffffffffffffffffff1663b5c736e4611dea60068686611fd2565b6040518263ffffffff1660e01b8152600401611e0891815260200190565b602060405180830381865afa158015611e25573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611db89190615672565b6040805180820190915260006020820181905273ffffffffffffffffffffffffffffffffffffffff83168252611e7e836127b0565b90508273ffffffffffffffffffffffffffffffffffffffff1663ebd93ac66040518163ffffffff1660e01b8152600401600060405180830381600087803b158015611ec857600080fd5b505af1925050508015611ed9575060015b611f4257611ee5615c08565b806308c379a003611f0a5750611ef9615c23565b80611f045750611f0c565b50610a16565b505b3d808015611f36576040519150601f19603f3d011682016040523d82523d6000602084013e611f3b565b606091505b5050610a16565b6000611f4d846127b0565b905081811461114f57600160208401525050919050565b6040805160208082018490526003828401528251808303840181526060909201909252805191012060009073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063b5c736e4906106c4565b6000808385604051602001611ff1929190918252602082015260400190565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815282825280516020918201209083018690529082018190529150606001604051602081830303815290604052805190602001209150509392505050565b6000620fffff82106120ca576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f696e76616c69642d6e756d626572000000000000000000000000000000000000604482015260640160405180910390fd5b81156120fe57816001166001146120f2576120ed600183901c6207ffff16615a71565b610723565b5060011c6207ffff1690565b507f8000000000000000000000000000000000000000000000000000000000000000919050565b6040805160208082018490526004828401528251808303840181526060909201909252805191012060009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490610f6b565b6060600061217f611c83565b90508067ffffffffffffffff81111561219a5761219a614f1e565b6040519080825280602002602001820160405280156121c3578160200160208202803683370190505b50915060005b81811015612228576121df61065e826001615ccb565b8382815181106121f1576121f1615b7d565b73ffffffffffffffffffffffffffffffffffffffff909216602092830291909101909101528061222081615bac565b9150506121c9565b505090565b6040805160208082018490526007828401528251808303840181526060909201909252805191012060009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490610f6b565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301526060916000917f000000000000000000000000000000000000000000000000000000000000000016906370a0823190602401602060405180830381865afa15801561230d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123319190615672565b90508067ffffffffffffffff81111561234c5761234c614f1e565b604051908082528060200260200182016040528015612375578160200160208202803683370190505b50915060005b8181101561114f576040517f2f745c5900000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8581166004830152602482018390527f00000000000000000000000000000000000000000000000000000000000000001690632f745c5990604401602060405180830381865afa158015612416573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061243a9190615672565b83828151811061244c5761244c615b7d565b60209081029190910101528061246181615bac565b91505061237b565b6040805160208082018490526003828401528251808303840181526060909201909252805191012060009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490610f6b565b606060006124c3612173565b80519091508067ffffffffffffffff8111156124e1576124e1614f1e565b60405190808252806020026020018201604052801561257e57816020015b604080516101408101825260008082526020808301829052928201819052606082018190526080820181905260a0820181905260c0820181905260e08201819052610100820181905261012082015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9092019101816124ff5790505b50925060005b818110156125e0576125b08382815181106125a1576125a1615b7d565b6020026020010151600061125c565b8482815181106125c2576125c2615b7d565b602002602001018190525080806125d890615bac565b915050612584565b50505090565b606060006125f2612173565b80519091508067ffffffffffffffff81111561261057612610614f1e565b60405190808252806020026020018201604052801561264957816020015b612636614481565b81526020019060019003908161262e5790505b50925060005b818110156125e05761266c83828151811061111257611112615b7d565b84828151811061267e5761267e615b7d565b6020026020010181905250808061269490615bac565b91505061264f565b60006107237f000000000000000000000000000000000000000000000000000000000000000083613ecb565b80516060908067ffffffffffffffff8111156126e6576126e6614f1e565b60405190808252806020026020018201604052801561272b57816020015b60408051808201909152600080825260208201528152602001906001900390816127045790505b50915060005b8181101561114f5761275b84828151811061274e5761274e615b7d565b6020026020010151611e49565b83828151811061276d5761276d615b7d565b6020026020010181905250808061278390615bac565b915050612731565b600073ffffffffffffffffffffffffffffffffffffffff821663b5c736e460016106c4565b600073ffffffffffffffffffffffffffffffffffffffff821663b5c736e460026106c4565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611cf0573d6000803e3d6000fd5b6128e1604080516102008101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905260c0830182905260e0830182905283518085018552828152808201839052610100840152835180850190945281845283015290610120820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c09091015290565b6127108203612a5f578273ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b81526004016101a060405180830381865afa925050508015612970575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261296d91810190615cef565b60015b1561072357805173ffffffffffffffffffffffffffffffffffffffff908116835260208083015182168185015285821660408086019190915283015182166060808601919091528301518216608080860191909152600060a08087018290528551851660c08801528551851660e0880152918501516101008088018051928716909252905184018290529185015161012080880180519290961690915293519092019190915282015161014080850191909152612710610160808601919091529183015161018080860191909152908301516101a0850152908201516101c084015201516101e0820152610723565b8273ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa158015612aab573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fca9190615e31565b604080516101a081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e081018290526101008101829052610120810182905261014081018290526101608101829052610180810182905290612b418461278b565b61ffff8082168452601082901c16602080850191909152909150612b6d9082901c6103ff16600a615f49565b61ffff166040830152612b89602a82901c6103ff16600a615f49565b61ffff166060830152612ba5603482901c6103ff16600a615f49565b61ffff166080830152612bc1603e82901c6103ff16600a615f49565b61ffff1660a08301526103ff604882901c811660c0840152605282901c1660e08301527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd8f08301612c1b57606081901c610100830152612c67565b605c81901c633fffffff168015612c5357612c368582611d5e565b73ffffffffffffffffffffffffffffffffffffffff166101008401525b50607a81901c6401ffffffff166101808301525b61010082015173ffffffffffffffffffffffffffffffffffffffff1615612e245781610100015173ffffffffffffffffffffffffffffffffffffffff16638e7bfbc06040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015612d12575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612d0f91810190615672565b60015b612d9d5781610100015173ffffffffffffffffffffffffffffffffffffffff1663e6aa216c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612d66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d8a9190615672565b6101208301819052610140830152612e24565b808361012001818152505082610100015173ffffffffffffffffffffffffffffffffffffffff1663f3190c896040518163ffffffff1660e01b8152600401602060405180830381865afa158015612df8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612e1c9190615672565b610140840152505b612e2d84611d14565b73ffffffffffffffffffffffffffffffffffffffff166101608301525092915050565b612ec2604051806101c0016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000612ecd87610efc565b67ffffffffffffffff8082168452604082811c82166020860152608083901c9091169084015260c081901c6060840152905073ffffffffffffffffffffffffffffffffffffffff87166309f0d8cb612f248961278b565b6040518263ffffffff1660e01b8152600401612f4291815260200190565b608060405180830381865afa158015612f5f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f839190615f67565b60e086015260c085015260a0840152608083015261010082018490526101208201839052614e20861480612fb85750619c4086145b15612fff578451600190811c617fff16610140840152855116600003612fee57816101400151612fe790615a71565b6101408301525b610140820151610180830152613041565b84516127109061ffff16850204610140830152845161ffff167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd8f0016101808301525b6175308614806130525750619c4086145b1561309d57602085018051600190811c617fff1661016085015290511660000361308c5781610160015161308590615a71565b6101608301525b6101608201516101a08301526130f1565b612710856020015161ffff168402816130b8576130b8615b13565b04610160830152602085015161ffff167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd8f0016101a08301525b5095945050505050565b6131346040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b600061313f856106a4565b9050600061314c866127b0565b905060008460c0015173ffffffffffffffffffffffffffffffffffffffff1663b5c736e4866101c001516040518263ffffffff1660e01b815260040161319491815260200190565b602060405180830381865afa1580156131b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131d59190615672565b6101008601516020015190915073ffffffffffffffffffffffffffffffffffffffff1661320e5760011c67ffffffffffffffff1661321c565b60011c67ffffffffffffffff165b60ff8116600882901c901b905060008560e0015173ffffffffffffffffffffffffffffffffffffffff1663b5c736e4876101e001516040518263ffffffff1660e01b815260040161326f91815260200190565b602060405180830381865afa15801561328c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132b09190615672565b6101208701516020015190915073ffffffffffffffffffffffffffffffffffffffff166132e95760011c67ffffffffffffffff166132f7565b60011c67ffffffffffffffff165b66ffffffffffffff605a85901c8116605286901c60ff9081169190911b808852609a87901c909216609287901c82161b602088015260408701849052600883901c92169190911b606086018190526fffffffffffffffffffffffffffffffff841660a0870152608084811c9087015260c0880151909164e8d4a51000910204855260e0870151602086015164e8d4a5100091020460208601526080870151604086015164e8d4a51000910204604086015260a0870151606086015164e8d4a51000910204606086015260c0870151608086015164e8d4a51000910204608086015260e087015160a086015164e8d4a5100091020460a086015250929695505050505050565b61344460405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b60c08601516101c08701516040517fb5c736e4000000000000000000000000000000000000000000000000000000008152600481019190915260009173ffffffffffffffffffffffffffffffffffffffff169063b5c736e490602401602060405180830381865afa1580156134bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906134e19190615672565b9050801561396657600080886000015173ffffffffffffffffffffffffffffffffffffffff168960c0015173ffffffffffffffffffffffffffffffffffffffff16036135515766ffffffffffffff600984901c1660ff600185901c161b915061354a8383614335565b9050613577565b66ffffffffffffff600984901c1660ff600185901c161b91506135748383614335565b90505b64e8d4a510008a6080015182028161359157613591615b13565b0480855282116135a25760006135a7565b835182035b60208501528351600090156135c257612710838a02046135c5565b60005b9050808560200151116135d95760006135f8565b620f424081866020015103620f423f02816135f6576135f6615b13565b045b602080870182905260408701919091526101008b0151015173ffffffffffffffffffffffffffffffffffffffff16905061396357600073eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee73ffffffffffffffffffffffffffffffffffffffff168a61010001516000015173ffffffffffffffffffffffffffffffffffffffff160361369d5750885173ffffffffffffffffffffffffffffffffffffffff163161394d565b6101008a0151518a516040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff91821660048201529116906370a0823190602401602060405180830381865afa158015613712573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137369190615672565b905073cd5fe23c85820f7b72d0926fc9b05b43e359b7ee73ffffffffffffffffffffffffffffffffffffffff168a61010001516000015173ffffffffffffffffffffffffffffffffffffffff16036138495789516040517fb203bb9900000000000000000000000000000000000000000000000000000000815273cd5fe23c85820f7b72d0926fc9b05b43e359b7ee600482015273ffffffffffffffffffffffffffffffffffffffff909116602482015273f047ab4c75cebf0eb9ed34ae2c186f3611aeafa69063b203bb9990604401602060405180830381865afa158015613823573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906138479190615672565b015b6101008a01515173ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffff6e83117fe59806cc0d194cc03f32e12d2a6f62780161394d5789516040517fb203bb9900000000000000000000000000000000000000000000000000000000815273917cee801a67f933f2e6b33fc0cd1ed2d5909d88600482015273ffffffffffffffffffffffffffffffffffffffff909116602482015273f047ab4c75cebf0eb9ed34ae2c186f3611aeafa69063b203bb9990604401602060405180830381865afa158015613927573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061394b9190615672565b015b846020015181101561396157604085018190525b505b50505b60e08701516101e08801516040517fb5c736e4000000000000000000000000000000000000000000000000000000008152600481019190915260009173ffffffffffffffffffffffffffffffffffffffff169063b5c736e490602401602060405180830381865afa1580156139df573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613a039190615672565b90508015613bc7576101208801516020015173ffffffffffffffffffffffffffffffffffffffff16613b70576060830186905260c08301859052620f4240620f423f85020460808401526101208801515160009073ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffff111111111111111111111111111111111111111201613ab25750875173ffffffffffffffffffffffffffffffffffffffff1631613b4e565b6101208901515189516040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff91821660048201529116906370a0823190602401602060405180830381865afa158015613b27573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b4b9190615672565b90505b83608001518111613b5f5780613b65565b83608001515b60a085015250613bc7565b66ffffffffffffff600982901c1660ff600183901c161b613b9182826143c9565b606085018190528110613ba5576000613bad565b808460600151035b620f4240620f423f909102046080850181905260a0850152505b64e8d4a510008960e00151612711613bdf9190615aa9565b613be99190615b42565b60e08401525090979650505050505050565b600060ff82901d80831803617fff811115613c1557600080fd5b7001000000000000000000000000000000006001821615613c4357506fff9dd7de423466c20352b1246ce4856f5b6002821615613c62576fff3bd55f4488ad277531fa1c725a66d00260801c5b6004821615613c81576ffe78410fd6498b73cb96a6917f8532590260801c5b6008821615613ca0576ffcf2d9987c9be178ad5bfeffaa1232730260801c5b6010821615613cbf576ff9ef02c4529258b057769680fc6601b30260801c5b6020821615613cde576ff402d288133a85a17784a411f7aba0820260801c5b6040821615613cfd576fe895615b5beb6386553757b0352bda900260801c5b6080821615613d1c576fd34f17a00ffa00a8309940a15930391a0260801c5b610100821615613d3c576fae6b7961714e20548d88ea5123f9a0ff0260801c5b610200821615613d5c576f76d6461f27082d74e0feed3b388c0ca10260801c5b610400821615613d7c576f372a3bfe0745d8b6b19d985d9a8b85bb0260801c5b610800821615613d9c576f0be32cbee48979763cf7247dd7bb539d0260801c5b611000821615613dbb576e8d4f70c9ff4924dac37612d1e2921e0260801c5b612000821615613dd9576d4e009ae5519380809a02ca7aec770260801c5b614000821615613df5576b17c45e641b6e95dee056ff100260801c5b600091507f80000000000000000000000000000000000000000000000000000000000000008416613e53577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0463ffffffff811615613e5357600191505b60201c0192915050565b6000806044835110613ec65760208301517f33c955bc000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000821601610ef65750505060248101516044820151905b915091565b6000606082600003613ee1576000915050610723565b607f8311613faa576040517fd60000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b16602282015260f884901b7fff000000000000000000000000000000000000000000000000000000000000001660368201526037015b6040516020818303038152906040529050614326565b60ff8311614087576040517fd70000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f8100000000000000000000000000000000000000000000000000000000000000603682015260f884901b7fff00000000000000000000000000000000000000000000000000000000000000166037820152603801613f94565b61ffff8311614165576040517fd80000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f820000000000000000000000000000000000000000000000000000000000000060368201527fffff00000000000000000000000000000000000000000000000000000000000060f085901b166037820152603901613f94565b62ffffff8311614244576040517fd90000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f830000000000000000000000000000000000000000000000000000000000000060368201527fffffff000000000000000000000000000000000000000000000000000000000060e885901b166037820152603a01613f94565b6040517fda0000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f840000000000000000000000000000000000000000000000000000000000000060368201527fffffffff0000000000000000000000000000000000000000000000000000000060e085901b166037820152603b0160405160208183030381529060405290505b80516020909101209392505050565b600066ffffffffffffff604984901c1660ff604185901c161b80820361435f576000915050610723565b612710613fff60a286901c168402046401ffffffff608186901c16420362ffffff60b087901c166143908284615aa9565b61439a9190615b42565b90508083116143aa5760006143ae565b8083035b935050808403838111156143c0578093505b50505092915050565b60d082901c6103ff1660c883901c60ff161b613fff60a284901c1661271083820204808401838110156143fe57505050610723565b608186901c6401ffffffff164203925066ffffffffffffff604987901c1660ff604188901c161b60b087901c62ffffff166144398585615aa9565b6144439190615b42565b61444d9190615ccb565b93508084111561445b578093505b6103ff60e287901c1660ff60da88901c161b9250828411156143c0575090949350505050565b604051806101200160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001614549604080516102008101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905260c0830182905260e0830182905283518085018552828152808201839052610100840152835180850190945281845283015290610120820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c09091015290565b8152604080516101a08101825260008082526020828101829052928201819052606082018190526080820181905260a0820181905260c0820181905260e082018190526101008201819052610120820181905261014082018190526101608201819052610180820152910190815260200161462c604051806101c0016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b815260200161466a6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b81526020016146b760405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b81526020016146c4614783565b815260200161471a60405180610120016040528060001515815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b815260200161477e604051806101600160405280600015158152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b905290565b6040518060e0016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200161477e6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b73ffffffffffffffffffffffffffffffffffffffff8116811461481a57600080fd5b50565b60006020828403121561482f57600080fd5b8135610fca816147f8565b805173ffffffffffffffffffffffffffffffffffffffff168252602081015161487b602084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060408101516148a3604084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060608101516148cb606084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060808101516148f3608084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060a081015161491b60a084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060c081015161494360c084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060e081015161496b60e084018273ffffffffffffffffffffffffffffffffffffffff169052565b5061010081810151805173ffffffffffffffffffffffffffffffffffffffff9081168584015260208201511661012085015250506101208101516101406149d781850183805173ffffffffffffffffffffffffffffffffffffffff908116835260209182015116910152565b820151610180848101919091526101608301516101a080860191909152908301516101c080860191909152908301516101e08086019190915290830151610200850152909101516102209092019190915250565b805161ffff1682526020810151614a48602084018261ffff169052565b506040810151614a5e604084018261ffff169052565b506060810151614a74606084018261ffff169052565b506080810151614a8a608084018261ffff169052565b5060a0810151614aa060a084018261ffff169052565b5060c0810151614ab660c084018261ffff169052565b5060e0810151614acc60e084018261ffff169052565b506101008181015173ffffffffffffffffffffffffffffffffffffffff8116848301525050610120818101519083015261014080820151908301526101608082015173ffffffffffffffffffffffffffffffffffffffff811682850152505061018090810151910152565b805173ffffffffffffffffffffffffffffffffffffffff1682526020810151614b63602084018261483a565b506040810151614b77610260840182614a2b565b5060608181015180516104008501526020808201516104208601526040808301516104408701528284015161046087015260808084015161048088015260a0808501516104a089015260c0808601516104c08a015260e0808701516104e08b0152610100808801516105008c0152610120808901516105208d0152610140808a01516105408e01526101608a01516105608e01526101808a01516105808e01526101a0909901516105a08d0152858b015180516105c08e0152808901516105e08e0152808801516106008e0152808b01516106208e0152808701516106408e01528501516106608d0152848b015180516106808e0152808901516106a08e0152808801516106c08e0152808b01516106e08e0152808701516107008e0152808601516107208e0152808501516107408e01528301516107608d0152838b015180516107808e0152808901516107a08e0152808801516107c08e0152808b01516107e08e0152808701516108008e0152808601516108208e015284015180516108408e0152808901516108608e0152808801516108808e0152808b01516108a08e0152808701516108c08e0152808601516108e08e01528401516109008d0152828b0151805115156109208e0152808901516109408e0152808801516109608e0152808b01516109808e0152808701516109a08e0152808601516109c08e0152808501516109e08e015280840151610a008e0152820151610a208d01529981015180511515610a408d015296870151610a608c015294860151610a808b015296850151610aa08a015291840151610ac0890152830151610ae0880152820151610b0087015292810151610b2086015291820151610b4085015291810151610b608401520151610b8090910152565b610ba081016107238284614b37565b600060208284031215614e2557600080fd5b5035919050565b805182526020810151614e57602084018273ffffffffffffffffffffffffffffffffffffffff169052565b506040810151614e6b604084018215159052565b506060810151614e7f606084018215159052565b506080818101519083015260a0808201519083015260c0808201519083015260e0808201519083015261010080820151908301526101208082015190830152610140808201519083015261016090810151910152565b610d208101614ee48285614e2c565b610fca610180830184614b37565b60008060408385031215614f0557600080fd5b8235614f10816147f8565b946020939093013593505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6060810181811067ffffffffffffffff82111715614f6d57614f6d614f1e565b60405250565b60a0810181811067ffffffffffffffff82111715614f6d57614f6d614f1e565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f830116810181811067ffffffffffffffff82111715614fd757614fd7614f1e565b6040525050565b604051610220810167ffffffffffffffff8111828210171561500257615002614f1e565b60405290565b604051610120810167ffffffffffffffff8111828210171561500257615002614f1e565b604051610160810167ffffffffffffffff8111828210171561500257615002614f1e565b6040516101a0810167ffffffffffffffff8111828210171561500257615002614f1e565b604051610200810167ffffffffffffffff8111828210171561500257615002614f1e565b600067ffffffffffffffff8211156150b2576150b2614f1e565b5060051b60200190565b600082601f8301126150cd57600080fd5b813560206150da82615098565b6040516150e78282614f93565b83815260059390931b850182019282810191508684111561510757600080fd5b8286015b8481101561512b57803561511e816147f8565b835291830191830161510b565b509695505050505050565b60006020828403121561514857600080fd5b813567ffffffffffffffff81111561515f57600080fd5b611db8848285016150bc565b600081518084526020808501945080840160005b838110156151a657615192878351614b37565b610ba096909601959082019060010161517f565b509495945050505050565b602081526000610fca602083018461516b565b805173ffffffffffffffffffffffffffffffffffffffff1682526020810151615205602084018273ffffffffffffffffffffffffffffffffffffffff169052565b50604081015161522d604084018273ffffffffffffffffffffffffffffffffffffffff169052565b506060810151615255606084018273ffffffffffffffffffffffffffffffffffffffff169052565b50608081015161527d608084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060a081015160a083015260c081015160c083015260e081015160e0830152610100808201518184015250610120808201516152bc8285018215159052565b50505050565b610140810161072382846151c4565b815181526020808301518183015260408084015181840152606080850151818501526080808601518186015260a0808701518187015260c0808801518051828901529586015160e0880152938501516101008701529184015161012086015283015161014085015282015161016084015201516101808201526101a08101610723565b602080825282518282018190526000919060409081850190868401855b828110156153b6576153a6848351805173ffffffffffffffffffffffffffffffffffffffff1682526020908101511515910152565b9284019290850190600101615371565b5091979650505050505050565b600080604083850312156153d657600080fd5b823567ffffffffffffffff808211156153ee57600080fd5b6153fa868387016150bc565b935060209150818501358181111561541157600080fd5b85019050601f8101861361542457600080fd5b803561542f81615098565b60405161543c8282614f93565b82815260059290921b830184019184810191508883111561545c57600080fd5b928401925b8284101561547a57833582529284019290840190615461565b80955050505050509250929050565b6020808252825182820181905260009190848201906040850190845b818110156154cc576154b88385516151c4565b9284019261014092909201916001016154a5565b50909695505050505050565b600080604083850312156154eb57600080fd5b50508035926020909101359150565b604080825283519082018190526000906020906060840190828701845b8281101561553e5761552a848351614e2c565b610180939093019290840190600101615517565b50505083810382850152615552818661516b565b9695505050505050565b60008060006060848603121561557157600080fd5b833561557c816147f8565b95602085013595506040909401359392505050565b815173ffffffffffffffffffffffffffffffffffffffff16815260208083015115159082015260408101610723565b6000806000606084860312156155d557600080fd5b505081359360208301359350604090920135919050565b6020808252825182820181905260009190848201906040850190845b818110156154cc57835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101615608565b6020808252825182820181905260009190848201906040850190845b818110156154cc57835183529284019291840191600101615656565b60006020828403121561568457600080fd5b5051919050565b8051801515811461125757600080fd5b8051611257816147f8565b600060e082840312156156b857600080fd5b60405160e0810181811067ffffffffffffffff821117156156db576156db614f1e565b806040525080915082516156ee816147f8565b808252506020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c08201525092915050565b60008183036101a081121561574957600080fd5b60405161575581614f4d565b8092508351815260a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08301121561578c57600080fd5b604051915061579a82614f73565b60208401516157a8816147f8565b8083525060408401516020830152606084015160408301526080840151606083015260a084015160808301528160208201526157e78560c086016156a6565b6040820152505092915050565b60006103a0828403121561580757600080fd5b61580f614fde565b825181526020808401519082015260408084015190820152606080840151908201526080808401519082015260a0808401519082015260c0808401519082015260e08084015190820152610100808401519082015261012080840151908201526101408084015190820152610160808401519082015261018080840151908201526101a080840151908201526101c080840151908201526101e0808401519082015290506102006158c284828501615735565b9082015292915050565b6000808284036104c08112156158e157600080fd5b610120808212156158f157600080fd5b6158f9615008565b91506159048561568b565b82526020850151602083015260408501516040830152606085015160608301526080850151608083015260a085015160a083015260c085015160c083015260e085015160e0830152610100808601518184015250819350615967868287016157f4565b925050509250929050565b60008082840361050081121561598757600080fd5b6101608082121561599757600080fd5b61599f61502c565b91506159aa8561568b565b82526020850151602083015260408501516040830152606085015160608301526080850151608083015260a085015160a083015260c085015160c083015260e085015160e0830152610100808601518184015250610120808601518184015250610140808601518184015250819350615967868287016157f4565b600060208284031215615a3757600080fd5b8151610fca816147f8565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007f80000000000000000000000000000000000000000000000000000000000000008203615aa257615aa2615a42565b5060000390565b808202811582820484141761072357610723615a42565b8181038181111561072357610723615a42565b600080600080600060a08688031215615aeb57600080fd5b5050835160208501516040860151606087015160809097015192989197509594509092509050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600082615b78577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203615bdd57615bdd615a42565b5060010190565b60008060408385031215615bf757600080fd5b505080516020909101519092909150565b600060033d11156105cf5760046000803e5060005160e01c90565b600060443d1015615c315790565b6040517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc803d016004833e81513d67ffffffffffffffff8160248401118184111715615c7f57505050505090565b8285019150815181811115615c975750505050505090565b843d8701016020828501011115615cb15750505050505090565b615cc060208286010187614f93565b509095945050505050565b8082018082111561072357610723615a42565b805160ff8116811461125757600080fd5b60006101a08284031215615d0257600080fd5b615d0a615050565b615d138361569b565b8152615d216020840161569b565b6020820152615d326040840161569b565b6040820152615d436060840161569b565b6060820152615d546080840161569b565b6080820152615d6560a0840161569b565b60a0820152615d7660c08401615cde565b60c0820152615d8760e08401615cde565b60e08201526101008381015190820152610120808401519082015261014080840151908201526101608084015190820152610180928301519281019290925250919050565b600060408284031215615dde57600080fd5b6040516040810181811067ffffffffffffffff82111715615e0157615e01614f1e565b80604052508091508251615e14816147f8565b81526020830151615e24816147f8565b6020919091015292915050565b60006102408284031215615e4457600080fd5b615e4c615074565b615e558361569b565b8152615e636020840161569b565b6020820152615e746040840161569b565b6040820152615e856060840161569b565b6060820152615e966080840161569b565b6080820152615ea760a0840161569b565b60a0820152615eb860c0840161569b565b60c0820152615ec960e0840161569b565b60e0820152610100615edd85828601615dcc565b90820152610140615ef085858301615dcc565b61012083015261018080850151828401526101a09150818501516101608401526101c080860151828501526101e09150818601518385015261020086015181850152506102208501518184015250508091505092915050565b61ffff818116838216028082169190828114611a5457611a54615a42565b60008060008060808587031215615f7d57600080fd5b50508251602084015160408501516060909501519196909550909250905056fea2646970667358221220680769e47eb5ef1901b19da21d797a83a55c027e0700327a472633d829f9cc0364736f6c63430008150033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106102d35760003560e01c80637955fffd11610186578063a8d9f493116100e3578063e06a7b7111610097578063eb1db01811610071578063eb1db01814610676578063f70b198c14610689578063fda1fa5f1461069c57600080fd5b8063e06a7b7114610648578063e6bd26a214610650578063ea19ba111461066357600080fd5b8063c67b5093116100c8578063c67b50931461060d578063cbc7be651461062d578063dd19c0fe1461064057600080fd5b8063a8d9f493146105e5578063bf518f5f146105fa57600080fd5b80638a0038881161013a5780638f8b81f01161011f5780638f8b81f0146105ae5780639d7aeeb4146105c1578063a8bc0693146105d257600080fd5b80638a003888146105885780638bfbeda61461059b57600080fd5b8063816022b81161016b578063816022b8146105425780638530330414610555578063890a13911461056857600080fd5b80637955fffd1461052f5780637bbede431461046c57600080fd5b80632404a3f911610234578063347ca8bb116101e85780635486f100116101cd5780635486f100146104ed5780636463e94c146104f55780636902f79f1461050857600080fd5b8063347ca8bb146104b957806351971bf7146104da57600080fd5b80632dd31000116102195780632dd31000146104455780632f2612cf1461046c578063344bd722146104a657600080fd5b80632404a3f9146104105780632c44e1d11461042557600080fd5b80631949138e1161028b5780631f51fd93116102705780631f51fd93146103bd5780631fcd3649146103d057806320ee1e44146103f057600080fd5b80631949138e146103655780631ef8986d1461039d57600080fd5b8063144128e8116102bc578063144128e81461031e5780631579a46c1461033f578063168a11c21461035257600080fd5b806303e883e0146102d857806309c062e2146102fe575b600080fd5b6102eb6102e636600461481d565b6106a4565b6040519081526020015b60405180910390f35b61031161030c36600461481d565b610729565b6040516102f59190614e04565b61033161032c366004614e13565b610a1c565b6040516102f5929190614ed5565b6102eb61034d36600461481d565b610efc565b6102eb610360366004614ef2565b610f21565b610378610373366004614e13565b610fd1565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016102f5565b6103b06103ab366004615136565b611098565b6040516102f591906151b1565b6102eb6103cb36600461481d565b611156565b6103e36103de366004614ef2565b61125c565b6040516102f591906152c2565b6104036103fe36600461481d565b6117c1565b6040516102f591906152d1565b61041861190d565b6040516102f59190615354565b6104386104333660046153c3565b61191f565b6040516102f59190615489565b6103787f000000000000000000000000000000000000000000000000000000000000000081565b6102eb61047a3660046154d8565b604080516020808201939093528082019390935280518084038201815260609093019052815191012090565b6102eb6104b436600461481d565b611a5c565b6104cc6104c736600461481d565b611aa9565b6040516102f59291906154fa565b6102eb6104e836600461481d565b611c5e565b6102eb611c83565b61037861050336600461481d565b611d14565b6103787f000000000000000000000000000000000000000000000000000000000000000081565b61037861053d36600461481d565b611d39565b610378610550366004614ef2565b611d5e565b6102eb61056336600461555c565b611dc0565b61057b61057636600461481d565b611e49565b6040516102f59190615591565b6102eb610596366004614e13565b611f64565b6102eb6105a93660046155c0565b611fd2565b6102eb6105bc366004614e13565b612058565b6102eb6105cf366004614e13565b90565b6102eb6105e0366004614ef2565b612125565b6105ed612173565b6040516102f591906155ec565b6102eb610608366004614ef2565b61222d565b61062061061b36600461481d565b61227b565b6040516102f5919061563a565b6102eb61063b366004614ef2565b612469565b6104386124b7565b6103b06125e6565b61037861065e366004614e13565b61269c565b610418610671366004615136565b6126c8565b6102eb61068436600461481d565b61278b565b6102eb61069736600461481d565b6127b0565b6102eb6127d5565b600073ffffffffffffffffffffffffffffffffffffffff821663b5c736e4825b6040518263ffffffff1660e01b81526004016106e291815260200190565b602060405180830381865afa1580156106ff573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107239190615672565b92915050565b610731614481565b73ffffffffffffffffffffffffffffffffffffffff82168152600061075583611156565b90508015610a16576107678382612842565b6020808401829052610100909101510151600090819081908190819073ffffffffffffffffffffffffffffffffffffffff166108795760208701516101000151516040517fe72ef91b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8a81166004830152918216602482015260009182917f00000000000000000000000000000000000000000000000000000000000000009091169063e72ef91b906044016104c060405180830381865afa158015610844573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061086891906158cc565b60e08b019190915260200151935050505b6020808801516101200151015173ffffffffffffffffffffffffffffffffffffffff166109935760208701516101200151516040517f967915d600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8a81166004830152918216602482015260009182917f00000000000000000000000000000000000000000000000000000000000000009091169063967915d69060440161050060405180830381865afa158015610947573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061096b9190615972565b6101008b81018390529051604083015161014084015193909201519199509197509550925050505b6109a68888602001516101600151612acf565b604088018190526109bc90899088908585612e50565b6060880181905260208801516109d593508992506130fb565b85608001819052506109ff85606001518660200151876040015160a0015161ffff168686866133fc565b60a0860152610a0d866117c1565b60c08601525050505b50919050565b610a9a60405180610180016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160001515815260200160001515815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b610aa2614481565b8282526000610ab084610fd1565b905073ffffffffffffffffffffffffffffffffffffffff811615610ef6576000610ada8286612469565b9050610ae582610729565b6040517f6352211e000000000000000000000000000000000000000000000000000000008152600481018790529093507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690636352211e90602401602060405180830381865afa158015610b73573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b979190615a25565b73ffffffffffffffffffffffffffffffffffffffff1660208501526001808216146060850181905266ffffffffffffff603583901c811660ff602d85901c81169190911b610120880181905260c0880152607584901c909116606d84901c9091161b6101608601819052610100860152610ddb5780600216600214610c2d57610c28600282901c6207ffff16615a71565b610c38565b6207ffff600282901c165b60808501819052601582901c62ffffff1660a0860152610120850151606091610c639060020b613bfb565b610c6d9190615aa9565b901c6101408501819052610100850151610c8691615ac0565b60e08501526080840151600090610c9e908490610f21565b90508060011660011480610cbe57508460a0015162ffffff600183901c16115b15610d95576001604086810191909152608086015160a087015161014088015192517f22348cc70000000000000000000000000000000000000000000000000000000081526004810192909252602482015260448101919091526064810182905273ffffffffffffffffffffffffffffffffffffffff8416906322348cc79060840160a060405180830381865afa158015610d5d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d819190615ad3565b505061012088015261014087015260808601525b8461016001518561014001511115610dc857846101600151856101400151610dbd9190615ac0565b610140860152610dd9565b600061014086018190526101608601525b505b64e8d4a51000836060015160c001518560c00151610df99190615aa9565b610e039190615b42565b60c0850152606083015160e0908101519085015164e8d4a5100091610e2791615aa9565b610e319190615b42565b60e0808601919091526060840151015161010085015164e8d4a5100091610e5791615aa9565b610e619190615b42565b610100850152606083015160c0015161012085015164e8d4a5100091610e8691615aa9565b610e909190615b42565b610120850152606083015160e0015161014085015164e8d4a5100091610eb591615aa9565b610ebf9190615b42565b610140850152606083015160e0015161016085015164e8d4a5100091610ee491615aa9565b610eee9190615b42565b610160850152505b50915091565b600073ffffffffffffffffffffffffffffffffffffffff821663b5c736e460086106c4565b6040805160208082018490526005828401528251808303840181526060909201909252805191012060009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e4905b6040518263ffffffff1660e01b8152600401610f8991815260200190565b602060405180830381865afa158015610fa6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fca9190615672565b9392505050565b600080610fdd83611f64565b6040517fe6bd26a200000000000000000000000000000000000000000000000000000000815263ffffffff60c083901c1660048201529091507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063e6bd26a290602401602060405180830381865afa158015611074573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fca9190615a25565b80516060908067ffffffffffffffff8111156110b6576110b6614f1e565b6040519080825280602002602001820160405280156110ef57816020015b6110dc614481565b8152602001906001900390816110d45790505b50915060005b8181101561114f5761111f84828151811061111257611112615b7d565b6020026020010151610729565b83828151811061113157611131615b7d565b6020026020010181905250808061114790615bac565b9150506110f5565b5050919050565b60008173ffffffffffffffffffffffffffffffffffffffff163b60000361117f57506000919050565b8173ffffffffffffffffffffffffffffffffffffffff1663bb24fe8a6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015611204575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261120191810190615672565b60015b610723578173ffffffffffffffffffffffffffffffffffffffff1661122b61065e84611a5c565b73ffffffffffffffffffffffffffffffffffffffff161461124e57506000919050565b50612710919050565b919050565b6040805161014081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081019190915281156112b957816112cb565b6fffffffffffffffffffffffffffffffff5b915060006112d884611156565b905080156117ba5773ffffffffffffffffffffffffffffffffffffffff8416825260006113058583612842565b9050612710816101600151036115b0576101208101515173ffffffffffffffffffffffffffffffffffffffff9081166020850152610100820151518116604080860191909152517f8433ea220000000000000000000000000000000000000000000000000000000081526004810186905260006024820181905261dead6044830152606482015290861690638433ea229060840160408051808303816000875af19250505080156113f1575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526113ee91810190615be4565b60015b61146d576113fd615c08565b806308c379a0036114225750611411615c23565b8061141c5750611424565b50611470565b505b3d80801561144e576040519150601f19603f3d011682016040523d82523d6000602084013e611453565b606091505b5061145d81613e5d565b60c086015260a085015250611470565b50505b6040517f8433ea22000000000000000000000000000000000000000000000000000000008152600481018590526000602482015261dead60448201526001606482015273ffffffffffffffffffffffffffffffffffffffff861690638433ea229060840160408051808303816000875af192505050801561152c575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261152991810190615be4565b60015b6115a957611538615c08565b806308c379a00361155d575061154c615c23565b80611557575061155f565b50611792565b505b3d808015611589576040519150601f19603f3d011682016040523d82523d6000602084013e61158e565b606091505b5061159881613e5d565b61010086015260e085015250611792565b5050611792565b610120810180515173ffffffffffffffffffffffffffffffffffffffff908116602086810191909152610100840180515183166040808901919091529351820151831660608801525101518116608086015290517f3202937e000000000000000000000000000000000000000000000000000000008152600060048201819052602482015290861690633202937e90604401600060405180830381600087803b15801561165c57600080fd5b505af192505050801561166d575060015b6116e557611679615c08565b806308c379a00361169e575061168d615c23565b8061169857506116a0565b506116e5565b505b3d8080156116ca576040519150601f19603f3d011682016040523d82523d6000602084013e6116cf565b606091505b506116d981613e5d565b60c086015260a0850152505b6040517f3202937e000000000000000000000000000000000000000000000000000000008152600060048201526001602482015273ffffffffffffffffffffffffffffffffffffffff861690633202937e90604401600060405180830381600087803b15801561175457600080fd5b505af1925050508015611765575060015b61179257611771615c08565b806308c379a00361155d5750611785615c23565b80611790575061155f565b505b8260a001518360e0015111806117b057508260c00151836101000151115b1515610120840152505b5092915050565b6117c9614783565b60006117d4836106a4565b90506117e8620fffff600283901c16612058565b6020830152633fffffff601682901c81166040840152603482901c16606083015266ffffffffffffff605a82901c1660ff605283901c161b60a083015266ffffffffffffff609a82901c1660ff609283901c161b608083015260d281901c63ffffffff168252604082015160009061186190859061222d565b60c08401516003821690529050611880600282901c620fffff16612058565b60c0840180516020019190915280516603ffffffffffff607484901c1660409091015251633fffffff601683901c1660609091015266ffffffffffffff603c82901c1660ff603483901c161b60c084018051608001919091525160a682901c633fffffff1660a0909101526118fd60c482901c620fffff16612058565b60c0808501510152509092915050565b606061191a610671612173565b905090565b81516060908067ffffffffffffffff81111561193d5761193d614f1e565b6040519080825280602002602001820160405280156119da57816020015b604080516101408101825260008082526020808301829052928201819052606082018190526080820181905260a0820181905260c0820181905260e08201819052610100820181905261012082015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90920191018161195b5790505b50915060005b81811015611a5457611a248582815181106119fd576119fd615b7d565b6020026020010151858381518110611a1757611a17615b7d565b602002602001015161125c565b838281518110611a3657611a36615b7d565b60200260200101819052508080611a4c90615bac565b9150506119e0565b505092915050565b60008173ffffffffffffffffffffffffffffffffffffffff1663540acabc6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156106ff573d6000803e3d6000fd5b6060806000611ab78461227b565b80519091508067ffffffffffffffff811115611ad557611ad5614f1e565b604051908082528060200260200182016040528015611b8457816020015b611b7160405180610180016040528060008152602001600073ffffffffffffffffffffffffffffffffffffffff16815260200160001515815260200160001515815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b815260200190600190039081611af35790505b5093508067ffffffffffffffff811115611ba057611ba0614f1e565b604051908082528060200260200182016040528015611bd957816020015b611bc6614481565b815260200190600190039081611bbe5790505b50925060005b81811015611c5657611c09838281518110611bfc57611bfc615b7d565b6020026020010151610a1c565b868381518110611c1b57611c1b615b7d565b60200260200101868481518110611c3457611c34615b7d565b6020026020010182905282905250508080611c4e90615bac565b915050611bdf565b505050915091565b600073ffffffffffffffffffffffffffffffffffffffff821663b5c736e4600a6106c4565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16638d6540236040518163ffffffff1660e01b8152600401602060405180830381865afa158015611cf0573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061191a9190615672565b600073ffffffffffffffffffffffffffffffffffffffff821663b5c736e460096106c4565b600073ffffffffffffffffffffffffffffffffffffffff821663b5c736e4600b6106c4565b600080611d7384611d6e86611156565b612842565b60a081015190915073ffffffffffffffffffffffffffffffffffffffff161580611d9b575082155b15611daa576000915050610723565b611db88160a0015184613ecb565b949350505050565b60008373ffffffffffffffffffffffffffffffffffffffff1663b5c736e4611dea60068686611fd2565b6040518263ffffffff1660e01b8152600401611e0891815260200190565b602060405180830381865afa158015611e25573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611db89190615672565b6040805180820190915260006020820181905273ffffffffffffffffffffffffffffffffffffffff83168252611e7e836127b0565b90508273ffffffffffffffffffffffffffffffffffffffff1663ebd93ac66040518163ffffffff1660e01b8152600401600060405180830381600087803b158015611ec857600080fd5b505af1925050508015611ed9575060015b611f4257611ee5615c08565b806308c379a003611f0a5750611ef9615c23565b80611f045750611f0c565b50610a16565b505b3d808015611f36576040519150601f19603f3d011682016040523d82523d6000602084013e611f3b565b606091505b5050610a16565b6000611f4d846127b0565b905081811461114f57600160208401525050919050565b6040805160208082018490526003828401528251808303840181526060909201909252805191012060009073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063b5c736e4906106c4565b6000808385604051602001611ff1929190918252602082015260400190565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815282825280516020918201209083018690529082018190529150606001604051602081830303815290604052805190602001209150509392505050565b6000620fffff82106120ca576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f696e76616c69642d6e756d626572000000000000000000000000000000000000604482015260640160405180910390fd5b81156120fe57816001166001146120f2576120ed600183901c6207ffff16615a71565b610723565b5060011c6207ffff1690565b507f8000000000000000000000000000000000000000000000000000000000000000919050565b6040805160208082018490526004828401528251808303840181526060909201909252805191012060009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490610f6b565b6060600061217f611c83565b90508067ffffffffffffffff81111561219a5761219a614f1e565b6040519080825280602002602001820160405280156121c3578160200160208202803683370190505b50915060005b81811015612228576121df61065e826001615ccb565b8382815181106121f1576121f1615b7d565b73ffffffffffffffffffffffffffffffffffffffff909216602092830291909101909101528061222081615bac565b9150506121c9565b505090565b6040805160208082018490526007828401528251808303840181526060909201909252805191012060009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490610f6b565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301526060916000917f000000000000000000000000000000000000000000000000000000000000000016906370a0823190602401602060405180830381865afa15801561230d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123319190615672565b90508067ffffffffffffffff81111561234c5761234c614f1e565b604051908082528060200260200182016040528015612375578160200160208202803683370190505b50915060005b8181101561114f576040517f2f745c5900000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8581166004830152602482018390527f00000000000000000000000000000000000000000000000000000000000000001690632f745c5990604401602060405180830381865afa158015612416573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061243a9190615672565b83828151811061244c5761244c615b7d565b60209081029190910101528061246181615bac565b91505061237b565b6040805160208082018490526003828401528251808303840181526060909201909252805191012060009073ffffffffffffffffffffffffffffffffffffffff84169063b5c736e490610f6b565b606060006124c3612173565b80519091508067ffffffffffffffff8111156124e1576124e1614f1e565b60405190808252806020026020018201604052801561257e57816020015b604080516101408101825260008082526020808301829052928201819052606082018190526080820181905260a0820181905260c0820181905260e08201819052610100820181905261012082015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9092019101816124ff5790505b50925060005b818110156125e0576125b08382815181106125a1576125a1615b7d565b6020026020010151600061125c565b8482815181106125c2576125c2615b7d565b602002602001018190525080806125d890615bac565b915050612584565b50505090565b606060006125f2612173565b80519091508067ffffffffffffffff81111561261057612610614f1e565b60405190808252806020026020018201604052801561264957816020015b612636614481565b81526020019060019003908161262e5790505b50925060005b818110156125e05761266c83828151811061111257611112615b7d565b84828151811061267e5761267e615b7d565b6020026020010181905250808061269490615bac565b91505061264f565b60006107237f000000000000000000000000000000000000000000000000000000000000000083613ecb565b80516060908067ffffffffffffffff8111156126e6576126e6614f1e565b60405190808252806020026020018201604052801561272b57816020015b60408051808201909152600080825260208201528152602001906001900390816127045790505b50915060005b8181101561114f5761275b84828151811061274e5761274e615b7d565b6020026020010151611e49565b83828151811061276d5761276d615b7d565b6020026020010181905250808061278390615bac565b915050612731565b600073ffffffffffffffffffffffffffffffffffffffff821663b5c736e460016106c4565b600073ffffffffffffffffffffffffffffffffffffffff821663b5c736e460026106c4565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611cf0573d6000803e3d6000fd5b6128e1604080516102008101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905260c0830182905260e0830182905283518085018552828152808201839052610100840152835180850190945281845283015290610120820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c09091015290565b6127108203612a5f578273ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b81526004016101a060405180830381865afa925050508015612970575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261296d91810190615cef565b60015b1561072357805173ffffffffffffffffffffffffffffffffffffffff908116835260208083015182168185015285821660408086019190915283015182166060808601919091528301518216608080860191909152600060a08087018290528551851660c08801528551851660e0880152918501516101008088018051928716909252905184018290529185015161012080880180519290961690915293519092019190915282015161014080850191909152612710610160808601919091529183015161018080860191909152908301516101a0850152908201516101c084015201516101e0820152610723565b8273ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa158015612aab573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fca9190615e31565b604080516101a081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e081018290526101008101829052610120810182905261014081018290526101608101829052610180810182905290612b418461278b565b61ffff8082168452601082901c16602080850191909152909150612b6d9082901c6103ff16600a615f49565b61ffff166040830152612b89602a82901c6103ff16600a615f49565b61ffff166060830152612ba5603482901c6103ff16600a615f49565b61ffff166080830152612bc1603e82901c6103ff16600a615f49565b61ffff1660a08301526103ff604882901c811660c0840152605282901c1660e08301527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd8f08301612c1b57606081901c610100830152612c67565b605c81901c633fffffff168015612c5357612c368582611d5e565b73ffffffffffffffffffffffffffffffffffffffff166101008401525b50607a81901c6401ffffffff166101808301525b61010082015173ffffffffffffffffffffffffffffffffffffffff1615612e245781610100015173ffffffffffffffffffffffffffffffffffffffff16638e7bfbc06040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015612d12575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612d0f91810190615672565b60015b612d9d5781610100015173ffffffffffffffffffffffffffffffffffffffff1663e6aa216c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612d66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d8a9190615672565b6101208301819052610140830152612e24565b808361012001818152505082610100015173ffffffffffffffffffffffffffffffffffffffff1663f3190c896040518163ffffffff1660e01b8152600401602060405180830381865afa158015612df8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612e1c9190615672565b610140840152505b612e2d84611d14565b73ffffffffffffffffffffffffffffffffffffffff166101608301525092915050565b612ec2604051806101c0016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000612ecd87610efc565b67ffffffffffffffff8082168452604082811c82166020860152608083901c9091169084015260c081901c6060840152905073ffffffffffffffffffffffffffffffffffffffff87166309f0d8cb612f248961278b565b6040518263ffffffff1660e01b8152600401612f4291815260200190565b608060405180830381865afa158015612f5f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f839190615f67565b60e086015260c085015260a0840152608083015261010082018490526101208201839052614e20861480612fb85750619c4086145b15612fff578451600190811c617fff16610140840152855116600003612fee57816101400151612fe790615a71565b6101408301525b610140820151610180830152613041565b84516127109061ffff16850204610140830152845161ffff167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd8f0016101808301525b6175308614806130525750619c4086145b1561309d57602085018051600190811c617fff1661016085015290511660000361308c5781610160015161308590615a71565b6101608301525b6101608201516101a08301526130f1565b612710856020015161ffff168402816130b8576130b8615b13565b04610160830152602085015161ffff167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd8f0016101a08301525b5095945050505050565b6131346040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b600061313f856106a4565b9050600061314c866127b0565b905060008460c0015173ffffffffffffffffffffffffffffffffffffffff1663b5c736e4866101c001516040518263ffffffff1660e01b815260040161319491815260200190565b602060405180830381865afa1580156131b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131d59190615672565b6101008601516020015190915073ffffffffffffffffffffffffffffffffffffffff1661320e5760011c67ffffffffffffffff1661321c565b60011c67ffffffffffffffff165b60ff8116600882901c901b905060008560e0015173ffffffffffffffffffffffffffffffffffffffff1663b5c736e4876101e001516040518263ffffffff1660e01b815260040161326f91815260200190565b602060405180830381865afa15801561328c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132b09190615672565b6101208701516020015190915073ffffffffffffffffffffffffffffffffffffffff166132e95760011c67ffffffffffffffff166132f7565b60011c67ffffffffffffffff165b66ffffffffffffff605a85901c8116605286901c60ff9081169190911b808852609a87901c909216609287901c82161b602088015260408701849052600883901c92169190911b606086018190526fffffffffffffffffffffffffffffffff841660a0870152608084811c9087015260c0880151909164e8d4a51000910204855260e0870151602086015164e8d4a5100091020460208601526080870151604086015164e8d4a51000910204604086015260a0870151606086015164e8d4a51000910204606086015260c0870151608086015164e8d4a51000910204608086015260e087015160a086015164e8d4a5100091020460a086015250929695505050505050565b61344460405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b60c08601516101c08701516040517fb5c736e4000000000000000000000000000000000000000000000000000000008152600481019190915260009173ffffffffffffffffffffffffffffffffffffffff169063b5c736e490602401602060405180830381865afa1580156134bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906134e19190615672565b9050801561396657600080886000015173ffffffffffffffffffffffffffffffffffffffff168960c0015173ffffffffffffffffffffffffffffffffffffffff16036135515766ffffffffffffff600984901c1660ff600185901c161b915061354a8383614335565b9050613577565b66ffffffffffffff600984901c1660ff600185901c161b91506135748383614335565b90505b64e8d4a510008a6080015182028161359157613591615b13565b0480855282116135a25760006135a7565b835182035b60208501528351600090156135c257612710838a02046135c5565b60005b9050808560200151116135d95760006135f8565b620f424081866020015103620f423f02816135f6576135f6615b13565b045b602080870182905260408701919091526101008b0151015173ffffffffffffffffffffffffffffffffffffffff16905061396357600073eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee73ffffffffffffffffffffffffffffffffffffffff168a61010001516000015173ffffffffffffffffffffffffffffffffffffffff160361369d5750885173ffffffffffffffffffffffffffffffffffffffff163161394d565b6101008a0151518a516040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff91821660048201529116906370a0823190602401602060405180830381865afa158015613712573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137369190615672565b905073cd5fe23c85820f7b72d0926fc9b05b43e359b7ee73ffffffffffffffffffffffffffffffffffffffff168a61010001516000015173ffffffffffffffffffffffffffffffffffffffff16036138495789516040517fb203bb9900000000000000000000000000000000000000000000000000000000815273cd5fe23c85820f7b72d0926fc9b05b43e359b7ee600482015273ffffffffffffffffffffffffffffffffffffffff909116602482015273f047ab4c75cebf0eb9ed34ae2c186f3611aeafa69063b203bb9990604401602060405180830381865afa158015613823573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906138479190615672565b015b6101008a01515173ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffff6e83117fe59806cc0d194cc03f32e12d2a6f62780161394d5789516040517fb203bb9900000000000000000000000000000000000000000000000000000000815273917cee801a67f933f2e6b33fc0cd1ed2d5909d88600482015273ffffffffffffffffffffffffffffffffffffffff909116602482015273f047ab4c75cebf0eb9ed34ae2c186f3611aeafa69063b203bb9990604401602060405180830381865afa158015613927573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061394b9190615672565b015b846020015181101561396157604085018190525b505b50505b60e08701516101e08801516040517fb5c736e4000000000000000000000000000000000000000000000000000000008152600481019190915260009173ffffffffffffffffffffffffffffffffffffffff169063b5c736e490602401602060405180830381865afa1580156139df573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613a039190615672565b90508015613bc7576101208801516020015173ffffffffffffffffffffffffffffffffffffffff16613b70576060830186905260c08301859052620f4240620f423f85020460808401526101208801515160009073ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffff111111111111111111111111111111111111111201613ab25750875173ffffffffffffffffffffffffffffffffffffffff1631613b4e565b6101208901515189516040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff91821660048201529116906370a0823190602401602060405180830381865afa158015613b27573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b4b9190615672565b90505b83608001518111613b5f5780613b65565b83608001515b60a085015250613bc7565b66ffffffffffffff600982901c1660ff600183901c161b613b9182826143c9565b606085018190528110613ba5576000613bad565b808460600151035b620f4240620f423f909102046080850181905260a0850152505b64e8d4a510008960e00151612711613bdf9190615aa9565b613be99190615b42565b60e08401525090979650505050505050565b600060ff82901d80831803617fff811115613c1557600080fd5b7001000000000000000000000000000000006001821615613c4357506fff9dd7de423466c20352b1246ce4856f5b6002821615613c62576fff3bd55f4488ad277531fa1c725a66d00260801c5b6004821615613c81576ffe78410fd6498b73cb96a6917f8532590260801c5b6008821615613ca0576ffcf2d9987c9be178ad5bfeffaa1232730260801c5b6010821615613cbf576ff9ef02c4529258b057769680fc6601b30260801c5b6020821615613cde576ff402d288133a85a17784a411f7aba0820260801c5b6040821615613cfd576fe895615b5beb6386553757b0352bda900260801c5b6080821615613d1c576fd34f17a00ffa00a8309940a15930391a0260801c5b610100821615613d3c576fae6b7961714e20548d88ea5123f9a0ff0260801c5b610200821615613d5c576f76d6461f27082d74e0feed3b388c0ca10260801c5b610400821615613d7c576f372a3bfe0745d8b6b19d985d9a8b85bb0260801c5b610800821615613d9c576f0be32cbee48979763cf7247dd7bb539d0260801c5b611000821615613dbb576e8d4f70c9ff4924dac37612d1e2921e0260801c5b612000821615613dd9576d4e009ae5519380809a02ca7aec770260801c5b614000821615613df5576b17c45e641b6e95dee056ff100260801c5b600091507f80000000000000000000000000000000000000000000000000000000000000008416613e53577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0463ffffffff811615613e5357600191505b60201c0192915050565b6000806044835110613ec65760208301517f33c955bc000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000821601610ef65750505060248101516044820151905b915091565b6000606082600003613ee1576000915050610723565b607f8311613faa576040517fd60000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b16602282015260f884901b7fff000000000000000000000000000000000000000000000000000000000000001660368201526037015b6040516020818303038152906040529050614326565b60ff8311614087576040517fd70000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f8100000000000000000000000000000000000000000000000000000000000000603682015260f884901b7fff00000000000000000000000000000000000000000000000000000000000000166037820152603801613f94565b61ffff8311614165576040517fd80000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f820000000000000000000000000000000000000000000000000000000000000060368201527fffff00000000000000000000000000000000000000000000000000000000000060f085901b166037820152603901613f94565b62ffffff8311614244576040517fd90000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f830000000000000000000000000000000000000000000000000000000000000060368201527fffffff000000000000000000000000000000000000000000000000000000000060e885901b166037820152603a01613f94565b6040517fda0000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f840000000000000000000000000000000000000000000000000000000000000060368201527fffffffff0000000000000000000000000000000000000000000000000000000060e085901b166037820152603b0160405160208183030381529060405290505b80516020909101209392505050565b600066ffffffffffffff604984901c1660ff604185901c161b80820361435f576000915050610723565b612710613fff60a286901c168402046401ffffffff608186901c16420362ffffff60b087901c166143908284615aa9565b61439a9190615b42565b90508083116143aa5760006143ae565b8083035b935050808403838111156143c0578093505b50505092915050565b60d082901c6103ff1660c883901c60ff161b613fff60a284901c1661271083820204808401838110156143fe57505050610723565b608186901c6401ffffffff164203925066ffffffffffffff604987901c1660ff604188901c161b60b087901c62ffffff166144398585615aa9565b6144439190615b42565b61444d9190615ccb565b93508084111561445b578093505b6103ff60e287901c1660ff60da88901c161b9250828411156143c0575090949350505050565b604051806101200160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001614549604080516102008101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905260c0830182905260e0830182905283518085018552828152808201839052610100840152835180850190945281845283015290610120820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c09091015290565b8152604080516101a08101825260008082526020828101829052928201819052606082018190526080820181905260a0820181905260c0820181905260e082018190526101008201819052610120820181905261014082018190526101608201819052610180820152910190815260200161462c604051806101c0016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b815260200161466a6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b81526020016146b760405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b81526020016146c4614783565b815260200161471a60405180610120016040528060001515815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b815260200161477e604051806101600160405280600015158152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b905290565b6040518060e0016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200161477e6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b73ffffffffffffffffffffffffffffffffffffffff8116811461481a57600080fd5b50565b60006020828403121561482f57600080fd5b8135610fca816147f8565b805173ffffffffffffffffffffffffffffffffffffffff168252602081015161487b602084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060408101516148a3604084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060608101516148cb606084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060808101516148f3608084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060a081015161491b60a084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060c081015161494360c084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060e081015161496b60e084018273ffffffffffffffffffffffffffffffffffffffff169052565b5061010081810151805173ffffffffffffffffffffffffffffffffffffffff9081168584015260208201511661012085015250506101208101516101406149d781850183805173ffffffffffffffffffffffffffffffffffffffff908116835260209182015116910152565b820151610180848101919091526101608301516101a080860191909152908301516101c080860191909152908301516101e08086019190915290830151610200850152909101516102209092019190915250565b805161ffff1682526020810151614a48602084018261ffff169052565b506040810151614a5e604084018261ffff169052565b506060810151614a74606084018261ffff169052565b506080810151614a8a608084018261ffff169052565b5060a0810151614aa060a084018261ffff169052565b5060c0810151614ab660c084018261ffff169052565b5060e0810151614acc60e084018261ffff169052565b506101008181015173ffffffffffffffffffffffffffffffffffffffff8116848301525050610120818101519083015261014080820151908301526101608082015173ffffffffffffffffffffffffffffffffffffffff811682850152505061018090810151910152565b805173ffffffffffffffffffffffffffffffffffffffff1682526020810151614b63602084018261483a565b506040810151614b77610260840182614a2b565b5060608181015180516104008501526020808201516104208601526040808301516104408701528284015161046087015260808084015161048088015260a0808501516104a089015260c0808601516104c08a015260e0808701516104e08b0152610100808801516105008c0152610120808901516105208d0152610140808a01516105408e01526101608a01516105608e01526101808a01516105808e01526101a0909901516105a08d0152858b015180516105c08e0152808901516105e08e0152808801516106008e0152808b01516106208e0152808701516106408e01528501516106608d0152848b015180516106808e0152808901516106a08e0152808801516106c08e0152808b01516106e08e0152808701516107008e0152808601516107208e0152808501516107408e01528301516107608d0152838b015180516107808e0152808901516107a08e0152808801516107c08e0152808b01516107e08e0152808701516108008e0152808601516108208e015284015180516108408e0152808901516108608e0152808801516108808e0152808b01516108a08e0152808701516108c08e0152808601516108e08e01528401516109008d0152828b0151805115156109208e0152808901516109408e0152808801516109608e0152808b01516109808e0152808701516109a08e0152808601516109c08e0152808501516109e08e015280840151610a008e0152820151610a208d01529981015180511515610a408d015296870151610a608c015294860151610a808b015296850151610aa08a015291840151610ac0890152830151610ae0880152820151610b0087015292810151610b2086015291820151610b4085015291810151610b608401520151610b8090910152565b610ba081016107238284614b37565b600060208284031215614e2557600080fd5b5035919050565b805182526020810151614e57602084018273ffffffffffffffffffffffffffffffffffffffff169052565b506040810151614e6b604084018215159052565b506060810151614e7f606084018215159052565b506080818101519083015260a0808201519083015260c0808201519083015260e0808201519083015261010080820151908301526101208082015190830152610140808201519083015261016090810151910152565b610d208101614ee48285614e2c565b610fca610180830184614b37565b60008060408385031215614f0557600080fd5b8235614f10816147f8565b946020939093013593505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6060810181811067ffffffffffffffff82111715614f6d57614f6d614f1e565b60405250565b60a0810181811067ffffffffffffffff82111715614f6d57614f6d614f1e565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f830116810181811067ffffffffffffffff82111715614fd757614fd7614f1e565b6040525050565b604051610220810167ffffffffffffffff8111828210171561500257615002614f1e565b60405290565b604051610120810167ffffffffffffffff8111828210171561500257615002614f1e565b604051610160810167ffffffffffffffff8111828210171561500257615002614f1e565b6040516101a0810167ffffffffffffffff8111828210171561500257615002614f1e565b604051610200810167ffffffffffffffff8111828210171561500257615002614f1e565b600067ffffffffffffffff8211156150b2576150b2614f1e565b5060051b60200190565b600082601f8301126150cd57600080fd5b813560206150da82615098565b6040516150e78282614f93565b83815260059390931b850182019282810191508684111561510757600080fd5b8286015b8481101561512b57803561511e816147f8565b835291830191830161510b565b509695505050505050565b60006020828403121561514857600080fd5b813567ffffffffffffffff81111561515f57600080fd5b611db8848285016150bc565b600081518084526020808501945080840160005b838110156151a657615192878351614b37565b610ba096909601959082019060010161517f565b509495945050505050565b602081526000610fca602083018461516b565b805173ffffffffffffffffffffffffffffffffffffffff1682526020810151615205602084018273ffffffffffffffffffffffffffffffffffffffff169052565b50604081015161522d604084018273ffffffffffffffffffffffffffffffffffffffff169052565b506060810151615255606084018273ffffffffffffffffffffffffffffffffffffffff169052565b50608081015161527d608084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060a081015160a083015260c081015160c083015260e081015160e0830152610100808201518184015250610120808201516152bc8285018215159052565b50505050565b610140810161072382846151c4565b815181526020808301518183015260408084015181840152606080850151818501526080808601518186015260a0808701518187015260c0808801518051828901529586015160e0880152938501516101008701529184015161012086015283015161014085015282015161016084015201516101808201526101a08101610723565b602080825282518282018190526000919060409081850190868401855b828110156153b6576153a6848351805173ffffffffffffffffffffffffffffffffffffffff1682526020908101511515910152565b9284019290850190600101615371565b5091979650505050505050565b600080604083850312156153d657600080fd5b823567ffffffffffffffff808211156153ee57600080fd5b6153fa868387016150bc565b935060209150818501358181111561541157600080fd5b85019050601f8101861361542457600080fd5b803561542f81615098565b60405161543c8282614f93565b82815260059290921b830184019184810191508883111561545c57600080fd5b928401925b8284101561547a57833582529284019290840190615461565b80955050505050509250929050565b6020808252825182820181905260009190848201906040850190845b818110156154cc576154b88385516151c4565b9284019261014092909201916001016154a5565b50909695505050505050565b600080604083850312156154eb57600080fd5b50508035926020909101359150565b604080825283519082018190526000906020906060840190828701845b8281101561553e5761552a848351614e2c565b610180939093019290840190600101615517565b50505083810382850152615552818661516b565b9695505050505050565b60008060006060848603121561557157600080fd5b833561557c816147f8565b95602085013595506040909401359392505050565b815173ffffffffffffffffffffffffffffffffffffffff16815260208083015115159082015260408101610723565b6000806000606084860312156155d557600080fd5b505081359360208301359350604090920135919050565b6020808252825182820181905260009190848201906040850190845b818110156154cc57835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101615608565b6020808252825182820181905260009190848201906040850190845b818110156154cc57835183529284019291840191600101615656565b60006020828403121561568457600080fd5b5051919050565b8051801515811461125757600080fd5b8051611257816147f8565b600060e082840312156156b857600080fd5b60405160e0810181811067ffffffffffffffff821117156156db576156db614f1e565b806040525080915082516156ee816147f8565b808252506020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c08201525092915050565b60008183036101a081121561574957600080fd5b60405161575581614f4d565b8092508351815260a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08301121561578c57600080fd5b604051915061579a82614f73565b60208401516157a8816147f8565b8083525060408401516020830152606084015160408301526080840151606083015260a084015160808301528160208201526157e78560c086016156a6565b6040820152505092915050565b60006103a0828403121561580757600080fd5b61580f614fde565b825181526020808401519082015260408084015190820152606080840151908201526080808401519082015260a0808401519082015260c0808401519082015260e08084015190820152610100808401519082015261012080840151908201526101408084015190820152610160808401519082015261018080840151908201526101a080840151908201526101c080840151908201526101e0808401519082015290506102006158c284828501615735565b9082015292915050565b6000808284036104c08112156158e157600080fd5b610120808212156158f157600080fd5b6158f9615008565b91506159048561568b565b82526020850151602083015260408501516040830152606085015160608301526080850151608083015260a085015160a083015260c085015160c083015260e085015160e0830152610100808601518184015250819350615967868287016157f4565b925050509250929050565b60008082840361050081121561598757600080fd5b6101608082121561599757600080fd5b61599f61502c565b91506159aa8561568b565b82526020850151602083015260408501516040830152606085015160608301526080850151608083015260a085015160a083015260c085015160c083015260e085015160e0830152610100808601518184015250610120808601518184015250610140808601518184015250819350615967868287016157f4565b600060208284031215615a3757600080fd5b8151610fca816147f8565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007f80000000000000000000000000000000000000000000000000000000000000008203615aa257615aa2615a42565b5060000390565b808202811582820484141761072357610723615a42565b8181038181111561072357610723615a42565b600080600080600060a08688031215615aeb57600080fd5b5050835160208501516040860151606087015160809097015192989197509594509092509050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600082615b78577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203615bdd57615bdd615a42565b5060010190565b60008060408385031215615bf757600080fd5b505080516020909101519092909150565b600060033d11156105cf5760046000803e5060005160e01c90565b600060443d1015615c315790565b6040517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc803d016004833e81513d67ffffffffffffffff8160248401118184111715615c7f57505050505090565b8285019150815181811115615c975750505050505090565b843d8701016020828501011115615cb15750505050505090565b615cc060208286010187614f93565b509095945050505050565b8082018082111561072357610723615a42565b805160ff8116811461125757600080fd5b60006101a08284031215615d0257600080fd5b615d0a615050565b615d138361569b565b8152615d216020840161569b565b6020820152615d326040840161569b565b6040820152615d436060840161569b565b6060820152615d546080840161569b565b6080820152615d6560a0840161569b565b60a0820152615d7660c08401615cde565b60c0820152615d8760e08401615cde565b60e08201526101008381015190820152610120808401519082015261014080840151908201526101608084015190820152610180928301519281019290925250919050565b600060408284031215615dde57600080fd5b6040516040810181811067ffffffffffffffff82111715615e0157615e01614f1e565b80604052508091508251615e14816147f8565b81526020830151615e24816147f8565b6020919091015292915050565b60006102408284031215615e4457600080fd5b615e4c615074565b615e558361569b565b8152615e636020840161569b565b6020820152615e746040840161569b565b6040820152615e856060840161569b565b6060820152615e966080840161569b565b6080820152615ea760a0840161569b565b60a0820152615eb860c0840161569b565b60c0820152615ec960e0840161569b565b60e0820152610100615edd85828601615dcc565b90820152610140615ef085858301615dcc565b61012083015261018080850151828401526101a09150818501516101608401526101c080860151828501526101e09150818601518385015261020086015181850152506102208501518184015250508091505092915050565b61ffff818116838216028082169190828114611a5457611a54615a42565b60008060008060808587031215615f7d57600080fd5b50508251602084015160408501516060909501519196909550909250905056fea2646970667358221220680769e47eb5ef1901b19da21d797a83a55c027e0700327a472633d829f9cc0364736f6c63430008150033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getAbsorbedDustDebt(address)": {
        "params": {
          "vault_": "The address of the vault."
        },
        "returns": {
          "_0": "The absorbed dust debt of the vault."
        }
      },
      "getAbsorbedLiquidityRaw(address)": {
        "params": {
          "vault_": "The address of the vault."
        },
        "returns": {
          "_0": "The absorbed liquidity of the vault."
        }
      },
      "getAllVaultsAddresses()": {
        "returns": {
          "vaults_": "The addresses of all the vaults."
        }
      },
      "getAllVaultsLiquidation()": {
        "returns": {
          "liquidationsData_": "An array of LiquidationStruct containing the liquidation data for all vaults."
        }
      },
      "getBranchDataRaw(address,uint256)": {
        "params": {
          "branch_": "The branch value.",
          "vault_": "The address of the vault."
        },
        "returns": {
          "_0": "The raw branch data of the vault."
        }
      },
      "getContractForDeployerIndex(address,uint256)": {
        "params": {
          "index_": "The index of the deployer.",
          "vault_": "The address of the vault."
        },
        "returns": {
          "_0": "The contract for deployer index of the vault."
        }
      },
      "getDexFromAddress(address)": {
        "params": {
          "vault_": "The address of the vault."
        },
        "returns": {
          "_0": "The DEX from address of the vault."
        }
      },
      "getMultipleVaultsLiquidation(address[],uint256[])": {
        "params": {
          "tokensInAmt_": "The array of token amounts to liquidate.",
          "vaults_": "The array of vault addresses."
        },
        "returns": {
          "liquidationsData_": "An array of LiquidationStruct containing the liquidation data for each vault."
        }
      },
      "getPositionDataRaw(address,uint256)": {
        "params": {
          "positionId_": "The ID of the position.",
          "vault_": "The address of the vault."
        },
        "returns": {
          "_0": "The position data of the vault."
        }
      },
      "getRateRaw(address)": {
        "params": {
          "vault_": "The address of the vault."
        },
        "returns": {
          "_0": "The raw rate of the vault."
        }
      },
      "getRebalancer(address)": {
        "params": {
          "vault_": "The address of the vault."
        },
        "returns": {
          "_0": "The rebalancer of the vault."
        }
      },
      "getTickDataRaw(address,int256)": {
        "params": {
          "tick_": "The tick value.",
          "vault_": "The address of the vault."
        },
        "returns": {
          "_0": "The raw tick data of the vault."
        }
      },
      "getTickHasDebtRaw(address,int256)": {
        "params": {
          "key_": "The tick key.",
          "vault_": "The address of the vault."
        },
        "returns": {
          "_0": "The raw tick data of the vault."
        }
      },
      "getTickIdDataRaw(address,int256,uint256)": {
        "params": {
          "id_": "The ID of the tick.",
          "tick_": "The tick value.",
          "vault_": "The address of the vault."
        },
        "returns": {
          "_0": "The raw tick data of the vault."
        }
      },
      "getTokenConfig(uint256)": {
        "params": {
          "nftId_": "The ID of the NFT."
        },
        "returns": {
          "_0": "The token configuration."
        }
      },
      "getTotalVaults()": {
        "returns": {
          "_0": "The total number of vaults."
        }
      },
      "getVaultAbsorb(address)": {
        "params": {
          "vault_": "The address of the vault."
        },
        "returns": {
          "absorbData_": "The AbsorbStruct containing the absorb data for the vault."
        }
      },
      "getVaultAddress(uint256)": {
        "params": {
          "vaultId_": "The ID of the vault."
        },
        "returns": {
          "vault_": "The address of the vault."
        }
      },
      "getVaultEntireData(address)": {
        "params": {
          "vault_": "The address of the vault to retrieve the data for."
        },
        "returns": {
          "vaultData_": "The entire data of the vault."
        }
      },
      "getVaultId(address)": {
        "params": {
          "vault_": "The address of the vault."
        },
        "returns": {
          "id_": "The ID of the vault."
        }
      },
      "getVaultLiquidation(address,uint256)": {
        "params": {
          "tokenInAmt_": "token in aka debt to payback, leave 0 to get max",
          "vault_": "address of vault for which to fetch"
        },
        "returns": {
          "liquidationData_": "liquidation related data. Check out structs.sol"
        }
      },
      "getVaultState(address)": {
        "params": {
          "vault_": "The address of the vault to retrieve the state for."
        },
        "returns": {
          "vaultState_": "The state of the vault, including top tick, current and total branches,                     total supply and borrow, total positions, and current branch state."
        }
      },
      "getVaultType(address)": {
        "params": {
          "vault_": "The address of the vault."
        },
        "returns": {
          "vaultType_": "The type of the vault. 0 if not a Fluid vault."
        }
      },
      "getVaultVariables2Raw(address)": {
        "params": {
          "vault_": "The address of the vault."
        },
        "returns": {
          "_0": "The raw variables of the vault."
        }
      },
      "getVaultVariablesRaw(address)": {
        "params": {
          "vault_": "The address of the vault."
        },
        "returns": {
          "_0": "The raw variables of the vault."
        }
      },
      "getVaultsAbsorb()": {
        "returns": {
          "absorbData_": "An array of AbsorbStruct containing the absorb data for all vaults."
        }
      },
      "getVaultsAbsorb(address[])": {
        "params": {
          "vaults_": "The array of vault addresses."
        },
        "returns": {
          "absorbData_": "An array of AbsorbStruct containing the absorb data for each vault."
        }
      },
      "getVaultsEntireData()": {
        "returns": {
          "vaultsData_": "An array of VaultEntireData structures containing the data for each vault."
        }
      },
      "getVaultsEntireData(address[])": {
        "params": {
          "vaults_": "The list of vault addresses."
        },
        "returns": {
          "vaultsData_": "An array of VaultEntireData structures containing the data for each vault."
        }
      },
      "positionByNftId(uint256)": {
        "params": {
          "nftId_": "The NFT ID for which to retrieve the position data."
        },
        "returns": {
          "userPosition_": "The UserPosition structure containing the position data.",
          "vaultData_": "The VaultEntireData structure containing the vault data."
        }
      },
      "positionsByUser(address)": {
        "params": {
          "user_": "The address of the user for whom to fetch positions and vault data."
        },
        "returns": {
          "userPositions_": "An array of UserPosition structs representing the user's positions.",
          "vaultsData_": "An array of VaultEntireData structs representing the vault data for each position."
        }
      },
      "positionsNftIdOfUser(address)": {
        "params": {
          "user_": "The address of the user for whom to fetch positions."
        },
        "returns": {
          "nftIds_": "An array of NFT IDs representing the user's positions."
        }
      },
      "totalPositions()": {
        "returns": {
          "_0": "The total number of positions."
        }
      },
      "vaultByNftId(uint256)": {
        "params": {
          "nftId_": "The NFT ID for which to fetch the vault address."
        },
        "returns": {
          "vault_": "The address of the vault associated with the NFT ID."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "calculateDoubleIntUintMapping(uint256,int256,uint256)": {
        "notice": "Calculating the slot ID for Liquidity contract for double mapping"
      },
      "calculateStorageSlotIntMapping(uint256,int256)": {
        "notice": "Calculating the slot ID for Liquidity contract for single mapping"
      },
      "calculateStorageSlotUintMapping(uint256,uint256)": {
        "notice": "Calculating the slot ID for Liquidity contract for single mapping"
      },
      "getAbsorbedDustDebt(address)": {
        "notice": "Get the absorbed dust debt of a vault."
      },
      "getAbsorbedLiquidityRaw(address)": {
        "notice": "Get the absorbed liquidity of a vault."
      },
      "getAllVaultsAddresses()": {
        "notice": "Get the addresses of all the vaults."
      },
      "getAllVaultsLiquidation()": {
        "notice": "Retrieves liquidation data for all vaults."
      },
      "getBranchDataRaw(address,uint256)": {
        "notice": "Get the raw branch data of a vault."
      },
      "getContractForDeployerIndex(address,uint256)": {
        "notice": "Get the contract for deployer index of a vault."
      },
      "getDexFromAddress(address)": {
        "notice": "Get the DEX from address of a vault."
      },
      "getMultipleVaultsLiquidation(address[],uint256[])": {
        "notice": "Retrieves liquidation data for multiple vaults."
      },
      "getPositionDataRaw(address,uint256)": {
        "notice": "Get the position data of a vault."
      },
      "getRateRaw(address)": {
        "notice": "Get the raw rate of a vault."
      },
      "getRebalancer(address)": {
        "notice": "Get the rebalancer of a vault."
      },
      "getTickDataRaw(address,int256)": {
        "notice": "Get the raw tick data of a vault."
      },
      "getTickHasDebtRaw(address,int256)": {
        "notice": "Get the raw tick data of a vault."
      },
      "getTickIdDataRaw(address,int256,uint256)": {
        "notice": "Get the raw tick data of a vault."
      },
      "getTokenConfig(uint256)": {
        "notice": "Get the token configuration."
      },
      "getTotalVaults()": {
        "notice": "Get the total number of vaults."
      },
      "getVaultAbsorb(address)": {
        "notice": "DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for a single vault."
      },
      "getVaultAddress(uint256)": {
        "notice": "Get the address of a vault."
      },
      "getVaultEntireData(address)": {
        "notice": "Retrieves the entire data for a given vault."
      },
      "getVaultId(address)": {
        "notice": "Get the ID of a vault."
      },
      "getVaultLiquidation(address,uint256)": {
        "notice": "fetches available liquidations"
      },
      "getVaultState(address)": {
        "notice": "Retrieves the state of a given vault."
      },
      "getVaultType(address)": {
        "notice": "Get the type of a vault."
      },
      "getVaultVariables2Raw(address)": {
        "notice": "Get the raw variables of a vault."
      },
      "getVaultVariablesRaw(address)": {
        "notice": "Get the raw variables of a vault."
      },
      "getVaultsAbsorb()": {
        "notice": "DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for all vaults."
      },
      "getVaultsAbsorb(address[])": {
        "notice": "DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for multiple vaults."
      },
      "getVaultsEntireData()": {
        "notice": "Retrieves the entire data for all vaults."
      },
      "getVaultsEntireData(address[])": {
        "notice": "Retrieves the entire data for a list of vaults."
      },
      "positionByNftId(uint256)": {
        "notice": "Retrieves the position data for a given NFT ID and the corresponding vault data."
      },
      "positionsByUser(address)": {
        "notice": "Fetches all positions and their corresponding vault data for a given user."
      },
      "positionsNftIdOfUser(address)": {
        "notice": "Returns an array of NFT IDs for all positions of a given user."
      },
      "totalPositions()": {
        "notice": "Returns the total number of positions across all users."
      },
      "vaultByNftId(uint256)": {
        "notice": "Returns the vault address associated with a given NFT ID."
      }
    },
    "notice": "Fluid Vault protocol resolver Implements various view-only methods to give easy access to Vault protocol data.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}