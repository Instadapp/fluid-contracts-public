{
  "address": "0x1FAf33c33ce81DC86fe50ba5b6F3417aBEC01d6E",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "minFee_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxFee_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minDeviation_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxDeviation_",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "dex_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "deployerContract_",
          "type": "address"
        },
        {
          "internalType": "contract IFluidReserveContract",
          "name": "reserveContract_",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "centerPriceActive_",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "errorId_",
          "type": "uint256"
        }
      ],
      "name": "FluidConfigError",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "dex",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fee",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "revenueCut",
          "type": "uint256"
        }
      ],
      "name": "LogRebalanceFeeAndRevenueCut",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CENTER_PRICE_ACTIVE",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DEX",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_DEVIATION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_FEE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MIN_DEVIATION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MIN_FEE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "RESERVE_CONTRACT",
      "outputs": [
        {
          "internalType": "contract IFluidReserveContract",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "UPDATE_FEE_TRIGGER_BUFFER",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "absoluteConfigDiff",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "currentConfig",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "deviation",
          "type": "uint256"
        }
      ],
      "name": "dynamicFeeFromDeviation",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "name": "dynamicFeeFromPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "price_",
          "type": "uint256"
        }
      ],
      "name": "getDeviationFromPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDexCenterPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDexDynamicFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDexFeeAndRevenueCut",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "fee_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "revenueCut_",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDexRevenueCut",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "revenueCut_",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDexVariables",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "lastToLastStoredPrice_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lastStoredPriceOfPool_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lastInteractionTimeStamp_",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "newConfig",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rebalance",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "relativeConfigPercentDiff",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x953d0e1332942f734fc920c2c9893fbbbe92e75337677d13c5f285b6f68ed57e",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x0Ed35B1609Ec45c7079E80d11149a52717e4859A",
    "contractAddress": null,
    "transactionIndex": 133,
    "gasUsed": "1202347",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xb9503d45b4357c45f61a1e426329f1b14fd0bb15830d32677a39d088d7e46c0a",
    "transactionHash": "0x953d0e1332942f734fc920c2c9893fbbbe92e75337677d13c5f285b6f68ed57e",
    "logs": [],
    "blockNumber": 22146682,
    "cumulativeGasUsed": "11183861",
    "status": 1,
    "byzantium": true
  },
  "args": [
    20,
    150,
    "200000000000000000000000",
    "750000000000000000000000",
    "0x0B1a513ee24972DAEf112bC777a5610d4325C9e7",
    "0x4EC7b668BAF70d4A4b0FC7941a7708A07b6d45Be",
    "0x264786EF916af64a1DB19F513F24a3681734ce92",
    true
  ],
  "numDeployments": 1,
  "solcInputHash": "700085a38554f5c9d5d49a91df2d82c5",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDeviation_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeviation_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dex_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deployerContract_\",\"type\":\"address\"},{\"internalType\":\"contract IFluidReserveContract\",\"name\":\"reserveContract_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"centerPriceActive_\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorId_\",\"type\":\"uint256\"}],\"name\":\"FluidConfigError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dex\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"revenueCut\",\"type\":\"uint256\"}],\"name\":\"LogRebalanceFeeAndRevenueCut\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CENTER_PRICE_ACTIVE\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DEVIATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_DEVIATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESERVE_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IFluidReserveContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UPDATE_FEE_TRIGGER_BUFFER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"absoluteConfigDiff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deviation\",\"type\":\"uint256\"}],\"name\":\"dynamicFeeFromDeviation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"dynamicFeeFromPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"}],\"name\":\"getDeviationFromPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDexCenterPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDexDynamicFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDexFeeAndRevenueCut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revenueCut_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDexRevenueCut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"revenueCut_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDexVariables\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastToLastStoredPrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStoredPriceOfPool_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastInteractionTimeStamp_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relativeConfigPercentDiff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"events\":{\"LogRebalanceFeeAndRevenueCut(address,uint256,uint256)\":{\"notice\":\"emitted when rebalancer successfully changes the fee and revenue cut\"}},\"kind\":\"user\",\"methods\":{\"CENTER_PRICE_ACTIVE()\":{\"notice\":\"Whether the center price is active\"},\"absoluteConfigDiff()\":{\"notice\":\"returns how much new config would be different from current config.\"},\"currentConfig()\":{\"notice\":\"returns the currently configured fee\"},\"dynamicFeeFromDeviation(uint256)\":{\"notice\":\"Calculates the dynamic fee based on the given deviation.\"},\"dynamicFeeFromPrice(uint256)\":{\"notice\":\"Calculates the dynamic fee based on the given price.\"},\"getDeviationFromPrice(uint256)\":{\"notice\":\"Calculates the deviation from the given price.\"},\"getDexDynamicFee()\":{\"notice\":\"returns the dynamic fee for the dex based on the last stored price of the pool\"},\"getDexFeeAndRevenueCut()\":{\"notice\":\"returns the fee and revenue cut for the dex\"},\"getDexRevenueCut()\":{\"notice\":\"returns the revenue cut for the dex\"},\"getDexVariables()\":{\"notice\":\"returns the last stored prices of the pool and the last interaction time stamp\"},\"newConfig()\":{\"notice\":\"returns the new calculated fee\"},\"rebalance()\":{\"notice\":\"rebalances the fee\"},\"relativeConfigPercentDiff()\":{\"notice\":\"returns how much new config would be different from current config in percent (100 = 1%, 1 = 0.01%).\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/config/dexFeeHandler/main.sol\":\"FluidDexFeeHandler\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[]},\"sources\":{\"contracts/config/dexFeeHandler/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Error } from \\\"../error.sol\\\";\\nimport { ErrorTypes } from \\\"../errorTypes.sol\\\";\\nimport { AddressCalcs } from \\\"../../libraries/addressCalcs.sol\\\";\\nimport { DexSlotsLink } from \\\"../../libraries/dexSlotsLink.sol\\\";\\nimport { IFluidDexT1 } from \\\"../../protocols/dex/interfaces/iDexT1.sol\\\";\\nimport { IFluidReserveContract } from \\\"../../reserve/interfaces/iReserveContract.sol\\\";\\n\\ninterface IFluidDexT1Admin {\\n    /// @notice sets a new fee and revenue cut for a certain dex\\n    /// @param fee_ new fee (scaled so that 1% = 10000)\\n    /// @param revenueCut_ new revenue cut\\n    function updateFeeAndRevenueCut(uint fee_, uint revenueCut_) external;\\n}\\n\\ninterface ICenterPrice {\\n    /// @notice Retrieves the center price for the pool\\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\\n    /// @return price The current price ratio of token1 to token0, expressed with 27 decimal places\\n    function centerPrice() external returns (uint price);\\n}\\n\\nabstract contract Events is Error {\\n    /// @notice emitted when rebalancer successfully changes the fee and revenue cut\\n    event LogRebalanceFeeAndRevenueCut(address dex, uint fee, uint revenueCut);\\n}\\n\\nabstract contract Constants is Events {\\n    uint256 internal constant FOUR_DECIMALS = 1e4;\\n    uint256 internal constant SIX_DECIMALS = 1e6;\\n\\n    uint256 internal constant SCALE = 1e27;\\n\\n    /// @notice Whether the center price is active\\n    bool public immutable CENTER_PRICE_ACTIVE;\\n\\n    uint256 internal constant X7 = 0x7f;\\n    uint256 internal constant X17 = 0x1ffff;\\n    uint256 internal constant X20 = 0xfffff;\\n    uint256 internal constant X28 = 0xfffffff;\\n    uint256 internal constant X30 = 0x3fffffff;\\n    uint256 internal constant X33 = 0x1ffffffff;\\n    uint256 internal constant X40 = 0xffffffffff;\\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\\n\\n    /// @dev Address of contract used for deploying center price & hook related contract\\n    address internal immutable DEPLOYER_CONTRACT;\\n\\n    uint256 public immutable MIN_FEE; // e.g. 10 -> 0.001%\\n    uint256 public immutable MAX_FEE; // e.g. 100 -> 0.01%\\n    uint256 public immutable MIN_DEVIATION; // in 1e27 scale, e.g. 3e23 -> 0.003\\n    uint256 public immutable MAX_DEVIATION; // in 1e27 scale, e.g. 1e24 -> 0.01\\n\\n    uint256 public immutable UPDATE_FEE_TRIGGER_BUFFER = 10; // e.g. 1e4 -> 1%\\n\\n    address public immutable DEX;\\n\\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\\n}\\n\\nabstract contract DexHelpers is Constants {\\n    modifier validAddress(address value_) {\\n        if (value_ == address(0)) {\\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        address dex_,\\n        address deployerContract_,\\n        bool isCenterPriceActive_\\n    ) validAddress(dex_) validAddress(deployerContract_) {\\n        DEX = dex_;\\n        DEPLOYER_CONTRACT = deployerContract_;\\n        CENTER_PRICE_ACTIVE = isCenterPriceActive_;\\n    }\\n\\n    function _getCenterPriceShift() internal view returns (uint256) {\\n        return IFluidDexT1(DEX).readFromStorage(bytes32(DexSlotsLink.DEX_CENTER_PRICE_SHIFT_SLOT));\\n    }\\n\\n    function _getDexVariables() internal view returns (uint256) {\\n        return IFluidDexT1(DEX).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES_SLOT));\\n    }\\n\\n    function _getDexVariables2() internal view returns (uint256) {\\n        return IFluidDexT1(DEX).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\\n    }\\n\\n    function _getCenterPriceFromCenterPriceAddress(uint256 centerPriceNonce_) internal returns (uint256) {\\n        return ICenterPrice(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, centerPriceNonce_)).centerPrice();\\n    }\\n\\n    function _calcCenterPrice(uint dexVariables_, uint centerPriceNonce_) internal returns (uint newCenterPrice_) {\\n        uint oldCenterPrice_ = (dexVariables_ >> 81) & X40;\\n        oldCenterPrice_ = (oldCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (oldCenterPrice_ & DEFAULT_EXPONENT_MASK);\\n\\n        uint centerPriceShift_ = _getCenterPriceShift();\\n\\n        uint startTimeStamp_ = centerPriceShift_ & X33;\\n        uint percent_ = (centerPriceShift_ >> 33) & X20;\\n        uint time_ = (centerPriceShift_ >> 53) & X20;\\n\\n        uint fromTimeStamp_ = (dexVariables_ >> 121) & X33;\\n        fromTimeStamp_ = fromTimeStamp_ > startTimeStamp_ ? fromTimeStamp_ : startTimeStamp_;\\n\\n        newCenterPrice_ = _getCenterPriceFromCenterPriceAddress(centerPriceNonce_);\\n        uint priceShift_ = (oldCenterPrice_ * percent_ * (block.timestamp - fromTimeStamp_)) / (time_ * SIX_DECIMALS);\\n\\n        if (newCenterPrice_ > oldCenterPrice_) {\\n            // shift on positive side\\n            oldCenterPrice_ += priceShift_;\\n            if (newCenterPrice_ > oldCenterPrice_) {\\n                newCenterPrice_ = oldCenterPrice_;\\n            }\\n        } else {\\n            unchecked {\\n                oldCenterPrice_ = oldCenterPrice_ > priceShift_ ? oldCenterPrice_ - priceShift_ : 0;\\n                // In case of oldCenterPrice_ ending up 0, which could happen when a lot of time has passed (pool has no swaps for many days or weeks)\\n                // then below we get into the else logic which will fully conclude shifting and return newCenterPrice_\\n                // as it was fetched from the external center price source.\\n                // not ideal that this would ever happen unless the pool is not in use and all/most users have left leaving not enough liquidity to trade on\\n            }\\n            if (newCenterPrice_ < oldCenterPrice_) {\\n                newCenterPrice_ = oldCenterPrice_;\\n            }\\n        }\\n    }\\n\\n    function _fetchCenterPrice() internal returns (uint256 centerPrice_) {\\n        (uint256 dexVariables_, uint256 dexVariables2_) = (_getDexVariables(), _getDexVariables2());\\n\\n        // centerPrice_ => center price hook\\n        centerPrice_ = (dexVariables2_ >> 112) & X30;\\n\\n        // whether centerPrice shift is active or not\\n        if (((dexVariables2_ >> 248) & 1) == 0) {\\n            if (centerPrice_ == 0) {\\n                centerPrice_ = (dexVariables_ >> 81) & X40;\\n                centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\\n            } else {\\n                // center price should be fetched from external source. For exmaple, in case of wstETH <> ETH pool,\\n                // we would want the center price to be pegged to wstETH exchange rate into ETH\\n                centerPrice_ = _getCenterPriceFromCenterPriceAddress(centerPrice_);\\n            }\\n        } else {\\n            // an active centerPrice_ shift is going on\\n            centerPrice_ = _calcCenterPrice(dexVariables_, centerPrice_);\\n        }\\n\\n        {\\n            uint maxCenterPrice_ = (dexVariables2_ >> 172) & X28;\\n            maxCenterPrice_ = (maxCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (maxCenterPrice_ & DEFAULT_EXPONENT_MASK);\\n\\n            if (centerPrice_ > maxCenterPrice_) {\\n                // if center price is greater than max center price\\n                centerPrice_ = maxCenterPrice_;\\n            } else {\\n                // check if center price is less than min center price\\n                uint minCenterPrice_ = (dexVariables2_ >> 200) & X28;\\n                minCenterPrice_ =\\n                    (minCenterPrice_ >> DEFAULT_EXPONENT_SIZE) <<\\n                    (minCenterPrice_ & DEFAULT_EXPONENT_MASK);\\n                if (centerPrice_ < minCenterPrice_) {\\n                    centerPrice_ = minCenterPrice_;\\n                }\\n            }\\n        }\\n    }\\n\\n    function _getDexFee() internal view returns (uint256 fee_) {\\n        return (_getDexVariables2() >> 2) & X17;\\n    }\\n\\n    function getDexCenterPrice() public returns (uint256) {\\n        return _fetchCenterPrice();\\n    }\\n\\n    /// @notice returns the revenue cut for the dex\\n    function getDexRevenueCut() public view returns (uint256 revenueCut_) {\\n        return (_getDexVariables2() >> 19) & X7;\\n    }\\n\\n    /// @notice returns the fee and revenue cut for the dex\\n    function getDexFeeAndRevenueCut() public view returns (uint256 fee_, uint256 revenueCut_) {\\n        uint256 dexVariables2_ = _getDexVariables2();\\n\\n        fee_ = (dexVariables2_ >> 2) & X17;\\n        revenueCut_ = (dexVariables2_ >> 19) & X7;\\n    }\\n\\n    /// @notice returns the last stored prices of the pool and the last interaction time stamp\\n    function getDexVariables()\\n        public\\n        view\\n        returns (uint256 lastToLastStoredPrice_, uint256 lastStoredPriceOfPool_, uint256 lastInteractionTimeStamp_)\\n    {\\n        uint256 dexVariables_ = _getDexVariables();\\n\\n        lastToLastStoredPrice_ = (dexVariables_ >> 1) & X40;\\n        lastToLastStoredPrice_ =\\n            (lastToLastStoredPrice_ >> DEFAULT_EXPONENT_SIZE) <<\\n            (lastToLastStoredPrice_ & DEFAULT_EXPONENT_MASK);\\n\\n        lastStoredPriceOfPool_ = (dexVariables_ >> 41) & X40;\\n        lastStoredPriceOfPool_ =\\n            (lastStoredPriceOfPool_ >> DEFAULT_EXPONENT_SIZE) <<\\n            (lastStoredPriceOfPool_ & DEFAULT_EXPONENT_MASK);\\n\\n        lastInteractionTimeStamp_ = (dexVariables_ >> 121) & X33;\\n    }\\n}\\n\\nabstract contract DynamicFee is DexHelpers {\\n    constructor(uint256 _minFee, uint256 _maxFee, uint256 _minDeviation, uint256 _maxDeviation) {\\n        // check for zero values\\n        if (_minFee == 0 || _maxFee == 0 || _minDeviation == 0 || _maxDeviation == 0)\\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\\n\\n        // check that max fee is not greater or equal to 1%\\n        if (_maxFee >= 1e4) revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\\n\\n        // check that min deviation is not greater than max deviation\\n        if (_minDeviation > _maxDeviation) revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\\n\\n        // check that min fee is not greater than max fee\\n        if (_minFee > _maxFee) revert FluidConfigError(ErrorTypes.DexFeeHandler__InvalidParams);\\n\\n        MIN_FEE = _minFee;\\n        MAX_FEE = _maxFee;\\n        MIN_DEVIATION = _minDeviation;\\n        MAX_DEVIATION = _maxDeviation;\\n    }\\n\\n    /// @notice Calculates the deviation from the given price.\\n    function getDeviationFromPrice(uint256 price_) public returns (uint256) {\\n        if (CENTER_PRICE_ACTIVE) {\\n            uint256 centerPrice_ = _fetchCenterPrice();\\n            uint256 deviation_ = price_ > centerPrice_ ? price_ - centerPrice_ : centerPrice_ - price_;\\n            return (deviation_ * SCALE) / centerPrice_;\\n        } else {\\n            return price_ > SCALE ? price_ - SCALE : SCALE - price_;\\n        }\\n    }\\n\\n    /// @notice Calculates the dynamic fee based on the given price.\\n    function dynamicFeeFromPrice(uint256 price) external returns (uint256) {\\n        return _computeDynamicFee(getDeviationFromPrice(price));\\n    }\\n\\n    /// @notice Calculates the dynamic fee based on the given deviation.\\n    function dynamicFeeFromDeviation(uint256 deviation) external view returns (uint256) {\\n        return _computeDynamicFee(deviation);\\n    }\\n\\n    /**\\n     * @dev Internal helper that implements a smooth-step curve for fee calculation\\n     * @param deviation Deviation from the target price in SCALE (1e27)\\n     * @return Fee in basis points (1e4 = 1%)\\n     */\\n    function _computeDynamicFee(uint256 deviation) internal view returns (uint256) {\\n        if (deviation <= MIN_DEVIATION) {\\n            return MIN_FEE;\\n        } else if (deviation >= MAX_DEVIATION) {\\n            return MAX_FEE;\\n        } else {\\n            // Calculate normalized position between min and max deviation (0 to 1 in SCALE)\\n            uint256 alpha = ((deviation - MIN_DEVIATION) * SCALE) / (MAX_DEVIATION - MIN_DEVIATION);\\n\\n            // Smooth step formula: 3x\\u00b2 - 2x\\u00b3\\n            // https://en.wikipedia.org/wiki/Smoothstep\\n            uint256 alpha2 = _scaleMul(alpha, alpha);\\n            uint256 alpha3 = _scaleMul(alpha2, alpha);\\n\\n            uint256 smooth = _scaleMul(3 * SCALE, alpha2) - _scaleMul(2 * SCALE, alpha3);\\n\\n            uint256 feeDelta = MAX_FEE - MIN_FEE;\\n            uint256 interpolatedFee = MIN_FEE + (_scaleMul(smooth, feeDelta));\\n\\n            return interpolatedFee;\\n        }\\n    }\\n\\n    function _scaleMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return (a * b) / SCALE;\\n    }\\n}\\n\\nabstract contract FluidDexFeeHandlerHelpers is DynamicFee {\\n    modifier onlyRebalancer() {\\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__Unauthorized);\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        uint256 minFee_,\\n        uint256 maxFee_,\\n        uint256 minDeviation_,\\n        uint256 maxDeviation_,\\n        address dex_,\\n        address deployerContract_,\\n        IFluidReserveContract reserveContract_,\\n        bool centerPriceActive_\\n    )\\n        validAddress(address(reserveContract_))\\n        DexHelpers(dex_, deployerContract_, centerPriceActive_)\\n        DynamicFee(minFee_, maxFee_, minDeviation_, maxDeviation_)\\n    {\\n        RESERVE_CONTRACT = reserveContract_;\\n    }\\n\\n    /// @notice returns the dynamic fee for the dex based on the last stored price of the pool\\n    function getDexDynamicFee() public returns (uint256) {\\n        (\\n            uint256 lastToLastStoredPrice_,\\n            uint256 lastStoredPriceOfPool_,\\n            uint256 lastInteractionTimeStamp_\\n        ) = getDexVariables();\\n\\n        if (lastInteractionTimeStamp_ == block.timestamp) lastStoredPriceOfPool_ = lastToLastStoredPrice_;\\n\\n        return _computeDynamicFee(getDeviationFromPrice(lastStoredPriceOfPool_));\\n    }\\n\\n    function _configPercentDiff(\\n        uint256 currentFee_,\\n        uint256 newFee_\\n    ) internal pure returns (uint256 configPercentDiff_) {\\n        if (currentFee_ == newFee_) {\\n            return 0;\\n        }\\n\\n        if (currentFee_ > newFee_) configPercentDiff_ = currentFee_ - newFee_;\\n        else configPercentDiff_ = newFee_ - currentFee_;\\n\\n        return (configPercentDiff_ * FOUR_DECIMALS) / currentFee_;\\n    }\\n}\\n\\ncontract FluidDexFeeHandler is FluidDexFeeHandlerHelpers {\\n    constructor(\\n        uint256 minFee_,\\n        uint256 maxFee_,\\n        uint256 minDeviation_,\\n        uint256 maxDeviation_,\\n        address dex_,\\n        address deployerContract_,\\n        IFluidReserveContract reserveContract_,\\n        bool centerPriceActive_\\n    )\\n        FluidDexFeeHandlerHelpers(\\n            minFee_,\\n            maxFee_,\\n            minDeviation_,\\n            maxDeviation_,\\n            dex_,\\n            deployerContract_,\\n            reserveContract_,\\n            centerPriceActive_\\n        )\\n    {}\\n\\n    /// @notice rebalances the fee\\n    function rebalance() external onlyRebalancer {\\n        uint256 newFee_ = getDexDynamicFee();\\n\\n        (uint256 currentFee_, uint256 currentRevenueCut_) = getDexFeeAndRevenueCut();\\n\\n        uint256 feePercentageChange_ = _configPercentDiff(currentFee_, newFee_);\\n\\n        // should be more than 0.001% to update\\n        if (feePercentageChange_ > UPDATE_FEE_TRIGGER_BUFFER) {\\n            IFluidDexT1Admin(DEX).updateFeeAndRevenueCut(newFee_, currentRevenueCut_ * FOUR_DECIMALS);\\n            emit LogRebalanceFeeAndRevenueCut(DEX, newFee_, currentRevenueCut_ * FOUR_DECIMALS);\\n        } else {\\n            revert FluidConfigError(ErrorTypes.DexFeeHandler__FeeUpdateNotRequired);\\n        }\\n    }\\n\\n    /// @notice returns how much new config would be different from current config in percent (100 = 1%, 1 = 0.01%).\\n    function relativeConfigPercentDiff() public returns (uint256) {\\n        return _configPercentDiff(_getDexFee(), getDexDynamicFee());\\n    }\\n\\n    /// @notice returns how much new config would be different from current config.\\n    function absoluteConfigDiff() public returns (uint256) {\\n        uint256 newFee_ = getDexDynamicFee();\\n        uint256 oldFee_ = _getDexFee();\\n\\n        return newFee_ > oldFee_ ? newFee_ - oldFee_ : oldFee_ - newFee_;\\n    }\\n\\n    /// @notice returns the new calculated fee\\n    function newConfig() public returns (uint256) {\\n        return getDexDynamicFee();\\n    }\\n\\n    /// @notice returns the currently configured fee\\n    function currentConfig() public view returns (uint256) {\\n        return _getDexFee();\\n    }\\n}\\n\",\"keccak256\":\"0x6bb52125f4d1d49437cda7d4a228a175139272d2071e39b0bc14ff3c125f3331\",\"license\":\"BUSL-1.1\"},\"contracts/config/error.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ncontract Error {\\n    error FluidConfigError(uint256 errorId_);\\n}\\n\",\"keccak256\":\"0x7fac063d4cfeb626e3a2720595a2db1d7352353ed6c7df61e95a6c164450c9e6\",\"license\":\"BUSL-1.1\"},\"contracts/config/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary ErrorTypes {\\n    /***********************************|\\n    |    ExpandPercentConfigHandler     | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an input address is zero\\n    uint256 internal constant ExpandPercentConfigHandler__AddressZero = 100001;\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant ExpandPercentConfigHandler__Unauthorized = 100002;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant ExpandPercentConfigHandler__InvalidParams = 100003;\\n\\n    /// @notice thrown when no update is currently needed\\n    uint256 internal constant ExpandPercentConfigHandler__NoUpdate = 100004;\\n\\n    /// @notice thrown when slot is not used, e.g. when borrow token is 0 there is no borrow data\\n    uint256 internal constant ExpandPercentConfigHandler__SlotDoesNotExist = 100005;\\n\\n    /***********************************|\\n    |      EthenaRateConfigHandler      | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an input address is zero\\n    uint256 internal constant EthenaRateConfigHandler__AddressZero = 100011;\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant EthenaRateConfigHandler__Unauthorized = 100012;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant EthenaRateConfigHandler__InvalidParams = 100013;\\n\\n    /// @notice thrown when no update is currently needed\\n    uint256 internal constant EthenaRateConfigHandler__NoUpdate = 100014;\\n\\n    /***********************************|\\n    |       MaxBorrowConfigHandler      | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an input address is zero\\n    uint256 internal constant MaxBorrowConfigHandler__AddressZero = 100021;\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant MaxBorrowConfigHandler__Unauthorized = 100022;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant MaxBorrowConfigHandler__InvalidParams = 100023;\\n\\n    /// @notice thrown when no update is currently needed\\n    uint256 internal constant MaxBorrowConfigHandler__NoUpdate = 100024;\\n\\n    /***********************************|\\n    |       BufferRateConfigHandler     | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an input address is zero\\n    uint256 internal constant BufferRateConfigHandler__AddressZero = 100031;\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant BufferRateConfigHandler__Unauthorized = 100032;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant BufferRateConfigHandler__InvalidParams = 100033;\\n\\n    /// @notice thrown when no update is currently needed\\n    uint256 internal constant BufferRateConfigHandler__NoUpdate = 100034;\\n\\n    /// @notice thrown when rate data version is not supported\\n    uint256 internal constant BufferRateConfigHandler__RateVersionUnsupported = 100035;\\n\\n    /***********************************|\\n    |          FluidRatesAuth           | \\n    |__________________________________*/\\n\\n    /// @notice thrown when no update is currently needed\\n    uint256 internal constant RatesAuth__NoUpdate = 100041;\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant RatesAuth__Unauthorized = 100042;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant RatesAuth__InvalidParams = 100043;\\n\\n    /// @notice thrown when cooldown is not yet expired\\n    uint256 internal constant RatesAuth__CooldownLeft = 100044;\\n\\n    /// @notice thrown when version is invalid\\n    uint256 internal constant RatesAuth__InvalidVersion = 100045;\\n\\n    /***********************************|\\n    |          ListTokenAuth            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant ListTokenAuth__Unauthorized = 100051;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant ListTokenAuth_AlreadyInitialized = 100052;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant ListTokenAuth__InvalidParams = 100053;\\n\\n    /***********************************|\\n    |       CollectRevenueAuth          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant CollectRevenueAuth__Unauthorized = 100061;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant CollectRevenueAuth__InvalidParams = 100062;\\n\\n    /***********************************|\\n    |       FluidWithdrawLimitAuth      | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant WithdrawLimitAuth__NoUserSupply = 100071;\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant WithdrawLimitAuth__Unauthorized = 100072;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant WithdrawLimitAuth__InvalidParams = 100073;\\n\\n    /// @notice thrown when no more withdrawal limit can be set for the day\\n    uint256 internal constant WithdrawLimitAuth__DailyLimitReached = 100074;\\n\\n    /// @notice thrown when no more withdrawal limit can be set for the hour\\n    uint256 internal constant WithdrawLimitAuth__HourlyLimitReached = 100075;\\n\\n    /// @notice thrown when the withdrawal limit and userSupply difference exceeds 5%\\n    uint256 internal constant WithdrawLimitAuth__ExcessPercentageDifference = 100076;\\n\\n    /***********************************|\\n    |       DexFeeHandler               | \\n    |__________________________________*/\\n\\n    /// @notice thrown when fee update is not required\\n    uint256 internal constant DexFeeHandler__FeeUpdateNotRequired = 100081;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant DexFeeHandler__InvalidParams = 100082;\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls\\n    uint256 internal constant DexFeeHandler__Unauthorized = 100083;\\n}\\n\",\"keccak256\":\"0x2fa4ec7f57800923dd2ff158c1030c588d4fd7b99fcda07108420e2ca47bad27\",\"license\":\"BUSL-1.1\"},\"contracts/infiniteProxy/interfaces/iProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IProxy {\\n    function setAdmin(address newAdmin_) external;\\n\\n    function setDummyImplementation(address newDummyImplementation_) external;\\n\\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\\n\\n    function removeImplementation(address implementation_) external;\\n\\n    function getAdmin() external view returns (address);\\n\\n    function getDummyImplementation() external view returns (address);\\n\\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\\n\\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\\n\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n}\\n\",\"keccak256\":\"0xbb605491d4bac08e816248feecae7dd17cfc1877c88b2e555abece2970f5ea00\",\"license\":\"MIT\"},\"contracts/libraries/addressCalcs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice implements calculation of address for contracts deployed through CREATE.\\n/// Accepts contract deployed from which address & nonce\\nlibrary AddressCalcs {\\n\\n    /// @notice                         Computes the address of a contract based\\n    /// @param deployedFrom_            Address from which the contract was deployed\\n    /// @param nonce_                   Nonce at which the contract was deployed\\n    /// @return contract_               Address of deployed contract\\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\\n        // @dev based on https://ethereum.stackexchange.com/a/61413\\n\\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\\n        // hence, nonce of vault deployment starts with 1.\\n        bytes memory data;\\n        if (nonce_ == 0x00) {\\n            return address(0);\\n        } else if (nonce_ <= 0x7f) {\\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\\n        } else if (nonce_ <= 0xff) {\\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\\n        } else if (nonce_ <= 0xffff) {\\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\\n        } else if (nonce_ <= 0xffffff) {\\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\\n        } else {\\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\\n        }\\n\\n        return address(uint160(uint256(keccak256(data))));\\n    }\\n\\n}\",\"keccak256\":\"0xca389bcfef035463ff43939ac5eccab07ab74cbb053e201541f9bcd846b3105a\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/dexSlotsLink.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\\nlibrary DexSlotsLink {\\n    /// @dev storage slot for variables at Dex\\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\\n    /// @dev storage slot for variables2 at Dex\\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\\n    /// @dev storage slot for total supply shares at Dex\\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\\n    /// @dev storage slot for user supply mapping at Dex\\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\\n    /// @dev storage slot for total borrow shares at Dex\\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\\n    /// @dev storage slot for user borrow mapping at Dex\\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\\n    /// @dev storage slot for oracle mapping at Dex\\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\\n    /// @dev storage slot for range and threshold shifts at Dex\\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\\n    /// @dev storage slot for center price shift at Dex\\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\\n\\n    // --------------------------------\\n    // @dev stacked uint256 storage slots bits position data for each:\\n\\n    // UserSupplyData\\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\\n\\n    // UserBorrowData\\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\\n\\n    // --------------------------------\\n\\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\\n    function calculateDoubleMappingStorageSlot(\\n        uint256 slot_,\\n        address key1_,\\n        address key2_\\n    ) internal pure returns (bytes32) {\\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\\n        return keccak256(abi.encode(key2_, intermediateSlot_));\\n    }\\n}\\n\",\"keccak256\":\"0xf1d6550d83fb0155a26655234922c9bdf4a1bbcf7a3ca767e9123d367a795307\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/adminModule/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Structs {\\n    struct AddressBool {\\n        address addr;\\n        bool value;\\n    }\\n\\n    struct AddressUint256 {\\n        address addr;\\n        uint256 value;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 1\\n    struct RateDataV1Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\\n        uint256 kink;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink;\\n        ///\\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 2\\n    struct RateDataV2Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\\n        uint256 kink1;\\n        ///\\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\\n        uint256 kink2;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink1;\\n        ///\\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\\n        uint256 rateAtUtilizationKink2;\\n        ///\\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set token config\\n    struct TokenConfig {\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 fee;\\n        ///\\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 threshold;\\n        ///\\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\\n        uint256 maxUtilization;\\n    }\\n\\n    /// @notice struct to set user supply & withdrawal config\\n    struct UserSupplyConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration withdrawal limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseWithdrawalLimit;\\n    }\\n\\n    /// @notice struct to set user borrow & payback config\\n    struct UserBorrowConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which debt limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration debt limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseDebtCeiling;\\n        ///\\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 maxDebtCeiling;\\n    }\\n}\\n\",\"keccak256\":\"0x10353c70015f27b880125cefab806dbed24a4458f187da66964f3ef60488f757\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/interfaces/iLiquidity.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { IProxy } from \\\"../../infiniteProxy/interfaces/iProxy.sol\\\";\\nimport { Structs as AdminModuleStructs } from \\\"../adminModule/structs.sol\\\";\\n\\ninterface IFluidLiquidityAdmin {\\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\\n    /// @param authsStatus_ array of structs setting allowed status for an address.\\n    ///                     status true => add auth, false => remove auth\\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\\n\\n    /// @notice adds/removes guardians. Only callable by Governance.\\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\\n    ///                         status true => add guardian, false => remove guardian\\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\\n\\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\\n    /// @param revenueCollector_  new revenue collector address\\n    function updateRevenueCollector(address revenueCollector_) external;\\n\\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\\n    /// @param newStatus_ new status\\n    ///        status = 2 -> pause, status = 1 -> resume.\\n    function changeStatus(uint256 newStatus_) external;\\n\\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\\n\\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\\n\\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\\n    ///         Only callable by Auths.\\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\\n\\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\\n    ///         Only callable by Auths.\\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\\n\\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\\n    ///         Only callable by Auths.\\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\\n\\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\\n    /// @param user_ user address for which to update the withdrawal limit\\n    /// @param token_ token address for which to update the withdrawal limit\\n    /// @param newLimit_ new limit until which user supply can decrease to.\\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\\n    ///                  current user supply as limit respectively.\\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\\n    ///                  below base limit then fully down to 0.\\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\\n\\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\\n    ///         Only callable by Auths.\\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\\n\\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\\n    /// Only callable by Guardians.\\n    /// @param user_          address of user to pause operations for\\n    /// @param supplyTokens_  token addresses to pause withdrawals for\\n    /// @param borrowTokens_  token addresses to pause borrowings for\\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\\n\\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\\n    /// Only callable by Guardians.\\n    /// @param user_          address of user to unpause operations for\\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\\n    /// @param borrowTokens_  token addresses to unpause borrowings for\\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\\n\\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\\n    /// @param tokens_  array of tokens to collect revenue for\\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\\n    function collectRevenue(address[] calldata tokens_) external;\\n\\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\\n    /// @param tokens_ tokens to update exchange prices for\\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\\n    function updateExchangePrices(\\n        address[] calldata tokens_\\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\\n}\\n\\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\\n    /// @notice Single function which handles supply, withdraw, borrow & payback\\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\\n    /// @param withdrawTo_ if withdrawal then to which address\\n    /// @param borrowTo_ if borrow then to which address\\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\\n    /// @return memVar3_ updated supplyExchangePrice\\n    /// @return memVar4_ updated borrowExchangePrice\\n    /// @dev to trigger skipping in / out transfers (gas optimization):\\n    /// -  ` callbackData_` MUST be encoded so that \\\"from\\\" address is the last 20 bytes in the last 32 bytes slot,\\n    ///     also for native token operations where liquidityCallback is not triggered!\\n    ///     from address must come at last position if there is more data. I.e. encode like:\\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\\n    /// -   this \\\"from\\\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\\n    ///     in the slot before (bytes 32 to 63)\\n    /// -   `msg.value` must be 0.\\n    /// -   Amounts must be either:\\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\\n    function operate(\\n        address token_,\\n        int256 supplyAmount_,\\n        int256 borrowAmount_,\\n        address withdrawTo_,\\n        address borrowTo_,\\n        bytes calldata callbackData_\\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\\n}\\n\\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\\n\",\"keccak256\":\"0x4aa83e84baa7c2f4d58b07a3eca4ab7fe7d6fc660898daaac338dc3f129c4123\",\"license\":\"MIT\"},\"contracts/protocols/dex/interfaces/iDexT1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IFluidDexT1 {\\n    error FluidDexError(uint256 errorId);\\n\\n    /// @notice used to simulate swap to find the output amount\\n    error FluidDexSwapResult(uint256 amountOut);\\n\\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\\n\\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\\n\\n    error FluidDexLiquidityOutput(uint256 shares);\\n\\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\\n\\n    /// @notice returns the dex id\\n    function DEX_ID() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct Implementations {\\n        address shift;\\n        address admin;\\n        address colOperations;\\n        address debtOperations;\\n        address perfectOperationsAndOracle;\\n    }\\n\\n    struct ConstantViews {\\n        uint256 dexId;\\n        address liquidity;\\n        address factory;\\n        Implementations implementations;\\n        address deployerContract;\\n        address token0;\\n        address token1;\\n        bytes32 supplyToken0Slot;\\n        bytes32 borrowToken0Slot;\\n        bytes32 supplyToken1Slot;\\n        bytes32 borrowToken1Slot;\\n        bytes32 exchangePriceToken0Slot;\\n        bytes32 exchangePriceToken1Slot;\\n        uint256 oracleMapping;\\n    }\\n\\n    struct ConstantViews2 {\\n        uint token0NumeratorPrecision;\\n        uint token0DenominatorPrecision;\\n        uint token1NumeratorPrecision;\\n        uint token1DenominatorPrecision;\\n    }\\n\\n    struct PricesAndExchangePrice {\\n        uint lastStoredPrice; // last stored price in 1e27 decimals\\n        uint centerPrice; // last stored price in 1e27 decimals\\n        uint upperRange; // price at upper range in 1e27 decimals\\n        uint lowerRange; // price at lower range in 1e27 decimals\\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\\n        uint supplyToken0ExchangePrice;\\n        uint borrowToken0ExchangePrice;\\n        uint supplyToken1ExchangePrice;\\n        uint borrowToken1ExchangePrice;\\n    }\\n\\n    struct CollateralReserves {\\n        uint token0RealReserves;\\n        uint token1RealReserves;\\n        uint token0ImaginaryReserves;\\n        uint token1ImaginaryReserves;\\n    }\\n\\n    struct DebtReserves {\\n        uint token0Debt;\\n        uint token1Debt;\\n        uint token0RealReserves;\\n        uint token1RealReserves;\\n        uint token0ImaginaryReserves;\\n        uint token1ImaginaryReserves;\\n    }\\n\\n    function getCollateralReserves(\\n        uint geometricMean_,\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint token0SupplyExchangePrice_,\\n        uint token1SupplyExchangePrice_\\n    ) external view returns (CollateralReserves memory c_);\\n\\n    function getDebtReserves(\\n        uint geometricMean_,\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint token0BorrowExchangePrice_,\\n        uint token1BorrowExchangePrice_\\n    ) external view returns (DebtReserves memory d_);\\n\\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\\n    function getPricesAndExchangePrices() external;\\n\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\\n\\n    struct Oracle {\\n        uint twap1by0; // TWAP price\\n        uint lowestPrice1by0; // lowest price point\\n        uint highestPrice1by0; // highest price point\\n        uint twap0by1; // TWAP price\\n        uint lowestPrice0by1; // lowest price point\\n        uint highestPrice0by1; // highest price point\\n    }\\n\\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountIn_ The exact amount of input tokens to swap\\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\\n    /// @return amountOut_ The amount of output tokens received from the swap\\n    function swapIn(\\n        bool swap0to1_,\\n        uint256 amountIn_,\\n        uint256 amountOutMin_,\\n        address to_\\n    ) external payable returns (uint256 amountOut_);\\n\\n    /// @dev Swap tokens with perfect amount out\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountOut_ The exact amount of tokens to receive after swap\\n    /// @param amountInMax_ Maximum amount of tokens to swap in\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\\n    /// @return amountIn_ The amount of input tokens used for the swap\\n    function swapOut(\\n        bool swap0to1_,\\n        uint256 amountOut_,\\n        uint256 amountInMax_,\\n        address to_\\n    ) external payable returns (uint256 amountIn_);\\n\\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\\n    /// @param shares_ The number of shares to mint\\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\\n    /// @return token0Amt_ Amount of token0 deposited\\n    /// @return token1Amt_ Amount of token1 deposited\\n    function depositPerfect(\\n        uint shares_,\\n        uint maxToken0Deposit_,\\n        uint maxToken1Deposit_,\\n        bool estimate_\\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\\n    /// @param shares_ The number of shares to withdraw\\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\\n    /// @return token0Amt_ The amount of token0 withdrawn\\n    /// @return token1Amt_ The amount of token1 withdrawn\\n    function withdrawPerfect(\\n        uint shares_,\\n        uint minToken0Withdraw_,\\n        uint minToken1Withdraw_,\\n        address to_\\n    ) external returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\\n    /// @param shares_ The number of shares to borrow\\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\\n    /// @return token0Amt_ Amount of token0 borrowed\\n    /// @return token1Amt_ Amount of token1 borrowed\\n    function borrowPerfect(\\n        uint shares_,\\n        uint minToken0Borrow_,\\n        uint minToken1Borrow_,\\n        address to_\\n    ) external returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\\n    /// @param shares_ The number of shares to pay back\\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\\n    /// @return token0Amt_ Amount of token0 paid back\\n    /// @return token1Amt_ Amount of token1 paid back\\n    function paybackPerfect(\\n        uint shares_,\\n        uint maxToken0Payback_,\\n        uint maxToken1Payback_,\\n        bool estimate_\\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\\n\\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\\n    /// @param token0Amt_ The amount of token0 to deposit\\n    /// @param token1Amt_ The amount of token1 to deposit\\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\\n    /// @return shares_ The amount of shares minted for the deposit\\n    function deposit(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint minSharesAmt_,\\n        bool estimate_\\n    ) external payable returns (uint shares_);\\n\\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\\n    /// @param token0Amt_ The amount of token0 to withdraw\\n    /// @param token1Amt_ The amount of token1 to withdraw\\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\\n    /// @return shares_ The number of shares burned for the withdrawal\\n    function withdraw(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint maxSharesAmt_,\\n        address to_\\n    ) external returns (uint shares_);\\n\\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\\n    /// @param token0Amt_ The amount of token0 to borrow\\n    /// @param token1Amt_ The amount of token1 to borrow\\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\\n    function borrow(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint maxSharesAmt_,\\n        address to_\\n    ) external returns (uint shares_);\\n\\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\\n    /// @param token0Amt_ The amount of token0 to payback\\n    /// @param token1Amt_ The amount of token1 to payback\\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\\n    /// @return shares_ The amount of borrow shares burned for the payback\\n    function payback(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint minSharesAmt_,\\n        bool estimate_\\n    ) external payable returns (uint shares_);\\n\\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\\n    /// @param shares_ The number of shares to burn for withdrawal\\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\\n    function withdrawPerfectInOneToken(\\n        uint shares_,\\n        uint minToken0_,\\n        uint minToken1_,\\n        address to_\\n    ) external returns (\\n        uint withdrawAmt_\\n    );\\n\\n    /// @dev This function allows users to payback their debt with perfect shares in one token\\n    /// @param shares_ The number of shares to burn for payback\\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\\n    function paybackPerfectInOneToken(\\n        uint shares_,\\n        uint maxToken0_,\\n        uint maxToken1_,\\n        bool estimate_\\n    ) external payable returns (\\n        uint paybackAmt_\\n    );\\n\\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\\n    /// but the difference due to interest will be super low so this difference is ignored\\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\\n    /// @return currentPrice_ price of pool after the most recent swap\\n    function oraclePrice(\\n        uint[] memory secondsAgos_\\n    ) external view returns (\\n        Oracle[] memory twaps_,\\n        uint currentPrice_\\n    );\\n}\\n\",\"keccak256\":\"0xa405007cdd45409412ce0fe02a991cadbae17760bc15402c839375505f69d7b2\",\"license\":\"MIT\"},\"contracts/reserve/interfaces/iReserveContract.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidLiquidity } from \\\"../../liquidity/interfaces/iLiquidity.sol\\\";\\n\\ninterface IFluidReserveContract {\\n    function isRebalancer(address user) external returns (bool);\\n\\n    function initialize(\\n        address[] memory _auths,\\n        address[] memory _rebalancers,\\n        IFluidLiquidity liquidity_,\\n        address owner_\\n    ) external;\\n\\n    function rebalanceFToken(address protocol_) external;\\n\\n    function rebalanceVault(address protocol_) external;\\n\\n    function transferFunds(address token_) external;\\n\\n    function getProtocolTokens(address protocol_) external;\\n\\n    function updateAuth(address auth_, bool isAuth_) external;\\n\\n    function updateRebalancer(address rebalancer_, bool isRebalancer_) external;\\n\\n    function approve(address[] memory protocols_, address[] memory tokens_, uint256[] memory amounts_) external;\\n\\n    function revoke(address[] memory protocols_, address[] memory tokens_) external;\\n}\\n\",\"keccak256\":\"0x36f69b8e3cf8479e5a2ab0390c6ac32e5ea4af5e7ecb91fc954c36503624eec8\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x6101a0604052600a610140523480156200001857600080fd5b5060405162001857380380620018578339810160408190526200003b9162000205565b878787878787878787878787878786826001600160a01b0381166200007d57604051636801712d60e11b8152620186f260048201526024015b60405180910390fd5b826001600160a01b038116620000ac57604051636801712d60e11b8152620186f2600482015260240162000074565b50506001600160a01b0392831661016052911660a0521515608052831580620000d3575082155b80620000dd575081155b80620000e7575080155b156200010c57604051636801712d60e11b8152620186f2600482015260240162000074565b61271083106200013557604051636801712d60e11b8152620186f2600482015260240162000074565b808211156200015d57604051636801712d60e11b8152620186f2600482015260240162000074565b828411156200018557604051636801712d60e11b8152620186f2600482015260240162000074565b60c09390935260e0919091526101005261012052816001600160a01b038116620001c857604051636801712d60e11b8152620186f2600482015260240162000074565b50506001600160a01b031661018052506200029a9c50505050505050505050505050565b6001600160a01b03811681146200020257600080fd5b50565b600080600080600080600080610100898b0312156200022357600080fd5b8851975060208901519650604089015195506060890151945060808901516200024c81620001ec565b60a08a01519094506200025f81620001ec565b60c08a01519093506200027281620001ec565b60e08a015190925080151581146200028957600080fd5b809150509295985092959890939650565b60805160a05160c05160e05161010051610120516101405161016051610180516114ce620003896000396000818161022a01526104900152600081816102c2015281816105ba0152818161067d01528181610b6501528181610cd70152611359015260008181610395015261057d01526000818161030c015281816108ef01526109630152600081816101e6015281816108a1015281816109420152610999015260008181610333015281816109170152610a66015260008181610291015281816108c901528181610a450152610a9e01526000610d3b0152600081816101a7015261073a01526114ce6000f3fe608060405234801561001057600080fd5b50600436106101775760003560e01c806380935aa9116100d8578063bc063e1a1161008c578063cae5880711610066578063cae5880714610365578063d50741f71461036d578063f28a169d1461039057600080fd5b8063bc063e1a1461032e578063bc669afb14610355578063be47bd831461035d57600080fd5b8063941da44e116100bd578063941da44e146102ec5780639b5075a4146102f4578063b05f233a1461030757600080fd5b806380935aa9146102bd578063813e6745146102e457600080fd5b80636449b8d71161012f57806376aaa6ce1161011457806376aaa6ce1461027957806376c7a3c71461028c5780637d7c2a1c146102b357600080fd5b80636449b8d714610225578063724d76251461027157600080fd5b80631d156e8b116101605780631d156e8b146101d9578063274d713c146101e15780632e2e5b471461020857600080fd5b806302918d131461017c5780631c37ae38146101a2575b600080fd5b61018f61018a36600461139d565b6103b7565b6040519081526020015b60405180910390f35b6101c97f000000000000000000000000000000000000000000000000000000000000000081565b6040519015158152602001610199565b61018f6103d0565b61018f7f000000000000000000000000000000000000000000000000000000000000000081565b6102106103ef565b60408051928352602083019190915201610199565b61024c7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610199565b61018f610417565b61018f61028736600461139d565b610457565b61018f7f000000000000000000000000000000000000000000000000000000000000000081565b6102bb610462565b005b61024c7f000000000000000000000000000000000000000000000000000000000000000081565b61018f610722565b61018f61072c565b61018f61030236600461139d565b610736565b61018f7f000000000000000000000000000000000000000000000000000000000000000081565b61018f7f000000000000000000000000000000000000000000000000000000000000000081565b61018f6107fb565b61018f610811565b61018f610844565b61037561084e565b60408051938452602084019290925290820152606001610199565b61018f7f000000000000000000000000000000000000000000000000000000000000000081565b60006103ca6103c583610736565b61089d565b92915050565b60006103ea6103dd610ace565b6103e5610811565b610ade565b905090565b60008060006103fc610b33565b600281901c6201ffff169460139190911c607f169350915050565b600080610422610811565b9050600061042e610ace565b90508082116104465761044182826113e5565b610450565b61045081836113e5565b9250505090565b60006103ca8261089d565b6040517f467c9eff0000000000000000000000000000000000000000000000000000000081523360048201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063467c9eff906024016020604051808303816000875af11580156104ee573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061051291906113f8565b610552576040517fd002e25a000000000000000000000000000000000000000000000000000000008152620186f360048201526024015b60405180910390fd5b600061055c610811565b90506000806105696103ef565b9150915060006105798385610ade565b90507f00000000000000000000000000000000000000000000000000000000000000008111156106e55773ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016632af69377856105ec6127108661141a565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b16815260048101929092526024820152604401600060405180830381600087803b15801561064257600080fd5b505af1158015610656573d6000803e3d6000fd5b505050507f05feefc978308fcb0cc1f214adc60cd97475eaeda69c7898697ea00bd1e11f4f7f000000000000000000000000000000000000000000000000000000000000000085612710856106ab919061141a565b6040805173ffffffffffffffffffffffffffffffffffffffff909416845260208401929092529082015260600160405180910390a161071c565b6040517fd002e25a000000000000000000000000000000000000000000000000000000008152620186f16004820152602401610549565b50505050565b60006103ea610be6565b60006103ea610811565b60007f0000000000000000000000000000000000000000000000000000000000000000156107b7576000610768610be6565b905060008184116107825761077d84836113e5565b61078c565b61078c82856113e5565b9050816107a56b033b2e3c9fd0803ce80000008361141a565b6107af9190611431565b949350505050565b6b033b2e3c9fd0803ce800000082116107e5576107e0826b033b2e3c9fd0803ce80000006113e5565b6103ca565b6103ca6b033b2e3c9fd0803ce8000000836113e5565b6000607f6013610809610b33565b901c16905090565b60008060008061081f61084e565b925092509250428103610830578291505b61083c6103c583610736565b935050505090565b60006103ea610ace565b60008060008061085c610ca5565b63ffffffff600982901c811660ff600184901c81169190911b97603184901c909216602984901c9091161b955060799190911c6401ffffffff169350915050565b60007f000000000000000000000000000000000000000000000000000000000000000082116108ed57507f0000000000000000000000000000000000000000000000000000000000000000919050565b7f0000000000000000000000000000000000000000000000000000000000000000821061093b57507f0000000000000000000000000000000000000000000000000000000000000000919050565b60006109877f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000006113e5565b6b033b2e3c9fd0803ce80000006109be7f0000000000000000000000000000000000000000000000000000000000000000866113e5565b6109c8919061141a565b6109d29190611431565b905060006109e08283610d1b565b905060006109ee8284610d1b565b90506000610a12610a0c6b033b2e3c9fd0803ce8000000600261141a565b83610d1b565b610a32610a2c6b033b2e3c9fd0803ce8000000600361141a565b85610d1b565b610a3c91906113e5565b90506000610a8a7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000006113e5565b90506000610a988383610d1b565b610ac2907f000000000000000000000000000000000000000000000000000000000000000061146c565b98975050505050505050565b60006201ffff6002610809610b33565b6000818303610aef575060006103ca565b81831115610b0857610b0182846113e5565b9050610b15565b610b1283836113e5565b90505b82610b226127108361141a565b610b2c9190611431565b9392505050565b6040517fb5c736e4000000000000000000000000000000000000000000000000000000008152600160048201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063b5c736e4906024015b602060405180830381865afa158015610bc2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ea919061147f565b6000806000610bf3610ca5565b610bfb610b33565b91509150633fffffff607082901c16925060f881901c600116600003610c4e5782600003610c3e5763ffffffff605983901c1660ff605184901c161b9250610c5b565b610c4783610d34565b9250610c5b565b610c588284610dd0565b92505b620fffff60b482901c1660ff60ac83901c161b80841115610c7e57809350610c9f565b620fffff60d083901c1660ff60c884901c161b80851015610c9d578094505b505b50505090565b6040517fb5c736e4000000000000000000000000000000000000000000000000000000008152600060048201819052907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063b5c736e490602401610ba5565b60006b033b2e3c9fd0803ce8000000610b22838561141a565b6000610d607f000000000000000000000000000000000000000000000000000000000000000083610ebd565b73ffffffffffffffffffffffffffffffffffffffff1663f763f7a66040518163ffffffff1660e01b81526004016020604051808303816000875af1158015610dac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ca919061147f565b600063ffffffff605984901c1660ff605185901c161b81610def611327565b90506401ffffffff80821690620fffff602184901c811691603585901c90911690607989901c16838111610e235783610e25565b805b9050610e3088610d34565b96506000610e41620f42408461141a565b610e4b83426113e5565b610e55868a61141a565b610e5f919061141a565b610e699190611431565b905086881115610e9057610e7d818861146c565b965086881115610e8b578697505b610eb0565b808711610e9e576000610ea2565b8087035b965086881015610eb0578697505b5050505050505092915050565b6000606082600003610ed35760009150506103ca565b607f8311610f9c576040517fd60000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b16602282015260f884901b7fff000000000000000000000000000000000000000000000000000000000000001660368201526037015b6040516020818303038152906040529050611318565b60ff8311611079576040517fd70000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f8100000000000000000000000000000000000000000000000000000000000000603682015260f884901b7fff00000000000000000000000000000000000000000000000000000000000000166037820152603801610f86565b61ffff8311611157576040517fd80000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f820000000000000000000000000000000000000000000000000000000000000060368201527fffff00000000000000000000000000000000000000000000000000000000000060f085901b166037820152603901610f86565b62ffffff8311611236576040517fd90000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f830000000000000000000000000000000000000000000000000000000000000060368201527fffffff000000000000000000000000000000000000000000000000000000000060e885901b166037820152603a01610f86565b6040517fda0000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f840000000000000000000000000000000000000000000000000000000000000060368201527fffffffff0000000000000000000000000000000000000000000000000000000060e085901b166037820152603b0160405160208183030381529060405290505b80516020909101209392505050565b6040517fb5c736e4000000000000000000000000000000000000000000000000000000008152600860048201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063b5c736e490602401610ba5565b6000602082840312156113af57600080fd5b5035919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b818103818111156103ca576103ca6113b6565b60006020828403121561140a57600080fd5b81518015158114610b2c57600080fd5b80820281158282048414176103ca576103ca6113b6565b600082611467577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b808201808211156103ca576103ca6113b6565b60006020828403121561149157600080fd5b505191905056fea264697066735822122072062e5c59dd2b93702843bed2b27a1a20ad9de614f62f32b4a09f3dfe416c5264736f6c63430008150033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101775760003560e01c806380935aa9116100d8578063bc063e1a1161008c578063cae5880711610066578063cae5880714610365578063d50741f71461036d578063f28a169d1461039057600080fd5b8063bc063e1a1461032e578063bc669afb14610355578063be47bd831461035d57600080fd5b8063941da44e116100bd578063941da44e146102ec5780639b5075a4146102f4578063b05f233a1461030757600080fd5b806380935aa9146102bd578063813e6745146102e457600080fd5b80636449b8d71161012f57806376aaa6ce1161011457806376aaa6ce1461027957806376c7a3c71461028c5780637d7c2a1c146102b357600080fd5b80636449b8d714610225578063724d76251461027157600080fd5b80631d156e8b116101605780631d156e8b146101d9578063274d713c146101e15780632e2e5b471461020857600080fd5b806302918d131461017c5780631c37ae38146101a2575b600080fd5b61018f61018a36600461139d565b6103b7565b6040519081526020015b60405180910390f35b6101c97f000000000000000000000000000000000000000000000000000000000000000081565b6040519015158152602001610199565b61018f6103d0565b61018f7f000000000000000000000000000000000000000000000000000000000000000081565b6102106103ef565b60408051928352602083019190915201610199565b61024c7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610199565b61018f610417565b61018f61028736600461139d565b610457565b61018f7f000000000000000000000000000000000000000000000000000000000000000081565b6102bb610462565b005b61024c7f000000000000000000000000000000000000000000000000000000000000000081565b61018f610722565b61018f61072c565b61018f61030236600461139d565b610736565b61018f7f000000000000000000000000000000000000000000000000000000000000000081565b61018f7f000000000000000000000000000000000000000000000000000000000000000081565b61018f6107fb565b61018f610811565b61018f610844565b61037561084e565b60408051938452602084019290925290820152606001610199565b61018f7f000000000000000000000000000000000000000000000000000000000000000081565b60006103ca6103c583610736565b61089d565b92915050565b60006103ea6103dd610ace565b6103e5610811565b610ade565b905090565b60008060006103fc610b33565b600281901c6201ffff169460139190911c607f169350915050565b600080610422610811565b9050600061042e610ace565b90508082116104465761044182826113e5565b610450565b61045081836113e5565b9250505090565b60006103ca8261089d565b6040517f467c9eff0000000000000000000000000000000000000000000000000000000081523360048201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063467c9eff906024016020604051808303816000875af11580156104ee573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061051291906113f8565b610552576040517fd002e25a000000000000000000000000000000000000000000000000000000008152620186f360048201526024015b60405180910390fd5b600061055c610811565b90506000806105696103ef565b9150915060006105798385610ade565b90507f00000000000000000000000000000000000000000000000000000000000000008111156106e55773ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016632af69377856105ec6127108661141a565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b16815260048101929092526024820152604401600060405180830381600087803b15801561064257600080fd5b505af1158015610656573d6000803e3d6000fd5b505050507f05feefc978308fcb0cc1f214adc60cd97475eaeda69c7898697ea00bd1e11f4f7f000000000000000000000000000000000000000000000000000000000000000085612710856106ab919061141a565b6040805173ffffffffffffffffffffffffffffffffffffffff909416845260208401929092529082015260600160405180910390a161071c565b6040517fd002e25a000000000000000000000000000000000000000000000000000000008152620186f16004820152602401610549565b50505050565b60006103ea610be6565b60006103ea610811565b60007f0000000000000000000000000000000000000000000000000000000000000000156107b7576000610768610be6565b905060008184116107825761077d84836113e5565b61078c565b61078c82856113e5565b9050816107a56b033b2e3c9fd0803ce80000008361141a565b6107af9190611431565b949350505050565b6b033b2e3c9fd0803ce800000082116107e5576107e0826b033b2e3c9fd0803ce80000006113e5565b6103ca565b6103ca6b033b2e3c9fd0803ce8000000836113e5565b6000607f6013610809610b33565b901c16905090565b60008060008061081f61084e565b925092509250428103610830578291505b61083c6103c583610736565b935050505090565b60006103ea610ace565b60008060008061085c610ca5565b63ffffffff600982901c811660ff600184901c81169190911b97603184901c909216602984901c9091161b955060799190911c6401ffffffff169350915050565b60007f000000000000000000000000000000000000000000000000000000000000000082116108ed57507f0000000000000000000000000000000000000000000000000000000000000000919050565b7f0000000000000000000000000000000000000000000000000000000000000000821061093b57507f0000000000000000000000000000000000000000000000000000000000000000919050565b60006109877f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000006113e5565b6b033b2e3c9fd0803ce80000006109be7f0000000000000000000000000000000000000000000000000000000000000000866113e5565b6109c8919061141a565b6109d29190611431565b905060006109e08283610d1b565b905060006109ee8284610d1b565b90506000610a12610a0c6b033b2e3c9fd0803ce8000000600261141a565b83610d1b565b610a32610a2c6b033b2e3c9fd0803ce8000000600361141a565b85610d1b565b610a3c91906113e5565b90506000610a8a7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000006113e5565b90506000610a988383610d1b565b610ac2907f000000000000000000000000000000000000000000000000000000000000000061146c565b98975050505050505050565b60006201ffff6002610809610b33565b6000818303610aef575060006103ca565b81831115610b0857610b0182846113e5565b9050610b15565b610b1283836113e5565b90505b82610b226127108361141a565b610b2c9190611431565b9392505050565b6040517fb5c736e4000000000000000000000000000000000000000000000000000000008152600160048201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063b5c736e4906024015b602060405180830381865afa158015610bc2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ea919061147f565b6000806000610bf3610ca5565b610bfb610b33565b91509150633fffffff607082901c16925060f881901c600116600003610c4e5782600003610c3e5763ffffffff605983901c1660ff605184901c161b9250610c5b565b610c4783610d34565b9250610c5b565b610c588284610dd0565b92505b620fffff60b482901c1660ff60ac83901c161b80841115610c7e57809350610c9f565b620fffff60d083901c1660ff60c884901c161b80851015610c9d578094505b505b50505090565b6040517fb5c736e4000000000000000000000000000000000000000000000000000000008152600060048201819052907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063b5c736e490602401610ba5565b60006b033b2e3c9fd0803ce8000000610b22838561141a565b6000610d607f000000000000000000000000000000000000000000000000000000000000000083610ebd565b73ffffffffffffffffffffffffffffffffffffffff1663f763f7a66040518163ffffffff1660e01b81526004016020604051808303816000875af1158015610dac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ca919061147f565b600063ffffffff605984901c1660ff605185901c161b81610def611327565b90506401ffffffff80821690620fffff602184901c811691603585901c90911690607989901c16838111610e235783610e25565b805b9050610e3088610d34565b96506000610e41620f42408461141a565b610e4b83426113e5565b610e55868a61141a565b610e5f919061141a565b610e699190611431565b905086881115610e9057610e7d818861146c565b965086881115610e8b578697505b610eb0565b808711610e9e576000610ea2565b8087035b965086881015610eb0578697505b5050505050505092915050565b6000606082600003610ed35760009150506103ca565b607f8311610f9c576040517fd60000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b16602282015260f884901b7fff000000000000000000000000000000000000000000000000000000000000001660368201526037015b6040516020818303038152906040529050611318565b60ff8311611079576040517fd70000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f8100000000000000000000000000000000000000000000000000000000000000603682015260f884901b7fff00000000000000000000000000000000000000000000000000000000000000166037820152603801610f86565b61ffff8311611157576040517fd80000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f820000000000000000000000000000000000000000000000000000000000000060368201527fffff00000000000000000000000000000000000000000000000000000000000060f085901b166037820152603901610f86565b62ffffff8311611236576040517fd90000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f830000000000000000000000000000000000000000000000000000000000000060368201527fffffff000000000000000000000000000000000000000000000000000000000060e885901b166037820152603a01610f86565b6040517fda0000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f840000000000000000000000000000000000000000000000000000000000000060368201527fffffffff0000000000000000000000000000000000000000000000000000000060e085901b166037820152603b0160405160208183030381529060405290505b80516020909101209392505050565b6040517fb5c736e4000000000000000000000000000000000000000000000000000000008152600860048201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063b5c736e490602401610ba5565b6000602082840312156113af57600080fd5b5035919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b818103818111156103ca576103ca6113b6565b60006020828403121561140a57600080fd5b81518015158114610b2c57600080fd5b80820281158282048414176103ca576103ca6113b6565b600082611467577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b808201808211156103ca576103ca6113b6565b60006020828403121561149157600080fd5b505191905056fea264697066735822122072062e5c59dd2b93702843bed2b27a1a20ad9de614f62f32b4a09f3dfe416c5264736f6c63430008150033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "events": {
      "LogRebalanceFeeAndRevenueCut(address,uint256,uint256)": {
        "notice": "emitted when rebalancer successfully changes the fee and revenue cut"
      }
    },
    "kind": "user",
    "methods": {
      "CENTER_PRICE_ACTIVE()": {
        "notice": "Whether the center price is active"
      },
      "absoluteConfigDiff()": {
        "notice": "returns how much new config would be different from current config."
      },
      "currentConfig()": {
        "notice": "returns the currently configured fee"
      },
      "dynamicFeeFromDeviation(uint256)": {
        "notice": "Calculates the dynamic fee based on the given deviation."
      },
      "dynamicFeeFromPrice(uint256)": {
        "notice": "Calculates the dynamic fee based on the given price."
      },
      "getDeviationFromPrice(uint256)": {
        "notice": "Calculates the deviation from the given price."
      },
      "getDexDynamicFee()": {
        "notice": "returns the dynamic fee for the dex based on the last stored price of the pool"
      },
      "getDexFeeAndRevenueCut()": {
        "notice": "returns the fee and revenue cut for the dex"
      },
      "getDexRevenueCut()": {
        "notice": "returns the revenue cut for the dex"
      },
      "getDexVariables()": {
        "notice": "returns the last stored prices of the pool and the last interaction time stamp"
      },
      "newConfig()": {
        "notice": "returns the new calculated fee"
      },
      "rebalance()": {
        "notice": "rebalances the fee"
      },
      "relativeConfigPercentDiff()": {
        "notice": "returns how much new config would be different from current config in percent (100 = 1%, 1 = 0.01%)."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}