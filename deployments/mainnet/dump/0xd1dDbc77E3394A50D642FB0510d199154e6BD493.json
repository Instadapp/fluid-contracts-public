{
  "address": "0xd1dDbc77E3394A50D642FB0510d199154e6BD493",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "liquidity_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "dexFactory_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "contractDeployer_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "colOperations_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "debtOperations_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "perfectOperationsAndSwapOut_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "mainAddress1_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "mainAddress2_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "errorId_",
          "type": "uint256"
        }
      ],
      "name": "FluidDexError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "errorId_",
          "type": "uint256"
        }
      ],
      "name": "FluidDexFactoryError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "shares_",
          "type": "uint256"
        }
      ],
      "name": "FluidDexLiquidityOutput",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "token0Amt",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "token1Amt",
          "type": "uint256"
        }
      ],
      "name": "FluidDexPerfectLiquidityOutput",
      "type": "error"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "lastStoredPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "centerPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "upperRange",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "lowerRange",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "geometricMean",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "supplyToken0ExchangePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowToken0ExchangePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "supplyToken1ExchangePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowToken1ExchangePrice",
              "type": "uint256"
            }
          ],
          "internalType": "struct Structs.PricesAndExchangePrice",
          "name": "pex_",
          "type": "tuple"
        }
      ],
      "name": "FluidDexPricesAndExchangeRates",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenAmt",
          "type": "uint256"
        }
      ],
      "name": "FluidDexSingleTokenOutput",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "name": "FluidDexSwapResult",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "dex",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "dexId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "supplyToken",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "borrowToken",
          "type": "address"
        }
      ],
      "name": "DexT1Deployed",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "ADDRESS_THIS",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ADMIN_IMPLEMENTATION",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "CONTRACT_DEPLOYER",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DEX_FACTORY",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "LIQUIDITY",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MINI_DEPLOYER",
      "outputs": [
        {
          "internalType": "contract MiniDeployer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SHIFT_IMPLEMENTATION",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "colOperationsCreationCode",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "debtOperationsCreationCode",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token0_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "token1_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "oracleMapping_",
          "type": "uint256"
        }
      ],
      "name": "dexT1",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "dexCreationBytecode_",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "dexT1CreationBytecode",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "perfectOperationsCreationCode",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xf6650920eec15364e34211b78d58600e1175b6d31948274f936c32509aa87e9f",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x0Ed35B1609Ec45c7079E80d11149a52717e4859A",
    "contractAddress": null,
    "transactionIndex": 87,
    "gasUsed": "6110595",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000001000000000000000100000000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000000000000000000400000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000008000000000000000",
    "blockHash": "0x780e7f12ee2b644387e1b8eaa610207b0ac09f442a21714f481a74f1b581a63b",
    "transactionHash": "0xf6650920eec15364e34211b78d58600e1175b6d31948274f936c32509aa87e9f",
    "logs": [
      {
        "transactionIndex": 87,
        "blockNumber": 20770381,
        "transactionHash": "0xf6650920eec15364e34211b78d58600e1175b6d31948274f936c32509aa87e9f",
        "address": "0xec0D53e462a973ce08fd4A44B671f48bd2CeEa33",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x00000000000000000000000093dd426446b5370f094a1e31f19991aaa6ac0be0"
        ],
        "data": "0x",
        "logIndex": 182,
        "blockHash": "0x780e7f12ee2b644387e1b8eaa610207b0ac09f442a21714f481a74f1b581a63b"
      }
    ],
    "blockNumber": 20770381,
    "cumulativeGasUsed": "13275009",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x52Aa899454998Be5b000Ad077a46Bbe360F4e497",
    "0x93DD426446B5370F094a1e31f19991AAA6Ac0bE0",
    "0x4EC7b668BAF70d4A4b0FC7941a7708A07b6d45Be",
    "0x4a5a27901DBb1D6A976ad60692BF030d10435e08",
    "0x5aB54297FbAf4d0f00538ef53b28c12A1F9CC470",
    "0xA5bddbf162E813486191e80bF0214E33d3309E93",
    "0x09D499DF1Ac683C797c0ca84E6B73B8684d637d7",
    "0xD029B6d3fe0d45cdcda2Bc1aB7095a0457EBFf5D"
  ],
  "numDeployments": 1,
  "solcInputHash": "1a08335383273de1f427bde4902bf5fa",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidity_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dexFactory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contractDeployer_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"colOperations_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"debtOperations_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"perfectOperationsAndSwapOut_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mainAddress1_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mainAddress2_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorId_\",\"type\":\"uint256\"}],\"name\":\"FluidDexError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorId_\",\"type\":\"uint256\"}],\"name\":\"FluidDexFactoryError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares_\",\"type\":\"uint256\"}],\"name\":\"FluidDexLiquidityOutput\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token0Amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1Amt\",\"type\":\"uint256\"}],\"name\":\"FluidDexPerfectLiquidityOutput\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lastStoredPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"centerPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upperRange\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lowerRange\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"geometricMean\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyToken0ExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowToken0ExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyToken1ExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowToken1ExchangePrice\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.PricesAndExchangePrice\",\"name\":\"pex_\",\"type\":\"tuple\"}],\"name\":\"FluidDexPricesAndExchangeRates\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"}],\"name\":\"FluidDexSingleTokenOutput\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"FluidDexSwapResult\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dex\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dexId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplyToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrowToken\",\"type\":\"address\"}],\"name\":\"DexT1Deployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADDRESS_THIS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ADMIN_IMPLEMENTATION\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONTRACT_DEPLOYER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEX_FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINI_DEPLOYER\",\"outputs\":[{\"internalType\":\"contract MiniDeployer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFT_IMPLEMENTATION\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"colOperationsCreationCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtOperationsCreationCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oracleMapping_\",\"type\":\"uint256\"}],\"name\":\"dexT1\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"dexCreationBytecode_\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexT1CreationBytecode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"perfectOperationsCreationCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"DexT1Deployed(address,uint256,address,address)\":{\"params\":{\"borrowToken\":\"The address of the borrow token.\",\"dex\":\"The address of the newly deployed dex.\",\"dexId\":\"The id of the newly deployed dex.\",\"supplyToken\":\"The address of the supply token.\"}}},\"kind\":\"dev\",\"methods\":{\"colOperationsCreationCode()\":{\"details\":\"Retrieves the creation code for the FluidDexT1OperationsCol contract\"},\"debtOperationsCreationCode()\":{\"details\":\"Retrieves the creation code for the FluidDexT1OperationsDebt contract\"},\"perfectOperationsCreationCode()\":{\"details\":\"Retrieves the creation code for the FluidDexT1PerfectOperations contract\"}},\"stateVariables\":{\"COL_OPERATIONS_CREATIONCODE_ADDRESS\":{\"details\":\"SSTORE2 pointers for the creation code of various operations contracts\"},\"POOL_T1_CREATIONCODE_ADDRESS_1\":{\"details\":\"SSTORE2 pointer for the PoolT1 creation code. Stored externally to reduce factory bytecode (in 2 parts)\"}},\"version\":1},\"userdoc\":{\"errors\":{\"FluidDexSwapResult(uint256)\":[{\"notice\":\"used to simulate swap to find the output amount\"}]},\"events\":{\"DexT1Deployed(address,uint256,address,address)\":{\"notice\":\"Emitted when a new dexT1 is deployed.\"}},\"kind\":\"user\",\"methods\":{\"ADDRESS_THIS()\":{\"notice\":\"address of this contract\"},\"ADMIN_IMPLEMENTATION()\":{\"notice\":\"address of Admin implementation\"},\"CONTRACT_DEPLOYER()\":{\"notice\":\"address of Deployer Contract\"},\"DEX_FACTORY()\":{\"notice\":\"address of dexfactory contract\"},\"LIQUIDITY()\":{\"notice\":\"address of liquidity contract\"},\"MINI_DEPLOYER()\":{\"notice\":\"address of MiniDeployer Contract\"},\"SHIFT_IMPLEMENTATION()\":{\"notice\":\"address of Shift implementation\"},\"dexT1CreationBytecode()\":{\"notice\":\"returns the stored DexT1 creation bytecode\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocols/dex/factory/deploymentLogics/poolT1Logic.sol\":\"FluidDexT1DeploymentLogic\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"contracts/infiniteProxy/interfaces/iProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IProxy {\\n    function setAdmin(address newAdmin_) external;\\n\\n    function setDummyImplementation(address newDummyImplementation_) external;\\n\\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\\n\\n    function removeImplementation(address implementation_) external;\\n\\n    function getAdmin() external view returns (address);\\n\\n    function getDummyImplementation() external view returns (address);\\n\\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\\n\\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\\n\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n}\\n\",\"keccak256\":\"0xbb605491d4bac08e816248feecae7dd17cfc1877c88b2e555abece2970f5ea00\",\"license\":\"MIT\"},\"contracts/libraries/addressCalcs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice implements calculation of address for contracts deployed through CREATE.\\n/// Accepts contract deployed from which address & nonce\\nlibrary AddressCalcs {\\n\\n    /// @notice                         Computes the address of a contract based\\n    /// @param deployedFrom_            Address from which the contract was deployed\\n    /// @param nonce_                   Nonce at which the contract was deployed\\n    /// @return contract_               Address of deployed contract\\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\\n        // @dev based on https://ethereum.stackexchange.com/a/61413\\n\\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\\n        // hence, nonce of vault deployment starts with 1.\\n        bytes memory data;\\n        if (nonce_ == 0x00) {\\n            return address(0);\\n        } else if (nonce_ <= 0x7f) {\\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\\n        } else if (nonce_ <= 0xff) {\\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\\n        } else if (nonce_ <= 0xffff) {\\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\\n        } else if (nonce_ <= 0xffffff) {\\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\\n        } else {\\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\\n        }\\n\\n        return address(uint160(uint256(keccak256(data))));\\n    }\\n\\n}\",\"keccak256\":\"0xca389bcfef035463ff43939ac5eccab07ab74cbb053e201541f9bcd846b3105a\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/bigMathMinified.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\\n/// result in significant gas cost reduction due to storage space reduction.\\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\\nlibrary BigMathMinified {\\n    /// @dev constants to use for `roundUp` input param to increase readability\\n    bool internal constant ROUND_DOWN = false;\\n    bool internal constant ROUND_UP = true;\\n\\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\\n    /// e.g.:\\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\\n    /// exponent =                                            0011,0011     (51)\\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\\n    ///\\n    /// @param normal number which needs to be converted into Big Number\\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\\n    /// @param roundUp signals if result should be rounded down or up\\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\\n    function toBigNumber(\\n        uint256 normal,\\n        uint256 coefficientSize,\\n        uint256 exponentSize,\\n        bool roundUp\\n    ) internal pure returns (uint256 bigNumber) {\\n        assembly {\\n            let lastBit_\\n            let number_ := normal\\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x80, number_)\\n                lastBit_ := 0x80\\n            }\\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x40, number_)\\n                lastBit_ := add(lastBit_, 0x40)\\n            }\\n            if gt(number_, 0xFFFFFFFF) {\\n                number_ := shr(0x20, number_)\\n                lastBit_ := add(lastBit_, 0x20)\\n            }\\n            if gt(number_, 0xFFFF) {\\n                number_ := shr(0x10, number_)\\n                lastBit_ := add(lastBit_, 0x10)\\n            }\\n            if gt(number_, 0xFF) {\\n                number_ := shr(0x8, number_)\\n                lastBit_ := add(lastBit_, 0x8)\\n            }\\n            if gt(number_, 0xF) {\\n                number_ := shr(0x4, number_)\\n                lastBit_ := add(lastBit_, 0x4)\\n            }\\n            if gt(number_, 0x3) {\\n                number_ := shr(0x2, number_)\\n                lastBit_ := add(lastBit_, 0x2)\\n            }\\n            if gt(number_, 0x1) {\\n                lastBit_ := add(lastBit_, 1)\\n            }\\n            if gt(number_, 0) {\\n                lastBit_ := add(lastBit_, 1)\\n            }\\n            if lt(lastBit_, coefficientSize) {\\n                // for throw exception\\n                lastBit_ := coefficientSize\\n            }\\n            let exponent := sub(lastBit_, coefficientSize)\\n            let coefficient := shr(exponent, normal)\\n            if and(roundUp, gt(exponent, 0)) {\\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\\n                coefficient := add(coefficient, 1)\\n                if eq(shl(coefficientSize, 1), coefficient) {\\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\\n                    coefficient := shl(sub(coefficientSize, 1), 1)\\n                    exponent := add(exponent, 1)\\n                }\\n            }\\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\\n                // if exponent is >= exponentSize, the normal number is too big to fit within\\n                // BigNumber with too small sizes for coefficient and exponent\\n                revert(0, 0)\\n            }\\n            bigNumber := shl(exponentSize, coefficient)\\n            bigNumber := add(bigNumber, exponent)\\n        }\\n    }\\n\\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\\n    function fromBigNumber(\\n        uint256 bigNumber,\\n        uint256 exponentSize,\\n        uint256 exponentMask\\n    ) internal pure returns (uint256 normal) {\\n        assembly {\\n            let coefficient := shr(exponentSize, bigNumber)\\n            let exponent := and(bigNumber, exponentMask)\\n            normal := shl(exponent, coefficient)\\n        }\\n    }\\n\\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\\n    /// e.g.\\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\\n        assembly {\\n            let number_ := normal\\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x80, number_)\\n                lastBit := 0x80\\n            }\\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x40, number_)\\n                lastBit := add(lastBit, 0x40)\\n            }\\n            if gt(number_, 0xFFFFFFFF) {\\n                number_ := shr(0x20, number_)\\n                lastBit := add(lastBit, 0x20)\\n            }\\n            if gt(number_, 0xFFFF) {\\n                number_ := shr(0x10, number_)\\n                lastBit := add(lastBit, 0x10)\\n            }\\n            if gt(number_, 0xFF) {\\n                number_ := shr(0x8, number_)\\n                lastBit := add(lastBit, 0x8)\\n            }\\n            if gt(number_, 0xF) {\\n                number_ := shr(0x4, number_)\\n                lastBit := add(lastBit, 0x4)\\n            }\\n            if gt(number_, 0x3) {\\n                number_ := shr(0x2, number_)\\n                lastBit := add(lastBit, 0x2)\\n            }\\n            if gt(number_, 0x1) {\\n                lastBit := add(lastBit, 1)\\n            }\\n            if gt(number_, 0) {\\n                lastBit := add(lastBit, 1)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf0be1002909edf30aec3dc6623c2bd2407ed94064b62674c01032b844dec206a\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/bytesSliceAndConcat.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary BytesSliceAndConcat {\\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\\n    function bytesConcat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    ) internal pure returns (bytes memory tempBytes) {\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(\\n                0x40,\\n                and(\\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n                    not(31) // Round down to the nearest 32 bytes.\\n                )\\n            )\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\\n    function bytesSlice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory tempBytes) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n}\\n\",\"keccak256\":\"0x42966896926a24dc7645ebf4679e6d701cb991144ef4d710d87738165d4024c7\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/dexCalcs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { BigMathMinified } from \\\"./bigMathMinified.sol\\\";\\nimport { DexSlotsLink } from \\\"./dexSlotsLink.sol\\\";\\n\\n/// @notice implements calculation methods used for Fluid Dex such as updated withdrawal / borrow limits.\\nlibrary DexCalcs {\\n    // constants used for BigMath conversion from and to storage\\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\\n\\n    uint256 internal constant FOUR_DECIMALS = 1e4;\\n    uint256 internal constant X14 = 0x3fff;\\n    uint256 internal constant X18 = 0x3ffff;\\n    uint256 internal constant X24 = 0xffffff;\\n    uint256 internal constant X33 = 0x1ffffffff;\\n    uint256 internal constant X64 = 0xffffffffffffffff;\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                      CALC LIMITS                       /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev calculates withdrawal limit before an operate execution:\\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\\n    /// @param userSupplyData_ user supply data packed uint256 from storage\\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\\n    function calcWithdrawalLimitBeforeOperate(\\n        uint256 userSupplyData_,\\n        uint256 userSupply_\\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\\n        // a deposit anyway. Important is that it would not revert.\\n\\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\\n        // is the fully expanded limit immediately.\\n\\n        // extract last set withdrawal limit\\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) &\\n            X64;\\n        lastWithdrawalLimit_ =\\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\\n        if (lastWithdrawalLimit_ == 0) {\\n            // withdrawal limit is not activated. Max withdrawal allowed\\n            return 0;\\n        }\\n\\n        uint256 maxWithdrawableLimit_;\\n        uint256 temp_;\\n        unchecked {\\n            // extract max withdrawable percent of user supply and\\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\\n\\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            maxWithdrawableLimit_ =\\n                (((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\\n                FOUR_DECIMALS;\\n\\n            // time elapsed since last withdrawal limit was set (in seconds)\\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\\n            // last timestamp can not be > current timestamp\\n            temp_ = block.timestamp - ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\\n        }\\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\\n        temp_ =\\n            (maxWithdrawableLimit_ * temp_) /\\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\\n            ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\\n        unchecked {\\n            // underflow explicitly checked & handled\\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\\n            temp_ = userSupply_ - maxWithdrawableLimit_;\\n        }\\n        // if withdrawal limit is decreased below minimum then set minimum\\n        // (e.g. when more than expandDuration time has elapsed)\\n        if (temp_ > currentWithdrawalLimit_) {\\n            currentWithdrawalLimit_ = temp_;\\n        }\\n    }\\n\\n    /// @dev calculates withdrawal limit after an operate execution:\\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\\n    /// @param userSupplyData_ user supply data packed uint256 from storage\\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\\n    ///                          raw for with interest mode, normal amount for interest free mode!\\n    function calcWithdrawalLimitAfterOperate(\\n        uint256 userSupplyData_,\\n        uint256 userSupply_,\\n        uint256 newWithdrawalLimit_\\n    ) internal pure returns (uint256) {\\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\\n        uint256 temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        // if user supply is below base limit then max withdrawals are allowed\\n        if (userSupply_ < temp_) {\\n            return 0;\\n        }\\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\\n        temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\\n        unchecked {\\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\\n        }\\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\\n        // increased deposit amount outpaces withrawals.\\n        if (temp_ > newWithdrawalLimit_) {\\n            return temp_;\\n        }\\n        return newWithdrawalLimit_;\\n    }\\n\\n    /// @dev calculates borrow limit before an operate execution:\\n    /// total amount user borrow can reach (not borrowable amount in current operation).\\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\\n    ///                             raw for with interest mode, normal amount for interest free mode!\\n    function calcBorrowLimitBeforeOperate(\\n        uint256 userBorrowData_,\\n        uint256 userBorrow_\\n    ) internal view returns (uint256 currentBorrowLimit_) {\\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\\n\\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\\n\\n        uint256 maxExpansionLimit_;\\n        uint256 maxExpandedBorrowLimit_;\\n        unchecked {\\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\\n\\n            // calculate max borrow limit: Max point limit can increase to since last interaction\\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\\n        }\\n\\n        // currentBorrowLimit_ = extract base borrow limit\\n        currentBorrowLimit_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\\n        currentBorrowLimit_ =\\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\\n            return currentBorrowLimit_;\\n        }\\n        // time elapsed since last borrow limit was set (in seconds)\\n        unchecked {\\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\\n            temp_ = block.timestamp - ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\\n        }\\n\\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\\n        currentBorrowLimit_ =\\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\\n            ((maxExpansionLimit_ * temp_) /\\n                ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\\n            //  extract last set borrow limit\\n            BigMathMinified.fromBigNumber(\\n                (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\\n                DEFAULT_EXPONENT_SIZE,\\n                DEFAULT_EXPONENT_MASK\\n            );\\n\\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\\n        // so set to `maxExpandedBorrowLimit_` in that case.\\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\\n        }\\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (currentBorrowLimit_ > temp_) {\\n            currentBorrowLimit_ = temp_;\\n        }\\n    }\\n\\n    /// @dev calculates borrow limit after an operate execution:\\n    /// total amount user borrow can reach (not borrowable amount in current operation).\\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\\n    function calcBorrowLimitAfterOperate(\\n        uint256 userBorrowData_,\\n        uint256 userBorrow_,\\n        uint256 newBorrowLimit_\\n    ) internal pure returns (uint256 borrowLimit_) {\\n        // temp_ = extract borrow expand percent\\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\\n\\n        unchecked {\\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\\n        }\\n\\n        // temp_ = extract base borrow limit\\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (borrowLimit_ < temp_) {\\n            // below base limit, borrow limit is always base limit\\n            return temp_;\\n        }\\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        // make sure fully expanded borrow limit is not above hard max borrow limit\\n        if (borrowLimit_ > temp_) {\\n            borrowLimit_ = temp_;\\n        }\\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\\n        if (newBorrowLimit_ > borrowLimit_) {\\n            return borrowLimit_;\\n        }\\n        return newBorrowLimit_;\\n    }\\n}\\n\",\"keccak256\":\"0x9c4252ebe634fccf3617ca05ffba41e27985d13e68ad0ea871aaba4851691ec7\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/dexSlotsLink.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\\nlibrary DexSlotsLink {\\n    /// @dev storage slot for variables at Dex\\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\\n    /// @dev storage slot for variables2 at Dex\\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\\n    /// @dev storage slot for total supply shares at Dex\\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\\n    /// @dev storage slot for user supply mapping at Dex\\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\\n    /// @dev storage slot for total borrow shares at Dex\\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\\n    /// @dev storage slot for user borrow mapping at Dex\\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\\n    /// @dev storage slot for oracle mapping at Dex\\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\\n    /// @dev storage slot for range and threshold shifts at Dex\\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\\n    /// @dev storage slot for center price shift at Dex\\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\\n\\n    // --------------------------------\\n    // @dev stacked uint256 storage slots bits position data for each:\\n\\n    // UserSupplyData\\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\\n\\n    // UserBorrowData\\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\\n\\n    // --------------------------------\\n\\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\\n    function calculateDoubleMappingStorageSlot(\\n        uint256 slot_,\\n        address key1_,\\n        address key2_\\n    ) internal pure returns (bytes32) {\\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\\n        return keccak256(abi.encode(key2_, intermediateSlot_));\\n    }\\n}\\n\",\"keccak256\":\"0xf1d6550d83fb0155a26655234922c9bdf4a1bbcf7a3ca767e9123d367a795307\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary LibsErrorTypes {\\n    /***********************************|\\n    |         LiquidityCalcs            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\\n\\n    /// @notice thrown when rate data is set to a version that is not implemented\\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\\n\\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\\n\\n    /***********************************|\\n    |           SafeTransfer            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when safe transfer from for an ERC20 fails\\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\\n\\n    /// @notice thrown when safe transfer for an ERC20 fails\\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\\n}\\n\",\"keccak256\":\"0xaf7732f30d00dd38082d37aa37887be485fc94b0c76ff302aff615d03381674f\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/liquidityCalcs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { LibsErrorTypes as ErrorTypes } from \\\"./errorTypes.sol\\\";\\nimport { LiquiditySlotsLink } from \\\"./liquiditySlotsLink.sol\\\";\\nimport { BigMathMinified } from \\\"./bigMathMinified.sol\\\";\\n\\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\\n/// borrow rate, withdrawal / borrow limits, revenue amount.\\nlibrary LiquidityCalcs {\\n    error FluidLiquidityCalcsError(uint256 errorId_);\\n\\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\\n    event BorrowRateMaxCap();\\n\\n    /// @dev constants as from Liquidity variables.sol\\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\\n\\n    /// @dev Ignoring leap years\\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\\n    // constants used for BigMath conversion from and to storage\\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\\n\\n    uint256 internal constant FOUR_DECIMALS = 1e4;\\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\\n    uint256 internal constant X14 = 0x3fff;\\n    uint256 internal constant X15 = 0x7fff;\\n    uint256 internal constant X16 = 0xffff;\\n    uint256 internal constant X18 = 0x3ffff;\\n    uint256 internal constant X24 = 0xffffff;\\n    uint256 internal constant X33 = 0x1ffffffff;\\n    uint256 internal constant X64 = 0xffffffffffffffff;\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                  CALC EXCHANGE PRICES                  /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\\n    function calcExchangePrices(\\n        uint256 exchangePricesAndConfig_\\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\\n        // Extracting exchange prices\\n        supplyExchangePrice_ =\\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\\n            X64;\\n        borrowExchangePrice_ =\\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\\n            X64;\\n\\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\\n        }\\n\\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\\n\\n        unchecked {\\n            // last timestamp can not be > current timestamp\\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\\n\\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\\n                X15;\\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\\n                return (supplyExchangePrice_, borrowExchangePrice_);\\n            }\\n\\n            // calculate new borrow exchange price.\\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\\n            borrowExchangePrice_ +=\\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\\n\\n            // FOR SUPPLY EXCHANGE PRICE:\\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\\n            //\\n            // Example:\\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\\n            // yield is 10 (so half a year must have passed).\\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 20%) = 62,5%\\n            // supplyRate = (40% * (100% - 10%)) * = 36% * 62,5% = 22.5%\\n            // increase in supplyExchangePrice, assuming 100 as previous price.\\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\\n\\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\\n\\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\\n\\n            if (temp_ == 1) {\\n                // if no raw supply: no exchange price update needed\\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\\n                return (supplyExchangePrice_, borrowExchangePrice_);\\n            }\\n\\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\\n            if (temp_ & 1 == 1) {\\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\\n                temp_ = temp_ >> 1;\\n\\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\\n                // in the if statement a little above.\\n\\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\\n                // so ratioSupplyYield must come out as 2.5 (250%).\\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\\n                temp_ =\\n                    // utilization * (100% + 100% / supplyRatio)\\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\\n                    (FOUR_DECIMALS);\\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\\n            } else {\\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\\n                temp_ = temp_ >> 1;\\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\\n\\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\\n                temp_ =\\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\\n                    (1e27 *\\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\\n                        (FOUR_DECIMALS + temp_)) /\\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\\n            }\\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\\n\\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\\n            if (borrowRatio_ & 1 == 1) {\\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\\n                borrowRatio_ = borrowRatio_ >> 1;\\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\\n\\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\\n\\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\\n            } else {\\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\\n                borrowRatio_ = borrowRatio_ >> 1;\\n\\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\\n            }\\n\\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\\n\\n            // 2. calculate supply rate\\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\\n            // but more suppliers not earning interest.\\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\\n                temp_ * // ratioSupplyYield\\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\\n\\n            // 3. calculate increase in supply exchange price\\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                     CALC REVENUE                       /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\\n    /// and the current balance of the Fluid liquidity contract for the token.\\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\\n    /// @return revenueAmount_ collectable revenue amount\\n    function calcRevenue(\\n        uint256 totalAmounts_,\\n        uint256 exchangePricesAndConfig_,\\n        uint256 liquidityTokenBalance_\\n    ) internal view returns (uint256 revenueAmount_) {\\n        // @dev no need to super-optimize this method as it is only used by admin\\n\\n        // calculate the new exchange prices based on earned interest\\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\\n\\n        // total supply = interest free + with interest converted from raw\\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\\n\\n        if (totalSupply_ > 0) {\\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\\n            // ensure there is no possible case because of rounding etc. where this would revert,\\n            // explicitly check if >\\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\\n            // can only be revenue.\\n        } else {\\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\\n            revenueAmount_ = liquidityTokenBalance_;\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                      CALC LIMITS                       /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev calculates withdrawal limit before an operate execution:\\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\\n    /// @param userSupplyData_ user supply data packed uint256 from storage\\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\\n    function calcWithdrawalLimitBeforeOperate(\\n        uint256 userSupplyData_,\\n        uint256 userSupply_\\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\\n        // a deposit anyway. Important is that it would not revert.\\n\\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\\n        // is the fully expanded limit immediately.\\n\\n        // extract last set withdrawal limit\\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\\n        lastWithdrawalLimit_ =\\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\\n        if (lastWithdrawalLimit_ == 0) {\\n            // withdrawal limit is not activated. Max withdrawal allowed\\n            return 0;\\n        }\\n\\n        uint256 maxWithdrawableLimit_;\\n        uint256 temp_;\\n        unchecked {\\n            // extract max withdrawable percent of user supply and\\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\\n\\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            maxWithdrawableLimit_ =\\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\\n                FOUR_DECIMALS;\\n\\n            // time elapsed since last withdrawal limit was set (in seconds)\\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\\n            // last timestamp can not be > current timestamp\\n            temp_ =\\n                block.timestamp -\\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\\n        }\\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\\n        temp_ =\\n            (maxWithdrawableLimit_ * temp_) /\\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\\n        unchecked {\\n            // underflow explicitly checked & handled\\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\\n            temp_ = userSupply_ - maxWithdrawableLimit_;\\n        }\\n        // if withdrawal limit is decreased below minimum then set minimum\\n        // (e.g. when more than expandDuration time has elapsed)\\n        if (temp_ > currentWithdrawalLimit_) {\\n            currentWithdrawalLimit_ = temp_;\\n        }\\n    }\\n\\n    /// @dev calculates withdrawal limit after an operate execution:\\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\\n    /// @param userSupplyData_ user supply data packed uint256 from storage\\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\\n    ///                          raw for with interest mode, normal amount for interest free mode!\\n    function calcWithdrawalLimitAfterOperate(\\n        uint256 userSupplyData_,\\n        uint256 userSupply_,\\n        uint256 newWithdrawalLimit_\\n    ) internal pure returns (uint256) {\\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        // if user supply is below base limit then max withdrawals are allowed\\n        if (userSupply_ < temp_) {\\n            return 0;\\n        }\\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\\n        unchecked {\\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\\n        }\\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\\n        // increased deposit amount outpaces withrawals.\\n        if (temp_ > newWithdrawalLimit_) {\\n            return temp_;\\n        }\\n        return newWithdrawalLimit_;\\n    }\\n\\n    /// @dev calculates borrow limit before an operate execution:\\n    /// total amount user borrow can reach (not borrowable amount in current operation).\\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\\n    ///                             raw for with interest mode, normal amount for interest free mode!\\n    function calcBorrowLimitBeforeOperate(\\n        uint256 userBorrowData_,\\n        uint256 userBorrow_\\n    ) internal view returns (uint256 currentBorrowLimit_) {\\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\\n\\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\\n\\n        uint256 maxExpansionLimit_;\\n        uint256 maxExpandedBorrowLimit_;\\n        unchecked {\\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\\n\\n            // calculate max borrow limit: Max point limit can increase to since last interaction\\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\\n        }\\n\\n        // currentBorrowLimit_ = extract base borrow limit\\n        currentBorrowLimit_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\\n        currentBorrowLimit_ =\\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\\n            return currentBorrowLimit_;\\n        }\\n        // time elapsed since last borrow limit was set (in seconds)\\n        unchecked {\\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\\n            temp_ =\\n                block.timestamp -\\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\\n        }\\n\\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\\n        currentBorrowLimit_ =\\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\\n            ((maxExpansionLimit_ * temp_) /\\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\\n            //  extract last set borrow limit\\n            BigMathMinified.fromBigNumber(\\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\\n                DEFAULT_EXPONENT_SIZE,\\n                DEFAULT_EXPONENT_MASK\\n            );\\n\\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\\n        // so set to `maxExpandedBorrowLimit_` in that case.\\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\\n        }\\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (currentBorrowLimit_ > temp_) {\\n            currentBorrowLimit_ = temp_;\\n        }\\n    }\\n\\n    /// @dev calculates borrow limit after an operate execution:\\n    /// total amount user borrow can reach (not borrowable amount in current operation).\\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\\n    function calcBorrowLimitAfterOperate(\\n        uint256 userBorrowData_,\\n        uint256 userBorrow_,\\n        uint256 newBorrowLimit_\\n    ) internal pure returns (uint256 borrowLimit_) {\\n        // temp_ = extract borrow expand percent\\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\\n\\n        unchecked {\\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\\n        }\\n\\n        // temp_ = extract base borrow limit\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (borrowLimit_ < temp_) {\\n            // below base limit, borrow limit is always base limit\\n            return temp_;\\n        }\\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n        // make sure fully expanded borrow limit is not above hard max borrow limit\\n        if (borrowLimit_ > temp_) {\\n            borrowLimit_ = temp_;\\n        }\\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\\n        if (newBorrowLimit_ > borrowLimit_) {\\n            return borrowLimit_;\\n        }\\n        return newBorrowLimit_;\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    //////////                      CALC RATES                        /////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev Calculates new borrow rate from utilization for a token\\n    /// @param rateData_ rate data packed uint256 from storage for the token\\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\\n        // extract rate version: 4 bits (0xF) starting from bit 0\\n        uint256 rateVersion_ = (rateData_ & 0xF);\\n\\n        if (rateVersion_ == 1) {\\n            rate_ = calcRateV1(rateData_, utilization_);\\n        } else if (rateVersion_ == 2) {\\n            rate_ = calcRateV2(rateData_, utilization_);\\n        } else {\\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\\n        }\\n\\n        if (rate_ > X16) {\\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\\n            // this is unlikely to ever happen if configs stay within expected levels.\\n            rate_ = X16;\\n            // emit event to more easily become aware\\n            emit BorrowRateMaxCap();\\n        }\\n    }\\n\\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\\n    /// @param rateData_ rate data packed uint256 from storage for the token\\n    /// @param utilization_  in 1e2 (100% = 1e4)\\n    /// @return rate_ rate in 1e2 precision\\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\\n        /// For rate v1 (one kink) ------------------------------------------------------\\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\\n\\n        // y = mx + c.\\n        // y is borrow rate\\n        // x is utilization\\n        // m = slope (m can also be negative for declining rates)\\n        // c is constant (c can be negative)\\n\\n        uint256 y1_;\\n        uint256 y2_;\\n        uint256 x1_;\\n        uint256 x2_;\\n\\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\\n        if (utilization_ < kink1_) {\\n            // if utilization is less than kink\\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\\n            x1_ = 0; // 0%\\n            x2_ = kink1_;\\n        } else {\\n            // else utilization is greater than kink\\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\\n            x1_ = kink1_;\\n            x2_ = FOUR_DECIMALS; // 100%\\n        }\\n\\n        int256 constant_;\\n        int256 slope_;\\n        unchecked {\\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\\n\\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\\n\\n            // calculating new borrow rate\\n            // - slope_ max value is 65535 * 1e12,\\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\\n            // - constant max value is 65535 * 1e12\\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\\n            // divisor TWELVE_DECIMALS can not be 0\\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\\n            if (slope_ < 0) {\\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\\n            }\\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\\n        }\\n    }\\n\\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\\n    /// @param rateData_ rate data packed uint256 from storage for the token\\n    /// @param utilization_  in 1e2 (100% = 1e4)\\n    /// @return rate_ rate in 1e4 precision\\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\\n        /// For rate v2 (two kinks) -----------------------------------------------------\\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\\n        /// Last 156 bits => 100-255 => blank, might come in use in future\\n\\n        // y = mx + c.\\n        // y is borrow rate\\n        // x is utilization\\n        // m = slope (m can also be negative for declining rates)\\n        // c is constant (c can be negative)\\n\\n        uint256 y1_;\\n        uint256 y2_;\\n        uint256 x1_;\\n        uint256 x2_;\\n\\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\\n        if (utilization_ < kink1_) {\\n            // if utilization is less than kink1\\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\\n            x1_ = 0; // 0%\\n            x2_ = kink1_;\\n        } else {\\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\\n            if (utilization_ < kink2_) {\\n                // if utilization is less than kink2\\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\\n                x1_ = kink1_;\\n                x2_ = kink2_;\\n            } else {\\n                // else utilization is greater than kink2\\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\\n                x1_ = kink2_;\\n                x2_ = FOUR_DECIMALS;\\n            }\\n        }\\n\\n        int256 constant_;\\n        int256 slope_;\\n        unchecked {\\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\\n\\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\\n\\n            // calculating new borrow rate\\n            // - slope_ max value is 65535 * 1e12,\\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\\n            // - constant max value is 65535 * 1e12\\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\\n            // divisor TWELVE_DECIMALS can not be 0\\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\\n            if (slope_ < 0) {\\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\\n            }\\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\\n        }\\n    }\\n\\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\\n    function getTotalSupply(\\n        uint256 totalAmounts_,\\n        uint256 supplyExchangePrice_\\n    ) internal pure returns (uint256 totalSupply_) {\\n        // totalSupply_ => supplyInterestFree\\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\\n\\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\\n\\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\\n    }\\n\\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\\n    function getTotalBorrow(\\n        uint256 totalAmounts_,\\n        uint256 borrowExchangePrice_\\n    ) internal pure returns (uint256 totalBorrow_) {\\n        // totalBorrow_ => borrowInterestFree\\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\\n\\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\\n\\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\\n    }\\n}\\n\",\"keccak256\":\"0xa65e2f84b2c33769ceb6b28fbd3221be29da2f8ac96e4d8b8cea91948d81a707\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/liquiditySlotsLink.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\\nlibrary LiquiditySlotsLink {\\n    /// @dev storage slot for status at Liquidity\\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\\n    /// @dev storage slot for auths mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\\n    /// @dev storage slot for guardians mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\\n    /// @dev storage slot for user class mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\\n    /// @dev storage slot for rateData mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\\n    /// @dev storage slot for totalAmounts mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\\n    /// @dev storage slot for user supply double mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\\n    /// @dev storage slot for user borrow double mapping at Liquidity\\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\\n    /// @dev storage slot for listed tokens array at Liquidity\\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\\n    /// @dev storage slot for listed tokens array at Liquidity\\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\\n\\n    // --------------------------------\\n    // @dev stacked uint256 storage slots bits position data for each:\\n\\n    // ExchangePricesAndConfig\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\\n\\n    // RateData:\\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\\n    // RateData: V1\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\\n    // RateData: V2\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\\n\\n    // TotalAmounts\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\\n\\n    // UserSupplyData\\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\\n\\n    // UserBorrowData\\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\\n\\n    // Configs2\\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\\n\\n    // --------------------------------\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\\n    function calculateDoubleMappingStorageSlot(\\n        uint256 slot_,\\n        address key1_,\\n        address key2_\\n    ) internal pure returns (bytes32) {\\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\\n        return keccak256(abi.encode(key2_, intermediateSlot_));\\n    }\\n}\\n\",\"keccak256\":\"0x0ae3e1d231bb6c14b54fc1f5ffa306edc0ac827a6a92279c77c0c09627fe08ae\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/safeTransfer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport { LibsErrorTypes as ErrorTypes } from \\\"./errorTypes.sol\\\";\\n\\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\\nlibrary SafeTransfer {\\n    error FluidSafeTransferError(uint256 errorId_);\\n\\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\\n        bool success_;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from_\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to_\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \\\"amount_\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success_ := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        if (!success_) {\\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\\n        }\\n    }\\n\\n    /// @dev Transfer `amount_` of `token_` to `to_`.\\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\\n        bool success_;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to_\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \\\"amount_\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success_ := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        if (!success_) {\\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\\n        }\\n    }\\n\\n    /// @dev Transfer `amount_` of ` native token to `to_`.\\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\\n    function safeTransferNative(address to_, uint256 amount_) internal {\\n        bool success_;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success_ := call(gas(), to_, amount_, 0, 0, 0, 0)\\n        }\\n\\n        if (!success_) {\\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7069d5801ef91035c666e05f11ccccdad310bbfc8f75b390cf44f69ff39d180d\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/libraries/storageRead.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\n/// @notice implements a method to read uint256 data from storage at a bytes32 storage slot key.\\ncontract StorageRead {\\n    function readFromStorage(bytes32 slot_) public view returns (uint256 result_) {\\n        assembly {\\n            result_ := sload(slot_) // read value from the storage slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1b03dfe294c2f0376f7e34c3960fe7088d7ff44bb2ffd9cb2ac940486bfba8c9\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/adminModule/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Structs {\\n    struct AddressBool {\\n        address addr;\\n        bool value;\\n    }\\n\\n    struct AddressUint256 {\\n        address addr;\\n        uint256 value;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 1\\n    struct RateDataV1Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\\n        uint256 kink;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink;\\n        ///\\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set borrow rate data for version 2\\n    struct RateDataV2Params {\\n        ///\\n        /// @param token for rate data\\n        address token;\\n        ///\\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\\n        uint256 kink1;\\n        ///\\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\\n        uint256 kink2;\\n        ///\\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\\n        /// i.e. constant minimum borrow rate\\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\\n        uint256 rateAtUtilizationZero;\\n        ///\\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\\n        uint256 rateAtUtilizationKink1;\\n        ///\\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\\n        uint256 rateAtUtilizationKink2;\\n        ///\\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\\n        uint256 rateAtUtilizationMax;\\n    }\\n\\n    /// @notice struct to set token config\\n    struct TokenConfig {\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 fee;\\n        ///\\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\\n        uint256 threshold;\\n        ///\\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\\n        uint256 maxUtilization;\\n    }\\n\\n    /// @notice struct to set user supply & withdrawal config\\n    struct UserSupplyConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration withdrawal limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseWithdrawalLimit;\\n    }\\n\\n    /// @notice struct to set user borrow & payback config\\n    struct UserBorrowConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param token address\\n        address token;\\n        ///\\n        /// @param mode: 0 = without interest. 1 = with interest\\n        uint8 mode;\\n        ///\\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which debt limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration debt limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseDebtCeiling;\\n        ///\\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 maxDebtCeiling;\\n    }\\n}\\n\",\"keccak256\":\"0x10353c70015f27b880125cefab806dbed24a4458f187da66964f3ef60488f757\",\"license\":\"BUSL-1.1\"},\"contracts/liquidity/interfaces/iLiquidity.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { IProxy } from \\\"../../infiniteProxy/interfaces/iProxy.sol\\\";\\nimport { Structs as AdminModuleStructs } from \\\"../adminModule/structs.sol\\\";\\n\\ninterface IFluidLiquidityAdmin {\\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\\n    /// @param authsStatus_ array of structs setting allowed status for an address.\\n    ///                     status true => add auth, false => remove auth\\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\\n\\n    /// @notice adds/removes guardians. Only callable by Governance.\\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\\n    ///                         status true => add guardian, false => remove guardian\\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\\n\\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\\n    /// @param revenueCollector_  new revenue collector address\\n    function updateRevenueCollector(address revenueCollector_) external;\\n\\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\\n    /// @param newStatus_ new status\\n    ///        status = 2 -> pause, status = 1 -> resume.\\n    function changeStatus(uint256 newStatus_) external;\\n\\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\\n\\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\\n\\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\\n    ///         Only callable by Auths.\\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\\n\\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\\n    ///         Only callable by Auths.\\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\\n\\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\\n    ///         Only callable by Auths.\\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\\n\\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\\n    /// @param user_ user address for which to update the withdrawal limit\\n    /// @param token_ token address for which to update the withdrawal limit\\n    /// @param newLimit_ new limit until which user supply can decrease to.\\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\\n    ///                  current user supply as limit respectively.\\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\\n    ///                  below base limit then fully down to 0.\\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\\n\\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\\n    ///         Only callable by Auths.\\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\\n\\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\\n    /// Only callable by Guardians.\\n    /// @param user_          address of user to pause operations for\\n    /// @param supplyTokens_  token addresses to pause withdrawals for\\n    /// @param borrowTokens_  token addresses to pause borrowings for\\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\\n\\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\\n    /// Only callable by Guardians.\\n    /// @param user_          address of user to unpause operations for\\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\\n    /// @param borrowTokens_  token addresses to unpause borrowings for\\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\\n\\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\\n    /// @param tokens_  array of tokens to collect revenue for\\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\\n    function collectRevenue(address[] calldata tokens_) external;\\n\\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\\n    /// @param tokens_ tokens to update exchange prices for\\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\\n    function updateExchangePrices(\\n        address[] calldata tokens_\\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\\n}\\n\\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\\n    /// @notice Single function which handles supply, withdraw, borrow & payback\\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\\n    /// @param withdrawTo_ if withdrawal then to which address\\n    /// @param borrowTo_ if borrow then to which address\\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\\n    /// @return memVar3_ updated supplyExchangePrice\\n    /// @return memVar4_ updated borrowExchangePrice\\n    /// @dev to trigger skipping in / out transfers (gas optimization):\\n    /// -  ` callbackData_` MUST be encoded so that \\\"from\\\" address is the last 20 bytes in the last 32 bytes slot,\\n    ///     also for native token operations where liquidityCallback is not triggered!\\n    ///     from address must come at last position if there is more data. I.e. encode like:\\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\\n    /// -   this \\\"from\\\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\\n    ///     in the slot before (bytes 32 to 63)\\n    /// -   `msg.value` must be 0.\\n    /// -   Amounts must be either:\\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\\n    function operate(\\n        address token_,\\n        int256 supplyAmount_,\\n        int256 borrowAmount_,\\n        address withdrawTo_,\\n        address borrowTo_,\\n        bytes calldata callbackData_\\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\\n}\\n\\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\\n\",\"keccak256\":\"0x4aa83e84baa7c2f4d58b07a3eca4ab7fe7d6fc660898daaac338dc3f129c4123\",\"license\":\"MIT\"},\"contracts/protocols/dex/error.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Structs } from \\\"./poolT1/coreModule/structs.sol\\\";\\n\\nabstract contract Error {\\n    error FluidDexError(uint256 errorId_);\\n\\n    error FluidDexFactoryError(uint256 errorId_);\\n\\n    /// @notice used to simulate swap to find the output amount\\n    error FluidDexSwapResult(uint256 amountOut);\\n\\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\\n\\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\\n\\n    error FluidDexLiquidityOutput(uint256 shares_);\\n\\n    error FluidDexPricesAndExchangeRates(Structs.PricesAndExchangePrice pex_);\\n}\\n\",\"keccak256\":\"0x67ee7f5c49e076ca1a02b545dafe2f6d782c759b7afad99682c2499e3b47c602\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary ErrorTypes {\\n    /***********************************|\\n    |            DEX Factory            | \\n    |__________________________________*/\\n\\n    uint256 internal constant DexFactory__InvalidOperation = 50001;\\n    uint256 internal constant DexFactory__Unauthorized = 50002;\\n    uint256 internal constant DexFactory__SameTokenNotAllowed = 50003;\\n    uint256 internal constant DexFactory__TokenConfigNotProper = 50004;\\n    uint256 internal constant DexFactory__InvalidParams = 50005;\\n    uint256 internal constant DexFactory__OnlyDelegateCallAllowed = 50006;\\n    uint256 internal constant DexFactory__InvalidDexAddress = 50007;\\n\\n    /***********************************|\\n    |             DexT1                 | \\n    |__________________________________*/\\n\\n    /// @notice thrown at reentrancy\\n    uint256 internal constant DexT1__AlreadyEntered = 51001;\\n\\n    uint256 internal constant DexT1__NotAnAuth = 51002;\\n\\n    uint256 internal constant DexT1__SmartColNotEnabled = 51003;\\n\\n    uint256 internal constant DexT1__SmartDebtNotEnabled = 51004;\\n\\n    uint256 internal constant DexT1__PoolNotInitialized = 51005;\\n\\n    uint256 internal constant DexT1__TokenReservesTooLow = 51006;\\n\\n    uint256 internal constant DexT1__EthAndAmountInMisMatch = 51007;\\n\\n    uint256 internal constant DexT1__EthSentForNonNativeSwap = 51008;\\n\\n    uint256 internal constant DexT1__NoSwapRoute = 51009;\\n\\n    uint256 internal constant DexT1__NotEnoughAmountOut = 51010;\\n\\n    uint256 internal constant DexT1__LiquidityLayerTokenUtilizationCapReached = 51011;\\n\\n    uint256 internal constant DexT1__HookReturnedFalse = 51012;\\n\\n    // Either user's config are not set or user is paused\\n    uint256 internal constant DexT1__UserSupplyInNotOn = 51013;\\n\\n    // Either user's config are not set or user is paused\\n    uint256 internal constant DexT1__UserDebtInNotOn = 51014;\\n\\n    // Thrown when contract asks for more token0 or token1 than what user's wants to give on deposit\\n    uint256 internal constant DexT1__AboveDepositMax = 51015;\\n\\n    uint256 internal constant DexT1__MsgValueLowOnDepositOrPayback = 51016;\\n\\n    uint256 internal constant DexT1__WithdrawLimitReached = 51017;\\n\\n    // Thrown when contract gives less token0 or token1 than what user's wants on withdraw\\n    uint256 internal constant DexT1__BelowWithdrawMin = 51018;\\n\\n    uint256 internal constant DexT1__DebtLimitReached = 51019;\\n\\n    // Thrown when contract gives less token0 or token1 than what user's wants on borrow\\n    uint256 internal constant DexT1__BelowBorrowMin = 51020;\\n\\n    // Thrown when contract asks for more token0 or token1 than what user's wants on payback\\n    uint256 internal constant DexT1__AbovePaybackMax = 51021;\\n\\n    uint256 internal constant DexT1__InvalidDepositAmts = 51022;\\n\\n    uint256 internal constant DexT1__DepositAmtsZero = 51023;\\n\\n    uint256 internal constant DexT1__SharesMintedLess = 51024;\\n\\n    uint256 internal constant DexT1__WithdrawalNotEnough = 51025;\\n\\n    uint256 internal constant DexT1__InvalidWithdrawAmts = 51026;\\n\\n    uint256 internal constant DexT1__WithdrawAmtsZero = 51027;\\n\\n    uint256 internal constant DexT1__WithdrawExcessSharesBurn = 51028;\\n\\n    uint256 internal constant DexT1__InvalidBorrowAmts = 51029;\\n\\n    uint256 internal constant DexT1__BorrowAmtsZero = 51030;\\n\\n    uint256 internal constant DexT1__BorrowExcessSharesMinted = 51031;\\n\\n    uint256 internal constant DexT1__PaybackAmtTooHigh = 51032;\\n\\n    uint256 internal constant DexT1__InvalidPaybackAmts = 51033;\\n\\n    uint256 internal constant DexT1__PaybackAmtsZero = 51034;\\n\\n    uint256 internal constant DexT1__PaybackSharedBurnedLess = 51035;\\n\\n    uint256 internal constant DexT1__NothingToArbitrage = 51036;\\n\\n    uint256 internal constant DexT1__MsgSenderNotLiquidity = 51037;\\n\\n    // On liquidity callback reentrancy bit should be on\\n    uint256 internal constant DexT1__ReentrancyBitShouldBeOn = 51038;\\n\\n    // Thrown is reentrancy is already on and someone tries to fetch oracle price. Should not be possible to this\\n    uint256 internal constant DexT1__OraclePriceFetchAlreadyEntered = 51039;\\n\\n    // Thrown when swap changes the current price by more than 5%\\n    uint256 internal constant DexT1__OracleUpdateHugeSwapDiff = 51040;\\n\\n    uint256 internal constant DexT1__Token0ShouldBeSmallerThanToken1 = 51041;\\n\\n    uint256 internal constant DexT1__OracleMappingOverflow = 51042;\\n\\n    /// @notice thrown if governance has paused the swapping & arbitrage so only perfect functions are usable\\n    uint256 internal constant DexT1__SwapAndArbitragePaused = 51043;\\n\\n    uint256 internal constant DexT1__ExceedsAmountInMax = 51044;\\n\\n    /// @notice thrown if amount in is too high or too low\\n    uint256 internal constant DexT1__SwapInLimitingAmounts = 51045;\\n\\n    /// @notice thrown if amount out is too high or too low\\n    uint256 internal constant DexT1__SwapOutLimitingAmounts = 51046;\\n\\n    uint256 internal constant DexT1__MintAmtOverflow = 51047;\\n\\n    uint256 internal constant DexT1__BurnAmtOverflow = 51048;\\n\\n    uint256 internal constant DexT1__LimitingAmountsSwapAndNonPerfectActions = 51049;\\n\\n    uint256 internal constant DexT1__InsufficientOracleData = 51050;\\n\\n    uint256 internal constant DexT1__SharesAmountInsufficient = 51051;\\n\\n    uint256 internal constant DexT1__CenterPriceOutOfRange = 51052;\\n\\n    uint256 internal constant DexT1__DebtReservesTooLow = 51053;\\n\\n    uint256 internal constant DexT1__SwapAndDepositTooLowOrTooHigh = 51054;\\n\\n    uint256 internal constant DexT1__WithdrawAndSwapTooLowOrTooHigh = 51055;\\n\\n    uint256 internal constant DexT1__BorrowAndSwapTooLowOrTooHigh = 51056;\\n\\n    uint256 internal constant DexT1__SwapAndPaybackTooLowOrTooHigh = 51057;\\n\\n    uint256 internal constant DexT1__InvalidImplementation = 51058;\\n\\n    uint256 internal constant DexT1__OnlyDelegateCallAllowed = 51059;\\n\\n    /***********************************|\\n    |            DEX Admin            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when pool is not initialized\\n    uint256 internal constant DexT1Admin__PoolNotInitialized = 52001;\\n\\n    uint256 internal constant DexT1Admin__SmartColIsAlreadyOn = 52002;\\n\\n    uint256 internal constant DexT1Admin__SmartDebtIsAlreadyOn = 52003;\\n\\n    /// @notice thrown when any of the configs value overflow the maximum limit\\n    uint256 internal constant DexT1Admin__ConfigOverflow = 52004;\\n\\n    uint256 internal constant DexT1Admin__AddressNotAContract = 52005;\\n\\n    uint256 internal constant DexT1Admin__InvalidParams = 52006;\\n\\n    uint256 internal constant DexT1Admin__UserNotDefined = 52007;\\n\\n    uint256 internal constant DexT1Admin__OnlyDelegateCallAllowed = 52008;\\n\\n    uint256 internal constant DexT1Admin__UnexpectedPoolState = 52009;\\n\\n    /// @notice thrown when trying to pause or unpause but user is already in the target pause state\\n    uint256 internal constant DexT1Admin__InvalidPauseToggle = 52009;\\n}\\n\",\"keccak256\":\"0x5101fb378fbaa0025bf444e9dee42ccbd6d6ec662e4371c4aa6d5afde3847b38\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/factory/deploymentHelpers/miniDeployer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Owned } from \\\"solmate/src/auth/Owned.sol\\\";\\n\\n/// @title MiniDeployer\\n/// @notice A contract that allows deployers to deploy any contract by passing the contract data in bytes\\n/// @dev The main objective of this contract is to avoid storing contract addresses in our protocols which requires 160 bits of storage\\n///      Instead, we can just store the nonce & deployment of this address to calculate the address realtime using \\\"AddressCalcs\\\" library\\ncontract MiniDeployer is Owned {\\n    /// @notice Thrown when an invalid operation is attempted\\n    error MiniDeployer__InvalidOperation();\\n\\n    /// @notice Emitted when a new contract is deployed\\n    event LogContractDeployed(address indexed contractAddress);\\n\\n    /// @notice Constructor to initialize the contract\\n    /// @param owner_ The address of the contract owner\\n    constructor(address owner_) Owned(owner_) {}\\n\\n    /// @notice Internal function to deploy a contract\\n    /// @param bytecode_ The bytecode of the contract to deploy\\n    /// @return address_ The address of the deployed contract\\n    /// @dev Uses inline assembly for efficient deployment\\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\\n        if (bytecode_.length == 0) {\\n            revert MiniDeployer__InvalidOperation();\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\\n        }\\n        if (address_ == address(0)) {\\n            revert MiniDeployer__InvalidOperation();\\n        }\\n    }\\n\\n    /// @notice Deploys a new contract\\n    /// @param contractCode_ The bytecode of the contract to deploy\\n    /// @return contractAddress_ The address of the deployed contract\\n    /// @dev Decrements the deployer's allowed deployments count if not the owner\\n    function deployContract(bytes calldata contractCode_) external onlyOwner returns (address contractAddress_) {\\n        contractAddress_ = _deploy(contractCode_);\\n\\n        emit LogContractDeployed(contractAddress_);\\n    }\\n}\\n\",\"keccak256\":\"0xe2477b35f959992a710b8eb589baa5d346799e524adaeb5a03abe5ac469b1ca3\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/factory/deploymentLogics/poolT1Logic.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { SSTORE2 } from \\\"solmate/src/utils/SSTORE2.sol\\\";\\n\\nimport { Error } from \\\"../../error.sol\\\";\\nimport { ErrorTypes } from \\\"../../errorTypes.sol\\\";\\nimport { IFluidDexFactory } from \\\"../../interfaces/iDexFactory.sol\\\";\\nimport { MiniDeployer } from \\\"../deploymentHelpers/miniDeployer.sol\\\";\\nimport { LiquiditySlotsLink } from \\\"../../../../libraries/liquiditySlotsLink.sol\\\";\\nimport { BytesSliceAndConcat } from \\\"../../../../libraries/bytesSliceAndConcat.sol\\\";\\n\\nimport { IFluidDexT1 } from \\\"../../interfaces/iDexT1.sol\\\";\\nimport { FluidDexT1Shift } from \\\"../../poolT1/coreModule/core/shift.sol\\\";\\nimport { FluidDexT1Admin } from \\\"../../poolT1/adminModule/main.sol\\\";\\nimport { FluidDexT1 } from \\\"../../poolT1/coreModule/core/main.sol\\\";\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n}\\n\\ncontract FluidDexT1DeploymentLogic is Error {\\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @dev SSTORE2 pointer for the PoolT1 creation code. Stored externally to reduce factory bytecode (in 2 parts)\\n    address internal immutable POOL_T1_CREATIONCODE_ADDRESS_1;\\n    address internal immutable POOL_T1_CREATIONCODE_ADDRESS_2;\\n\\n    /// @dev SSTORE2 pointers for the creation code of various operations contracts\\n    address internal immutable COL_OPERATIONS_CREATIONCODE_ADDRESS;\\n    address internal immutable DEBT_OPERATIONS_CREATIONCODE_ADDRESS;\\n    address internal immutable PERFECT_OPERATIONS_AND_SWAP_OUT_CREATIONCODE_ADDRESS;\\n\\n    /// @notice address of liquidity contract\\n    address public immutable LIQUIDITY;\\n\\n    /// @notice address of dexfactory contract\\n    address public immutable DEX_FACTORY;\\n\\n    /// @notice address of Admin implementation\\n    address public immutable ADMIN_IMPLEMENTATION;\\n\\n    /// @notice address of Shift implementation\\n    address public immutable SHIFT_IMPLEMENTATION;\\n\\n    /// @notice address of Deployer Contract\\n    address public immutable CONTRACT_DEPLOYER;\\n\\n    /// @notice address of MiniDeployer Contract\\n    MiniDeployer public immutable MINI_DEPLOYER;\\n\\n    /// @notice address of this contract\\n    address public immutable ADDRESS_THIS;\\n\\n    /// @notice Emitted when a new dexT1 is deployed.\\n    /// @param dex The address of the newly deployed dex.\\n    /// @param dexId The id of the newly deployed dex.\\n    /// @param supplyToken The address of the supply token.\\n    /// @param borrowToken The address of the borrow token.\\n    event DexT1Deployed(address indexed dex, uint256 dexId, address indexed supplyToken, address indexed borrowToken);\\n\\n    /// @dev                            Deploys a contract using the CREATE opcode with the provided bytecode (`bytecode_`).\\n    ///                                 This is an internal function, meant to be used within the contract to facilitate the deployment of other contracts.\\n    /// @param bytecode_                The bytecode of the contract to be deployed.\\n    /// @return address_                Returns the address of the deployed contract.\\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\\n        if (bytecode_.length == 0) {\\n            revert FluidDexError(ErrorTypes.DexFactory__InvalidOperation);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\\n        }\\n        if (address_ == address(0)) {\\n            revert FluidDexError(ErrorTypes.DexFactory__InvalidOperation);\\n        }\\n    }\\n\\n    constructor(\\n        address liquidity_,\\n        address dexFactory_,\\n        address contractDeployer_,\\n        address colOperations_,\\n        address debtOperations_,\\n        address perfectOperationsAndSwapOut_,\\n        address mainAddress1_,\\n        address mainAddress2_\\n    ) {\\n        LIQUIDITY = liquidity_;\\n        DEX_FACTORY = dexFactory_;\\n        CONTRACT_DEPLOYER = contractDeployer_;\\n\\n        \\n        POOL_T1_CREATIONCODE_ADDRESS_1 = mainAddress1_;\\n        POOL_T1_CREATIONCODE_ADDRESS_2 = mainAddress2_;\\n\\n        ADDRESS_THIS = address(this);\\n\\n        // Deploy mini deployer\\n        MINI_DEPLOYER = new MiniDeployer(DEX_FACTORY);\\n\\n        // Deploy admin implementation\\n        FluidDexT1Admin adminImplementation = new FluidDexT1Admin();\\n        ADMIN_IMPLEMENTATION = address(adminImplementation);\\n\\n        // Deploy shift implementation\\n        FluidDexT1Shift shiftImplementation = new FluidDexT1Shift(CONTRACT_DEPLOYER);\\n        SHIFT_IMPLEMENTATION = address(shiftImplementation);\\n\\n        COL_OPERATIONS_CREATIONCODE_ADDRESS = colOperations_;\\n        DEBT_OPERATIONS_CREATIONCODE_ADDRESS = debtOperations_;\\n        PERFECT_OPERATIONS_AND_SWAP_OUT_CREATIONCODE_ADDRESS = perfectOperationsAndSwapOut_;\\n    }\\n\\n    function dexT1(\\n        address token0_,\\n        address token1_,\\n        uint256 oracleMapping_\\n    ) external returns (bytes memory dexCreationBytecode_) {\\n        if (address(this) == ADDRESS_THIS) revert FluidDexError(ErrorTypes.DexFactory__OnlyDelegateCallAllowed);\\n\\n        if (token0_ == token1_) revert FluidDexError(ErrorTypes.DexFactory__SameTokenNotAllowed);\\n        if (token0_ > token1_) revert FluidDexError(ErrorTypes.DexFactory__TokenConfigNotProper);\\n\\n        IFluidDexT1.ConstantViews memory constants_;\\n        constants_.liquidity = LIQUIDITY;\\n        constants_.factory = address(this);\\n        constants_.implementations.shift = SHIFT_IMPLEMENTATION;\\n        constants_.deployerContract = CONTRACT_DEPLOYER;\\n        constants_.token0 = token0_;\\n        constants_.token1 = token1_;\\n        constants_.dexId = IFluidDexFactory(address(this)).totalDexes();\\n        constants_.oracleMapping = oracleMapping_;\\n\\n        address dex_ = IFluidDexFactory(address(this)).getDexAddress(constants_.dexId);\\n\\n        constants_ = _calculateLiquidityDexSlots(constants_, dex_);\\n\\n        // Deploy perfect operations and oracle implementation\\n        address perfectOperationsAndOracle_ = MINI_DEPLOYER.deployContract(\\n            abi.encodePacked(perfectOperationsCreationCode(), abi.encode(constants_))\\n        );\\n\\n        // Deploy col operations implementation through mini deployer\\n        address colOperations_ = MINI_DEPLOYER.deployContract(\\n            abi.encodePacked(colOperationsCreationCode(), abi.encode(constants_))\\n        );\\n\\n        // Deploy debt operations implementation\\n        address debtOperations_ = MINI_DEPLOYER.deployContract(\\n            abi.encodePacked(debtOperationsCreationCode(), abi.encode(constants_))\\n        );\\n\\n        constants_.implementations.admin = ADMIN_IMPLEMENTATION;\\n        constants_.implementations.perfectOperationsAndOracle = perfectOperationsAndOracle_;\\n        constants_.implementations.colOperations = colOperations_;\\n        constants_.implementations.debtOperations = debtOperations_;\\n\\n        dexCreationBytecode_ = abi.encodePacked(dexT1CreationBytecode(), abi.encode(constants_));\\n\\n        emit DexT1Deployed(dex_, constants_.dexId, token0_, token1_);\\n\\n        return dexCreationBytecode_;\\n    }\\n\\n    /// @notice returns the stored DexT1 creation bytecode\\n    function dexT1CreationBytecode() public view returns (bytes memory) {\\n        return BytesSliceAndConcat.bytesConcat(SSTORE2.read(POOL_T1_CREATIONCODE_ADDRESS_1), SSTORE2.read(POOL_T1_CREATIONCODE_ADDRESS_2));\\n    }\\n\\n    /// @dev Retrieves the creation code for the FluidDexT1OperationsCol contract\\n    function colOperationsCreationCode() public view returns (bytes memory) {\\n        return SSTORE2.read(COL_OPERATIONS_CREATIONCODE_ADDRESS);\\n    }\\n\\n    /// @dev Retrieves the creation code for the FluidDexT1OperationsDebt contract\\n    function debtOperationsCreationCode() public view returns (bytes memory) {\\n        return SSTORE2.read(DEBT_OPERATIONS_CREATIONCODE_ADDRESS);\\n    }\\n\\n    /// @dev Retrieves the creation code for the FluidDexT1PerfectOperations contract\\n    function perfectOperationsCreationCode() public view returns (bytes memory) {\\n        return SSTORE2.read(PERFECT_OPERATIONS_AND_SWAP_OUT_CREATIONCODE_ADDRESS);\\n    }\\n\\n    /// @dev                          Calculates the liquidity dex slots for the given supply token, borrow token, and dex (`dex_`).\\n    /// @param constants_             Constants struct as used in Dex T1\\n    /// @param dex_                   The address of the dex.\\n    /// @return liquidityDexSlots_    Returns the calculated liquidity dex slots set in the `IFluidDexT1.ConstantViews` struct.\\n    function _calculateLiquidityDexSlots(\\n        IFluidDexT1.ConstantViews memory constants_,\\n        address dex_\\n    ) private pure returns (IFluidDexT1.ConstantViews memory) {\\n        constants_.supplyToken0Slot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\\n            LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\\n            dex_,\\n            constants_.token0\\n        );\\n        constants_.borrowToken0Slot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\\n            LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\\n            dex_,\\n            constants_.token0\\n        );\\n        constants_.supplyToken1Slot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\\n            LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\\n            dex_,\\n            constants_.token1\\n        );\\n        constants_.borrowToken1Slot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\\n            LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\\n            dex_,\\n            constants_.token1\\n        );\\n        constants_.exchangePriceToken0Slot = LiquiditySlotsLink.calculateMappingStorageSlot(\\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\\n            constants_.token0\\n        );\\n        constants_.exchangePriceToken1Slot = LiquiditySlotsLink.calculateMappingStorageSlot(\\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\\n            constants_.token1\\n        );\\n\\n        return constants_;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x76991172d45b228db129af1157c900d894065038a4e56073409d4f9cab6cbfb2\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/interfaces/iDexFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IFluidDexFactory {\\n    /// @notice Global auth is auth for all dexes\\n    function isGlobalAuth(address auth_) external view returns (bool);\\n\\n    /// @notice Dex auth is auth for a specific dex\\n    function isDexAuth(address vault_, address auth_) external view returns (bool);\\n\\n    /// @notice Total dexes deployed.\\n    function totalDexes() external view returns (uint256);\\n\\n    /// @notice Compute dexAddress\\n    function getDexAddress(uint256 vaultId) external view returns (address);\\n\\n    /// @notice read uint256 `result_` for a storage `slot_` key\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n}\\n\",\"keccak256\":\"0xe6e7efed6dfd3a58f17fa24e21d0acda2bf7549d60b88ed8e9a0d6bd0bfb2d94\",\"license\":\"MIT\"},\"contracts/protocols/dex/interfaces/iDexT1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IFluidDexT1 {\\n    /// @notice returns the dex id\\n    function DEX_ID() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct Implementations {\\n        address shift;\\n        address admin;\\n        address colOperations;\\n        address debtOperations;\\n        address perfectOperationsAndOracle;\\n    }\\n\\n    struct ConstantViews {\\n        uint256 dexId;\\n        address liquidity;\\n        address factory;\\n        Implementations implementations;\\n        address deployerContract;\\n        address token0;\\n        address token1;\\n        bytes32 supplyToken0Slot;\\n        bytes32 borrowToken0Slot;\\n        bytes32 supplyToken1Slot;\\n        bytes32 borrowToken1Slot;\\n        bytes32 exchangePriceToken0Slot;\\n        bytes32 exchangePriceToken1Slot;\\n        uint256 oracleMapping;\\n    }\\n\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    struct ConstantViews2 {\\n        uint token0NumeratorPrecision;\\n        uint token0DenominatorPrecision;\\n        uint token1NumeratorPrecision;\\n        uint token1DenominatorPrecision;\\n    }\\n\\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\\n\\n    function swapIn(\\n        bool swap0to1_,\\n        uint256 amountIn_,\\n        uint256 amountOutMin_,\\n        address to_\\n    ) external payable returns (uint256 amountOut_);\\n\\n    function swapOut(\\n        bool swap0to1_,\\n        uint256 amountOut_,\\n        uint256 amountInMax_,\\n        address to_\\n    ) external payable returns (uint256 amountIn_);\\n\\n    function depositPerfect(\\n        uint shares_,\\n        uint maxToken0Deposit_,\\n        uint maxToken1Deposit_,\\n        bool estimate_\\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\\n\\n    function withdrawPerfect(\\n        uint shares_,\\n        uint minToken0Withdraw_,\\n        uint minToken1Withdraw_,\\n        bool estimate_\\n    ) external returns (uint token0Amt_, uint token1Amt_);\\n\\n    function borrowPerfect(\\n        uint shares_,\\n        uint minToken0Borrow_,\\n        uint minToken1Borrow_,\\n        bool estimate_\\n    ) external returns (uint token0Amt_, uint token1Amt_);\\n\\n    function paybackPerfect(\\n        uint shares_,\\n        uint maxToken0Payback_,\\n        uint maxToken1Payback_,\\n        bool estimate_\\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\\n\\n    function deposit(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint minSharesAmt_,\\n        bool estimate_\\n    ) external payable returns (uint shares_);\\n\\n    function withdraw(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint maxSharesAmt_,\\n        bool estimate_\\n    ) external returns (uint shares_);\\n\\n    function borrow(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint maxSharesAmt_,\\n        bool estimate_\\n    ) external returns (uint shares_);\\n\\n    function payback(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint minSharesAmt_,\\n        bool estimate_\\n    ) external payable returns (uint shares_);\\n\\n    function withdrawPerfectInOneToken(\\n        uint shares_,\\n        uint minToken0_,\\n        uint minToken1_,\\n        bool estimate_\\n    ) external returns (uint withdrawAmt_);\\n\\n    function paybackPerfectInOneToken(\\n        uint shares_,\\n        uint maxToken0_,\\n        uint maxToken1_,\\n        bool estimate_\\n    ) external payable returns (uint paybackAmt_);\\n\\n    struct Oracle {\\n        uint twap1by0; // TWAP price\\n        uint lowestPrice1by0; // lowest price point\\n        uint highestPrice1by0; // highest price point\\n        uint twap0by1; // TWAP price\\n        uint lowestPrice0by1; // lowest price point\\n        uint highestPrice0by1; // highest price point\\n    }\\n\\n    function oraclePrice(uint[] memory secondsAgos_) external returns (Oracle[] memory twaps_, uint currentPrice_);\\n\\n    function getPricesAndExchangePrices() external;\\n}\\n\",\"keccak256\":\"0xfe8d0e1d475cd8648ae024b373e92d380e71e7d5951294281d01f8cad42c0209\",\"license\":\"MIT\"},\"contracts/protocols/dex/poolT1/adminModule/events.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Structs } from \\\"./structs.sol\\\";\\n\\nabstract contract Events is Structs {\\n    /// @dev Emitted when smart collateral is turned on\\n    /// @param token0Amt The amount of token0 used for smart collateral\\n    event LogTurnOnSmartCol(uint token0Amt);\\n\\n    /// @dev Emitted when smart debt is turned on\\n    /// @param token0Amt The amount of token0 used for smart debt\\n    event LogTurnOnSmartDebt(uint token0Amt);\\n\\n    /// @dev Emitted when fee and revenue cut are updated\\n    /// @param fee The new fee value\\n    /// @param revenueCut The new revenue cut value\\n    event LogUpdateFeeAndRevenueCut(uint fee, uint revenueCut);\\n\\n    /// @dev Emitted when range percents are updated\\n    /// @param upperPercent The new upper percent value\\n    /// @param lowerPercent The new lower percent value\\n    /// @param shiftTime The new shift time value\\n    event LogUpdateRangePercents(uint upperPercent, uint lowerPercent, uint shiftTime);\\n\\n    /// @dev Emitted when threshold percent is updated\\n    /// @param upperThresholdPercent The new upper threshold percent value\\n    /// @param lowerThresholdPercent The new lower threshold percent value\\n    /// @param thresholdShiftTime The new threshold shift time value\\n    /// @param shiftTime The new shift time value\\n    event LogUpdateThresholdPercent(\\n        uint upperThresholdPercent,\\n        uint lowerThresholdPercent,\\n        uint thresholdShiftTime,\\n        uint shiftTime\\n    );\\n\\n    /// @dev Emitted when center price address is updated\\n    /// @param centerPriceAddress The new center price address nonce\\n    /// @param percent The new percent value\\n    /// @param time The new time value\\n    event LogUpdateCenterPriceAddress(uint centerPriceAddress, uint percent, uint time);\\n\\n    /// @dev Emitted when hook address is updated\\n    /// @param hookAddress The new hook address nonce\\n    event LogUpdateHookAddress(uint hookAddress);\\n\\n    /// @dev Emitted when center price limits are updated\\n    /// @param maxCenterPrice The new maximum center price\\n    /// @param minCenterPrice The new minimum center price\\n    event LogUpdateCenterPriceLimits(uint maxCenterPrice, uint minCenterPrice);\\n\\n    /// @dev Emitted when utilization limit is updated\\n    /// @param token0UtilizationLimit The new utilization limit for token0\\n    /// @param token1UtilizationLimit The new utilization limit for token1\\n    event LogUpdateUtilizationLimit(uint token0UtilizationLimit, uint token1UtilizationLimit);\\n\\n    /// @dev Emitted when user supply configs are updated\\n    /// @param userSupplyConfigs The array of updated user supply configurations\\n    event LogUpdateUserSupplyConfigs(UserSupplyConfig[] userSupplyConfigs);\\n\\n    /// @dev Emitted when user borrow configs are updated\\n    /// @param userBorrowConfigs The array of updated user borrow configurations\\n    event LogUpdateUserBorrowConfigs(UserBorrowConfig[] userBorrowConfigs);\\n\\n    /// @dev Emitted when a user is paused\\n    /// @param user The address of the paused user\\n    /// @param pauseSupply Whether supply operations are paused\\n    /// @param pauseBorrow Whether borrow operations are paused\\n    event LogPauseUser(address user, bool pauseSupply, bool pauseBorrow);\\n\\n    /// @dev Emitted when a user is unpaused\\n    /// @param user The address of the unpaused user\\n    /// @param unpauseSupply Whether supply operations are unpaused\\n    /// @param unpauseBorrow Whether borrow operations are unpaused\\n    event LogUnpauseUser(address user, bool unpauseSupply, bool unpauseBorrow);\\n\\n    /// @notice Emitted when the pool configuration is initialized\\n    /// @param smartCol Whether smart collateral is enabled\\n    /// @param smartDebt Whether smart debt is enabled\\n    /// @param token0ColAmt The amount of token0 collateral\\n    /// @param token0DebtAmt The amount of token0 debt\\n    /// @param fee The fee percentage (in 4 decimals, 10000 = 1%)\\n    /// @param revenueCut The revenue cut percentage (in 4 decimals, 100000 = 10%)\\n    /// @param centerPriceAddress The nonce for the center price contract address\\n    /// @param hookAddress The nonce for the hook contract address\\n    event LogInitializePoolConfig(\\n        bool smartCol,\\n        bool smartDebt,\\n        uint token0ColAmt,\\n        uint token0DebtAmt,\\n        uint fee,\\n        uint revenueCut,\\n        uint centerPriceAddress,\\n        uint hookAddress\\n    );\\n\\n    /// @notice Emitted when the price parameters are initialized\\n    /// @param upperPercent The upper range percent (in 4 decimals, 10000 = 1%)\\n    /// @param lowerPercent The lower range percent (in 4 decimals, 10000 = 1%)\\n    /// @param upperShiftThreshold The upper shift threshold (in 4 decimals, 10000 = 1%)\\n    /// @param lowerShiftThreshold The lower shift threshold (in 4 decimals, 10000 = 1%)\\n    /// @param thresholdShiftTime The time for threshold shift (in seconds)\\n    /// @param maxCenterPrice The maximum center price\\n    /// @param minCenterPrice The minimum center price\\n    event LogInitializePriceParams(\\n        uint upperPercent,\\n        uint lowerPercent,\\n        uint upperShiftThreshold,\\n        uint lowerShiftThreshold,\\n        uint thresholdShiftTime,\\n        uint maxCenterPrice,\\n        uint minCenterPrice\\n    );\\n\\n    /// @dev Emitted when swap and arbitrage are paused\\n    event LogPauseSwapAndArbitrage();\\n\\n    /// @dev Emitted when swap and arbitrage are unpaused\\n    event LogUnpauseSwapAndArbitrage();\\n\\n    /// @notice emitted when user withdrawal limit is updated\\n    event LogUpdateUserWithdrawalLimit(address user, uint256 newLimit);\\n\\n    /// @dev Emitted when funds are rescued\\n    /// @param token The address of the token\\n    event LogRescueFunds(address token);\\n}\\n\",\"keccak256\":\"0x4aac6eb56a51fe4a7f4d6e16732e6f84d597fcc19ff66e2ce998a72ac9c0e7cb\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/poolT1/adminModule/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { Variables } from \\\"../common/variables.sol\\\";\\nimport { Events } from \\\"./events.sol\\\";\\nimport { ErrorTypes } from \\\"../../errorTypes.sol\\\";\\nimport { Error } from \\\"../../error.sol\\\";\\nimport { BigMathMinified } from \\\"../../../../libraries/bigMathMinified.sol\\\";\\nimport { ConstantVariables } from \\\"../common/constantVariables.sol\\\";\\nimport { Structs } from \\\"./structs.sol\\\";\\nimport { IFluidDexT1 } from \\\"../../interfaces/iDexT1.sol\\\";\\nimport { IFluidLiquidity } from \\\"../../../../liquidity/interfaces/iLiquidity.sol\\\";\\nimport { SafeTransfer } from \\\"../../../../libraries/safeTransfer.sol\\\";\\nimport { AddressCalcs } from \\\"../../../../libraries/addressCalcs.sol\\\";\\nimport { DexSlotsLink } from \\\"../../../../libraries/dexSlotsLink.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @notice Fluid Dex protocol Admin Module contract.\\n///         Implements admin related methods to set pool configs\\n///         Methods are limited to be called via delegateCall only. Dex CoreModule (\\\"DexT1\\\" contract)\\n///         is expected to call the methods implemented here after checking the msg.sender is authorized.\\ncontract FluidDexT1Admin is ConstantVariables, Variables, Structs, Events, Error {\\n    using BigMathMinified for uint256;\\n\\n    address private immutable ADDRESS_THIS;\\n\\n    constructor() {\\n        ADDRESS_THIS = address(this);\\n    }\\n\\n    modifier _onlyDelegateCall() {\\n        // also indirectly checked by `_check` because pool can never be initialized as long as the initialize method\\n        // is delegate call only, but just to be sure on Admin logic we add the modifier everywhere nonetheless.\\n        if (address(this) == ADDRESS_THIS) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__OnlyDelegateCallAllowed);\\n        }\\n        _;\\n    }\\n\\n    modifier _check() {\\n        if ((dexVariables2 & X3) == 0) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__PoolNotInitialized);\\n        }\\n        _;\\n    }\\n\\n    /// @dev checks that `value_` address is a contract (which includes address zero check) or native address\\n    function _checkIsContractOrNativeAddress(address value_) internal view {\\n        if (value_.code.length == 0 && value_ != NATIVE_TOKEN) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__AddressNotAContract);\\n        }\\n    }\\n\\n    /// @dev checks that `value_` address is a contract (which includes address zero check)\\n    function _checkIsContract(address value_) internal view {\\n        if (value_.code.length == 0) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__AddressNotAContract);\\n        }\\n    }\\n\\n    function turnOnSmartCol(uint token0Amt_) public payable _check _onlyDelegateCall {\\n        if (dexVariables2 & 1 == 1) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__SmartColIsAlreadyOn);\\n        }\\n        uint centerPrice_ = (dexVariables >> 81) & X40;\\n        centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\\n        _turnOnSmartCol(token0Amt_, centerPrice_);\\n\\n        dexVariables2 = dexVariables2 | 1;\\n\\n        emit LogTurnOnSmartCol(token0Amt_);\\n    }\\n\\n    function _turnOnSmartCol(uint token0Amt_, uint centerPrice_) internal {\\n        IFluidDexT1.ConstantViews memory c_ = IFluidDexT1(address(this)).constantsView();\\n        IFluidDexT1.ConstantViews2 memory c2_ = IFluidDexT1(address(this)).constantsView2();\\n\\n        uint token0AmtAdjusted_ = (token0Amt_ * c2_.token0NumeratorPrecision) / c2_.token0DenominatorPrecision;\\n\\n        uint token1AmtAdjusted_ = (centerPrice_ * token0AmtAdjusted_) / 1e27;\\n\\n        uint token1Amt_ = (token1AmtAdjusted_ * c2_.token1DenominatorPrecision) / c2_.token1NumeratorPrecision;\\n\\n        IFluidLiquidity liquidity_ = IFluidLiquidity(c_.liquidity);\\n\\n        // if both tokens are not native token and msg.value is sent, revert\\n        if (msg.value > 0 && c_.token0 != NATIVE_TOKEN && c_.token1 != NATIVE_TOKEN) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\\n        }\\n\\n        address token_;\\n        uint amt_;\\n        for (uint i = 0; i < 2; i++) {\\n            if (i == 0) {\\n                token_ = c_.token0;\\n                amt_ = token0Amt_;\\n            } else {\\n                token_ = c_.token1;\\n                amt_ = token1Amt_;\\n            }\\n            if (token_ == NATIVE_TOKEN) {\\n                if (msg.value > amt_) {\\n                    SafeTransfer.safeTransferNative(msg.sender, msg.value - amt_);\\n                } else if (msg.value < amt_) {\\n                    revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\\n                }\\n                // deposit\\n                liquidity_.operate{ value: amt_ }(token_, int(amt_), 0, address(0), address(0), abi.encode(msg.sender));\\n            } else {\\n                // deposit\\n                liquidity_.operate(token_, int(amt_), 0, address(0), address(0), abi.encode(msg.sender));\\n            }\\n        }\\n\\n        // minting shares according to whatever tokenAmt is bigger\\n        // adding shares on storage but not adding shares for any user, hence locking these shares forever\\n        // adjusted amounts are in 12 decimals, making shares in 18 decimals\\n        _totalSupplyShares = (token0AmtAdjusted_ > token1AmtAdjusted_)\\n            ? token0AmtAdjusted_ * 10 ** (18 - TOKENS_DECIMALS_PRECISION)\\n            : token1AmtAdjusted_ * 10 ** (18 - TOKENS_DECIMALS_PRECISION);\\n\\n        if (_totalSupplyShares < NINE_DECIMALS) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__UnexpectedPoolState);\\n        }\\n    }\\n\\n    function turnOnSmartDebt(uint token0Amt_) public _check _onlyDelegateCall {\\n        if (dexVariables2 & 2 == 2) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__SmartDebtIsAlreadyOn);\\n        }\\n        uint centerPrice_ = (dexVariables >> 81) & X40;\\n        centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\\n        _turnOnSmartDebt(token0Amt_, centerPrice_);\\n\\n        dexVariables2 = dexVariables2 | 2;\\n\\n        emit LogTurnOnSmartDebt(token0Amt_);\\n    }\\n\\n    /// @dev Can only borrow if DEX pool address borrow config is added in Liquidity Layer for both the tokens else Liquidity Layer will revert\\n    /// governance will have access to _turnOnSmartDebt, technically governance here can borrow as much as limits are set\\n    /// so it's governance responsibility that it borrows small amount between $100 - $10,000\\n    /// Borrowing in 50:50 ratio (doesn't matter if pool configuration is set to 20:80, 30:70, etc, external swap will arbitrage & balance the pool)\\n    function _turnOnSmartDebt(uint token0Amt_, uint centerPrice_) internal {\\n        IFluidDexT1.ConstantViews memory c_ = IFluidDexT1(address(this)).constantsView();\\n        IFluidDexT1.ConstantViews2 memory c2_ = IFluidDexT1(address(this)).constantsView2();\\n\\n        uint token0AmtAdjusted_ = (token0Amt_ * c2_.token0NumeratorPrecision) / c2_.token0DenominatorPrecision;\\n\\n        uint token1AmtAdjusted_ = (centerPrice_ * token0AmtAdjusted_) / 1e27;\\n\\n        uint token1Amt_ = (token1AmtAdjusted_ * c2_.token1DenominatorPrecision) / c2_.token1NumeratorPrecision;\\n\\n        IFluidLiquidity liquidity_ = IFluidLiquidity(c_.liquidity);\\n\\n        liquidity_.operate(c_.token0, 0, int(token0Amt_), address(0), TEAM_MULTISIG, new bytes(0));\\n        liquidity_.operate(c_.token1, 0, int(token1Amt_), address(0), TEAM_MULTISIG, new bytes(0));\\n\\n        // minting shares as whatever tokenAmt is bigger\\n        // adding shares on storage but not adding shares for any user, hence locking these shares forever\\n        // adjusted amounts are in 12 decimals, making shares in 18 decimals\\n        _totalBorrowShares = (token0AmtAdjusted_ > token1AmtAdjusted_)\\n            ? token0AmtAdjusted_ * 10 ** (18 - TOKENS_DECIMALS_PRECISION)\\n            : token1AmtAdjusted_ * 10 ** (18 - TOKENS_DECIMALS_PRECISION);\\n\\n        if (_totalBorrowShares < NINE_DECIMALS) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__UnexpectedPoolState);\\n        }\\n    }\\n\\n    /// @param fee_ in 4 decimals, 10000 = 1%\\n    /// @param revenueCut_ in 4 decimals, 100000 = 10%, 10% cut on fee_, so if fee is 1% and cut is 10% then cut in swap amount will be 10% of 1% = 0.1%\\n    function updateFeeAndRevenueCut(uint fee_, uint revenueCut_) public _check _onlyDelegateCall {\\n        // cut is an integer in storage slot which is more than enough\\n        // but from UI we are allowing to send in 4 decimals to maintain consistency & avoid human error in future\\n        if (revenueCut_ != 0 && revenueCut_ < FOUR_DECIMALS) {\\n            // human input error. should send 0 for wanting 0, not 0 because of precision reduction.\\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\\n        }\\n\\n        revenueCut_ = revenueCut_ / FOUR_DECIMALS;\\n\\n        if (fee_ > FIVE_DECIMALS || revenueCut_ > TWO_DECIMALS) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\\n        }\\n\\n        dexVariables2 =\\n            (dexVariables2 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC000003) |\\n            (fee_ << 2) |\\n            (revenueCut_ << 19);\\n\\n        emit LogUpdateFeeAndRevenueCut(fee_, revenueCut_ * FOUR_DECIMALS);\\n    }\\n\\n    /// @param upperPercent_ in 4 decimals, 10000 = 1%\\n    /// @param lowerPercent_ in 4 decimals, 10000 = 1%\\n    /// @param shiftTime_ in secs, in how much time the upper percent configs change should be fully done\\n    function updateRangePercents(\\n        uint upperPercent_,\\n        uint lowerPercent_,\\n        uint shiftTime_\\n    ) public _check _onlyDelegateCall {\\n        uint dexVariables2_ = dexVariables2;\\n        if (\\n            (upperPercent_ > (SIX_DECIMALS - FOUR_DECIMALS)) || // capping range to 99%.\\n            (lowerPercent_ > (SIX_DECIMALS - FOUR_DECIMALS)) || // capping range to 99%.\\n            (upperPercent_ == 0) ||\\n            (lowerPercent_ == 0) ||\\n            (shiftTime_ > X20) ||\\n            (((dexVariables2_ >> 26) & 1) == 1) // if last shift is still active then don't allow a newer shift\\n        ) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\\n        }\\n\\n        dexVariables2 =\\n            (dexVariables2_ & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF80000000003FFFFFF) |\\n            (uint((shiftTime_ > 0) ? 1 : 0) << 26) |\\n            (upperPercent_ << 27) |\\n            (lowerPercent_ << 47);\\n\\n        uint oldUpperPercent_ = (dexVariables2_ >> 27) & X20;\\n        uint oldLowerPercent_ = (dexVariables2_ >> 47) & X20;\\n\\n        if (shiftTime_ > 0) {\\n            _rangeShift = uint128(\\n                oldUpperPercent_ | (oldLowerPercent_ << 20) | (shiftTime_ << 40) | (block.timestamp << 60)\\n            );\\n        }\\n        // Note _rangeShift is reset when the previous shift is fully completed, which is forced to have happened through if check above\\n\\n        emit LogUpdateRangePercents(upperPercent_, lowerPercent_, shiftTime_);\\n    }\\n\\n    /// @param upperThresholdPercent_ in 4 decimals, 10000 = 1%\\n    /// @param lowerThresholdPercent_ in 4 decimals, 10000 = 1%\\n    /// @param thresholdShiftTime_ in secs, in how much time the threshold percent should take to shift the ranges\\n    /// @param shiftTime_ in secs, in how much time the upper config changes should be fully done.\\n    function updateThresholdPercent(\\n        uint upperThresholdPercent_,\\n        uint lowerThresholdPercent_,\\n        uint thresholdShiftTime_,\\n        uint shiftTime_\\n    ) public _check _onlyDelegateCall {\\n        uint dexVariables2_ = dexVariables2;\\n\\n        // thresholds are with 0.1% precision, hence removing last 3 decimals.\\n        // we are allowing to send in 4 decimals to maintain consistency with other params\\n        upperThresholdPercent_ = upperThresholdPercent_ / THREE_DECIMALS;\\n        lowerThresholdPercent_ = lowerThresholdPercent_ / THREE_DECIMALS;\\n        if (\\n            (upperThresholdPercent_ > THREE_DECIMALS) ||\\n            (lowerThresholdPercent_ > THREE_DECIMALS) ||\\n            (thresholdShiftTime_ == 0) ||\\n            (thresholdShiftTime_ > X24) ||\\n            (upperThresholdPercent_ == 0) ||\\n            (lowerThresholdPercent_ == 0) ||\\n            (shiftTime_ > X20) ||\\n            (((dexVariables2_ >> 67) & 1) == 1) // if last shift is still active then don't allow a newer shift\\n        ) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\\n        }\\n\\n        dexVariables2 =\\n            (dexVariables2_ & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000007FFFFFFFFFFFFFFFF) |\\n            (uint((shiftTime_ > 0) ? 1 : 0) << 67) |\\n            (upperThresholdPercent_ << 68) |\\n            (lowerThresholdPercent_ << 78) |\\n            (thresholdShiftTime_ << 88);\\n\\n        uint oldUpperThresholdPercent_ = (dexVariables2_ >> 68) & X10;\\n        uint oldLowerThresholdPercent_ = (dexVariables2_ >> 78) & X10;\\n        uint oldThresholdTime_ = (dexVariables2_ >> 88) & X24;\\n\\n        if (shiftTime_ > 0) {\\n            _thresholdShift = uint128(\\n                oldUpperThresholdPercent_ |\\n                    (oldLowerThresholdPercent_ << 20) |\\n                    (shiftTime_ << 40) |\\n                    (block.timestamp << 60) |\\n                    (oldThresholdTime_ << 93)\\n            );\\n        }\\n        // Note _thresholdShift is reset when the previous shift is fully completed, which is forced to have happened through if check above\\n\\n        emit LogUpdateThresholdPercent(\\n            upperThresholdPercent_ * THREE_DECIMALS,\\n            lowerThresholdPercent_ * THREE_DECIMALS,\\n            thresholdShiftTime_,\\n            shiftTime_\\n        );\\n    }\\n\\n    /// @dev we are storing uint nonce from which we will calculate the contract address, to store an address we need 160 bits\\n    /// which is quite a lot of storage slot\\n    /// @param centerPriceAddress_ nonce < X30, this nonce will be used to calculate contract address\\n    function updateCenterPriceAddress(\\n        uint centerPriceAddress_,\\n        uint percent_,\\n        uint time_\\n    ) public _check _onlyDelegateCall {\\n        if ((centerPriceAddress_ > X30) || (percent_ == 0) || (percent_ > X20) || (time_ == 0) || (time_ > X20)) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\\n        }\\n\\n        if (centerPriceAddress_ > 0) {\\n            IFluidDexT1.ConstantViews memory c_ = IFluidDexT1(address(this)).constantsView();\\n            address centerPrice_ = AddressCalcs.addressCalc(c_.deployerContract, centerPriceAddress_);\\n            _checkIsContract(centerPrice_);\\n            // note: if address is made 0 then as well in the last swap currentPrice is updated on storage, so code will start using that automatically\\n            dexVariables2 =\\n                (dexVariables2 & 0xFeFFFFFFFFFFFFFFFFFFFFFFFFFFC0000000FFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n                (centerPriceAddress_ << 112) |\\n                (uint(1) << 248);\\n\\n            _centerPriceShift = block.timestamp | (percent_ << 33) | (time_ << 53);\\n        } else {\\n            dexVariables2 = (dexVariables2 & 0xFeFFFFFFFFFFFFFFFFFFFFFFFFFFC0000000FFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n            _centerPriceShift = 0;\\n        }\\n\\n        emit LogUpdateCenterPriceAddress(centerPriceAddress_, percent_, time_);\\n    }\\n\\n    /// @dev we are storing uint nonce from which we will calculate the contract address, to store an address we need 160 bits\\n    /// which is quite a lot of storage slot\\n    /// @param hookAddress_ nonce < X30, this nonce will be used to calculate contract address\\n    function updateHookAddress(uint hookAddress_) public _check _onlyDelegateCall {\\n        if (hookAddress_ > X30) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\\n        }\\n\\n        if (hookAddress_ > 0) {\\n            IFluidDexT1.ConstantViews memory c_ = IFluidDexT1(address(this)).constantsView();\\n            address hook_ = AddressCalcs.addressCalc(c_.deployerContract, hookAddress_);\\n            _checkIsContract(hook_);\\n        }\\n\\n        dexVariables2 =\\n            (dexVariables2 & 0xFFFFFFFFFFFFFFFFFFFFF00000003FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n            (hookAddress_ << 142);\\n\\n        emit LogUpdateHookAddress(hookAddress_);\\n    }\\n\\n    function updateCenterPriceLimits(uint maxCenterPrice_, uint minCenterPrice_) public _check _onlyDelegateCall {\\n        uint centerPrice_ = (dexVariables >> 81) & X40;\\n        centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (\\n            (maxCenterPrice_ <= minCenterPrice_) ||\\n            (centerPrice_ <= minCenterPrice_) ||\\n            (centerPrice_ >= maxCenterPrice_) ||\\n            (minCenterPrice_ == 0)\\n        ) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\\n        }\\n\\n        dexVariables2 =\\n            (dexVariables2 & 0xFFFFFFF00000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n            (maxCenterPrice_.toBigNumber(20, 8, BigMathMinified.ROUND_UP) << 172) |\\n            (minCenterPrice_.toBigNumber(20, 8, BigMathMinified.ROUND_DOWN) << 200);\\n\\n        emit LogUpdateCenterPriceLimits(maxCenterPrice_, minCenterPrice_);\\n    }\\n\\n    function updateUtilizationLimit(\\n        uint token0UtilizationLimit_,\\n        uint token1UtilizationLimit_\\n    ) public _check _onlyDelegateCall {\\n        if (\\n            (token0UtilizationLimit_ != 0 && token0UtilizationLimit_ < THREE_DECIMALS) ||\\n            (token1UtilizationLimit_ != 0 && token1UtilizationLimit_ < THREE_DECIMALS)\\n        ) {\\n            // human input error. should send 0 for wanting 0, not 0 because of precision reduction.\\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\\n        }\\n\\n        token0UtilizationLimit_ = token0UtilizationLimit_ / THREE_DECIMALS;\\n        token1UtilizationLimit_ = token1UtilizationLimit_ / THREE_DECIMALS;\\n\\n        if (token0UtilizationLimit_ > THREE_DECIMALS || token1UtilizationLimit_ > THREE_DECIMALS) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\\n        }\\n\\n        dexVariables2 =\\n            (dexVariables2 & 0xFF00000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n            (token0UtilizationLimit_ << 228) |\\n            (token1UtilizationLimit_ << 238);\\n\\n        emit LogUpdateUtilizationLimit(\\n            token0UtilizationLimit_ * THREE_DECIMALS,\\n            token1UtilizationLimit_ * THREE_DECIMALS\\n        );\\n    }\\n\\n    function updateUserSupplyConfigs(UserSupplyConfig[] memory userSupplyConfigs_) external _check _onlyDelegateCall {\\n        uint256 userSupplyData_;\\n\\n        for (uint256 i; i < userSupplyConfigs_.length; ) {\\n            _checkIsContract(userSupplyConfigs_[i].user);\\n            if (userSupplyConfigs_[i].expandDuration == 0) {\\n                // can not set expand duration to 0 as that could cause a division by 0 in LiquidityCalcs.\\n                // having expand duration as 0 is anyway not an expected config so removing the possibility for that.\\n                // if no expansion is wanted, simply set expandDuration to 1 and expandPercent to 0.\\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\\n            }\\n            if (userSupplyConfigs_[i].expandPercent > FOUR_DECIMALS) {\\n                revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\\n            }\\n            if (userSupplyConfigs_[i].expandDuration > X24) {\\n                // duration is max 24 bits\\n                revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\\n            }\\n            if (userSupplyConfigs_[i].baseWithdrawalLimit == 0) {\\n                // base withdrawal limit can not be 0. As a side effect, this ensures that there is no supply config\\n                // where all values would be 0, so configured users can be differentiated in the mapping.\\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\\n            }\\n            // @dev baseWithdrawalLimit has no max bits amount as it is in normal token amount & converted to BigNumber\\n\\n            // get current user config data from storage\\n            userSupplyData_ = _userSupplyData[userSupplyConfigs_[i].user];\\n\\n            // Updating user data on storage\\n            _userSupplyData[userSupplyConfigs_[i].user] =\\n                // mask to update first bit + bits 162-217 (expand percentage, expand duration, base limit)\\n                (userSupplyData_ & 0xfffffffffc00000000000003ffffffffffffffffffffffffffffffffffffffff) |\\n                (1) |\\n                (userSupplyConfigs_[i].expandPercent << DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) |\\n                (userSupplyConfigs_[i].expandDuration << DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) |\\n                // convert base withdrawal limit to BigNumber for storage (10 | 8). (below this, 100% can be withdrawn)\\n                (userSupplyConfigs_[i].baseWithdrawalLimit.toBigNumber(\\n                    SMALL_COEFFICIENT_SIZE,\\n                    DEFAULT_EXPONENT_SIZE,\\n                    BigMathMinified.ROUND_DOWN\\n                ) << DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit LogUpdateUserSupplyConfigs(userSupplyConfigs_);\\n    }\\n\\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\\n    /// @param user_ user address for which to update the withdrawal limit\\n    /// @param newLimit_ new limit until which user supply can decrease to.\\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\\n    ///                  current user supply as limit respectively.\\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\\n    ///                  below base limit then fully down to 0.\\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\\n    function updateUserWithdrawalLimit(address user_, uint256 newLimit_) external _check _onlyDelegateCall {\\n        _checkIsContract(user_);\\n\\n        // get current user config data from storage\\n        uint256 userSupplyData_ = _userSupplyData[user_];\\n        if (userSupplyData_ == 0) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__UserNotDefined);\\n        }\\n\\n        // get current user supply amount\\n        uint256 userSupply_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\\n        userSupply_ = (userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK);\\n\\n        // maxExpansionLimit_ => withdrawal limit expandPercent (is in 1e2 decimals)\\n        uint256 maxExpansionLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\\n        maxExpansionLimit_ = userSupply_ - ((userSupply_ * maxExpansionLimit_) / FOUR_DECIMALS);\\n\\n        if (newLimit_ == 0 || newLimit_ < maxExpansionLimit_) {\\n            // instant full expansion, and if that goes below base limit then fully down to 0.\\n            // if we were to set a limit that goes below max expansion limit, then after 1 deposit or 1 withdrawal it would\\n            // become based on the max expansion limit again (unless it goes below base limit), which can be confusing.\\n            // Also updating base limit here to avoid the change after 1 interaction might have undesired effects.\\n            // So limiting update to max. full expansion. If more is desired, this must be called again after some withdraws.\\n            newLimit_ = maxExpansionLimit_;\\n        } else if (newLimit_ == type(uint256).max || newLimit_ > userSupply_) {\\n            // current withdrawable 0 (sets current user supply as limit).\\n            newLimit_ = userSupply_;\\n        }\\n        // else => new limit is between > max expansion and < user supply.\\n\\n        // set input limit as new current limit. instant withdrawable will be userSupply_ - newLimit_\\n\\n        uint256 baseLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\\n        baseLimit_ = (baseLimit_ >> DEFAULT_EXPONENT_SIZE) << (baseLimit_ & DEFAULT_EXPONENT_MASK);\\n        if (userSupply_ < baseLimit_) {\\n            newLimit_ = 0;\\n            // Note if new limit goes below base limit, it follows default behavior: first there must be a withdrawal\\n            // that brings user supply below base limit, then the limit will be set to 0.\\n            // otherwise we would have the same problem as described above after 1 interaction.\\n        }\\n\\n        // Update on storage\\n        _userSupplyData[user_] =\\n            // mask to update bits 65-161 (withdrawal limit, timestamp)\\n            (userSupplyData_ & 0xFFFFFFFFFFFFFFFFFFFFFFFC000000000000000000000001FFFFFFFFFFFFFFFF) |\\n            (newLimit_.toBigNumber(DEFAULT_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BigMathMinified.ROUND_DOWN) <<\\n                DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) | // converted to BigNumber can not overflow\\n            (block.timestamp << DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP);\\n\\n        emit LogUpdateUserWithdrawalLimit(user_, newLimit_);\\n    }\\n\\n    function updateUserBorrowConfigs(UserBorrowConfig[] memory userBorrowConfigs_) external _check _onlyDelegateCall {\\n        uint256 userBorrowData_;\\n\\n        for (uint256 i; i < userBorrowConfigs_.length; ) {\\n            _checkIsContract(userBorrowConfigs_[i].user);\\n            if (\\n                // max debt ceiling must not be smaller than base debt ceiling. Also covers case where max = 0 but base > 0\\n                userBorrowConfigs_[i].baseDebtCeiling > userBorrowConfigs_[i].maxDebtCeiling ||\\n                // can not set expand duration to 0 as that could cause a division by 0 in LiquidityCalcs.\\n                // having expand duration as 0 is anyway not an expected config so removing the possibility for that.\\n                // if no expansion is wanted, simply set expandDuration to 1 and expandPercent to 0.\\n                userBorrowConfigs_[i].expandDuration == 0\\n            ) {\\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\\n            }\\n            if (userBorrowConfigs_[i].expandPercent > X14) {\\n                // expandPercent is max 14 bits\\n                revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\\n            }\\n            if (userBorrowConfigs_[i].expandDuration > X24) {\\n                // duration is max 24 bits\\n                revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\\n            }\\n            if (userBorrowConfigs_[i].baseDebtCeiling == 0 || userBorrowConfigs_[i].maxDebtCeiling == 0) {\\n                // limits can not be 0. As a side effect, this ensures that there is no borrow config\\n                // where all values would be 0, so configured users can be differentiated in the mapping.\\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\\n            }\\n            // @dev baseDebtCeiling & maxDebtCeiling have no max bits amount as they are in normal token amount\\n            // and then converted to BigNumber\\n\\n            // get current user config data from storage\\n            userBorrowData_ = _userBorrowData[userBorrowConfigs_[i].user];\\n\\n            // Updating user data on storage\\n\\n            _userBorrowData[userBorrowConfigs_[i].user] =\\n                // mask to update first bit (mode) + bits 162-235 (debt limit values)\\n                (userBorrowData_ & 0xfffff0000000000000000003ffffffffffffffffffffffffffffffffffffffff) |\\n                (1) |\\n                (userBorrowConfigs_[i].expandPercent << DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) |\\n                (userBorrowConfigs_[i].expandDuration << DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) |\\n                // convert base debt limit to BigNumber for storage (10 | 8). (borrow is always possible below this)\\n                (userBorrowConfigs_[i].baseDebtCeiling.toBigNumber(\\n                    SMALL_COEFFICIENT_SIZE,\\n                    DEFAULT_EXPONENT_SIZE,\\n                    BigMathMinified.ROUND_DOWN\\n                ) << DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) |\\n                // convert max debt limit to BigNumber for storage (10 | 8). (no borrowing ever possible above this)\\n                (userBorrowConfigs_[i].maxDebtCeiling.toBigNumber(\\n                    SMALL_COEFFICIENT_SIZE,\\n                    DEFAULT_EXPONENT_SIZE,\\n                    BigMathMinified.ROUND_DOWN\\n                ) << DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit LogUpdateUserBorrowConfigs(userBorrowConfigs_);\\n    }\\n\\n    function pauseUser(address user_, bool pauseSupply_, bool pauseBorrow_) public _onlyDelegateCall {\\n        _checkIsContract(user_);\\n\\n        uint256 userData_;\\n\\n        if (pauseSupply_) {\\n            // userData_ => userSupplyData_\\n            userData_ = _userSupplyData[user_];\\n            if (userData_ == 0) {\\n                revert FluidDexError(ErrorTypes.DexT1Admin__UserNotDefined);\\n            }\\n            if (userData_ & 1 == 0) {\\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidPauseToggle);\\n            }\\n            // set first bit as 0, meaning all user's supply operations are paused\\n            _userSupplyData[user_] = userData_ & (~uint(1));\\n        }\\n\\n        if (pauseBorrow_) {\\n            // userData_ => userBorrowData_\\n            userData_ = _userBorrowData[user_];\\n            if (userData_ == 0) {\\n                revert FluidDexError(ErrorTypes.DexT1Admin__UserNotDefined);\\n            }\\n            if (userData_ & 1 == 0) {\\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidPauseToggle);\\n            }\\n            // set first bit as 0, meaning all user's borrow operations are paused\\n            _userBorrowData[user_] = userData_ & (~uint(1));\\n        }\\n\\n        emit LogPauseUser(user_, pauseSupply_, pauseBorrow_);\\n    }\\n\\n    function unpauseUser(address user_, bool unpauseSupply_, bool unpauseBorrow_) public _onlyDelegateCall {\\n        _checkIsContract(user_);\\n\\n        uint256 userData_;\\n\\n        if (unpauseSupply_) {\\n            // userData_ => userSupplyData_\\n            userData_ = _userSupplyData[user_];\\n            if (userData_ == 0) {\\n                revert FluidDexError(ErrorTypes.DexT1Admin__UserNotDefined);\\n            }\\n            if (userData_ & 1 == 1) {\\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidPauseToggle);\\n            }\\n\\n            // set first bit as 1, meaning unpause\\n            _userSupplyData[user_] = userData_ | 1;\\n        }\\n\\n        if (unpauseBorrow_) {\\n            // userData_ => userBorrowData_\\n            userData_ = _userBorrowData[user_];\\n            if (userData_ == 0) {\\n                revert FluidDexError(ErrorTypes.DexT1Admin__UserNotDefined);\\n            }\\n            if (userData_ & 1 == 1) {\\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidPauseToggle);\\n            }\\n\\n            // set first bit as 1, meaning unpause\\n            _userBorrowData[user_] = userData_ | 1;\\n        }\\n\\n        emit LogUnpauseUser(user_, unpauseSupply_, unpauseBorrow_);\\n    }\\n\\n    /// note we have not added updateUtilizationLimit in the params here because struct of InitializeVariables already has 16 variables\\n    /// we might skip adding it and let it update through the indepdent function to keep initialize struct simple\\n    function initialize(InitializeVariables memory i_) public payable _onlyDelegateCall {\\n        _checkIsContract(TEAM_MULTISIG);\\n\\n        if (!(i_.smartCol || i_.smartDebt)) {\\n            // either 1 should be on upon pool initialization\\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\\n        }\\n        // cut is an integer in storage slot which is more than enough\\n        // but from UI we are allowing to send in 4 decimals to maintain consistency & avoid human error in future\\n        if (i_.revenueCut != 0 && i_.revenueCut < FOUR_DECIMALS) {\\n            // human input error. should send 0 for wanting 0, not 0 because of precision reduction.\\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\\n        }\\n\\n        // revenue cut has no decimals\\n        i_.revenueCut = i_.revenueCut / FOUR_DECIMALS;\\n        i_.upperShiftThreshold = i_.upperShiftThreshold / THREE_DECIMALS;\\n        i_.lowerShiftThreshold = i_.lowerShiftThreshold / THREE_DECIMALS;\\n\\n        if (\\n            (i_.fee > FIVE_DECIMALS) || // fee cannot be more than 10%\\n            (i_.revenueCut > TWO_DECIMALS) ||\\n            (i_.upperPercent > (SIX_DECIMALS - FOUR_DECIMALS)) || // capping range to 99%.\\n            (i_.lowerPercent > (SIX_DECIMALS - FOUR_DECIMALS)) || // capping range to 99%.\\n            (i_.upperPercent == 0) ||\\n            (i_.lowerPercent == 0) ||\\n            (i_.upperShiftThreshold > THREE_DECIMALS) ||\\n            (i_.lowerShiftThreshold > THREE_DECIMALS) ||\\n            (i_.upperShiftThreshold == 0) ||\\n            (i_.lowerShiftThreshold == 0) ||\\n            (i_.thresholdShiftTime == 0) ||\\n            (i_.thresholdShiftTime > X24) ||\\n            (i_.centerPriceAddress > X30) ||\\n            (i_.hookAddress > X30) ||\\n            (i_.centerPrice <= i_.minCenterPrice) ||\\n            (i_.centerPrice >= i_.maxCenterPrice) ||\\n            (i_.minCenterPrice == 0)\\n        ) {\\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\\n        }\\n\\n        uint dexVariables2_;\\n\\n        if (i_.smartCol) {\\n            _turnOnSmartCol(i_.token0ColAmt, i_.centerPrice);\\n            dexVariables2_ = dexVariables2_ | 1;\\n        }\\n\\n        if (i_.smartDebt) {\\n            _turnOnSmartDebt(i_.token0DebtAmt, i_.centerPrice);\\n            dexVariables2_ = dexVariables2_ | 2;\\n        }\\n\\n        i_.centerPrice = i_.centerPrice.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN);\\n        // setting up initial dexVariables\\n        dexVariables =\\n            (i_.centerPrice << 1) |\\n            (i_.centerPrice << 41) |\\n            (i_.centerPrice << 81) |\\n            (block.timestamp << 121) |\\n            (60 << 154) | // just setting 60 seconds, no particular reason for it why \\\"60\\\"\\n            (7 << 176);\\n\\n        dexVariables2 =\\n            dexVariables2_ |\\n            (i_.fee << 2) |\\n            (i_.revenueCut << 19) |\\n            (i_.upperPercent << 27) |\\n            (i_.lowerPercent << 47) |\\n            (i_.upperShiftThreshold << 68) |\\n            (i_.lowerShiftThreshold << 78) |\\n            (i_.thresholdShiftTime << 88) |\\n            (i_.centerPriceAddress << 112) |\\n            (i_.hookAddress << 142) |\\n            (i_.maxCenterPrice.toBigNumber(20, 8, BigMathMinified.ROUND_UP) << 172) |\\n            (i_.minCenterPrice.toBigNumber(20, 8, BigMathMinified.ROUND_DOWN) << 200) |\\n            (THREE_DECIMALS << 228) | // setting initial token0 max utilization to 100%\\n            (THREE_DECIMALS << 238); // setting initial token1 max utilization to 100%\\n\\n        emit LogInitializePoolConfig(\\n            i_.smartCol,\\n            i_.smartDebt,\\n            i_.token0ColAmt,\\n            i_.token0DebtAmt,\\n            i_.fee,\\n            i_.revenueCut * FOUR_DECIMALS,\\n            i_.centerPriceAddress,\\n            i_.hookAddress\\n        );\\n\\n        emit LogInitializePriceParams(\\n            i_.upperPercent,\\n            i_.lowerPercent,\\n            i_.upperShiftThreshold * THREE_DECIMALS,\\n            i_.lowerShiftThreshold * THREE_DECIMALS,\\n            i_.thresholdShiftTime,\\n            i_.maxCenterPrice,\\n            i_.minCenterPrice\\n        );\\n    }\\n\\n    function pauseSwapAndArbitrage() public _onlyDelegateCall {\\n        uint dexVariables2_ = dexVariables2;\\n        if ((dexVariables2_ >> 255) == 1) {\\n            // already paused\\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\\n        }\\n        dexVariables2 = dexVariables2_ | (uint(1) << 255);\\n\\n        emit LogPauseSwapAndArbitrage();\\n    }\\n\\n    function unpauseSwapAndArbitrage() public _onlyDelegateCall {\\n        uint dexVariables2_ = dexVariables2;\\n        if ((dexVariables2_ >> 255) == 0) {\\n            // already unpaused\\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\\n        }\\n        dexVariables2 = (dexVariables2_ << 1) >> 1;\\n\\n        emit LogUnpauseSwapAndArbitrage();\\n    }\\n\\n    /// @notice sends any potentially stuck funds to Liquidity contract.\\n    /// @dev this contract never holds any funds as all operations send / receive funds from user <-> Liquidity.\\n    function rescueFunds(address token_) external _onlyDelegateCall {\\n        address liquidity_ = IFluidDexT1(address(this)).constantsView().liquidity;\\n        if (token_ == NATIVE_TOKEN) {\\n            SafeTransfer.safeTransferNative(liquidity_, address(this).balance);\\n        } else {\\n            SafeTransfer.safeTransfer(token_, liquidity_, IERC20(token_).balanceOf(address(this)));\\n        }\\n\\n        emit LogRescueFunds(token_);\\n    }\\n}\\n\",\"keccak256\":\"0xeb1fc14ca4878c77403d0231cd091896631ed445a29d5873138d600cf4d14fe5\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/poolT1/adminModule/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Structs {\\n    struct InitializeVariables {\\n        bool smartCol;\\n        uint token0ColAmt;\\n        bool smartDebt;\\n        uint token0DebtAmt;\\n        uint centerPrice;\\n        uint fee;\\n        uint revenueCut;\\n        uint upperPercent;\\n        uint lowerPercent;\\n        uint upperShiftThreshold;\\n        uint lowerShiftThreshold;\\n        uint thresholdShiftTime;\\n        uint centerPriceAddress;\\n        uint hookAddress;\\n        uint maxCenterPrice;\\n        uint minCenterPrice;\\n    }\\n\\n    /// @notice struct to set user supply & withdrawal config\\n    struct UserSupplyConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration withdrawal limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseWithdrawalLimit;\\n    }\\n\\n    /// @notice struct to set user borrow & payback config\\n    struct UserBorrowConfig {\\n        ///\\n        /// @param user address\\n        address user;\\n        ///\\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\\n        /// Also used to calculate rate at which debt limit should decrease (instant).\\n        uint256 expandPercent;\\n        ///\\n        /// @param expandDuration debt limit expand duration in seconds.\\n        /// used to calculate rate together with expandPercent\\n        uint256 expandDuration;\\n        ///\\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 baseDebtCeiling;\\n        ///\\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\\n        /// with interest -> raw, without interest -> normal\\n        uint256 maxDebtCeiling;\\n    }\\n}\\n\",\"keccak256\":\"0x78aafe0823a9ceeda9e3e7f44aac785b2bf6a4a7517798678a69ac06c0e33fe1\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/poolT1/common/constantVariables.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { StorageRead } from \\\"../../../../libraries/storageRead.sol\\\";\\n\\ninterface ITokenDecimals {\\n    function decimals() external view returns (uint8);\\n}\\n\\nabstract contract ConstantVariables is StorageRead {\\n    /*//////////////////////////////////////////////////////////////\\n                          CONSTANTS / IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address internal constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\\n\\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    uint256 internal constant NATIVE_TOKEN_DECIMALS = 18;\\n    address internal constant ADDRESS_DEAD = 0x000000000000000000000000000000000000dEaD;\\n    uint256 internal constant TOKENS_DECIMALS_PRECISION = 12;\\n    uint256 internal constant TOKENS_DECIMALS = 1e12;\\n\\n    uint256 internal constant SMALL_COEFFICIENT_SIZE = 10;\\n    uint256 internal constant DEFAULT_COEFFICIENT_SIZE = 56;\\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\\n\\n    uint256 internal constant X2 = 0x3;\\n    uint256 internal constant X3 = 0x7;\\n    uint256 internal constant X5 = 0x1f;\\n    uint256 internal constant X7 = 0x7f;\\n    uint256 internal constant X8 = 0xff;\\n    uint256 internal constant X9 = 0x1ff;\\n    uint256 internal constant X10 = 0x3ff;\\n    uint256 internal constant X11 = 0x7ff;\\n    uint256 internal constant X14 = 0x3fff;\\n    uint256 internal constant X16 = 0xffff;\\n    uint256 internal constant X17 = 0x1ffff;\\n    uint256 internal constant X18 = 0x3ffff;\\n    uint256 internal constant X20 = 0xfffff;\\n    uint256 internal constant X22 = 0x3fffff;\\n    uint256 internal constant X23 = 0x7fffff;\\n    uint256 internal constant X24 = 0xffffff;\\n    uint256 internal constant X28 = 0xfffffff;\\n    uint256 internal constant X30 = 0x3fffffff;\\n    uint256 internal constant X32 = 0xffffffff;\\n    uint256 internal constant X33 = 0x1ffffffff;\\n    uint256 internal constant X40 = 0xffffffffff;\\n    uint256 internal constant X64 = 0xffffffffffffffff;\\n    uint256 internal constant X96 = 0xffffffffffffffffffffffff;\\n    uint256 internal constant X128 = 0xffffffffffffffffffffffffffffffff;\\n\\n    uint256 internal constant TWO_DECIMALS = 1e2;\\n    uint256 internal constant THREE_DECIMALS = 1e3;\\n    uint256 internal constant FOUR_DECIMALS = 1e4;\\n    uint256 internal constant FIVE_DECIMALS = 1e5;\\n    uint256 internal constant SIX_DECIMALS = 1e6;\\n    uint256 internal constant EIGHT_DECIMALS = 1e8;\\n    uint256 internal constant NINE_DECIMALS = 1e9;\\n\\n    uint256 internal constant PRICE_PRECISION = 1e27;\\n\\n    uint256 internal constant ORACLE_PRECISION = 1e18; // 100%\\n    uint256 internal constant ORACLE_LIMIT = 5 * 1e16; // 5%\\n\\n    /// after swap token0 reserves should not be less than token1InToken0 / MINIMUM_LIQUIDITY_SWAP\\n    /// after swap token1 reserves should not be less than token0InToken1 / MINIMUM_LIQUIDITY_SWAP\\n    uint256 internal constant MINIMUM_LIQUIDITY_SWAP = 1e4;\\n\\n    /// after user operations (deposit, withdraw, borrow, payback) token0 reserves should not be less than token1InToken0 / MINIMUM_LIQUIDITY_USER_OPERATIONS\\n    /// after user operations (deposit, withdraw, borrow, payback) token1 reserves should not be less than token0InToken0 / MINIMUM_LIQUIDITY_USER_OPERATIONS\\n    uint256 internal constant MINIMUM_LIQUIDITY_USER_OPERATIONS = 1e6;\\n\\n    /// To skip transfers in liquidity layer if token in & out is same and liquidity layer is on the winning side\\n    bytes32 internal constant SKIP_TRANSFERS = keccak256(bytes(\\\"SKIP_TRANSFERS\\\"));\\n\\n    function _decimals(address token_) internal view returns (uint256) {\\n        return (token_ == NATIVE_TOKEN) ? NATIVE_TOKEN_DECIMALS : ITokenDecimals(token_).decimals();\\n    }\\n}\\n\",\"keccak256\":\"0xab697f39bfede319530bac2bc86e71e663c6b81de2bafea4255f2cc65f2b520b\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/poolT1/common/variables.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Variables {\\n    /*//////////////////////////////////////////////////////////////\\n                          STORAGE VARIABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// First 1 bit  => 0 => re-entrancy. If 0 then allow transaction to go, else throw.\\n    /// Next 40 bits => 1-40 => last to last stored price. BigNumber (32 bits precision, 8 bits exponent)\\n    /// Next 40 bits => 41-80 => last stored price of pool. BigNumber (32 bits precision, 8 bits exponent)\\n    /// Next 40 bits => 81-120 => center price. Center price from where the ranges will be calculated. BigNumber (32 bits precision, 8 bits exponent)\\n    /// Next 33 bits => 121-153 => last interaction time stamp\\n    /// Next 22 bits => 154-175 => max 4194303 seconds (~1165 hrs, ~48.5 days), time difference between last to last and last price stored\\n    /// Next 3 bits  => 176-178 => oracle checkpoint, if 0 then first slot, if 7 then last slot\\n    /// Next 16 bits => 179-194 => current mapping or oracle, after every 8 transaction it will increase by 1. Max capacity is 65535 but it can be lower than that check dexVariables2\\n    uint internal dexVariables;\\n\\n    /// Next  1 bit  => 0 => is smart collateral enabled?\\n    /// Next  1 bit  => 1 => is smart debt enabled?\\n    /// Next 17 bits => 2-18 => fee (1% = 10000, max value: 100000 = 10%, fee should not be more than 10%)\\n    /// Next  7 bits => 19-25 => revenue cut from fee (1 = 1%, 100 = 100%). If fee is 1000 = 0.1% and revenue cut is 10 = 10% then governance get 0.01% of every swap\\n    /// Next  1 bit  => 26 => percent active change going on or not, 0 = false, 1 = true, if true than that means governance has updated the below percents and the update should happen with a specified time.\\n    /// Next 20 bits => 27-46 => upperPercent (1% = 10000, max value: 104.8575%) upperRange - upperRange * upperPercent = centerPrice. Hence, upperRange = centerPrice / (1 - upperPercent)\\n    /// Next 20 bits => 47-66 => lowerPercent. lowerRange = centerPrice - centerPrice * lowerPercent.\\n    /// Next  1 bit  => 67 => threshold percent active change going on or not, 0 = false, 1 = true, if true than that means governance has updated the below percents and the update should happen with a specified time.\\n    /// Next 10 bits => 68-77 => upper shift threshold percent, 1 = 0.1%. 1000 = 100%. if currentPrice > (centerPrice + (upperRange - centerPrice) * (1000 - upperShiftThresholdPercent) / 1000) then trigger shift\\n    /// Next 10 bits => 78-87 => lower shift threshold percent, 1 = 0.1%. 1000 = 100%. if currentPrice < (centerPrice - (centerPrice - lowerRange) * (1000 - lowerShiftThresholdPercent) / 1000) then trigger shift\\n    /// Next 24 bits => 88-111 => Shifting time (~194 days) (rate = (% up + % down) / time ?)\\n    /// Next 30 bits => 112-131 => Address of center price if center price should be fetched externally, for example, for wstETH <> ETH pool, fetch wstETH exchange rate into stETH from wstETH contract.\\n    /// Why fetch it externally? Because let's say pool width is 0.1% and wstETH temporarily got depeg of 0.5% then pool will start to shift to newer pricing\\n    /// but we don't want pool to shift to 0.5% because we know the depeg will recover so to avoid the loss for users.\\n    /// Next 30 bits => 142-171 => Hooks bits, calculate hook address by storing deployment nonce from factory.\\n    /// Next 28 bits => 172-199 => max center price. BigNumber (20 bits precision, 8 bits exponent)\\n    /// Next 28 bits => 200-227 => min center price. BigNumber (20 bits precision, 8 bits exponent)\\n    /// Next 10 bits => 228-237 => utilization limit of token0. Max value 1000 = 100%, if 100% then no need to check the utilization.\\n    /// Next 10 bits => 238-247 => utilization limit of token1. Max value 1000 = 100%, if 100% then no need to check the utilization.\\n    /// Next 1  bit  => 248     => is center price shift active\\n    /// Last 1  bit  => 255     => Pause swap & arbitrage (only perfect functions will be usable), if we need to pause entire DEX then that can be done through pausing DEX on Liquidity Layer\\n    uint internal dexVariables2;\\n\\n    uint internal _totalSupplyShares;\\n\\n    /// @dev user supply data: user -> data\\n    /// Aside from 1st bit, entire bits here are same as liquidity layer _userSupplyData. Hence exact same supply & borrow limit library can be used\\n    /// First  1 bit  =>       0 => is user allowed to supply? 0 = not allowed, 1 = allowed\\n    /// Next  64 bits =>   1- 64 => user supply amount/shares; BigMath: 56 | 8\\n    /// Next  64 bits =>  65-128 => previous user withdrawal limit; BigMath: 56 | 8\\n    /// Next  33 bits => 129-161 => last triggered process timestamp (enough until 16 March 2242 -> max value 8589934591)\\n    /// Next  14 bits => 162-175 => expand withdrawal limit percentage (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383).\\n    ///                             @dev shrinking is instant\\n    /// Next  24 bits => 176-199 => withdrawal limit expand duration in seconds.(Max value 16_777_215; ~4_660 hours, ~194 days)\\n    /// Next  18 bits => 200-217 => base withdrawal limit: below this, 100% withdrawals can be done (aka shares can be burned); BigMath: 10 | 8\\n    /// Next  38 bits => 218-255 => empty for future use\\n    mapping(address => uint) internal _userSupplyData;\\n\\n    uint internal _totalBorrowShares;\\n\\n    /// @dev user borrow data: user -> data\\n    /// Aside from 1st bit, entire bits here are same as liquidity layer _userBorrowData. Hence exact same supply & borrow limit library function can be used\\n    /// First  1 bit  =>       0 => is user allowed to borrow? 0 = not allowed, 1 = allowed\\n    /// Next  64 bits =>   1- 64 => user debt amount/shares; BigMath: 56 | 8\\n    /// Next  64 bits =>  65-128 => previous user debt ceiling; BigMath: 56 | 8\\n    /// Next  33 bits => 129-161 => last triggered process timestamp (enough until 16 March 2242 -> max value 8589934591)\\n    /// Next  14 bits => 162-175 => expand debt ceiling percentage (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\\n    ///                             @dev shrinking is instant\\n    /// Next  24 bits => 176-199 => debt ceiling expand duration in seconds (Max value 16_777_215; ~4_660 hours, ~194 days)\\n    /// Next  18 bits => 200-217 => base debt ceiling: below this, there's no debt ceiling limits; BigMath: 10 | 8\\n    /// Next  18 bits => 218-235 => max debt ceiling: absolute maximum debt ceiling can expand to; BigMath: 10 | 8\\n    /// Next  20 bits => 236-255 => empty for future use\\n    mapping(address => uint) internal _userBorrowData;\\n\\n    /// Price difference between last swap of last block & last swap of new block\\n    /// If last swap happened at Block B - 4 and next swap happened after 4 blocks at Block B then it will store that difference\\n    /// considering time difference between these 4 blocks is 48 seconds, hence time will be stored as 48\\n    /// New oracle update:\\n    /// time to 9 bits and precision to 22 bits\\n    /// if time exceeds 9 bits which is 511 sec or ~8.5 min then we will use 2 oracle slot to store the data\\n    /// we will leave the both time slot as 0 and on first sign + precision slot we will store time and\\n    /// on second sign + precision slot we will store sign & precision\\n    /// First 9 bits =>   0-  8 => time, 511 seconds\\n    /// Next   1 bit  =>  9     => sign of percent in change, if 1 then 0 or positive, else negative\\n    /// Next  22 bits =>  10- 31 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\\n    /// Next  9 bits =>  32- 40 => time, 511 seconds\\n    /// Next   1 bit  =>  41     => sign of percent in change, if 1 then 0 or positive, else negative\\n    /// Next  22 bits =>  42- 63 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\\n    /// Next  9 bits =>  64- 72 => time, 511 seconds\\n    /// Next   1 bit  =>  73     => sign of percent in change, if 1 then 0 or positive, else negative\\n    /// Next  22 bits =>  74- 95 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\\n    /// Next  9 bits =>  96-104 => time, 511 seconds\\n    /// Next   1 bit  => 105     => sign of percent in change, if 1 then 0 or positive, else negative\\n    /// Next  22 bits => 106-127 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\\n    /// Next  9 bits => 128-136 => time, 511 seconds\\n    /// Next   1 bit  => 137     => sign of percent in change, if 1 then 0 or positive, else negative\\n    /// Next  22 bits => 138-159 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\\n    /// Next  9 bits => 160-168 => time, 511 seconds\\n    /// Next   1 bit  => 169     => sign of percent in change, if 1 then 0 or positive, else negative\\n    /// Next  22 bits => 170-191 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\\n    /// Next  9 bits => 192-200 => time, 511 seconds\\n    /// Next   1 bit  => 201     => sign of percent in change, if 1 then 0 or positive, else negative\\n    /// Next  22 bits => 202-223 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\\n    /// Next  9 bits => 224-232 => time, 511 seconds\\n    /// Next   1 bit  => 233     => sign of percent in change, if 1 then 0 or positive, else negative\\n    /// Next  22 bits => 234-255 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\\n    mapping(uint => uint) internal _oracle;\\n\\n    /// First 20 bits =>  0-19 => old upper shift\\n    /// Next  20 bits => 20-39 => old lower shift\\n    /// Next  20 bits => 40-59 => in seconds, ~12 days max, shift can last for max ~12 days\\n    /// Next  33 bits => 60-92 => timestamp of when the shift has started.\\n    uint128 internal _rangeShift;\\n\\n    /// First 10 bits =>  0- 9 => old upper shift\\n    /// Next  10 bits => 10-19 => empty so we can use same helper function\\n    /// Next  10 bits => 20-29 => old lower shift\\n    /// Next  10 bits => 30-39 => empty so we can use same helper function\\n    /// Next  20 bits => 40-59 => in seconds, ~12 days max, shift can last for max ~12 days\\n    /// Next  33 bits => 60-92 => timestamp of when the shift has started.\\n    /// Next  24 bits => 93-116 => old threshold time\\n    uint128 internal _thresholdShift;\\n\\n    /// Shifting is fuzzy and with time it'll keep on getting closer and then eventually get over\\n    /// First 33 bits => 0 -32 => starting timestamp\\n    /// Next  20 bits => 33-52 => % shift\\n    /// Next  20 bits => 53-72 => time to shift that percent\\n    uint256 internal _centerPriceShift;\\n}\\n\",\"keccak256\":\"0xd36a003ed4f7dde310ce208c8ffdf6a96ee2dbe3ea0892286e4e731e90e79566\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/poolT1/coreModule/core/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { CoreHelpers } from \\\"../helpers/coreHelpers.sol\\\";\\nimport { SafeTransfer } from \\\"../../../../../libraries/safeTransfer.sol\\\";\\nimport { DexSlotsLink } from \\\"../../../../../libraries/dexSlotsLink.sol\\\";\\nimport { DexCalcs } from \\\"../../../../../libraries/dexCalcs.sol\\\";\\nimport { BigMathMinified } from \\\"../../../../../libraries/bigMathMinified.sol\\\";\\nimport { ErrorTypes } from \\\"../../../errorTypes.sol\\\";\\nimport { IFluidDexT1 } from \\\"../../../interfaces/iDexT1.sol\\\";\\n\\n/// @title FluidDexT1\\n/// @notice Implements core logics for Fluid Dex protocol.\\n/// Note Token transfers happen directly from user to Liquidity contract and vice-versa.\\ncontract FluidDexT1 is CoreHelpers {\\n    using BigMathMinified for uint256;\\n\\n    constructor(ConstantViews memory constantViews_) CoreHelpers(constantViews_) {\\n        // any implementations should not be zero\\n        if (\\n            constantViews_.implementations.shift == address(0) ||\\n            constantViews_.implementations.admin == address(0) ||\\n            constantViews_.implementations.colOperations == address(0) ||\\n            constantViews_.implementations.debtOperations == address(0) ||\\n            constantViews_.implementations.perfectOperationsAndSwapOut == address(0)\\n        ) {\\n            revert FluidDexError(ErrorTypes.DexT1__InvalidImplementation);\\n        }\\n    }\\n\\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountIn_ The exact amount of input tokens to swap\\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\\n    /// @return amountOut_ The amount of output tokens received from the swap\\n    function swapIn(\\n        bool swap0to1_,\\n        uint256 amountIn_,\\n        uint256 amountOutMin_,\\n        address to_\\n    ) public payable returns (uint256 amountOut_) {\\n        uint dexVariables_ = dexVariables;\\n        uint dexVariables2_ = dexVariables2;\\n\\n        if ((dexVariables2_ >> 255) == 1) revert FluidDexError(ErrorTypes.DexT1__SwapAndArbitragePaused);\\n\\n        _check(dexVariables_, dexVariables2_);\\n\\n        if (to_ == address(0)) to_ = msg.sender;\\n\\n        SwapInMemory memory s_;\\n\\n        if (swap0to1_) {\\n            (s_.tokenIn, s_.tokenOut) = (TOKEN_0, TOKEN_1);\\n            unchecked {\\n                s_.amtInAdjusted = (amountIn_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION;\\n            }\\n        } else {\\n            (s_.tokenIn, s_.tokenOut) = (TOKEN_1, TOKEN_0);\\n            unchecked {\\n                s_.amtInAdjusted = (amountIn_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION;\\n            }\\n        }\\n\\n        _verifySwapAndNonPerfectActions(s_.amtInAdjusted, amountIn_);\\n\\n        PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\\n\\n        if (msg.value > 0) {\\n            if (msg.value != amountIn_) revert FluidDexError(ErrorTypes.DexT1__EthAndAmountInMisMatch);\\n            if (s_.tokenIn != NATIVE_TOKEN) revert FluidDexError(ErrorTypes.DexT1__EthSentForNonNativeSwap);\\n        }\\n\\n        // is smart collateral pool enabled\\n        uint temp_ = dexVariables2_ & 1;\\n        // is smart debt pool enabled\\n        uint temp2_ = (dexVariables2_ >> 1) & 1;\\n\\n        uint temp3_;\\n        uint temp4_;\\n\\n        // extracting fee\\n        temp3_ = ((dexVariables2_ >> 2) & X17);\\n        unchecked {\\n            // converting revenue cut in 4 decimals, 1% = 10000\\n            // If fee is 1% and revenue cut is 10% then 0.1 * 10000 = 1000\\n            // hence revenueCut = 1e6 - 1000 = 999000\\n            // s_.revenueCut => 1 - revenue cut\\n            s_.revenueCut = SIX_DECIMALS - ((((dexVariables2_ >> 19) & X7) * temp3_) / 100);\\n            // 1 - fee. If fee is 1% then withoutFee will be 1e6 - 1e4\\n            // s_.fee => 1 - withdraw fee\\n            s_.fee = SIX_DECIMALS - temp3_;\\n        }\\n\\n        CollateralReservesSwap memory cs_;\\n        DebtReservesSwap memory ds_;\\n        if (temp_ == 1) {\\n            // smart collateral is enabled\\n            {\\n                CollateralReserves memory c_ = _getCollateralReserves(\\n                    pex_.geometricMean,\\n                    pex_.upperRange,\\n                    pex_.lowerRange,\\n                    pex_.supplyToken0ExchangePrice,\\n                    pex_.supplyToken1ExchangePrice\\n                );\\n                if (swap0to1_) {\\n                    (\\n                        cs_.tokenInRealReserves,\\n                        cs_.tokenOutRealReserves,\\n                        cs_.tokenInImaginaryReserves,\\n                        cs_.tokenOutImaginaryReserves\\n                    ) = (\\n                        c_.token0RealReserves,\\n                        c_.token1RealReserves,\\n                        c_.token0ImaginaryReserves,\\n                        c_.token1ImaginaryReserves\\n                    );\\n                } else {\\n                    (\\n                        cs_.tokenInRealReserves,\\n                        cs_.tokenOutRealReserves,\\n                        cs_.tokenInImaginaryReserves,\\n                        cs_.tokenOutImaginaryReserves\\n                    ) = (\\n                        c_.token1RealReserves,\\n                        c_.token0RealReserves,\\n                        c_.token1ImaginaryReserves,\\n                        c_.token0ImaginaryReserves\\n                    );\\n                }\\n            }\\n        }\\n\\n        if (temp2_ == 1) {\\n            // smart debt is enabled\\n            {\\n                DebtReserves memory d_ = _getDebtReserves(\\n                    pex_.geometricMean,\\n                    pex_.upperRange,\\n                    pex_.lowerRange,\\n                    pex_.borrowToken0ExchangePrice,\\n                    pex_.borrowToken1ExchangePrice\\n                );\\n                if (swap0to1_) {\\n                    (\\n                        ds_.tokenInDebt,\\n                        ds_.tokenOutDebt,\\n                        ds_.tokenInRealReserves,\\n                        ds_.tokenOutRealReserves,\\n                        ds_.tokenInImaginaryReserves,\\n                        ds_.tokenOutImaginaryReserves\\n                    ) = (\\n                        d_.token0Debt,\\n                        d_.token1Debt,\\n                        d_.token0RealReserves,\\n                        d_.token1RealReserves,\\n                        d_.token0ImaginaryReserves,\\n                        d_.token1ImaginaryReserves\\n                    );\\n                } else {\\n                    (\\n                        ds_.tokenInDebt,\\n                        ds_.tokenOutDebt,\\n                        ds_.tokenInRealReserves,\\n                        ds_.tokenOutRealReserves,\\n                        ds_.tokenInImaginaryReserves,\\n                        ds_.tokenOutImaginaryReserves\\n                    ) = (\\n                        d_.token1Debt,\\n                        d_.token0Debt,\\n                        d_.token1RealReserves,\\n                        d_.token0RealReserves,\\n                        d_.token1ImaginaryReserves,\\n                        d_.token0ImaginaryReserves\\n                    );\\n                }\\n            }\\n        }\\n\\n        // limiting amtInAdjusted to be not more than 50% of both (collateral & debt) imaginary tokenIn reserves combined\\n        // basically, if this throws that means user is trying to swap 0.5x tokenIn if current tokenIn imaginary reserves is x\\n        // let's take x as token0 here, that means, initially the pool pricing might be:\\n        // token1Reserve / x and new pool pricing will become token1Reserve / 1.5x (token1Reserve will decrease after swap but for simplicity ignoring that)\\n        // So pool price is decreased by ~33.33% (oracle will throw error in this case as it only allows 5% price difference but better to limit it before hand)\\n        unchecked {\\n            if (s_.amtInAdjusted > ((cs_.tokenInImaginaryReserves + ds_.tokenInImaginaryReserves) / 2))\\n                revert FluidDexError(ErrorTypes.DexT1__SwapInLimitingAmounts);\\n        }\\n\\n        if (temp_ == 1 && temp2_ == 1) {\\n            // unless both pools are enabled s_.swapRoutingAmt will be 0\\n            s_.swapRoutingAmt = _swapRoutingIn(\\n                s_.amtInAdjusted,\\n                cs_.tokenOutImaginaryReserves,\\n                cs_.tokenInImaginaryReserves,\\n                ds_.tokenOutImaginaryReserves,\\n                ds_.tokenInImaginaryReserves\\n            );\\n        }\\n\\n        // In below if else statement temps are:\\n        // temp_ => deposit amt\\n        // temp2_ => withdraw amt\\n        // temp3_ => payback amt\\n        // temp4_ => borrow amt\\n        if (int(s_.amtInAdjusted) > s_.swapRoutingAmt && s_.swapRoutingAmt > 0) {\\n            // swap will route from the both pools\\n            // temp_ = amountInCol_\\n            temp_ = uint(s_.swapRoutingAmt);\\n            unchecked {\\n                // temp3_ = amountInDebt_\\n                temp3_ = s_.amtInAdjusted - temp_;\\n            }\\n\\n            (temp2_, temp4_) = (0, 0);\\n\\n            // debt pool price will be the same as collateral pool after the swap\\n            s_.withdrawTo = to_;\\n            s_.borrowTo = to_;\\n        } else if ((temp_ == 1 && temp2_ == 0) || (s_.swapRoutingAmt >= int(s_.amtInAdjusted))) {\\n            // entire swap will route through collateral pool\\n            (temp_, temp2_, temp3_, temp4_) = (s_.amtInAdjusted, 0, 0, 0);\\n            // price can slightly differ from debt pool but difference will be very small. Probably <0.01% for active DEX pools.\\n            s_.withdrawTo = to_;\\n        } else if ((temp_ == 0 && temp2_ == 1) || (s_.swapRoutingAmt <= 0)) {\\n            // entire swap will route through debt pool\\n            (temp_, temp2_, temp3_, temp4_) = (0, 0, s_.amtInAdjusted, 0);\\n            // price can slightly differ from collateral pool but difference will be very small. Probably <0.01% for active DEX pools.\\n            s_.borrowTo = to_;\\n        } else {\\n            // swap should never reach this point but if it does then reverting\\n            revert FluidDexError(ErrorTypes.DexT1__NoSwapRoute);\\n        }\\n\\n        if (temp_ > 0) {\\n            // temp2_ = amountOutCol_\\n            temp2_ = _getAmountOut(\\n                ((temp_ * s_.fee) / SIX_DECIMALS),\\n                cs_.tokenInImaginaryReserves,\\n                cs_.tokenOutImaginaryReserves\\n            );\\n            swap0to1_\\n                ? _verifyToken1Reserves(\\n                    (cs_.tokenInRealReserves + temp_),\\n                    (cs_.tokenOutRealReserves - temp2_),\\n                    pex_.centerPrice,\\n                    MINIMUM_LIQUIDITY_SWAP\\n                )\\n                : _verifyToken0Reserves(\\n                    (cs_.tokenOutRealReserves - temp2_),\\n                    (cs_.tokenInRealReserves + temp_),\\n                    pex_.centerPrice,\\n                    MINIMUM_LIQUIDITY_SWAP\\n                );\\n        }\\n        if (temp3_ > 0) {\\n            // temp4_ = amountOutDebt_\\n            temp4_ = _getAmountOut(\\n                ((temp3_ * s_.fee) / SIX_DECIMALS),\\n                ds_.tokenInImaginaryReserves,\\n                ds_.tokenOutImaginaryReserves\\n            );\\n            swap0to1_\\n                ? _verifyToken1Reserves(\\n                    (ds_.tokenInRealReserves + temp3_),\\n                    (ds_.tokenOutRealReserves - temp4_),\\n                    pex_.centerPrice,\\n                    MINIMUM_LIQUIDITY_SWAP\\n                )\\n                : _verifyToken0Reserves(\\n                    (ds_.tokenOutRealReserves - temp4_),\\n                    (ds_.tokenInRealReserves + temp3_),\\n                    pex_.centerPrice,\\n                    MINIMUM_LIQUIDITY_SWAP\\n                );\\n        }\\n\\n        // from whatever pool higher amount of swap is routing we are taking that as final price, does not matter much because both pools final price should be same\\n        if (temp_ > temp3_) {\\n            // new pool price from col pool\\n            s_.price = swap0to1_\\n                ? ((cs_.tokenOutImaginaryReserves - temp2_) * 1e27) / (cs_.tokenInImaginaryReserves + temp_)\\n                : ((cs_.tokenInImaginaryReserves + temp_) * 1e27) / (cs_.tokenOutImaginaryReserves - temp2_);\\n        } else {\\n            // new pool price from debt pool\\n            s_.price = swap0to1_\\n                ? ((ds_.tokenOutImaginaryReserves - temp4_) * 1e27) / (ds_.tokenInImaginaryReserves + temp3_)\\n                : ((ds_.tokenInImaginaryReserves + temp3_) * 1e27) / (ds_.tokenOutImaginaryReserves - temp4_);\\n        }\\n\\n        // converting into normal token amounts\\n        if (swap0to1_) {\\n            temp_ = ((temp_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\\n            temp3_ = ((temp3_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\\n            // only adding uncheck in out amount\\n            unchecked {\\n                temp2_ = ((temp2_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\\n                temp4_ = ((temp4_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\\n            }\\n        } else {\\n            temp_ = ((temp_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\\n            temp3_ = ((temp3_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\\n            // only adding uncheck in out amount\\n            unchecked {\\n                temp2_ = ((temp2_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\\n                temp4_ = ((temp4_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\\n            }\\n        }\\n\\n        unchecked {\\n            amountOut_ = temp2_ + temp4_;\\n        }\\n\\n        // if address dead then reverting with amountOut\\n        if (to_ == ADDRESS_DEAD) revert FluidDexSwapResult(amountOut_);\\n\\n        if (amountOut_ < amountOutMin_) revert FluidDexError(ErrorTypes.DexT1__NotEnoughAmountOut);\\n\\n        // (temp_ + temp3_) == amountIn_ == msg.value (for native token), if there is revenue cut then this statement is not true\\n        temp_ = (temp_ * s_.revenueCut) / SIX_DECIMALS;\\n        temp3_ = (temp3_ * s_.revenueCut) / SIX_DECIMALS;\\n        // allocating to avoid stack-too-deep error\\n        s_.data = abi.encode(amountIn_, msg.sender);\\n        // deposit & payback token in at liquidity\\n        LIQUIDITY.operate{ value: msg.value }(s_.tokenIn, int(temp_), -int(temp3_), address(0), address(0), s_.data);\\n        // withdraw & borrow token out at liquidity\\n        LIQUIDITY.operate(s_.tokenOut, -int(temp2_), int(temp4_), s_.withdrawTo, s_.borrowTo, new bytes(0));\\n\\n        // if hook exists then calling hook\\n        temp_ = (dexVariables2_ >> 142) & X30;\\n        if (temp_ > 0) {\\n            s_.swap0to1 = swap0to1_;\\n            _hookVerify(temp_, 1, s_.swap0to1, s_.price);\\n        }\\n\\n        swap0to1_\\n            ? _utilizationVerify(((dexVariables2_ >> 238) & X10), EXCHANGE_PRICE_TOKEN_1_SLOT)\\n            : _utilizationVerify(((dexVariables2_ >> 228) & X10), EXCHANGE_PRICE_TOKEN_0_SLOT);\\n\\n        dexVariables = _updateOracle(s_.price, pex_.centerPrice, dexVariables_);\\n\\n        emit Swap(swap0to1_, amountIn_, amountOut_, to_);\\n    }\\n\\n    /// @dev Swap tokens with perfect amount out\\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\\n    /// @param amountOut_ The exact amount of tokens to receive after swap\\n    /// @param amountInMax_ Maximum amount of tokens to swap in\\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\\n    /// @return amountIn_ The amount of input tokens used for the swap\\n    function swapOut(\\n        bool swap0to1_,\\n        uint256 amountOut_,\\n        uint256 amountInMax_,\\n        address to_\\n    ) public payable returns (uint256 amountIn_) {\\n        return\\n            abi.decode(\\n                _spell(\\n                    PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION,\\n                    abi.encodeWithSelector(IFluidDexT1.swapOut.selector, swap0to1_, amountOut_, amountInMax_, to_)\\n                ),\\n                (uint256)\\n            );\\n    }\\n\\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\\n    /// @param shares_ The number of shares to mint\\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\\n    /// @return token0Amt_ Amount of token0 deposited\\n    /// @return token1Amt_ Amount of token1 deposited\\n    function depositPerfect(\\n        uint shares_,\\n        uint maxToken0Deposit_,\\n        uint maxToken1Deposit_,\\n        bool estimate_\\n    ) public payable returns (uint token0Amt_, uint token1Amt_) {\\n        return\\n            abi.decode(\\n                _spell(\\n                    PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION,\\n                    abi.encodeWithSelector(\\n                        IFluidDexT1.depositPerfect.selector,\\n                        shares_,\\n                        maxToken0Deposit_,\\n                        maxToken1Deposit_,\\n                        estimate_\\n                    )\\n                ),\\n                (uint256, uint256)\\n            );\\n    }\\n\\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\\n    /// @param shares_ The number of shares to withdraw\\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\\n    /// @param estimate_ If true, the function will revert with the estimated withdrawal amounts without actually performing the withdrawal\\n    /// @return token0Amt_ The amount of token0 withdrawn\\n    /// @return token1Amt_ The amount of token1 withdrawn\\n    function withdrawPerfect(\\n        uint shares_,\\n        uint minToken0Withdraw_,\\n        uint minToken1Withdraw_,\\n        bool estimate_\\n    ) public returns (uint token0Amt_, uint token1Amt_) {\\n        return\\n            abi.decode(\\n                _spell(\\n                    PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION,\\n                    abi.encodeWithSelector(\\n                        IFluidDexT1.withdrawPerfect.selector,\\n                        shares_,\\n                        minToken0Withdraw_,\\n                        minToken1Withdraw_,\\n                        estimate_\\n                    )\\n                ),\\n                (uint256, uint256)\\n            );\\n    }\\n\\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\\n    /// @param shares_ The number of shares to borrow\\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\\n    /// @param estimate_ If true, function will revert with estimated borrow amounts without executing the borrow\\n    /// @return token0Amt_ Amount of token0 borrowed\\n    /// @return token1Amt_ Amount of token1 borrowed\\n    function borrowPerfect(\\n        uint shares_,\\n        uint minToken0Borrow_,\\n        uint minToken1Borrow_,\\n        bool estimate_\\n    ) public returns (uint token0Amt_, uint token1Amt_) {\\n        return\\n            abi.decode(\\n                _spell(\\n                    PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION,\\n                    abi.encodeWithSelector(\\n                        IFluidDexT1.borrowPerfect.selector,\\n                        shares_,\\n                        minToken0Borrow_,\\n                        minToken1Borrow_,\\n                        estimate_\\n                    )\\n                ),\\n                (uint256, uint256)\\n            );\\n    }\\n\\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\\n    /// @param shares_ The number of shares to pay back\\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\\n    /// @return token0Amt_ Amount of token0 paid back\\n    /// @return token1Amt_ Amount of token1 paid back\\n    function paybackPerfect(\\n        uint shares_,\\n        uint maxToken0Payback_,\\n        uint maxToken1Payback_,\\n        bool estimate_\\n    ) public payable returns (uint token0Amt_, uint token1Amt_) {\\n        return\\n            abi.decode(\\n                _spell(\\n                    PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION,\\n                    abi.encodeWithSelector(\\n                        IFluidDexT1.paybackPerfect.selector,\\n                        shares_,\\n                        maxToken0Payback_,\\n                        maxToken1Payback_,\\n                        estimate_\\n                    )\\n                ),\\n                (uint256, uint256)\\n            );\\n    }\\n\\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\\n    /// @param token0Amt_ The amount of token0 to deposit\\n    /// @param token1Amt_ The amount of token1 to deposit\\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\\n    /// @return shares_ The amount of shares minted for the deposit\\n    function deposit(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint minSharesAmt_,\\n        bool estimate_\\n    ) public payable returns (uint shares_) {\\n        return\\n            abi.decode(\\n                _spell(\\n                    COL_OPERATIONS_IMPLEMENTATION,\\n                    abi.encodeWithSelector(\\n                        IFluidDexT1.deposit.selector,\\n                        token0Amt_,\\n                        token1Amt_,\\n                        minSharesAmt_,\\n                        estimate_\\n                    )\\n                ),\\n                (uint256)\\n            );\\n    }\\n\\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\\n    /// @param token0Amt_ The amount of token0 to withdraw\\n    /// @param token1Amt_ The amount of token1 to withdraw\\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\\n    /// @param estimate_ If true, the function will revert with the estimated shares to burn without actually performing the withdrawal\\n    /// @return shares_ The number of shares burned for the withdrawal\\n    function withdraw(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint maxSharesAmt_,\\n        bool estimate_\\n    ) public returns (uint shares_) {\\n        return\\n            abi.decode(\\n                _spell(\\n                    COL_OPERATIONS_IMPLEMENTATION,\\n                    abi.encodeWithSelector(\\n                        IFluidDexT1.withdraw.selector,\\n                        token0Amt_,\\n                        token1Amt_,\\n                        maxSharesAmt_,\\n                        estimate_\\n                    )\\n                ),\\n                (uint256)\\n            );\\n    }\\n\\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\\n    /// @param token0Amt_ The amount of token0 to borrow\\n    /// @param token1Amt_ The amount of token1 to borrow\\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\\n    /// @param estimate_ If true, only estimates the shares without actually borrowing\\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\\n    function borrow(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint maxSharesAmt_,\\n        bool estimate_\\n    ) public returns (uint shares_) {\\n        return\\n            abi.decode(\\n                _spell(\\n                    DEBT_OPERATIONS_IMPLEMENTATION,\\n                    abi.encodeWithSelector(\\n                        IFluidDexT1.borrow.selector,\\n                        token0Amt_,\\n                        token1Amt_,\\n                        maxSharesAmt_,\\n                        estimate_\\n                    )\\n                ),\\n                (uint256)\\n            );\\n    }\\n\\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\\n    /// @param token0Amt_ The amount of token0 to payback\\n    /// @param token1Amt_ The amount of token1 to payback\\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\\n    /// @return shares_ The amount of borrow shares burned for the payback\\n    function payback(\\n        uint token0Amt_,\\n        uint token1Amt_,\\n        uint minSharesAmt_,\\n        bool estimate_\\n    ) public payable returns (uint shares_) {\\n        return\\n            abi.decode(\\n                _spell(\\n                    DEBT_OPERATIONS_IMPLEMENTATION,\\n                    abi.encodeWithSelector(\\n                        IFluidDexT1.payback.selector,\\n                        token0Amt_,\\n                        token1Amt_,\\n                        minSharesAmt_,\\n                        estimate_\\n                    )\\n                ),\\n                (uint256)\\n            );\\n    }\\n\\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\\n    /// @param shares_ The number of shares to burn for withdrawal\\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\\n    /// @param estimate_ If true, the function will revert with the estimated withdrawal amount without executing the withdrawal\\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\\n    function withdrawPerfectInOneToken(\\n        uint shares_,\\n        uint minToken0_,\\n        uint minToken1_,\\n        bool estimate_\\n    ) public returns (uint withdrawAmt_) {\\n        return\\n            abi.decode(\\n                _spell(\\n                    COL_OPERATIONS_IMPLEMENTATION,\\n                    abi.encodeWithSelector(\\n                        IFluidDexT1.withdrawPerfectInOneToken.selector,\\n                        shares_,\\n                        minToken0_,\\n                        minToken1_,\\n                        estimate_\\n                    )\\n                ),\\n                (uint256)\\n            );\\n    }\\n\\n    /// @dev This function allows users to payback their debt with perfect shares in one token\\n    /// @param shares_ The number of shares to burn for payback\\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\\n    function paybackPerfectInOneToken(\\n        uint shares_,\\n        uint maxToken0_,\\n        uint maxToken1_,\\n        bool estimate_\\n    ) public payable returns (uint paybackAmt_) {\\n        return\\n            abi.decode(\\n                _spell(\\n                    DEBT_OPERATIONS_IMPLEMENTATION,\\n                    abi.encodeWithSelector(\\n                        IFluidDexT1.paybackPerfectInOneToken.selector,\\n                        shares_,\\n                        maxToken0_,\\n                        maxToken1_,\\n                        estimate_\\n                    )\\n                ),\\n                (uint256)\\n            );\\n    }\\n\\n    /// @dev liquidity callback for cheaper token transfers in case of deposit or payback.\\n    /// only callable by Liquidity during an operation.\\n    function liquidityCallback(address token_, uint amount_, bytes calldata data_) external {\\n        if (msg.sender != address(LIQUIDITY)) revert FluidDexError(ErrorTypes.DexT1__MsgSenderNotLiquidity);\\n        if (dexVariables & 1 == 0) revert FluidDexError(ErrorTypes.DexT1__ReentrancyBitShouldBeOn);\\n\\n        if (data_.length == 64) {\\n            (uint amountWithRevenueCut_, address from_) = abi.decode(data_, (uint, address));\\n            // not checking if amountWithRevenueCut_ > amount_, because it will be and if it's less than liquidity layer will throw.\\n            SafeTransfer.safeTransferFrom(token_, from_, address(LIQUIDITY), amountWithRevenueCut_);\\n        } else {\\n            SafeTransfer.safeTransferFrom(token_, abi.decode(data_, (address)), address(LIQUIDITY), amount_);\\n        }\\n    }\\n\\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\\n    /// but the difference due to interest will be super low so this difference is ignored\\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\\n    /// @return currentPrice_ price of pool after the most recent swap\\n    function oraclePrice(\\n        uint[] memory secondsAgos_\\n    ) external view returns (Oracle[] memory twaps_, uint currentPrice_) {\\n        OraclePriceMemory memory o_;\\n\\n        uint dexVariables_ = dexVariables;\\n        twaps_ = new Oracle[](secondsAgos_.length);\\n\\n        uint totalTime_;\\n        uint time_;\\n\\n        uint i;\\n        uint secondsAgo_ = secondsAgos_[0];\\n\\n        currentPrice_ = (dexVariables_ >> 41) & X40;\\n        currentPrice_ = (currentPrice_ >> DEFAULT_EXPONENT_SIZE) << (currentPrice_ & DEFAULT_EXPONENT_MASK);\\n        uint price_ = currentPrice_;\\n        o_.lowestPrice1by0 = currentPrice_;\\n        o_.highestPrice1by0 = currentPrice_;\\n\\n        uint twap1by0_;\\n        uint twap0by1_;\\n\\n        uint j;\\n\\n        o_.oracleSlot = (dexVariables_ >> 176) & X3;\\n        o_.oracleMap = (dexVariables_ >> 179) & X16;\\n        // if o_.oracleSlot == 7 then it'll enter the if statement in the below while loop\\n        o_.oracle = o_.oracleSlot < 7 ? _oracle[o_.oracleMap] : 0;\\n\\n        uint slotData_;\\n        uint percentDiff_;\\n\\n        if (((dexVariables_ >> 121) & X33) < block.timestamp) {\\n            // last swap didn't occured in this block.\\n            // hence last price is current price of pool & also the last price\\n            time_ = block.timestamp - ((dexVariables_ >> 121) & X33);\\n        } else {\\n            // last swap occured in this block, that means current price is active for 0 secs. Hence TWAP for it will be 0.\\n            ++j;\\n        }\\n\\n        while (true) {\\n            if (j == 2) {\\n                if (++o_.oracleSlot == 8) {\\n                    o_.oracleSlot = 0;\\n                    if (o_.oracleMap == 0) {\\n                        o_.oracleMap = TOTAL_ORACLE_MAPPING;\\n                    }\\n                    o_.oracle = _oracle[--o_.oracleMap];\\n                }\\n\\n                slotData_ = (o_.oracle >> (o_.oracleSlot * 32)) & X32;\\n                if (slotData_ > 0) {\\n                    time_ = slotData_ & X9;\\n                    if (time_ == 0) {\\n                        // time is in precision & sign bits\\n                        time_ = slotData_ >> 9;\\n                        // if o_.oracleSlot is 7 then precision & bits and stored in 1 less map\\n                        if (o_.oracleSlot == 7) {\\n                            o_.oracleSlot = 0;\\n                            if (o_.oracleMap == 0) {\\n                                o_.oracleMap = TOTAL_ORACLE_MAPPING;\\n                            }\\n                            o_.oracle = _oracle[--o_.oracleMap];\\n                            slotData_ = o_.oracle & X32;\\n                        } else {\\n                            ++o_.oracleSlot;\\n                            slotData_ = (o_.oracle >> (o_.oracleSlot * 32)) & X32;\\n                        }\\n                    }\\n                    percentDiff_ = slotData_ >> 10;\\n                    percentDiff_ = (ORACLE_LIMIT * percentDiff_) / X22;\\n                    if (((slotData_ >> 9) & 1 == 1)) {\\n                        // if positive then old price was lower than current hence subtracting\\n                        price_ = price_ - (price_ * percentDiff_) / ORACLE_PRECISION;\\n                    } else {\\n                        // if negative then old price was higher than current hence adding\\n                        price_ = price_ + (price_ * percentDiff_) / ORACLE_PRECISION;\\n                    }\\n                } else {\\n                    // oracle data does not exist. Probably due to pool recently got initialized and not have much swaps.\\n                    revert FluidDexError(ErrorTypes.DexT1__InsufficientOracleData);\\n                }\\n            } else if (j == 1) {\\n                // last & last to last price\\n                price_ = (dexVariables_ >> 1) & X40;\\n                price_ = (price_ >> DEFAULT_EXPONENT_SIZE) << (price_ & DEFAULT_EXPONENT_MASK);\\n                time_ = (dexVariables_ >> 154) & X22;\\n                ++j;\\n            } else if (j == 0) {\\n                ++j;\\n            }\\n\\n            totalTime_ += time_;\\n            if (o_.lowestPrice1by0 > price_) o_.lowestPrice1by0 = price_;\\n            if (o_.highestPrice1by0 < price_) o_.highestPrice1by0 = price_;\\n            if (totalTime_ < secondsAgo_) {\\n                twap1by0_ += price_ * time_;\\n                twap0by1_ += (1e54 / price_) * time_;\\n            } else {\\n                time_ = time_ + secondsAgo_ - totalTime_;\\n                twap1by0_ += price_ * time_;\\n                twap0by1_ += (1e54 / price_) * time_;\\n                // also auto checks that secondsAgos_ should not be == 0\\n                twap1by0_ = twap1by0_ / secondsAgo_;\\n                twap0by1_ = twap0by1_ / secondsAgo_;\\n\\n                twaps_[i] = Oracle(\\n                    twap1by0_,\\n                    o_.lowestPrice1by0,\\n                    o_.highestPrice1by0,\\n                    twap0by1_,\\n                    (1e54 / o_.highestPrice1by0),\\n                    (1e54 / o_.lowestPrice1by0)\\n                );\\n\\n                // TWAP for next secondsAgo will start with price_\\n                o_.lowestPrice1by0 = price_;\\n                o_.highestPrice1by0 = price_;\\n\\n                while (++i < secondsAgos_.length) {\\n                    // secondsAgo_ = [60, 15, 0]\\n                    time_ = totalTime_ - secondsAgo_;\\n                    // updating total time as new seconds ago started\\n                    totalTime_ = time_;\\n                    // also auto checks that secondsAgos_[i + 1] > secondsAgos_[i]\\n                    secondsAgo_ = secondsAgos_[i] - secondsAgos_[i - 1];\\n                    if (totalTime_ < secondsAgo_) {\\n                        twap1by0_ = price_ * time_;\\n                        twap0by1_ = (1e54 / price_) * time_;\\n                        // if time_ comes out as 0 here then lowestPrice & highestPrice should not be price_, it should be next price_ that we will calculate\\n                        if (time_ == 0) {\\n                            o_.lowestPrice1by0 = type(uint).max;\\n                            o_.highestPrice1by0 = 0;\\n                        }\\n                        break;\\n                    } else {\\n                        time_ = time_ + secondsAgo_ - totalTime_;\\n                        // twap1by0_ = price_ here\\n                        twap1by0_ = price_ * time_;\\n                        // twap0by1_ = (1e54 / price_) * time_;\\n                        twap0by1_ = (1e54 / price_) * time_;\\n                        twap1by0_ = twap1by0_ / secondsAgo_;\\n                        twap0by1_ = twap0by1_ / secondsAgo_;\\n                        twaps_[i] = Oracle(\\n                            twap1by0_,\\n                            o_.lowestPrice1by0,\\n                            o_.highestPrice1by0,\\n                            twap0by1_,\\n                            (1e54 / o_.highestPrice1by0),\\n                            (1e54 / o_.lowestPrice1by0)\\n                        );\\n                    }\\n                }\\n                if (i == secondsAgos_.length) return (twaps_, currentPrice_); // oracle fetch over\\n            }\\n        }\\n    }\\n\\n    function getPricesAndExchangePrices() public {\\n        uint dexVariables_ = dexVariables;\\n        uint dexVariables2_ = dexVariables2;\\n\\n        _check(dexVariables_, dexVariables2_);\\n\\n        PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables, dexVariables2);\\n\\n        revert FluidDexPricesAndExchangeRates(pex_);\\n    }\\n\\n    /// @dev Internal fallback function to handle calls to non-existent functions\\n    /// @notice This function is called when a transaction is sent to the contract without matching any other function\\n    /// @notice It checks if the caller is authorized, enables re-entrancy protection, delegates the call to the admin implementation, and then disables re-entrancy protection\\n    /// @notice Only authorized callers (global or dex auth) can trigger this function\\n    /// @notice This function uses assembly to perform a delegatecall to the admin implementation to update configs related to DEX\\n    function _fallback() private {\\n        if (!(DEX_FACTORY.isGlobalAuth(msg.sender) || DEX_FACTORY.isDexAuth(address(this), msg.sender))) {\\n            revert FluidDexError(ErrorTypes.DexT1__NotAnAuth);\\n        }\\n\\n        uint dexVariables_ = dexVariables;\\n        if (dexVariables_ & 1 == 1) revert FluidDexError(ErrorTypes.DexT1__AlreadyEntered);\\n        // enabling re-entrancy\\n        dexVariables = dexVariables_ | 1;\\n\\n        // Delegate the current call to `ADMIN_IMPLEMENTATION`.\\n        _spell(ADMIN_IMPLEMENTATION, msg.data);\\n\\n        // disabling re-entrancy\\n        // directly fetching from storage so updates from Admin module will get auto covered\\n        dexVariables = dexVariables & ~uint(1);\\n    }\\n\\n    fallback() external payable {\\n        _fallback();\\n    }\\n\\n    receive() external payable {\\n        if (msg.sig != 0x00000000) {\\n            _fallback();\\n        }\\n    }\\n\\n    /// @notice returns all Vault constants\\n    function constantsView() external view returns (ConstantViews memory constantsView_) {\\n        constantsView_.dexId = DEX_ID;\\n        constantsView_.liquidity = address(LIQUIDITY);\\n        constantsView_.factory = address(DEX_FACTORY);\\n        constantsView_.token0 = TOKEN_0;\\n        constantsView_.token1 = TOKEN_1;\\n        constantsView_.implementations.shift = SHIFT_IMPLEMENTATION;\\n        constantsView_.implementations.admin = ADMIN_IMPLEMENTATION;\\n        constantsView_.implementations.colOperations = COL_OPERATIONS_IMPLEMENTATION;\\n        constantsView_.implementations.debtOperations = DEBT_OPERATIONS_IMPLEMENTATION;\\n        constantsView_.implementations.perfectOperationsAndSwapOut = PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION;\\n        constantsView_.deployerContract = DEPLOYER_CONTRACT;\\n        constantsView_.supplyToken0Slot = SUPPLY_TOKEN_0_SLOT;\\n        constantsView_.borrowToken0Slot = BORROW_TOKEN_0_SLOT;\\n        constantsView_.supplyToken1Slot = SUPPLY_TOKEN_1_SLOT;\\n        constantsView_.borrowToken1Slot = BORROW_TOKEN_1_SLOT;\\n        constantsView_.exchangePriceToken0Slot = EXCHANGE_PRICE_TOKEN_0_SLOT;\\n        constantsView_.exchangePriceToken1Slot = EXCHANGE_PRICE_TOKEN_1_SLOT;\\n        constantsView_.oracleMapping = TOTAL_ORACLE_MAPPING;\\n    }\\n\\n    /// @notice returns all Vault constants\\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_) {\\n        constantsView2_.token0NumeratorPrecision = TOKEN_0_NUMERATOR_PRECISION;\\n        constantsView2_.token0DenominatorPrecision = TOKEN_0_DENOMINATOR_PRECISION;\\n        constantsView2_.token1NumeratorPrecision = TOKEN_1_NUMERATOR_PRECISION;\\n        constantsView2_.token1DenominatorPrecision = TOKEN_1_DENOMINATOR_PRECISION;\\n    }\\n\\n    /// @notice Calculates the real and imaginary reserves for collateral tokens\\n    /// @dev This function retrieves the supply of both tokens from the liquidity layer,\\n    ///      adjusts them based on exchange prices, and calculates imaginary reserves\\n    ///      based on the geometric mean and price range\\n    /// @param geometricMean_ The geometric mean of the token prices\\n    /// @param upperRange_ The upper price range\\n    /// @param lowerRange_ The lower price range\\n    /// @param token0SupplyExchangePrice_ The exchange price for token0 from liquidity layer\\n    /// @param token1SupplyExchangePrice_ The exchange price for token1 from liquidity layer\\n    /// @return c_ A struct containing the calculated real and imaginary reserves for both tokens:\\n    ///         - token0RealReserves: The real reserves of token0\\n    ///         - token1RealReserves: The real reserves of token1\\n    ///         - token0ImaginaryReserves: The imaginary reserves of token0\\n    ///         - token1ImaginaryReserves: The imaginary reserves of token1\\n    function getCollateralReserves(\\n        uint geometricMean_,\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint token0SupplyExchangePrice_,\\n        uint token1SupplyExchangePrice_\\n    ) public view returns (CollateralReserves memory c_) {\\n        return\\n            _getCollateralReserves(\\n                geometricMean_,\\n                upperRange_,\\n                lowerRange_,\\n                token0SupplyExchangePrice_,\\n                token1SupplyExchangePrice_\\n            );\\n    }\\n\\n    /// @notice Calculates the debt reserves for both tokens\\n    /// @param geometricMean_ The geometric mean of the upper and lower price ranges\\n    /// @param upperRange_ The upper price range\\n    /// @param lowerRange_ The lower price range\\n    /// @param token0BorrowExchangePrice_ The exchange price of token0 from liquidity layer\\n    /// @param token1BorrowExchangePrice_ The exchange price of token1 from liquidity layer\\n    /// @return d_ The calculated debt reserves for both tokens, containing:\\n    ///         - token0Debt: The debt amount of token0\\n    ///         - token1Debt: The debt amount of token1\\n    ///         - token0RealReserves: The real reserves of token0 derived from token1 debt\\n    ///         - token1RealReserves: The real reserves of token1 derived from token0 debt\\n    ///         - token0ImaginaryReserves: The imaginary debt reserves of token0\\n    ///         - token1ImaginaryReserves: The imaginary debt reserves of token1\\n    function getDebtReserves(\\n        uint geometricMean_,\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint token0BorrowExchangePrice_,\\n        uint token1BorrowExchangePrice_\\n    ) public view returns (DebtReserves memory d_) {\\n        return\\n            _getDebtReserves(\\n                geometricMean_,\\n                upperRange_,\\n                lowerRange_,\\n                token0BorrowExchangePrice_,\\n                token1BorrowExchangePrice_\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xbdc4288d1b59250f87964de7a5f703dc4048d5a6b388e204fcd1a268a8f64380\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/poolT1/coreModule/core/shift.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { FixedPointMathLib } from \\\"solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\nimport { Variables } from \\\"../../common/variables.sol\\\";\\nimport { ConstantVariables } from \\\"../../common/constantVariables.sol\\\";\\nimport { Events } from \\\"../events.sol\\\";\\nimport { ErrorTypes } from \\\"../../../errorTypes.sol\\\";\\nimport { ICenterPrice } from \\\"../interfaces.sol\\\";\\nimport { AddressCalcs } from \\\"../../../../../libraries/addressCalcs.sol\\\";\\nimport { Error } from \\\"../../../error.sol\\\";\\n\\ncontract FluidDexT1Shift is Variables, ConstantVariables, Events, Error {\\n    address private immutable DEPLOYER_CONTRACT;\\n\\n    address private immutable THIS_CONTRACT;\\n\\n    constructor(address deployerContract_) {\\n        DEPLOYER_CONTRACT = deployerContract_;\\n        THIS_CONTRACT = address(this);\\n    }\\n\\n    modifier _onlyDelegateCall() {\\n        // also indirectly checked by `_check` because pool can never be initialized as long as the initialize method\\n        // is delegate call only, but just to be sure on Admin logic we add the modifier everywhere nonetheless.\\n        if (address(this) == THIS_CONTRACT) {\\n            revert FluidDexError(ErrorTypes.DexT1__OnlyDelegateCallAllowed);\\n        }\\n        _;\\n    }\\n\\n    /// @dev This function calculates the new value of a parameter after a shifting process.\\n    /// @param current_ The current value is the final value where the shift ends\\n    /// @param old_ The old value from where shifting started.\\n    /// @param timePassed_ The time passed since shifting started.\\n    /// @param shiftDuration_ The total duration of the shift when old_ reaches current_\\n    /// @return The new value of the parameter after the shift.\\n    function _calcShiftingDone(\\n        uint current_,\\n        uint old_,\\n        uint timePassed_,\\n        uint shiftDuration_\\n    ) internal pure returns (uint) {\\n        if (current_ > old_) {\\n            uint diff_ = current_ - old_;\\n            current_ = old_ + ((diff_ * timePassed_) / shiftDuration_);\\n        } else {\\n            uint diff_ = old_ - current_;\\n            current_ = old_ - ((diff_ * timePassed_) / shiftDuration_);\\n        }\\n        return current_;\\n    }\\n\\n    /// @dev Calculates the new upper and lower range values during an active range shift\\n    /// @param upperRange_ The target upper range value\\n    /// @param lowerRange_ The target lower range value\\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\\n    /// @return The updated upper range, lower range, and dexVariables2\\n    /// @notice This function handles the gradual shifting of range values over time\\n    /// @notice If the shift is complete, it updates the state and clears the shift data\\n    function _calcRangeShifting(\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint dexVariables2_\\n    ) public _onlyDelegateCall returns (uint, uint, uint) {\\n        uint rangeShift_ = _rangeShift;\\n        uint oldUpperRange_ = rangeShift_ & X20;\\n        uint oldLowerRange_ = (rangeShift_ >> 20) & X20;\\n        uint shiftDuration_ = (rangeShift_ >> 40) & X20;\\n        uint startTimeStamp_ = ((rangeShift_ >> 60) & X33);\\n        if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\\n            // shifting fully done\\n            delete _rangeShift;\\n            // making active shift as 0 because shift is over\\n            // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates from this function and _calcThresholdShifting.\\n            dexVariables2_ = dexVariables2_ & ~uint(1 << 26);\\n            dexVariables2 = dexVariables2_;\\n            return (upperRange_, lowerRange_, dexVariables2_);\\n        }\\n        uint timePassed_ = block.timestamp - startTimeStamp_;\\n        return (\\n            _calcShiftingDone(upperRange_, oldUpperRange_, timePassed_, shiftDuration_),\\n            _calcShiftingDone(lowerRange_, oldLowerRange_, timePassed_, shiftDuration_),\\n            dexVariables2_\\n        );\\n    }\\n\\n    /// @dev Calculates the new upper and lower threshold values during an active threshold shift\\n    /// @param upperThreshold_ The target upper threshold value\\n    /// @param lowerThreshold_ The target lower threshold value\\n    /// @param thresholdTime_ The time passed since shifting started\\n    /// @return The updated upper threshold, lower threshold, and threshold time\\n    /// @notice This function handles the gradual shifting of threshold values over time\\n    /// @notice If the shift is complete, it updates the state and clears the shift data\\n    function _calcThresholdShifting(\\n        uint upperThreshold_,\\n        uint lowerThreshold_,\\n        uint thresholdTime_\\n    ) public _onlyDelegateCall returns (uint, uint, uint) {\\n        uint thresholdShift_ = _thresholdShift;\\n        uint oldUpperThreshold_ = thresholdShift_ & X20;\\n        uint oldLowerThreshold_ = (thresholdShift_ >> 20) & X20;\\n        uint shiftDuration_ = (thresholdShift_ >> 40) & X20;\\n        uint startTimeStamp_ = ((thresholdShift_ >> 60) & X33);\\n        uint oldThresholdTime_ = (thresholdShift_ >> 93) & X24;\\n        if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\\n            // shifting fully done\\n            delete _thresholdShift;\\n            // making active shift as 0 because shift is over\\n            // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates from this function and _calcRangeShifting.\\n            dexVariables2 = dexVariables2 & ~uint(1 << 67);\\n            return (upperThreshold_, lowerThreshold_, thresholdTime_);\\n        }\\n        uint timePassed_ = block.timestamp - startTimeStamp_;\\n        return (\\n            _calcShiftingDone(upperThreshold_, oldUpperThreshold_, timePassed_, shiftDuration_),\\n            _calcShiftingDone(lowerThreshold_, oldLowerThreshold_, timePassed_, shiftDuration_),\\n            _calcShiftingDone(thresholdTime_, oldThresholdTime_, timePassed_, shiftDuration_)\\n        );\\n    }\\n\\n    /// @dev Calculates the new center price during an active price shift\\n    /// @param dexVariables_ The current state of dex variables\\n    /// @param dexVariables2_ Additional dex variables\\n    /// @return newCenterPrice_ The updated center price\\n    /// @notice This function gradually shifts the center price towards a new target price over time\\n    /// @notice It uses an external price source (via ICenterPrice) to determine the target price\\n    /// @notice The shift continues until the current price reaches the target, or the shift duration ends\\n    /// @notice Once the shift is complete, it updates the state and clears the shift data\\n    /// @notice The shift rate is dynamic and depends on:\\n    /// @notice - Time remaining in the shift duration\\n    /// @notice - The new center price (fetched externally, which may change)\\n    /// @notice - The current (old) center price\\n    /// @notice This results in a fuzzy shifting mechanism where the rate can change as these parameters evolve\\n    /// @notice The externally fetched new center price is expected to not differ significantly from the last externally fetched center price\\n    function _calcCenterPrice(\\n        uint dexVariables_,\\n        uint dexVariables2_\\n    ) public _onlyDelegateCall returns (uint newCenterPrice_) {\\n        uint oldCenterPrice_ = (dexVariables_ >> 81) & X40;\\n        oldCenterPrice_ = (oldCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (oldCenterPrice_ & DEFAULT_EXPONENT_MASK);\\n        uint centerPriceShift_ = _centerPriceShift;\\n        uint startTimeStamp_ = centerPriceShift_ & X33;\\n        uint percent_ = (centerPriceShift_ >> 33) & X20;\\n        uint time_ = (centerPriceShift_ >> 53) & X20;\\n\\n        uint fromTimeStamp_ = (dexVariables_ >> 121) & X33;\\n        fromTimeStamp_ = fromTimeStamp_ > startTimeStamp_ ? fromTimeStamp_ : startTimeStamp_;\\n\\n        newCenterPrice_ = ICenterPrice(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, ((dexVariables2_ >> 112) & X30)))\\n            .centerPrice();\\n        uint priceShift_ = (oldCenterPrice_ * percent_ * (block.timestamp - fromTimeStamp_)) / (time_ * SIX_DECIMALS);\\n\\n        if (newCenterPrice_ > oldCenterPrice_) {\\n            // shift on positive side\\n            oldCenterPrice_ += priceShift_;\\n            if (newCenterPrice_ > oldCenterPrice_) {\\n                newCenterPrice_ = oldCenterPrice_;\\n            } else {\\n                // shifting fully done\\n                delete _centerPriceShift;\\n                // making active shift as 0 because shift is over\\n                // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\\n                dexVariables2 = dexVariables2 & ~uint(1 << 248);\\n            }\\n        } else {\\n            unchecked {\\n                oldCenterPrice_ = oldCenterPrice_ > priceShift_ ? oldCenterPrice_ - priceShift_ : 0;\\n                // In case of oldCenterPrice_ ending up 0, which could happen when a lot of time has passed (pool has no swaps for many days or weeks)\\n                // then below we get into the else logic which will fully conclude shifting and return newCenterPrice_\\n                // as it was fetched from the external center price source.\\n                // not ideal that this would ever happen unless the pool is not in use and all/most users have left leaving not enough liquidity to trade on\\n            }\\n            if (newCenterPrice_ < oldCenterPrice_) {\\n                newCenterPrice_ = oldCenterPrice_;\\n            } else {\\n                // shifting fully done\\n                delete _centerPriceShift;\\n                // making active shift as 0 because shift is over\\n                // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\\n                dexVariables2 = dexVariables2 & ~uint(1 << 248);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6f25a6fa24f29a9b463469393f7134605b5a62a4a7765919e2ddff94b8283811\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/poolT1/coreModule/events.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Events {\\n    /// @notice Emitted on token swaps\\n    /// @param swap0to1 Indicates whether the swap is from token0 to token1 or vice-versa.\\n    /// @param amountIn The amount of tokens to be sent to the vault to swap.\\n    /// @param amountOut The amount of tokens user got from the swap.\\n    /// @param to Recepient of swapped tokens.\\n    event Swap(bool swap0to1, uint256 amountIn, uint256 amountOut, address to);\\n\\n    /// @notice Emitted when liquidity is added with shares specified.\\n    /// @param shares Expected exact shares to be received.\\n    /// @param token0Amt Amount of token0 deposited.\\n    /// @param token0Amt Amount of token1 deposited.\\n    event LogDepositPerfectColLiquidity(uint shares, uint token0Amt, uint token1Amt);\\n\\n    /// @notice Emitted when liquidity is withdrawn with shares specified.\\n    /// @param shares shares burned\\n    /// @param token0Amt Amount of token0 withdrawn.\\n    /// @param token1Amt Amount of token1 withdrawn.\\n    event LogWithdrawPerfectColLiquidity(uint shares, uint token0Amt, uint token1Amt);\\n\\n    /// @notice Emitted when liquidity is borrowed with shares specified.\\n    /// @param shares shares minted\\n    /// @param token0Amt Amount of token0 borrowed.\\n    /// @param token1Amt Amount of token1 borrowed.\\n    event LogBorrowPerfectDebtLiquidity(uint shares, uint token0Amt, uint token1Amt);\\n\\n    /// @notice Emitted when liquidity is paid back with shares specified.\\n    /// @param shares shares burned\\n    /// @param token0Amt Amount of token0 paid back.\\n    /// @param token1Amt Amount of token1 paid back.\\n    event LogPaybackPerfectDebtLiquidity(uint shares, uint token0Amt, uint token1Amt);\\n\\n    /// @notice Emitted when liquidity is deposited with specified token0 & token1 amount\\n    /// @param amount0 Amount of token0 deposited.\\n    /// @param amount1 Amount of token1 deposited.\\n    /// @param shares Amount of shares minted.\\n    event LogDepositColLiquidity(uint amount0, uint amount1, uint shares);\\n\\n    /// @notice Emitted when liquidity is withdrawn with specified token0 & token1 amount\\n    /// @param amount0 Amount of token0 withdrawn.\\n    /// @param amount1 Amount of token1 withdrawn.\\n    /// @param shares Amount of shares burned.\\n    event LogWithdrawColLiquidity(uint amount0, uint amount1, uint shares);\\n\\n    /// @notice Emitted when liquidity is borrowed with specified token0 & token1 amount\\n    /// @param amount0 Amount of token0 borrowed.\\n    /// @param amount1 Amount of token1 borrowed.\\n    /// @param shares Amount of shares minted.\\n    event LogBorrowDebtLiquidity(uint amount0, uint amount1, uint shares);\\n\\n    /// @notice Emitted when liquidity is paid back with specified token0 & token1 amount\\n    /// @param amount0 Amount of token0 paid back.\\n    /// @param amount1 Amount of token1 paid back.\\n    /// @param shares Amount of shares burned.\\n    event LogPaybackDebtLiquidity(uint amount0, uint amount1, uint shares);\\n\\n    /// @notice Emitted when liquidity is withdrawn with shares specified into one token only.\\n    /// @param shares shares burned\\n    /// @param token0Amt Amount of token0 withdrawn.\\n    /// @param token1Amt Amount of token1 withdrawn.\\n    event LogWithdrawColInOneToken(uint shares, uint token0Amt, uint token1Amt);\\n\\n    /// @notice Emitted when liquidity is paid back with shares specified from one token only.\\n    /// @param shares shares burned\\n    /// @param token0Amt Amount of token0 paid back.\\n    /// @param token1Amt Amount of token1 paid back.\\n    event LogPaybackDebtInOneToken(uint shares, uint token0Amt, uint token1Amt);\\n\\n    /// @notice Emitted when internal arbitrage between 2 pools happen\\n    /// @param routing if positive then routing is amtIn of token0 in deposit & borrow else token0 withdraw & payback\\n    /// @param amtOut if routing is positive then token1 withdraw & payback amount else token1 deposit & borrow\\n    event LogArbitrage(int routing, uint amtOut);\\n}\\n\",\"keccak256\":\"0x2ccdd6f07486693ec9abccbba5eaaf21ffe1b5436ed961322e663f78b6f1b998\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/poolT1/coreModule/helpers/coreHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { FixedPointMathLib } from \\\"solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\nimport { Variables } from \\\"../../common/variables.sol\\\";\\nimport { ImmutableVariables } from \\\"../immutableVariables.sol\\\";\\nimport { Events } from \\\"../events.sol\\\";\\nimport { ErrorTypes } from \\\"../../../errorTypes.sol\\\";\\nimport { IHook, ICenterPrice } from \\\"../interfaces.sol\\\";\\nimport { LiquiditySlotsLink } from \\\"../../../../../libraries/liquiditySlotsLink.sol\\\";\\nimport { LiquidityCalcs } from \\\"../../../../../libraries/liquidityCalcs.sol\\\";\\nimport { DexSlotsLink } from \\\"../../../../../libraries/dexSlotsLink.sol\\\";\\nimport { DexCalcs } from \\\"../../../../../libraries/dexCalcs.sol\\\";\\nimport { BigMathMinified } from \\\"../../../../../libraries/bigMathMinified.sol\\\";\\nimport { AddressCalcs } from \\\"../../../../../libraries/addressCalcs.sol\\\";\\n\\ninterface IShifting {\\n    /// @dev Calculates the new upper and lower range values during an active range shift\\n    /// @param upperRange_ The target upper range value\\n    /// @param lowerRange_ The target lower range value\\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\\n    /// @return The updated upper range, lower range, and dexVariables2\\n    function _calcRangeShifting(\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint dexVariables2_\\n    ) external returns (uint, uint, uint);\\n\\n    /// @dev Calculates the new threshold values during an active threshold shift\\n    /// @param upperThreshold_ The target upper threshold value\\n    /// @param lowerThreshold_ The target lower threshold value\\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\\n    /// @return The updated upper threshold, lower threshold, and dexVariables2\\n    function _calcThresholdShifting(\\n        uint upperThreshold_,\\n        uint lowerThreshold_,\\n        uint dexVariables2_\\n    ) external returns (uint, uint, uint);\\n\\n    /// @dev Calculates the new center price during an active center price shift\\n    /// @param centerPrice_ The current center price\\n    /// @return The updated center price\\n    function _calcCenterPrice(uint centerPrice_) external returns (uint);\\n}\\n\\nabstract contract CoreHelpers is Variables, ImmutableVariables, Events {\\n    using BigMathMinified for uint256;\\n\\n    /// @dev            do any arbitrary call\\n    /// @param target_  Address to which the call needs to be delegated\\n    /// @param data_    Data to execute at the delegated address\\n    function _spell(address target_, bytes memory data_) internal returns (bytes memory response_) {\\n        assembly {\\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\\n            let size := returndatasize()\\n\\n            response_ := mload(0x40)\\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\\n            mstore(response_, size)\\n            returndatacopy(add(response_, 0x20), 0, size)\\n\\n            if iszero(succeeded) {\\n                // throw if delegatecall failed\\n                returndatacopy(0x00, 0x00, size)\\n                revert(0x00, size)\\n            }\\n        }\\n    }\\n\\n    /// @dev Given an input amount of asset and pair reserves, returns the maximum output amount of the other asset\\n    /// @param amountIn_ The amount of input asset.\\n    /// @param iReserveIn_ Imaginary token reserve with input amount.\\n    /// @param iReserveOut_ Imaginary token reserve of output amount.\\n    function _getAmountOut(\\n        uint256 amountIn_,\\n        uint iReserveIn_,\\n        uint iReserveOut_\\n    ) internal pure returns (uint256 amountOut_) {\\n        unchecked {\\n            // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\\n            uint256 numerator_ = amountIn_ * iReserveOut_;\\n            uint256 denominator_ = iReserveIn_ + amountIn_;\\n\\n            // Using the swap formula: (AmountIn * iReserveY) / (iReserveX + AmountIn)\\n            amountOut_ = numerator_ / denominator_;\\n        }\\n    }\\n\\n    /// @dev Given an output amount of asset and pair reserves, returns the input amount of the other asset\\n    /// @param amountOut_ Desired output amount of the asset.\\n    /// @param iReserveIn_ Imaginary token reserve of input amount.\\n    /// @param iReserveOut_ Imaginary token reserve of output amount.\\n    function _getAmountIn(\\n        uint256 amountOut_,\\n        uint iReserveIn_,\\n        uint iReserveOut_\\n    ) internal pure returns (uint256 amountIn_) {\\n        // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\\n        uint256 numerator_ = amountOut_ * iReserveIn_;\\n        uint256 denominator_ = iReserveOut_ - amountOut_;\\n\\n        // Using the swap formula: (AmountOut * iReserveX) / (iReserveY - AmountOut)\\n        amountIn_ = numerator_ / denominator_;\\n    }\\n\\n    /// @param t total amount in\\n    /// @param x imaginary reserves of token out of collateral\\n    /// @param y imaginary reserves of token in of collateral\\n    /// @param x2 imaginary reserves of token out of debt\\n    /// @param y2 imaginary reserves of token in of debt\\n    /// @return a_ how much swap should go through collateral pool. Remaining will go from debt\\n    /// note if a < 0 then entire trade route through debt pool and debt pool arbitrage with col pool\\n    /// note if a > t then entire trade route through col pool and col pool arbitrage with debt pool\\n    /// note if a > 0 & a < t then swap will route through both pools\\n    function _swapRoutingIn(uint t, uint x, uint y, uint x2, uint y2) internal pure returns (int a_) {\\n        // Main equations:\\n        // 1. out = x * a / (y + a)\\n        // 2. out2 = x2 * (t - a) / (y2 + (t - a))\\n        // final price should be same\\n        // 3. (y + a) / (x - out) = (y2 + (t - a)) / (x2 - out2)\\n        // derivation: https://chatgpt.com/share/dce6f381-ee5f-4d5f-b6ea-5996e84d5b57\\n\\n        // adding 1e18 precision\\n        uint xyRoot_ = FixedPointMathLib.sqrt(x * y * 1e18);\\n        uint x2y2Root_ = FixedPointMathLib.sqrt(x2 * y2 * 1e18);\\n\\n        a_ = (int(y2 * xyRoot_ + t * xyRoot_) - int(y * x2y2Root_)) / int(xyRoot_ + x2y2Root_);\\n    }\\n\\n    /// @param t total amount out\\n    /// @param x imaginary reserves of token in of collateral\\n    /// @param y imaginary reserves of token out of collateral\\n    /// @param x2 imaginary reserves of token in of debt\\n    /// @param y2 imaginary reserves of token out of debt\\n    /// @return a_ how much swap should go through collateral pool. Remaining will go from debt\\n    /// note if a < 0 then entire trade route through debt pool and debt pool arbitrage with col pool\\n    /// note if a > t then entire trade route through col pool and col pool arbitrage with debt pool\\n    /// note if a > 0 & a < t then swap will route through both pools\\n    function _swapRoutingOut(uint t, uint x, uint y, uint x2, uint y2) internal pure returns (int a_) {\\n        // Main equations:\\n        // 1. in = (x * a) / (y - a)\\n        // 2. in2 = (x2 * (t - a)) / (y2 - (t - a))\\n        // final price should be same\\n        // 3. (y - a) / (x + in) = (y2 - (t - a)) / (x2 + in2)\\n        // derivation: https://chatgpt.com/share/6585bc28-841f-49ec-aea2-1e5c5b7f4fa9\\n\\n        // adding 1e18 precision\\n        uint xyRoot_ = FixedPointMathLib.sqrt(x * y * 1e18);\\n        uint x2y2Root_ = FixedPointMathLib.sqrt(x2 * y2 * 1e18);\\n\\n        // 1e18 precision gets cancelled out in division\\n        a_ = (int(t * xyRoot_ + y * x2y2Root_) - int(y2 * xyRoot_)) / int(xyRoot_ + x2y2Root_);\\n    }\\n\\n    function _utilizationVerify(uint utilizationLimit_, bytes32 exchangePriceSlot_) internal view {\\n        if (utilizationLimit_ < THREE_DECIMALS) {\\n            utilizationLimit_ = utilizationLimit_ * 10;\\n            // extracting utilization of token from liquidity layer\\n            uint liquidityLayerUtilization_ = LIQUIDITY.readFromStorage(exchangePriceSlot_);\\n            liquidityLayerUtilization_ =\\n                (liquidityLayerUtilization_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) &\\n                X14;\\n            // Note: this can go slightly above the utilization limit if no update is written to storage at liquidity layer\\n            // if swap was not big enough to go far enough above or any other storage update threshold write cause there\\n            // so just to keep in mind when configuring the actual limit reachable can be utilizationLimit_ + storageUpdateThreshold at Liquidity\\n            if (liquidityLayerUtilization_ > utilizationLimit_)\\n                revert FluidDexError(ErrorTypes.DexT1__LiquidityLayerTokenUtilizationCapReached);\\n        }\\n    }\\n\\n    function _check(uint dexVariables_, uint dexVariables2_) internal {\\n        if (dexVariables_ & 1 == 1) revert FluidDexError(ErrorTypes.DexT1__AlreadyEntered);\\n        if (dexVariables2_ & 3 == 0) revert FluidDexError(ErrorTypes.DexT1__PoolNotInitialized);\\n        // enabling re-entrancy\\n        dexVariables = dexVariables_ | 1;\\n    }\\n\\n    /// @dev if token0 reserves are too low w.r.t token1 then revert, this is to avoid edge case scenario and making sure that precision on calculations should be high enough\\n    function _verifyToken0Reserves(\\n        uint token0Reserves_,\\n        uint token1Reserves_,\\n        uint centerPrice_,\\n        uint minLiquidity_\\n    ) internal pure {\\n        if (((token0Reserves_) < ((token1Reserves_ * 1e27) / (centerPrice_ * minLiquidity_)))) {\\n            revert FluidDexError(ErrorTypes.DexT1__TokenReservesTooLow);\\n        }\\n    }\\n\\n    /// @dev if token1 reserves are too low w.r.t token0 then revert, this is to avoid edge case scenario and making sure that precision on calculations should be high enough\\n    function _verifyToken1Reserves(\\n        uint token0Reserves_,\\n        uint token1Reserves_,\\n        uint centerPrice_,\\n        uint minLiquidity_\\n    ) internal pure {\\n        if (((token1Reserves_) < ((token0Reserves_ * centerPrice_) / (1e27 * minLiquidity_)))) {\\n            revert FluidDexError(ErrorTypes.DexT1__TokenReservesTooLow);\\n        }\\n    }\\n\\n    function _verifySwapAndNonPerfectActions(uint amountAdjusted_, uint amount_) internal pure {\\n        // after shifting amount should not become 0\\n        // limiting to six decimals which means in case of USDC, USDT it's 1 wei, for WBTC 100 wei, for ETH 1000 gwei\\n        if (amountAdjusted_ < SIX_DECIMALS || amountAdjusted_ > X96 || amount_ < TWO_DECIMALS || amount_ > X128)\\n            revert FluidDexError(ErrorTypes.DexT1__LimitingAmountsSwapAndNonPerfectActions);\\n    }\\n\\n    /// @dev Calculates the new upper and lower range values during an active range shift\\n    /// @param upperRange_ The target upper range value\\n    /// @param lowerRange_ The target lower range value\\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\\n    /// @return The updated upper range, lower range, and dexVariables2\\n    /// @notice This function handles the gradual shifting of range values over time\\n    /// @notice If the shift is complete, it updates the state and clears the shift data\\n    function _calcRangeShifting(\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint dexVariables2_\\n    ) internal returns (uint, uint, uint) {\\n        return\\n            abi.decode(\\n                _spell(\\n                    SHIFT_IMPLEMENTATION,\\n                    abi.encodeWithSelector(\\n                        IShifting._calcRangeShifting.selector,\\n                        upperRange_,\\n                        lowerRange_,\\n                        dexVariables2_\\n                    )\\n                ),\\n                (uint, uint, uint)\\n            );\\n    }\\n\\n    /// @dev Calculates the new upper and lower threshold values during an active threshold shift\\n    /// @param upperThreshold_ The target upper threshold value\\n    /// @param lowerThreshold_ The target lower threshold value\\n    /// @param thresholdTime_ The time passed since shifting started\\n    /// @return The updated upper threshold, lower threshold, and threshold time\\n    /// @notice This function handles the gradual shifting of threshold values over time\\n    /// @notice If the shift is complete, it updates the state and clears the shift data\\n    function _calcThresholdShifting(\\n        uint upperThreshold_,\\n        uint lowerThreshold_,\\n        uint thresholdTime_\\n    ) internal returns (uint, uint, uint) {\\n        return\\n            abi.decode(\\n                _spell(\\n                    SHIFT_IMPLEMENTATION,\\n                    abi.encodeWithSelector(\\n                        IShifting._calcThresholdShifting.selector,\\n                        upperThreshold_,\\n                        lowerThreshold_,\\n                        thresholdTime_\\n                    )\\n                ),\\n                (uint, uint, uint)\\n            );\\n    }\\n\\n    /// @dev Calculates the new center price during an active price shift\\n    /// @param dexVariables_ The current state of dex variables\\n    /// @param dexVariables2_ Additional dex variables\\n    /// @return newCenterPrice_ The updated center price\\n    /// @notice This function gradually shifts the center price towards a new target price over time\\n    /// @notice It uses an external price source (via ICenterPrice) to determine the target price\\n    /// @notice The shift continues until the current price reaches the target, or the shift duration ends\\n    /// @notice Once the shift is complete, it updates the state and clears the shift data\\n    /// @notice The shift rate is dynamic and depends on:\\n    /// @notice - Time remaining in the shift duration\\n    /// @notice - The new center price (fetched externally, which may change)\\n    /// @notice - The current (old) center price\\n    /// @notice This results in a fuzzy shifting mechanism where the rate can change as these parameters evolve\\n    /// @notice The externally fetched new center price is expected to not differ significantly from the last externally fetched center price\\n    function _calcCenterPrice(uint dexVariables_, uint dexVariables2_) internal returns (uint newCenterPrice_) {\\n        return\\n            abi.decode(\\n                _spell(\\n                    SHIFT_IMPLEMENTATION,\\n                    abi.encodeWithSelector(IShifting._calcCenterPrice.selector, dexVariables_, dexVariables2_)\\n                ),\\n                (uint)\\n            );\\n    }\\n\\n    /// @notice Calculates and returns the current prices and exchange prices for the pool\\n    /// @param dexVariables_ The first set of DEX variables containing various pool parameters\\n    /// @param dexVariables2_ The second set of DEX variables containing additional pool parameters\\n    /// @return pex_ A struct containing the calculated prices and exchange prices:\\n    ///         - pex_.lastStoredPrice: The last stored price in 1e27 decimals\\n    ///         - pex_.centerPrice: The calculated or fetched center price in 1e27 decimals\\n    ///         - pex_.upperRange: The upper range price limit in 1e27 decimals\\n    ///         - pex_.lowerRange: The lower range price limit in 1e27 decimals\\n    ///         - pex_.geometricMean: The geometric mean of upper range & lower range in 1e27 decimals\\n    ///         - pex_.supplyToken0ExchangePrice: The current exchange price for supplying token0\\n    ///         - pex_.borrowToken0ExchangePrice: The current exchange price for borrowing token0\\n    ///         - pex_.supplyToken1ExchangePrice: The current exchange price for supplying token1\\n    ///         - pex_.borrowToken1ExchangePrice: The current exchange price for borrowing token1\\n    /// @dev This function performs the following operations:\\n    ///      1. Determines the center price (either from storage, external source, or calculated)\\n    ///      2. Retrieves the last stored price from dexVariables_\\n    ///      3. Calculates the upper and lower range prices based on the center price and range percentages\\n    ///      4. Checks if rebalancing is needed based on threshold settings\\n    ///      5. Adjusts prices if necessary based on the time elapsed and threshold conditions\\n    ///      6. Update the dexVariables2_ if changes were made\\n    ///      7. Returns the calculated prices and exchange prices in the PricesAndExchangePrice struct\\n    function _getPricesAndExchangePrices(\\n        uint dexVariables_,\\n        uint dexVariables2_\\n    ) internal returns (PricesAndExchangePrice memory pex_) {\\n        uint centerPrice_;\\n\\n        if (((dexVariables2_ >> 248) & 1) == 0) {\\n            // centerPrice_ => center price hook\\n            centerPrice_ = (dexVariables2_ >> 112) & X30;\\n            if (centerPrice_ == 0) {\\n                centerPrice_ = (dexVariables_ >> 81) & X40;\\n                centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\\n            } else {\\n                // center price should be fetched from external source. For exmaple, in case of wstETH <> ETH pool,\\n                // we would want the center price to be pegged to wstETH exchange rate into ETH\\n                centerPrice_ = ICenterPrice(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, centerPrice_)).centerPrice();\\n            }\\n        } else {\\n            // an active centerPrice_ shift is going on\\n            centerPrice_ = _calcCenterPrice(dexVariables_, dexVariables2_);\\n        }\\n\\n        uint lastStoredPrice_ = (dexVariables_ >> 41) & X40;\\n        lastStoredPrice_ = (lastStoredPrice_ >> DEFAULT_EXPONENT_SIZE) << (lastStoredPrice_ & DEFAULT_EXPONENT_MASK);\\n\\n        uint upperRange_ = ((dexVariables2_ >> 27) & X20);\\n        uint lowerRange_ = ((dexVariables2_ >> 47) & X20);\\n        if (((dexVariables2_ >> 26) & 1) == 1) {\\n            // an active range shift is going on\\n            (upperRange_, lowerRange_, dexVariables2_) = _calcRangeShifting(upperRange_, lowerRange_, dexVariables2_);\\n        }\\n\\n        unchecked {\\n            // adding into unchecked because upperRange_ & lowerRange_ can only be > 0 & < SIX_DECIMALS\\n            // 1% = 1e4, 100% = 1e6\\n            upperRange_ = (centerPrice_ * SIX_DECIMALS) / (SIX_DECIMALS - upperRange_);\\n            // 1% = 1e4, 100% = 1e6\\n            lowerRange_ = (centerPrice_ * (SIX_DECIMALS - lowerRange_)) / SIX_DECIMALS;\\n        }\\n\\n        bool changed_;\\n        {\\n            // goal will be to keep threshold percents 0 if center price is fetched from external source\\n            // checking if threshold are set non 0 then only rebalancing is on\\n            if (((dexVariables2_ >> 68) & X20) > 0) {\\n                uint upperThreshold_ = (dexVariables2_ >> 68) & X10;\\n                uint lowerThreshold_ = (dexVariables2_ >> 78) & X10;\\n                uint shiftingTime_ = (dexVariables2_ >> 88) & X24;\\n                if (((dexVariables2_ >> 67) & 1) == 1) {\\n                    // if active shift is going on for threshold then calculate threshold real time\\n                    (upperThreshold_, lowerThreshold_, shiftingTime_) = _calcThresholdShifting(\\n                        upperThreshold_,\\n                        lowerThreshold_,\\n                        shiftingTime_\\n                    );\\n                }\\n\\n                unchecked {\\n                    if (\\n                        lastStoredPrice_ >\\n                        (centerPrice_ +\\n                            ((upperRange_ - centerPrice_) * (THREE_DECIMALS - upperThreshold_)) /\\n                            THREE_DECIMALS)\\n                    ) {\\n                        uint timeElapsed_ = block.timestamp - ((dexVariables_ >> 121) & X33);\\n                        // price shifting towards upper range\\n                        if (timeElapsed_ < shiftingTime_) {\\n                            centerPrice_ = centerPrice_ + ((upperRange_ - centerPrice_) * timeElapsed_) / shiftingTime_;\\n                        } else {\\n                            // 100% price shifted\\n                            centerPrice_ = upperRange_;\\n                        }\\n                        changed_ = true;\\n                    } else if (\\n                        lastStoredPrice_ <\\n                        (centerPrice_ -\\n                            ((centerPrice_ - lowerRange_) * (THREE_DECIMALS - lowerThreshold_)) /\\n                            THREE_DECIMALS)\\n                    ) {\\n                        uint timeElapsed_ = block.timestamp - ((dexVariables_ >> 121) & X33);\\n                        // price shifting towards lower range\\n                        if (timeElapsed_ < shiftingTime_) {\\n                            centerPrice_ = centerPrice_ - ((centerPrice_ - lowerRange_) * timeElapsed_) / shiftingTime_;\\n                        } else {\\n                            // 100% price shifted\\n                            centerPrice_ = lowerRange_;\\n                        }\\n                        changed_ = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // temp_ => max center price\\n        uint temp_ = (dexVariables2 >> 172) & X28;\\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n        if (centerPrice_ > temp_) {\\n            // if center price is greater than max center price\\n            centerPrice_ = temp_;\\n            changed_ = true;\\n        } else {\\n            // check if center price is less than min center price\\n            // temp_ => min center price\\n            temp_ = (dexVariables2 >> 200) & X28;\\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n            if (centerPrice_ < temp_) {\\n                centerPrice_ = temp_;\\n                changed_ = true;\\n            }\\n        }\\n\\n        // if centerPrice_ is changed then calculating upper and lower range again\\n        if (changed_) {\\n            upperRange_ = ((dexVariables2_ >> 27) & X20);\\n            lowerRange_ = ((dexVariables2_ >> 47) & X20);\\n            if (((dexVariables2_ >> 26) & 1) == 1) {\\n                (upperRange_, lowerRange_, dexVariables2_) = _calcRangeShifting(\\n                    upperRange_,\\n                    lowerRange_,\\n                    dexVariables2_\\n                );\\n            }\\n\\n            unchecked {\\n                // adding into unchecked because upperRange_ & lowerRange_ can only be > 0 & < SIX_DECIMALS\\n                // 1% = 1e4, 100% = 1e6\\n                upperRange_ = (centerPrice_ * SIX_DECIMALS) / (SIX_DECIMALS - upperRange_);\\n                // 1% = 1e4, 100% = 1e6\\n                lowerRange_ = (centerPrice_ * (SIX_DECIMALS - lowerRange_)) / SIX_DECIMALS;\\n            }\\n        }\\n\\n        pex_.lastStoredPrice = lastStoredPrice_;\\n        pex_.centerPrice = centerPrice_;\\n        pex_.upperRange = upperRange_;\\n        pex_.lowerRange = lowerRange_;\\n\\n        unchecked {\\n            if (upperRange_ < 1e38) {\\n                // 1e38 * 1e38 = 1e76 which is less than max uint limit\\n                pex_.geometricMean = FixedPointMathLib.sqrt(upperRange_ * lowerRange_);\\n            } else {\\n                // upperRange_ price is pretty large hence lowerRange_ will also be pretty large\\n                pex_.geometricMean = FixedPointMathLib.sqrt((upperRange_ / 1e18) * (lowerRange_ / 1e18)) * 1e18;\\n            }\\n        }\\n\\n        // Exchange price will remain same as Liquidity Layer\\n        (pex_.supplyToken0ExchangePrice, pex_.borrowToken0ExchangePrice) = LiquidityCalcs.calcExchangePrices(\\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_0_SLOT)\\n        );\\n\\n        (pex_.supplyToken1ExchangePrice, pex_.borrowToken1ExchangePrice) = LiquidityCalcs.calcExchangePrices(\\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_1_SLOT)\\n        );\\n    }\\n\\n    /// @dev getting reserves outside range.\\n    /// @param gp_ is geometric mean pricing of upper percent & lower percent\\n    /// @param pa_ price of upper range or lower range\\n    /// @param rx_ real reserves of token0 or token1\\n    /// @param ry_ whatever is rx_ the other will be ry_\\n    function _calculateReservesOutsideRange(\\n        uint gp_,\\n        uint pa_,\\n        uint rx_,\\n        uint ry_\\n    ) internal pure returns (uint xa_, uint yb_) {\\n        // equations we have:\\n        // 1. x*y = k\\n        // 2. xa*ya = k\\n        // 3. xb*yb = k\\n        // 4. Pa = ya / xa = upperRange_ (known)\\n        // 5. Pb = yb / xb = lowerRange_ (known)\\n        // 6. x - xa = rx = real reserve of x (known)\\n        // 7. y - yb = ry = real reserve of y (known)\\n        // With solving we get:\\n        // ((Pa*Pb)^(1/2) - Pa)*xa^2 + (rx * (Pa*Pb)^(1/2) + ry)*xa + rx*ry = 0\\n        // yb = yb = xa * (Pa * Pb)^(1/2)\\n\\n        // xa = (GP\\u22c5rx + ry + (-rx\\u22c5ry\\u22c54\\u22c5(GP - Pa) + (GP\\u22c5rx + ry)^2)^0.5) / (2Pa - 2GP)\\n        // multiply entire equation by 1e27 to remove the price decimals precision of 1e27\\n        // xa = (GP\\u22c5rx + ry\\u22c51e27 + (rx\\u22c5ry\\u22c54\\u22c5(Pa - GP)\\u22c51e27 + (GP\\u22c5rx + ry\\u22c51e27)^2)^0.5) / 2*(Pa - GP)\\n        // dividing the equation with 2*(Pa - GP). Pa is always > GP so answer will be positive.\\n        // xa = (((GP\\u22c5rx + ry\\u22c51e27) / 2*(Pa - GP)) + (((rx\\u22c5ry\\u22c54\\u22c5(Pa - GP)\\u22c51e27) / 4*(Pa - GP)^2) + ((GP\\u22c5rx + ry\\u22c51e27) / 2*(Pa - GP))^2)^0.5)\\n        // xa = (((GP\\u22c5rx + ry\\u22c51e27) / 2*(Pa - GP)) + (((rx\\u22c5ry\\u22c51e27) / (Pa - GP)) + ((GP\\u22c5rx + ry\\u22c51e27) / 2*(Pa - GP))^2)^0.5)\\n\\n        // dividing in 3 parts for simplification:\\n        // part1 = (Pa - GP)\\n        // part2 = (GP\\u22c5rx + ry\\u22c51e27) / (2*part1)\\n        // part3 = rx\\u22c5ry\\n        // note: part1 will almost always be < 1e28 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e29\\n        uint p1_ = pa_ - gp_;\\n        uint p2_ = ((gp_ * rx_) + (ry_ * 1e27)) / (2 * p1_);\\n        uint p3_ = rx_ * ry_;\\n        // to avoid overflowing\\n        p3_ = (p3_ < 1e50) ? ((p3_ * 1e27) / p1_) : (p3_ / p1_) * 1e27;\\n\\n        // xa = part2 + (part3 + (part2 * part2))^(1/2)\\n        // yb = xa_ * gp_\\n        xa_ = p2_ + FixedPointMathLib.sqrt((p3_ + (p2_ * p2_)));\\n        yb_ = (xa_ * gp_) / 1e27;\\n    }\\n\\n    /// @dev Retrieves collateral amount from liquidity layer for a given token\\n    /// @param supplyTokenSlot_ The storage slot for the supply token data\\n    /// @param tokenExchangePrice_ The exchange price of the token\\n    /// @param isToken0_ Boolean indicating if the token is token0 (true) or token1 (false)\\n    /// @return tokenSupply_ The calculated liquidity collateral amount\\n    function _getLiquidityCollateral(\\n        bytes32 supplyTokenSlot_,\\n        uint tokenExchangePrice_,\\n        bool isToken0_\\n    ) internal view returns (uint tokenSupply_) {\\n        uint tokenSupplyData_ = LIQUIDITY.readFromStorage(supplyTokenSlot_);\\n        tokenSupply_ = (tokenSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\\n        tokenSupply_ = (tokenSupply_ >> DEFAULT_EXPONENT_SIZE) << (tokenSupply_ & DEFAULT_EXPONENT_MASK);\\n\\n        if (tokenSupplyData_ & 1 == 1) {\\n            // supply with interest is on\\n            unchecked {\\n                tokenSupply_ = (tokenSupply_ * tokenExchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\\n            }\\n        }\\n\\n        unchecked {\\n            tokenSupply_ = isToken0_\\n                ? ((tokenSupply_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\\n                : ((tokenSupply_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\\n        }\\n    }\\n\\n    /// @notice Calculates the real and imaginary reserves for collateral tokens\\n    /// @dev This function retrieves the supply of both tokens from the liquidity layer,\\n    ///      adjusts them based on exchange prices, and calculates imaginary reserves\\n    ///      based on the geometric mean and price range\\n    /// @param geometricMean_ The geometric mean of the token prices\\n    /// @param upperRange_ The upper price range\\n    /// @param lowerRange_ The lower price range\\n    /// @param token0SupplyExchangePrice_ The exchange price for token0 from liquidity layer\\n    /// @param token1SupplyExchangePrice_ The exchange price for token1 from liquidity layer\\n    /// @return c_ A struct containing the calculated real and imaginary reserves for both tokens:\\n    ///         - token0RealReserves: The real reserves of token0\\n    ///         - token1RealReserves: The real reserves of token1\\n    ///         - token0ImaginaryReserves: The imaginary reserves of token0\\n    ///         - token1ImaginaryReserves: The imaginary reserves of token1\\n    function _getCollateralReserves(\\n        uint geometricMean_,\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint token0SupplyExchangePrice_,\\n        uint token1SupplyExchangePrice_\\n    ) internal view returns (CollateralReserves memory c_) {\\n        uint token0Supply_ = _getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, token0SupplyExchangePrice_, true);\\n        uint token1Supply_ = _getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, token1SupplyExchangePrice_, false);\\n\\n        if (geometricMean_ < 1e27) {\\n            (c_.token0ImaginaryReserves, c_.token1ImaginaryReserves) = _calculateReservesOutsideRange(\\n                geometricMean_,\\n                upperRange_,\\n                token0Supply_,\\n                token1Supply_\\n            );\\n        } else {\\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\\n            // 1 / geometricMean for new geometricMean\\n            // 1 / lowerRange will become upper range\\n            // 1 / upperRange will become lower range\\n            (c_.token1ImaginaryReserves, c_.token0ImaginaryReserves) = _calculateReservesOutsideRange(\\n                (1e54 / geometricMean_),\\n                (1e54 / lowerRange_),\\n                token1Supply_,\\n                token0Supply_\\n            );\\n        }\\n\\n        c_.token0RealReserves = token0Supply_;\\n        c_.token1RealReserves = token1Supply_;\\n        unchecked {\\n            c_.token0ImaginaryReserves += token0Supply_;\\n            c_.token1ImaginaryReserves += token1Supply_;\\n        }\\n    }\\n\\n    /// @notice Calculates the real and imaginary debt reserves for both tokens\\n    /// @dev This function uses a quadratic equation to determine the debt reserves\\n    ///      based on the geometric mean price and the current debt amounts\\n    /// @param gp_ The geometric mean price of upper range & lower range\\n    /// @param pb_ The price of lower range\\n    /// @param dx_ The debt amount of one token\\n    /// @param dy_ The debt amount of the other token\\n    /// @return rx_ The real debt reserve of the first token\\n    /// @return ry_ The real debt reserve of the second token\\n    /// @return irx_ The imaginary debt reserve of the first token\\n    /// @return iry_ The imaginary debt reserve of the second token\\n    function _calculateDebtReserves(\\n        uint gp_,\\n        uint pb_,\\n        uint dx_,\\n        uint dy_\\n    ) internal pure returns (uint rx_, uint ry_, uint irx_, uint iry_) {\\n        // Assigning letter to knowns:\\n        // c = debtA\\n        // d = debtB\\n        // e = upperPrice\\n        // f = lowerPrice\\n        // g = upperPrice^1/2\\n        // h = lowerPrice^1/2\\n\\n        // c = 1\\n        // d = 2000\\n        // e = 2222.222222\\n        // f = 1800\\n        // g = 2222.222222^1/2\\n        // h = 1800^1/2\\n\\n        // Assigning letter to unknowns:\\n        // w = realDebtReserveA\\n        // x = realDebtReserveB\\n        // y = imaginaryDebtReserveA\\n        // z = imaginaryDebtReserveB\\n        // k = k\\n\\n        // below quadratic will give answer of realDebtReserveB\\n        // A, B, C of quadratic equation:\\n        // A = h\\n        // B = dh - cfg\\n        // C = -cfdh\\n\\n        // A = lowerPrice^1/2\\n        // B = debtB\\u22c5lowerPrice^1/2 - debtA\\u22c5lowerPrice\\u22c5upperPrice^1/2\\n        // C = -(debtA\\u22c5lowerPrice\\u22c5debtB\\u22c5lowerPrice^1/2)\\n\\n        // x = (cfg \\u2212 dh + (4cdf(h^2)+(cfg\\u2212dh)^2))^(1/2)) / 2h\\n        // simplifying dividing by h, note h = f^1/2\\n        // x = ((c\\u22c5g\\u22c5(f^1/2) \\u2212 d) / 2 + ((4\\u22c5c\\u22c5d\\u22c5f\\u22c5f) / (4h^2) + ((c\\u22c5f\\u22c5g) / 2h \\u2212 (d\\u22c5h) / 2h)^2))^(1/2))\\n        // x = ((c\\u22c5g\\u22c5(f^1/2) \\u2212 d) / 2 + ((c\\u22c5d\\u22c5f) + ((c\\u22c5g\\u22c5(f^1/2) \\u2212 d) / 2)^2))^(1/2))\\n\\n        // dividing in 3 parts for simplification:\\n        // part1 = (c\\u22c5g\\u22c5(f^1/2) \\u2212 d) / 2\\n        // part2 = (c\\u22c5d\\u22c5f)\\n        // x = (part1 + (part2 + part1^2)^(1/2))\\n        // note: part1 will almost always be < 1e27 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e28\\n\\n        // part1 = ((debtA * upperPrice^1/2 * lowerPrice^1/2) - debtB) / 2\\n        // note: upperPrice^1/2 * lowerPrice^1/2 = geometric mean\\n        // part1 = ((debtA * geometricMean) - debtB) / 2\\n        // part2 = debtA * debtB * lowerPrice\\n\\n        // converting decimals properly as price is in 1e27 decimals\\n        // part1 = ((debtA * geometricMean) - (debtB * 1e27)) / (2 * 1e27)\\n        // part2 = (debtA * debtB * lowerPrice) / 1e27\\n        // final x equals:\\n        // x = (part1 + (part2 + part1^2)^(1/2))\\n        int p1_ = (int(dx_ * gp_) - int(dy_ * 1e27)) / (2 * 1e27);\\n        uint p2_ = (dx_ * dy_);\\n        p2_ = p2_ < 1e50 ? (p2_ * pb_) / 1e27 : (p2_ / 1e27) * pb_;\\n        ry_ = uint(p1_ + int(FixedPointMathLib.sqrt((p2_ + uint(p1_ * p1_)))));\\n\\n        // finding z:\\n        // x^2 - zx + cfz = 0\\n        // z*(x - cf) = x^2\\n        // z = x^2 / (x - cf)\\n        // z = x^2 / (x - debtA * lowerPrice)\\n        // converting decimals properly as price is in 1e27 decimals\\n        // z = (x^2 * 1e27) / ((x * 1e27) - (debtA * lowerPrice))\\n\\n        iry_ = ((ry_ * 1e27) - (dx_ * pb_));\\n        if (iry_ < SIX_DECIMALS) {\\n            // almost impossible situation to ever get here\\n            revert FluidDexError(ErrorTypes.DexT1__DebtReservesTooLow);\\n        }\\n        if (ry_ < 1e25) {\\n            iry_ = (ry_ * ry_ * 1e27) / iry_;\\n        } else {\\n            // note: it can never result in negative as final result will always be in positive\\n            iry_ = (ry_ * ry_) / (iry_ / 1e27);\\n        }\\n\\n        // finding y\\n        // x = z * c / (y + c)\\n        // y + c = z * c / x\\n        // y = (z * c / x) - c\\n        // y = (z * debtA / x) - debtA\\n        irx_ = ((iry_ * dx_) / ry_) - dx_;\\n\\n        // finding w\\n        // w = y * d / (z + d)\\n        // w = (y * debtB) / (z + debtB)\\n        rx_ = (irx_ * dy_) / (iry_ + dy_);\\n    }\\n\\n    /// @notice Calculates the debt amount for a given token from liquidity layer\\n    /// @param borrowTokenSlot_ The storage slot for the token's borrow data\\n    /// @param tokenExchangePrice_ The current exchange price of the token\\n    /// @param isToken0_ Boolean indicating if this is for token0 (true) or token1 (false)\\n    /// @return tokenDebt_ The calculated debt amount for the token\\n    function _getLiquidityDebt(\\n        bytes32 borrowTokenSlot_,\\n        uint tokenExchangePrice_,\\n        bool isToken0_\\n    ) internal view returns (uint tokenDebt_) {\\n        uint tokenBorrowData_ = LIQUIDITY.readFromStorage(borrowTokenSlot_);\\n\\n        tokenDebt_ = (tokenBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\\n        tokenDebt_ = (tokenDebt_ >> 8) << (tokenDebt_ & X8);\\n\\n        if (tokenBorrowData_ & 1 == 1) {\\n            // borrow with interest is on\\n            unchecked {\\n                tokenDebt_ = (tokenDebt_ * tokenExchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\\n            }\\n        }\\n\\n        unchecked {\\n            tokenDebt_ = isToken0_\\n                ? ((tokenDebt_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\\n                : ((tokenDebt_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\\n        }\\n    }\\n\\n    /// @notice Calculates the debt reserves for both tokens\\n    /// @param geometricMean_ The geometric mean of the upper and lower price ranges\\n    /// @param upperRange_ The upper price range\\n    /// @param lowerRange_ The lower price range\\n    /// @param token0BorrowExchangePrice_ The exchange price of token0 from liquidity layer\\n    /// @param token1BorrowExchangePrice_ The exchange price of token1 from liquidity layer\\n    /// @return d_ The calculated debt reserves for both tokens, containing:\\n    ///         - token0Debt: The debt amount of token0\\n    ///         - token1Debt: The debt amount of token1\\n    ///         - token0RealReserves: The real reserves of token0 derived from token1 debt\\n    ///         - token1RealReserves: The real reserves of token1 derived from token0 debt\\n    ///         - token0ImaginaryReserves: The imaginary debt reserves of token0\\n    ///         - token1ImaginaryReserves: The imaginary debt reserves of token1\\n    function _getDebtReserves(\\n        uint geometricMean_,\\n        uint upperRange_,\\n        uint lowerRange_,\\n        uint token0BorrowExchangePrice_,\\n        uint token1BorrowExchangePrice_\\n    ) internal view returns (DebtReserves memory d_) {\\n        uint token0Debt_ = _getLiquidityDebt(BORROW_TOKEN_0_SLOT, token0BorrowExchangePrice_, true);\\n        uint token1Debt_ = _getLiquidityDebt(BORROW_TOKEN_1_SLOT, token1BorrowExchangePrice_, false);\\n\\n        d_.token0Debt = token0Debt_;\\n        d_.token1Debt = token1Debt_;\\n\\n        if (geometricMean_ < 1e27) {\\n            (\\n                d_.token0RealReserves,\\n                d_.token1RealReserves,\\n                d_.token0ImaginaryReserves,\\n                d_.token1ImaginaryReserves\\n            ) = _calculateDebtReserves(geometricMean_, lowerRange_, token0Debt_, token1Debt_);\\n        } else {\\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\\n            // 1 / geometricMean for new geometricMean\\n            // 1 / lowerRange will become upper range\\n            // 1 / upperRange will become lower range\\n            (\\n                d_.token1RealReserves,\\n                d_.token0RealReserves,\\n                d_.token1ImaginaryReserves,\\n                d_.token0ImaginaryReserves\\n            ) = _calculateDebtReserves((1e54 / geometricMean_), (1e54 / upperRange_), token1Debt_, token0Debt_);\\n        }\\n    }\\n\\n    function _updateOracle(uint newPrice_, uint centerPrice_, uint dexVariables_) internal returns (uint) {\\n        // time difference between last & current swap\\n        uint timeDiff_ = block.timestamp - ((dexVariables_ >> 121) & X33);\\n\\n        uint temp_;\\n        uint temp2_;\\n        uint temp3_;\\n\\n        if (timeDiff_ > 0) {\\n            // update oracle\\n\\n            // olderPrice_ => temp_\\n            temp_ = (dexVariables_ >> 1) & X40;\\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n            // oldPrice_ => temp2_\\n            temp2_ = (dexVariables_ >> 41) & X40;\\n            temp2_ = (temp2_ >> DEFAULT_EXPONENT_SIZE) << (temp2_ & DEFAULT_EXPONENT_MASK);\\n\\n            // check newPrice_ & oldPrice_ difference should not be more than 5%\\n            // old price w.r.t new price\\n            int priceDiff_ = int(ORACLE_PRECISION) - int((temp2_ * ORACLE_PRECISION) / newPrice_);\\n\\n            unchecked {\\n                if ((priceDiff_ > int(ORACLE_LIMIT)) || (priceDiff_ < -int(ORACLE_LIMIT))) {\\n                    // if oracle price difference is more than 5% then revert\\n                    // in 1 swap price should only change by <= 5%\\n                    // if a total fall by let's say 8% then in current block price can only fall by 5% and\\n                    // in next block it'll fall the remaining 3%\\n                    revert FluidDexError(ErrorTypes.DexT1__OracleUpdateHugeSwapDiff);\\n                }\\n            }\\n\\n            unchecked {\\n                // older price w.r.t old price\\n                priceDiff_ = int(ORACLE_PRECISION) - int((temp_ * ORACLE_PRECISION) / temp2_);\\n            }\\n\\n            // priceDiffInPercentAndSign_ => temp3_\\n            // priceDiff_ will always be lower than ORACLE_LIMIT due to above check\\n            unchecked {\\n                if (priceDiff_ < 0) {\\n                    temp3_ = ((uint(-priceDiff_) * X22) / ORACLE_LIMIT) << 1;\\n                } else {\\n                    // if greater than or equal to 0 then make sign flag 1\\n                    temp3_ = (((uint(priceDiff_) * X22) / ORACLE_LIMIT) << 1) | 1;\\n                }\\n            }\\n\\n            if (timeDiff_ > X22) {\\n                // if time difference is this then that means DEX has been inactive ~45 days\\n                // that means oracle price of this DEX should not be used.\\n                timeDiff_ = X22;\\n            }\\n\\n            // temp_ => lastTimeDiff_\\n            temp_ = (dexVariables_ >> 154) & X22;\\n            uint nextOracleSlot_ = ((dexVariables_ >> 176) & X3);\\n            uint oracleMap_ = (dexVariables_ >> 179) & X16;\\n            if (temp_ > X9) {\\n                if (nextOracleSlot_ > 0) {\\n                    // if greater than 0 then current slot has 2 or more oracle slot empty\\n                    // First 9 bits are of time, so not using that\\n                    temp3_ = (temp3_ << 41) | (temp_ << 9);\\n                    _oracle[oracleMap_] = _oracle[oracleMap_] | (temp3_ << (--nextOracleSlot_ * 32));\\n                    if (nextOracleSlot_ > 0) {\\n                        --nextOracleSlot_;\\n                    } else {\\n                        // if == 0 that means the oracle slots will get filled and shift to next oracle map\\n                        nextOracleSlot_ = 7;\\n                        unchecked {\\n                            oracleMap_ = (oracleMap_ + 1) % TOTAL_ORACLE_MAPPING;\\n                        }\\n                        _oracle[oracleMap_] = 0;\\n                    }\\n                } else {\\n                    // if == 0\\n                    // then seconds will be in last map\\n                    // precision will be in last map + 1\\n                    // Storing precision & sign slot in first precision & sign slot and leaving time slot empty\\n                    temp3_ = temp3_ << 9;\\n                    _oracle[oracleMap_] = _oracle[oracleMap_] | temp3_;\\n                    nextOracleSlot_ = 6; // storing 6 here as 7 is going to occupied right now\\n                    unchecked {\\n                        oracleMap_ = (oracleMap_ + 1) % TOTAL_ORACLE_MAPPING;\\n                    }\\n                    // Storing time in 2nd precision & sign and leaving time slot empty\\n                    _oracle[oracleMap_] = temp_ << ((7 * 32) + 9);\\n                }\\n            } else {\\n                temp3_ = (temp3_ << 9) | temp_;\\n                unchecked {\\n                    if (nextOracleSlot_ < 7) {\\n                        _oracle[oracleMap_] = _oracle[oracleMap_] | (temp3_ << (nextOracleSlot_ * 32));\\n                    } else {\\n                        _oracle[oracleMap_] = temp3_ << ((7 * 32));\\n                    }\\n                }\\n                if (nextOracleSlot_ > 0) {\\n                    --nextOracleSlot_;\\n                } else {\\n                    nextOracleSlot_ = 7;\\n                    unchecked {\\n                        oracleMap_ = (oracleMap_ + 1) % TOTAL_ORACLE_MAPPING;\\n                    }\\n                }\\n            }\\n\\n            // doing this due to stack too deep error when using params memory variables\\n            temp_ = newPrice_;\\n            temp2_ = centerPrice_;\\n            temp3_ = dexVariables_;\\n\\n            // then update last price\\n            temp3_ =\\n                (temp3_ & 0xfffffffffffffff8000000000000000000000000000000000000000000000001) |\\n                (((temp3_ >> 41) & X40) << 1) |\\n                (temp_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN) << 41) |\\n                (temp2_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN) << 81) |\\n                (block.timestamp << 121) |\\n                (timeDiff_ << 154) |\\n                (nextOracleSlot_ << 176) |\\n                (oracleMap_ << 179);\\n        } else {\\n            // temp_ => oldCenterPrice\\n            temp_ = (dexVariables_ >> 81) & X40;\\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n            // Ensure that the center price is within the acceptable range of the old center price if it's not the first swap in the same block\\n            unchecked {\\n                if (\\n                    (centerPrice_ < (((EIGHT_DECIMALS - 1) * temp_) / EIGHT_DECIMALS)) ||\\n                    (centerPrice_ > (((EIGHT_DECIMALS + 1) * temp_) / EIGHT_DECIMALS))\\n                ) {\\n                    revert FluidDexError(ErrorTypes.DexT1__CenterPriceOutOfRange);\\n                }\\n            }\\n\\n            // olderPrice_ => temp_\\n            temp_ = (dexVariables_ >> 1) & X40;\\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\\n\\n            // check newPrice_ & olderPrice_ difference should not be more than 5%\\n            // older price w.r.t new price\\n            int priceDiff_ = int(ORACLE_PRECISION) - int((temp_ * ORACLE_PRECISION) / newPrice_);\\n\\n            if ((priceDiff_ > int(ORACLE_LIMIT)) || (priceDiff_ < -int(ORACLE_LIMIT))) {\\n                // if oracle price difference is more than 5% then revert\\n                // in 1 swap price should only change by <= 5%\\n                // if a total fall by let's say 8% then in current block price can only fall by 5% and\\n                // in next block it'll fall the remaining 3%\\n                revert FluidDexError(ErrorTypes.DexT1__OracleUpdateHugeSwapDiff);\\n            }\\n\\n            // doing this due to stack too deep error when using params memory variables\\n            temp_ = newPrice_;\\n            temp3_ = dexVariables_;\\n            // 2nd swap in same block no need to update anything around oracle, only need to update last swap price in dexVariables\\n            temp3_ =\\n                (temp3_ & 0xfffffffffffffffffffffffffffffffffffffffffffe0000000001ffffffffff) |\\n                (temp_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN) << 41);\\n        }\\n\\n        return temp3_;\\n    }\\n\\n    function _hookVerify(uint hookAddress_, uint mode_, bool swap0to1_, uint price_) internal {\\n        try\\n            IHook(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, hookAddress_)).dexPrice(\\n                mode_,\\n                swap0to1_,\\n                TOKEN_0,\\n                TOKEN_1,\\n                price_\\n            )\\n        returns (bool isOk_) {\\n            if (!isOk_) revert FluidDexError(ErrorTypes.DexT1__HookReturnedFalse);\\n        } catch (bytes memory /*lowLevelData*/) {\\n            // skip checking hook nothing\\n        }\\n    }\\n\\n    constructor(ConstantViews memory constantViews_) ImmutableVariables(constantViews_) {}\\n}\\n\",\"keccak256\":\"0x44688332019d2414eaddadb3f09f54d2cd6c13d7d6fc14da0d9e93a66cc51e1f\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/poolT1/coreModule/immutableVariables.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidLiquidity } from \\\"../../../../liquidity/interfaces/iLiquidity.sol\\\";\\nimport { Structs } from \\\"./structs.sol\\\";\\nimport { ConstantVariables } from \\\"../common/constantVariables.sol\\\";\\nimport { IFluidDexFactory } from \\\"../../interfaces/iDexFactory.sol\\\";\\nimport { Error } from \\\"../../error.sol\\\";\\nimport { ErrorTypes } from \\\"../../errorTypes.sol\\\";\\n\\nabstract contract ImmutableVariables is ConstantVariables, Structs, Error {\\n    /*//////////////////////////////////////////////////////////////\\n                          CONSTANTS / IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public immutable DEX_ID;\\n\\n    /// @dev Address of token 0\\n    address internal immutable TOKEN_0;\\n\\n    /// @dev Address of token 1\\n    address internal immutable TOKEN_1;\\n\\n    address internal immutable THIS_CONTRACT;\\n\\n    uint256 internal immutable TOKEN_0_NUMERATOR_PRECISION;\\n    uint256 internal immutable TOKEN_0_DENOMINATOR_PRECISION;\\n    uint256 internal immutable TOKEN_1_NUMERATOR_PRECISION;\\n    uint256 internal immutable TOKEN_1_DENOMINATOR_PRECISION;\\n\\n    /// @dev Address of liquidity contract\\n    IFluidLiquidity internal immutable LIQUIDITY;\\n\\n    /// @dev Address of DEX factory contract\\n    IFluidDexFactory internal immutable DEX_FACTORY;\\n\\n    /// @dev Address of Shift implementation\\n    address internal immutable SHIFT_IMPLEMENTATION;\\n\\n    /// @dev Address of Admin implementation\\n    address internal immutable ADMIN_IMPLEMENTATION;\\n\\n    /// @dev Address of Col Operations implementation\\n    address internal immutable COL_OPERATIONS_IMPLEMENTATION;\\n\\n    /// @dev Address of Debt Operations implementation\\n    address internal immutable DEBT_OPERATIONS_IMPLEMENTATION;\\n\\n    /// @dev Address of Perfect Operations and Swap Out implementation\\n    address internal immutable PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION;\\n\\n    /// @dev Address of contract used for deploying center price & hook related contract\\n    address internal immutable DEPLOYER_CONTRACT;\\n\\n    /// @dev Liquidity layer slots\\n    bytes32 internal immutable SUPPLY_TOKEN_0_SLOT;\\n    bytes32 internal immutable BORROW_TOKEN_0_SLOT;\\n    bytes32 internal immutable SUPPLY_TOKEN_1_SLOT;\\n    bytes32 internal immutable BORROW_TOKEN_1_SLOT;\\n    bytes32 internal immutable EXCHANGE_PRICE_TOKEN_0_SLOT;\\n    bytes32 internal immutable EXCHANGE_PRICE_TOKEN_1_SLOT;\\n    uint256 internal immutable TOTAL_ORACLE_MAPPING;\\n\\n    function _calcNumeratorAndDenominator(\\n        address token_\\n    ) private view returns (uint256 numerator_, uint256 denominator_) {\\n        uint256 decimals_ = _decimals(token_);\\n        if (decimals_ > TOKENS_DECIMALS_PRECISION) {\\n            numerator_ = 1;\\n            denominator_ = 10 ** (decimals_ - TOKENS_DECIMALS_PRECISION);\\n        } else {\\n            numerator_ = 10 ** (TOKENS_DECIMALS_PRECISION - decimals_);\\n            denominator_ = 1;\\n        }\\n    }\\n\\n    constructor(ConstantViews memory constants_) {\\n        THIS_CONTRACT = address(this);\\n\\n        DEX_ID = constants_.dexId;\\n        LIQUIDITY = IFluidLiquidity(constants_.liquidity);\\n        DEX_FACTORY = IFluidDexFactory(constants_.factory);\\n\\n        TOKEN_0 = constants_.token0;\\n        TOKEN_1 = constants_.token1;\\n\\n        if (TOKEN_0 >= TOKEN_1) revert FluidDexError(ErrorTypes.DexT1__Token0ShouldBeSmallerThanToken1);\\n\\n        (TOKEN_0_NUMERATOR_PRECISION, TOKEN_0_DENOMINATOR_PRECISION) = _calcNumeratorAndDenominator(TOKEN_0);\\n        (TOKEN_1_NUMERATOR_PRECISION, TOKEN_1_DENOMINATOR_PRECISION) = _calcNumeratorAndDenominator(TOKEN_1);\\n\\n        if (constants_.implementations.shift != address(0)) {\\n            SHIFT_IMPLEMENTATION = constants_.implementations.shift;\\n        } else {\\n            SHIFT_IMPLEMENTATION = address(this);\\n        }\\n        if (constants_.implementations.admin != address(0)) {\\n            ADMIN_IMPLEMENTATION = constants_.implementations.admin;\\n        } else {\\n            ADMIN_IMPLEMENTATION = address(this);\\n        }\\n        if (constants_.implementations.colOperations != address(0)) {\\n            COL_OPERATIONS_IMPLEMENTATION = constants_.implementations.colOperations;\\n        } else {\\n            COL_OPERATIONS_IMPLEMENTATION = address(this);\\n        }\\n        if (constants_.implementations.debtOperations != address(0)) {\\n            DEBT_OPERATIONS_IMPLEMENTATION = constants_.implementations.debtOperations;\\n        } else {\\n            DEBT_OPERATIONS_IMPLEMENTATION = address(this);\\n        }\\n        if (constants_.implementations.perfectOperationsAndSwapOut != address(0)) {\\n            PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION = constants_.implementations.perfectOperationsAndSwapOut;\\n        } else {\\n            PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION = address(this);\\n        }\\n\\n        DEPLOYER_CONTRACT = constants_.deployerContract;\\n\\n        SUPPLY_TOKEN_0_SLOT = constants_.supplyToken0Slot;\\n        BORROW_TOKEN_0_SLOT = constants_.borrowToken0Slot;\\n        SUPPLY_TOKEN_1_SLOT = constants_.supplyToken1Slot;\\n        BORROW_TOKEN_1_SLOT = constants_.borrowToken1Slot;\\n        EXCHANGE_PRICE_TOKEN_0_SLOT = constants_.exchangePriceToken0Slot;\\n        EXCHANGE_PRICE_TOKEN_1_SLOT = constants_.exchangePriceToken1Slot;\\n\\n        if (constants_.oracleMapping > X16) revert FluidDexError(ErrorTypes.DexT1__OracleMappingOverflow);\\n\\n        TOTAL_ORACLE_MAPPING = constants_.oracleMapping;\\n    }\\n}\\n\",\"keccak256\":\"0x03a004dfca351193090a40ea5829311a0bfb33c3c433ab8353a40de9c9448f87\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/poolT1/coreModule/interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ninterface IHook {\\n    /// @notice Hook function to check for liquidation opportunities before external swaps\\n    /// @dev The primary use of this hook is to check if a particular pair vault has liquidation available.\\n    ///      If liquidation is available, it gives priority to the liquidation process before allowing external swaps.\\n    ///      In most cases, this hook will not be set.\\n    /// @param id_ Identifier for the operation type: 1 for swap, 2 for internal arbitrage\\n    /// @param swap0to1_ Direction of the swap: true if swapping token0 for token1, false otherwise\\n    /// @param token0_ Address of the first token in the pair\\n    /// @param token1_ Address of the second token in the pair\\n    /// @param price_ The price ratio of token1 to token0, expressed with 27 decimal places\\n    /// @return isOk_ Boolean indicating whether the operation should proceed\\n    function dexPrice(\\n        uint id_,\\n        bool swap0to1_,\\n        address token0_,\\n        address token1_,\\n        uint price_\\n    ) external returns (bool isOk_);\\n}\\n\\ninterface ICenterPrice {\\n    /// @notice Retrieves the center price for the pool\\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\\n    /// @return price The current price ratio of token1 to token0, expressed with 27 decimal places\\n    function centerPrice() external returns (uint price);\\n}\\n\",\"keccak256\":\"0x6e42130fb15dbcfc2850e69bd7f26a1c709a6711cd00c10d2afb7aa1b97cfcc8\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/dex/poolT1/coreModule/structs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Structs {\\n    struct PricesAndExchangePrice {\\n        uint lastStoredPrice; // last stored price in 1e27 decimals\\n        uint centerPrice; // last stored price in 1e27 decimals\\n        uint upperRange; // price at upper range in 1e27 decimals\\n        uint lowerRange; // price at lower range in 1e27 decimals\\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\\n        uint supplyToken0ExchangePrice;\\n        uint borrowToken0ExchangePrice;\\n        uint supplyToken1ExchangePrice;\\n        uint borrowToken1ExchangePrice;\\n    }\\n\\n    struct CollateralReserves {\\n        uint token0RealReserves;\\n        uint token1RealReserves;\\n        uint token0ImaginaryReserves;\\n        uint token1ImaginaryReserves;\\n    }\\n\\n    struct CollateralReservesSwap {\\n        uint tokenInRealReserves;\\n        uint tokenOutRealReserves;\\n        uint tokenInImaginaryReserves;\\n        uint tokenOutImaginaryReserves;\\n    }\\n\\n    struct DebtReserves {\\n        uint token0Debt;\\n        uint token1Debt;\\n        uint token0RealReserves;\\n        uint token1RealReserves;\\n        uint token0ImaginaryReserves;\\n        uint token1ImaginaryReserves;\\n    }\\n\\n    struct DebtReservesSwap {\\n        uint tokenInDebt;\\n        uint tokenOutDebt;\\n        uint tokenInRealReserves;\\n        uint tokenOutRealReserves;\\n        uint tokenInImaginaryReserves;\\n        uint tokenOutImaginaryReserves;\\n    }\\n\\n    struct SwapInMemory {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amtInAdjusted;\\n        address withdrawTo;\\n        address borrowTo;\\n        uint price; // price of pool after swap\\n        uint fee; // fee of pool\\n        uint revenueCut; // revenue cut of pool\\n        bool swap0to1;\\n        int swapRoutingAmt;\\n        bytes data; // just added to avoid stack-too-deep error\\n    }\\n\\n    struct SwapOutMemory {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amtOutAdjusted;\\n        address withdrawTo;\\n        address borrowTo;\\n        uint price; // price of pool after swap\\n        uint fee;\\n        uint revenueCut; // revenue cut of pool\\n        bool swap0to1;\\n        int swapRoutingAmt;\\n        bytes data; // just added to avoid stack-too-deep error\\n        uint msgValue;\\n    }\\n\\n    struct DepositColMemory {\\n        uint256 token0AmtAdjusted;\\n        uint256 token1AmtAdjusted;\\n        uint256 token0ReservesInitial;\\n        uint256 token1ReservesInitial;\\n    }\\n\\n    struct WithdrawColMemory {\\n        uint256 token0AmtAdjusted;\\n        uint256 token1AmtAdjusted;\\n        uint256 token0ReservesInitial;\\n        uint256 token1ReservesInitial;\\n    }\\n\\n    struct BorrowDebtMemory {\\n        uint256 token0AmtAdjusted;\\n        uint256 token1AmtAdjusted;\\n        uint256 token0DebtInitial;\\n        uint256 token1DebtInitial;\\n    }\\n\\n    struct PaybackDebtMemory {\\n        uint256 token0AmtAdjusted;\\n        uint256 token1AmtAdjusted;\\n        uint256 token0DebtInitial;\\n        uint256 token1DebtInitial;\\n    }\\n\\n    struct OraclePriceMemory {\\n        uint lowestPrice1by0;\\n        uint highestPrice1by0;\\n        uint oracleSlot;\\n        uint oracleMap;\\n        uint oracle;\\n    }\\n\\n    struct Oracle {\\n        uint twap1by0; // TWAP price\\n        uint lowestPrice1by0; // lowest price point\\n        uint highestPrice1by0; // highest price point\\n        uint twap0by1; // TWAP price\\n        uint lowestPrice0by1; // lowest price point\\n        uint highestPrice0by1; // highest price point\\n    }\\n\\n    struct Implementations {\\n        address shift;\\n        address admin;\\n        address colOperations;\\n        address debtOperations;\\n        address perfectOperationsAndSwapOut;\\n    }\\n\\n    struct ConstantViews {\\n        uint256 dexId;\\n        address liquidity;\\n        address factory;\\n        Implementations implementations;\\n        address deployerContract;\\n        address token0;\\n        address token1;\\n        bytes32 supplyToken0Slot;\\n        bytes32 borrowToken0Slot;\\n        bytes32 supplyToken1Slot;\\n        bytes32 borrowToken1Slot;\\n        bytes32 exchangePriceToken0Slot;\\n        bytes32 exchangePriceToken1Slot;\\n        uint256 oracleMapping;\\n    }\\n\\n    struct ConstantViews2 {\\n        uint token0NumeratorPrecision;\\n        uint token0DenominatorPrecision;\\n        uint token1NumeratorPrecision;\\n        uint token1DenominatorPrecision;\\n    }\\n}\\n\",\"keccak256\":\"0x9714c6d61ff428f611cee5ac3971678a5de52ae7b39e9b6efa237e2c52ed6ddd\",\"license\":\"BUSL-1.1\"},\"solmate/src/auth/Owned.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xfedb27d14c508342c33eb067c9a02eabcdb0f9dcf93b04ded1001f580d12d0ea\",\"license\":\"AGPL-3.0-only\"},\"solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1b62af9baf5b8e991ed7531bc87f45550ba9d61e8dbff5caf237ccaf3a3fd843\",\"license\":\"AGPL-3.0-only\"},\"solmate/src/utils/SSTORE2.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Read and write to persistent storage at a fraction of the cost.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\\nlibrary SSTORE2 {\\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               WRITE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function write(bytes memory data) internal returns (address pointer) {\\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\\n        bytes memory runtimeCode = abi.encodePacked(hex\\\"00\\\", data);\\n\\n        bytes memory creationCode = abi.encodePacked(\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            hex\\\"60_0B_59_81_38_03_80_92_59_39_F3\\\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\\n        );\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Deploy a new contract with the generated creation code.\\n            // We start 32 bytes into the code to avoid copying the byte length.\\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\\n        }\\n\\n        require(pointer != address(0), \\\"DEPLOYMENT_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               READ LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function read(address pointer) internal view returns (bytes memory) {\\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\\n    }\\n\\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n\\n        return readBytecode(pointer, start, pointer.code.length - start);\\n    }\\n\\n    function read(\\n        address pointer,\\n        uint256 start,\\n        uint256 end\\n    ) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n        end += DATA_OFFSET;\\n\\n        require(pointer.code.length >= end, \\\"OUT_OF_BOUNDS\\\");\\n\\n        return readBytecode(pointer, start, end - start);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function readBytecode(\\n        address pointer,\\n        uint256 start,\\n        uint256 size\\n    ) private view returns (bytes memory data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            data := mload(0x40)\\n\\n            // Update the free memory pointer to prevent overriding our data.\\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\\n            // Adding 31 to size and running the result through the logic above ensures\\n            // the memory pointer remains word-aligned, following the Solidity convention.\\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\\n\\n            // Store the size of the data in the first 32 byte chunk of free memory.\\n            mstore(data, size)\\n\\n            // Copy the code into memory right after the 32 bytes we used to store the size.\\n            extcodecopy(pointer, add(data, 32), start, size)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc5359c92365c550c418725fc534a538426ea8f6e7f6c06c0a9d66647d864469d\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x6102006040523480156200001257600080fd5b50604051620070e0380380620070e08339810160408190526200003591620001a6565b6001600160a01b03808916610120528781166101408190528782166101a05283821660805290821660a052306101e05260405162000073906200015f565b6001600160a01b039091168152602001604051809103906000f080158015620000a0573d6000803e3d6000fd5b506001600160a01b03166101c052604051600090620000bf906200016d565b604051809103906000f080158015620000dc573d6000803e3d6000fd5b506001600160a01b038116610160526101a05160405191925060009162000103906200017b565b6001600160a01b039091168152602001604051809103906000f08015801562000130573d6000803e3d6000fd5b506001600160a01b039081166101805296871660c0525050505090821660e0521661010052506200024e915050565b6104f480620014f583390190565b614a0a80620019e983390190565b610ced80620063f383390190565b80516001600160a01b0381168114620001a157600080fd5b919050565b600080600080600080600080610100898b031215620001c457600080fd5b620001cf8962000189565b9750620001df60208a0162000189565b9650620001ef60408a0162000189565b9550620001ff60608a0162000189565b94506200020f60808a0162000189565b93506200021f60a08a0162000189565b92506200022f60c08a0162000189565b91506200023f60e08a0162000189565b90509295985092959890939650565b60805160a05160c05160e05161010051610120516101405161016051610180516101a0516101c0516101e0516111de62000317600039600081816101f0015261034f01526000818161016b015281816106df015281816107e201526108e5015260008181610192015261059601526000818161014401526105710152600081816102170152610a00015260006101b901526000818160de0152610537015260006102e701526000610312015260006102bc015260006102870152600061025e01526111de6000f3fe608060405234801561001057600080fd5b50600436106100d45760003560e01c8063c758ec5611610081578063cc2fe94b1161005b578063cc2fe94b14610212578063d71f047014610239578063da3d57cb1461024157600080fd5b8063c758ec56146101db578063c995fa7a146101e3578063cc025f7c146101eb57600080fd5b80638cb1b071116100b25780638cb1b071146101665780639603fd271461018d57806397b87b4a146101b457600080fd5b80632861c7d1146100d95780635d5b87e01461012a5780637f2f809e1461013f575b600080fd5b6101007f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b610132610254565b6040516101219190610eb9565b6101007f000000000000000000000000000000000000000000000000000000000000000081565b6101007f000000000000000000000000000000000000000000000000000000000000000081565b6101007f000000000000000000000000000000000000000000000000000000000000000081565b6101007f000000000000000000000000000000000000000000000000000000000000000081565b6101326102b5565b6101326102e0565b6101007f000000000000000000000000000000000000000000000000000000000000000081565b6101007f000000000000000000000000000000000000000000000000000000000000000081565b61013261030b565b61013261024f366004610f2f565b610336565b60606102b06102827f0000000000000000000000000000000000000000000000000000000000000000610b3f565b6102ab7f0000000000000000000000000000000000000000000000000000000000000000610b3f565b610b73565b905090565b60606102b07f0000000000000000000000000000000000000000000000000000000000000000610b3f565b60606102b07f0000000000000000000000000000000000000000000000000000000000000000610b3f565b60606102b07f0000000000000000000000000000000000000000000000000000000000000000610b3f565b606073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036103b0576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261c35660048201526024015b60405180910390fd5b8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1603610419576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261c35360048201526024016103a7565b8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161115610483576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261c35460048201526024016103a7565b610520604080516101c08101825260008082526020808301829052828401829052835160a08101855282815290810182905292830181905260608381018290526080840191909152909190820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c0820181905260e08201819052610100820181905261012082018190526101409091015290565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000811660208084019190915230604080850182905260608501517f0000000000000000000000000000000000000000000000000000000000000000851690527f00000000000000000000000000000000000000000000000000000000000000008416608086015288841660a086015292871660c085015282517f93656c17000000000000000000000000000000000000000000000000000000008152925190926393656c179260048083019391928290030181865afa15801561061c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106409190610f70565b8082526101a082018490526040517f12e366aa00000000000000000000000000000000000000000000000000000000815260009130916312e366aa9161068c9160040190815260200190565b602060405180830381865afa1580156106a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106cd9190610f89565b90506106d98282610beb565b915060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663798133dd6107216102e0565b856040516020016107329190610fad565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529082905261076e929160200161113f565b6040516020818303038152906040526040518263ffffffff1660e01b81526004016107999190610eb9565b6020604051808303816000875af11580156107b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107dc9190610f89565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663798133dd6108246102b5565b866040516020016108359190610fad565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815290829052610871929160200161113f565b6040516020818303038152906040526040518263ffffffff1660e01b815260040161089c9190610eb9565b6020604051808303816000875af11580156108bb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108df9190610f89565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663798133dd61092761030b565b876040516020016109389190610fad565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815290829052610974929160200161113f565b6040516020818303038152906040526040518263ffffffff1660e01b815260040161099f9190610eb9565b6020604051808303816000875af11580156109be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109e29190610f89565b6060808701805173ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000008116602090920191909152815187821660809091015281518682166040919091015290519083169101529050610a53610254565b85604051602001610a649190610fad565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815290829052610aa0929160200161113f565b60405160208183030381529060405295508773ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff167f3fecd5f7aca6136a20a999e7d11ff5dcea4bd675cb125f93ccd7d53f98ec57e48860000151604051610b2b91815260200190565b60405180910390a450505050509392505050565b6060610b6d826001610b688173ffffffffffffffffffffffffffffffffffffffff84163b61116e565b610e54565b92915050565b60606040519050825180825260208201818101602086015b81831015610ba3578051835260209283019201610b8b565b50845184518101855292509050808201602085015b81831015610bd0578051835260209283019201610bb8565b50601f19601f87518501158301011660405250505092915050565b610c88604080516101c08101825260008082526020808301829052828401829052835160a08101855282815290810182905292830181905260608381018290526080840191909152909190820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c0820181905260e08201819052610100820181905261012082018190526101409091015290565b5060a082810180516040805173ffffffffffffffffffffffffffffffffffffffff9586166020808301829052600883850181905284518085038601815260608086018752815191840191909120968a16608080870191909152858a019790975285518086038a01815260c0958601875280519084012060e08c015287518651808501869052600981890181905288518083038a0181528285018a52805190870120928d16828b0152818c019290925287518082038c01815290870188528051908501206101008d0152858c0180518851808701889052808a019590955288518086038a0181528585018a52805190870120908d16858b0152848c015287518085038c01815293870188528351938501939093206101208d01528251875180860196909652858801919091528651808603880181528583018852805190850120908b1697850197909752838901969096528451808403909801885291909201835285519582019590952061014088015292518151908616818501526005818301819052825180830384018152918401835281519185019190912061016088015293518151951685840152848101939093528251808503840181529301909152815191012061018082015290565b60408051603f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168101909152818152818360208301863c9392505050565b60005b83811015610eb0578181015183820152602001610e98565b50506000910152565b6020815260008251806020840152610ed8816040850160208701610e95565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b73ffffffffffffffffffffffffffffffffffffffff81168114610f2c57600080fd5b50565b600080600060608486031215610f4457600080fd5b8335610f4f81610f0a565b92506020840135610f5f81610f0a565b929592945050506040919091013590565b600060208284031215610f8257600080fd5b5051919050565b600060208284031215610f9b57600080fd5b8151610fa681610f0a565b9392505050565b81518152602080830151610240830191610fde9084018273ffffffffffffffffffffffffffffffffffffffff169052565b506040830151611006604084018273ffffffffffffffffffffffffffffffffffffffff169052565b506060830151611064606084018273ffffffffffffffffffffffffffffffffffffffff808251168352806020830151166020840152806040830151166040840152806060830151166060840152806080830151166080840152505050565b50608083015161010061108e8185018373ffffffffffffffffffffffffffffffffffffffff169052565b60a085015191506101206110b98186018473ffffffffffffffffffffffffffffffffffffffff169052565b60c086015192506101406110e48187018573ffffffffffffffffffffffffffffffffffffffff169052565b60e0870151610160878101919091529287015161018080880191909152918701516101a080880191909152908701516101c0870152918601516101e08601528501516102008501529093015161022090920191909152919050565b60008351611151818460208801610e95565b835190830190611165818360208801610e95565b01949350505050565b81810381811115610b6d577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fdfea2646970667358221220585da3d1c1bfc1dc58ae9a7d6d0e76c6c15e66fa855fdb0162a767e80c46d33d64736f6c63430008150033608060405234801561001057600080fd5b506040516104f43803806104f483398101604081905261002f9161007e565b600080546001600160a01b0319166001600160a01b03831690811782556040518392907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a350506100ae565b60006020828403121561009057600080fd5b81516001600160a01b03811681146100a757600080fd5b9392505050565b610437806100bd6000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063798133dd146100465780638da5cb5b14610082578063f2fde38b146100a2575b600080fd5b610059610054366004610352565b6100b7565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b6000546100599073ffffffffffffffffffffffffffffffffffffffff1681565b6100b56100b03660046103c4565b6101c7565b005b6000805473ffffffffffffffffffffffffffffffffffffffff16331461013e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f554e415554484f52495a4544000000000000000000000000000000000000000060448201526064015b60405180910390fd5b61017d83838080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506102b892505050565b60405190915073ffffffffffffffffffffffffffffffffffffffff8216907ff40020e78c6e173ba88aa2c344ed520fab87fe67b9e5aa34626af9d86a3cd47b90600090a292915050565b60005473ffffffffffffffffffffffffffffffffffffffff163314610248576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f554e415554484f52495a454400000000000000000000000000000000000000006044820152606401610135565b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081178255604051909133917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a350565b600081516000036102f5576040517f830297c900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8151602083016000f0905073ffffffffffffffffffffffffffffffffffffffff811661034d576040517f830297c900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b919050565b6000806020838503121561036557600080fd5b823567ffffffffffffffff8082111561037d57600080fd5b818501915085601f83011261039157600080fd5b8135818111156103a057600080fd5b8660208285010111156103b257600080fd5b60209290920196919550909350505050565b6000602082840312156103d657600080fd5b813573ffffffffffffffffffffffffffffffffffffffff811681146103fa57600080fd5b939250505056fea2646970667358221220af536c9afad3ba8d61e4562d1c33e55496e94a329eeae2c137be91332db73f0164736f6c6343000815003360a060405234801561001057600080fd5b50306080526080516149636100a7600039600081816103eb015281816105e6015281816109d301528181610b6201528181610e3601528181611088015281816116040152818161175101528181611861015281816119af01528181611b9b01528181611e27015281816120a7015281816121fb015281816123b4015281816127cf01528181612a2a0152612c2501526149636000f3fe6080604052600436106101445760003560e01c8063999c1446116100c0578063b5c736e411610074578063e53b201711610059578063e53b20171461032c578063e552a1e31461034c578063fbfe2dac1461036c57600080fd5b8063b5c736e4146102db578063ba9af1e31461030c57600080fd5b8063a71e4958116100a5578063a71e49581461027b578063a9a362da1461029b578063b4e1e032146102bb57600080fd5b8063999c14461461023b578063a295521c1461025b57600080fd5b806353a97b41116101175780636552d966116100fc5780636552d966146101fe57806374f04a361461021357806382df16521461022657600080fd5b806353a97b41146101cb5780635cbbba28146101eb57600080fd5b8063021f4f451461014957806326fda0b61461016b5780632af693771461018b57806346887549146101ab575b600080fd5b34801561015557600080fd5b50610169610164366004613e46565b61038c565b005b34801561017757600080fd5b50610169610186366004613fb7565b61058c565b34801561019757600080fd5b506101696101a636600461408f565b610979565b3480156101b757600080fd5b506101696101c63660046140c6565b610b4b565b3480156101d757600080fd5b506101696101e636600461410b565b610ddc565b6101696101f9366004614137565b611071565b34801561020a57600080fd5b506101696115ed565b610169610221366004613e46565b6116f7565b34801561023257600080fd5b5061016961184a565b34801561024757600080fd5b5061016961025636600461408f565b611955565b34801561026757600080fd5b5061016961027636600461420b565b611b41565b34801561028757600080fd5b5061016961029636600461423d565b611dcd565b3480156102a757600080fd5b506101696102b6366004613e46565b61204d565b3480156102c757600080fd5b506101696102d636600461408f565b6121a1565b3480156102e757600080fd5b506102fa6102f6366004613e46565b5490565b60405190815260200160405180910390f35b34801561031857600080fd5b50610169610327366004614269565b61235a565b34801561033857600080fd5b50610169610347366004614344565b6127b8565b34801561035857600080fd5b5061016961036736600461410b565b6129d0565b34801561037857600080fd5b506101696103873660046140c6565b612c0e565b6007600154166000036103d4576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2160048201526024015b60405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610447576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b633fffffff811115610489576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2460048201526024016103cb565b80156105215760003073ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa1580156104dd573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061050191906143ee565b90506000610513826080015184612ed3565b905061051e8161333f565b50505b600180547ffffffffffffffffffffff00000003fffffffffffffffffffffffffffffffffff16608e83901b1790556040517f94102a9d6162476c3137d9fd67d61facaaa3948cf6bf84ee18357a1d5b8c8d67906105819083815260200190565b60405180910390a150565b6007600154166000036105cf576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2160048201526024016103cb565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610642576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b6000805b825181101561093d57610675838281518110610664576106646144d5565b60200260200101516000015161333f565b828181518110610687576106876144d5565b6020026020010151604001516000036106d0576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2660048201526024016103cb565b6127108382815181106106e5576106e56144d5565b602002602001015160200151111561072d576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2460048201526024016103cb565b62ffffff838281518110610743576107436144d5565b602002602001015160400151111561078b576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2460048201526024016103cb565b82818151811061079d5761079d6144d5565b6020026020010151606001516000036107e6576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2660048201526024016103cb565b600360008483815181106107fc576107fc6144d5565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054915060c861087e600a60086000878681518110610862576108626144d5565b602002602001015160600151613397909392919063ffffffff16565b901b60b0848381518110610894576108946144d5565b602002602001015160400151901b60a28584815181106108b6576108b66144d5565b602002602001015160200151901b847ffffffffffc00000000000003ffffffffffffffffffffffffffffffffffffffff1660011717171760036000858481518110610903576109036144d5565b6020908102919091018101515173ffffffffffffffffffffffffffffffffffffffff16825281019190915260400160002055600101610646565b507fd680117828f16ca739150617fc61e326f97e4d9581d61b58992153b92c74fc738260405161096d9190614504565b60405180910390a15050565b6007600154166000036109bc576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2160048201526024016103cb565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610a2f576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b8015801590610a3f575061271081105b15610a7a576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2660048201526024016103cb565b610a86612710826145ad565b9050620186a0821180610a995750606481115b15610ad4576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2460048201526024016103cb565b600180547ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00000316600284901b17601383901b1790557f8708c2a2bbba04e8e9c7448cd64dc109b367341f5504a9835ffb5e7d9ae08ef682610b36612710846145e8565b6040805192835260208301919091520161096d565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610bbe576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b610bc78361333f565b60008215610ca1575073ffffffffffffffffffffffffffffffffffffffff831660009081526003602052604081205490819003610c34576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2760048201526024016103cb565b80600116600103610c75576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2960048201526024016103cb565b73ffffffffffffffffffffffffffffffffffffffff841660009081526003602052604090206001821790555b8115610d79575073ffffffffffffffffffffffffffffffffffffffff831660009081526005602052604081205490819003610d0c576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2760048201526024016103cb565b80600116600103610d4d576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2960048201526024016103cb565b73ffffffffffffffffffffffffffffffffffffffff841660009081526005602052604090206001821790555b6040805173ffffffffffffffffffffffffffffffffffffffff861681528415156020820152831515918101919091527faf3eea5162d915eca532881ca41e1a5292bda2947fe94711cad3b4bb260b57f0906060015b60405180910390a150505050565b600760015416600003610e1f576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2160048201526024016103cb565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610e92576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b633fffffff831180610ea2575081155b80610eaf5750620fffff82115b80610eb8575080155b80610ec55750620fffff81115b15610f00576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2460048201526024016103cb565b8215610ffc5760003073ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa158015610f54573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f7891906143ee565b90506000610f8a826080015186612ed3565b9050610f958161333f565b5050600180547ffeffffffffffffffffffffffffffc0000000ffffffffffffffffffffffffffff16607085901b177f010000000000000000000000000000000000000000000000000000000000000017905542602183901b17603582901b1760085561102a565b600180547ffeffffffffffffffffffffffffffc0000000ffffffffffffffffffffffffffff16905560006008555b60408051848152602081018490529081018290527f06020920d3b0c76370853b723475139901039a0e0d8a2b442b2fc50587a80475906060015b60405180910390a1505050565b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036110e4576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b611101734f6f977acdd1177dcd81ab83074855ecb9c2d49e61333f565b80518061110f575080604001515b611149576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2660048201526024016103cb565b60c08101511580159061116157506127108160c00151105b1561119c576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2660048201526024016103cb565b6127108160c001516111ae91906145ad565b60c08201526101208101516111c6906103e8906145ad565b6101208201526101408101516111df906103e8906145ad565b61014082015260a0810151620186a010806111fe575060648160c00151115b8061121a5750611213612710620f42406145ff565b8160e00151115b80611237575061122f612710620f42406145ff565b816101000151115b80611244575060e0810151155b806112525750610100810151155b8061126357506103e8816101200151115b8061127457506103e8816101400151115b806112825750610120810151155b806112905750610140810151155b8061129e5750610160810151155b806112b0575062ffffff816101600151115b806112c35750633fffffff816101800151115b806112d65750633fffffff816101a00151115b806112ea5750806101e00151816080015111155b806112fe5750806101c00151816080015110155b8061130c57506101e0810151155b15611347576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2460048201526024016103cb565b80516000901561136757611363826020015183608001516134c0565b6001175b81604001511561138757611383826060015183608001516139ce565b6002175b608082015161139b90602060086000613397565b6080830181905276070000f000000000000000000000000000000000000000600182901b602983901b1760519290921b919091174260791b171760009081556101e08301517efa000000000000000000000000000000000000000000000000000000000000917d3e80000000000000000000000000000000000000000000000000000000009160c8916114349190601490600890613397565b6101c0860151911b9060ac9061144f90601460086001613397565b901b608e866101a00151901b6070876101800151901b6058886101600151901b604e896101400151901b60448a6101200151901b602f8b6101000151901b601b8c60e00151901b60138d60c00151901b60028e60a00151901b8d171717171717171717171717176001819055507fa2bd88124c6cef5f905c8de83ae31b7495469be7a44f0a14ec766e4f2926b9e482600001518360400151846020015185606001518660a001516127108860c0015161150891906145e8565b6101808901516101a08a01516040805198151589529615156020890152958701949094526060860192909252608085015260a084015260c083015260e08201526101000160405180910390a17f4df8f1fe60aa37610aa9a5f2958b11c634c2b231797213ea15069cd214bfb7888260e001518361010001516103e885610120015161159391906145e8565b6103e88661014001516115a691906145e8565b6101608701516101c08801516101e0890151604080519788526020880196909652948601939093526060850191909152608084015260a083015260c082015260e00161096d565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003611660576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b60015460ff81901c6000036116a5576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2660048201526024016103cb565b7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81166001556040517f665227fdef5dd5aac81086c2301f0e50676c351cf8da0f456de2c2c3e16409de90600090a150565b60076001541660000361173a576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2160048201526024016103cb565b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036117ad576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b6001546001166001036117f0576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2260048201526024016103cb565b600054605981901c63ffffffff1660519190911c60ff161b61181282826134c0565b60018054811790556040518281527fa56b37b3edf9e1379ca408e58c1d4d85d03aa751c1dd8b76fa9813bfb2f9793d9060200161096d565b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036118bd576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b600180549060ff82901c9003611903576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2660048201526024016103cb565b7f800000000000000000000000000000000000000000000000000000000000000081176001556040517f84039da4130b96ef0fa0fffa1bb1306c814913702f63ede2d1cbcdfa43fc67d690600090a150565b600760015416600003611998576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2160048201526024016103cb565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003611a0b576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b8115801590611a1b57506103e882105b80611a3157508015801590611a3157506103e881105b15611a6c576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2660048201526024016103cb565b611a786103e8836145ad565b9150611a866103e8826145ad565b90506103e8821180611a9957506103e881115b15611ad4576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2460048201526024016103cb565b600180547fff00000fffffffffffffffffffffffffffffffffffffffffffffffffffffffff1660e484901b1760ee83901b1790557f6d66190870f5a401bd2f24056c4f721a7a9e522501ea222a140bbc2debd302cd611b356103e8846145e8565b610b366103e8846145e8565b600760015416600003611b84576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2160048201526024016103cb565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003611bf7576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b600154611c066103e8866145ad565b9450611c146103e8856145ad565b93506103e8851180611c2757506103e884115b80611c30575082155b80611c3d575062ffffff83115b80611c46575084155b80611c4f575083155b80611c5c5750620fffff82115b80611c6e5750604381901c6001166001145b15611ca9576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2460048201526024016103cb565b605883901b604e85901b604487901b604360008611611cc9576000611ccc565b60015b60ff16901b7fffffffffffffffffffffffffffffffffffff000000000007ffffffffffffffff8516171717176001556103ff604482901c811690604e83901c1662ffffff605884901c168415611d6457600780546fffffffffffffffffffffffffffffffff601485901b8617602889901b1742603c1b17605d85901b1781167001000000000000000000000000000000000291161790555b7fdb32664896dae5696540e472ef73d084b10faf79a5560470bd88d34daee92401611d916103e88a6145e8565b611d9d6103e88a6145e8565b60408051928352602083019190915281018890526060810187905260800160405180910390a15050505050505050565b600760015416600003611e10576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2160048201526024016103cb565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003611e83576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b611e8c8261333f565b73ffffffffffffffffffffffffffffffffffffffff821660009081526003602052604081205490819003611ef0576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2760048201526024016103cb565b66ffffffffffffff600982901c1660ff600183901c161b60a282901c613fff16612710611f1d82846145e8565b611f2791906145ad565b611f3190836145ff565b9050831580611f3f57508084105b15611f4c57809350611f82565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff841480611f7957508184115b15611f82578193505b6103ff60d084901c1660ff60c885901c161b80831015611fa157600094505b4260811b6041611fb687603860086000613397565b73ffffffffffffffffffffffffffffffffffffffff89166000818152600360209081526040918290209390941b7ffffffffffffffffffffffffc000000000000000000000001ffffffffffffffff8a16179490941790915582519081529081018790527fa0174ec7e13de1c5954dd270d67dafceaddc2e7c685d5dada0015b8bb51fb2d891015b60405180910390a1505050505050565b600760015416600003612090576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2160048201526024016103cb565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003612103576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b600154600216600203612146576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2360048201526024016103cb565b600054605981901c63ffffffff1660519190911c60ff161b61216882826139ce565b6001805460021790556040518281527f171ddc092d7f435025cb4835ca5827641260e8f2d37ffc48aca4836509b79d509060200161096d565b6007600154166000036121e4576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2160048201526024016103cb565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003612257576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b600054605981901c63ffffffff1660519190911c60ff161b818311158061227e5750818111155b806122895750828110155b80612292575081155b156122cd576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2660048201526024016103cb565b60c86122de83601460086000613397565b901b60ac6122f185601460086001613397565b901b6001547ffffffff00000000000000fffffffffffffffffffffffffffffffffffffffffff1617176001819055507fd4436251a5b52c21c680a58a0c189dad238e3150aaa2848762b76807e000d0d68383604051611064929190918252602082015260400190565b60076001541660000361239d576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2160048201526024016103cb565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003612410576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b6000805b825181101561278857612432838281518110610664576106646144d5565b828181518110612444576124446144d5565b602002602001015160800151838281518110612462576124626144d5565b60200260200101516060015111806124975750828181518110612487576124876144d5565b6020026020010151604001516000145b156124d2576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2660048201526024016103cb565b613fff8382815181106124e7576124e76144d5565b602002602001015160200151111561252f576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2460048201526024016103cb565b62ffffff838281518110612545576125456144d5565b602002602001015160400151111561258d576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2460048201526024016103cb565b82818151811061259f5761259f6144d5565b602002602001015160600151600014806125d657508281815181106125c6576125c66144d5565b6020026020010151608001516000145b15612611576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2660048201526024016103cb565b60056000848381518110612627576126276144d5565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054915060da6126a9600a6008600087868151811061268d5761268d6144d5565b602002602001015160800151613397909392919063ffffffff16565b901b60c86126c8600a60086000888781518110610862576108626144d5565b901b60b08584815181106126de576126de6144d5565b602002602001015160400151901b60a2868581518110612700576127006144d5565b602002602001015160200151901b857ffffff0000000000000000003ffffffffffffffffffffffffffffffffffffffff16600117171717176005600085848151811061274e5761274e6144d5565b6020908102919091018101515173ffffffffffffffffffffffffffffffffffffffff16825281019190915260400160002055600101612414565b507fce933896f6e8c2a05b92cd7f854cd82e69ada9e533cf438643d5d3a7ac9cba9d8260405161096d9190614612565b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016300361282b576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b60003073ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa158015612879573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061289d91906143ee565b6020015190507fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff8316016128ef576128ea8147613d4d565b61298a565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015261298a908390839073ffffffffffffffffffffffffffffffffffffffff8316906370a0823190602401602060405180830381865afa158015612961573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129859190614689565b613d9c565b60405173ffffffffffffffffffffffffffffffffffffffff831681527fdff2a3947bcf9fc0807b142e7c8497066db9183428b7bdbfb1fcd0f55c27a3df9060200161096d565b600760015416600003612a13576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2160048201526024016103cb565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003612a86576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b600154612a98612710620f42406145ff565b841180612ab25750612aaf612710620f42406145ff565b83115b80612abb575083155b80612ac4575082155b80612ad15750620fffff82115b80612ae35750601a81901c6001166001145b15612b1e576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2460048201526024016103cb565b602f83901b601b85901b601a60008511612b39576000612b3c565b60015b60ff16901b7ffffffffffffffffffffffffffffffffffffffffffffffff80000000003ffffff8416171717600155620fffff601b82901c811690602f83901c168315612bd057600780547fffffffffffffffffffffffffffffffff000000000000000000000000000000001642603c1b602887901b601485901b861717176fffffffffffffffffffffffffffffffff161790555b60408051878152602081018790529081018590527f4eb847e2909fd5c725b018d79e18739badfb33ba8aa65926fba2c644c3cc5a8e9060600161203d565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003612c81576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2860048201526024016103cb565b612c8a8361333f565b60008215612d83575073ffffffffffffffffffffffffffffffffffffffff831660009081526003602052604081205490819003612cf7576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2760048201526024016103cb565b80600116600003612d38576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2960048201526024016103cb565b73ffffffffffffffffffffffffffffffffffffffff841660009081526003602052604090207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe821690555b8115612e7a575073ffffffffffffffffffffffffffffffffffffffff831660009081526005602052604081205490819003612dee576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2760048201526024016103cb565b80600116600003612e2f576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2960048201526024016103cb565b73ffffffffffffffffffffffffffffffffffffffff841660009081526005602052604090207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe821690555b6040805173ffffffffffffffffffffffffffffffffffffffff861681528415156020820152831515918101919091527fe785e6d4f9f1321c6c8d597385ff4ebcff4a597d59ac3911b5052fbf805eb6c990606001610dce565b6000606082600003612ee9576000915050613339565b607f8311612fb2576040517fd60000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b16602282015260f884901b7fff000000000000000000000000000000000000000000000000000000000000001660368201526037015b604051602081830303815290604052905061332e565b60ff831161308f576040517fd70000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f8100000000000000000000000000000000000000000000000000000000000000603682015260f884901b7fff00000000000000000000000000000000000000000000000000000000000000166037820152603801612f9c565b61ffff831161316d576040517fd80000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f820000000000000000000000000000000000000000000000000000000000000060368201527fffff00000000000000000000000000000000000000000000000000000000000060f085901b166037820152603901612f9c565b62ffffff831161324c576040517fd90000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f830000000000000000000000000000000000000000000000000000000000000060368201527fffffff000000000000000000000000000000000000000000000000000000000060e885901b166037820152603a01612f9c565b6040517fda0000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f840000000000000000000000000000000000000000000000000000000000000060368201527fffffffff0000000000000000000000000000000000000000000000000000000060e085901b166037820152603b0160405160208183030381529060405290505b805160209091012090505b92915050565b8073ffffffffffffffffffffffffffffffffffffffff163b600003613394576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2560048201526024016103cb565b50565b600080856fffffffffffffffffffffffffffffffff8111156133ba5760809150811c5b67ffffffffffffffff8111156133d2576040918201911c5b63ffffffff8111156133e6576020918201911c5b61ffff8111156133f8576010918201911c5b60ff811115613409576008918201911c5b600f81111561341a576004918201911c5b600381111561342b576002918201911c5b600181111561343b576001820191505b8015613448576001820191505b50848110156134545750835b848103905085811c600082118416156134a357600181019050806001871b036134a357506001908101907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff86011b5b6001851b82106134b257600080fd5b90931b909201949350505050565b60003073ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa15801561350e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061353291906143ee565b905060003073ffffffffffffffffffffffffffffffffffffffff16631595cbd36040518163ffffffff1660e01b8152600401608060405180830381865afa158015613581573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135a591906146a2565b602081015181519192506000916135bc90876145e8565b6135c691906145ad565b905060006b033b2e3c9fd0803ce80000006135e183876145e8565b6135eb91906145ad565b90506000836040015184606001518361360491906145e8565b61360e91906145ad565b60208601519091503415801590613653575060a086015173ffffffffffffffffffffffffffffffffffffffff1673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14155b801561368d575060c086015173ffffffffffffffffffffffffffffffffffffffff1673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14155b156136c8576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2660048201526024016103cb565b60008060005b600281101561392d57806000036136ee578860a0015192508a91506136f9565b8860c0015192508491505b7fffffffffffffffffffffffff111111111111111111111111111111111111111273ffffffffffffffffffffffffffffffffffffffff84160161385e5781341115613756576137513361374c84346145ff565b613d4d565b613794565b81341015613794576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2660048201526024016103cb565b8373ffffffffffffffffffffffffffffffffffffffff1663ad967e158385856000806000336040516020016137e5919073ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b6040516020818303038152906040526040518863ffffffff1660e01b81526004016138159695949392919061474c565b604080518083038185885af1158015613832573d6000803e3d6000fd5b50505050506040513d601f19601f8201168201806040525081019061385791906147a5565b505061391b565b604080513360208083019190915282518083039091018152818301928390527fad967e150000000000000000000000000000000000000000000000000000000090925273ffffffffffffffffffffffffffffffffffffffff86169163ad967e15916138d691879187916000918291829160440161474c565b60408051808303816000875af11580156138f4573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061391891906147a5565b50505b80613925816147c9565b9150506136ce565b5084861161395b57613941600c60126145ff565b61394c90600a614921565b61395690866145e8565b61397c565b613967600c60126145ff565b61397290600a614921565b61397c90876145e8565b6002819055633b9aca0011156139c2576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2960048201526024016103cb565b50505050505050505050565b60003073ffffffffffffffffffffffffffffffffffffffff1663b7791bf26040518163ffffffff1660e01b815260040161024060405180830381865afa158015613a1c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613a4091906143ee565b905060003073ffffffffffffffffffffffffffffffffffffffff16631595cbd36040518163ffffffff1660e01b8152600401608060405180830381865afa158015613a8f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613ab391906146a2565b60208101518151919250600091613aca90876145e8565b613ad491906145ad565b905060006b033b2e3c9fd0803ce8000000613aef83876145e8565b613af991906145ad565b905060008360400151846060015183613b1291906145e8565b613b1c91906145ad565b60208681015160a0880151604080516000808252948101918290527fad967e1500000000000000000000000000000000000000000000000000000000909152939450909273ffffffffffffffffffffffffffffffffffffffff84169263ad967e1592613ba8929091908d908290734f6f977acdd1177dcd81ab83074855ecb9c2d49e906024810161474c565b60408051808303816000875af1158015613bc6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613bea91906147a5565b505060c086015160408051600080825260208201928390527fad967e150000000000000000000000000000000000000000000000000000000090925273ffffffffffffffffffffffffffffffffffffffff84169263ad967e1592613c6b9287908290734f6f977acdd1177dcd81ab83074855ecb9c2d49e906024810161474c565b60408051808303816000875af1158015613c89573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613cad91906147a5565b5050828411613cdc57613cc2600c60126145ff565b613ccd90600a614921565b613cd790846145e8565b613cfd565b613ce8600c60126145ff565b613cf390600a614921565b613cfd90856145e8565b6004819055633b9aca001115613d43576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261cb2960048201526024016103cb565b5050505050505050565b600080600080600085875af1905080613d97576040517fdee51a8a0000000000000000000000000000000000000000000000000000000081526201155a60048201526024016103cb565b505050565b60006040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152826024820152602060006044836000895af13d15601f3d1160016000511416171691505080613e40576040517fdee51a8a0000000000000000000000000000000000000000000000000000000081526201155a60048201526024016103cb565b50505050565b600060208284031215613e5857600080fd5b5035919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516080810167ffffffffffffffff81118282101715613eb157613eb1613e5f565b60405290565b604051610200810167ffffffffffffffff81118282101715613eb157613eb1613e5f565b60405160a0810167ffffffffffffffff81118282101715613eb157613eb1613e5f565b6040516101c0810167ffffffffffffffff81118282101715613eb157613eb1613e5f565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715613f6957613f69613e5f565b604052919050565b600067ffffffffffffffff821115613f8b57613f8b613e5f565b5060051b60200190565b73ffffffffffffffffffffffffffffffffffffffff8116811461339457600080fd5b60006020808385031215613fca57600080fd5b823567ffffffffffffffff811115613fe157600080fd5b8301601f81018513613ff257600080fd5b803561400561400082613f71565b613f22565b81815260079190911b8201830190838101908783111561402457600080fd5b928401925b8284101561408457608084890312156140425760008081fd5b61404a613e8e565b843561405581613f95565b815284860135868201526040808601359082015260608086013590820152825260809093019290840190614029565b979650505050505050565b600080604083850312156140a257600080fd5b50508035926020909101359150565b803580151581146140c157600080fd5b919050565b6000806000606084860312156140db57600080fd5b83356140e681613f95565b92506140f4602085016140b1565b9150614102604085016140b1565b90509250925092565b60008060006060848603121561412057600080fd5b505081359360208301359350604090920135919050565b6000610200828403121561414a57600080fd5b614152613eb7565b61415b836140b1565b815260208301356020820152614173604084016140b1565b6040820152606083810135908201526080808401359082015260a0808401359082015260c0808401359082015260e08084013590820152610100808401359082015261012080840135908201526101408084013590820152610160808401359082015261018080840135908201526101a080840135908201526101c080840135908201526101e0928301359281019290925250919050565b6000806000806080858703121561422157600080fd5b5050823594602084013594506040840135936060013592509050565b6000806040838503121561425057600080fd5b823561425b81613f95565b946020939093013593505050565b6000602080838503121561427c57600080fd5b823567ffffffffffffffff81111561429357600080fd5b8301601f810185136142a457600080fd5b80356142b261400082613f71565b81815260a091820283018401918482019190888411156142d157600080fd5b938501935b838510156143385780858a0312156142ee5760008081fd5b6142f6613edb565b853561430181613f95565b81528587013587820152604080870135908201526060808701359082015260808087013590820152835293840193918501916142d6565b50979650505050505050565b60006020828403121561435657600080fd5b813561436181613f95565b9392505050565b80516140c181613f95565b600060a0828403121561438557600080fd5b61438d613edb565b9050815161439a81613f95565b815260208201516143aa81613f95565b602082015260408201516143bd81613f95565b604082015260608201516143d081613f95565b606082015260808201516143e381613f95565b608082015292915050565b6000610240828403121561440157600080fd5b614409613efe565b8251815261441960208401614368565b602082015261442a60408401614368565b604082015261443c8460608501614373565b606082015261010061444f818501614368565b6080830152610120614462818601614368565b60a0840152610140614475818701614368565b60c08501526101608087015160e086015261018080880151858701526101a0945084880151848701526101c0880151838701526101e088015182870152610200880151818701525050505061022084015181830152508091505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602080825282518282018190526000919060409081850190868401855b82811015614571578151805173ffffffffffffffffffffffffffffffffffffffff168552868101518786015285810151868601526060908101519085015260809093019290850190600101614521565b5091979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000826145e3577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b80820281158282048414176133395761333961457e565b818103818111156133395761333961457e565b602080825282518282018190526000919060409081850190868401855b82811015614571578151805173ffffffffffffffffffffffffffffffffffffffff16855286810151878601528581015186860152606080820151908601526080908101519085015260a0909301929085019060010161462f565b60006020828403121561469b57600080fd5b5051919050565b6000608082840312156146b457600080fd5b6146bc613e8e565b825181526020830151602082015260408301516040820152606083015160608201528091505092915050565b6000815180845260005b8181101561470e576020818501810151868301820152016146f2565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b600073ffffffffffffffffffffffffffffffffffffffff8089168352876020840152866040840152808616606084015280851660808401525060c060a083015261479960c08301846146e8565b98975050505050505050565b600080604083850312156147b857600080fd5b505080516020909101519092909150565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036147fa576147fa61457e565b5060010190565b600181815b8085111561485a57817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048211156148405761484061457e565b8085161561484d57918102915b93841c9390800290614806565b509250929050565b60008261487157506001613339565b8161487e57506000613339565b8160018114614894576002811461489e576148ba565b6001915050613339565b60ff8411156148af576148af61457e565b50506001821b613339565b5060208310610133831016604e8410600b84101617156148dd575081810a613339565b6148e78383614801565b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048211156149195761491961457e565b029392505050565b6000614361838361486256fea2646970667358221220768fa7518f0269693474f5970a831f878e41adea025f7db6225d828bbc99186e64736f6c6343000815003360c060405234801561001057600080fd5b50604051610ced380380610ced83398101604081905261002f91610044565b6001600160a01b03166080523060a052610074565b60006020828403121561005657600080fd5b81516001600160a01b038116811461006d57600080fd5b9392505050565b60805160a051610c476100a66000396000818160e50152818161024901526104a2015260006102f80152610c476000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c80630d7cf0ab146100515780632f850fb314610084578063b5c736e4146100a5578063e8518a66146100b7575b600080fd5b61006461005f366004610aea565b6100ca565b604080519384526020840192909252908201526060015b60405180910390f35b610097610092366004610b16565b610230565b60405190815260200161007b565b6100976100b3366004610b38565b5490565b6100646100c5366004610aea565b610487565b6000808073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610146576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261c77360048201526024015b60405180910390fd5b6007546fffffffffffffffffffffffffffffffff811690620fffff80821691601481901c821691602882901c1690603c1c6401ffffffff16426101898383610b80565b10156101f3575050600780547fffffffffffffffffffffffffffffffff00000000000000000000000000000000169055505050507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbffffff92909216600181905591508390508282610227565b60006101ff8242610b93565b905061020d8c868386610605565b6102198c868487610605565b8b9850985098505050505050505b93509350939050565b600073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036102a5576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261c773600482015260240161013d565b600854605984901c63ffffffff16605185901c60ff161b906401ffffffff80821690620fffff602184901c811691603585901c90911690607989901c168381116102ef57836102f1565b805b90506103277f0000000000000000000000000000000000000000000000000000000000000000633fffffff60708b901c1661067e565b73ffffffffffffffffffffffffffffffffffffffff1663f763f7a66040518163ffffffff1660e01b81526004016020604051808303816000875af1158015610373573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103979190610ba6565b965060006103a8620f424084610bbf565b6103b28342610b93565b6103bc868a610bbf565b6103c69190610bbf565b6103d09190610bd6565b905086881115610428576103e48188610b80565b9650868811156103f65786975061047a565b6000600855600180547ffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff16905561047a565b80871161043657600061043a565b8087035b96508688101561044c5786975061047a565b6000600855600180547ffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690555b5050505050505092915050565b6000808073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036104fe576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261c773600482015260240161013d565b6007546fffffffffffffffffffffffffffffffff70010000000000000000000000000000000090910490811690620fffff80821691601481901c821691602882901c1690603c81901c6401ffffffff1690605d1c62ffffff16426105628484610b80565b10156105bd575050600780546fffffffffffffffffffffffffffffffff1690555050600180547ffffffffffffffffffffffffffffffffffffffffffffffff7ffffffffffffffff169055508693508592508491506102279050565b60006105c98342610b93565b90506105d78d878387610605565b6105e38d878488610605565b6105ef8d858589610605565b9950995099505050505050505093509350939050565b60008385111561064457600061061b8587610b93565b9050826106288583610bbf565b6106329190610bd6565b61063c9086610b80565b955050610675565b60006106508686610b93565b90508261065d8583610bbf565b6106679190610bd6565b6106719086610b93565b9550505b50929392505050565b6000606082600003610694576000915050610ae4565b607f831161075d576040517fd60000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b16602282015260f884901b7fff000000000000000000000000000000000000000000000000000000000000001660368201526037015b6040516020818303038152906040529050610ad9565b60ff831161083a576040517fd70000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f8100000000000000000000000000000000000000000000000000000000000000603682015260f884901b7fff00000000000000000000000000000000000000000000000000000000000000166037820152603801610747565b61ffff8311610918576040517fd80000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f820000000000000000000000000000000000000000000000000000000000000060368201527fffff00000000000000000000000000000000000000000000000000000000000060f085901b166037820152603901610747565b62ffffff83116109f7576040517fd90000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f830000000000000000000000000000000000000000000000000000000000000060368201527fffffff000000000000000000000000000000000000000000000000000000000060e885901b166037820152603a01610747565b6040517fda0000000000000000000000000000000000000000000000000000000000000060208201527f940000000000000000000000000000000000000000000000000000000000000060218201527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606086901b1660228201527f840000000000000000000000000000000000000000000000000000000000000060368201527fffffffff0000000000000000000000000000000000000000000000000000000060e085901b166037820152603b0160405160208183030381529060405290505b805160209091012090505b92915050565b600080600060608486031215610aff57600080fd5b505081359360208301359350604090920135919050565b60008060408385031215610b2957600080fd5b50508035926020909101359150565b600060208284031215610b4a57600080fd5b5035919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b80820180821115610ae457610ae4610b51565b81810381811115610ae457610ae4610b51565b600060208284031215610bb857600080fd5b5051919050565b8082028115828204841417610ae457610ae4610b51565b600082610c0c577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b50049056fea26469706673582212207bbd86704f31cc2190b9c491cdeea583a55ffb7ce53de73eb1ec77a53f34eab264736f6c63430008150033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100d45760003560e01c8063c758ec5611610081578063cc2fe94b1161005b578063cc2fe94b14610212578063d71f047014610239578063da3d57cb1461024157600080fd5b8063c758ec56146101db578063c995fa7a146101e3578063cc025f7c146101eb57600080fd5b80638cb1b071116100b25780638cb1b071146101665780639603fd271461018d57806397b87b4a146101b457600080fd5b80632861c7d1146100d95780635d5b87e01461012a5780637f2f809e1461013f575b600080fd5b6101007f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b610132610254565b6040516101219190610eb9565b6101007f000000000000000000000000000000000000000000000000000000000000000081565b6101007f000000000000000000000000000000000000000000000000000000000000000081565b6101007f000000000000000000000000000000000000000000000000000000000000000081565b6101007f000000000000000000000000000000000000000000000000000000000000000081565b6101326102b5565b6101326102e0565b6101007f000000000000000000000000000000000000000000000000000000000000000081565b6101007f000000000000000000000000000000000000000000000000000000000000000081565b61013261030b565b61013261024f366004610f2f565b610336565b60606102b06102827f0000000000000000000000000000000000000000000000000000000000000000610b3f565b6102ab7f0000000000000000000000000000000000000000000000000000000000000000610b3f565b610b73565b905090565b60606102b07f0000000000000000000000000000000000000000000000000000000000000000610b3f565b60606102b07f0000000000000000000000000000000000000000000000000000000000000000610b3f565b60606102b07f0000000000000000000000000000000000000000000000000000000000000000610b3f565b606073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036103b0576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261c35660048201526024015b60405180910390fd5b8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1603610419576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261c35360048201526024016103a7565b8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161115610483576040517f2fee3e0e00000000000000000000000000000000000000000000000000000000815261c35460048201526024016103a7565b610520604080516101c08101825260008082526020808301829052828401829052835160a08101855282815290810182905292830181905260608381018290526080840191909152909190820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c0820181905260e08201819052610100820181905261012082018190526101409091015290565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000811660208084019190915230604080850182905260608501517f0000000000000000000000000000000000000000000000000000000000000000851690527f00000000000000000000000000000000000000000000000000000000000000008416608086015288841660a086015292871660c085015282517f93656c17000000000000000000000000000000000000000000000000000000008152925190926393656c179260048083019391928290030181865afa15801561061c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106409190610f70565b8082526101a082018490526040517f12e366aa00000000000000000000000000000000000000000000000000000000815260009130916312e366aa9161068c9160040190815260200190565b602060405180830381865afa1580156106a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106cd9190610f89565b90506106d98282610beb565b915060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663798133dd6107216102e0565b856040516020016107329190610fad565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529082905261076e929160200161113f565b6040516020818303038152906040526040518263ffffffff1660e01b81526004016107999190610eb9565b6020604051808303816000875af11580156107b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107dc9190610f89565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663798133dd6108246102b5565b866040516020016108359190610fad565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815290829052610871929160200161113f565b6040516020818303038152906040526040518263ffffffff1660e01b815260040161089c9190610eb9565b6020604051808303816000875af11580156108bb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108df9190610f89565b905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663798133dd61092761030b565b876040516020016109389190610fad565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815290829052610974929160200161113f565b6040516020818303038152906040526040518263ffffffff1660e01b815260040161099f9190610eb9565b6020604051808303816000875af11580156109be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109e29190610f89565b6060808701805173ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000008116602090920191909152815187821660809091015281518682166040919091015290519083169101529050610a53610254565b85604051602001610a649190610fad565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815290829052610aa0929160200161113f565b60405160208183030381529060405295508773ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff167f3fecd5f7aca6136a20a999e7d11ff5dcea4bd675cb125f93ccd7d53f98ec57e48860000151604051610b2b91815260200190565b60405180910390a450505050509392505050565b6060610b6d826001610b688173ffffffffffffffffffffffffffffffffffffffff84163b61116e565b610e54565b92915050565b60606040519050825180825260208201818101602086015b81831015610ba3578051835260209283019201610b8b565b50845184518101855292509050808201602085015b81831015610bd0578051835260209283019201610bb8565b50601f19601f87518501158301011660405250505092915050565b610c88604080516101c08101825260008082526020808301829052828401829052835160a08101855282815290810182905292830181905260608381018290526080840191909152909190820190815260006020820181905260408201819052606082018190526080820181905260a0820181905260c0820181905260e08201819052610100820181905261012082018190526101409091015290565b5060a082810180516040805173ffffffffffffffffffffffffffffffffffffffff9586166020808301829052600883850181905284518085038601815260608086018752815191840191909120968a16608080870191909152858a019790975285518086038a01815260c0958601875280519084012060e08c015287518651808501869052600981890181905288518083038a0181528285018a52805190870120928d16828b0152818c019290925287518082038c01815290870188528051908501206101008d0152858c0180518851808701889052808a019590955288518086038a0181528585018a52805190870120908d16858b0152848c015287518085038c01815293870188528351938501939093206101208d01528251875180860196909652858801919091528651808603880181528583018852805190850120908b1697850197909752838901969096528451808403909801885291909201835285519582019590952061014088015292518151908616818501526005818301819052825180830384018152918401835281519185019190912061016088015293518151951685840152848101939093528251808503840181529301909152815191012061018082015290565b60408051603f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168101909152818152818360208301863c9392505050565b60005b83811015610eb0578181015183820152602001610e98565b50506000910152565b6020815260008251806020840152610ed8816040850160208701610e95565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b73ffffffffffffffffffffffffffffffffffffffff81168114610f2c57600080fd5b50565b600080600060608486031215610f4457600080fd5b8335610f4f81610f0a565b92506020840135610f5f81610f0a565b929592945050506040919091013590565b600060208284031215610f8257600080fd5b5051919050565b600060208284031215610f9b57600080fd5b8151610fa681610f0a565b9392505050565b81518152602080830151610240830191610fde9084018273ffffffffffffffffffffffffffffffffffffffff169052565b506040830151611006604084018273ffffffffffffffffffffffffffffffffffffffff169052565b506060830151611064606084018273ffffffffffffffffffffffffffffffffffffffff808251168352806020830151166020840152806040830151166040840152806060830151166060840152806080830151166080840152505050565b50608083015161010061108e8185018373ffffffffffffffffffffffffffffffffffffffff169052565b60a085015191506101206110b98186018473ffffffffffffffffffffffffffffffffffffffff169052565b60c086015192506101406110e48187018573ffffffffffffffffffffffffffffffffffffffff169052565b60e0870151610160878101919091529287015161018080880191909152918701516101a080880191909152908701516101c0870152918601516101e08601528501516102008501529093015161022090920191909152919050565b60008351611151818460208801610e95565b835190830190611165818360208801610e95565b01949350505050565b81810381811115610b6d577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fdfea2646970667358221220585da3d1c1bfc1dc58ae9a7d6d0e76c6c15e66fa855fdb0162a767e80c46d33d64736f6c63430008150033",
  "devdoc": {
    "events": {
      "DexT1Deployed(address,uint256,address,address)": {
        "params": {
          "borrowToken": "The address of the borrow token.",
          "dex": "The address of the newly deployed dex.",
          "dexId": "The id of the newly deployed dex.",
          "supplyToken": "The address of the supply token."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "colOperationsCreationCode()": {
        "details": "Retrieves the creation code for the FluidDexT1OperationsCol contract"
      },
      "debtOperationsCreationCode()": {
        "details": "Retrieves the creation code for the FluidDexT1OperationsDebt contract"
      },
      "perfectOperationsCreationCode()": {
        "details": "Retrieves the creation code for the FluidDexT1PerfectOperations contract"
      }
    },
    "stateVariables": {
      "COL_OPERATIONS_CREATIONCODE_ADDRESS": {
        "details": "SSTORE2 pointers for the creation code of various operations contracts"
      },
      "POOL_T1_CREATIONCODE_ADDRESS_1": {
        "details": "SSTORE2 pointer for the PoolT1 creation code. Stored externally to reduce factory bytecode (in 2 parts)"
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "FluidDexSwapResult(uint256)": [
        {
          "notice": "used to simulate swap to find the output amount"
        }
      ]
    },
    "events": {
      "DexT1Deployed(address,uint256,address,address)": {
        "notice": "Emitted when a new dexT1 is deployed."
      }
    },
    "kind": "user",
    "methods": {
      "ADDRESS_THIS()": {
        "notice": "address of this contract"
      },
      "ADMIN_IMPLEMENTATION()": {
        "notice": "address of Admin implementation"
      },
      "CONTRACT_DEPLOYER()": {
        "notice": "address of Deployer Contract"
      },
      "DEX_FACTORY()": {
        "notice": "address of dexfactory contract"
      },
      "LIQUIDITY()": {
        "notice": "address of liquidity contract"
      },
      "MINI_DEPLOYER()": {
        "notice": "address of MiniDeployer Contract"
      },
      "SHIFT_IMPLEMENTATION()": {
        "notice": "address of Shift implementation"
      },
      "dexT1CreationBytecode()": {
        "notice": "returns the stored DexT1 creation bytecode"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}