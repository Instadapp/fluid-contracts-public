{
  "language": "Solidity",
  "sources": {
    "contracts/protocols/lending/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Error {\n    error FluidLendingError(uint256 errorId_);\n}\n"
    },
    "contracts/protocols/lending/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |               fToken              | \n    |__________________________________*/\n\n    /// @notice thrown when a deposit amount is too small to increase BigMath stored balance in Liquidity.\n    /// precision of BigMath is 1e12, so if token holds 120_000_000_000 USDC, min amount to make a difference would be 0.1 USDC.\n    /// i.e. user would send a very small deposit which mints no shares -> revert\n    uint256 internal constant fToken__DepositInsignificant = 20001;\n\n    /// @notice thrown when minimum output amount is not reached, e.g. for minimum shares minted (deposit) or\n    ///         minimum assets received (redeem)\n    uint256 internal constant fToken__MinAmountOut = 20002;\n\n    /// @notice thrown when maximum amount is surpassed, e.g. for maximum shares burned (withdraw) or\n    ///         maximum assets input (mint)\n    uint256 internal constant fToken__MaxAmount = 20003;\n\n    /// @notice thrown when invalid params are sent to a method, e.g. zero address\n    uint256 internal constant fToken__InvalidParams = 20004;\n\n    /// @notice thrown when an unauthorized caller is trying to execute an auth-protected method\n    uint256 internal constant fToken__Unauthorized = 20005;\n\n    /// @notice thrown when a with permit / signature method is called from msg.sender that is the owner.\n    /// Should call the method without permit instead if msg.sender is the owner.\n    uint256 internal constant fToken__PermitFromOwnerCall = 20006;\n\n    /// @notice thrown when a reentrancy is detected.\n    uint256 internal constant fToken__Reentrancy = 20007;\n\n    /// @notice thrown when _tokenExchangePrice overflows type(uint64).max\n    uint256 internal constant fToken__ExchangePriceOverflow = 20008;\n\n    /// @notice thrown when msg.sender is not rebalancer\n    uint256 internal constant fToken__NotRebalancer = 20009;\n\n    /// @notice thrown when rebalance is called with msg.value > 0 for non NativeUnderlying fToken\n    uint256 internal constant fToken__NotNativeUnderlying = 20010;\n\n    /// @notice thrown when the received new liquidity exchange price is of unexpected value (< than the old one)\n    uint256 internal constant fToken__LiquidityExchangePriceUnexpected = 20011;\n\n    /***********************************|\n    |     fToken Native Underlying      | \n    |__________________________________*/\n\n    /// @notice thrown when native deposit is called but sent along `msg.value` does not cover the deposit amount\n    uint256 internal constant fTokenNativeUnderlying__TransferInsufficient = 21001;\n\n    /// @notice thrown when a liquidity callback is called for a native token operation\n    uint256 internal constant fTokenNativeUnderlying__UnexpectedLiquidityCallback = 21002;\n\n    /***********************************|\n    |         Lending Factory         | \n    |__________________________________*/\n\n    /// @notice thrown when a method is called with invalid params\n    uint256 internal constant LendingFactory__InvalidParams = 22001;\n\n    /// @notice thrown when the provided input param address is zero\n    uint256 internal constant LendingFactory__ZeroAddress = 22002;\n\n    /// @notice thrown when the token already exists\n    uint256 internal constant LendingFactory__TokenExists = 22003;\n\n    /// @notice thrown when the fToken has not yet been configured at Liquidity\n    uint256 internal constant LendingFactory__LiquidityNotConfigured = 22004;\n\n    /// @notice thrown when an unauthorized caller is trying to execute an auth-protected method\n    uint256 internal constant LendingFactory__Unauthorized = 22005;\n\n    /***********************************|\n    |   Lending Rewards Rate Model      | \n    |__________________________________*/\n\n    /// @notice thrown when invalid params are given as input\n    uint256 internal constant LendingRewardsRateModel__InvalidParams = 23001;\n\n    /// @notice thrown when calculated rewards rate is exceeding the maximum rate\n    uint256 internal constant LendingRewardsRateModel__MaxRate = 23002;\n\n    /// @notice thrown when start is called by any other address other than initiator\n    uint256 internal constant LendingRewardsRateModel__NotTheInitiator = 23003;\n\n    /// @notice thrown when start is called after the rewards are already started\n    uint256 internal constant LendingRewardsRateModel__AlreadyStarted = 23004;\n\n    /// @notice thrown when the provided input param address is zero\n    uint256 internal constant LendingRewardsRateModel__ZeroAddress = 23005;\n}\n"
    },
    "contracts/protocols/lending/interfaces/iLendingRewardsRateModel.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidLendingRewardsRateModel {\n    /// @notice Calculates the current rewards rate (APR)\n    /// @param totalAssets_ amount of assets in the lending\n    /// @return rate_ rewards rate percentage per year with 1e12 RATE_PRECISION, e.g. 1e12 = 1%, 1e14 = 100%\n    /// @return ended_ flag to signal that rewards have ended (always 0 going forward)\n    /// @return startTime_ start time of rewards to compare against last update timestamp\n    function getRate(uint256 totalAssets_) external view returns (uint256 rate_, bool ended_, uint256 startTime_);\n\n    /// @notice Returns config constants for rewards rate model\n    function getConfig()\n        external\n        view\n        returns (\n            uint256 duration_,\n            uint256 startTime_,\n            uint256 endTime_,\n            uint256 startTvl_,\n            uint256 maxRate_,\n            uint256 rewardAmount_,\n            address initiator_\n        );\n}\n"
    },
    "contracts/protocols/lending/lendingRewardsRateModel/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLendingRewardsRateModel } from \"../interfaces/iLendingRewardsRateModel.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\n\n/// @title LendingRewardsRateModel\n/// @notice Calculates rewards rate used for an fToken based on a rewardAmount over a given duration.\n/// Rewards start once the allowed initiator address triggers `start()` and only accrue above a certain startTVL.\n/// Max rate cap is at 50%.\ncontract FluidLendingRewardsRateModel is IFluidLendingRewardsRateModel, Error {\n    /// @notice Emitted when rewards are started\n    event LogRewardsStarted(uint256 startTime, uint256 endTime);\n\n    /// @dev precision decimals for rewards rate\n    uint256 internal constant RATE_PRECISION = 1e12;\n\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /// @dev maximum rewards rate is 50%. no config higher than this should be possible.\n    uint256 internal constant MAX_RATE = 50 * RATE_PRECISION; // 1e12 = 1%, this is 50%.\n\n    /// @dev tvl below which rewards rate is 0\n    uint256 internal immutable START_TVL;\n\n    /// @dev for how long rewards should run\n    uint256 internal immutable DURATION;\n\n    /// @dev annualized reward based on constructor input params (duration, rewardAmount)\n    uint256 internal immutable YEARLY_REWARD;\n\n    /// @dev total amounts to be distributed. not needed but stored for easier tracking via `getConfig`\n    uint256 internal immutable REWARD_AMOUNT;\n\n    /// @dev address which has access to call start() which kickstarts the rewards\n    address internal immutable INITIATOR;\n\n    /// @dev address of the previously active lending rewards rate model for smooth transition. Can be zero address if none.\n    IFluidLendingRewardsRateModel public immutable PREVIOUS_MODEL;\n    /// @dev end time of previous lending rewards rate model. 0 if there is no previous model.\n    uint256 internal immutable PREVIOUS_MODEL_END_TIME;\n\n    /// @dev when rewards got started\n    uint96 internal startTime;\n    /// @dev when rewards will get over\n    uint96 internal endTime;\n\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__ZeroAddress);\n        }\n        _;\n    }\n\n    /// @notice sets immutable vars for rewards rate config based on input params.\n    /// @param duration_ for how long rewards should run\n    /// @param startTvl_  tvl below which rate is 0\n    /// @param rewardAmount_  total amount of underlying asset to be distributed as rewards\n    /// @param initiator_  address which has access to kickstart the rewards, if previousModel is address zero\n    /// @param previousModel_  address of previously active lendingRewardsRateModel. can be zero address if none.\n    constructor(\n        uint256 duration_,\n        uint256 startTvl_,\n        uint256 rewardAmount_,\n        address initiator_,\n        IFluidLendingRewardsRateModel previousModel_\n    ) {\n        // sanity checks\n        if (\n            duration_ == 0 ||\n            rewardAmount_ == 0 ||\n            startTvl_ == 0 ||\n            (initiator_ == address(0) && address(previousModel_) == address(0))\n        ) {\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__InvalidParams);\n        }\n\n        START_TVL = startTvl_;\n        DURATION = duration_;\n        REWARD_AMOUNT = rewardAmount_;\n        INITIATOR = initiator_;\n\n        YEARLY_REWARD = (rewardAmount_ * SECONDS_PER_YEAR) / DURATION;\n\n        if (address(previousModel_) != address(0)) {\n            PREVIOUS_MODEL = previousModel_;\n            (, , PREVIOUS_MODEL_END_TIME, , , , ) = previousModel_.getConfig();\n            if (PREVIOUS_MODEL_END_TIME == 0) {\n                revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__InvalidParams);\n            }\n\n            // start current model exactly when previous model ends. no trigger via start() needed.\n            startTime = uint96(PREVIOUS_MODEL_END_TIME);\n            endTime = uint96(PREVIOUS_MODEL_END_TIME + DURATION);\n\n            emit LogRewardsStarted(startTime, endTime);\n        }\n    }\n\n    /// @inheritdoc IFluidLendingRewardsRateModel\n    function getConfig()\n        external\n        view\n        returns (\n            uint256 duration_,\n            uint256 startTime_,\n            uint256 endTime_,\n            uint256 startTvl_,\n            uint256 maxRate_,\n            uint256 rewardAmount_,\n            address initiator_\n        )\n    {\n        return (DURATION, startTime, endTime, START_TVL, MAX_RATE, REWARD_AMOUNT, INITIATOR);\n    }\n\n    /// @inheritdoc IFluidLendingRewardsRateModel\n    function getRate(uint256 totalAssets_) public view returns (uint256 rate_, bool ended_, uint256 startTime_) {\n        if (block.timestamp <= PREVIOUS_MODEL_END_TIME) {\n            // return previous model reate until previous model end time.\n            return PREVIOUS_MODEL.getRate(totalAssets_);\n        }\n\n        startTime_ = startTime;\n        uint endTime_ = endTime;\n        if (startTime_ == 0 || endTime_ == 0) {\n            return (0, false, startTime_);\n        }\n        if (block.timestamp > endTime_) {\n            return (0, true, startTime_);\n        }\n        if (totalAssets_ < START_TVL) {\n            return (0, false, startTime_);\n        }\n\n        rate_ = (YEARLY_REWARD * 1e14) / totalAssets_;\n\n        return (rate_ > MAX_RATE ? MAX_RATE : rate_, false, startTime_);\n    }\n\n    function start() external {\n        if (msg.sender != INITIATOR) {\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__NotTheInitiator);\n        }\n        if (startTime > 0 || endTime > 0) {\n            // will fail if started in constructor for smooth transition from previous model\n            revert FluidLendingError(ErrorTypes.LendingRewardsRateModel__AlreadyStarted);\n        }\n        startTime = uint96(block.timestamp);\n        endTime = uint96(block.timestamp + DURATION);\n\n        emit LogRewardsStarted(startTime, endTime);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}