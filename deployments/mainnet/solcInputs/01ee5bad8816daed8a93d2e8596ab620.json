{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/infiniteProxy/interfaces/iProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IProxy {\n    function setAdmin(address newAdmin_) external;\n\n    function setDummyImplementation(address newDummyImplementation_) external;\n\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\n\n    function removeImplementation(address implementation_) external;\n\n    function getAdmin() external view returns (address);\n\n    function getDummyImplementation() external view returns (address);\n\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\n\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/bigMathMinified.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\nlibrary BigMathMinified {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/bytesSliceAndConcat.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary BytesSliceAndConcat {\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesConcat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    ) internal pure returns (bytes memory tempBytes) {\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesSlice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory tempBytes) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/libraries/dexCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\nimport { DexSlotsLink } from \"./dexSlotsLink.sol\";\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// @DEV ATTENTION: ON ANY CHANGES HERE, MAKE SURE THAT LOGIC IN VAULTS WILL STILL BE VALID.\n// SOME CODE THERE ASSUMES DEXCALCS == LIQUIDITYCALCS.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n/// @notice implements calculation methods used for Fluid Dex such as updated withdrawal / borrow limits.\nlibrary DexCalcs {\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) &\n            X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ = block.timestamp - ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ = block.timestamp - ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n}\n"
    },
    "contracts/libraries/dexSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\nlibrary DexSlotsLink {\n    /// @dev storage slot for variables at Dex\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\n    /// @dev storage slot for variables2 at Dex\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\n    /// @dev storage slot for total supply shares at Dex\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\n    /// @dev storage slot for user supply mapping at Dex\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\n    /// @dev storage slot for total borrow shares at Dex\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\n    /// @dev storage slot for user borrow mapping at Dex\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\n    /// @dev storage slot for oracle mapping at Dex\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\n    /// @dev storage slot for range and threshold shifts at Dex\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\n    /// @dev storage slot for center price shift at Dex\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n}\n"
    },
    "contracts/libraries/fluidProtocolTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ninterface IFluidProtocol {\n    function TYPE() external view returns (uint256);\n}\n\n/// @notice implements helper methods to filter Fluid protocols by a certain type\nlibrary FluidProtocolTypes {\n    uint256 internal constant VAULT_T1_TYPE = 10000; // VaultT1 borrow protocol type vaults\n    uint256 internal constant VAULT_T2_SMART_COL_TYPE = 20000; // DEX protocol type vault\n    uint256 internal constant VAULT_T3_SMART_DEBT_TYPE = 30000; // DEX protocol type vault\n    uint256 internal constant VAULT_T4_SMART_COL_SMART_DEBT_TYPE = 40000; // DEX protocol type vault\n\n    /// @dev filters input `addresses_` by protocol `type_`. Input addresses must be actual Fluid protocols, otherwise\n    ///      they would be wrongly assumed to be VaultT1 even if they are not Fluid VaultT1 smart contracts.\n    ///      `type_` must be a listed constant type of this library.\n    ///      Example usage is to filter all vault addresses at the Vault factory by a certain type, e.g. to not include\n    ///      DEX protocol type vaults.\n    function filterBy(address[] memory addresses_, uint256 type_) internal view returns (address[] memory filtered_) {\n        uint256 curType_;\n        uint256 filteredProtocols_ = addresses_.length;\n        for (uint256 i; i < addresses_.length; ) {\n            try IFluidProtocol(addresses_[i]).TYPE() returns (uint256 protocolType_) {\n                curType_ = protocolType_;\n            } catch {\n                curType_ = VAULT_T1_TYPE;\n            }\n\n            if (curType_ != type_) {\n                addresses_[i] = address(0);\n                --filteredProtocols_;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        filtered_ = new address[](filteredProtocols_);\n        uint256 index_;\n        unchecked {\n            for (uint256 i; i < addresses_.length; ) {\n                if (addresses_[i] != address(0)) {\n                    filtered_[index_] = addresses_[i];\n                    ++index_;\n                }\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/liquidityCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\nimport { LiquiditySlotsLink } from \"./liquiditySlotsLink.sol\";\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\n\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\n/// borrow rate, withdrawal / borrow limits, revenue amount.\nlibrary LiquidityCalcs {\n    error FluidLiquidityCalcsError(uint256 errorId_);\n\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\n    event BorrowRateMaxCap();\n\n    /// @dev constants as from Liquidity variables.sol\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X15 = 0x7fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                  CALC EXCHANGE PRICES                  /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\n    function calcExchangePrices(\n        uint256 exchangePricesAndConfig_\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\n        // Extracting exchange prices\n        supplyExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\n            X64;\n        borrowExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\n            X64;\n\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\n        }\n\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\n\n        unchecked {\n            // last timestamp can not be > current timestamp\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\n\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\n                X15;\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // calculate new borrow exchange price.\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\n            borrowExchangePrice_ +=\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\n\n            // FOR SUPPLY EXCHANGE PRICE:\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\n            //\n            // Example:\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\n            // yield is 10 (so half a year must have passed).\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 20%) = 62,5%\n            // supplyRate = (40% * (100% - 10%)) * = 36% * 62,5% = 22.5%\n            // increase in supplyExchangePrice, assuming 100 as previous price.\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\n\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\n\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\n\n            if (temp_ == 1) {\n                // if no raw supply: no exchange price update needed\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\n            if (temp_ & 1 == 1) {\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n                temp_ = temp_ >> 1;\n\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\n                // in the if statement a little above.\n\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\n                // so ratioSupplyYield must come out as 2.5 (250%).\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\n                temp_ =\n                    // utilization * (100% + 100% / supplyRatio)\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\n                    (FOUR_DECIMALS);\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\n            } else {\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n                temp_ = temp_ >> 1;\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\n\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\n                temp_ =\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\n                    (1e27 *\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\n                        (FOUR_DECIMALS + temp_)) /\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\n            }\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\n\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\n            if (borrowRatio_ & 1 == 1) {\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\n\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\n            } else {\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\n            }\n\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\n\n            // 2. calculate supply rate\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\n            // but more suppliers not earning interest.\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\n                temp_ * // ratioSupplyYield\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\n\n            // 3. calculate increase in supply exchange price\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                     CALC REVENUE                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\n    /// and the current balance of the Fluid liquidity contract for the token.\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\n    /// @return revenueAmount_ collectable revenue amount\n    function calcRevenue(\n        uint256 totalAmounts_,\n        uint256 exchangePricesAndConfig_,\n        uint256 liquidityTokenBalance_\n    ) internal view returns (uint256 revenueAmount_) {\n        // @dev no need to super-optimize this method as it is only used by admin\n\n        // calculate the new exchange prices based on earned interest\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\n\n        // total supply = interest free + with interest converted from raw\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\n\n        if (totalSupply_ > 0) {\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\n            // ensure there is no possible case because of rounding etc. where this would revert,\n            // explicitly check if >\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\n            // can only be revenue.\n        } else {\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\n            revenueAmount_ = liquidityTokenBalance_;\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ =\n                block.timestamp -\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ =\n                block.timestamp -\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC RATES                        /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev Calculates new borrow rate from utilization for a token\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\n        // extract rate version: 4 bits (0xF) starting from bit 0\n        uint256 rateVersion_ = (rateData_ & 0xF);\n\n        if (rateVersion_ == 1) {\n            rate_ = calcRateV1(rateData_, utilization_);\n        } else if (rateVersion_ == 2) {\n            rate_ = calcRateV2(rateData_, utilization_);\n        } else {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\n        }\n\n        if (rate_ > X16) {\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\n            // this is unlikely to ever happen if configs stay within expected levels.\n            rate_ = X16;\n            // emit event to more easily become aware\n            emit BorrowRateMaxCap();\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e2 precision\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v1 (one kink) ------------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // else utilization is greater than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\n            x1_ = kink1_;\n            x2_ = FOUR_DECIMALS; // 100%\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e4 precision\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v2 (two kinks) -----------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 156 bits => 100-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink1\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\n            if (utilization_ < kink2_) {\n                // if utilization is less than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                x1_ = kink1_;\n                x2_ = kink2_;\n            } else {\n                // else utilization is greater than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\n                x1_ = kink2_;\n                x2_ = FOUR_DECIMALS;\n            }\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\n    function getTotalSupply(\n        uint256 totalAmounts_,\n        uint256 supplyExchangePrice_\n    ) internal pure returns (uint256 totalSupply_) {\n        // totalSupply_ => supplyInterestFree\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\n    function getTotalBorrow(\n        uint256 totalAmounts_,\n        uint256 borrowExchangePrice_\n    ) internal pure returns (uint256 totalBorrow_) {\n        // totalBorrow_ => borrowInterestFree\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n}\n"
    },
    "contracts/libraries/liquiditySlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\nlibrary LiquiditySlotsLink {\n    /// @dev storage slot for status at Liquidity\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\n    /// @dev storage slot for auths mapping at Liquidity\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\n    /// @dev storage slot for guardians mapping at Liquidity\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\n    /// @dev storage slot for user class mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\n    /// @dev storage slot for rateData mapping at Liquidity\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\n    /// @dev storage slot for totalAmounts mapping at Liquidity\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\n    /// @dev storage slot for user supply double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\n    /// @dev storage slot for user borrow double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // ExchangePricesAndConfig\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\n\n    // RateData:\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\n    // RateData: V1\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\n    // RateData: V2\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\n\n    // TotalAmounts\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\n\n    // Configs2\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/safeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\n\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\nlibrary SafeTransfer {\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 20000; // pass max. 20k gas for native transfers\n\n    error FluidSafeTransferError(uint256 errorId_);\n\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from_\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of `token_` to `to_`.\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of ` native token to `to_`.\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\n    function safeTransferNative(address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n}\n"
    },
    "contracts/libraries/storageRead.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements a method to read uint256 data from storage at a bytes32 storage slot key.\ncontract StorageRead {\n    function readFromStorage(bytes32 slot_) public view returns (uint256 result_) {\n        assembly {\n            result_ := sload(slot_) // read value from the storage slot\n        }\n    }\n}\n"
    },
    "contracts/libraries/tickMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that calculates number \"tick\" and \"ratioX96\" from this: ratioX96 = (1.0015^tick) * 2^96\n/// @notice this library is used in Fluid Vault protocol for optimiziation.\n/// @dev \"tick\" supports between -32767 and 32767. \"ratioX96\" supports between 37075072 and 169307877264527972847801929085841449095838922544595\nlibrary TickMath {\n    /// The minimum tick that can be passed in getRatioAtTick. 1.0015**-32767\n    int24 internal constant MIN_TICK = -32767;\n    /// The maximum tick that can be passed in getRatioAtTick. 1.0015**32767\n    int24 internal constant MAX_TICK = 32767;\n\n    uint256 internal constant FACTOR00 = 0x100000000000000000000000000000000;\n    uint256 internal constant FACTOR01 = 0xff9dd7de423466c20352b1246ce4856f; // 2^128/1.0015**1 = 339772707859149738855091969477551883631\n    uint256 internal constant FACTOR02 = 0xff3bd55f4488ad277531fa1c725a66d0; // 2^128/1.0015**2 = 339263812140938331358054887146831636176\n    uint256 internal constant FACTOR03 = 0xfe78410fd6498b73cb96a6917f853259; // 2^128/1.0015**4 = 338248306163758188337119769319392490073\n    uint256 internal constant FACTOR04 = 0xfcf2d9987c9be178ad5bfeffaa123273; // 2^128/1.0015**8 = 336226404141693512316971918999264834163\n    uint256 internal constant FACTOR05 = 0xf9ef02c4529258b057769680fc6601b3; // 2^128/1.0015**16 = 332218786018727629051611634067491389875\n    uint256 internal constant FACTOR06 = 0xf402d288133a85a17784a411f7aba082; // 2^128/1.0015**32 = 324346285652234375371948336458280706178\n    uint256 internal constant FACTOR07 = 0xe895615b5beb6386553757b0352bda90; // 2^128/1.0015**64 = 309156521885964218294057947947195947664\n    uint256 internal constant FACTOR08 = 0xd34f17a00ffa00a8309940a15930391a; // 2^128/1.0015**128 = 280877777739312896540849703637713172762 \n    uint256 internal constant FACTOR09 = 0xae6b7961714e20548d88ea5123f9a0ff; // 2^128/1.0015**256 = 231843708922198649176471782639349113087\n    uint256 internal constant FACTOR10 = 0x76d6461f27082d74e0feed3b388c0ca1; // 2^128/1.0015**512 = 157961477267171621126394973980180876449\n    uint256 internal constant FACTOR11 = 0x372a3bfe0745d8b6b19d985d9a8b85bb; // 2^128/1.0015**1024 = 73326833024599564193373530205717235131\n    uint256 internal constant FACTOR12 = 0x0be32cbee48979763cf7247dd7bb539d; // 2^128/1.0015**2048 = 15801066890623697521348224657638773661\n    uint256 internal constant FACTOR13 = 0x8d4f70c9ff4924dac37612d1e2921e;   // 2^128/1.0015**4096 = 733725103481409245883800626999235102\n    uint256 internal constant FACTOR14 = 0x4e009ae5519380809a02ca7aec77;     // 2^128/1.0015**8192 = 1582075887005588088019997442108535\n    uint256 internal constant FACTOR15 = 0x17c45e641b6e95dee056ff10;         // 2^128/1.0015**16384 = 7355550435635883087458926352\n\n    /// The minimum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MIN_TICK). ~ Equivalent to `(1 << 96) * (1.0015**-32767)`\n    uint256 internal constant MIN_RATIOX96 = 37075072;\n    /// The maximum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MAX_TICK).\n    /// ~ Equivalent to `(1 << 96) * (1.0015**32767)`, rounding etc. leading to minor difference\n    uint256 internal constant MAX_RATIOX96 = 169307877264527972847801929085841449095838922544595;\n\n    uint256 internal constant ZERO_TICK_SCALED_RATIO = 0x1000000000000000000000000; // 1 << 96 // 79228162514264337593543950336\n    uint256 internal constant _1E26 = 1e26;\n\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return ratioX96 ratio = (debt amount/collateral amount)\n    function getRatioAtTick(int tick) internal pure returns (uint256 ratioX96) {\n        assembly {\n            let absTick_ := sub(xor(tick, sar(255, tick)), sar(255, tick))\n\n            if gt(absTick_, MAX_TICK) {\n                revert(0, 0)\n            }\n            let factor_ := FACTOR00\n            if and(absTick_, 0x1) {\n                factor_ := FACTOR01\n            }\n            if and(absTick_, 0x2) {\n                factor_ := shr(128, mul(factor_, FACTOR02))\n            }\n            if and(absTick_, 0x4) {\n                factor_ := shr(128, mul(factor_, FACTOR03))\n            }\n            if and(absTick_, 0x8) {\n                factor_ := shr(128, mul(factor_, FACTOR04))\n            }\n            if and(absTick_, 0x10) {\n                factor_ := shr(128, mul(factor_, FACTOR05))\n            }\n            if and(absTick_, 0x20) {\n                factor_ := shr(128, mul(factor_, FACTOR06))\n            }\n            if and(absTick_, 0x40) {\n                factor_ := shr(128, mul(factor_, FACTOR07))\n            }\n            if and(absTick_, 0x80) {\n                factor_ := shr(128, mul(factor_, FACTOR08))\n            }\n            if and(absTick_, 0x100) {\n                factor_ := shr(128, mul(factor_, FACTOR09))\n            }\n            if and(absTick_, 0x200) {\n                factor_ := shr(128, mul(factor_, FACTOR10))\n            }\n            if and(absTick_, 0x400) {\n                factor_ := shr(128, mul(factor_, FACTOR11))\n            }\n            if and(absTick_, 0x800) {\n                factor_ := shr(128, mul(factor_, FACTOR12))\n            }\n            if and(absTick_, 0x1000) {\n                factor_ := shr(128, mul(factor_, FACTOR13))\n            }\n            if and(absTick_, 0x2000) {\n                factor_ := shr(128, mul(factor_, FACTOR14))\n            }\n            if and(absTick_, 0x4000) {\n                factor_ := shr(128, mul(factor_, FACTOR15))\n            }\n\n            let precision_ := 0\n            if iszero(and(tick, 0x8000000000000000000000000000000000000000000000000000000000000000)) {\n                factor_ := div(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, factor_)\n                // we round up in the division so getTickAtRatio of the output price is always consistent\n                if mod(factor_, 0x100000000) {\n                    precision_ := 1\n                }\n            }\n            ratioX96 := add(shr(32, factor_), precision_)\n        }\n    }\n\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\n    /// @dev Throws if ratioX96 > max ratio || ratioX96 < min ratio\n    /// @param ratioX96 The input ratio; ratio = (debt amount/collateral amount)\n    /// @return tick The output tick for the above formula. Returns in round down form. if tick is 123.23 then 123, if tick is -123.23 then returns -124\n    /// @return perfectRatioX96 perfect ratio for the above tick\n    function getTickAtRatio(uint256 ratioX96) internal pure returns (int tick, uint perfectRatioX96) {\n        assembly {\n            if or(gt(ratioX96, MAX_RATIOX96), lt(ratioX96, MIN_RATIOX96)) {\n                revert(0, 0)\n            }\n\n            let cond := lt(ratioX96, ZERO_TICK_SCALED_RATIO)\n            let factor_\n\n            if iszero(cond) {\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\n                factor_ := div(mul(ratioX96, _1E26), ZERO_TICK_SCALED_RATIO)\n            }\n            if cond {\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\n                factor_ := div(mul(ZERO_TICK_SCALED_RATIO, _1E26), ratioX96)\n            }\n\n            // put in https://www.wolframalpha.com/ whole equation: (1.0015^tick) * 2^96 * 10^26 / 79228162514264337593543950336\n\n            // for tick = 16384\n            // ratioX96 = (1.0015^16384) * 2^96 = 3665252098134783297721995888537077351735\n            // 3665252098134783297721995888537077351735 * 10^26 / 79228162514264337593543950336 =\n            // 4626198540796508716348404308345255985.06131964639489434655721\n            if iszero(lt(factor_, 4626198540796508716348404308345255985)) {\n                tick := or(tick, 0x4000)\n                factor_ := div(mul(factor_, _1E26), 4626198540796508716348404308345255985)\n            }\n            // for tick = 8192\n            // ratioX96 = (1.0015^8192) * 2^96 = 17040868196391020479062776466509865\n            // 17040868196391020479062776466509865 * 10^26 / 79228162514264337593543950336 =\n            // 21508599537851153911767490449162.3037648642153898377655505172\n            if iszero(lt(factor_, 21508599537851153911767490449162)) {\n                tick := or(tick, 0x2000)\n                factor_ := div(mul(factor_, _1E26), 21508599537851153911767490449162)\n            }\n            // for tick = 4096\n            // ratioX96 = (1.0015^4096) * 2^96 = 36743933851015821532611831851150\n            // 36743933851015821532611831851150 * 10^26 / 79228162514264337593543950336 =\n            // 46377364670549310883002866648.9777607649742626173648716941385\n            if iszero(lt(factor_, 46377364670549310883002866649)) {\n                tick := or(tick, 0x1000)\n                factor_ := div(mul(factor_, _1E26), 46377364670549310883002866649)\n            }\n            // for tick = 2048\n            // ratioX96 = (1.0015^2048) * 2^96 = 1706210527034005899209104452335\n            // 1706210527034005899209104452335 * 10^26 / 79228162514264337593543950336 =\n            // 2153540449365864845468344760.06357108484096046743300420319322\n            if iszero(lt(factor_, 2153540449365864845468344760)) {\n                tick := or(tick, 0x800)\n                factor_ := div(mul(factor_, _1E26), 2153540449365864845468344760)\n            }\n            // for tick = 1024\n            // ratioX96 = (1.0015^1024) * 2^96 = 367668226692760093024536487236\n            // 367668226692760093024536487236 * 10^26 / 79228162514264337593543950336 =\n            // 464062544207767844008185024.950588990554136265212906454481127\n            if iszero(lt(factor_, 464062544207767844008185025)) {\n                tick := or(tick, 0x400)\n                factor_ := div(mul(factor_, _1E26), 464062544207767844008185025)\n            }\n            // for tick = 512\n            // ratioX96 = (1.0015^512) * 2^96 = 170674186729409605620119663668\n            // 170674186729409605620119663668 * 10^26 / 79228162514264337593543950336 =\n            // 215421109505955298802281577.031879604792139232258508172947569\n            if iszero(lt(factor_, 215421109505955298802281577)) {\n                tick := or(tick, 0x200)\n                factor_ := div(mul(factor_, _1E26), 215421109505955298802281577)\n            }\n            // for tick = 256\n            // ratioX96 = (1.0015^256) * 2^96 = 116285004205991934861656513301\n            // 116285004205991934861656513301 * 10^26 / 79228162514264337593543950336 =\n            // 146772309890508740607270614.667650899656438875541505058062410\n            if iszero(lt(factor_, 146772309890508740607270615)) {\n                tick := or(tick, 0x100)\n                factor_ := div(mul(factor_, _1E26), 146772309890508740607270615)\n            }\n            // for tick = 128\n            // ratioX96 = (1.0015^128) * 2^96 = 95984619659632141743747099590\n            // 95984619659632141743747099590 * 10^26 / 79228162514264337593543950336 =\n            // 121149622323187099817270416.157248837742741760456796835775887\n            if iszero(lt(factor_, 121149622323187099817270416)) {\n                tick := or(tick, 0x80)\n                factor_ := div(mul(factor_, _1E26), 121149622323187099817270416)\n            }\n            // for tick = 64\n            // ratioX96 = (1.0015^64) * 2^96 = 87204845308406958006717891124\n            // 87204845308406958006717891124 * 10^26 / 79228162514264337593543950336 =\n            // 110067989135437147685980801.568068573422377364214113968609839\n            if iszero(lt(factor_, 110067989135437147685980801)) {\n                tick := or(tick, 0x40)\n                factor_ := div(mul(factor_, _1E26), 110067989135437147685980801)\n            }\n            // for tick = 32\n            // ratioX96 = (1.0015^32) * 2^96 = 83120873769022354029916374475\n            // 83120873769022354029916374475 * 10^26 / 79228162514264337593543950336 =\n            // 104913292358707887270979599.831816586773651266562785765558183\n            if iszero(lt(factor_, 104913292358707887270979600)) {\n                tick := or(tick, 0x20)\n                factor_ := div(mul(factor_, _1E26), 104913292358707887270979600)\n            }\n            // for tick = 16\n            // ratioX96 = (1.0015^16) * 2^96 = 81151180492336368327184716176\n            // 81151180492336368327184716176 * 10^26 / 79228162514264337593543950336 =\n            // 102427189924701091191840927.762844039579442328381455567932128\n            if iszero(lt(factor_, 102427189924701091191840928)) {\n                tick := or(tick, 0x10)\n                factor_ := div(mul(factor_, _1E26), 102427189924701091191840928)\n            }\n            // for tick = 8\n            // ratioX96 = (1.0015^8) * 2^96 = 80183906840906820640659903620\n            // 80183906840906820640659903620 * 10^26 / 79228162514264337593543950336 =\n            // 101206318935480056907421312.890625\n            if iszero(lt(factor_, 101206318935480056907421313)) {\n                tick := or(tick, 0x8)\n                factor_ := div(mul(factor_, _1E26), 101206318935480056907421313)\n            }\n            // for tick = 4\n            // ratioX96 = (1.0015^4) * 2^96 = 79704602139525152702959747603\n            // 79704602139525152702959747603 * 10^26 / 79228162514264337593543950336 =\n            // 100601351350506250000000000\n            if iszero(lt(factor_, 100601351350506250000000000)) {\n                tick := or(tick, 0x4)\n                factor_ := div(mul(factor_, _1E26), 100601351350506250000000000)\n            }\n            // for tick = 2\n            // ratioX96 = (1.0015^2) * 2^96 = 79466025265172787701084167660\n            // 79466025265172787701084167660 * 10^26 / 79228162514264337593543950336 =\n            // 100300225000000000000000000\n            if iszero(lt(factor_, 100300225000000000000000000)) {\n                tick := or(tick, 0x2)\n                factor_ := div(mul(factor_, _1E26), 100300225000000000000000000)\n            }\n            // for tick = 1\n            // ratioX96 = (1.0015^1) * 2^96 = 79347004758035734099934266261\n            // 79347004758035734099934266261 * 10^26 / 79228162514264337593543950336 =\n            // 100150000000000000000000000\n            if iszero(lt(factor_, 100150000000000000000000000)) {\n                tick := or(tick, 0x1)\n                factor_ := div(mul(factor_, _1E26), 100150000000000000000000000)\n            }\n            if iszero(cond) {\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\n                perfectRatioX96 := div(mul(ratioX96, _1E26), factor_)\n            }\n            if cond {\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\n                tick := not(tick)\n                perfectRatioX96 := div(mul(ratioX96, factor_), 100150000000000000000000000)\n            }\n            // perfect ratio should always be <= ratioX96\n            // not sure if it can ever be bigger but better to have extra checks\n            if gt(perfectRatioX96, ratioX96) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "contracts/liquidity/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    /// @notice struct to set borrow rate data for version 1\n    struct RateDataV1Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\n        uint256 kink;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink;\n        ///\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set borrow rate data for version 2\n    struct RateDataV2Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\n        uint256 kink1;\n        ///\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\n        uint256 kink2;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink1;\n        ///\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\n        uint256 rateAtUtilizationKink2;\n        ///\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set token config\n    struct TokenConfig {\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\n        uint256 fee;\n        ///\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\n        uint256 threshold;\n        ///\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\n        uint256 maxUtilization;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/liquidity/interfaces/iLiquidity.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IProxy } from \"../../infiniteProxy/interfaces/iProxy.sol\";\nimport { Structs as AdminModuleStructs } from \"../adminModule/structs.sol\";\n\ninterface IFluidLiquidityAdmin {\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\n    /// @param authsStatus_ array of structs setting allowed status for an address.\n    ///                     status true => add auth, false => remove auth\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\n\n    /// @notice adds/removes guardians. Only callable by Governance.\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\n    ///                         status true => add guardian, false => remove guardian\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\n\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\n    /// @param revenueCollector_  new revenue collector address\n    function updateRevenueCollector(address revenueCollector_) external;\n\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\n    /// @param newStatus_ new status\n    ///        status = 2 -> pause, status = 1 -> resume.\n    function changeStatus(uint256 newStatus_) external;\n\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\n\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\n\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\n    ///         Only callable by Auths.\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\n\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\n    ///         Only callable by Auths.\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\n\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param token_ token address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\n\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\n\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to pause operations for\n    /// @param supplyTokens_  token addresses to pause withdrawals for\n    /// @param borrowTokens_  token addresses to pause borrowings for\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to unpause operations for\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\n    /// @param borrowTokens_  token addresses to unpause borrowings for\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\n    /// @param tokens_  array of tokens to collect revenue for\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\n    function collectRevenue(address[] calldata tokens_) external;\n\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\n    /// @param tokens_ tokens to update exchange prices for\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\n    function updateExchangePrices(\n        address[] calldata tokens_\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\n}\n\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\n    /// @notice Single function which handles supply, withdraw, borrow & payback\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\n    /// @param withdrawTo_ if withdrawal then to which address\n    /// @param borrowTo_ if borrow then to which address\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\n    /// @return memVar3_ updated supplyExchangePrice\n    /// @return memVar4_ updated borrowExchangePrice\n    /// @dev to trigger skipping in / out transfers (gas optimization):\n    /// -  ` callbackData_` MUST be encoded so that \"from\" address is the last 20 bytes in the last 32 bytes slot,\n    ///     also for native token operations where liquidityCallback is not triggered!\n    ///     from address must come at last position if there is more data. I.e. encode like:\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\n    /// -   this \"from\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\n    ///     in the slot before (bytes 32 to 63)\n    /// -   `msg.value` must be 0.\n    /// -   Amounts must be either:\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\n}\n\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\n"
    },
    "contracts/oracle/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Error {\n    error FluidOracleError(uint256 errorId_);\n}\n"
    },
    "contracts/oracle/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |           FluidOracleL2           | \n    |__________________________________*/\n\n    /// @notice thrown when sequencer on a L2 has an outage and grace period has not yet passed.\n    uint256 internal constant FluidOracleL2__SequencerOutage = 60000;\n\n    /***********************************|\n    |     UniV3CheckCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the delta between main price source and check rate source is exceeding the allowed delta\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidPrice = 60001;\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidParams = 60002;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant UniV3CheckCLRSOracle__ExchangeRateZero = 60003;\n\n    /***********************************|\n    |           FluidOracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid info name is passed into a fluid oracle (e.g. not set or too long)\n    uint256 internal constant FluidOracle__InvalidInfoName = 60010;\n\n    /***********************************|\n    |            sUSDe Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDeOracle__InvalidParams = 60102;\n\n    /***********************************|\n    |           Pendle Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PendleOracle__InvalidParams = 60201;\n\n    /// @notice thrown when the Pendle market Oracle has not been initialized yet\n    uint256 internal constant PendleOracle__MarketNotInitialized = 60202;\n\n    /// @notice thrown when the Pendle market does not have 18 decimals\n    uint256 internal constant PendleOracle__MarketInvalidDecimals = 60203;\n\n    /// @notice thrown when the Pendle market returns an unexpected price\n    uint256 internal constant PendleOracle__InvalidPrice = 60204;\n\n    /***********************************|\n    |    CLRS2UniV3CheckCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant CLRS2UniV3CheckCLRSOracleL2__ExchangeRateZero = 60301;\n\n    /***********************************|\n    |    Ratio2xFallbackCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant Ratio2xFallbackCLRSOracleL2__ExchangeRateZero = 60311;\n\n    /***********************************|\n    |            WeETHsOracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHsOracle__InvalidParams = 60321;\n\n    /***********************************|\n    |          Chainlink Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant ChainlinkOracle__InvalidParams = 61001;\n\n    /***********************************|\n    |          UniswapV3 Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3Oracle__InvalidParams = 62001;\n\n    /// @notice thrown when constructor is called with invalid ordered seconds agos values\n    uint256 internal constant UniV3Oracle__InvalidSecondsAgos = 62002;\n\n    /// @notice thrown when constructor is called with invalid delta values > 100%\n    uint256 internal constant UniV3Oracle__InvalidDeltas = 62003;\n\n    /***********************************|\n    |            WstETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WstETHOracle__InvalidParams = 63001;\n\n    /***********************************|\n    |           Redstone Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant RedstoneOracle__InvalidParams = 64001;\n\n    /***********************************|\n    |          Fallback Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant FallbackOracle__InvalidParams = 65001;\n\n    /***********************************|\n    |       FallbackCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant FallbackCLRSOracle__ExchangeRateZero = 66001;\n\n    /***********************************|\n    |         WstETHCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant WstETHCLRSOracle__ExchangeRateZero = 67001;\n\n    /***********************************|\n    |        CLFallbackUniV3Oracle      | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant CLFallbackUniV3Oracle__ExchangeRateZero = 68001;\n\n    /***********************************|\n    |  WstETHCLRS2UniV3CheckCLRSOracle  | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant WstETHCLRS2UniV3CheckCLRSOracle__ExchangeRateZero = 69001;\n\n    /***********************************|\n    |             WeETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHOracle__InvalidParams = 70001;\n}\n"
    },
    "contracts/oracle/fluidOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"./interfaces/iFluidOracle.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { Error as OracleError } from \"./error.sol\";\n\n/// @title   FluidOracle\n/// @notice  Base contract that any Fluid Oracle must implement\nabstract contract FluidOracle is IFluidOracle, OracleError {\n    /// @dev short helper string to easily identify the oracle. E.g. token symbols\n    //\n    // using a bytes32 because string can not be immutable.\n    bytes32 private immutable _infoName;\n\n    constructor(string memory infoName_) {\n        if (bytes(infoName_).length > 32 || bytes(infoName_).length == 0) {\n            revert FluidOracleError(ErrorTypes.FluidOracle__InvalidInfoName);\n        }\n\n        // convert string to bytes32\n        bytes32 infoNameBytes32_;\n        assembly {\n            infoNameBytes32_ := mload(add(infoName_, 32))\n        }\n        _infoName = infoNameBytes32_;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function infoName() external view returns (string memory) {\n        // convert bytes32 to string\n        uint256 length_;\n        while (length_ < 32 && _infoName[length_] != 0) {\n            length_++;\n        }\n        bytes memory infoNameBytes_ = new bytes(length_);\n        for (uint256 i; i < length_; i++) {\n            infoNameBytes_[i] = _infoName[i];\n        }\n        return string(infoNameBytes_);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() external view virtual returns (uint256 exchangeRate_);\n}\n"
    },
    "contracts/oracle/interfaces/iFluidOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidOracle {\n    /// @dev Deprecated. Use `getExchangeRateOperate()` and `getExchangeRateLiquidate()` instead. Only implemented for\n    ///      backwards compatibility.\n    function getExchangeRate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for operates\n    function getExchangeRateOperate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for liquidations\n    function getExchangeRateLiquidate() external view returns (uint256 exchangeRate_);\n\n    /// @notice helper string to easily identify the oracle. E.g. token symbols\n    function infoName() external view returns (string memory);\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/iLiquidityResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Structs as LiquidityStructs } from \"../../../periphery/resolvers/liquidity/structs.sol\";\n\ninterface IFluidLiquidityResolver {\n    /// @notice gets the `revenueAmount_` for a `token_`.\n    function getRevenue(address token_) external view returns (uint256 revenueAmount_);\n\n    /// @notice address of contract that gets sent the revenue. Configurable by governance\n    function getRevenueCollector() external view returns (address);\n\n    /// @notice Liquidity contract paused status: status = 1 -> normal. status = 2 -> paused.\n    function getStatus() external view returns (uint256);\n\n    /// @notice checks if `auth_` is an allowed auth on Liquidity.\n    /// Auths can set most config values. E.g. contracts that automate certain flows like e.g. adding a new fToken.\n    /// Governance can add/remove auths. Governance is auth by default.\n    function isAuth(address auth_) external view returns (uint256);\n\n    /// @notice checks if `guardian_` is an allowed Guardian on Liquidity.\n    /// Guardians can pause lower class users.\n    /// Governance can add/remove guardians. Governance is guardian by default.\n    function isGuardian(address guardian_) external view returns (uint256);\n\n    /// @notice gets user class for `user_`. Class defines which protocols can be paused by guardians.\n    /// Currently there are 2 classes: 0 can be paused by guardians. 1 cannot be paused by guardians.\n    /// New protocols are added as class 0 and will be upgraded to 1 over time.\n    function getUserClass(address user_) external view returns (uint256);\n\n    /// @notice gets exchangePricesAndConfig packed uint256 storage slot for `token_`.\n    function getExchangePricesAndConfig(address token_) external view returns (uint256);\n\n    /// @notice gets rateConfig packed uint256 storage slot for `token_`.\n    function getRateConfig(address token_) external view returns (uint256);\n\n    /// @notice gets totalAmounts packed uint256 storage slot for `token_`.\n    function getTotalAmounts(address token_) external view returns (uint256);\n\n    /// @notice gets configs2 packed uint256 storage slot for `token_`.\n    function getConfigs2(address token_) external view returns (uint256);\n\n    /// @notice gets userSupply data packed uint256 storage slot for `user_` and `token_`.\n    function getUserSupply(address user_, address token_) external view returns (uint256);\n\n    /// @notice gets userBorrow data packed uint256 storage slot for `user_` and `token_`.\n    function getUserBorrow(address user_, address token_) external view returns (uint256);\n\n    /// @notice returns all `listedTokens_` at the Liquidity contract. Once configured, a token can never be removed.\n    function listedTokens() external view returns (address[] memory listedTokens_);\n\n    /// @notice get the Rate config data `rateData_` for a `token_` compiled from the packed uint256 rateConfig storage slot\n    function getTokenRateData(address token_) external view returns (LiquidityStructs.RateData memory rateData_);\n\n    /// @notice get the Rate config datas `rateDatas_` for multiple `tokens_` compiled from the packed uint256 rateConfig storage slot\n    function getTokensRateData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.RateData[] memory rateDatas_);\n\n    /// @notice returns general data for `token_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokenData(\n        address token_\n    ) external view returns (LiquidityStructs.OverallTokenData memory overallTokenData_);\n\n    /// @notice returns general data for multiple `tokens_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokensData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns general data for all `listedTokens()` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getAllOverallTokensData()\n        external\n        view\n        returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserSupplyData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData memory userSupplyData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleSupplyData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserBorrowData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData memory userBorrowData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleBorrowData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `supplyTokens_`\n    ///     and returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `borrowTokens_`\n    function getUserMultipleBorrowSupplyData(\n        address user_,\n        address[] calldata supplyTokens_,\n        address[] calldata borrowTokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallSupplyTokensData_,\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallBorrowTokensData_\n        );\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs as AdminModuleStructs } from \"../../../liquidity/adminModule/structs.sol\";\n\nabstract contract Structs {\n    struct RateData {\n        uint256 version;\n        AdminModuleStructs.RateDataV1Params rateDataV1;\n        AdminModuleStructs.RateDataV2Params rateDataV2;\n    }\n\n    struct OverallTokenData {\n        uint256 borrowRate;\n        uint256 supplyRate;\n        uint256 fee; // revenue fee\n        uint256 lastStoredUtilization;\n        uint256 storageUpdateThreshold;\n        uint256 lastUpdateTimestamp;\n        uint256 supplyExchangePrice;\n        uint256 borrowExchangePrice;\n        uint256 supplyRawInterest;\n        uint256 supplyInterestFree;\n        uint256 borrowRawInterest;\n        uint256 borrowInterestFree;\n        uint256 totalSupply;\n        uint256 totalBorrow;\n        uint256 revenue;\n        uint256 maxUtilization; // maximum allowed utilization\n        RateData rateData;\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserSupplyData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 supply; // user supply amount\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\n        uint256 withdrawalLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\n        uint256 baseWithdrawalLimit;\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\n        uint256 withdrawableUntilLimit;\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserBorrowData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 borrow; // user borrow amount\n        uint256 borrowLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseBorrowLimit;\n        uint256 maxBorrowLimit;\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vault/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Variables } from \"./variables.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { TickMath } from \"../../../libraries/tickMath.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\n\ncontract Helpers is Variables, Structs {\n    function normalSlot(uint256 slot_) public pure returns (bytes32) {\n        return bytes32(slot_);\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping\n    function calculateStorageSlotUintMapping(uint256 slot_, uint key_) public pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping\n    function calculateStorageSlotIntMapping(uint256 slot_, int key_) public pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping\n    function calculateDoubleIntUintMapping(uint256 slot_, int key1_, uint key2_) public pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n\n    function tickHelper(uint tickRaw_) public pure returns (int tick) {\n        require(tickRaw_ < X20, \"invalid-number\");\n        if (tickRaw_ > 0) {\n            tick = tickRaw_ & 1 == 1 ? int((tickRaw_ >> 1) & X19) : -int((tickRaw_ >> 1) & X19);\n        } else {\n            tick = type(int).min;\n        }\n    }\n\n    constructor(address factory_, address liquidityResolver_) Variables(factory_, liquidityResolver_) {}\n}\n"
    },
    "contracts/periphery/resolvers/vault/iVaultResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Structs } from \"./structs.sol\";\n\ninterface IFluidVaultResolver {\n    function vaultByNftId(uint nftId_) external view returns (address vault_);\n\n    function positionByNftId(\n        uint nftId_\n    ) external view returns (Structs.UserPosition memory userPosition_, Structs.VaultEntireData memory vaultData_);\n\n    function getVaultVariablesRaw(address vault_) external view returns (uint);\n\n    function getVaultVariables2Raw(address vault_) external view returns (uint);\n\n    function getTickHasDebtRaw(address vault_, int key_) external view returns (uint);\n\n    function getTickDataRaw(address vault_, int tick_) external view returns (uint);\n\n    function getBranchDataRaw(address vault_, uint branch_) external view returns (uint);\n\n    function getPositionDataRaw(address vault_, uint positionId_) external view returns (uint);\n\n    function getAllVaultsAddresses() external view returns (address[] memory vaults_);\n\n    function getVaultLiquidation(\n        address vault_,\n        uint tokenInAmt_\n    ) external returns (Structs.LiquidationStruct memory liquidationData_);\n\n    function getVaultEntireData(address vault_) external view returns (Structs.VaultEntireData memory vaultData_);\n}\n"
    },
    "contracts/periphery/resolvers/vault/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Helpers } from \"./helpers.sol\";\nimport { TickMath } from \"../../../libraries/tickMath.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\nimport { IFluidOracle } from \"../../../oracle/fluidOracle.sol\";\nimport { IFluidVault } from \"../../../protocols/vault/interfaces/iVault.sol\";\nimport { IFluidVaultT1 } from \"../../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { Structs as FluidLiquidityResolverStructs } from \"../liquidity/structs.sol\";\nimport { LiquiditySlotsLink } from \"../../../libraries/liquiditySlotsLink.sol\";\nimport { LiquidityCalcs } from \"../../../libraries/liquidityCalcs.sol\";\nimport { DexCalcs } from \"../../../libraries/dexCalcs.sol\";\nimport { DexSlotsLink } from \"../../../libraries/dexSlotsLink.sol\";\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { IFluidStorageReadable } from \"./variables.sol\";\nimport { FluidProtocolTypes } from \"../../../libraries/fluidProtocolTypes.sol\";\n\ninterface TokenInterface {\n    function balanceOf(address) external view returns (uint);\n}\n\n/// @notice Fluid Vault protocol resolver\n/// Implements various view-only methods to give easy access to Vault protocol data.\ncontract FluidVaultResolver is Helpers {\n    constructor(address factory_, address liquidityResolver_) Helpers(factory_, liquidityResolver_) {}\n\n    /// @notice Get the address of a vault.\n    /// @param vaultId_ The ID of the vault.\n    /// @return vault_ The address of the vault.\n    function getVaultAddress(uint vaultId_) public view returns (address vault_) {\n        return AddressCalcs.addressCalc(address(FACTORY), vaultId_);\n    }\n\n    /// @notice Get the type of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return vaultType_ The type of the vault. 0 if not a Fluid vault.\n    function getVaultType(address vault_) public view returns (uint vaultType_) {\n        if (vault_.code.length == 0) {\n            return 0;\n        }\n        try IFluidVault(vault_).TYPE() returns (uint type_) {\n            return type_;\n        } catch {\n            if (getVaultAddress(getVaultId(vault_)) != vault_) {\n                return 0;\n            }\n            // if TYPE() is not available but address is valid vault id, it must be vault T1\n            return FluidProtocolTypes.VAULT_T1_TYPE;\n        }\n    }\n\n    /// @notice Get the ID of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return id_ The ID of the vault.\n    function getVaultId(address vault_) public view returns (uint id_) {\n        id_ = IFluidVault(vault_).VAULT_ID();\n    }\n\n    /// @notice Get the token configuration.\n    /// @param nftId_ The ID of the NFT.\n    /// @return The token configuration.\n    function getTokenConfig(uint nftId_) public view returns (uint) {\n        return FACTORY.readFromStorage(calculateStorageSlotUintMapping(3, nftId_));\n    }\n\n    /// @notice Get the raw variables of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The raw variables of the vault.\n    function getVaultVariablesRaw(address vault_) public view returns (uint) {\n        return IFluidVault(vault_).readFromStorage(normalSlot(0));\n    }\n\n    /// @notice Get the raw variables of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The raw variables of the vault.\n    function getVaultVariables2Raw(address vault_) public view returns (uint) {\n        return IFluidVault(vault_).readFromStorage(normalSlot(1));\n    }\n\n    /// @notice Get the absorbed liquidity of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The absorbed liquidity of the vault.\n    function getAbsorbedLiquidityRaw(address vault_) public view returns (uint) {\n        return IFluidVault(vault_).readFromStorage(normalSlot(2));\n    }\n\n    /// @notice Get the position data of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param positionId_ The ID of the position.\n    /// @return The position data of the vault.\n    function getPositionDataRaw(address vault_, uint positionId_) public view returns (uint) {\n        return IFluidVault(vault_).readFromStorage(calculateStorageSlotUintMapping(3, positionId_));\n    }\n\n    /// @notice Get the raw tick data of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param tick_ The tick value.\n    /// @return The raw tick data of the vault.\n    // if tick > 0 then key_ = tick / 256\n    // if tick < 0 then key_ = (tick / 256) - 1\n    function getTickDataRaw(address vault_, int tick_) public view returns (uint) {\n        return IFluidVault(vault_).readFromStorage(calculateStorageSlotIntMapping(5, tick_));\n    }\n\n    /// @notice Get the raw tick data of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param key_ The tick key.\n    /// @return The raw tick data of the vault.\n    function getTickHasDebtRaw(address vault_, int key_) public view returns (uint) {\n        return IFluidVault(vault_).readFromStorage(calculateStorageSlotIntMapping(4, key_));\n    }\n\n    /// @notice Get the raw tick data of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param tick_ The tick value.\n    /// @param id_ The ID of the tick.\n    /// @return The raw tick data of the vault.\n    // id_ = (realId_ / 3) + 1\n    function getTickIdDataRaw(address vault_, int tick_, uint id_) public view returns (uint) {\n        return IFluidVault(vault_).readFromStorage(calculateDoubleIntUintMapping(6, tick_, id_));\n    }\n\n    /// @notice Get the raw branch data of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param branch_ The branch value.\n    /// @return The raw branch data of the vault.\n    function getBranchDataRaw(address vault_, uint branch_) public view returns (uint) {\n        return IFluidVault(vault_).readFromStorage(calculateStorageSlotUintMapping(7, branch_));\n    }\n\n    /// @notice Get the raw rate of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The raw rate of the vault.\n    function getRateRaw(address vault_) public view returns (uint) {\n        return IFluidVault(vault_).readFromStorage(normalSlot(8));\n    }\n\n    /// @notice Get the rebalancer of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The rebalancer of the vault.\n    function getRebalancer(address vault_) public view returns (address) {\n        return address(uint160(IFluidVault(vault_).readFromStorage(normalSlot(9))));\n    }\n\n    /// @notice Get the absorbed dust debt of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The absorbed dust debt of the vault.\n    function getAbsorbedDustDebt(address vault_) public view returns (uint) {\n        return IFluidVault(vault_).readFromStorage(normalSlot(10));\n    }\n\n    /// @notice Get the DEX from address of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The DEX from address of the vault.\n    function getDexFromAddress(address vault_) public view returns (address) {\n        return address(uint160(IFluidVault(vault_).readFromStorage(normalSlot(11))));\n    }\n\n    /// @notice Get the total number of vaults.\n    /// @return The total number of vaults.\n    function getTotalVaults() public view returns (uint) {\n        return FACTORY.totalVaults();\n    }\n\n    /// @notice Get the addresses of all the vaults.\n    /// @return vaults_ The addresses of all the vaults.\n    function getAllVaultsAddresses() public view returns (address[] memory vaults_) {\n        uint totalVaults_ = getTotalVaults();\n        vaults_ = new address[](totalVaults_);\n        for (uint i = 0; i < totalVaults_; i++) {\n            vaults_[i] = getVaultAddress((i + 1));\n        }\n    }\n\n    /// @notice Get the contract for deployer index of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param index_ The index of the deployer.\n    /// @return The contract for deployer index of the vault.\n    function getContractForDeployerIndex(address vault_, uint index_) public view returns (address) {\n        IFluidVault.ConstantViews memory constants_ = _getVaultConstants(vault_, getVaultType(vault_));\n        if (constants_.deployer == address(0) || index_ == 0) {\n            return address(0);\n        }\n        return AddressCalcs.addressCalc(constants_.deployer, index_);\n    }\n\n    /// @dev Get the constants of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param vaultType_ The type of the vault.\n    /// @return constants_ The constants of the vault.\n    function _getVaultConstants(\n        address vault_,\n        uint vaultType_\n    ) internal view returns (IFluidVault.ConstantViews memory constants_) {\n        if (vaultType_ == FluidProtocolTypes.VAULT_T1_TYPE) {\n            try IFluidVaultT1(vault_).constantsView() returns (IFluidVaultT1.ConstantViews memory constantsT1_) {\n                constants_.liquidity = constantsT1_.liquidity;\n                constants_.factory = constantsT1_.factory;\n                constants_.operateImplementation = address(vault_);\n                constants_.adminImplementation = constantsT1_.adminImplementation;\n                constants_.secondaryImplementation = constantsT1_.secondaryImplementation;\n                constants_.deployer = address(0);\n                constants_.supply = constantsT1_.liquidity;\n                constants_.borrow = constantsT1_.liquidity;\n                constants_.supplyToken.token0 = constantsT1_.supplyToken;\n                constants_.supplyToken.token1 = address(0);\n                constants_.borrowToken.token0 = constantsT1_.borrowToken;\n                constants_.borrowToken.token1 = address(0);\n                constants_.vaultId = constantsT1_.vaultId;\n                constants_.vaultType = FluidProtocolTypes.VAULT_T1_TYPE;\n                constants_.supplyExchangePriceSlot = constantsT1_.liquiditySupplyExchangePriceSlot;\n                constants_.borrowExchangePriceSlot = constantsT1_.liquidityBorrowExchangePriceSlot;\n                constants_.userSupplySlot = constantsT1_.liquidityUserSupplySlot;\n                constants_.userBorrowSlot = constantsT1_.liquidityUserBorrowSlot;\n            } catch {\n                // vault address is likely not a fluid vault or not deployed yet etc.\n                // vault type is detected as being T1 when TYPE() is not present, which could also happen\n                // on non-Fluid-vault contracts\n            }\n        } else {\n            constants_ = IFluidVault(vault_).constantsView();\n        }\n    }\n\n    /// @dev Get the configuration of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param vaultType_ The type of the vault.\n    /// @return configs_ The configuration of the vault.\n    function _getVaultConfig(address vault_, uint vaultType_) internal view returns (Configs memory configs_) {\n        uint vaultVariables2_ = getVaultVariables2Raw(vault_);\n        configs_.supplyRateMagnifier = uint16(vaultVariables2_ & X16);\n        configs_.borrowRateMagnifier = uint16((vaultVariables2_ >> 16) & X16);\n        configs_.collateralFactor = (uint16((vaultVariables2_ >> 32) & X10)) * 10;\n        configs_.liquidationThreshold = (uint16((vaultVariables2_ >> 42) & X10)) * 10;\n        configs_.liquidationMaxLimit = (uint16((vaultVariables2_ >> 52) & X10) * 10);\n        configs_.withdrawalGap = uint16((vaultVariables2_ >> 62) & X10) * 10;\n        configs_.liquidationPenalty = uint16((vaultVariables2_ >> 72) & X10);\n        configs_.borrowFee = uint16((vaultVariables2_ >> 82) & X10);\n\n        if (vaultType_ == FluidProtocolTypes.VAULT_T1_TYPE) {\n            configs_.oracle = address(uint160(vaultVariables2_ >> 96));\n        } else {\n            /// Next 30 bits => 92-121 => bits to calculate address of oracle\n            uint index_ = (vaultVariables2_ >> 92) & X30;\n            if (index_ > 0) {\n                configs_.oracle = getContractForDeployerIndex(vault_, index_);\n            }\n            /// Next 33 bits => 122-154 => last update timestamp\n            configs_.lastUpdateTimestamp = uint((vaultVariables2_ >> 122) & X33);\n        }\n\n        if (configs_.oracle != address(0)) {\n            try IFluidOracle(configs_.oracle).getExchangeRateOperate() returns (uint exchangeRate_) {\n                configs_.oraclePriceOperate = exchangeRate_;\n                configs_.oraclePriceLiquidate = IFluidOracle(configs_.oracle).getExchangeRateLiquidate();\n            } catch {\n                // deprecated backward compatible for older vaults oracles\n                configs_.oraclePriceOperate = IFluidOracle(configs_.oracle).getExchangeRate();\n                configs_.oraclePriceLiquidate = configs_.oraclePriceOperate;\n            }\n        }\n\n        configs_.rebalancer = getRebalancer(vault_);\n    }\n\n    /// @dev Get the exchange prices and rates of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param vaultType_ The type of the vault.\n    /// @param configs_ The configuration of the vault.\n    /// @param liquiditySupplyRate_ The liquidity supply rate, only set in case of NOT smart collateral.\n    /// @param liquidityBorrowRate_ The liquidity borrow rate, only set in case of NOT smart debt.\n    /// @return exchangePricesAndRates_ The exchange prices and rates of the vault.\n    function _getExchangePricesAndRates(\n        address vault_,\n        uint vaultType_,\n        Configs memory configs_,\n        uint liquiditySupplyRate_,\n        uint liquidityBorrowRate_\n    ) internal view returns (ExchangePricesAndRates memory exchangePricesAndRates_) {\n        uint exchangePrices_ = getRateRaw(vault_);\n        exchangePricesAndRates_.lastStoredLiquiditySupplyExchangePrice = exchangePrices_ & X64;\n        exchangePricesAndRates_.lastStoredLiquidityBorrowExchangePrice = (exchangePrices_ >> 64) & X64;\n        exchangePricesAndRates_.lastStoredVaultSupplyExchangePrice = (exchangePrices_ >> 128) & X64;\n        exchangePricesAndRates_.lastStoredVaultBorrowExchangePrice = (exchangePrices_ >> 192) & X64;\n\n        (\n            exchangePricesAndRates_.liquiditySupplyExchangePrice,\n            exchangePricesAndRates_.liquidityBorrowExchangePrice,\n            exchangePricesAndRates_.vaultSupplyExchangePrice,\n            exchangePricesAndRates_.vaultBorrowExchangePrice\n        ) = IFluidVault(vault_).updateExchangePrices(getVaultVariables2Raw(vault_));\n\n        exchangePricesAndRates_.supplyRateLiquidity = liquiditySupplyRate_;\n        exchangePricesAndRates_.borrowRateLiquidity = liquidityBorrowRate_;\n\n        if (\n            vaultType_ == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE ||\n            vaultType_ == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\n        ) {\n            // in case of smart collateral supply magnifier bits stores supply interest rate positive or negative\n            // negative meaning charging users, positive means incentivizing users\n            exchangePricesAndRates_.supplyRateVault = int256((configs_.supplyRateMagnifier >> 1) & X15);\n            // if first bit == 1 then positive else negative\n            if ((configs_.supplyRateMagnifier & 1) == 0) {\n                exchangePricesAndRates_.supplyRateVault = -exchangePricesAndRates_.supplyRateVault;\n            }\n            exchangePricesAndRates_.rewardsOrFeeRateSupply = exchangePricesAndRates_.supplyRateVault;\n        } else {\n            // NOT smart col\n            exchangePricesAndRates_.supplyRateVault = int256(\n                (liquiditySupplyRate_ * configs_.supplyRateMagnifier) / 10000\n            );\n            exchangePricesAndRates_.rewardsOrFeeRateSupply = int256(uint(configs_.supplyRateMagnifier)) - 10000;\n        }\n\n        if (\n            vaultType_ == FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE ||\n            vaultType_ == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\n        ) {\n            // in case of smart debt borrow magnifier bits stores borrow interest rate positive or negative\n            // negative meaning incentivizing users, positive means charging users\n            exchangePricesAndRates_.borrowRateVault = int256((configs_.borrowRateMagnifier >> 1) & X15);\n            // if first bit == 1 then positive else negative\n            if ((configs_.borrowRateMagnifier & 1) == 0) {\n                exchangePricesAndRates_.borrowRateVault = -exchangePricesAndRates_.borrowRateVault;\n            }\n            exchangePricesAndRates_.rewardsOrFeeRateBorrow = exchangePricesAndRates_.borrowRateVault;\n        } else {\n            // NOT smart debt\n            exchangePricesAndRates_.borrowRateVault = int256(\n                (liquidityBorrowRate_ * configs_.borrowRateMagnifier) / 10000\n            );\n            exchangePricesAndRates_.rewardsOrFeeRateBorrow = -int256(uint(configs_.borrowRateMagnifier)) - 10000;\n        }\n    }\n\n    /// @dev Get the total supply and borrow of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param exchangePricesAndRates_ The exchange prices and rates of the vault.\n    /// @param constantsVariables_ The constants and variables of the vault.\n    /// @return totalSupplyAndBorrow_ The total supply and borrow of the vault.\n    function _getTotalSupplyAndBorrow(\n        address vault_,\n        ExchangePricesAndRates memory exchangePricesAndRates_,\n        IFluidVault.ConstantViews memory constantsVariables_\n    ) internal view returns (TotalSupplyAndBorrow memory totalSupplyAndBorrow_) {\n        uint vaultVariables_ = getVaultVariablesRaw(vault_);\n        uint absorbedLiquidity_ = getAbsorbedLiquidityRaw(vault_);\n        uint totalSupplyLiquidityOrDex_ = IFluidStorageReadable(constantsVariables_.supply).readFromStorage(\n            constantsVariables_.userSupplySlot\n        );\n        // extracting user's supply\n        if (constantsVariables_.supplyToken.token1 == address(0)) {\n            totalSupplyLiquidityOrDex_ =\n                (totalSupplyLiquidityOrDex_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) &\n                X64;\n        } else {\n            totalSupplyLiquidityOrDex_ = (totalSupplyLiquidityOrDex_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n        }\n        // converting big number into normal number\n        totalSupplyLiquidityOrDex_ = (totalSupplyLiquidityOrDex_ >> 8) << (totalSupplyLiquidityOrDex_ & X8);\n\n        uint totalBorrowLiquidityOrDex_ = IFluidStorageReadable(constantsVariables_.borrow).readFromStorage(\n            constantsVariables_.userBorrowSlot\n        );\n        // extracting user's borrow\n        if (constantsVariables_.borrowToken.token1 == address(0)) {\n            totalBorrowLiquidityOrDex_ =\n                (totalBorrowLiquidityOrDex_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) &\n                X64;\n        } else {\n            totalBorrowLiquidityOrDex_ = (totalBorrowLiquidityOrDex_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n        }\n        // converting big number into normal number\n        totalBorrowLiquidityOrDex_ = (totalBorrowLiquidityOrDex_ >> 8) << (totalBorrowLiquidityOrDex_ & X8);\n\n        totalSupplyAndBorrow_.totalSupplyVault = (vaultVariables_ >> 82) & X64;\n        // Converting bignumber into normal number\n        totalSupplyAndBorrow_.totalSupplyVault =\n            (totalSupplyAndBorrow_.totalSupplyVault >> 8) <<\n            (totalSupplyAndBorrow_.totalSupplyVault & X8);\n        totalSupplyAndBorrow_.totalBorrowVault = (vaultVariables_ >> 146) & X64;\n        // Converting bignumber into normal number\n        totalSupplyAndBorrow_.totalBorrowVault =\n            (totalSupplyAndBorrow_.totalBorrowVault >> 8) <<\n            (totalSupplyAndBorrow_.totalBorrowVault & X8);\n\n        totalSupplyAndBorrow_.totalSupplyLiquidityOrDex = totalSupplyLiquidityOrDex_;\n        totalSupplyAndBorrow_.totalBorrowLiquidityOrDex = totalBorrowLiquidityOrDex_;\n\n        totalSupplyAndBorrow_.absorbedBorrow = absorbedLiquidity_ & X128;\n        totalSupplyAndBorrow_.absorbedSupply = absorbedLiquidity_ >> 128;\n\n        // converting raw total supply & total borrow into normal amounts\n        totalSupplyAndBorrow_.totalSupplyVault =\n            (totalSupplyAndBorrow_.totalSupplyVault * exchangePricesAndRates_.vaultSupplyExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n        totalSupplyAndBorrow_.totalBorrowVault =\n            (totalSupplyAndBorrow_.totalBorrowVault * exchangePricesAndRates_.vaultBorrowExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n\n        // below logic multiply with liquidity exchange price also works for case of smart debt / smart col because\n        // liquiditySupplyExchangePrice and liquidityBorrowExchangePrice will be EXCHANGE_PRICES_PRECISION\n        totalSupplyAndBorrow_.totalSupplyLiquidityOrDex =\n            (totalSupplyAndBorrow_.totalSupplyLiquidityOrDex * exchangePricesAndRates_.liquiditySupplyExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n        totalSupplyAndBorrow_.totalBorrowLiquidityOrDex =\n            (totalSupplyAndBorrow_.totalBorrowLiquidityOrDex * exchangePricesAndRates_.liquidityBorrowExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n\n        totalSupplyAndBorrow_.absorbedSupply =\n            (totalSupplyAndBorrow_.absorbedSupply * exchangePricesAndRates_.vaultSupplyExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n        totalSupplyAndBorrow_.absorbedBorrow =\n            (totalSupplyAndBorrow_.absorbedBorrow * exchangePricesAndRates_.vaultBorrowExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n    }\n\n    /// @dev Calculates limits and availability for a user's vault operations.\n    /// @param exchangePricesAndRates_ Exchange prices and rates for the vault.\n    /// @param constantsVariables_ Constants and variables for the vault.\n    /// @param withdrawalGapConfig_ Configuration for the withdrawal gap.\n    /// @param borrowLimit_ The borrow limit for the user. Only set if not smart debt.\n    /// @param borrowLimitUtilization_ The utilization of the borrow limit. Only set if not smart debt.\n    /// @param borrowableUntilLimit_ The limit until which borrowing is allowed. Only set if not smart debt.\n    /// @return limitsAndAvailability_ The calculated limits and availability for the user's vault operations.\n    function _getLimitsAndAvailability(\n        ExchangePricesAndRates memory exchangePricesAndRates_,\n        IFluidVault.ConstantViews memory constantsVariables_,\n        uint withdrawalGapConfig_,\n        uint borrowLimit_,\n        uint borrowLimitUtilization_,\n        uint borrowableUntilLimit_\n    ) internal view returns (LimitsAndAvailability memory limitsAndAvailability_) {\n        // fetching user's supply slot data\n        uint userSupplyLiquidityOrDexData_ = IFluidStorageReadable(constantsVariables_.supply).readFromStorage(\n            constantsVariables_.userSupplySlot\n        );\n        if (userSupplyLiquidityOrDexData_ > 0) {\n            uint userSupply_;\n            uint supplyLimitRaw_;\n            if (constantsVariables_.supply == address(constantsVariables_.liquidity)) {\n                userSupply_ = (userSupplyLiquidityOrDexData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n                userSupply_ = (userSupply_ >> 8) << (userSupply_ & X8);\n\n                supplyLimitRaw_ = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(\n                    userSupplyLiquidityOrDexData_,\n                    userSupply_\n                );\n            } else {\n                // smart col -> using Dex libraries\n                userSupply_ = (userSupplyLiquidityOrDexData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n                userSupply_ = (userSupply_ >> 8) << (userSupply_ & X8);\n\n                supplyLimitRaw_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyLiquidityOrDexData_, userSupply_);\n            }\n\n            // liquiditySupplyExchangePrice is EXCHANGE_PRICES_PRECISION in case of smart col\n            limitsAndAvailability_.withdrawLimit =\n                (supplyLimitRaw_ * exchangePricesAndRates_.liquiditySupplyExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n\n            // totalSupplyLiquidityOrDex = user supply\n            limitsAndAvailability_.withdrawableUntilLimit = userSupply_ > limitsAndAvailability_.withdrawLimit\n                ? userSupply_ - limitsAndAvailability_.withdrawLimit\n                : 0;\n\n            uint withdrawalGap_ = limitsAndAvailability_.withdrawLimit == 0\n                ? 0 // apply withdrawal gap only if withdraw limit is actually active (not below base limit)\n                : (userSupply_ * withdrawalGapConfig_) / 1e4;\n\n            limitsAndAvailability_.withdrawableUntilLimit = (limitsAndAvailability_.withdrawableUntilLimit >\n                withdrawalGap_)\n                ? (((limitsAndAvailability_.withdrawableUntilLimit - withdrawalGap_) * 999999) / 1000000)\n                : 0;\n\n            limitsAndAvailability_.withdrawable = limitsAndAvailability_.withdrawableUntilLimit;\n            if (constantsVariables_.supplyToken.token1 == address(0)) {\n                // NOT smart col -> check withdrawableUntilLimit against available balance at Liquidity\n                // if smart col -> must check manually against balances using data returned at DexResolver\n                uint balanceOf_;\n                if (constantsVariables_.supplyToken.token0 == NATIVE_TOKEN_ADDRESS) {\n                    balanceOf_ = address(constantsVariables_.liquidity).balance;\n                } else {\n                    balanceOf_ = TokenInterface(constantsVariables_.supplyToken.token0).balanceOf(\n                        address(constantsVariables_.liquidity)\n                    );\n                }\n                if (balanceOf_ < limitsAndAvailability_.withdrawableUntilLimit) {\n                    limitsAndAvailability_.withdrawable = limitsAndAvailability_.withdrawableUntilLimit;\n                }\n            }\n        }\n\n        uint userBorrowLiquidityOrDexData_ = IFluidStorageReadable(constantsVariables_.borrow).readFromStorage(\n            constantsVariables_.userBorrowSlot\n        );\n        if (userBorrowLiquidityOrDexData_ > 0) {\n            if (constantsVariables_.borrowToken.token1 == address(0)) {\n                // NOT smart debt. fetch limit from LiquidityResolver\n\n                limitsAndAvailability_.borrowLimit = borrowLimit_;\n                limitsAndAvailability_.borrowLimitUtilization = borrowLimitUtilization_;\n\n                limitsAndAvailability_.borrowableUntilLimit = (borrowableUntilLimit_ * 999999) / 1000000;\n\n                uint balanceOf_;\n                if (constantsVariables_.borrowToken.token0 == NATIVE_TOKEN_ADDRESS) {\n                    balanceOf_ = address(constantsVariables_.liquidity).balance;\n                } else {\n                    balanceOf_ = TokenInterface(constantsVariables_.borrowToken.token0).balanceOf(\n                        address(constantsVariables_.liquidity)\n                    );\n                }\n                limitsAndAvailability_.borrowable = balanceOf_ > limitsAndAvailability_.borrowableUntilLimit\n                    ? limitsAndAvailability_.borrowableUntilLimit\n                    : balanceOf_;\n            } else {\n                // smart debt -> using Dex libraries\n                uint userBorrow_ = (userBorrowLiquidityOrDexData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n                userBorrow_ = (userBorrow_ >> 8) << (userBorrow_ & X8);\n\n                limitsAndAvailability_.borrowLimit = DexCalcs.calcBorrowLimitBeforeOperate(\n                    userBorrowLiquidityOrDexData_,\n                    userBorrow_\n                );\n\n                limitsAndAvailability_.borrowableUntilLimit = limitsAndAvailability_.borrowLimit > userBorrow_\n                    ? limitsAndAvailability_.borrowLimit - userBorrow_\n                    : 0;\n\n                limitsAndAvailability_.borrowableUntilLimit =\n                    (limitsAndAvailability_.borrowableUntilLimit * 999999) /\n                    1000000;\n\n                limitsAndAvailability_.borrowable = limitsAndAvailability_.borrowableUntilLimit;\n            }\n        }\n\n        limitsAndAvailability_.minimumBorrowing =\n            (10001 * exchangePricesAndRates_.vaultBorrowExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n    }\n\n    /// @notice Retrieves the state of a given vault.\n    /// @param vault_ The address of the vault to retrieve the state for.\n    /// @return vaultState_ The state of the vault, including top tick, current and total branches,\n    ///                     total supply and borrow, total positions, and current branch state.\n    function getVaultState(address vault_) public view returns (VaultState memory vaultState_) {\n        uint vaultVariables_ = getVaultVariablesRaw(vault_);\n\n        vaultState_.topTick = tickHelper(((vaultVariables_ >> 2) & X20));\n        vaultState_.currentBranch = (vaultVariables_ >> 22) & X30;\n        vaultState_.totalBranch = (vaultVariables_ >> 52) & X30;\n        vaultState_.totalSupply = BigMathMinified.fromBigNumber((vaultVariables_ >> 82) & X64, 8, X8);\n        vaultState_.totalBorrow = BigMathMinified.fromBigNumber((vaultVariables_ >> 146) & X64, 8, X8);\n        vaultState_.totalPositions = (vaultVariables_ >> 210) & X32;\n\n        uint currentBranchData_ = getBranchDataRaw(vault_, vaultState_.currentBranch);\n        vaultState_.currentBranchState.status = currentBranchData_ & 3;\n        vaultState_.currentBranchState.minimaTick = tickHelper(((currentBranchData_ >> 2) & X20));\n        vaultState_.currentBranchState.debtFactor = (currentBranchData_ >> 116) & X50;\n        vaultState_.currentBranchState.partials = (currentBranchData_ >> 22) & X30;\n        vaultState_.currentBranchState.debtLiquidity = BigMathMinified.fromBigNumber(\n            (currentBranchData_ >> 52) & X64,\n            8,\n            X8\n        );\n        vaultState_.currentBranchState.baseBranchId = (currentBranchData_ >> 166) & X30;\n        vaultState_.currentBranchState.baseBranchMinima = tickHelper(((currentBranchData_ >> 196) & X20));\n    }\n\n    /// @notice Retrieves the entire data for a given vault.\n    /// @param vault_ The address of the vault to retrieve the data for.\n    /// @return vaultData_ The entire data of the vault.\n    function getVaultEntireData(address vault_) public view returns (VaultEntireData memory vaultData_) {\n        vaultData_.vault = vault_;\n        uint vaultType_ = getVaultType(vault_);\n\n        if (vaultType_ != 0) {\n            vaultData_.constantVariables = _getVaultConstants(vault_, vaultType_);\n\n            // in case of NOT smart debt, the borrow limits are fetched from liquidity resolver\n            uint borrowLimit_;\n            uint borrowLimitUtilization_;\n            uint borrowableUntilLimit_;\n\n            {\n                uint liquiditySupplyRate_;\n                uint liquidityBorrowRate_;\n                if (vaultData_.constantVariables.supplyToken.token1 == address(0)) {\n                    // NOT smart col\n                    (\n                        FluidLiquidityResolverStructs.UserSupplyData memory liquidityUserSupplyData_,\n                        FluidLiquidityResolverStructs.OverallTokenData memory liquiditySupplyTokenData_\n                    ) = LIQUIDITY_RESOLVER.getUserSupplyData(vault_, vaultData_.constantVariables.supplyToken.token0);\n\n                    vaultData_.liquidityUserSupplyData = liquidityUserSupplyData_;\n\n                    liquiditySupplyRate_ = liquiditySupplyTokenData_.supplyRate;\n                }\n\n                if (vaultData_.constantVariables.borrowToken.token1 == address(0)) {\n                    // NOT smart debt\n                    (\n                        FluidLiquidityResolverStructs.UserBorrowData memory liquidityUserBorrowData_,\n                        FluidLiquidityResolverStructs.OverallTokenData memory liquidityBorrowTokenData_\n                    ) = LIQUIDITY_RESOLVER.getUserBorrowData(vault_, vaultData_.constantVariables.borrowToken.token0);\n\n                    vaultData_.liquidityUserBorrowData = liquidityUserBorrowData_;\n\n                    liquidityBorrowRate_ = liquidityBorrowTokenData_.borrowRate;\n\n                    borrowLimit_ = liquidityUserBorrowData_.borrowLimit;\n                    borrowLimitUtilization_ = liquidityUserBorrowData_.borrowLimitUtilization;\n                    borrowableUntilLimit_ = liquidityUserBorrowData_.borrowableUntilLimit;\n                }\n\n                vaultData_.configs = _getVaultConfig(vault_, vaultData_.constantVariables.vaultType);\n                vaultData_.exchangePricesAndRates = _getExchangePricesAndRates(\n                    vault_,\n                    vaultType_,\n                    vaultData_.configs,\n                    liquiditySupplyRate_,\n                    liquidityBorrowRate_\n                );\n            }\n            vaultData_.totalSupplyAndBorrow = _getTotalSupplyAndBorrow(\n                vault_,\n                vaultData_.exchangePricesAndRates,\n                vaultData_.constantVariables\n            );\n            vaultData_.limitsAndAvailability = _getLimitsAndAvailability(\n                vaultData_.exchangePricesAndRates,\n                vaultData_.constantVariables,\n                vaultData_.configs.withdrawalGap,\n                borrowLimit_,\n                borrowLimitUtilization_,\n                borrowableUntilLimit_\n            );\n            vaultData_.vaultState = getVaultState(vault_);\n        }\n    }\n\n    /// @notice Retrieves the entire data for a list of vaults.\n    /// @param vaults_ The list of vault addresses.\n    /// @return vaultsData_ An array of VaultEntireData structures containing the data for each vault.\n    function getVaultsEntireData(\n        address[] memory vaults_\n    ) external view returns (VaultEntireData[] memory vaultsData_) {\n        uint length_ = vaults_.length;\n        vaultsData_ = new VaultEntireData[](length_);\n        for (uint i = 0; i < length_; i++) {\n            vaultsData_[i] = getVaultEntireData(vaults_[i]);\n        }\n    }\n\n    /// @notice Retrieves the entire data for all vaults.\n    /// @return vaultsData_ An array of VaultEntireData structures containing the data for each vault.\n    function getVaultsEntireData() external view returns (VaultEntireData[] memory vaultsData_) {\n        address[] memory vaults_ = getAllVaultsAddresses();\n        uint length_ = vaults_.length;\n        vaultsData_ = new VaultEntireData[](length_);\n        for (uint i = 0; i < length_; i++) {\n            vaultsData_[i] = getVaultEntireData(vaults_[i]);\n        }\n    }\n\n    /// @notice Retrieves the position data for a given NFT ID and the corresponding vault data.\n    /// @param nftId_ The NFT ID for which to retrieve the position data.\n    /// @return userPosition_ The UserPosition structure containing the position data.\n    /// @return vaultData_ The VaultEntireData structure containing the vault data.\n    function positionByNftId(\n        uint nftId_\n    ) public view returns (UserPosition memory userPosition_, VaultEntireData memory vaultData_) {\n        userPosition_.nftId = nftId_;\n        address vault_ = vaultByNftId(nftId_);\n        if (vault_ != address(0)) {\n            uint positionData_ = getPositionDataRaw(vault_, nftId_);\n            vaultData_ = getVaultEntireData(vault_);\n\n            userPosition_.owner = FACTORY.ownerOf(nftId_);\n            userPosition_.isSupplyPosition = (positionData_ & 1) == 1;\n            userPosition_.supply = (positionData_ >> 45) & X64;\n            // Converting big number into normal number\n            userPosition_.supply = (userPosition_.supply >> 8) << (userPosition_.supply & X8);\n            userPosition_.beforeSupply = userPosition_.supply;\n            userPosition_.dustBorrow = (positionData_ >> 109) & X64;\n            // Converting big number into normal number\n            userPosition_.dustBorrow = (userPosition_.dustBorrow >> 8) << (userPosition_.dustBorrow & X8);\n            userPosition_.beforeDustBorrow = userPosition_.dustBorrow;\n            if (!userPosition_.isSupplyPosition) {\n                userPosition_.tick = (positionData_ & 2) == 2\n                    ? int((positionData_ >> 2) & X19)\n                    : -int((positionData_ >> 2) & X19);\n                userPosition_.tickId = (positionData_ >> 21) & X24;\n                userPosition_.borrow =\n                    (TickMath.getRatioAtTick(int24(userPosition_.tick)) * userPosition_.supply) >>\n                    96;\n                userPosition_.beforeBorrow = userPosition_.borrow - userPosition_.beforeDustBorrow;\n\n                uint tickData_ = getTickDataRaw(vault_, userPosition_.tick);\n\n                if (((tickData_ & 1) == 1) || (((tickData_ >> 1) & X24) > userPosition_.tickId)) {\n                    // user got liquidated\n                    userPosition_.isLiquidated = true;\n                    (userPosition_.tick, userPosition_.borrow, userPosition_.supply, , ) = IFluidVault(vault_)\n                        .fetchLatestPosition(userPosition_.tick, userPosition_.tickId, userPosition_.borrow, tickData_);\n                }\n\n                if (userPosition_.borrow > userPosition_.dustBorrow) {\n                    userPosition_.borrow = userPosition_.borrow - userPosition_.dustBorrow;\n                } else {\n                    userPosition_.borrow = 0;\n                    userPosition_.dustBorrow = 0;\n                }\n            }\n\n            // converting raw amounts into normal\n            userPosition_.beforeSupply =\n                (userPosition_.beforeSupply * vaultData_.exchangePricesAndRates.vaultSupplyExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n            userPosition_.beforeBorrow =\n                (userPosition_.beforeBorrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n            userPosition_.beforeDustBorrow =\n                (userPosition_.beforeDustBorrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n            userPosition_.supply =\n                (userPosition_.supply * vaultData_.exchangePricesAndRates.vaultSupplyExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n            userPosition_.borrow =\n                (userPosition_.borrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n            userPosition_.dustBorrow =\n                (userPosition_.dustBorrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n        }\n    }\n\n    /// @notice Returns an array of NFT IDs for all positions of a given user.\n    /// @param user_ The address of the user for whom to fetch positions.\n    /// @return nftIds_ An array of NFT IDs representing the user's positions.\n    function positionsNftIdOfUser(address user_) public view returns (uint[] memory nftIds_) {\n        uint totalPositions_ = FACTORY.balanceOf(user_);\n        nftIds_ = new uint[](totalPositions_);\n        for (uint i; i < totalPositions_; i++) {\n            nftIds_[i] = FACTORY.tokenOfOwnerByIndex(user_, i);\n        }\n    }\n\n    /// @notice Returns the vault address associated with a given NFT ID.\n    /// @param nftId_ The NFT ID for which to fetch the vault address.\n    /// @return vault_ The address of the vault associated with the NFT ID.\n    function vaultByNftId(uint nftId_) public view returns (address vault_) {\n        uint tokenConfig_ = getTokenConfig(nftId_);\n        vault_ = FACTORY.getVaultAddress((tokenConfig_ >> 192) & X32);\n    }\n\n    /// @notice Fetches all positions and their corresponding vault data for a given user.\n    /// @param user_ The address of the user for whom to fetch positions and vault data.\n    /// @return userPositions_ An array of UserPosition structs representing the user's positions.\n    /// @return vaultsData_ An array of VaultEntireData structs representing the vault data for each position.\n    function positionsByUser(\n        address user_\n    ) external view returns (UserPosition[] memory userPositions_, VaultEntireData[] memory vaultsData_) {\n        uint[] memory nftIds_ = positionsNftIdOfUser(user_);\n        uint length_ = nftIds_.length;\n        userPositions_ = new UserPosition[](length_);\n        vaultsData_ = new VaultEntireData[](length_);\n        for (uint i = 0; i < length_; i++) {\n            (userPositions_[i], vaultsData_[i]) = positionByNftId(nftIds_[i]);\n        }\n    }\n\n    /// @notice Returns the total number of positions across all users.\n    /// @return The total number of positions.\n    function totalPositions() external view returns (uint) {\n        return FACTORY.totalSupply();\n    }\n\n    /// @notice fetches available liquidations\n    /// @param vault_ address of vault for which to fetch\n    /// @param tokenInAmt_ token in aka debt to payback, leave 0 to get max\n    /// @return liquidationData_ liquidation related data. Check out structs.sol\n    function getVaultLiquidation(\n        address vault_,\n        uint tokenInAmt_\n    ) public returns (LiquidationStruct memory liquidationData_) {\n        tokenInAmt_ = tokenInAmt_ == 0 ? X128 : tokenInAmt_;\n\n        uint vaultType_ = getVaultType(vault_);\n        if (vaultType_ != 0) {\n            liquidationData_.vault = vault_;\n            IFluidVault.ConstantViews memory constants_ = _getVaultConstants(vault_, vaultType_);\n\n            if (constants_.vaultType == FluidProtocolTypes.VAULT_T1_TYPE) {\n                liquidationData_.token0In = constants_.borrowToken.token0;\n                liquidationData_.token0Out = constants_.supplyToken.token0;\n\n                // running without absorb\n                try IFluidVaultT1(vault_).liquidate(tokenInAmt_, 0, 0x000000000000000000000000000000000000dEaD, false) {\n                    // Handle successful execution\n                } catch Error(string memory) {\n                    // Handle generic errors with a reason\n                } catch (bytes memory lowLevelData_) {\n                    (liquidationData_.inAmt, liquidationData_.outAmt) = _decodeLiquidationResult(lowLevelData_);\n                }\n\n                // running with absorb\n                try IFluidVaultT1(vault_).liquidate(tokenInAmt_, 0, 0x000000000000000000000000000000000000dEaD, true) {\n                    // Handle successful execution\n                } catch Error(string memory) {\n                    // Handle generic errors with a reason\n                } catch (bytes memory lowLevelData_) {\n                    (liquidationData_.inAmtWithAbsorb, liquidationData_.outAmtWithAbsorb) = _decodeLiquidationResult(\n                        lowLevelData_\n                    );\n                }\n            } else {\n                liquidationData_.token0In = constants_.borrowToken.token0;\n                liquidationData_.token0Out = constants_.supplyToken.token0;\n                liquidationData_.token1In = constants_.borrowToken.token1;\n                liquidationData_.token1Out = constants_.supplyToken.token1;\n\n                // running without absorb\n                try IFluidVault(vault_).simulateLiquidate(0, false) {\n                    // Handle successful execution\n                } catch Error(string memory) {\n                    // Handle generic errors with a reason\n                } catch (bytes memory lowLevelData_) {\n                    (liquidationData_.inAmt, liquidationData_.outAmt) = _decodeLiquidationResult(lowLevelData_);\n                }\n\n                // running with absorb\n                try IFluidVault(vault_).simulateLiquidate(0, true) {\n                    // Handle successful execution\n                } catch Error(string memory) {\n                    // Handle generic errors with a reason\n                } catch (bytes memory lowLevelData_) {\n                    (liquidationData_.inAmtWithAbsorb, liquidationData_.outAmtWithAbsorb) = _decodeLiquidationResult(\n                        lowLevelData_\n                    );\n                }\n            }\n\n            liquidationData_.absorbAvailable =\n                liquidationData_.inAmtWithAbsorb > liquidationData_.inAmt ||\n                liquidationData_.outAmtWithAbsorb > liquidationData_.outAmt;\n        }\n    }\n\n    /// @dev helper method to decode liquidation result revert data\n    function _decodeLiquidationResult(bytes memory lowLevelData_) internal pure returns (uint amtIn_, uint amtOut_) {\n        // Check if the error data is long enough to contain a selector\n        if (lowLevelData_.length >= 68) {\n            bytes4 errorSelector_;\n            assembly {\n                // Extract the selector from the error data\n                errorSelector_ := mload(add(lowLevelData_, 0x20))\n            }\n            if (errorSelector_ == IFluidVault.FluidLiquidateResult.selector) {\n                assembly {\n                    amtOut_ := mload(add(lowLevelData_, 36))\n                    amtIn_ := mload(add(lowLevelData_, 68))\n                }\n            } // else -> tokenInAmtTwo & tokenOutAmtTwo remains 0\n        }\n    }\n\n    /// @notice Retrieves liquidation data for multiple vaults.\n    /// @param vaults_ The array of vault addresses.\n    /// @param tokensInAmt_ The array of token amounts to liquidate.\n    /// @return liquidationsData_ An array of LiquidationStruct containing the liquidation data for each vault.\n    function getMultipleVaultsLiquidation(\n        address[] memory vaults_,\n        uint[] memory tokensInAmt_\n    ) external returns (LiquidationStruct[] memory liquidationsData_) {\n        uint length_ = vaults_.length;\n        liquidationsData_ = new LiquidationStruct[](length_);\n        for (uint i = 0; i < length_; i++) {\n            liquidationsData_[i] = getVaultLiquidation(vaults_[i], tokensInAmt_[i]);\n        }\n    }\n\n    /// @notice Retrieves liquidation data for all vaults.\n    /// @return liquidationsData_ An array of LiquidationStruct containing the liquidation data for all vaults.\n    function getAllVaultsLiquidation() external returns (LiquidationStruct[] memory liquidationsData_) {\n        address[] memory vaults_ = getAllVaultsAddresses();\n        uint length_ = vaults_.length;\n\n        liquidationsData_ = new LiquidationStruct[](length_);\n        for (uint i = 0; i < length_; i++) {\n            liquidationsData_[i] = getVaultLiquidation(vaults_[i], 0);\n        }\n    }\n\n    /// @notice DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for a single vault.\n    /// @param vault_ The address of the vault.\n    /// @return absorbData_ The AbsorbStruct containing the absorb data for the vault.\n    function getVaultAbsorb(address vault_) public returns (AbsorbStruct memory absorbData_) {\n        absorbData_.vault = vault_;\n        uint absorbedLiquidity_ = getAbsorbedLiquidityRaw(vault_);\n        try IFluidVaultT1(vault_).absorb() {\n            // Handle successful execution\n            uint newAbsorbedLiquidity_ = getAbsorbedLiquidityRaw(vault_);\n            if (newAbsorbedLiquidity_ != absorbedLiquidity_) {\n                absorbData_.absorbAvailable = true;\n            }\n        } catch Error(string memory) {} catch (bytes memory) {}\n    }\n\n    /// @notice DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for multiple vaults.\n    /// @param vaults_ The array of vault addresses.\n    /// @return absorbData_ An array of AbsorbStruct containing the absorb data for each vault.\n    function getVaultsAbsorb(address[] memory vaults_) public returns (AbsorbStruct[] memory absorbData_) {\n        uint length_ = vaults_.length;\n        absorbData_ = new AbsorbStruct[](length_);\n        for (uint i = 0; i < length_; i++) {\n            absorbData_[i] = getVaultAbsorb(vaults_[i]);\n        }\n    }\n\n    /// @notice DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for all vaults.\n    /// @return absorbData_ An array of AbsorbStruct containing the absorb data for all vaults.\n    function getVaultsAbsorb() public returns (AbsorbStruct[] memory absorbData_) {\n        return getVaultsAbsorb(getAllVaultsAddresses());\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vault/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidVault } from \"../../../protocols/vault/interfaces/iVault.sol\";\nimport { Structs as FluidLiquidityResolverStructs } from \"../liquidity/structs.sol\";\n\ncontract Structs {\n    struct Configs {\n        // can be supplyRate instead if Vault Type is smart col. in that case if 1st bit == 1 then positive else negative\n        uint16 supplyRateMagnifier;\n        // can be borrowRate instead if Vault Type is smart debt. in that case if 1st bit == 1 then positive else negative\n        uint16 borrowRateMagnifier;\n        uint16 collateralFactor;\n        uint16 liquidationThreshold;\n        uint16 liquidationMaxLimit;\n        uint16 withdrawalGap;\n        uint16 liquidationPenalty;\n        uint16 borrowFee;\n        address oracle;\n        uint oraclePriceOperate;\n        uint oraclePriceLiquidate;\n        address rebalancer;\n        uint lastUpdateTimestamp;\n    }\n\n    struct ExchangePricesAndRates {\n        uint lastStoredLiquiditySupplyExchangePrice; // 0 in case of smart col\n        uint lastStoredLiquidityBorrowExchangePrice; // 0 in case of smart debt\n        uint lastStoredVaultSupplyExchangePrice;\n        uint lastStoredVaultBorrowExchangePrice;\n        uint liquiditySupplyExchangePrice; // set to 1e12 in case of smart col\n        uint liquidityBorrowExchangePrice; // set to 1e12 in case of smart debt\n        uint vaultSupplyExchangePrice;\n        uint vaultBorrowExchangePrice;\n        uint supplyRateLiquidity; // set to 0 in case of smart col\n        uint borrowRateLiquidity; // set to 0 in case of smart debt\n        int supplyRateVault; // can be negative in case of smart col (meaning pay to supply)\n        int borrowRateVault; // can be negative in case of smart debt (meaning get paid to borrow)\n        int rewardsOrFeeRateSupply; // rewards rate in percent 1e2 precision (1% = 100, 100% = 10000). positive rewards, negative fee\n        int rewardsOrFeeRateBorrow; // rewards rate in percent 1e2 precision (1% = 100, 100% = 10000). positive rewards, negative fee\n    }\n\n    struct TotalSupplyAndBorrow {\n        uint totalSupplyVault;\n        uint totalBorrowVault;\n        uint totalSupplyLiquidityOrDex;\n        uint totalBorrowLiquidityOrDex;\n        uint absorbedSupply;\n        uint absorbedBorrow;\n    }\n\n    struct LimitsAndAvailability {\n        // in case of DEX: withdrawable / borrowable amount of vault at DEX, BUT there could be that DEX can not withdraw\n        // that much at Liquidity! So for DEX this must be combined with returned data in DexResolver.\n        uint withdrawLimit;\n        uint withdrawableUntilLimit;\n        uint withdrawable;\n        uint borrowLimit;\n        uint borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        uint borrowLimitUtilization; // borrow limit for `maxUtilization` config at Liquidity\n        uint minimumBorrowing;\n    }\n\n    struct CurrentBranchState {\n        uint status; // if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\n        int minimaTick;\n        uint debtFactor;\n        uint partials;\n        uint debtLiquidity;\n        uint baseBranchId;\n        int baseBranchMinima;\n    }\n\n    struct VaultState {\n        uint totalPositions;\n        int topTick;\n        uint currentBranch;\n        uint totalBranch;\n        uint totalBorrow;\n        uint totalSupply;\n        CurrentBranchState currentBranchState;\n    }\n\n    struct VaultEntireData {\n        address vault;\n        IFluidVault.ConstantViews constantVariables;\n        Configs configs;\n        ExchangePricesAndRates exchangePricesAndRates;\n        TotalSupplyAndBorrow totalSupplyAndBorrow;\n        LimitsAndAvailability limitsAndAvailability;\n        VaultState vaultState;\n        // liquidity related data such as supply amount, limits, expansion etc.\n        // only set if not smart col!\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyData;\n        // liquidity related data such as borrow amount, limits, expansion etc.\n        // only set if not smart debt!\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowData;\n    }\n\n    struct UserPosition {\n        uint nftId;\n        address owner;\n        bool isLiquidated;\n        bool isSupplyPosition; // if true that means borrowing is 0\n        int tick;\n        uint tickId;\n        uint beforeSupply;\n        uint beforeBorrow;\n        uint beforeDustBorrow;\n        uint supply;\n        uint borrow;\n        uint dustBorrow;\n    }\n\n    /// @dev liquidation related data\n    /// @param vault address of vault\n    /// @param token0In address of token in\n    /// @param token0Out address of token out\n    /// @param token1In address of token in (if smart debt)\n    /// @param token1Out address of token out (if smart col)\n    /// @param inAmt (without absorb liquidity) minimum of available liquidation\n    /// @param outAmt (without absorb liquidity) expected token out, collateral to withdraw\n    /// @param inAmtWithAbsorb (absorb liquidity included) minimum of available liquidation. In most cases it'll be same as inAmt but sometimes can be bigger.\n    /// @param outAmtWithAbsorb (absorb liquidity included) expected token out, collateral to withdraw. In most cases it'll be same as outAmt but sometimes can be bigger.\n    /// @param absorbAvailable true if absorb is available\n    /// @dev Liquidity in with absirb will always be >= without asborb. Sometimes without asborb can provide better swaps,\n    ///      sometimes with absirb can provide better swaps. But available in with absirb will always be >= One\n    struct LiquidationStruct {\n        address vault;\n        address token0In;\n        address token0Out;\n        address token1In;\n        address token1Out;\n        // amounts in case of smart col / smart debt are in shares, otherwise token amounts\n        uint inAmt;\n        uint outAmt;\n        uint inAmtWithAbsorb;\n        uint outAmtWithAbsorb;\n        bool absorbAvailable;\n    }\n\n    struct AbsorbStruct {\n        address vault;\n        bool absorbAvailable;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vault/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidityResolver } from \"../liquidity/iLiquidityResolver.sol\";\nimport { IFluidVaultFactory } from \"../../../protocols/vault/interfaces/iVaultFactory.sol\";\n\ninterface IFluidStorageReadable {\n    function readFromStorage(bytes32 slot_) external view returns (uint result_);\n}\n\ncontract Variables {\n    IFluidVaultFactory public immutable FACTORY;\n    IFluidLiquidityResolver public immutable LIQUIDITY_RESOLVER;\n\n    // 30 bits (used for partials mainly)\n    uint internal constant X8 = 0xff;\n    uint internal constant X10 = 0x3ff;\n    uint internal constant X14 = 0x3fff;\n    uint internal constant X15 = 0x7fff;\n    uint internal constant X16 = 0xffff;\n    uint internal constant X19 = 0x7ffff;\n    uint internal constant X20 = 0xfffff;\n    uint internal constant X24 = 0xffffff;\n    uint internal constant X25 = 0x1ffffff;\n    uint internal constant X30 = 0x3fffffff;\n    uint internal constant X32 = 0xffffffff;\n    uint internal constant X33 = 0x1ffffffff;\n    uint internal constant X35 = 0x7ffffffff;\n    uint internal constant X40 = 0xffffffffff;\n    uint internal constant X50 = 0x3ffffffffffff;\n    uint internal constant X64 = 0xffffffffffffffff;\n    uint internal constant X96 = 0xffffffffffffffffffffffff;\n    uint internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n    /// @dev address that is mapped to the chain native token\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    uint internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    constructor(address factory_, address liquidityResolver_) {\n        FACTORY = IFluidVaultFactory(factory_);\n        LIQUIDITY_RESOLVER = IFluidLiquidityResolver(liquidityResolver_);\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultLiquidation/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Variables } from \"./variables.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { FluidProtocolTypes } from \"../../../libraries/fluidProtocolTypes.sol\";\nimport { Structs as VaultResolverStructs } from \"../vault/structs.sol\";\nimport { IFluidVaultResolver } from \"../vault/iVaultResolver.sol\";\nimport { IFluidVaultT1 } from \"../../../protocols/vault/interfaces/iVaultT1.sol\";\n\n/// @notice Resolver contract that helps in finding available token (liquidation) swaps available in Fluid VaultT1s.\n/// @dev    Note that on the same protocol, if \"withAbsorb = true\" is executed, this also consumes the swap\n///         that would be on the same protocol with \"withAbsorb = false\". So the total available swap amount\n///         at a protocol if both a swap with and without absorb is available is not `with inAmt + without inAmt`\n///         but rather `with inAmt`.\n///         Sometimes with absorb can provide better swaps, sometimes without absorb can provide better swaps.\n///         But available liquidity for \"withAbsorb\" amounts will always be >= without absorb amounts.\n/// @dev    The \"Raw\" methods return both the with and without absorb swaps for the same Fluid Vault, the non-\"Raw\"\n///         methods automatically filter by the better ratio swap. For same cases a better optimization of ratios\n///         is possible with custom logic based on the \"Raw\" methods, see details in comments.\n/// @dev    for native token, send 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE.\n/// @dev    returned swaps Struct can be fed into `getSwapTx` to prepare the tx that executes the swaps.\n/// @dev    non-view methods in this contract are expected to be called with callStatic,\n///         although they would anyway not do any actual state changes.\ncontract FluidVaultLiquidationResolver is Variables, Structs {\n    /// @notice thrown if an input param address is zero\n    error FluidVaultLiquidationsResolver__AddressZero();\n    /// @notice thrown if an invalid param is given to a method\n    error FluidVaultLiquidationsResolver__InvalidParams();\n\n    /// @notice constructor sets the immutable vault resolver address\n    constructor(IFluidVaultResolver vaultResolver_) Variables(vaultResolver_) {\n        if (address(vaultResolver_) == address(0)) {\n            revert FluidVaultLiquidationsResolver__AddressZero();\n        }\n    }\n\n    /// @notice returns all available token swap paths\n    function getAllSwapPaths() public view returns (SwapPath[] memory paths_) {\n        address[] memory vaultAddresses_ = _getVaultT1s();\n        paths_ = new SwapPath[](vaultAddresses_.length);\n\n        address borrowToken_;\n        address supplyToken_;\n        for (uint256 i; i < vaultAddresses_.length; ++i) {\n            (borrowToken_, supplyToken_) = _getVaultTokens(vaultAddresses_[i]);\n            paths_[i] = SwapPath({ protocol: vaultAddresses_[i], tokenIn: borrowToken_, tokenOut: supplyToken_ });\n        }\n    }\n\n    /// @notice returns all swap paths for a certain `tokenIn_` swapped to a `tokenOut_`.\n    ///         returns empty array if no swap path is available for a given pair.\n    function getSwapPaths(address tokenIn_, address tokenOut_) public view returns (SwapPath[] memory paths_) {\n        address[] memory vaultAddresses_ = _getVaultT1s();\n\n        uint256 foundVaultsCount_;\n        address[] memory foundVaults_ = new address[](vaultAddresses_.length);\n\n        address borrowToken_;\n        address supplyToken_;\n        for (uint256 i; i < vaultAddresses_.length; ++i) {\n            (borrowToken_, supplyToken_) = _getVaultTokens(vaultAddresses_[i]);\n\n            if (borrowToken_ == tokenIn_ && supplyToken_ == tokenOut_) {\n                foundVaults_[foundVaultsCount_] = vaultAddresses_[i];\n                ++foundVaultsCount_;\n            }\n        }\n\n        paths_ = new SwapPath[](foundVaultsCount_);\n        for (uint256 i; i < foundVaultsCount_; ++i) {\n            paths_[i] = SwapPath({ protocol: foundVaults_[i], tokenIn: tokenIn_, tokenOut: tokenOut_ });\n        }\n    }\n\n    /// @notice returns all available swap paths for any `tokensIn_` to any `tokensOut_`.\n    function getAnySwapPaths(\n        address[] calldata tokensIn_,\n        address[] calldata tokensOut_\n    ) public view returns (SwapPath[] memory paths_) {\n        SwapPath[] memory maxPaths_ = new SwapPath[](tokensIn_.length * tokensOut_.length);\n\n        address[] memory vaultAddresses_ = _getVaultT1s();\n\n        uint256 matches_;\n\n        address borrowToken_;\n        address supplyToken_;\n        unchecked {\n            for (uint256 vi; vi < vaultAddresses_.length; ++vi) {\n                (borrowToken_, supplyToken_) = _getVaultTokens(vaultAddresses_[vi]);\n\n                // for each vault, iterate over all possible input params token combinations\n                for (uint256 i; i < tokensIn_.length; ++i) {\n                    for (uint256 j; j < tokensOut_.length; ++j) {\n                        if (borrowToken_ == tokensIn_[i] && supplyToken_ == tokensOut_[j]) {\n                            maxPaths_[matches_] = SwapPath({\n                                protocol: vaultAddresses_[vi],\n                                tokenIn: borrowToken_,\n                                tokenOut: supplyToken_\n                            });\n                            ++matches_;\n                        }\n                    }\n                }\n            }\n\n            paths_ = new SwapPath[](matches_);\n            for (uint256 i; i < matches_; ++i) {\n                paths_[i] = maxPaths_[i];\n            }\n        }\n    }\n\n    /// @notice returns the swap data for with and without absorb for a Fluid `vault_`.\n    function getVaultSwapData(\n        address vault_\n    ) public returns (SwapData memory withoutAbsorb_, SwapData memory withAbsorb_) {\n        VaultResolverStructs.LiquidationStruct memory liquidationData_ = VAULT_RESOLVER.getVaultLiquidation(vault_, 0);\n\n        withoutAbsorb_ = SwapData({\n            inAmt: liquidationData_.inAmt,\n            outAmt: liquidationData_.outAmt,\n            withAbsorb: false,\n            ratio: _calcRatio(liquidationData_.inAmt, liquidationData_.outAmt)\n        });\n\n        withAbsorb_ = SwapData({\n            inAmt: liquidationData_.inAmtWithAbsorb,\n            outAmt: liquidationData_.outAmtWithAbsorb,\n            withAbsorb: true,\n            ratio: _calcRatio(liquidationData_.inAmtWithAbsorb, liquidationData_.outAmtWithAbsorb)\n        });\n    }\n\n    /// @notice returns the swap data for with and without absorb for multiple Fluid `vaults_`.\n    function getVaultsSwapData(\n        address[] memory vaults_\n    ) public returns (SwapData[] memory withoutAbsorb_, SwapData[] memory withAbsorb_) {\n        withoutAbsorb_ = new SwapData[](vaults_.length);\n        withAbsorb_ = new SwapData[](vaults_.length);\n        for (uint256 i; i < vaults_.length; ++i) {\n            (withoutAbsorb_[i], withAbsorb_[i]) = getVaultSwapData(vaults_[i]);\n        }\n    }\n\n    /// @notice returns the swap data for with and without absorb for all Fluid vaults.\n    function getAllVaultsSwapData() public returns (SwapData[] memory withoutAbsorb_, SwapData[] memory withAbsorb_) {\n        return getVaultsSwapData(_getVaultT1s());\n    }\n\n    /// @notice returns the available swap amounts at a certain `protocol_`. Only returns non-zero swaps.\n    ///         For vault protocol considering both a swap that uses liquidation with absorb and without absorb.\n    function getSwapForProtocol(address protocol_) public returns (Swap memory swap_) {\n        if (protocol_ == address(0)) {\n            return swap_;\n        }\n\n        (address borrowToken_, address supplyToken_) = _getVaultTokens(protocol_);\n        (SwapData memory withoutAbsorb_, SwapData memory withAbsorb_) = getVaultSwapData(protocol_);\n        return\n            Swap({\n                path: SwapPath({ protocol: protocol_, tokenIn: borrowToken_, tokenOut: supplyToken_ }),\n                data: _getBetterRatioSwapData(withoutAbsorb_, withAbsorb_)\n            });\n    }\n\n    /// @notice returns all available `swaps_` for multiple Fluid `vaults_` raw. Only returns non-zero swaps.\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\n    function getVaultsSwapRaw(address[] memory vaults_) public returns (Swap[] memory swaps_) {\n        unchecked {\n            uint256 nonZeroSwaps_;\n            Swap[] memory allSwaps_ = new Swap[](vaults_.length * 2);\n\n            SwapData memory withoutAbsorb_;\n            SwapData memory withAbsorb_;\n            address borrowToken_;\n            address supplyToken_;\n            for (uint256 i; i < vaults_.length; ++i) {\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(vaults_[i]);\n                if (withAbsorb_.inAmt == 0) {\n                    // if with absorb is 0, then without absorb can only be 0 too\n                    continue;\n                }\n                ++nonZeroSwaps_;\n                if (withAbsorb_.inAmt == withoutAbsorb_.inAmt) {\n                    // with absorb has the same liquidity as without absorb.\n                    // running liquidate() with absorb in that case only costs extra gas. return only without absorb swap\n                    withAbsorb_.inAmt = 0;\n                } else if (withoutAbsorb_.inAmt > 0) {\n                    // both with and without absorb swaps\n                    ++nonZeroSwaps_;\n                }\n\n                (borrowToken_, supplyToken_) = _getVaultTokens(vaults_[i]);\n\n                allSwaps_[i * 2] = Swap({\n                    path: SwapPath({ protocol: vaults_[i], tokenIn: borrowToken_, tokenOut: supplyToken_ }),\n                    data: withoutAbsorb_\n                });\n                allSwaps_[i * 2 + 1] = Swap({\n                    path: SwapPath({ protocol: vaults_[i], tokenIn: borrowToken_, tokenOut: supplyToken_ }),\n                    data: withAbsorb_\n                });\n            }\n\n            return _getNonZeroSwaps(allSwaps_, nonZeroSwaps_);\n        }\n    }\n\n    /// @notice returns all available `swaps_` for all Fluid vaults raw. Only returns non-zero swaps.\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\n    function getAllVaultsSwapRaw() public returns (Swap[] memory swaps_) {\n        return getVaultsSwapRaw(_getVaultT1s());\n    }\n\n    /// @notice returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\n    function getSwapsForPathsRaw(SwapPath[] memory paths_) public returns (Swap[] memory swaps_) {\n        unchecked {\n            Swap[] memory allSwaps_ = new Swap[](paths_.length * 2);\n\n            uint256 nonZeroSwaps_;\n            SwapData memory withoutAbsorb_;\n            SwapData memory withAbsorb_;\n            for (uint256 i; i < paths_.length; ++i) {\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(paths_[i].protocol);\n\n                if (withAbsorb_.inAmt == 0) {\n                    // if with absorb is 0, then without absorb can only be 0 too\n                    continue;\n                }\n                ++nonZeroSwaps_;\n                if (withAbsorb_.inAmt == withoutAbsorb_.inAmt) {\n                    // with absorb has the same liquidity as without absorb.\n                    // running liquidate() with absorb in that case only costs extra gas. return only without absorb swap\n                    withAbsorb_.inAmt = 0;\n                } else if (withoutAbsorb_.inAmt > 0) {\n                    // both with and without absorb swaps\n                    ++nonZeroSwaps_;\n                }\n\n                allSwaps_[i * 2] = Swap({ path: paths_[i], data: withoutAbsorb_ });\n\n                allSwaps_[i * 2 + 1] = Swap({ path: paths_[i], data: withAbsorb_ });\n            }\n\n            swaps_ = new Swap[](nonZeroSwaps_);\n            uint256 index_;\n            for (uint256 i; i < allSwaps_.length; ++i) {\n                if (allSwaps_[i].data.inAmt > 0) {\n                    swaps_[index_] = allSwaps_[i];\n                    ++index_;\n                }\n            }\n        }\n    }\n\n    /// @notice finds all available `swaps_` for `tokenIn_` to `tokenOut_`.\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\n    function getSwapsRaw(address tokenIn_, address tokenOut_) public returns (Swap[] memory swaps_) {\n        return getSwapsForPathsRaw(getSwapPaths(tokenIn_, tokenOut_));\n    }\n\n    /// @notice finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.\n    ///         Token pairs that are not available or where available swap amounts are zero\n    ///         will not be present in the returned `swaps_` array.\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\n    function getAnySwapsRaw(\n        address[] calldata tokensIn_,\n        address[] calldata tokensOut_\n    ) public returns (Swap[] memory swaps_) {\n        return getSwapsForPathsRaw(getAnySwapPaths(tokensIn_, tokensOut_));\n    }\n\n    /// @notice returns all available `swaps_` for multiple Fluid `vaults_`. Only returns non-zero swaps.\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\n    ///         better ratio.\n    function getVaultsSwap(address[] memory vaults_) public returns (Swap[] memory swaps_) {\n        unchecked {\n            uint256 nonZeroSwaps_;\n            Swap[] memory allSwaps_ = new Swap[](vaults_.length);\n\n            SwapData memory withoutAbsorb_;\n            SwapData memory withAbsorb_;\n            Swap memory swap_;\n            for (uint256 i; i < vaults_.length; ++i) {\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(vaults_[i]);\n                swap_ = Swap({\n                    path: SwapPath({ protocol: vaults_[i], tokenIn: address(0), tokenOut: address(0) }),\n                    data: _getBetterRatioSwapData(withoutAbsorb_, withAbsorb_)\n                });\n\n                if (swap_.data.inAmt == 0) {\n                    // no swap available on this vault\n                    continue;\n                }\n\n                ++nonZeroSwaps_;\n\n                (swap_.path.tokenIn, swap_.path.tokenOut) = _getVaultTokens(vaults_[i]);\n\n                allSwaps_[i] = swap_;\n            }\n\n            return _getNonZeroSwaps(allSwaps_, nonZeroSwaps_);\n        }\n    }\n\n    /// @notice returns all available `swaps_` for all Fluid vaults. Only returns non-zero swaps.\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\n    ///         better ratio.\n    function getAllVaultsSwap() public returns (Swap[] memory swaps_) {\n        return getVaultsSwap(_getVaultT1s());\n    }\n\n    /// @notice returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\n    ///         better ratio.\n    function getSwapsForPaths(SwapPath[] memory paths_) public returns (Swap[] memory swaps_) {\n        unchecked {\n            Swap[] memory allSwaps_ = new Swap[](paths_.length);\n\n            uint256 nonZeroSwaps_;\n            Swap memory swap_;\n            SwapData memory withoutAbsorb_;\n            SwapData memory withAbsorb_;\n            for (uint256 i; i < paths_.length; ++i) {\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(paths_[i].protocol);\n                swap_ = Swap({ path: paths_[i], data: _getBetterRatioSwapData(withoutAbsorb_, withAbsorb_) });\n\n                if (swap_.data.inAmt == 0) {\n                    // no swap available on this vault\n                    continue;\n                }\n\n                ++nonZeroSwaps_;\n\n                allSwaps_[i] = swap_;\n            }\n\n            return _getNonZeroSwaps(allSwaps_, nonZeroSwaps_);\n        }\n    }\n\n    /// @notice finds all available `swaps_` for `tokenIn_` to `tokenOut_`.\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\n    ///         better ratio.\n    function getSwaps(address tokenIn_, address tokenOut_) public returns (Swap[] memory swaps_) {\n        return getSwapsForPaths(getSwapPaths(tokenIn_, tokenOut_));\n    }\n\n    /// @notice finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.\n    ///         Token pairs that are not available or where available swap amounts are zero\n    ///         will not be present in the returned `swaps_` array.\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\n    ///         better ratio.\n    function getAnySwaps(\n        address[] calldata tokensIn_,\n        address[] calldata tokensOut_\n    ) public returns (Swap[] memory swaps_) {\n        return getSwapsForPaths(getAnySwapPaths(tokensIn_, tokensOut_));\n    }\n\n    /// @notice returns the calldata to execute a swap as returned by the other methods in this contract.\n    ///         `swap_.data.inAmt` must come from msg.sender, `swap_.data.outAmt` goes to `receiver_`. If the input token\n    ///         is the native token, msg.value must be sent along when triggering the actual call with the returned calldata\n    ///         which should be `swap_.data.inAmt`.\n    /// @param swap_ Swap struct as returned by other methods\n    /// @param receiver_ receiver address that the output token is sent to\n    /// @param slippage_ maximum allowed slippage for the expected output token amount. Reverts iIf received token out\n    ///                  amount is lower than this. in 1e4 percentage, e.g. 1% = 10000, 0.3% = 3000, 0.01% = 100, 0.0001% = 1.\n    /// @return target_ target address where `calldata_` must be executed\n    /// @return calldata_ the calldata that can be used to trigger the liquidation call, resulting in the desired swap.\n    function getSwapTx(\n        Swap calldata swap_,\n        address receiver_,\n        uint256 slippage_\n    ) public pure returns (address target_, bytes memory calldata_) {\n        if (swap_.path.protocol == address(0) || receiver_ == address(0)) {\n            revert FluidVaultLiquidationsResolver__AddressZero();\n        }\n        if (slippage_ >= 1e6 || swap_.data.inAmt == 0 || swap_.data.outAmt == 0) {\n            revert FluidVaultLiquidationsResolver__InvalidParams();\n        }\n\n        uint256 colPerUnitDebt_ = (swap_.data.outAmt * 1e18) / swap_.data.inAmt;\n        colPerUnitDebt_ = (colPerUnitDebt_ * (1e6 - slippage_)) / 1e6; // e.g. 50 * 99% / 100% = 49.5\n\n        calldata_ = abi.encodeWithSelector(\n            IFluidVaultT1(swap_.path.protocol).liquidate.selector,\n            swap_.data.inAmt,\n            colPerUnitDebt_,\n            receiver_,\n            swap_.data.withAbsorb\n        );\n        target_ = swap_.path.protocol;\n    }\n\n    /// @notice returns the same data as `getSwapTx` for an array of input `swaps_` at once.\n    function getSwapTxs(\n        Swap[] calldata swaps_,\n        address receiver_,\n        uint256 slippage_\n    ) public pure returns (address[] memory targets_, bytes[] memory calldatas_) {\n        targets_ = new address[](swaps_.length);\n        calldatas_ = new bytes[](swaps_.length);\n        for (uint256 i; i < swaps_.length; ++i) {\n            (targets_[i], calldatas_[i]) = getSwapTx(swaps_[i], receiver_, slippage_);\n        }\n    }\n\n    /// @notice finds all swaps from `tokenIn_` to `tokenOut_` for an exact input amount `inAmt_`.\n    ///         filters the available swaps and sorts them by ratio, so the returned swaps are the best available\n    ///         swaps to reach the target `inAmt_`.\n    ///         If the full available amount is less than the target `inAmt_`, the available amount is returned as `actualInAmt_`.\n    /// @dev The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better\n    /// but the target swap amount is more than the available without absorb liquidity. For this, currently the available\n    /// withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity.\n    /// The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false\n    /// to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing\n    /// amount up to the target amount with the worse ratio with absorb liquidity.\n    /// @param tokenIn_ input token\n    /// @param tokenOut_ output token\n    /// @param inAmt_ exact input token amount that should be swapped to output token\n    /// @return swaps_ swaps to reach the target amount, sorted by ratio in descending order\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\n    /// @return actualInAmt_ actual input token amount. Can be less than inAmt_ if all available swaps can not cover\n    ///                      the target amount.\n    /// @return outAmt_ output token amount received for `actualInAmt_`\n    function exactInput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 inAmt_\n    ) public returns (Swap[] memory swaps_, uint256 actualInAmt_, uint256 outAmt_) {\n        return filterToTargetInAmt(getSwapsRaw(tokenIn_, tokenOut_), inAmt_);\n    }\n\n    /// @notice finds all swaps from `tokenIn_` to `tokenOut_` for an APPROXIMATE output amount `outAmt_`.\n    ///         filters the available swaps and sorts them by ratio, so the returned swaps are the best available\n    ///         swaps to reach the target `outAmt_`.\n    ///         If the full available amount is less than the target `outAmt_`, the available amount is returned as `actualOutAmt_`.\n    ///         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to\n    ///         approximately estimate the required input amounts to reach a certain output amount. This\n    ///         will change until execution and should be controlled with a maximum slippage.\n    ///         Recommended to use exact input methods instead.\n    /// @dev The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better\n    /// but the target swap amount is more than the available without absorb liquidity. For this currently the available\n    /// withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity.\n    /// The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false\n    /// to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing\n    /// amount up to the target amount with the worse ratio with absorb liquidity.\n    /// @param tokenIn_ input token\n    /// @param tokenOut_ output token\n    /// @param outAmt_ exact output token amount that should be swapped to from input token\n    /// @return swaps_ swaps to reach the target amount, sorted by ratio in descending order\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\n    /// @return inAmt_ input token amount needed to receive `actualOutAmt_`\n    /// @return approxOutAmt_ approximate output token amount. Can be less than `outAmt_` if all available swaps can not cover\n    ///                       the target amount.\n    function approxOutput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 outAmt_\n    ) public returns (Swap[] memory swaps_, uint256 inAmt_, uint256 approxOutAmt_) {\n        return filterToApproxOutAmt(getSwapsRaw(tokenIn_, tokenOut_), outAmt_);\n    }\n\n    /// @notice filters the `swaps_` to the point where `targetInAmt_` is reached.\n    ///         This is best used in combination with the \"Raw\" methods, as the `targetInAmt_` allows for more optimized\n    ///         filtering than otherwise done with the non-\"Raw\" methods.\n    /// @return filteredSwaps_ swaps to reach the target amount, sorted by ratio in descending order\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\n    /// @return actualInAmt_ actual input amount. Can be less than targetInAmt_ if all available swaps can not cover\n    ///                      the target amount.\n    /// @return approxOutAmt_ actual estimated output amount.\n    function filterToTargetInAmt(\n        Swap[] memory swaps_,\n        uint256 targetInAmt_\n    ) public returns (Swap[] memory filteredSwaps_, uint256 actualInAmt_, uint256 approxOutAmt_) {\n        return _filterToTarget(swaps_, targetInAmt_, type(uint256).max);\n    }\n\n    /// @notice filters the `swaps_` to the point where APPROXIMATELY `targetOutAmt_` is reached.\n    ///         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to\n    ///         approximately estimate the required input amounts to reach a certain output amount. This\n    ///         will change until execution and should be controlled with a maximum slippage.\n    ///         Recommended to use exact input methods instead.\n    ///         This is best used in combination with the \"Raw\" methods, as the `targetInAmt_` allows for more optimized\n    ///         filtering than otherwise done with the non-\"Raw\" methods.\n    /// @return filteredSwaps_ swaps to reach the target amount, sorted by ratio in descending order\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\n    /// @return actualInAmt_ actual input amount.\n    /// @return approxOutAmt_ APPROXIMATE actual output amount. Can be less than targetOutAmt_ if all available swaps\n    ///                      can not cover the target amount.\n    function filterToApproxOutAmt(\n        Swap[] memory swaps_,\n        uint256 targetApproxOutAmt_\n    ) public returns (Swap[] memory filteredSwaps_, uint256 actualInAmt_, uint256 approxOutAmt_) {\n        return _filterToTarget(swaps_, type(uint256).max, targetApproxOutAmt_);\n    }\n\n    /// @dev filters the `swaps_` to the point where either `targetInAmt_` or `targetOutAmt_` is reached.\n    ///         To filter only by in or only by out amount, send `type(uint256).max` for the other param.\n    /// @return filteredSwaps_ swaps to reach the target amount, sorted by ratio in descending order\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\n    /// @return actualInAmt_ actual input amount. Can be less than targetInAmt_ if all available swaps can not cover\n    ///                      the target amount.\n    /// @return actualOutAmt_ actual output amount. Can be less than targetOutAmt_ if all available swaps can not cover\n    ///                      the target amount.\n    function _filterToTarget(\n        Swap[] memory swaps_,\n        uint256 targetInAmt_,\n        uint256 targetOutAmt_\n    ) internal returns (Swap[] memory filteredSwaps_, uint256 actualInAmt_, uint256 actualOutAmt_) {\n        swaps_ = _sortByRatio(swaps_);\n        (filteredSwaps_, actualInAmt_, actualOutAmt_) = _filterSwapsUntilTarget(swaps_, targetInAmt_, targetOutAmt_);\n\n        if (actualInAmt_ > targetInAmt_ || actualOutAmt_ > targetOutAmt_) {\n            // reduce last swap in amt to match target in amt\n            uint256 lastSwapIndex_ = filteredSwaps_.length - 1;\n\n            uint256 missingInAmt_;\n            if (actualInAmt_ > targetInAmt_) {\n                // swaps_[i].data.inAmt is causing that we over reach targetInAmt_\n                // so to get missing account from here until targetInAmt_, we only want\n                // swaps_[i].data.inAmt minus whatever is too much (actualInAmt_ - targetInAmt_)\n                missingInAmt_ = filteredSwaps_[lastSwapIndex_].data.inAmt + 1 - (actualInAmt_ - targetInAmt_);\n            } else {\n                // get missing in amt to use for liquidation call input param based on missing out amt and ratio\n                uint256 missingOutAmt_ = filteredSwaps_[lastSwapIndex_].data.outAmt - (actualOutAmt_ - targetOutAmt_);\n\n                // get total available liquidation and the ratios for with absorb vs without absorb\n                VaultResolverStructs.LiquidationStruct memory liquidationDataAvailable_ = VAULT_RESOLVER\n                    .getVaultLiquidation(filteredSwaps_[lastSwapIndex_].path.protocol, 0);\n\n                uint256 withoutAbsorbRatio_ = _calcRatio(\n                    liquidationDataAvailable_.inAmt,\n                    liquidationDataAvailable_.outAmt\n                );\n                // calculate the ratio of the absorb only liquidity part\n                uint256 absorbOnlyRatio_ = _calcRatio(\n                    liquidationDataAvailable_.inAmtWithAbsorb - liquidationDataAvailable_.inAmt,\n                    liquidationDataAvailable_.outAmtWithAbsorb - liquidationDataAvailable_.outAmt\n                );\n                if (absorbOnlyRatio_ > withoutAbsorbRatio_ || liquidationDataAvailable_.outAmt < missingOutAmt_) {\n                    // with absorb has the better ratio than without absorb or without absorb can not fully cover\n                    // the missing out amount. So with absorb has to be run.\n                    // Note for the case liquidationDataAvailable_.outAmt < missingOutAmt_:\n                    // missing in amt would ideally be a combination of the whole without absorb liquidity +\n                    // some left over which has the different (worse) with absorb ratio.\n                    // when running withAbsorb = true, always the whole with absorb liquidity is taken first.\n                    // so to profit of the better without absorb liquidity, this would have to be turned into 2 swaps.\n                    // but this might not always be better because of gas usage etc., so for simplicity we just\n                    // take the whole absorb liquidity first.\n\n                    // check if absorb only liquidity covers the missing out amount, if so then the swap ratio is already known\n                    // as absorbOnlyRatio_ which can be used to derive the required inAmt\n                    uint256 asborbOnlyLiquidity_ = liquidationDataAvailable_.outAmtWithAbsorb -\n                        liquidationDataAvailable_.outAmt;\n                    if (asborbOnlyLiquidity_ >= missingOutAmt_) {\n                        missingInAmt_ = (missingOutAmt_ * 1e27) / absorbOnlyRatio_ + 1;\n                    } else {\n                        // missing in amt is a combination of the whole absorb liquidity + some left over\n                        // which has the different without absorb ratio\n                        missingInAmt_ = (asborbOnlyLiquidity_ * 1e27) / absorbOnlyRatio_ + 1;\n                        missingInAmt_ += ((missingOutAmt_ - asborbOnlyLiquidity_) * 1e27) / withoutAbsorbRatio_ + 1;\n                    }\n                } else {\n                    // without absorb has the better ratio AND missing out amount can be covered by without absorb liquidity\n                    missingInAmt_ = (missingOutAmt_ * 1e27) / withoutAbsorbRatio_ + 1;\n                }\n            }\n\n            VaultResolverStructs.LiquidationStruct memory liquidationData_ = VAULT_RESOLVER.getVaultLiquidation(\n                filteredSwaps_[lastSwapIndex_].path.protocol,\n                missingInAmt_\n            );\n\n            actualInAmt_ -= filteredSwaps_[lastSwapIndex_].data.inAmt;\n            actualOutAmt_ -= filteredSwaps_[lastSwapIndex_].data.outAmt;\n\n            if (filteredSwaps_[lastSwapIndex_].data.withAbsorb) {\n                filteredSwaps_[lastSwapIndex_].data.inAmt = liquidationData_.inAmtWithAbsorb;\n                filteredSwaps_[lastSwapIndex_].data.outAmt = liquidationData_.outAmtWithAbsorb;\n                filteredSwaps_[lastSwapIndex_].data.ratio = _calcRatio(\n                    liquidationData_.inAmtWithAbsorb,\n                    liquidationData_.outAmtWithAbsorb\n                );\n            } else {\n                filteredSwaps_[lastSwapIndex_].data.inAmt = liquidationData_.inAmt;\n                filteredSwaps_[lastSwapIndex_].data.outAmt = liquidationData_.outAmt;\n                filteredSwaps_[lastSwapIndex_].data.ratio = _calcRatio(liquidationData_.inAmt, liquidationData_.outAmt);\n            }\n\n            actualInAmt_ += filteredSwaps_[lastSwapIndex_].data.inAmt;\n            actualOutAmt_ += filteredSwaps_[lastSwapIndex_].data.outAmt;\n        }\n    }\n\n    /// @dev sorts `swaps_` by ratio descending. Higher ratio is better (getting more output for input).\n    ///      Best ratio swap will be at pos 0, second best at pos 1 and so on\n    function _sortByRatio(Swap[] memory swaps_) internal pure returns (Swap[] memory) {\n        bool swapped_;\n        Swap memory helper_;\n        for (uint256 i = 1; i < swaps_.length; i++) {\n            swapped_ = false;\n            for (uint256 j = 0; j < swaps_.length - i; j++) {\n                if (swaps_[j + 1].data.ratio > swaps_[j].data.ratio) {\n                    helper_ = swaps_[j];\n                    swaps_[j] = swaps_[j + 1];\n                    swaps_[j + 1] = helper_;\n                    swapped_ = true;\n                }\n            }\n            if (!swapped_) {\n                return swaps_;\n            }\n        }\n\n        return swaps_;\n    }\n\n    /// @dev filters `swaps_` to exactly reach `targetInAmt_`. Takes into consideration to filter out any swaps\n    ///      where both the withAbsorb and withoutAbsorb swap would be present for the same protocol, only\n    ///      leaving the withAbsorb swap (as that includes withoutAbsorb).\n    ///      Also returns the total in `sumInAmt_` and out `sumOutAmt_` amounts, which will be less than `targetInAmt_`\n    ///      in the case that the target amount can not be reached even with all swaps.\n    function _filterSwapsUntilTarget(\n        Swap[] memory swaps_,\n        uint256 targetInAmt_,\n        uint256 targetOutAmt_\n    ) internal returns (Swap[] memory filteredSwaps_, uint256 sumInAmt_, uint256 sumOutAmt_) {\n        if (swaps_.length == 0) {\n            return (swaps_, 0, 0);\n        }\n        uint256 filteredCount_;\n        // find swaps needed until target in amt\n        while (sumInAmt_ < targetInAmt_ && sumOutAmt_ < targetOutAmt_ && filteredCount_ < swaps_.length) {\n            sumInAmt_ += swaps_[filteredCount_].data.inAmt;\n            sumOutAmt_ += swaps_[filteredCount_].data.outAmt;\n            ++filteredCount_;\n        }\n\n        // must not double count without absorb when with absorb is already present\n        // until filteredCount, for any protocol where with absorb is present,\n        // filter out the without absorb if that swap is present too.\n        // if any is found then the while to find swaps until targetAmt must be run again\n        // as it will be less with the filtered out element deducted.\n        uint256 duplicatesCount_;\n        for (uint256 i; i < filteredCount_ - 1; ++i) {\n            for (uint256 j = i + 1; j < filteredCount_; ++j) {\n                if (swaps_[i].path.protocol == swaps_[j].path.protocol) {\n                    // same protocol present twice (with and without absorb).\n                    // mark without absorb to be removed by setting the inAmt to 0\n                    if (swaps_[i].data.withAbsorb) {\n                        swaps_[j].data.inAmt = 0;\n                    } else {\n                        swaps_[i].data.inAmt = 0;\n                    }\n                    duplicatesCount_++;\n                }\n            }\n        }\n\n        if (duplicatesCount_ > 0) {\n            uint256 index_;\n            // filter swaps that are set to 0\n            filteredSwaps_ = new Swap[](swaps_.length - duplicatesCount_);\n            for (uint256 i; i < swaps_.length; ++i) {\n                if (swaps_[i].data.inAmt > 0) {\n                    filteredSwaps_[index_] = swaps_[i];\n                    ++index_;\n                }\n            }\n\n            // recursive call again to reach target amount as planned.\n            return _filterSwapsUntilTarget(filteredSwaps_, targetInAmt_, targetOutAmt_);\n        }\n\n        // when clean of duplicates -> finished, return filtered swaps and total sumInAmt\n        filteredSwaps_ = new Swap[](filteredCount_);\n        for (uint256 i; i < filteredCount_; ++i) {\n            filteredSwaps_[i] = swaps_[i];\n        }\n        return (filteredSwaps_, sumInAmt_, sumOutAmt_);\n    }\n\n    /// @dev gets the better swap based on ratio of with vs without absorb swap data.\n    function _getBetterRatioSwapData(\n        SwapData memory withoutAbsorb_,\n        SwapData memory withAbsorb_\n    ) internal pure returns (SwapData memory swap_) {\n        if (withAbsorb_.inAmt == 0) {\n            // if ratio == 0, meaning inAmt is 0, then the with absorb swap is returned.\n            return withAbsorb_;\n        }\n\n        if (withAbsorb_.ratio > withoutAbsorb_.ratio) {\n            // If (ratio of withAbsorb > ratio of withoutAbsorb) then always absorb should be true.\n            return withAbsorb_;\n        }\n\n        if (withAbsorb_.ratio == withoutAbsorb_.ratio) {\n            if (withAbsorb_.inAmt == withoutAbsorb_.inAmt) {\n                // with absorb has the same liquidity as without absorb.\n                // running liquidate() with absorb in that case only costs extra gas. return only without absorb swap\n                return withoutAbsorb_;\n            }\n\n            // with absorb has more liquidity, but same ratio -> return with absorb\n            return withAbsorb_;\n        }\n\n        // ratio of without absorb is better.\n        // todo: case where with absorb has worse ratio. but it could have significant more liquidity -> will not be\n        // returned here as long as there is without absorb liquidity...\n        return withoutAbsorb_;\n    }\n\n    /// @dev filters `allSwaps_` to the non zero amount `swaps_`, knowing the `nonZeroSwapsCount_`\n    function _getNonZeroSwaps(\n        Swap[] memory allSwaps_,\n        uint256 nonZeroSwapsCount_\n    ) internal pure returns (Swap[] memory swaps_) {\n        unchecked {\n            swaps_ = new Swap[](nonZeroSwapsCount_);\n            uint256 index_;\n            for (uint256 i; i < allSwaps_.length; ++i) {\n                if (allSwaps_[i].data.inAmt > 0) {\n                    swaps_[index_] = allSwaps_[i];\n                    ++index_;\n                }\n            }\n        }\n    }\n\n    /// @dev gets the `vault_` token in (borrow token) and token out (supply token)\n    function _getVaultTokens(address vault_) internal view returns (address tokenIn_, address tokenOut_) {\n        IFluidVaultT1.ConstantViews memory constants_ = IFluidVaultT1(vault_).constantsView();\n        return (constants_.borrowToken, constants_.supplyToken);\n    }\n\n    /// @dev returns ratio for how much outAmt_ am I getting for inAmt_. scaled by 1e27\n    function _calcRatio(uint256 inAmt_, uint256 outAmt_) internal pure returns (uint256) {\n        if (outAmt_ == 0) {\n            return 0;\n        }\n        return (outAmt_ * 1e27) / inAmt_;\n    }\n\n    /// @dev returns all VaultT1 type protocols at the Fluid VaultFactory\n    function _getVaultT1s() internal view returns (address[] memory) {\n        return FluidProtocolTypes.filterBy(VAULT_RESOLVER.getAllVaultsAddresses(), FluidProtocolTypes.VAULT_T1_TYPE);\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultLiquidation/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Structs {\n    struct SwapPath {\n        ///\n        /// @param protocol vault address at which the token pair is available\n        address protocol;\n        ///\n        /// @param tokenIn input token, borrow token at the vault\n        address tokenIn;\n        ///\n        /// @param tokenOut output token, collateral token at the vault\n        address tokenOut;\n    }\n\n    struct SwapData {\n        ///\n        /// @param inAmt total input token amount\n        uint256 inAmt;\n        ///\n        /// @param outAmt total output token amount received\n        uint256 outAmt;\n        ///\n        /// @param withAbsorb flag for using mode \"withAbsorb\" when calling liquidate() on the Vault.\n        ///                   Is set to true if a) liquidity without absorb would not\n        ///                   cover the desired `inAmt_` or if b) the rate of with absorb is better than without absorb.\n        bool withAbsorb;\n        ///\n        /// @param ratio ratio of outAmt / inAmt scaled by 1e27\n        uint256 ratio;\n    }\n\n    struct Swap {\n        ///\n        /// @param path swap path struct info such as protocol where the swap is available\n        SwapPath path;\n        ///\n        /// @param data swap data struct info such as amounts\n        SwapData data;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultLiquidation/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidVaultResolver } from \"../vault/iVaultResolver.sol\";\n\ncontract Variables {\n    IFluidVaultResolver public immutable VAULT_RESOLVER;\n\n    constructor(IFluidVaultResolver vaultResolver_) {\n        VAULT_RESOLVER = vaultResolver_;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultPositions/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Variables } from \"./variables.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { IFluidVaultFactory } from \"../../../protocols/vault/interfaces/iVaultFactory.sol\";\nimport { Structs as VaultResolverStructs } from \"../vault/structs.sol\";\nimport { IFluidVaultResolver } from \"../vault/iVaultResolver.sol\";\nimport { IFluidVault } from \"../../../protocols/vault/interfaces/iVault.sol\";\nimport { TickMath } from \"../../../libraries/tickMath.sol\";\n\n/// @title Fluid Vault protocol Positions Resolver for all vault types.\n/// @notice This contract resolves positions for Fluid Vaults, providing functionality to retrieve NFT IDs and positions for a given vault.\ncontract FluidVaultPositionsResolver is Variables, Structs {\n    /// @notice thrown if an input param address is zero\n    error FluidVaultPositionsResolver__AddressZero();\n\n    /// @notice constructor sets the immutable vault resolver and vault factory address\n    constructor(\n        IFluidVaultResolver vaultResolver_,\n        IFluidVaultFactory vaultFactory_\n    ) Variables(vaultResolver_, vaultFactory_) {\n        if (address(vaultResolver_) == address(0) || address(vaultFactory_) == address(0)) {\n            revert FluidVaultPositionsResolver__AddressZero();\n        }\n    }\n\n    function getAllVaultNftIds(address vault_) public view returns (uint256[] memory nftIds_) {\n        uint256 totalPositions_ = FACTORY.totalSupply();\n\n        /// get total positions for vault: Next 32 bits => 210-241 => Total positions\n        uint256 totalVaultPositions_ = (VAULT_RESOLVER.getVaultVariablesRaw(vault_) >> 210) & 0xFFFFFFFF;\n        nftIds_ = new uint256[](totalVaultPositions_);\n\n        // get nft Ids belonging to the vault_\n        uint256 nftId_;\n        uint256 j;\n        for (uint256 i; i < totalPositions_; ) {\n            nftId_ = FACTORY.tokenByIndex(i);\n            unchecked {\n                ++i;\n            }\n            if (_vaultByNftId(nftId_) == vault_) {\n                nftIds_[j] = nftId_;\n\n                unchecked {\n                    ++j;\n                }\n            }\n        }\n    }\n\n    function getPositionsForNftIds(uint256[] memory nftIds_) public view returns (UserPosition[] memory positions_) {\n        positions_ = new UserPosition[](nftIds_.length);\n\n        for (uint256 i; i < nftIds_.length; ++i) {\n            address vault_ = _vaultByNftId(nftIds_[i]);\n            if (vault_ == address(0)) {\n                // should never happen but make sure it wouldn't lead to a revert\n                positions_[i] = UserPosition({ nftId: nftIds_[i], owner: address(0), supply: 0, borrow: 0 });\n            } else {\n                (, , uint vaultSupplyExchangePrice_, uint vaultBorrowExchangePrice_) = IFluidVault(vault_)\n                    .updateExchangePrices(VAULT_RESOLVER.getVaultVariables2Raw(vault_));\n\n                positions_[i] = _getVaultPosition(\n                    vault_,\n                    nftIds_[i],\n                    vaultSupplyExchangePrice_,\n                    vaultBorrowExchangePrice_\n                );\n            }\n        }\n    }\n\n    function getAllVaultPositions(address vault_) public view returns (UserPosition[] memory positions_) {\n        if (vault_ != address(0)) {\n            // exchange prices are always the same for the same vault\n            (, , uint vaultSupplyExchangePrice_, uint vaultBorrowExchangePrice_) = IFluidVault(vault_)\n                .updateExchangePrices(VAULT_RESOLVER.getVaultVariables2Raw(vault_));\n\n            uint256 totalPositions_ = FACTORY.totalSupply();\n\n            // get total positions for vault: Next 32 bits => 210-241 => Total positions\n            uint256 totalVaultPositions_ = (VAULT_RESOLVER.getVaultVariablesRaw(vault_) >> 210) & 0xFFFFFFFF;\n            positions_ = new UserPosition[](totalVaultPositions_);\n\n            uint256 nftId_;\n            uint256 j;\n            for (uint256 i; i < totalPositions_; ) {\n                nftId_ = FACTORY.tokenByIndex(i);\n                unchecked {\n                    ++i;\n                }\n\n                if (_vaultByNftId(nftId_) == vault_) {\n                    positions_[j] = _getVaultPosition(\n                        vault_,\n                        nftId_,\n                        vaultSupplyExchangePrice_,\n                        vaultBorrowExchangePrice_\n                    );\n\n                    unchecked {\n                        ++j;\n                    }\n                }\n            }\n        }\n    }\n\n    function _vaultByNftId(uint nftId_) internal view returns (address vault_) {\n        uint tokenConfig_ = FACTORY.readFromStorage(keccak256(abi.encode(nftId_, 3)));\n        vault_ = FACTORY.getVaultAddress((tokenConfig_ >> 192) & X32);\n    }\n\n    function _getVaultPosition(\n        address vault_,\n        uint nftId_,\n        uint vaultSupplyExchangePrice_,\n        uint vaultBorrowExchangePrice_\n    ) internal view returns (UserPosition memory userPosition_) {\n        // @dev code below based on VaultResolver `positionByNftId()`\n        userPosition_.nftId = nftId_;\n        userPosition_.owner = FACTORY.ownerOf(nftId_);\n\n        uint positionData_ = VAULT_RESOLVER.getPositionDataRaw(vault_, nftId_);\n\n        userPosition_.supply = (positionData_ >> 45) & X64;\n        // Converting big number into normal number\n        userPosition_.supply = (userPosition_.supply >> 8) << (userPosition_.supply & X8);\n\n        if ((positionData_ & 1) != 1) {\n            // not just a supply position\n\n            int tick_ = (positionData_ & 2) == 2 ? int((positionData_ >> 2) & X19) : -int((positionData_ >> 2) & X19);\n            userPosition_.borrow = (TickMath.getRatioAtTick(int24(tick_)) * userPosition_.supply) >> 96;\n\n            uint tickData_ = VAULT_RESOLVER.getTickDataRaw(vault_, tick_);\n            uint tickId_ = (positionData_ >> 21) & X24;\n            if (((tickData_ & 1) == 1) || (((tickData_ >> 1) & X24) > tickId_)) {\n                (tick_, userPosition_.borrow, userPosition_.supply, , ) = IFluidVault(vault_).fetchLatestPosition(\n                    tick_,\n                    tickId_,\n                    userPosition_.borrow,\n                    tickData_\n                );\n            }\n\n            uint dustBorrow_ = (positionData_ >> 109) & X64;\n            // Converting big number into normal number\n            dustBorrow_ = (dustBorrow_ >> 8) << (dustBorrow_ & X8);\n\n            if (userPosition_.borrow > dustBorrow_) {\n                userPosition_.borrow = userPosition_.borrow - dustBorrow_;\n            } else {\n                // TODO: Make sure this is right. If borrow is less than dust debt then both gets 0\n                userPosition_.borrow = 0;\n            }\n\n            userPosition_.borrow = (userPosition_.borrow * vaultBorrowExchangePrice_) / 1e12;\n        }\n\n        userPosition_.supply = (userPosition_.supply * vaultSupplyExchangePrice_) / 1e12;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultPositions/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Structs {\n    struct UserPosition {\n        uint nftId;\n        address owner;\n        uint supply;\n        uint borrow;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultPositions/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidVaultResolver } from \"../vault/iVaultResolver.sol\";\nimport { IFluidVaultFactory } from \"../../../protocols/vault/interfaces/iVaultFactory.sol\";\n\ncontract Variables {\n    IFluidVaultResolver public immutable VAULT_RESOLVER;\n    IFluidVaultFactory public immutable FACTORY;\n\n    // 30 bits (used for partials mainly)\n    uint internal constant X8 = 0xff;\n    uint internal constant X19 = 0x7ffff;\n    uint internal constant X24 = 0xffffff;\n    uint internal constant X32 = 0xffffffff;\n    uint internal constant X64 = 0xffffffffffffffff;\n\n    constructor(IFluidVaultResolver vaultResolver_, IFluidVaultFactory vaultFactory_) {\n        VAULT_RESOLVER = vaultResolver_;\n        FACTORY = vaultFactory_;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultT1/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Variables } from \"./variables.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { TickMath } from \"../../../libraries/tickMath.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\n\ncontract Helpers is Variables, Structs {\n    function normalSlot(uint256 slot_) public pure returns (bytes32) {\n        return bytes32(slot_);\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping\n    function calculateStorageSlotUintMapping(uint256 slot_, uint key_) public pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping\n    function calculateStorageSlotIntMapping(uint256 slot_, int key_) public pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping\n    function calculateDoubleIntUintMapping(uint256 slot_, int key1_, uint key2_) public pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n\n    function tickHelper(uint tickRaw_) public pure returns (int tick) {\n        require(tickRaw_ < X20, \"invalid-number\");\n        if (tickRaw_ > 0) {\n            tick = tickRaw_ & 1 == 1 ? int((tickRaw_ >> 1) & X19) : -int((tickRaw_ >> 1) & X19);\n        } else {\n            tick = type(int).min;\n        }\n    }\n\n    constructor(address factory_, address liquidityResolver_) Variables(factory_, liquidityResolver_) {}\n}\n"
    },
    "contracts/periphery/resolvers/vaultT1/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Helpers } from \"./helpers.sol\";\nimport { TickMath } from \"../../../libraries/tickMath.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\nimport { IFluidOracle } from \"../../../oracle/fluidOracle.sol\";\nimport { IFluidVaultT1 } from \"../../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { Structs as FluidLiquidityResolverStructs } from \"../liquidity/structs.sol\";\nimport { LiquiditySlotsLink } from \"../../../libraries/liquiditySlotsLink.sol\";\nimport { LiquidityCalcs } from \"../../../libraries/liquidityCalcs.sol\";\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { FluidProtocolTypes, IFluidProtocol } from \"../../../libraries/fluidProtocolTypes.sol\";\nimport { IFluidStorageReadable } from \"./variables.sol\";\n\ninterface TokenInterface {\n    function balanceOf(address) external view returns (uint);\n}\n\n/// @notice Fluid VaultT1 protocol resolver\n/// ATTENTION: Use VaultResolver instead! This is just a temporary legacy-compatible resolver.\n/// Implements various view-only methods to give easy access to Vault protocol data.\ncontract FluidVaultT1Resolver is Helpers {\n    constructor(address factory_, address liquidityResolver_) Helpers(factory_, liquidityResolver_) {}\n\n    /// @notice Get the address of a vault.\n    /// @param vaultId_ The ID of the vault.\n    /// @return vault_ The address of the vault.\n    function getVaultAddress(uint vaultId_) public view returns (address vault_) {\n        return AddressCalcs.addressCalc(address(FACTORY), vaultId_);\n    }\n\n    /// @notice Get the type of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return vaultType_ The type of the vault. 0 if not a Fluid vault.\n    function getVaultType(address vault_) public view returns (uint vaultType_) {\n        if (vault_.code.length == 0) {\n            return 0;\n        }\n        try IFluidProtocol(vault_).TYPE() returns (uint type_) {\n            return type_;\n        } catch {\n            if (getVaultAddress(getVaultId(vault_)) != vault_) {\n                return 0;\n            }\n            // if TYPE() is not available but address is valid vault id, it must be vault T1\n            return FluidProtocolTypes.VAULT_T1_TYPE;\n        }\n    }\n\n    /// @notice Get the ID of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return id_ The ID of the vault.\n    function getVaultId(address vault_) public view returns (uint id_) {\n        id_ = IFluidVaultT1(vault_).VAULT_ID();\n    }\n\n    /// @notice Get the token configuration.\n    /// @param nftId_ The ID of the NFT.\n    /// @return The token configuration.\n    function getTokenConfig(uint nftId_) public view returns (uint) {\n        return FACTORY.readFromStorage(calculateStorageSlotUintMapping(3, nftId_));\n    }\n\n    /// @notice Get the raw variables of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The raw variables of the vault.\n    function getVaultVariablesRaw(address vault_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(normalSlot(0));\n    }\n\n    /// @notice Get the raw variables of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The raw variables of the vault.\n    function getVaultVariables2Raw(address vault_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(normalSlot(1));\n    }\n\n    /// @notice Get the absorbed liquidity of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The absorbed liquidity of the vault.\n    function getAbsorbedLiquidityRaw(address vault_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(normalSlot(2));\n    }\n\n    /// @notice Get the position data of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param positionId_ The ID of the position.\n    /// @return The position data of the vault.\n    function getPositionDataRaw(address vault_, uint positionId_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(calculateStorageSlotUintMapping(3, positionId_));\n    }\n\n    /// @notice Get the raw tick data of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param tick_ The tick value.\n    /// @return The raw tick data of the vault.\n    // if tick > 0 then key_ = tick / 256\n    // if tick < 0 then key_ = (tick / 256) - 1\n    function getTickDataRaw(address vault_, int tick_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(calculateStorageSlotIntMapping(5, tick_));\n    }\n\n    /// @notice Get the raw tick data of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param key_ The tick key.\n    /// @return The raw tick data of the vault.\n    function getTickHasDebtRaw(address vault_, int key_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(calculateStorageSlotIntMapping(4, key_));\n    }\n\n    /// @notice Get the raw tick data of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param tick_ The tick value.\n    /// @param id_ The ID of the tick.\n    /// @return The raw tick data of the vault.\n    // id_ = (realId_ / 3) + 1\n    function getTickIdDataRaw(address vault_, int tick_, uint id_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(calculateDoubleIntUintMapping(6, tick_, id_));\n    }\n\n    /// @notice Get the raw branch data of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param branch_ The branch value.\n    /// @return The raw branch data of the vault.\n    function getBranchDataRaw(address vault_, uint branch_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(calculateStorageSlotUintMapping(7, branch_));\n    }\n\n    /// @notice Get the raw rate of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The raw rate of the vault.\n    function getRateRaw(address vault_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(normalSlot(8));\n    }\n\n    /// @notice Get the rebalancer of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The rebalancer of the vault.\n    function getRebalancer(address vault_) public view returns (address) {\n        return address(uint160(IFluidVaultT1(vault_).readFromStorage(normalSlot(9))));\n    }\n\n    /// @notice Get the absorbed dust debt of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The absorbed dust debt of the vault.\n    function getAbsorbedDustDebt(address vault_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(normalSlot(10));\n    }\n\n    /// @notice Get the total number of vaults (incl. new vault types).\n    /// @return The total number of vaults.\n    function getTotalVaults() public view returns (uint) {\n        return FACTORY.totalVaults();\n    }\n\n    /// @notice Get the addresses of all the vaults.\n    /// @return vaults_ The addresses of all the vaults.\n    function getAllVaultsAddresses() public view returns (address[] memory vaults_) {\n        uint totalVaults_ = getTotalVaults();\n        vaults_ = new address[](totalVaults_);\n        for (uint i = 0; i < totalVaults_; i++) {\n            vaults_[i] = getVaultAddress((i + 1));\n        }\n        return FluidProtocolTypes.filterBy(vaults_, FluidProtocolTypes.VAULT_T1_TYPE);\n    }\n\n    /// @dev Get the constants of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return constants_ The constants of the vault.\n    function _getVaultConstants(address vault_) internal view returns (IFluidVaultT1.ConstantViews memory constants_) {\n        constants_ = IFluidVaultT1(vault_).constantsView();\n    }\n\n    /// @dev Get the configuration of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return configs_ The configuration of the vault.\n    function _getVaultConfig(address vault_) internal view returns (Configs memory configs_) {\n        uint vaultVariables2_ = getVaultVariables2Raw(vault_);\n        configs_.supplyRateMagnifier = uint16(vaultVariables2_ & X16);\n        configs_.borrowRateMagnifier = uint16((vaultVariables2_ >> 16) & X16);\n        configs_.collateralFactor = (uint16((vaultVariables2_ >> 32) & X10)) * 10;\n        configs_.liquidationThreshold = (uint16((vaultVariables2_ >> 42) & X10)) * 10;\n        configs_.liquidationMaxLimit = (uint16((vaultVariables2_ >> 52) & X10) * 10);\n        configs_.withdrawalGap = uint16((vaultVariables2_ >> 62) & X10) * 10;\n        configs_.liquidationPenalty = uint16((vaultVariables2_ >> 72) & X10);\n        configs_.borrowFee = uint16((vaultVariables2_ >> 82) & X10);\n        configs_.oracle = address(uint160(vaultVariables2_ >> 96));\n\n        if (configs_.oracle != address(0)) {\n            try IFluidOracle(configs_.oracle).getExchangeRateOperate() returns (uint exchangeRate_) {\n                configs_.oraclePriceOperate = exchangeRate_;\n                configs_.oraclePriceLiquidate = IFluidOracle(configs_.oracle).getExchangeRateLiquidate();\n            } catch {\n                // deprecated backward compatible for older vaults oracles\n                configs_.oraclePriceOperate = IFluidOracle(configs_.oracle).getExchangeRate();\n                configs_.oraclePriceLiquidate = configs_.oraclePriceOperate;\n            }\n        }\n\n        configs_.rebalancer = getRebalancer(vault_);\n    }\n\n    /// @dev Get the exchange prices and rates of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param configs_ The configuration of the vault.\n    /// @param liquiditySupplyRate_ The liquidity supply rate\n    /// @param liquidityBorrowRate_ The liquidity borrow rate\n    /// @return exchangePricesAndRates_ The exchange prices and rates of the vault.\n    function _getExchangePricesAndRates(\n        address vault_,\n        Configs memory configs_,\n        uint liquiditySupplyRate_,\n        uint liquidityBorrowRate_\n    ) internal view returns (ExchangePricesAndRates memory exchangePricesAndRates_) {\n        uint exchangePrices_ = getRateRaw(vault_);\n        exchangePricesAndRates_.lastStoredLiquiditySupplyExchangePrice = exchangePrices_ & X64;\n        exchangePricesAndRates_.lastStoredLiquidityBorrowExchangePrice = (exchangePrices_ >> 64) & X64;\n        exchangePricesAndRates_.lastStoredVaultSupplyExchangePrice = (exchangePrices_ >> 128) & X64;\n        exchangePricesAndRates_.lastStoredVaultBorrowExchangePrice = (exchangePrices_ >> 192) & X64;\n\n        (\n            exchangePricesAndRates_.liquiditySupplyExchangePrice,\n            exchangePricesAndRates_.liquidityBorrowExchangePrice,\n            exchangePricesAndRates_.vaultSupplyExchangePrice,\n            exchangePricesAndRates_.vaultBorrowExchangePrice\n        ) = IFluidVaultT1(vault_).updateExchangePrices(getVaultVariables2Raw(vault_));\n\n        exchangePricesAndRates_.supplyRateLiquidity = liquiditySupplyRate_;\n        exchangePricesAndRates_.borrowRateLiquidity = liquidityBorrowRate_;\n\n        exchangePricesAndRates_.supplyRateVault = (liquiditySupplyRate_ * configs_.supplyRateMagnifier) / 10000;\n        exchangePricesAndRates_.borrowRateVault = (liquidityBorrowRate_ * configs_.borrowRateMagnifier) / 10000;\n        exchangePricesAndRates_.rewardsRate = configs_.supplyRateMagnifier > 10000\n            ? configs_.supplyRateMagnifier - 10000\n            : 0;\n    }\n\n    /// @dev Get the total supply and borrow of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param exchangePricesAndRates_ The exchange prices and rates of the vault.\n    /// @param constantsVariables_ The constants and variables of the vault.\n    /// @return totalSupplyAndBorrow_ The total supply and borrow of the vault.\n    function _getTotalSupplyAndBorrow(\n        address vault_,\n        ExchangePricesAndRates memory exchangePricesAndRates_,\n        IFluidVaultT1.ConstantViews memory constantsVariables_\n    ) internal view returns (TotalSupplyAndBorrow memory totalSupplyAndBorrow_) {\n        uint vaultVariables_ = getVaultVariablesRaw(vault_);\n        uint absorbedLiquidity_ = getAbsorbedLiquidityRaw(vault_);\n        uint totalSupplyLiquidity_ = IFluidStorageReadable(constantsVariables_.liquidity).readFromStorage(\n            constantsVariables_.liquidityUserSupplySlot\n        );\n        // extracting user's supply\n        totalSupplyLiquidity_ = (totalSupplyLiquidity_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n        // converting big number into normal number\n        totalSupplyLiquidity_ = (totalSupplyLiquidity_ >> 8) << (totalSupplyLiquidity_ & X8);\n\n        uint totalBorrowLiquidity_ = IFluidStorageReadable(constantsVariables_.liquidity).readFromStorage(\n            constantsVariables_.liquidityUserBorrowSlot\n        );\n        // extracting user's borrow\n        totalBorrowLiquidity_ = (totalBorrowLiquidity_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n        // converting big number into normal number\n        totalBorrowLiquidity_ = (totalBorrowLiquidity_ >> 8) << (totalBorrowLiquidity_ & X8);\n\n        totalSupplyAndBorrow_.totalSupplyVault = (vaultVariables_ >> 82) & X64;\n        // Converting bignumber into normal number\n        totalSupplyAndBorrow_.totalSupplyVault =\n            (totalSupplyAndBorrow_.totalSupplyVault >> 8) <<\n            (totalSupplyAndBorrow_.totalSupplyVault & X8);\n        totalSupplyAndBorrow_.totalBorrowVault = (vaultVariables_ >> 146) & X64;\n        // Converting bignumber into normal number\n        totalSupplyAndBorrow_.totalBorrowVault =\n            (totalSupplyAndBorrow_.totalBorrowVault >> 8) <<\n            (totalSupplyAndBorrow_.totalBorrowVault & X8);\n\n        totalSupplyAndBorrow_.totalSupplyLiquidity = totalSupplyLiquidity_;\n        totalSupplyAndBorrow_.totalBorrowLiquidity = totalBorrowLiquidity_;\n\n        totalSupplyAndBorrow_.absorbedBorrow = absorbedLiquidity_ & X128;\n        totalSupplyAndBorrow_.absorbedSupply = absorbedLiquidity_ >> 128;\n\n        // converting raw total supply & total borrow into normal amounts\n        totalSupplyAndBorrow_.totalSupplyVault =\n            (totalSupplyAndBorrow_.totalSupplyVault * exchangePricesAndRates_.vaultSupplyExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n        totalSupplyAndBorrow_.totalBorrowVault =\n            (totalSupplyAndBorrow_.totalBorrowVault * exchangePricesAndRates_.vaultBorrowExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n\n        // below logic multiply with liquidity exchange price also works for case of smart debt / smart col because\n        // liquiditySupplyExchangePrice and liquidityBorrowExchangePrice will be EXCHANGE_PRICES_PRECISION\n        totalSupplyAndBorrow_.totalSupplyLiquidity =\n            (totalSupplyAndBorrow_.totalSupplyLiquidity * exchangePricesAndRates_.liquiditySupplyExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n        totalSupplyAndBorrow_.totalBorrowLiquidity =\n            (totalSupplyAndBorrow_.totalBorrowLiquidity * exchangePricesAndRates_.liquidityBorrowExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n\n        totalSupplyAndBorrow_.absorbedSupply =\n            (totalSupplyAndBorrow_.absorbedSupply * exchangePricesAndRates_.vaultSupplyExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n        totalSupplyAndBorrow_.absorbedBorrow =\n            (totalSupplyAndBorrow_.absorbedBorrow * exchangePricesAndRates_.vaultBorrowExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n    }\n\n    /// @dev Calculates limits and availability for a user's vault operations.\n    /// @param exchangePricesAndRates_ Exchange prices and rates for the vault.\n    /// @param constantsVariables_ Constants and variables for the vault.\n    /// @param withdrawalGapConfig_ Configuration for the withdrawal gap.\n    /// @param borrowLimit_ The borrow limit for the user. Only set if not smart debt.\n    /// @param borrowLimitUtilization_ The utilization of the borrow limit. Only set if not smart debt.\n    /// @param borrowableUntilLimit_ The limit until which borrowing is allowed. Only set if not smart debt.\n    /// @return limitsAndAvailability_ The calculated limits and availability for the user's vault operations.\n    function _getLimitsAndAvailability(\n        ExchangePricesAndRates memory exchangePricesAndRates_,\n        IFluidVaultT1.ConstantViews memory constantsVariables_,\n        uint withdrawalGapConfig_,\n        uint borrowLimit_,\n        uint borrowLimitUtilization_,\n        uint borrowableUntilLimit_\n    ) internal view returns (LimitsAndAvailability memory limitsAndAvailability_) {\n        // fetching user's supply slot data\n        uint userSupplyLiquidityData_ = IFluidStorageReadable(constantsVariables_.liquidity).readFromStorage(\n            constantsVariables_.liquidityUserSupplySlot\n        );\n        if (userSupplyLiquidityData_ > 0) {\n            uint userSupply_;\n            uint supplyLimitRaw_;\n            userSupply_ = (userSupplyLiquidityData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            userSupply_ = (userSupply_ >> 8) << (userSupply_ & X8);\n\n            supplyLimitRaw_ = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(userSupplyLiquidityData_, userSupply_);\n\n            // liquiditySupplyExchangePrice is EXCHANGE_PRICES_PRECISION in case of smart col\n            limitsAndAvailability_.withdrawLimit =\n                (supplyLimitRaw_ * exchangePricesAndRates_.liquiditySupplyExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n\n            // totalSupplyLiquidity = user supply\n            limitsAndAvailability_.withdrawableUntilLimit = userSupply_ > limitsAndAvailability_.withdrawLimit\n                ? userSupply_ - limitsAndAvailability_.withdrawLimit\n                : 0;\n\n            uint withdrawalGap_ = limitsAndAvailability_.withdrawLimit == 0\n                ? 0 // apply withdrawal gap only if withdraw limit is actually active (not below base limit)\n                : (userSupply_ * withdrawalGapConfig_) / 1e4;\n\n            limitsAndAvailability_.withdrawableUntilLimit = (limitsAndAvailability_.withdrawableUntilLimit >\n                withdrawalGap_)\n                ? (((limitsAndAvailability_.withdrawableUntilLimit - withdrawalGap_) * 999999) / 1000000)\n                : 0;\n\n            limitsAndAvailability_.withdrawable = limitsAndAvailability_.withdrawableUntilLimit;\n            uint balanceOf_;\n            if (constantsVariables_.supplyToken == NATIVE_TOKEN_ADDRESS) {\n                balanceOf_ = address(constantsVariables_.liquidity).balance;\n            } else {\n                balanceOf_ = TokenInterface(constantsVariables_.supplyToken).balanceOf(\n                    address(constantsVariables_.liquidity)\n                );\n            }\n            if (balanceOf_ < limitsAndAvailability_.withdrawableUntilLimit) {\n                limitsAndAvailability_.withdrawable = limitsAndAvailability_.withdrawableUntilLimit;\n            }\n        }\n\n        uint userBorrowLiquidityData_ = IFluidStorageReadable(constantsVariables_.liquidity).readFromStorage(\n            constantsVariables_.liquidityUserBorrowSlot\n        );\n        if (userBorrowLiquidityData_ > 0) {\n            limitsAndAvailability_.borrowLimit = borrowLimit_;\n            limitsAndAvailability_.borrowLimitUtilization = borrowLimitUtilization_;\n\n            limitsAndAvailability_.borrowableUntilLimit = (borrowableUntilLimit_ * 999999) / 1000000;\n\n            uint balanceOf_;\n            if (constantsVariables_.borrowToken == NATIVE_TOKEN_ADDRESS) {\n                balanceOf_ = address(constantsVariables_.liquidity).balance;\n            } else {\n                balanceOf_ = TokenInterface(constantsVariables_.borrowToken).balanceOf(\n                    address(constantsVariables_.liquidity)\n                );\n            }\n            limitsAndAvailability_.borrowable = balanceOf_ > limitsAndAvailability_.borrowableUntilLimit\n                ? limitsAndAvailability_.borrowableUntilLimit\n                : balanceOf_;\n        }\n\n        limitsAndAvailability_.minimumBorrowing =\n            (10001 * exchangePricesAndRates_.vaultBorrowExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n    }\n\n    /// @notice Retrieves the state of a given vault.\n    /// @param vault_ The address of the vault to retrieve the state for.\n    /// @return vaultState_ The state of the vault, including top tick, current and total branches,\n    ///                     total supply and borrow, total positions, and current branch state.\n    function getVaultState(address vault_) public view returns (VaultState memory vaultState_) {\n        uint vaultVariables_ = getVaultVariablesRaw(vault_);\n\n        vaultState_.topTick = tickHelper(((vaultVariables_ >> 2) & X20));\n        vaultState_.currentBranch = (vaultVariables_ >> 22) & X30;\n        vaultState_.totalBranch = (vaultVariables_ >> 52) & X30;\n        vaultState_.totalSupply = BigMathMinified.fromBigNumber((vaultVariables_ >> 82) & X64, 8, X8);\n        vaultState_.totalBorrow = BigMathMinified.fromBigNumber((vaultVariables_ >> 146) & X64, 8, X8);\n        vaultState_.totalPositions = (vaultVariables_ >> 210) & X32;\n\n        uint currentBranchData_ = getBranchDataRaw(vault_, vaultState_.currentBranch);\n        vaultState_.currentBranchState.status = currentBranchData_ & 3;\n        vaultState_.currentBranchState.minimaTick = tickHelper(((currentBranchData_ >> 2) & X20));\n        vaultState_.currentBranchState.debtFactor = (currentBranchData_ >> 116) & X50;\n        vaultState_.currentBranchState.partials = (currentBranchData_ >> 22) & X30;\n        vaultState_.currentBranchState.debtLiquidity = BigMathMinified.fromBigNumber(\n            (currentBranchData_ >> 52) & X64,\n            8,\n            X8\n        );\n        vaultState_.currentBranchState.baseBranchId = (currentBranchData_ >> 166) & X30;\n        vaultState_.currentBranchState.baseBranchMinima = tickHelper(((currentBranchData_ >> 196) & X20));\n    }\n\n    /// @notice Retrieves the entire data for a given vault.\n    /// @param vault_ The address of the vault to retrieve the data for.\n    /// @return vaultData_ The entire data of the vault.\n    function getVaultEntireData(address vault_) public view returns (VaultEntireData memory vaultData_) {\n        vaultData_.vault = vault_;\n        uint vaultType_ = getVaultType(vault_);\n        if (vaultType_ == FluidProtocolTypes.VAULT_T1_TYPE) {\n            vaultData_.constantVariables = _getVaultConstants(vault_);\n\n            // in case of NOT smart debt, the borrow limits are fetched from liquidity resolver\n            uint borrowLimit_;\n            uint borrowLimitUtilization_;\n            uint borrowableUntilLimit_;\n\n            {\n                uint liquiditySupplyRate_;\n                uint liquidityBorrowRate_;\n                (\n                    FluidLiquidityResolverStructs.UserSupplyData memory liquidityUserSupplyData_,\n                    FluidLiquidityResolverStructs.OverallTokenData memory liquiditySupplyTokenData_\n                ) = LIQUIDITY_RESOLVER.getUserSupplyData(vault_, vaultData_.constantVariables.supplyToken);\n\n                vaultData_.liquidityUserSupplyData = liquidityUserSupplyData_;\n\n                liquiditySupplyRate_ = liquiditySupplyTokenData_.supplyRate;\n\n                (\n                    FluidLiquidityResolverStructs.UserBorrowData memory liquidityUserBorrowData_,\n                    FluidLiquidityResolverStructs.OverallTokenData memory liquidityBorrowTokenData_\n                ) = LIQUIDITY_RESOLVER.getUserBorrowData(vault_, vaultData_.constantVariables.borrowToken);\n\n                vaultData_.liquidityUserBorrowData = liquidityUserBorrowData_;\n\n                liquidityBorrowRate_ = liquidityBorrowTokenData_.borrowRate;\n\n                borrowLimit_ = liquidityUserBorrowData_.borrowLimit;\n                borrowLimitUtilization_ = liquidityUserBorrowData_.borrowLimitUtilization;\n                borrowableUntilLimit_ = liquidityUserBorrowData_.borrowableUntilLimit;\n\n                vaultData_.configs = _getVaultConfig(vault_);\n                vaultData_.exchangePricesAndRates = _getExchangePricesAndRates(\n                    vault_,\n                    vaultData_.configs,\n                    liquiditySupplyRate_,\n                    liquidityBorrowRate_\n                );\n            }\n            vaultData_.totalSupplyAndBorrow = _getTotalSupplyAndBorrow(\n                vault_,\n                vaultData_.exchangePricesAndRates,\n                vaultData_.constantVariables\n            );\n            vaultData_.limitsAndAvailability = _getLimitsAndAvailability(\n                vaultData_.exchangePricesAndRates,\n                vaultData_.constantVariables,\n                vaultData_.configs.withdrawalGap,\n                borrowLimit_,\n                borrowLimitUtilization_,\n                borrowableUntilLimit_\n            );\n            vaultData_.vaultState = getVaultState(vault_);\n        }\n    }\n\n    /// @notice Retrieves the entire data for a list of vaults.\n    /// @param vaults_ The list of vault addresses.\n    /// @return vaultsData_ An array of VaultEntireData structures containing the data for each vault.\n    function getVaultsEntireData(\n        address[] memory vaults_\n    ) external view returns (VaultEntireData[] memory vaultsData_) {\n        uint length_ = vaults_.length;\n        vaultsData_ = new VaultEntireData[](length_);\n        for (uint i = 0; i < length_; i++) {\n            vaultsData_[i] = getVaultEntireData(vaults_[i]);\n        }\n    }\n\n    /// @notice Retrieves the entire data for all vaults.\n    /// @return vaultsData_ An array of VaultEntireData structures containing the data for each vault.\n    function getVaultsEntireData() external view returns (VaultEntireData[] memory vaultsData_) {\n        address[] memory vaults_ = getAllVaultsAddresses();\n        uint length_ = vaults_.length;\n        vaultsData_ = new VaultEntireData[](length_);\n        for (uint i = 0; i < length_; i++) {\n            vaultsData_[i] = getVaultEntireData(vaults_[i]);\n        }\n    }\n\n    /// @notice Retrieves the position data for a given NFT ID and the corresponding vault data.\n    /// @param nftId_ The NFT ID for which to retrieve the position data.\n    /// @return userPosition_ The UserPosition structure containing the position data.\n    /// @return vaultData_ The VaultEntireData structure containing the vault data.\n    function positionByNftId(\n        uint nftId_\n    ) public view returns (UserPosition memory userPosition_, VaultEntireData memory vaultData_) {\n        userPosition_.nftId = nftId_;\n        address vault_ = vaultByNftId(nftId_);\n        if (vault_ != address(0)) {\n            uint positionData_ = getPositionDataRaw(vault_, nftId_);\n            vaultData_ = getVaultEntireData(vault_);\n\n            userPosition_.owner = FACTORY.ownerOf(nftId_);\n            userPosition_.isSupplyPosition = (positionData_ & 1) == 1;\n            userPosition_.supply = (positionData_ >> 45) & X64;\n            // Converting big number into normal number\n            userPosition_.supply = (userPosition_.supply >> 8) << (userPosition_.supply & X8);\n            userPosition_.beforeSupply = userPosition_.supply;\n            userPosition_.dustBorrow = (positionData_ >> 109) & X64;\n            // Converting big number into normal number\n            userPosition_.dustBorrow = (userPosition_.dustBorrow >> 8) << (userPosition_.dustBorrow & X8);\n            userPosition_.beforeDustBorrow = userPosition_.dustBorrow;\n            if (!userPosition_.isSupplyPosition) {\n                userPosition_.tick = (positionData_ & 2) == 2\n                    ? int((positionData_ >> 2) & X19)\n                    : -int((positionData_ >> 2) & X19);\n                userPosition_.tickId = (positionData_ >> 21) & X24;\n                userPosition_.borrow =\n                    (TickMath.getRatioAtTick(int24(userPosition_.tick)) * userPosition_.supply) >>\n                    96;\n                userPosition_.beforeBorrow = userPosition_.borrow - userPosition_.beforeDustBorrow;\n\n                uint tickData_ = getTickDataRaw(vault_, userPosition_.tick);\n\n                if (((tickData_ & 1) == 1) || (((tickData_ >> 1) & X24) > userPosition_.tickId)) {\n                    // user got liquidated\n                    userPosition_.isLiquidated = true;\n                    (userPosition_.tick, userPosition_.borrow, userPosition_.supply, , ) = IFluidVaultT1(vault_)\n                        .fetchLatestPosition(userPosition_.tick, userPosition_.tickId, userPosition_.borrow, tickData_);\n                }\n\n                if (userPosition_.borrow > userPosition_.dustBorrow) {\n                    userPosition_.borrow = userPosition_.borrow - userPosition_.dustBorrow;\n                } else {\n                    userPosition_.borrow = 0;\n                    userPosition_.dustBorrow = 0;\n                }\n            }\n\n            // converting raw amounts into normal\n            userPosition_.beforeSupply =\n                (userPosition_.beforeSupply * vaultData_.exchangePricesAndRates.vaultSupplyExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n            userPosition_.beforeBorrow =\n                (userPosition_.beforeBorrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n            userPosition_.beforeDustBorrow =\n                (userPosition_.beforeDustBorrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n            userPosition_.supply =\n                (userPosition_.supply * vaultData_.exchangePricesAndRates.vaultSupplyExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n            userPosition_.borrow =\n                (userPosition_.borrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n            userPosition_.dustBorrow =\n                (userPosition_.dustBorrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n        }\n    }\n\n    /// @notice Returns an array of NFT IDs for all positions of a given user.\n    /// @param user_ The address of the user for whom to fetch positions.\n    /// @return nftIds_ An array of NFT IDs representing the user's positions.\n    function positionsNftIdOfUser(address user_) public view returns (uint[] memory nftIds_) {\n        uint totalPositions_ = FACTORY.balanceOf(user_);\n        nftIds_ = new uint[](totalPositions_);\n        for (uint i; i < totalPositions_; i++) {\n            nftIds_[i] = FACTORY.tokenOfOwnerByIndex(user_, i);\n        }\n    }\n\n    /// @notice Returns the vault address associated with a given NFT ID.\n    /// @param nftId_ The NFT ID for which to fetch the vault address.\n    /// @return vault_ The address of the vault associated with the NFT ID.\n    function vaultByNftId(uint nftId_) public view returns (address vault_) {\n        uint tokenConfig_ = getTokenConfig(nftId_);\n        vault_ = FACTORY.getVaultAddress((tokenConfig_ >> 192) & X32);\n    }\n\n    /// @notice Fetches all positions and their corresponding vault data for a given user.\n    /// @param user_ The address of the user for whom to fetch positions and vault data.\n    /// @return userPositions_ An array of UserPosition structs representing the user's positions.\n    /// @return vaultsData_ An array of VaultEntireData structs representing the vault data for each position.\n    function positionsByUser(\n        address user_\n    ) external view returns (UserPosition[] memory userPositions_, VaultEntireData[] memory vaultsData_) {\n        uint[] memory nftIds_ = positionsNftIdOfUser(user_);\n        uint length_ = nftIds_.length;\n        userPositions_ = new UserPosition[](length_);\n        vaultsData_ = new VaultEntireData[](length_);\n        for (uint i = 0; i < length_; i++) {\n            (userPositions_[i], vaultsData_[i]) = positionByNftId(nftIds_[i]);\n        }\n    }\n\n    /// @notice Returns the total number of positions across all users.\n    /// @return The total number of positions.\n    function totalPositions() external view returns (uint) {\n        return FACTORY.totalSupply();\n    }\n\n    /// @notice fetches available liquidations\n    /// @param vault_ address of vault for which to fetch\n    /// @param tokenInAmt_ token in aka debt to payback, leave 0 to get max\n    /// @return liquidationData_ liquidation related data. Check out structs.sol\n    function getVaultLiquidation(\n        address vault_,\n        uint tokenInAmt_\n    ) public returns (LiquidationStruct memory liquidationData_) {\n        tokenInAmt_ = tokenInAmt_ == 0 ? X128 : tokenInAmt_;\n\n        liquidationData_.vault = vault_;\n\n        uint vaultType_ = getVaultType(vault_);\n        if (vaultType_ == FluidProtocolTypes.VAULT_T1_TYPE) {\n            IFluidVaultT1.ConstantViews memory constants_ = _getVaultConstants(vault_);\n\n            liquidationData_.tokenIn = constants_.borrowToken;\n            liquidationData_.tokenOut = constants_.supplyToken;\n\n            // running without absorb\n            try IFluidVaultT1(vault_).liquidate(tokenInAmt_, 0, 0x000000000000000000000000000000000000dEaD, false) {\n                // Handle successful execution\n            } catch Error(string memory) {\n                // Handle generic errors with a reason\n            } catch (bytes memory lowLevelData_) {\n                (liquidationData_.tokenInAmtOne, liquidationData_.tokenOutAmtOne) = _decodeLiquidationResult(\n                    lowLevelData_\n                );\n            }\n\n            // running with absorb\n            try IFluidVaultT1(vault_).liquidate(tokenInAmt_, 0, 0x000000000000000000000000000000000000dEaD, true) {\n                // Handle successful execution\n            } catch Error(string memory) {\n                // Handle generic errors with a reason\n            } catch (bytes memory lowLevelData_) {\n                (liquidationData_.tokenInAmtTwo, liquidationData_.tokenOutAmtTwo) = _decodeLiquidationResult(\n                    lowLevelData_\n                );\n            }\n        }\n    }\n\n    /// @dev helper method to decode liquidation result revert data\n    function _decodeLiquidationResult(bytes memory lowLevelData_) internal pure returns (uint amtIn_, uint amtOut_) {\n        // Check if the error data is long enough to contain a selector\n        if (lowLevelData_.length >= 68) {\n            bytes4 errorSelector_;\n            assembly {\n                // Extract the selector from the error data\n                errorSelector_ := mload(add(lowLevelData_, 0x20))\n            }\n            if (errorSelector_ == IFluidVaultT1.FluidLiquidateResult.selector) {\n                assembly {\n                    amtOut_ := mload(add(lowLevelData_, 36))\n                    amtIn_ := mload(add(lowLevelData_, 68))\n                }\n            } // else -> tokenInAmtTwo & tokenOutAmtTwo remains 0\n        }\n    }\n\n    /// @notice Retrieves liquidation data for multiple vaults.\n    /// @param vaults_ The array of vault addresses.\n    /// @param tokensInAmt_ The array of token amounts to liquidate.\n    /// @return liquidationsData_ An array of LiquidationStruct containing the liquidation data for each vault.\n    function getMultipleVaultsLiquidation(\n        address[] memory vaults_,\n        uint[] memory tokensInAmt_\n    ) external returns (LiquidationStruct[] memory liquidationsData_) {\n        uint length_ = vaults_.length;\n        liquidationsData_ = new LiquidationStruct[](length_);\n        for (uint i = 0; i < length_; i++) {\n            liquidationsData_[i] = getVaultLiquidation(vaults_[i], tokensInAmt_[i]);\n        }\n    }\n\n    /// @notice Retrieves liquidation data for all vaults.\n    /// @return liquidationsData_ An array of LiquidationStruct containing the liquidation data for all vaults.\n    function getAllVaultsLiquidation() external returns (LiquidationStruct[] memory liquidationsData_) {\n        address[] memory vaults_ = getAllVaultsAddresses();\n        uint length_ = vaults_.length;\n\n        liquidationsData_ = new LiquidationStruct[](length_);\n        for (uint i = 0; i < length_; i++) {\n            liquidationsData_[i] = getVaultLiquidation(vaults_[i], 0);\n        }\n    }\n\n    /// @notice DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for a single vault.\n    /// @param vault_ The address of the vault.\n    /// @return absorbData_ The AbsorbStruct containing the absorb data for the vault.\n    function getVaultAbsorb(address vault_) public returns (AbsorbStruct memory absorbData_) {\n        absorbData_.vault = vault_;\n        uint absorbedLiquidity_ = getAbsorbedLiquidityRaw(vault_);\n        try IFluidVaultT1(vault_).absorb() {\n            // Handle successful execution\n            uint newAbsorbedLiquidity_ = getAbsorbedLiquidityRaw(vault_);\n            if (newAbsorbedLiquidity_ != absorbedLiquidity_) {\n                absorbData_.absorbAvailable = true;\n            }\n        } catch Error(string memory) {} catch (bytes memory) {}\n    }\n\n    /// @notice DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for multiple vaults.\n    /// @param vaults_ The array of vault addresses.\n    /// @return absorbData_ An array of AbsorbStruct containing the absorb data for each vault.\n    function getVaultsAbsorb(address[] memory vaults_) public returns (AbsorbStruct[] memory absorbData_) {\n        uint length_ = vaults_.length;\n        absorbData_ = new AbsorbStruct[](length_);\n        for (uint i = 0; i < length_; i++) {\n            absorbData_[i] = getVaultAbsorb(vaults_[i]);\n        }\n    }\n\n    /// @notice DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for all vaults.\n    /// @return absorbData_ An array of AbsorbStruct containing the absorb data for all vaults.\n    function getVaultsAbsorb() public returns (AbsorbStruct[] memory absorbData_) {\n        return getVaultsAbsorb(getAllVaultsAddresses());\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultT1/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidVaultT1 } from \"../../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { Structs as FluidLiquidityResolverStructs } from \"../liquidity/structs.sol\";\n\ncontract Structs {\n    struct Configs {\n        uint16 supplyRateMagnifier;\n        uint16 borrowRateMagnifier;\n        uint16 collateralFactor;\n        uint16 liquidationThreshold;\n        uint16 liquidationMaxLimit;\n        uint16 withdrawalGap;\n        uint16 liquidationPenalty;\n        uint16 borrowFee;\n        address oracle;\n        uint oraclePriceOperate;\n        uint oraclePriceLiquidate;\n        address rebalancer;\n    }\n\n    struct ExchangePricesAndRates {\n        uint lastStoredLiquiditySupplyExchangePrice;\n        uint lastStoredLiquidityBorrowExchangePrice;\n        uint lastStoredVaultSupplyExchangePrice;\n        uint lastStoredVaultBorrowExchangePrice;\n        uint liquiditySupplyExchangePrice;\n        uint liquidityBorrowExchangePrice;\n        uint vaultSupplyExchangePrice;\n        uint vaultBorrowExchangePrice;\n        uint supplyRateVault;\n        uint borrowRateVault;\n        uint supplyRateLiquidity;\n        uint borrowRateLiquidity;\n        uint rewardsRate; // rewards rate in percent 1e2 precision (1% = 100, 100% = 10000)\n    }\n\n    struct TotalSupplyAndBorrow {\n        uint totalSupplyVault;\n        uint totalBorrowVault;\n        uint totalSupplyLiquidity;\n        uint totalBorrowLiquidity;\n        uint absorbedSupply;\n        uint absorbedBorrow;\n    }\n\n    struct LimitsAndAvailability {\n        uint withdrawLimit;\n        uint withdrawableUntilLimit;\n        uint withdrawable;\n        uint borrowLimit;\n        uint borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        uint borrowLimitUtilization; // borrow limit for `maxUtilization` config at Liquidity\n        uint minimumBorrowing;\n    }\n    struct CurrentBranchState {\n        uint status; // if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\n        int minimaTick;\n        uint debtFactor;\n        uint partials;\n        uint debtLiquidity;\n        uint baseBranchId;\n        int baseBranchMinima;\n    }\n    struct VaultState {\n        uint totalPositions;\n        int topTick;\n        uint currentBranch;\n        uint totalBranch;\n        uint totalBorrow;\n        uint totalSupply;\n        CurrentBranchState currentBranchState;\n    }\n\n    struct VaultEntireData {\n        address vault;\n        IFluidVaultT1.ConstantViews constantVariables;\n        Configs configs;\n        ExchangePricesAndRates exchangePricesAndRates;\n        TotalSupplyAndBorrow totalSupplyAndBorrow;\n        LimitsAndAvailability limitsAndAvailability;\n        VaultState vaultState;\n        // liquidity related data such as supply amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyData;\n        // liquidity related data such as borrow amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowData;\n    }\n\n    struct UserPosition {\n        uint nftId;\n        address owner;\n        bool isLiquidated;\n        bool isSupplyPosition; // if true that means borrowing is 0\n        int tick;\n        uint tickId;\n        uint beforeSupply;\n        uint beforeBorrow;\n        uint beforeDustBorrow;\n        uint supply;\n        uint borrow;\n        uint dustBorrow;\n    }\n\n    /// @dev liquidation related data\n    /// @param vault address of vault\n    /// @param tokenIn_ address of token in\n    /// @param tokenOut_ address of token out\n    /// @param tokenInAmtOne_ (without absorb liquidity) minimum of available liquidation & tokenInAmt_\n    /// @param tokenOutAmtOne_ (without absorb liquidity) expected token out, collateral to withdraw\n    /// @param tokenInAmtTwo_ (absorb liquidity included) minimum of available liquidation & tokenInAmt_. In most cases it'll be same as tokenInAmtOne_ but sometimes can be bigger.\n    /// @param tokenOutAmtTwo_ (absorb liquidity included) expected token out, collateral to withdraw. In most cases it'll be same as tokenOutAmtOne_ but sometimes can be bigger.\n    /// @dev Liquidity in Two will always be >= One. Sometimes One can provide better swaps, sometimes Two can provide better swaps. But available in Two will always be >= One\n    struct LiquidationStruct {\n        address vault;\n        address tokenIn;\n        address tokenOut;\n        uint tokenInAmtOne;\n        uint tokenOutAmtOne;\n        uint tokenInAmtTwo;\n        uint tokenOutAmtTwo;\n    }\n\n    struct AbsorbStruct {\n        address vault;\n        bool absorbAvailable;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultT1/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidityResolver } from \"../liquidity/iLiquidityResolver.sol\";\nimport { IFluidVaultFactory } from \"../../../protocols/vault/interfaces/iVaultFactory.sol\";\n\ninterface IFluidStorageReadable {\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n\ncontract Variables {\n    IFluidVaultFactory public immutable FACTORY;\n    IFluidLiquidityResolver public immutable LIQUIDITY_RESOLVER;\n\n    // 30 bits (used for partials mainly)\n    uint internal constant X8 = 0xff;\n    uint internal constant X10 = 0x3ff;\n    uint internal constant X14 = 0x3fff;\n    uint internal constant X15 = 0x7fff;\n    uint internal constant X16 = 0xffff;\n    uint internal constant X19 = 0x7ffff;\n    uint internal constant X20 = 0xfffff;\n    uint internal constant X24 = 0xffffff;\n    uint internal constant X25 = 0x1ffffff;\n    uint internal constant X30 = 0x3fffffff;\n    uint internal constant X32 = 0xffffffff;\n    uint internal constant X33 = 0x1ffffffff;\n    uint internal constant X35 = 0x7ffffffff;\n    uint internal constant X40 = 0xffffffffff;\n    uint internal constant X50 = 0x3ffffffffffff;\n    uint internal constant X64 = 0xffffffffffffffff;\n    uint internal constant X96 = 0xffffffffffffffffffffffff;\n    uint internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n    /// @dev address that is mapped to the chain native token\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    constructor(address factory_, address liquidityResolver_) {\n        FACTORY = IFluidVaultFactory(factory_);\n        LIQUIDITY_RESOLVER = IFluidLiquidityResolver(liquidityResolver_);\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultTicksBranches/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { TickMath } from \"../../../libraries/tickMath.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\nimport { IFluidVaultResolver } from \"../vault/iVaultResolver.sol\";\nimport { IFluidVault } from \"../../../protocols/vault/interfaces/iVault.sol\";\n\nimport { Structs } from \"./structs.sol\";\nimport { Variables } from \"./variables.sol\";\n\n/// @notice Fluid Vault protocol ticks & branches resolver for all vault types.\ncontract FluidVaultTicksBranchesResolver is Variables, Structs {\n    /// @notice thrown if an input param address is zero\n    error FluidVaultTicksBranchesResolver__AddressZero();\n\n    /// @notice constructor sets the immutable vault resolver address\n    constructor(IFluidVaultResolver vaultResolver_) Variables(vaultResolver_) {\n        if (address(vaultResolver_) == address(0)) {\n            revert FluidVaultTicksBranchesResolver__AddressZero();\n        }\n    }\n\n    function getTicksDebt(\n        address vault_,\n        int fromTick_,\n        uint totalTicks_\n    ) public view returns (TickDebt[] memory ticksDebt_, int toTick_) {\n        int topTick_ = _tickHelper(((VAULT_RESOLVER.getVaultVariablesRaw(vault_) >> 2) & X20));\n\n        fromTick_ = topTick_ < fromTick_ ? topTick_ : fromTick_;\n        if (fromTick_ > type(int).min) {\n            // if fromTick_ == tpye(int).min means top tick is not set, meaning no positions exist\n            int startMapId_ = fromTick_ < 0 ? ((fromTick_ + 1) / 256) - 1 : fromTick_ / 256;\n            // Removing all other after fromTick\n            uint tickHasDebt_;\n            {\n                uint tickHasDebtRaw_ = VAULT_RESOLVER.getTickHasDebtRaw(vault_, startMapId_);\n\n                uint bitsToRemove_ = uint(-fromTick_ + (startMapId_ * 256 + 255));\n                tickHasDebt_ = (tickHasDebtRaw_ << bitsToRemove_) >> bitsToRemove_;\n            }\n\n            // Adding 1 here as toTick_ is inclusive in the data so if totalTicks_ = 400 then it'll only check 400\n            toTick_ = fromTick_ - int(totalTicks_) + 1;\n\n            uint count_ = _countTicksWithDebt(vault_, toTick_, startMapId_, tickHasDebt_);\n\n            (, , uint vaultSupplyExchangePrice_, uint vaultBorrowExchangePrice_) = IFluidVault(vault_)\n                .updateExchangePrices(VAULT_RESOLVER.getVaultVariables2Raw(vault_));\n\n            ticksDebt_ = _populateTicksDebt(\n                vault_,\n                toTick_,\n                startMapId_,\n                tickHasDebt_,\n                count_,\n                vaultSupplyExchangePrice_,\n                vaultBorrowExchangePrice_\n            );\n        }\n    }\n\n    function getMultipleVaultsTicksDebt(\n        address[] memory vaults_,\n        int[] memory fromTicks_,\n        uint[] memory totalTicks_\n    ) public view returns (VaultsTickDebt[] memory vaultsTickDebt_) {\n        uint length_ = vaults_.length;\n\n        vaultsTickDebt_ = new VaultsTickDebt[](length_);\n        for (uint i = 0; i < length_; i++) {\n            (vaultsTickDebt_[i].tickDebt, vaultsTickDebt_[i].toTick) = getTicksDebt(\n                vaults_[i],\n                fromTicks_[i],\n                totalTicks_[i]\n            );\n        }\n    }\n\n    function getAllVaultsTicksDebt(uint totalTicks_) public view returns (VaultsTickDebt[] memory vaultsTickDebt_) {\n        address[] memory vaults_ = VAULT_RESOLVER.getAllVaultsAddresses();\n        uint length_ = vaults_.length;\n\n        vaultsTickDebt_ = new VaultsTickDebt[](length_);\n        for (uint i = 0; i < length_; i++) {\n            (vaultsTickDebt_[i].tickDebt, vaultsTickDebt_[i].toTick) = getTicksDebt(\n                vaults_[i],\n                type(int).max,\n                totalTicks_\n            );\n        }\n    }\n\n    function getBranchesDebt(\n        address vault_,\n        uint fromBranchId_,\n        uint toBranchId_\n    ) public view returns (BranchDebt[] memory branchesDebt_) {\n        uint vaultVariables_ = VAULT_RESOLVER.getVaultVariablesRaw(vault_);\n        uint totalBranch_ = (vaultVariables_ >> 52) & X30;\n        toBranchId_ = (toBranchId_ == 0 ? 1 : toBranchId_);\n        fromBranchId_ = (totalBranch_ < fromBranchId_ ? totalBranch_ : fromBranchId_);\n\n        require(fromBranchId_ >= toBranchId_, \"fromBranchId_ must be greater than or equal to toBranchId_\");\n\n        branchesDebt_ = new BranchDebt[](fromBranchId_ - toBranchId_ + 1);\n\n        uint index_;\n\n        for (uint i = fromBranchId_; i >= toBranchId_; i--) {\n            branchesDebt_[index_++] = _getBranchDebt(vault_, vaultVariables_, i);\n        }\n    }\n\n    function getMultipleVaultsBranchesDebt(\n        address[] memory vaults_,\n        uint[] memory fromBranchIds_,\n        uint[] memory toBranchIds_\n    ) external view returns (BranchesDebt[] memory branchesDebt_) {\n        uint length_ = vaults_.length;\n\n        branchesDebt_ = new BranchesDebt[](length_);\n        for (uint i = 0; i < length_; i++) {\n            branchesDebt_[i].branchDebt = getBranchesDebt(vaults_[i], fromBranchIds_[i], toBranchIds_[i]);\n        }\n    }\n\n    function getAllVaultsBranchesDebt() external view returns (BranchesDebt[] memory branchesDebt_) {\n        address[] memory vaults_ = VAULT_RESOLVER.getAllVaultsAddresses();\n        uint length_ = vaults_.length;\n\n        branchesDebt_ = new BranchesDebt[](length_);\n        for (uint i = 0; i < length_; i++) {\n            branchesDebt_[i].branchDebt = getBranchesDebt(vaults_[i], type(uint).max, 0);\n        }\n    }\n\n    function _populateTicksDebt(\n        address vault_,\n        int toTick_,\n        int mapId_,\n        uint tickHasDebt_,\n        uint count_,\n        uint vaultSupplyExchangePrice_,\n        uint vaultBorrowExchangePrice_\n    ) internal view returns (TickDebt[] memory ticksDebt_) {\n        ticksDebt_ = new TickDebt[](count_);\n\n        count_ = 0; // reuse var for loop index counter\n        int nextTick_;\n        uint tickExistingRawDebt_;\n        uint ratio_;\n        uint collateralRaw_;\n\n        while (true) {\n            while (tickHasDebt_ > 0) {\n                {\n                    uint msb_ = BigMathMinified.mostSignificantBit(tickHasDebt_);\n                    // removing next tick from tickHasDebt\n                    tickHasDebt_ = (tickHasDebt_ << (257 - msb_)) >> (257 - msb_);\n                    nextTick_ = mapId_ * 256 + int(msb_ - 1);\n                }\n                if (nextTick_ < toTick_) {\n                    return ticksDebt_;\n                }\n                tickExistingRawDebt_ = (VAULT_RESOLVER.getTickDataRaw(vault_, nextTick_) >> 25) & X64;\n                tickExistingRawDebt_ = (tickExistingRawDebt_ >> 8) << (tickExistingRawDebt_ & X8);\n                ratio_ = TickMath.getRatioAtTick(nextTick_);\n                collateralRaw_ = (tickExistingRawDebt_ * (1 << 96)) / ratio_;\n                ticksDebt_[count_++] = TickDebt({\n                    debtRaw: tickExistingRawDebt_,\n                    collateralRaw: collateralRaw_,\n                    debtNormal: (tickExistingRawDebt_ * vaultBorrowExchangePrice_) / 1e12,\n                    collateralNormal: (collateralRaw_ * vaultSupplyExchangePrice_) / 1e12,\n                    ratio: ratio_,\n                    tick: nextTick_\n                });\n            }\n\n            if (--mapId_ == -129) {\n                break;\n            }\n\n            tickHasDebt_ = VAULT_RESOLVER.getTickHasDebtRaw(vault_, mapId_);\n        }\n    }\n\n    function _tickHelper(uint tickRaw_) internal pure returns (int tick) {\n        require(tickRaw_ < X20, \"invalid-number\");\n        if (tickRaw_ > 0) {\n            tick = tickRaw_ & 1 == 1 ? int((tickRaw_ >> 1) & X19) : -int((tickRaw_ >> 1) & X19);\n        } else {\n            tick = type(int).min;\n        }\n    }\n\n    function _countTicksWithDebt(\n        address vault_,\n        int toTick_,\n        int mapId_,\n        uint tickHasDebt_\n    ) internal view returns (uint count_) {\n        uint msb_;\n        int nextTick_;\n        while (true) {\n            while (tickHasDebt_ > 0) {\n                msb_ = BigMathMinified.mostSignificantBit(tickHasDebt_);\n                // removing next tick from tickHasDebt\n                tickHasDebt_ = (tickHasDebt_ << (257 - msb_)) >> (257 - msb_);\n                nextTick_ = mapId_ * 256 + int(msb_ - 1);\n                if (nextTick_ < toTick_) {\n                    return count_;\n                }\n                count_++;\n            }\n\n            if (--mapId_ == -129) {\n                break;\n            }\n            tickHasDebt_ = VAULT_RESOLVER.getTickHasDebtRaw(vault_, mapId_);\n        }\n        return count_;\n    }\n\n    function _getBranchDebt(\n        address vault_,\n        uint vaultVariables_,\n        uint branchId_\n    ) internal view returns (BranchDebt memory) {\n        uint currentBranchData_ = VAULT_RESOLVER.getBranchDataRaw(vault_, branchId_);\n\n        int minimaTick_ = _tickHelper((currentBranchData_ >> 2) & X20);\n        uint status_ = currentBranchData_ & 3;\n\n        if (status_ == 0) {\n            // not liquidated status == 0\n            // only current branch can be non-liquidated branch\n            return _getActiveBranchDebt(vaultVariables_, currentBranchData_, branchId_, status_);\n        } else if (status_ == 1) {\n            // liquidated status == 1\n            return _getLiquidatedBranchDebt(vault_, currentBranchData_, branchId_, status_, minimaTick_);\n        } else {\n            // merged status == 2\n            // absorbed status == 3\n            return _getClosedOrMergedBranchDebt(currentBranchData_, branchId_, status_);\n        }\n    }\n\n    function _getActiveBranchDebt(\n        uint vaultVariables_,\n        uint currentBranchData_,\n        uint branchId_,\n        uint status_\n    ) internal pure returns (BranchDebt memory branchDebt_) {\n        int topTick_ = _tickHelper((vaultVariables_ >> 2) & X20);\n\n        uint ratio_ = topTick_ > type(int).min ? TickMath.getRatioAtTick(topTick_) : 0;\n\n        branchDebt_ = BranchDebt({\n            debtRaw: 0,\n            collateralRaw: 0,\n            debtNormal: 0,\n            collateralNormal: 0,\n            branchId: branchId_,\n            status: status_, // active status\n            tick: topTick_, // as branch is not liquidated, just returning topTick for now, as whenever liquidation starts it'll start from topTick\n            partials: 0,\n            ratio: ratio_,\n            debtFactor: (currentBranchData_ >> 116) & X50,\n            baseBranchId: ((currentBranchData_ >> 166) & X30),\n            baseBranchTick: _tickHelper((currentBranchData_ >> 196) & X20) // if == type(int).min, then current branch is master branch\n        });\n    }\n\n    function _getClosedOrMergedBranchDebt(\n        uint currentBranchData_,\n        uint branchId_,\n        uint status_\n    ) internal pure returns (BranchDebt memory branchDebt_) {\n        int baseBranchTick_ = _tickHelper((currentBranchData_ >> 196) & X20);\n        uint ratio_ = baseBranchTick_ > type(int).min ? TickMath.getRatioAtTick(baseBranchTick_) : 0;\n\n        branchDebt_ = BranchDebt({\n            debtRaw: 0,\n            collateralRaw: 0,\n            debtNormal: 0,\n            collateralNormal: 0,\n            branchId: branchId_,\n            status: status_,\n            tick: baseBranchTick_, // as branch is merged/closed, so adding baseBranchTick_ as this is where it went out of existance\n            partials: 0,\n            ratio: ratio_,\n            debtFactor: (currentBranchData_ >> 116) & X50,\n            baseBranchId: ((currentBranchData_ >> 166) & X30),\n            baseBranchTick: baseBranchTick_ // if == type(int).min, then current branch is master branch\n        });\n    }\n\n    function _getLiquidatedBranchDebt(\n        address vault_,\n        uint currentBranchData_,\n        uint branchId_,\n        uint status_,\n        int minimaTick_\n    ) internal view returns (BranchDebt memory branchDebt_) {\n        uint debtLiquidity_ = BigMathMinified.fromBigNumber((currentBranchData_ >> 52) & X64, 8, X8);\n        (uint collateralRaw_, uint ratio_) = _getCollateralRaw(currentBranchData_, debtLiquidity_, minimaTick_);\n\n        (, , uint256 vaultSupplyExchangePrice_, uint256 vaultBorrowExchangePrice_) = IFluidVault(vault_)\n            .updateExchangePrices(VAULT_RESOLVER.getVaultVariables2Raw(vault_));\n\n        branchDebt_ = BranchDebt({\n            debtRaw: debtLiquidity_,\n            collateralRaw: collateralRaw_,\n            debtNormal: (debtLiquidity_ * vaultBorrowExchangePrice_) / 1e12,\n            collateralNormal: (collateralRaw_ * vaultSupplyExchangePrice_) / 1e12,\n            branchId: branchId_,\n            status: status_,\n            tick: minimaTick_, // as branch is merged/closed, so adding baseBranchTick_ as this is where it went out of existance\n            partials: 0,\n            ratio: ratio_,\n            debtFactor: (currentBranchData_ >> 116) & X50,\n            baseBranchId: ((currentBranchData_ >> 166) & X30),\n            baseBranchTick: _tickHelper((currentBranchData_ >> 196) & X20) // if == type(int).min, then current branch is master branch\n        });\n    }\n\n    function _getCollateralRaw(\n        uint currentBranchData_,\n        uint debtLiquidity_,\n        int minimaTick_\n    ) internal pure returns (uint collateralRaw_, uint ratio_) {\n        ratio_ = TickMath.getRatioAtTick(int24(minimaTick_));\n        uint ratioOneLess_ = (ratio_ * 10000) / 10015;\n        uint length_ = ratio_ - ratioOneLess_;\n        uint partials_ = (currentBranchData_ >> 22) & X30;\n        uint currentRatio_ = ratioOneLess_ + ((length_ * partials_) / X30);\n        collateralRaw_ = (debtLiquidity_ * TickMath.ZERO_TICK_SCALED_RATIO) / currentRatio_;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultTicksBranches/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Structs {\n    struct TickDebt {\n        uint256 debtRaw;\n        uint256 collateralRaw;\n        uint256 debtNormal; // debtRaw * exchange price\n        uint256 collateralNormal; // collateralRaw * exchange price\n        uint256 ratio;\n        int256 tick;\n    }\n\n    struct VaultsTickDebt {\n        TickDebt[] tickDebt;\n        int toTick;\n    }\n\n    struct BranchDebt {\n        uint256 debtRaw;\n        uint256 collateralRaw;\n        uint256 debtNormal; // debtRaw * exchange price\n        uint256 collateralNormal; // collateralRaw * exchange price\n        uint256 branchId;\n        uint256 status; // if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\n        int256 tick;\n        uint256 partials;\n        uint256 ratio;\n        uint debtFactor; // debt factor or connection factor\n        uint baseBranchId;\n        int baseBranchTick;\n    }\n\n    struct BranchesDebt {\n        BranchDebt[] branchDebt;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultTicksBranches/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidVaultResolver } from \"../vault/iVaultResolver.sol\";\n\ncontract Variables {\n    IFluidVaultResolver public immutable VAULT_RESOLVER;\n\n    uint internal constant X8 = 0xff;\n    uint internal constant X19 = 0x7ffff;\n    uint internal constant X20 = 0xfffff;\n    uint internal constant X30 = 0x3fffffff;\n    uint internal constant X50 = 0x3ffffffffffff;\n    uint internal constant X64 = 0xffffffffffffffff;\n\n    constructor(IFluidVaultResolver vaultResolver_) {\n        VAULT_RESOLVER = vaultResolver_;\n    }\n}\n"
    },
    "contracts/protocols/dex/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs } from \"./poolT1/coreModule/structs.sol\";\n\nabstract contract Error {\n    error FluidDexError(uint256 errorId_);\n\n    error FluidDexFactoryError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares_);\n\n    error FluidDexPricesAndExchangeRates(Structs.PricesAndExchangePrice pex_);\n}\n"
    },
    "contracts/protocols/dex/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |             DexT1                 | \n    |__________________________________*/\n\n    /// @notice thrown at reentrancy\n    uint256 internal constant DexT1__AlreadyEntered = 51001;\n\n    uint256 internal constant DexT1__NotAnAuth = 51002;\n\n    uint256 internal constant DexT1__SmartColNotEnabled = 51003;\n\n    uint256 internal constant DexT1__SmartDebtNotEnabled = 51004;\n\n    uint256 internal constant DexT1__PoolNotInitialized = 51005;\n\n    uint256 internal constant DexT1__TokenReservesTooLow = 51006;\n\n    uint256 internal constant DexT1__EthAndAmountInMisMatch = 51007;\n\n    uint256 internal constant DexT1__EthSentForNonNativeSwap = 51008;\n\n    uint256 internal constant DexT1__NoSwapRoute = 51009;\n\n    uint256 internal constant DexT1__NotEnoughAmountOut = 51010;\n\n    uint256 internal constant DexT1__LiquidityLayerTokenUtilizationCapReached = 51011;\n\n    uint256 internal constant DexT1__HookReturnedFalse = 51012;\n\n    // Either user's config are not set or user is paused\n    uint256 internal constant DexT1__UserSupplyInNotOn = 51013;\n\n    // Either user's config are not set or user is paused\n    uint256 internal constant DexT1__UserDebtInNotOn = 51014;\n\n    // Thrown when contract asks for more token0 or token1 than what user's wants to give on deposit\n    uint256 internal constant DexT1__AboveDepositMax = 51015;\n\n    uint256 internal constant DexT1__MsgValueLowOnDepositOrPayback = 51016;\n\n    uint256 internal constant DexT1__WithdrawLimitReached = 51017;\n\n    // Thrown when contract gives less token0 or token1 than what user's wants on withdraw\n    uint256 internal constant DexT1__BelowWithdrawMin = 51018;\n\n    uint256 internal constant DexT1__DebtLimitReached = 51019;\n\n    // Thrown when contract gives less token0 or token1 than what user's wants on borrow\n    uint256 internal constant DexT1__BelowBorrowMin = 51020;\n\n    // Thrown when contract asks for more token0 or token1 than what user's wants on payback\n    uint256 internal constant DexT1__AbovePaybackMax = 51021;\n\n    uint256 internal constant DexT1__InvalidDepositAmts = 51022;\n\n    uint256 internal constant DexT1__DepositAmtsZero = 51023;\n\n    uint256 internal constant DexT1__SharesMintedLess = 51024;\n\n    uint256 internal constant DexT1__WithdrawalNotEnough = 51025;\n\n    uint256 internal constant DexT1__InvalidWithdrawAmts = 51026;\n\n    uint256 internal constant DexT1__WithdrawAmtsZero = 51027;\n\n    uint256 internal constant DexT1__WithdrawExcessSharesBurn = 51028;\n\n    uint256 internal constant DexT1__InvalidBorrowAmts = 51029;\n\n    uint256 internal constant DexT1__BorrowAmtsZero = 51030;\n\n    uint256 internal constant DexT1__BorrowExcessSharesMinted = 51031;\n\n    uint256 internal constant DexT1__PaybackAmtTooHigh = 51032;\n\n    uint256 internal constant DexT1__InvalidPaybackAmts = 51033;\n\n    uint256 internal constant DexT1__PaybackAmtsZero = 51034;\n\n    uint256 internal constant DexT1__PaybackSharedBurnedLess = 51035;\n\n    uint256 internal constant DexT1__NothingToArbitrage = 51036;\n\n    uint256 internal constant DexT1__MsgSenderNotLiquidity = 51037;\n\n    // On liquidity callback reentrancy bit should be on\n    uint256 internal constant DexT1__ReentrancyBitShouldBeOn = 51038;\n\n    // Thrown is reentrancy is already on and someone tries to fetch oracle price. Should not be possible to this\n    uint256 internal constant DexT1__OraclePriceFetchAlreadyEntered = 51039;\n\n    // Thrown when swap changes the current price by more than 5%\n    uint256 internal constant DexT1__OracleUpdateHugeSwapDiff = 51040;\n\n    uint256 internal constant DexT1__Token0ShouldBeSmallerThanToken1 = 51041;\n\n    uint256 internal constant DexT1__OracleMappingOverflow = 51042;\n\n    /// @notice thrown if governance has paused the swapping & arbitrage so only perfect functions are usable\n    uint256 internal constant DexT1__SwapAndArbitragePaused = 51043;\n\n    uint256 internal constant DexT1__ExceedsAmountInMax = 51044;\n\n    /// @notice thrown if amount in is too high or too low\n    uint256 internal constant DexT1__SwapInLimitingAmounts = 51045;\n\n    /// @notice thrown if amount out is too high or too low\n    uint256 internal constant DexT1__SwapOutLimitingAmounts = 51046;\n\n    uint256 internal constant DexT1__MintAmtOverflow = 51047;\n\n    uint256 internal constant DexT1__BurnAmtOverflow = 51048;\n\n    uint256 internal constant DexT1__LimitingAmountsSwapAndNonPerfectActions = 51049;\n\n    uint256 internal constant DexT1__InsufficientOracleData = 51050;\n\n    uint256 internal constant DexT1__SharesAmountInsufficient = 51051;\n\n    uint256 internal constant DexT1__CenterPriceOutOfRange = 51052;\n\n    uint256 internal constant DexT1__DebtReservesTooLow = 51053;\n\n    uint256 internal constant DexT1__SwapAndDepositTooLowOrTooHigh = 51054;\n\n    uint256 internal constant DexT1__WithdrawAndSwapTooLowOrTooHigh = 51055;\n\n    uint256 internal constant DexT1__BorrowAndSwapTooLowOrTooHigh = 51056;\n\n    uint256 internal constant DexT1__SwapAndPaybackTooLowOrTooHigh = 51057;\n\n    uint256 internal constant DexT1__InvalidImplementation = 51058;\n\n    uint256 internal constant DexT1__OnlyDelegateCallAllowed = 51059;\n\n    uint256 internal constant DexT1__IncorrectDataLength = 51060;\n\n    uint256 internal constant DexT1__AmountToSendLessThanAmount = 51061;\n\n    uint256 internal constant DexT1__InvalidCollateralReserves = 51062;\n\n    uint256 internal constant DexT1__InvalidDebtReserves = 51063;\n\n    uint256 internal constant DexT1__SupplySharesOverflow = 51064;\n\n    uint256 internal constant DexT1__BorrowSharesOverflow = 51065;\n\n    uint256 internal constant DexT1__OracleNotActive = 51066;\n\n    /***********************************|\n    |            DEX Admin              | \n    |__________________________________*/\n\n    /// @notice thrown when pool is not initialized\n    uint256 internal constant DexT1Admin__PoolNotInitialized = 52001;\n\n    uint256 internal constant DexT1Admin__SmartColIsAlreadyOn = 52002;\n\n    uint256 internal constant DexT1Admin__SmartDebtIsAlreadyOn = 52003;\n\n    /// @notice thrown when any of the configs value overflow the maximum limit\n    uint256 internal constant DexT1Admin__ConfigOverflow = 52004;\n\n    uint256 internal constant DexT1Admin__AddressNotAContract = 52005;\n\n    uint256 internal constant DexT1Admin__InvalidParams = 52006;\n\n    uint256 internal constant DexT1Admin__UserNotDefined = 52007;\n\n    uint256 internal constant DexT1Admin__OnlyDelegateCallAllowed = 52008;\n\n    uint256 internal constant DexT1Admin__UnexpectedPoolState = 52009;\n\n    /// @notice thrown when trying to pause or unpause but user is already in the target pause state\n    uint256 internal constant DexT1Admin__InvalidPauseToggle = 52009;\n\n    /***********************************|\n    |            DEX Factory            | \n    |__________________________________*/\n\n    uint256 internal constant DexFactory__InvalidOperation = 53001;\n    uint256 internal constant DexFactory__Unauthorized = 53002;\n    uint256 internal constant DexFactory__SameTokenNotAllowed = 53003;\n    uint256 internal constant DexFactory__TokenConfigNotProper = 53004;\n    uint256 internal constant DexFactory__InvalidParams = 53005;\n    uint256 internal constant DexFactory__OnlyDelegateCallAllowed = 53006;\n    uint256 internal constant DexFactory__InvalidDexAddress = 53007;\n}\n"
    },
    "contracts/protocols/dex/factory/deploymentHelpers/miniDeployer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Owned } from \"solmate/src/auth/Owned.sol\";\n\n/// @title MiniDeployer\n/// @notice A contract that allows deployers to deploy any contract by passing the contract data in bytes\n/// @dev The main objective of this contract is to avoid storing contract addresses in our protocols which requires 160 bits of storage\n///      Instead, we can just store the nonce & deployment of this address to calculate the address realtime using \"AddressCalcs\" library\ncontract MiniDeployer is Owned {\n    /// @notice Thrown when an invalid operation is attempted\n    error MiniDeployer__InvalidOperation();\n\n    /// @notice Emitted when a new contract is deployed\n    event LogContractDeployed(address indexed contractAddress);\n\n    /// @notice Constructor to initialize the contract\n    /// @param owner_ The address of the contract owner\n    constructor(address owner_) Owned(owner_) {}\n\n    /// @notice Internal function to deploy a contract\n    /// @param bytecode_ The bytecode of the contract to deploy\n    /// @return address_ The address of the deployed contract\n    /// @dev Uses inline assembly for efficient deployment\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\n        if (bytecode_.length == 0) {\n            revert MiniDeployer__InvalidOperation();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\n        }\n        if (address_ == address(0)) {\n            revert MiniDeployer__InvalidOperation();\n        }\n    }\n\n    /// @notice Deploys a new contract\n    /// @param contractCode_ The bytecode of the contract to deploy\n    /// @return contractAddress_ The address of the deployed contract\n    /// @dev Decrements the deployer's allowed deployments count if not the owner\n    function deployContract(bytes calldata contractCode_) external onlyOwner returns (address contractAddress_) {\n        contractAddress_ = _deploy(contractCode_);\n\n        emit LogContractDeployed(contractAddress_);\n    }\n}\n"
    },
    "contracts/protocols/dex/factory/deploymentLogics/poolT1Logic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SSTORE2 } from \"solmate/src/utils/SSTORE2.sol\";\n\nimport { Error } from \"../../error.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { IFluidDexFactory } from \"../../interfaces/iDexFactory.sol\";\nimport { MiniDeployer } from \"../deploymentHelpers/miniDeployer.sol\";\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\nimport { BytesSliceAndConcat } from \"../../../../libraries/bytesSliceAndConcat.sol\";\n\nimport { IFluidDexT1 } from \"../../interfaces/iDexT1.sol\";\nimport { FluidDexT1Shift } from \"../../poolT1/coreModule/core/shift.sol\";\nimport { FluidDexT1Admin } from \"../../poolT1/adminModule/main.sol\";\nimport { FluidDexT1 } from \"../../poolT1/coreModule/core/main.sol\";\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ncontract FluidDexT1DeploymentLogic is Error {\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev SSTORE2 pointer for the PoolT1 creation code. Stored externally to reduce factory bytecode (in 2 parts)\n    address internal immutable POOL_T1_CREATIONCODE_ADDRESS_1;\n    address internal immutable POOL_T1_CREATIONCODE_ADDRESS_2;\n\n    /// @dev SSTORE2 pointers for the creation code of various operations contracts\n    address internal immutable COL_OPERATIONS_CREATIONCODE_ADDRESS;\n    address internal immutable DEBT_OPERATIONS_CREATIONCODE_ADDRESS;\n    address internal immutable PERFECT_OPERATIONS_AND_SWAP_OUT_CREATIONCODE_ADDRESS;\n\n    /// @notice address of liquidity contract\n    address public immutable LIQUIDITY;\n\n    /// @notice address of dexfactory contract\n    address public immutable DEX_FACTORY;\n\n    /// @notice address of Admin implementation\n    address public immutable ADMIN_IMPLEMENTATION;\n\n    /// @notice address of Shift implementation\n    address public immutable SHIFT_IMPLEMENTATION;\n\n    /// @notice address of Deployer Contract\n    address public immutable CONTRACT_DEPLOYER;\n\n    /// @notice address of MiniDeployer Contract\n    MiniDeployer public immutable MINI_DEPLOYER;\n\n    /// @notice address of this contract\n    address public immutable ADDRESS_THIS;\n\n    /// @notice Emitted when a new dexT1 is deployed.\n    /// @param dex The address of the newly deployed dex.\n    /// @param dexId The id of the newly deployed dex.\n    /// @param supplyToken The address of the supply token.\n    /// @param borrowToken The address of the borrow token.\n    event DexT1Deployed(address indexed dex, uint256 dexId, address indexed supplyToken, address indexed borrowToken);\n\n    /// @dev                            Deploys a contract using the CREATE opcode with the provided bytecode (`bytecode_`).\n    ///                                 This is an internal function, meant to be used within the contract to facilitate the deployment of other contracts.\n    /// @param bytecode_                The bytecode of the contract to be deployed.\n    /// @return address_                Returns the address of the deployed contract.\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\n        if (bytecode_.length == 0) {\n            revert FluidDexError(ErrorTypes.DexFactory__InvalidOperation);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\n        }\n        if (address_ == address(0)) {\n            revert FluidDexError(ErrorTypes.DexFactory__InvalidOperation);\n        }\n    }\n\n    constructor(\n        address liquidity_,\n        address dexFactory_,\n        address contractDeployer_,\n        address colOperations_,\n        address debtOperations_,\n        address perfectOperationsAndSwapOut_,\n        address mainAddress1_,\n        address mainAddress2_\n    ) {\n        LIQUIDITY = liquidity_;\n        DEX_FACTORY = dexFactory_;\n        CONTRACT_DEPLOYER = contractDeployer_;\n\n        \n        POOL_T1_CREATIONCODE_ADDRESS_1 = mainAddress1_;\n        POOL_T1_CREATIONCODE_ADDRESS_2 = mainAddress2_;\n\n        ADDRESS_THIS = address(this);\n\n        // Deploy mini deployer\n        MINI_DEPLOYER = new MiniDeployer(DEX_FACTORY);\n\n        // Deploy admin implementation\n        FluidDexT1Admin adminImplementation = new FluidDexT1Admin();\n        ADMIN_IMPLEMENTATION = address(adminImplementation);\n\n        // Deploy shift implementation\n        FluidDexT1Shift shiftImplementation = new FluidDexT1Shift(CONTRACT_DEPLOYER);\n        SHIFT_IMPLEMENTATION = address(shiftImplementation);\n\n        COL_OPERATIONS_CREATIONCODE_ADDRESS = colOperations_;\n        DEBT_OPERATIONS_CREATIONCODE_ADDRESS = debtOperations_;\n        PERFECT_OPERATIONS_AND_SWAP_OUT_CREATIONCODE_ADDRESS = perfectOperationsAndSwapOut_;\n    }\n\n    function dexT1(\n        address token0_,\n        address token1_,\n        uint256 oracleMapping_\n    ) external returns (bytes memory dexCreationBytecode_) {\n        if (address(this) == ADDRESS_THIS) revert FluidDexError(ErrorTypes.DexFactory__OnlyDelegateCallAllowed);\n\n        if (token0_ == token1_) revert FluidDexError(ErrorTypes.DexFactory__SameTokenNotAllowed);\n        if (token0_ > token1_) revert FluidDexError(ErrorTypes.DexFactory__TokenConfigNotProper);\n\n        IFluidDexT1.ConstantViews memory constants_;\n        constants_.liquidity = LIQUIDITY;\n        constants_.factory = address(this);\n        constants_.implementations.shift = SHIFT_IMPLEMENTATION;\n        constants_.deployerContract = CONTRACT_DEPLOYER;\n        constants_.token0 = token0_;\n        constants_.token1 = token1_;\n        constants_.dexId = IFluidDexFactory(address(this)).totalDexes();\n        constants_.oracleMapping = oracleMapping_;\n\n        address dex_ = IFluidDexFactory(address(this)).getDexAddress(constants_.dexId);\n\n        constants_ = _calculateLiquidityDexSlots(constants_, dex_);\n\n        // Deploy perfect operations and oracle implementation\n        address perfectOperationsAndOracle_ = MINI_DEPLOYER.deployContract(\n            abi.encodePacked(perfectOperationsCreationCode(), abi.encode(constants_))\n        );\n\n        // Deploy col operations implementation through mini deployer\n        address colOperations_ = MINI_DEPLOYER.deployContract(\n            abi.encodePacked(colOperationsCreationCode(), abi.encode(constants_))\n        );\n\n        // Deploy debt operations implementation\n        address debtOperations_ = MINI_DEPLOYER.deployContract(\n            abi.encodePacked(debtOperationsCreationCode(), abi.encode(constants_))\n        );\n\n        constants_.implementations.admin = ADMIN_IMPLEMENTATION;\n        constants_.implementations.perfectOperationsAndOracle = perfectOperationsAndOracle_;\n        constants_.implementations.colOperations = colOperations_;\n        constants_.implementations.debtOperations = debtOperations_;\n\n        dexCreationBytecode_ = abi.encodePacked(dexT1CreationBytecode(), abi.encode(constants_));\n\n        emit DexT1Deployed(dex_, constants_.dexId, token0_, token1_);\n\n        return dexCreationBytecode_;\n    }\n\n    /// @notice returns the stored DexT1 creation bytecode\n    function dexT1CreationBytecode() public view returns (bytes memory) {\n        return BytesSliceAndConcat.bytesConcat(SSTORE2.read(POOL_T1_CREATIONCODE_ADDRESS_1), SSTORE2.read(POOL_T1_CREATIONCODE_ADDRESS_2));\n    }\n\n    /// @dev Retrieves the creation code for the FluidDexT1OperationsCol contract\n    function colOperationsCreationCode() public view returns (bytes memory) {\n        return SSTORE2.read(COL_OPERATIONS_CREATIONCODE_ADDRESS);\n    }\n\n    /// @dev Retrieves the creation code for the FluidDexT1OperationsDebt contract\n    function debtOperationsCreationCode() public view returns (bytes memory) {\n        return SSTORE2.read(DEBT_OPERATIONS_CREATIONCODE_ADDRESS);\n    }\n\n    /// @dev Retrieves the creation code for the FluidDexT1PerfectOperations contract\n    function perfectOperationsCreationCode() public view returns (bytes memory) {\n        return SSTORE2.read(PERFECT_OPERATIONS_AND_SWAP_OUT_CREATIONCODE_ADDRESS);\n    }\n\n    /// @dev                          Calculates the liquidity dex slots for the given supply token, borrow token, and dex (`dex_`).\n    /// @param constants_             Constants struct as used in Dex T1\n    /// @param dex_                   The address of the dex.\n    /// @return liquidityDexSlots_    Returns the calculated liquidity dex slots set in the `IFluidDexT1.ConstantViews` struct.\n    function _calculateLiquidityDexSlots(\n        IFluidDexT1.ConstantViews memory constants_,\n        address dex_\n    ) private pure returns (IFluidDexT1.ConstantViews memory) {\n        constants_.supplyToken0Slot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n            dex_,\n            constants_.token0\n        );\n        constants_.borrowToken0Slot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n            dex_,\n            constants_.token0\n        );\n        constants_.supplyToken1Slot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n            dex_,\n            constants_.token1\n        );\n        constants_.borrowToken1Slot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n            dex_,\n            constants_.token1\n        );\n        constants_.exchangePriceToken0Slot = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            constants_.token0\n        );\n        constants_.exchangePriceToken1Slot = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            constants_.token1\n        );\n\n        return constants_;\n    }\n\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexFactory {\n    /// @notice Global auth is auth for all dexes\n    function isGlobalAuth(address auth_) external view returns (bool);\n\n    /// @notice Dex auth is auth for a specific dex\n    function isDexAuth(address vault_, address auth_) external view returns (bool);\n\n    /// @notice Total dexes deployed.\n    function totalDexes() external view returns (uint256);\n\n    /// @notice Compute dexAddress\n    function getDexAddress(uint256 dexId_) external view returns (address);\n\n    /// @notice read uint256 `result_` for a storage `slot_` key\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexT1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexT1 {\n    error FluidDexError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares);\n\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\n\n    /// @notice returns the dex id\n    function DEX_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndOracle;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) external view returns (CollateralReserves memory c_);\n\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) external view returns (DebtReserves memory d_);\n\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\n    function getPricesAndExchangePrices() external;\n\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) external returns (\n        uint withdrawAmt_\n    );\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) external payable returns (\n        uint paybackAmt_\n    );\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(\n        uint[] memory secondsAgos_\n    ) external view returns (\n        Oracle[] memory twaps_,\n        uint currentPrice_\n    );\n}\n"
    },
    "contracts/protocols/dex/poolT1/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs } from \"./structs.sol\";\n\nabstract contract Events is Structs {\n    /// @dev Emitted when smart collateral is turned on\n    /// @param token0Amt The amount of token0 used for smart collateral\n    event LogTurnOnSmartCol(uint token0Amt);\n\n    /// @dev Emitted when smart debt is turned on\n    /// @param token0Amt The amount of token0 used for smart debt\n    event LogTurnOnSmartDebt(uint token0Amt);\n\n    /// @dev Emitted when fee and revenue cut are updated\n    /// @param fee The new fee value\n    /// @param revenueCut The new revenue cut value\n    event LogUpdateFeeAndRevenueCut(uint fee, uint revenueCut);\n\n    /// @dev Emitted when range percents are updated\n    /// @param upperPercent The new upper percent value\n    /// @param lowerPercent The new lower percent value\n    /// @param shiftTime The new shift time value\n    event LogUpdateRangePercents(uint upperPercent, uint lowerPercent, uint shiftTime);\n\n    /// @dev Emitted when threshold percent is updated\n    /// @param upperThresholdPercent The new upper threshold percent value\n    /// @param lowerThresholdPercent The new lower threshold percent value\n    /// @param thresholdShiftTime The new threshold shift time value\n    /// @param shiftTime The new shift time value\n    event LogUpdateThresholdPercent(\n        uint upperThresholdPercent,\n        uint lowerThresholdPercent,\n        uint thresholdShiftTime,\n        uint shiftTime\n    );\n\n    /// @dev Emitted when center price address is updated\n    /// @param centerPriceAddress The new center price address nonce\n    /// @param percent The new percent value\n    /// @param time The new time value\n    event LogUpdateCenterPriceAddress(uint centerPriceAddress, uint percent, uint time);\n\n    /// @dev Emitted when hook address is updated\n    /// @param hookAddress The new hook address nonce\n    event LogUpdateHookAddress(uint hookAddress);\n\n    /// @dev Emitted when center price limits are updated\n    /// @param maxCenterPrice The new maximum center price\n    /// @param minCenterPrice The new minimum center price\n    event LogUpdateCenterPriceLimits(uint maxCenterPrice, uint minCenterPrice);\n\n    /// @dev Emitted when utilization limit is updated\n    /// @param token0UtilizationLimit The new utilization limit for token0\n    /// @param token1UtilizationLimit The new utilization limit for token1\n    event LogUpdateUtilizationLimit(uint token0UtilizationLimit, uint token1UtilizationLimit);\n\n    /// @dev Emitted when user supply configs are updated\n    /// @param userSupplyConfigs The array of updated user supply configurations\n    event LogUpdateUserSupplyConfigs(UserSupplyConfig[] userSupplyConfigs);\n\n    /// @dev Emitted when user borrow configs are updated\n    /// @param userBorrowConfigs The array of updated user borrow configurations\n    event LogUpdateUserBorrowConfigs(UserBorrowConfig[] userBorrowConfigs);\n\n    /// @dev Emitted when a user is paused\n    /// @param user The address of the paused user\n    /// @param pauseSupply Whether supply operations are paused\n    /// @param pauseBorrow Whether borrow operations are paused\n    event LogPauseUser(address user, bool pauseSupply, bool pauseBorrow);\n\n    /// @dev Emitted when a user is unpaused\n    /// @param user The address of the unpaused user\n    /// @param unpauseSupply Whether supply operations are unpaused\n    /// @param unpauseBorrow Whether borrow operations are unpaused\n    event LogUnpauseUser(address user, bool unpauseSupply, bool unpauseBorrow);\n\n    /// @notice Emitted when the pool configuration is initialized\n    /// @param smartCol Whether smart collateral is enabled\n    /// @param smartDebt Whether smart debt is enabled\n    /// @param token0ColAmt The amount of token0 collateral\n    /// @param token0DebtAmt The amount of token0 debt\n    /// @param fee The fee percentage (in 4 decimals, 10000 = 1%)\n    /// @param revenueCut The revenue cut percentage (in 4 decimals, 100000 = 10%)\n    /// @param centerPriceAddress The nonce for the center price contract address\n    /// @param hookAddress The nonce for the hook contract address\n    event LogInitializePoolConfig(\n        bool smartCol,\n        bool smartDebt,\n        uint token0ColAmt,\n        uint token0DebtAmt,\n        uint fee,\n        uint revenueCut,\n        uint centerPriceAddress,\n        uint hookAddress\n    );\n\n    /// @notice Emitted when the price parameters are initialized\n    /// @param upperPercent The upper range percent (in 4 decimals, 10000 = 1%)\n    /// @param lowerPercent The lower range percent (in 4 decimals, 10000 = 1%)\n    /// @param upperShiftThreshold The upper shift threshold (in 4 decimals, 10000 = 1%)\n    /// @param lowerShiftThreshold The lower shift threshold (in 4 decimals, 10000 = 1%)\n    /// @param thresholdShiftTime The time for threshold shift (in seconds)\n    /// @param maxCenterPrice The maximum center price\n    /// @param minCenterPrice The minimum center price\n    event LogInitializePriceParams(\n        uint upperPercent,\n        uint lowerPercent,\n        uint upperShiftThreshold,\n        uint lowerShiftThreshold,\n        uint thresholdShiftTime,\n        uint maxCenterPrice,\n        uint minCenterPrice\n    );\n\n    /// @dev Emitted when swap and arbitrage are paused\n    event LogPauseSwapAndArbitrage();\n\n    /// @dev Emitted when swap and arbitrage are unpaused\n    event LogUnpauseSwapAndArbitrage();\n\n    /// @notice emitted when user withdrawal limit is updated\n    event LogUpdateUserWithdrawalLimit(address user, uint256 newLimit);\n\n    /// @dev Emitted when funds are rescued\n    /// @param token The address of the token\n    event LogRescueFunds(address token);\n\n    /// @dev Emitted when max supply shares are updated\n    /// @param maxSupplyShares The new maximum supply shares\n    event LogUpdateMaxSupplyShares(uint maxSupplyShares);\n\n    /// @dev Emitted when max borrow shares are updated\n    /// @param maxBorrowShares The new maximum borrow shares\n    event LogUpdateMaxBorrowShares(uint maxBorrowShares);\n\n    /// @dev Emitted when oracle activation is toggled\n    /// @param turnOn Whether oracle is turned on\n    event LogToggleOracleActivation(bool turnOn);\n}\n"
    },
    "contracts/protocols/dex/poolT1/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Variables } from \"../common/variables.sol\";\nimport { Events } from \"./events.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { ConstantVariables } from \"../common/constantVariables.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { IFluidDexT1 } from \"../../interfaces/iDexT1.sol\";\nimport { IFluidLiquidity } from \"../../../../liquidity/interfaces/iLiquidity.sol\";\nimport { SafeTransfer } from \"../../../../libraries/safeTransfer.sol\";\nimport { AddressCalcs } from \"../../../../libraries/addressCalcs.sol\";\nimport { DexSlotsLink } from \"../../../../libraries/dexSlotsLink.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @notice Fluid Dex protocol Admin Module contract.\n///         Implements admin related methods to set pool configs\n///         Methods are limited to be called via delegateCall only. Dex CoreModule (\"DexT1\" contract)\n///         is expected to call the methods implemented here after checking the msg.sender is authorized.\ncontract FluidDexT1Admin is ConstantVariables, Variables, Structs, Events, Error {\n    using BigMathMinified for uint256;\n\n    address private immutable ADDRESS_THIS;\n\n    constructor() {\n        ADDRESS_THIS = address(this);\n    }\n\n    modifier _onlyDelegateCall() {\n        // also indirectly checked by `_check` because pool can never be initialized as long as the initialize method\n        // is delegate call only, but just to be sure on Admin logic we add the modifier everywhere nonetheless.\n        if (address(this) == ADDRESS_THIS) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    modifier _check() {\n        if ((dexVariables2 & 3) == 0) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__PoolNotInitialized);\n        }\n        _;\n    }\n\n    /// @dev checks that `value_` address is a contract (which includes address zero check) or native address\n    function _checkIsContractOrNativeAddress(address value_) internal view {\n        if (value_.code.length == 0 && value_ != NATIVE_TOKEN) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__AddressNotAContract);\n        }\n    }\n\n    /// @dev checks that `value_` address is a contract (which includes address zero check)\n    function _checkIsContract(address value_) internal view {\n        if (value_.code.length == 0) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__AddressNotAContract);\n        }\n    }\n\n    function turnOnSmartCol(uint token0Amt_) public payable _check _onlyDelegateCall {\n        if (dexVariables2 & 1 == 1) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__SmartColIsAlreadyOn);\n        }\n        uint centerPrice_ = (dexVariables >> 81) & X40;\n        centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n        _turnOnSmartCol(token0Amt_, centerPrice_);\n\n        dexVariables2 = dexVariables2 | 1;\n\n        emit LogTurnOnSmartCol(token0Amt_);\n    }\n\n    function _turnOnSmartCol(uint token0Amt_, uint centerPrice_) internal {\n        IFluidDexT1.ConstantViews memory c_ = IFluidDexT1(address(this)).constantsView();\n        IFluidDexT1.ConstantViews2 memory c2_ = IFluidDexT1(address(this)).constantsView2();\n\n        uint token0AmtAdjusted_ = (token0Amt_ * c2_.token0NumeratorPrecision) / c2_.token0DenominatorPrecision;\n\n        uint token1AmtAdjusted_ = (centerPrice_ * token0AmtAdjusted_) / 1e27;\n\n        uint token1Amt_ = (token1AmtAdjusted_ * c2_.token1DenominatorPrecision) / c2_.token1NumeratorPrecision;\n\n        IFluidLiquidity liquidity_ = IFluidLiquidity(c_.liquidity);\n\n        // if both tokens are not native token and msg.value is sent, revert\n        if (msg.value > 0 && c_.token0 != NATIVE_TOKEN && c_.token1 != NATIVE_TOKEN) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n\n        address token_;\n        uint amt_;\n        for (uint i = 0; i < 2; i++) {\n            if (i == 0) {\n                token_ = c_.token0;\n                amt_ = token0Amt_;\n            } else {\n                token_ = c_.token1;\n                amt_ = token1Amt_;\n            }\n            if (token_ == NATIVE_TOKEN) {\n                if (msg.value > amt_) {\n                    SafeTransfer.safeTransferNative(msg.sender, msg.value - amt_);\n                } else if (msg.value < amt_) {\n                    revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n                }\n                // deposit\n                liquidity_.operate{ value: amt_ }(\n                    token_,\n                    int(amt_),\n                    0,\n                    address(0),\n                    address(0),\n                    abi.encode(amt_, false, msg.sender)\n                );\n            } else {\n                // deposit\n                liquidity_.operate(token_, int(amt_), 0, address(0), address(0), abi.encode(amt_, false, msg.sender));\n            }\n        }\n\n        // minting shares according to whatever tokenAmt is bigger\n        // adding shares on storage but not adding shares for any user, hence locking these shares forever\n        // adjusted amounts are in 12 decimals, making shares in 18 decimals\n        uint totalSupplyShares_ = (token0AmtAdjusted_ > token1AmtAdjusted_)\n            ? token0AmtAdjusted_ * 10 ** (18 - TOKENS_DECIMALS_PRECISION)\n            : token1AmtAdjusted_ * 10 ** (18 - TOKENS_DECIMALS_PRECISION);\n\n        if (totalSupplyShares_ < NINE_DECIMALS) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__UnexpectedPoolState);\n        }\n\n        // setting initial max shares as X128\n        totalSupplyShares_ = (totalSupplyShares_ & X128) | (X128 << 128);\n        // storing in storage\n        _totalSupplyShares = totalSupplyShares_;\n    }\n\n    function turnOnSmartDebt(uint token0Amt_) public _check _onlyDelegateCall {\n        if (dexVariables2 & 2 == 2) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__SmartDebtIsAlreadyOn);\n        }\n        uint centerPrice_ = (dexVariables >> 81) & X40;\n        centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n        _turnOnSmartDebt(token0Amt_, centerPrice_);\n\n        dexVariables2 = dexVariables2 | 2;\n\n        emit LogTurnOnSmartDebt(token0Amt_);\n    }\n\n    /// @dev Can only borrow if DEX pool address borrow config is added in Liquidity Layer for both the tokens else Liquidity Layer will revert\n    /// governance will have access to _turnOnSmartDebt, technically governance here can borrow as much as limits are set\n    /// so it's governance responsibility that it borrows small amount between $100 - $10,000\n    /// Borrowing in 50:50 ratio (doesn't matter if pool configuration is set to 20:80, 30:70, etc, external swap will arbitrage & balance the pool)\n    function _turnOnSmartDebt(uint token0Amt_, uint centerPrice_) internal {\n        IFluidDexT1.ConstantViews memory c_ = IFluidDexT1(address(this)).constantsView();\n        IFluidDexT1.ConstantViews2 memory c2_ = IFluidDexT1(address(this)).constantsView2();\n\n        uint token0AmtAdjusted_ = (token0Amt_ * c2_.token0NumeratorPrecision) / c2_.token0DenominatorPrecision;\n\n        uint token1AmtAdjusted_ = (centerPrice_ * token0AmtAdjusted_) / 1e27;\n\n        uint token1Amt_ = (token1AmtAdjusted_ * c2_.token1DenominatorPrecision) / c2_.token1NumeratorPrecision;\n\n        IFluidLiquidity liquidity_ = IFluidLiquidity(c_.liquidity);\n\n        liquidity_.operate(c_.token0, 0, int(token0Amt_), address(0), TEAM_MULTISIG, new bytes(0));\n        liquidity_.operate(c_.token1, 0, int(token1Amt_), address(0), TEAM_MULTISIG, new bytes(0));\n\n        // minting shares as whatever tokenAmt is bigger\n        // adding shares on storage but not adding shares for any user, hence locking these shares forever\n        // adjusted amounts are in 12 decimals, making shares in 18 decimals\n        uint totalBorrowShares_ = (token0AmtAdjusted_ > token1AmtAdjusted_)\n            ? token0AmtAdjusted_ * 10 ** (18 - TOKENS_DECIMALS_PRECISION)\n            : token1AmtAdjusted_ * 10 ** (18 - TOKENS_DECIMALS_PRECISION);\n\n        if (totalBorrowShares_ < NINE_DECIMALS) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__UnexpectedPoolState);\n        }\n\n        // setting initial max shares as X128\n        totalBorrowShares_ = (totalBorrowShares_ & X128) | (X128 << 128);\n        // storing in storage\n        _totalBorrowShares = totalBorrowShares_;\n    }\n\n    /// @param fee_ in 4 decimals, 10000 = 1%\n    /// @param revenueCut_ in 4 decimals, 100000 = 10%, 10% cut on fee_, so if fee is 1% and cut is 10% then cut in swap amount will be 10% of 1% = 0.1%\n    function updateFeeAndRevenueCut(uint fee_, uint revenueCut_) public _check _onlyDelegateCall {\n        // cut is an integer in storage slot which is more than enough\n        // but from UI we are allowing to send in 4 decimals to maintain consistency & avoid human error in future\n        if (revenueCut_ != 0 && revenueCut_ < FOUR_DECIMALS) {\n            // human input error. should send 0 for wanting 0, not 0 because of precision reduction.\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n\n        revenueCut_ = revenueCut_ / FOUR_DECIMALS;\n\n        if (fee_ > FIVE_DECIMALS || revenueCut_ > TWO_DECIMALS) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n\n        dexVariables2 =\n            (dexVariables2 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC000003) |\n            (fee_ << 2) |\n            (revenueCut_ << 19);\n\n        emit LogUpdateFeeAndRevenueCut(fee_, revenueCut_ * FOUR_DECIMALS);\n    }\n\n    /// @param upperPercent_ in 4 decimals, 10000 = 1%\n    /// @param lowerPercent_ in 4 decimals, 10000 = 1%\n    /// @param shiftTime_ in secs, in how much time the upper percent configs change should be fully done\n    function updateRangePercents(\n        uint upperPercent_,\n        uint lowerPercent_,\n        uint shiftTime_\n    ) public _check _onlyDelegateCall {\n        uint dexVariables2_ = dexVariables2;\n        if (\n            (upperPercent_ > (SIX_DECIMALS - FOUR_DECIMALS)) || // capping range to 99%.\n            (lowerPercent_ > (SIX_DECIMALS - FOUR_DECIMALS)) || // capping range to 99%.\n            (upperPercent_ == 0) ||\n            (lowerPercent_ == 0) ||\n            (shiftTime_ > X20) ||\n            (((dexVariables2_ >> 26) & 1) == 1) // if last shift is still active then don't allow a newer shift\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n\n        dexVariables2 =\n            (dexVariables2_ & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF80000000003FFFFFF) |\n            (uint((shiftTime_ > 0) ? 1 : 0) << 26) |\n            (upperPercent_ << 27) |\n            (lowerPercent_ << 47);\n\n        uint oldUpperPercent_ = (dexVariables2_ >> 27) & X20;\n        uint oldLowerPercent_ = (dexVariables2_ >> 47) & X20;\n\n        if (shiftTime_ > 0) {\n            _rangeShift = uint128(\n                oldUpperPercent_ | (oldLowerPercent_ << 20) | (shiftTime_ << 40) | (block.timestamp << 60)\n            );\n        }\n        // Note _rangeShift is reset when the previous shift is fully completed, which is forced to have happened through if check above\n\n        emit LogUpdateRangePercents(upperPercent_, lowerPercent_, shiftTime_);\n    }\n\n    /// @param upperThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param lowerThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param thresholdShiftTime_ in secs, in how much time the threshold percent should take to shift the ranges\n    /// @param shiftTime_ in secs, in how much time the upper config changes should be fully done.\n    function updateThresholdPercent(\n        uint upperThresholdPercent_,\n        uint lowerThresholdPercent_,\n        uint thresholdShiftTime_,\n        uint shiftTime_\n    ) public _check _onlyDelegateCall {\n        uint dexVariables2_ = dexVariables2;\n\n        // thresholds are with 0.1% precision, hence removing last 3 decimals.\n        // we are allowing to send in 4 decimals to maintain consistency with other params\n        upperThresholdPercent_ = upperThresholdPercent_ / THREE_DECIMALS;\n        lowerThresholdPercent_ = lowerThresholdPercent_ / THREE_DECIMALS;\n        if (\n            (upperThresholdPercent_ > THREE_DECIMALS) ||\n            (lowerThresholdPercent_ > THREE_DECIMALS) ||\n            (thresholdShiftTime_ == 0) ||\n            (thresholdShiftTime_ > X24) ||\n            ((upperThresholdPercent_ == 0) && (lowerThresholdPercent_ > 0)) ||\n            ((upperThresholdPercent_ > 0) && (lowerThresholdPercent_ == 0)) ||\n            (shiftTime_ > X20) ||\n            (((dexVariables2_ >> 67) & 1) == 1) // if last shift is still active then don't allow a newer shift\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n\n        dexVariables2 =\n            (dexVariables2_ & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000007FFFFFFFFFFFFFFFF) |\n            (uint((shiftTime_ > 0) ? 1 : 0) << 67) |\n            (upperThresholdPercent_ << 68) |\n            (lowerThresholdPercent_ << 78) |\n            (thresholdShiftTime_ << 88);\n\n        uint oldUpperThresholdPercent_ = (dexVariables2_ >> 68) & X10;\n        uint oldLowerThresholdPercent_ = (dexVariables2_ >> 78) & X10;\n        uint oldThresholdTime_ = (dexVariables2_ >> 88) & X24;\n\n        if (shiftTime_ > 0) {\n            _thresholdShift = uint128(\n                oldUpperThresholdPercent_ |\n                    (oldLowerThresholdPercent_ << 20) |\n                    (shiftTime_ << 40) |\n                    (block.timestamp << 60) |\n                    (oldThresholdTime_ << 93)\n            );\n        }\n        // Note _thresholdShift is reset when the previous shift is fully completed, which is forced to have happened through if check above\n\n        emit LogUpdateThresholdPercent(\n            upperThresholdPercent_ * THREE_DECIMALS,\n            lowerThresholdPercent_ * THREE_DECIMALS,\n            thresholdShiftTime_,\n            shiftTime_\n        );\n    }\n\n    /// @dev we are storing uint nonce from which we will calculate the contract address, to store an address we need 160 bits\n    /// which is quite a lot of storage slot\n    /// @param centerPriceAddress_ nonce < X30, this nonce will be used to calculate contract address\n    function updateCenterPriceAddress(\n        uint centerPriceAddress_,\n        uint percent_,\n        uint time_\n    ) public _check _onlyDelegateCall {\n        if ((centerPriceAddress_ > X30) || (percent_ == 0) || (percent_ > X20) || (time_ == 0) || (time_ > X20)) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n\n        if (centerPriceAddress_ > 0) {\n            IFluidDexT1.ConstantViews memory c_ = IFluidDexT1(address(this)).constantsView();\n            address centerPrice_ = AddressCalcs.addressCalc(c_.deployerContract, centerPriceAddress_);\n            _checkIsContract(centerPrice_);\n            // note: if address is made 0 then as well in the last swap currentPrice is updated on storage, so code will start using that automatically\n            dexVariables2 =\n                (dexVariables2 & 0xFeFFFFFFFFFFFFFFFFFFFFFFFFFFC0000000FFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n                (centerPriceAddress_ << 112) |\n                (uint(1) << 248);\n\n            _centerPriceShift = block.timestamp | (percent_ << 33) | (time_ << 53);\n        } else {\n            dexVariables2 = (dexVariables2 & 0xFeFFFFFFFFFFFFFFFFFFFFFFFFFFC0000000FFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n            _centerPriceShift = 0;\n        }\n\n        emit LogUpdateCenterPriceAddress(centerPriceAddress_, percent_, time_);\n    }\n\n    /// @dev we are storing uint nonce from which we will calculate the contract address, to store an address we need 160 bits\n    /// which is quite a lot of storage slot\n    /// @param hookAddress_ nonce < X30, this nonce will be used to calculate contract address\n    function updateHookAddress(uint hookAddress_) public _check _onlyDelegateCall {\n        if (hookAddress_ > X30) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n\n        if (hookAddress_ > 0) {\n            IFluidDexT1.ConstantViews memory c_ = IFluidDexT1(address(this)).constantsView();\n            address hook_ = AddressCalcs.addressCalc(c_.deployerContract, hookAddress_);\n            _checkIsContract(hook_);\n        }\n\n        dexVariables2 =\n            (dexVariables2 & 0xFFFFFFFFFFFFFFFFFFFFF00000003FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n            (hookAddress_ << 142);\n\n        emit LogUpdateHookAddress(hookAddress_);\n    }\n\n    function updateCenterPriceLimits(uint maxCenterPrice_, uint minCenterPrice_) public _check _onlyDelegateCall {\n        uint centerPrice_ = (dexVariables >> 81) & X40;\n        centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n\n        if (\n            (maxCenterPrice_ <= minCenterPrice_) ||\n            (centerPrice_ <= minCenterPrice_) ||\n            (centerPrice_ >= maxCenterPrice_) ||\n            (minCenterPrice_ == 0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n\n        dexVariables2 =\n            (dexVariables2 & 0xFFFFFFF00000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n            (maxCenterPrice_.toBigNumber(20, 8, BigMathMinified.ROUND_UP) << 172) |\n            (minCenterPrice_.toBigNumber(20, 8, BigMathMinified.ROUND_DOWN) << 200);\n\n        emit LogUpdateCenterPriceLimits(maxCenterPrice_, minCenterPrice_);\n    }\n\n    function updateUtilizationLimit(\n        uint token0UtilizationLimit_,\n        uint token1UtilizationLimit_\n    ) public _check _onlyDelegateCall {\n        if (\n            (token0UtilizationLimit_ != 0 && token0UtilizationLimit_ < THREE_DECIMALS) ||\n            (token1UtilizationLimit_ != 0 && token1UtilizationLimit_ < THREE_DECIMALS)\n        ) {\n            // human input error. should send 0 for wanting 0, not 0 because of precision reduction.\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n\n        token0UtilizationLimit_ = token0UtilizationLimit_ / THREE_DECIMALS;\n        token1UtilizationLimit_ = token1UtilizationLimit_ / THREE_DECIMALS;\n\n        if (token0UtilizationLimit_ > THREE_DECIMALS || token1UtilizationLimit_ > THREE_DECIMALS) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n\n        dexVariables2 =\n            (dexVariables2 & 0xFF00000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n            (token0UtilizationLimit_ << 228) |\n            (token1UtilizationLimit_ << 238);\n\n        emit LogUpdateUtilizationLimit(\n            token0UtilizationLimit_ * THREE_DECIMALS,\n            token1UtilizationLimit_ * THREE_DECIMALS\n        );\n    }\n\n    function updateUserSupplyConfigs(UserSupplyConfig[] memory userSupplyConfigs_) external _check _onlyDelegateCall {\n        uint256 userSupplyData_;\n\n        for (uint256 i; i < userSupplyConfigs_.length; ) {\n            _checkIsContract(userSupplyConfigs_[i].user);\n            if (userSupplyConfigs_[i].expandDuration == 0) {\n                // can not set expand duration to 0 as that could cause a division by 0 in LiquidityCalcs.\n                // having expand duration as 0 is anyway not an expected config so removing the possibility for that.\n                // if no expansion is wanted, simply set expandDuration to 1 and expandPercent to 0.\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n            }\n            if (userSupplyConfigs_[i].expandPercent > FOUR_DECIMALS) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n            }\n            if (userSupplyConfigs_[i].expandDuration > X24) {\n                // duration is max 24 bits\n                revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n            }\n            if (userSupplyConfigs_[i].baseWithdrawalLimit == 0) {\n                // base withdrawal limit can not be 0. As a side effect, this ensures that there is no supply config\n                // where all values would be 0, so configured users can be differentiated in the mapping.\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n            }\n            // @dev baseWithdrawalLimit has no max bits amount as it is in normal token amount & converted to BigNumber\n\n            // get current user config data from storage\n            userSupplyData_ = _userSupplyData[userSupplyConfigs_[i].user];\n\n            // Updating user data on storage\n            _userSupplyData[userSupplyConfigs_[i].user] =\n                // mask to update first bit + bits 162-217 (expand percentage, expand duration, base limit)\n                (userSupplyData_ & 0xfffffffffc00000000000003ffffffffffffffffffffffffffffffffffffffff) |\n                (1) |\n                (userSupplyConfigs_[i].expandPercent << DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) |\n                (userSupplyConfigs_[i].expandDuration << DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) |\n                // convert base withdrawal limit to BigNumber for storage (10 | 8). (below this, 100% can be withdrawn)\n                (userSupplyConfigs_[i].baseWithdrawalLimit.toBigNumber(\n                    SMALL_COEFFICIENT_SIZE,\n                    DEFAULT_EXPONENT_SIZE,\n                    BigMathMinified.ROUND_DOWN\n                ) << DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit LogUpdateUserSupplyConfigs(userSupplyConfigs_);\n    }\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, uint256 newLimit_) external _check _onlyDelegateCall {\n        _checkIsContract(user_);\n\n        // get current user config data from storage\n        uint256 userSupplyData_ = _userSupplyData[user_];\n        if (userSupplyData_ == 0) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__UserNotDefined);\n        }\n\n        // get current user supply amount\n        uint256 userSupply_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n        userSupply_ = (userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK);\n\n        // maxExpansionLimit_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        uint256 maxExpansionLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        maxExpansionLimit_ = userSupply_ - ((userSupply_ * maxExpansionLimit_) / FOUR_DECIMALS);\n\n        if (newLimit_ == 0 || newLimit_ < maxExpansionLimit_) {\n            // instant full expansion, and if that goes below base limit then fully down to 0.\n            // if we were to set a limit that goes below max expansion limit, then after 1 deposit or 1 withdrawal it would\n            // become based on the max expansion limit again (unless it goes below base limit), which can be confusing.\n            // Also updating base limit here to avoid the change after 1 interaction might have undesired effects.\n            // So limiting update to max. full expansion. If more is desired, this must be called again after some withdraws.\n            newLimit_ = maxExpansionLimit_;\n        } else if (newLimit_ == type(uint256).max || newLimit_ > userSupply_) {\n            // current withdrawable 0 (sets current user supply as limit).\n            newLimit_ = userSupply_;\n        }\n        // else => new limit is between > max expansion and < user supply.\n\n        // set input limit as new current limit. instant withdrawable will be userSupply_ - newLimit_\n\n        uint256 baseLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        baseLimit_ = (baseLimit_ >> DEFAULT_EXPONENT_SIZE) << (baseLimit_ & DEFAULT_EXPONENT_MASK);\n        if (userSupply_ < baseLimit_) {\n            newLimit_ = 0;\n            // Note if new limit goes below base limit, it follows default behavior: first there must be a withdrawal\n            // that brings user supply below base limit, then the limit will be set to 0.\n            // otherwise we would have the same problem as described above after 1 interaction.\n        }\n\n        // Update on storage\n        _userSupplyData[user_] =\n            // mask to update bits 65-161 (withdrawal limit, timestamp)\n            (userSupplyData_ & 0xFFFFFFFFFFFFFFFFFFFFFFFC000000000000000000000001FFFFFFFFFFFFFFFF) |\n            (newLimit_.toBigNumber(DEFAULT_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BigMathMinified.ROUND_DOWN) <<\n                DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) | // converted to BigNumber can not overflow\n            (block.timestamp << DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP);\n\n        emit LogUpdateUserWithdrawalLimit(user_, newLimit_);\n    }\n\n    function updateUserBorrowConfigs(UserBorrowConfig[] memory userBorrowConfigs_) external _check _onlyDelegateCall {\n        uint256 userBorrowData_;\n\n        for (uint256 i; i < userBorrowConfigs_.length; ) {\n            _checkIsContract(userBorrowConfigs_[i].user);\n            if (\n                // max debt ceiling must not be smaller than base debt ceiling. Also covers case where max = 0 but base > 0\n                userBorrowConfigs_[i].baseDebtCeiling > userBorrowConfigs_[i].maxDebtCeiling ||\n                // can not set expand duration to 0 as that could cause a division by 0 in LiquidityCalcs.\n                // having expand duration as 0 is anyway not an expected config so removing the possibility for that.\n                // if no expansion is wanted, simply set expandDuration to 1 and expandPercent to 0.\n                userBorrowConfigs_[i].expandDuration == 0\n            ) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n            }\n            if (userBorrowConfigs_[i].expandPercent > X14) {\n                // expandPercent is max 14 bits\n                revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n            }\n            if (userBorrowConfigs_[i].expandDuration > X24) {\n                // duration is max 24 bits\n                revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n            }\n            if (userBorrowConfigs_[i].baseDebtCeiling == 0 || userBorrowConfigs_[i].maxDebtCeiling == 0) {\n                // limits can not be 0. As a side effect, this ensures that there is no borrow config\n                // where all values would be 0, so configured users can be differentiated in the mapping.\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n            }\n            // @dev baseDebtCeiling & maxDebtCeiling have no max bits amount as they are in normal token amount\n            // and then converted to BigNumber\n\n            // get current user config data from storage\n            userBorrowData_ = _userBorrowData[userBorrowConfigs_[i].user];\n\n            // Updating user data on storage\n\n            _userBorrowData[userBorrowConfigs_[i].user] =\n                // mask to update first bit (mode) + bits 162-235 (debt limit values)\n                (userBorrowData_ & 0xfffff0000000000000000003ffffffffffffffffffffffffffffffffffffffff) |\n                (1) |\n                (userBorrowConfigs_[i].expandPercent << DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) |\n                (userBorrowConfigs_[i].expandDuration << DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) |\n                // convert base debt limit to BigNumber for storage (10 | 8). (borrow is always possible below this)\n                (userBorrowConfigs_[i].baseDebtCeiling.toBigNumber(\n                    SMALL_COEFFICIENT_SIZE,\n                    DEFAULT_EXPONENT_SIZE,\n                    BigMathMinified.ROUND_DOWN\n                ) << DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) |\n                // convert max debt limit to BigNumber for storage (10 | 8). (no borrowing ever possible above this)\n                (userBorrowConfigs_[i].maxDebtCeiling.toBigNumber(\n                    SMALL_COEFFICIENT_SIZE,\n                    DEFAULT_EXPONENT_SIZE,\n                    BigMathMinified.ROUND_DOWN\n                ) << DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit LogUpdateUserBorrowConfigs(userBorrowConfigs_);\n    }\n\n    function pauseUser(address user_, bool pauseSupply_, bool pauseBorrow_) public _onlyDelegateCall {\n        _checkIsContract(user_);\n\n        uint256 userData_;\n\n        if (pauseSupply_) {\n            // userData_ => userSupplyData_\n            userData_ = _userSupplyData[user_];\n            if (userData_ == 0) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__UserNotDefined);\n            }\n            if (userData_ & 1 == 0) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidPauseToggle);\n            }\n            // set first bit as 0, meaning all user's supply operations are paused\n            _userSupplyData[user_] = userData_ & (~uint(1));\n        }\n\n        if (pauseBorrow_) {\n            // userData_ => userBorrowData_\n            userData_ = _userBorrowData[user_];\n            if (userData_ == 0) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__UserNotDefined);\n            }\n            if (userData_ & 1 == 0) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidPauseToggle);\n            }\n            // set first bit as 0, meaning all user's borrow operations are paused\n            _userBorrowData[user_] = userData_ & (~uint(1));\n        }\n\n        emit LogPauseUser(user_, pauseSupply_, pauseBorrow_);\n    }\n\n    function unpauseUser(address user_, bool unpauseSupply_, bool unpauseBorrow_) public _onlyDelegateCall {\n        _checkIsContract(user_);\n\n        uint256 userData_;\n\n        if (unpauseSupply_) {\n            // userData_ => userSupplyData_\n            userData_ = _userSupplyData[user_];\n            if (userData_ == 0) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__UserNotDefined);\n            }\n            if (userData_ & 1 == 1) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidPauseToggle);\n            }\n\n            // set first bit as 1, meaning unpause\n            _userSupplyData[user_] = userData_ | 1;\n        }\n\n        if (unpauseBorrow_) {\n            // userData_ => userBorrowData_\n            userData_ = _userBorrowData[user_];\n            if (userData_ == 0) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__UserNotDefined);\n            }\n            if (userData_ & 1 == 1) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidPauseToggle);\n            }\n\n            // set first bit as 1, meaning unpause\n            _userBorrowData[user_] = userData_ | 1;\n        }\n\n        emit LogUnpauseUser(user_, unpauseSupply_, unpauseBorrow_);\n    }\n\n    /// note we have not added updateUtilizationLimit in the params here because struct of InitializeVariables already has 16 variables\n    /// we might skip adding it and let it update through the indepdent function to keep initialize struct simple\n    function initialize(InitializeVariables memory i_) public payable _onlyDelegateCall {\n        _checkIsContract(TEAM_MULTISIG);\n\n        if (!(i_.smartCol || i_.smartDebt)) {\n            // either 1 should be on upon pool initialization\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n        // cut is an integer in storage slot which is more than enough\n        // but from UI we are allowing to send in 4 decimals to maintain consistency & avoid human error in future\n        if (i_.revenueCut != 0 && i_.revenueCut < FOUR_DECIMALS) {\n            // human input error. should send 0 for wanting 0, not 0 because of precision reduction.\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n\n        // revenue cut has no decimals\n        i_.revenueCut = i_.revenueCut / FOUR_DECIMALS;\n        i_.upperShiftThreshold = i_.upperShiftThreshold / THREE_DECIMALS;\n        i_.lowerShiftThreshold = i_.lowerShiftThreshold / THREE_DECIMALS;\n\n        if (\n            (i_.fee > FIVE_DECIMALS) || // fee cannot be more than 10%\n            (i_.revenueCut > TWO_DECIMALS) ||\n            (i_.upperPercent > (SIX_DECIMALS - FOUR_DECIMALS)) || // capping range to 99%.\n            (i_.lowerPercent > (SIX_DECIMALS - FOUR_DECIMALS)) || // capping range to 99%.\n            (i_.upperPercent == 0) ||\n            (i_.lowerPercent == 0) ||\n            (i_.upperShiftThreshold > THREE_DECIMALS) ||\n            (i_.lowerShiftThreshold > THREE_DECIMALS) ||\n            ((i_.upperShiftThreshold == 0) && (i_.lowerShiftThreshold > 0)) ||\n            ((i_.upperShiftThreshold > 0) && (i_.lowerShiftThreshold == 0)) ||\n            (i_.thresholdShiftTime == 0) ||\n            (i_.thresholdShiftTime > X24) ||\n            (i_.centerPriceAddress > X30) ||\n            (i_.hookAddress > X30) ||\n            (i_.centerPrice <= i_.minCenterPrice) ||\n            (i_.centerPrice >= i_.maxCenterPrice) ||\n            (i_.minCenterPrice == 0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n\n        uint dexVariables2_;\n\n        if (i_.smartCol) {\n            _turnOnSmartCol(i_.token0ColAmt, i_.centerPrice);\n            dexVariables2_ = dexVariables2_ | 1;\n        }\n\n        if (i_.smartDebt) {\n            _turnOnSmartDebt(i_.token0DebtAmt, i_.centerPrice);\n            dexVariables2_ = dexVariables2_ | 2;\n        }\n\n        i_.centerPrice = i_.centerPrice.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN);\n        // setting up initial dexVariables\n        dexVariables =\n            (i_.centerPrice << 1) |\n            (i_.centerPrice << 41) |\n            (i_.centerPrice << 81) |\n            (block.timestamp << 121) |\n            (60 << 154) | // just setting 60 seconds, no particular reason for it why \"60\"\n            (7 << 176);\n\n        dexVariables2 =\n            dexVariables2_ |\n            (i_.fee << 2) |\n            (i_.revenueCut << 19) |\n            (i_.upperPercent << 27) |\n            (i_.lowerPercent << 47) |\n            (i_.upperShiftThreshold << 68) |\n            (i_.lowerShiftThreshold << 78) |\n            (i_.thresholdShiftTime << 88) |\n            (i_.centerPriceAddress << 112) |\n            (i_.hookAddress << 142) |\n            (i_.maxCenterPrice.toBigNumber(20, 8, BigMathMinified.ROUND_UP) << 172) |\n            (i_.minCenterPrice.toBigNumber(20, 8, BigMathMinified.ROUND_DOWN) << 200) |\n            (THREE_DECIMALS << 228) | // setting initial token0 max utilization to 100%\n            (THREE_DECIMALS << 238); // setting initial token1 max utilization to 100%\n\n        emit LogInitializePoolConfig(\n            i_.smartCol,\n            i_.smartDebt,\n            i_.token0ColAmt,\n            i_.token0DebtAmt,\n            i_.fee,\n            i_.revenueCut * FOUR_DECIMALS,\n            i_.centerPriceAddress,\n            i_.hookAddress\n        );\n\n        emit LogInitializePriceParams(\n            i_.upperPercent,\n            i_.lowerPercent,\n            i_.upperShiftThreshold * THREE_DECIMALS,\n            i_.lowerShiftThreshold * THREE_DECIMALS,\n            i_.thresholdShiftTime,\n            i_.maxCenterPrice,\n            i_.minCenterPrice\n        );\n    }\n\n    function pauseSwapAndArbitrage() public _onlyDelegateCall {\n        uint dexVariables2_ = dexVariables2;\n        if ((dexVariables2_ >> 255) == 1) {\n            // already paused\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n        dexVariables2 = dexVariables2_ | (uint(1) << 255);\n\n        emit LogPauseSwapAndArbitrage();\n    }\n\n    function unpauseSwapAndArbitrage() public _onlyDelegateCall {\n        uint dexVariables2_ = dexVariables2;\n        if ((dexVariables2_ >> 255) == 0) {\n            // already unpaused\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n        dexVariables2 = (dexVariables2_ << 1) >> 1;\n\n        emit LogUnpauseSwapAndArbitrage();\n    }\n\n    /// @notice sends any potentially stuck funds to Liquidity contract.\n    /// @dev this contract never holds any funds as all operations send / receive funds from user <-> Liquidity.\n    function rescueFunds(address token_) external _onlyDelegateCall {\n        address liquidity_ = IFluidDexT1(address(this)).constantsView().liquidity;\n        if (token_ == NATIVE_TOKEN) {\n            SafeTransfer.safeTransferNative(liquidity_, address(this).balance);\n        } else {\n            SafeTransfer.safeTransfer(token_, liquidity_, IERC20(token_).balanceOf(address(this)));\n        }\n\n        emit LogRescueFunds(token_);\n    }\n\n    function updateMaxSupplyShares(uint maxSupplyShares_) external _onlyDelegateCall {\n        uint totalSupplyShares_ = _totalSupplyShares;\n\n        // totalSupplyShares_ can only be 0 when smart col pool is not initialized\n        if ((maxSupplyShares_ > X128) || (totalSupplyShares_ == 0)) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n        _totalSupplyShares = (totalSupplyShares_ & X128) | (maxSupplyShares_ << 128);\n\n        emit LogUpdateMaxSupplyShares(maxSupplyShares_);\n    }\n\n    function updateMaxBorrowShares(uint maxBorrowShares_) external _onlyDelegateCall {\n        uint totalBorrowShares_ = _totalBorrowShares;\n\n        // totalBorrowShares_ can only be 0 when smart debt pool is not initialized\n        if ((maxBorrowShares_ > X128) || (totalBorrowShares_ == 0)) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n        _totalBorrowShares = (totalBorrowShares_ & X128) | (maxBorrowShares_ << 128);\n\n        emit LogUpdateMaxBorrowShares(maxBorrowShares_);\n    }\n\n    /// @notice Toggles the oracle activation\n    /// @param turnOn_ Whether to turn on or off the oracle\n    function toggleOracleActivation(bool turnOn_) external _onlyDelegateCall {\n        uint dexVariables_ = dexVariables;\n        if ((((dexVariables_ >> 195) & 1 == 1) && turnOn_) || (((dexVariables_ >> 195) & 1 == 0) && !turnOn_)) {\n            // already active\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n        if (turnOn_) {\n            dexVariables = dexVariables_ | (uint(1) << 195);\n        } else {\n            dexVariables = dexVariables_ & (~(uint(1) << 195));\n        }\n\n        emit LogToggleOracleActivation(turnOn_);\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct InitializeVariables {\n        bool smartCol;\n        uint token0ColAmt;\n        bool smartDebt;\n        uint token0DebtAmt;\n        uint centerPrice;\n        uint fee;\n        uint revenueCut;\n        uint upperPercent;\n        uint lowerPercent;\n        uint upperShiftThreshold;\n        uint lowerShiftThreshold;\n        uint thresholdShiftTime;\n        uint centerPriceAddress;\n        uint hookAddress;\n        uint maxCenterPrice;\n        uint minCenterPrice;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/common/constantVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { StorageRead } from \"../../../../libraries/storageRead.sol\";\n\ninterface ITokenDecimals {\n    function decimals() external view returns (uint8);\n}\n\nabstract contract ConstantVariables is StorageRead {\n    /*//////////////////////////////////////////////////////////////\n                          CONSTANTS / IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    address internal constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 internal constant NATIVE_TOKEN_DECIMALS = 18;\n    address internal constant ADDRESS_DEAD = 0x000000000000000000000000000000000000dEaD;\n    uint256 internal constant TOKENS_DECIMALS_PRECISION = 12;\n    uint256 internal constant TOKENS_DECIMALS = 1e12;\n\n    uint256 internal constant SMALL_COEFFICIENT_SIZE = 10;\n    uint256 internal constant DEFAULT_COEFFICIENT_SIZE = 56;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant X2 = 0x3;\n    uint256 internal constant X3 = 0x7;\n    uint256 internal constant X5 = 0x1f;\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X8 = 0xff;\n    uint256 internal constant X9 = 0x1ff;\n    uint256 internal constant X10 = 0x3ff;\n    uint256 internal constant X11 = 0x7ff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X17 = 0x1ffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X20 = 0xfffff;\n    uint256 internal constant X22 = 0x3fffff;\n    uint256 internal constant X23 = 0x7fffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X28 = 0xfffffff;\n    uint256 internal constant X30 = 0x3fffffff;\n    uint256 internal constant X32 = 0xffffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X40 = 0xffffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n    uint256 internal constant X96 = 0xffffffffffffffffffffffff;\n    uint256 internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n\n    uint256 internal constant TWO_DECIMALS = 1e2;\n    uint256 internal constant THREE_DECIMALS = 1e3;\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant FIVE_DECIMALS = 1e5;\n    uint256 internal constant SIX_DECIMALS = 1e6;\n    uint256 internal constant EIGHT_DECIMALS = 1e8;\n    uint256 internal constant NINE_DECIMALS = 1e9;\n\n    uint256 internal constant PRICE_PRECISION = 1e27;\n\n    uint256 internal constant ORACLE_PRECISION = 1e18; // 100%\n    uint256 internal constant ORACLE_LIMIT = 5 * 1e16; // 5%\n\n    /// after swap token0 reserves should not be less than token1InToken0 / MINIMUM_LIQUIDITY_SWAP\n    /// after swap token1 reserves should not be less than token0InToken1 / MINIMUM_LIQUIDITY_SWAP\n    uint256 internal constant MINIMUM_LIQUIDITY_SWAP = 1e4;\n\n    /// after user operations (deposit, withdraw, borrow, payback) token0 reserves should not be less than token1InToken0 / MINIMUM_LIQUIDITY_USER_OPERATIONS\n    /// after user operations (deposit, withdraw, borrow, payback) token1 reserves should not be less than token0InToken0 / MINIMUM_LIQUIDITY_USER_OPERATIONS\n    uint256 internal constant MINIMUM_LIQUIDITY_USER_OPERATIONS = 1e6;\n\n    /// To skip transfers in liquidity layer if token in & out is same and liquidity layer is on the winning side\n    bytes32 internal constant SKIP_TRANSFERS = keccak256(bytes(\"SKIP_TRANSFERS\"));\n\n    function _decimals(address token_) internal view returns (uint256) {\n        return (token_ == NATIVE_TOKEN) ? NATIVE_TOKEN_DECIMALS : ITokenDecimals(token_).decimals();\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/common/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Variables {\n    /*//////////////////////////////////////////////////////////////\n                          STORAGE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// First 1 bit  => 0 => re-entrancy. If 0 then allow transaction to go, else throw.\n    /// Next 40 bits => 1-40 => last to last stored price. BigNumber (32 bits precision, 8 bits exponent)\n    /// Next 40 bits => 41-80 => last stored price of pool. BigNumber (32 bits precision, 8 bits exponent)\n    /// Next 40 bits => 81-120 => center price. Center price from where the ranges will be calculated. BigNumber (32 bits precision, 8 bits exponent)\n    /// Next 33 bits => 121-153 => last interaction time stamp\n    /// Next 22 bits => 154-175 => max 4194303 seconds (~1165 hrs, ~48.5 days), time difference between last to last and last price stored\n    /// Next 3 bits  => 176-178 => oracle checkpoint, if 0 then first slot, if 7 then last slot\n    /// Next 16 bits => 179-194 => current mapping or oracle, after every 8 transaction it will increase by 1. Max capacity is 65535 but it can be lower than that check dexVariables2\n    /// Next 1 bit  => 195 => is oracle active?\n    uint internal dexVariables;\n\n    /// Next  1 bit  => 0 => is smart collateral enabled?\n    /// Next  1 bit  => 1 => is smart debt enabled?\n    /// Next 17 bits => 2-18 => fee (1% = 10000, max value: 100000 = 10%, fee should not be more than 10%)\n    /// Next  7 bits => 19-25 => revenue cut from fee (1 = 1%, 100 = 100%). If fee is 1000 = 0.1% and revenue cut is 10 = 10% then governance get 0.01% of every swap\n    /// Next  1 bit  => 26 => percent active change going on or not, 0 = false, 1 = true, if true than that means governance has updated the below percents and the update should happen with a specified time.\n    /// Next 20 bits => 27-46 => upperPercent (1% = 10000, max value: 104.8575%) upperRange - upperRange * upperPercent = centerPrice. Hence, upperRange = centerPrice / (1 - upperPercent)\n    /// Next 20 bits => 47-66 => lowerPercent. lowerRange = centerPrice - centerPrice * lowerPercent.\n    /// Next  1 bit  => 67 => threshold percent active change going on or not, 0 = false, 1 = true, if true than that means governance has updated the below percents and the update should happen with a specified time.\n    /// Next 10 bits => 68-77 => upper shift threshold percent, 1 = 0.1%. 1000 = 100%. if currentPrice > (centerPrice + (upperRange - centerPrice) * (1000 - upperShiftThresholdPercent) / 1000) then trigger shift\n    /// Next 10 bits => 78-87 => lower shift threshold percent, 1 = 0.1%. 1000 = 100%. if currentPrice < (centerPrice - (centerPrice - lowerRange) * (1000 - lowerShiftThresholdPercent) / 1000) then trigger shift\n    /// Next 24 bits => 88-111 => Shifting time (~194 days) (rate = (% up + % down) / time ?)\n    /// Next 30 bits => 112-131 => Address of center price if center price should be fetched externally, for example, for wstETH <> ETH pool, fetch wstETH exchange rate into stETH from wstETH contract.\n    /// Why fetch it externally? Because let's say pool width is 0.1% and wstETH temporarily got depeg of 0.5% then pool will start to shift to newer pricing\n    /// but we don't want pool to shift to 0.5% because we know the depeg will recover so to avoid the loss for users.\n    /// Next 30 bits => 142-171 => Hooks bits, calculate hook address by storing deployment nonce from factory.\n    /// Next 28 bits => 172-199 => max center price. BigNumber (20 bits precision, 8 bits exponent)\n    /// Next 28 bits => 200-227 => min center price. BigNumber (20 bits precision, 8 bits exponent)\n    /// Next 10 bits => 228-237 => utilization limit of token0. Max value 1000 = 100%, if 100% then no need to check the utilization.\n    /// Next 10 bits => 238-247 => utilization limit of token1. Max value 1000 = 100%, if 100% then no need to check the utilization.\n    /// Next 1  bit  => 248     => is center price shift active\n    /// Last 1  bit  => 255     => Pause swap & arbitrage (only perfect functions will be usable), if we need to pause entire DEX then that can be done through pausing DEX on Liquidity Layer\n    uint internal dexVariables2;\n\n    /// first 128 bits => 0-127 => total supply shares\n    /// last 128 bits => 128-255 => max supply shares\n    uint internal _totalSupplyShares;\n\n    /// @dev user supply data: user -> data\n    /// Aside from 1st bit, entire bits here are same as liquidity layer _userSupplyData. Hence exact same supply & borrow limit library can be used\n    /// First  1 bit  =>       0 => is user allowed to supply? 0 = not allowed, 1 = allowed\n    /// Next  64 bits =>   1- 64 => user supply amount/shares; BigMath: 56 | 8\n    /// Next  64 bits =>  65-128 => previous user withdrawal limit; BigMath: 56 | 8\n    /// Next  33 bits => 129-161 => last triggered process timestamp (enough until 16 March 2242 -> max value 8589934591)\n    /// Next  14 bits => 162-175 => expand withdrawal limit percentage (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383).\n    ///                             @dev shrinking is instant\n    /// Next  24 bits => 176-199 => withdrawal limit expand duration in seconds.(Max value 16_777_215; ~4_660 hours, ~194 days)\n    /// Next  18 bits => 200-217 => base withdrawal limit: below this, 100% withdrawals can be done (aka shares can be burned); BigMath: 10 | 8\n    /// Next  38 bits => 218-255 => empty for future use\n    mapping(address => uint) internal _userSupplyData;\n\n    /// first 128 bits => 0-127 => total borrow shares\n    /// last 128 bits => 128-255 => max borrow shares\n    uint internal _totalBorrowShares;\n\n    /// @dev user borrow data: user -> data\n    /// Aside from 1st bit, entire bits here are same as liquidity layer _userBorrowData. Hence exact same supply & borrow limit library function can be used\n    /// First  1 bit  =>       0 => is user allowed to borrow? 0 = not allowed, 1 = allowed\n    /// Next  64 bits =>   1- 64 => user debt amount/shares; BigMath: 56 | 8\n    /// Next  64 bits =>  65-128 => previous user debt ceiling; BigMath: 56 | 8\n    /// Next  33 bits => 129-161 => last triggered process timestamp (enough until 16 March 2242 -> max value 8589934591)\n    /// Next  14 bits => 162-175 => expand debt ceiling percentage (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    ///                             @dev shrinking is instant\n    /// Next  24 bits => 176-199 => debt ceiling expand duration in seconds (Max value 16_777_215; ~4_660 hours, ~194 days)\n    /// Next  18 bits => 200-217 => base debt ceiling: below this, there's no debt ceiling limits; BigMath: 10 | 8\n    /// Next  18 bits => 218-235 => max debt ceiling: absolute maximum debt ceiling can expand to; BigMath: 10 | 8\n    /// Next  20 bits => 236-255 => empty for future use\n    mapping(address => uint) internal _userBorrowData;\n\n    /// Price difference between last swap of last block & last swap of new block\n    /// If last swap happened at Block B - 4 and next swap happened after 4 blocks at Block B then it will store that difference\n    /// considering time difference between these 4 blocks is 48 seconds, hence time will be stored as 48\n    /// New oracle update:\n    /// time to 9 bits and precision to 22 bits\n    /// if time exceeds 9 bits which is 511 sec or ~8.5 min then we will use 2 oracle slot to store the data\n    /// we will leave the both time slot as 0 and on first sign + precision slot we will store time and\n    /// on second sign + precision slot we will store sign & precision\n    /// First 9 bits =>   0-  8 => time, 511 seconds\n    /// Next   1 bit  =>  9     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits =>  10- 31 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits =>  32- 40 => time, 511 seconds\n    /// Next   1 bit  =>  41     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits =>  42- 63 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits =>  64- 72 => time, 511 seconds\n    /// Next   1 bit  =>  73     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits =>  74- 95 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits =>  96-104 => time, 511 seconds\n    /// Next   1 bit  => 105     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits => 106-127 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits => 128-136 => time, 511 seconds\n    /// Next   1 bit  => 137     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits => 138-159 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits => 160-168 => time, 511 seconds\n    /// Next   1 bit  => 169     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits => 170-191 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits => 192-200 => time, 511 seconds\n    /// Next   1 bit  => 201     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits => 202-223 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits => 224-232 => time, 511 seconds\n    /// Next   1 bit  => 233     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits => 234-255 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    mapping(uint => uint) internal _oracle;\n\n    /// First 20 bits =>  0-19 => old upper shift\n    /// Next  20 bits => 20-39 => old lower shift\n    /// Next  20 bits => 40-59 => in seconds, ~12 days max, shift can last for max ~12 days\n    /// Next  33 bits => 60-92 => timestamp of when the shift has started.\n    uint128 internal _rangeShift;\n\n    /// First 10 bits =>  0- 9 => old upper shift\n    /// Next  10 bits => 10-19 => empty so we can use same helper function\n    /// Next  10 bits => 20-29 => old lower shift\n    /// Next  10 bits => 30-39 => empty so we can use same helper function\n    /// Next  20 bits => 40-59 => in seconds, ~12 days max, shift can last for max ~12 days\n    /// Next  33 bits => 60-92 => timestamp of when the shift has started.\n    /// Next  24 bits => 93-116 => old threshold time\n    uint128 internal _thresholdShift;\n\n    /// Shifting is fuzzy and with time it'll keep on getting closer and then eventually get over\n    /// First 33 bits => 0 -32 => starting timestamp\n    /// Next  20 bits => 33-52 => % shift\n    /// Next  20 bits => 53-72 => time to shift that percent\n    uint256 internal _centerPriceShift;\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/core/colOperations.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SecondaryHelpers } from \"../helpers/secondaryHelpers.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @title FluidDexT1\n/// @notice Implements core logics for Fluid Dex protocol.\n/// Note Token transfers happen directly from user to Liquidity contract and vice-versa.\ncontract FluidDexT1OperationsCol is SecondaryHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) SecondaryHelpers(constantViews_) {\n        // all implementations should be zero other than shift\n        if (\n            constantViews_.implementations.shift == address(0) ||\n            constantViews_.implementations.admin != address(0) ||\n            constantViews_.implementations.colOperations != address(0) ||\n            constantViews_.implementations.debtOperations != address(0) ||\n            constantViews_.implementations.perfectOperationsAndSwapOut != address(0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__InvalidImplementation);\n        }\n    }\n\n    modifier _onlyDelegateCall() {\n        // also indirectly checked by `_check` because pool can never be initialized as long as the initialize method\n        // is delegate call only, but just to be sure on Admin logic we add the modifier everywhere nonetheless.\n        if (address(this) == THIS_CONTRACT) {\n            revert FluidDexError(ErrorTypes.DexT1__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) public payable _onlyDelegateCall returns (uint shares_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userSupplyData_ = _userSupplyData[msg.sender];\n\n        if (userSupplyData_ & 1 == 0 && !estimate_) revert FluidDexError(ErrorTypes.DexT1__UserSupplyInNotOn);\n\n        // is smart collateral pool enabled\n        if ((dexVariables2_ & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            DepositColMemory memory d_;\n\n            CollateralReserves memory c_ = _getCollateralReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.supplyToken0ExchangePrice,\n                pex_.supplyToken1ExchangePrice\n            );\n            CollateralReserves memory c2_ = c_;\n\n            if (token0Amt_ > 0) {\n                d_.token0AmtAdjusted =\n                    (((token0Amt_ - 1) * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION) -\n                    1;\n                _verifySwapAndNonPerfectActions(d_.token0AmtAdjusted, token0Amt_);\n                _verifyMint(d_.token0AmtAdjusted, c_.token0RealReserves);\n            }\n\n            if (token1Amt_ > 0) {\n                d_.token1AmtAdjusted =\n                    (((token1Amt_ - 1) * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION) -\n                    1;\n                _verifySwapAndNonPerfectActions(d_.token1AmtAdjusted, token1Amt_);\n                _verifyMint(d_.token1AmtAdjusted, c_.token1RealReserves);\n            }\n\n            uint temp_;\n            uint temp2_;\n\n            uint totalSupplyShares_ = _totalSupplyShares & X128;\n            if ((c_.token0RealReserves > 0) && (c_.token1RealReserves > 0)) {\n                if (d_.token0AmtAdjusted > 0 && d_.token1AmtAdjusted > 0) {\n                    // mint shares in equal proportion\n                    // temp_ => expected shares from token0 deposit\n                    temp_ = (d_.token0AmtAdjusted * 1e18) / c_.token0RealReserves;\n                    // temp2_ => expected shares from token1 deposit\n                    temp2_ = (d_.token1AmtAdjusted * 1e18) / c_.token1RealReserves;\n                    if (temp_ > temp2_) {\n                        // use temp2_ shares\n                        shares_ = (temp2_ * totalSupplyShares_) / 1e18;\n                        // temp_ => token0 to swap\n                        temp_ = ((temp_ - temp2_) * c_.token0RealReserves) / 1e18;\n                        temp2_ = 0;\n                    } else if (temp2_ > temp_) {\n                        // use temp_ shares\n                        shares_ = (temp_ * totalSupplyShares_) / 1e18;\n                        // temp2_ => token1 to swap\n                        temp2_ = ((temp2_ - temp_) * c_.token1RealReserves) / 1e18;\n                        temp_ = 0;\n                    } else {\n                        // if equal then revert as swap will not be needed anymore which can create some issue, better to use depositPerfect in this case\n                        revert FluidDexError(ErrorTypes.DexT1__InvalidDepositAmts);\n                    }\n\n                    // User deposited in equal proportion here. Hence updating col reserves and the swap will happen on updated col reserves\n                    c2_ = _getUpdatedColReserves(shares_, totalSupplyShares_, c_, true);\n\n                    totalSupplyShares_ += shares_;\n                } else if (d_.token0AmtAdjusted > 0) {\n                    temp_ = d_.token0AmtAdjusted;\n                    temp2_ = 0;\n                } else if (d_.token1AmtAdjusted > 0) {\n                    temp_ = 0;\n                    temp2_ = d_.token1AmtAdjusted;\n                } else {\n                    // user sent both amounts as 0\n                    revert FluidDexError(ErrorTypes.DexT1__InvalidDepositAmts);\n                }\n\n                if (temp_ > 0) {\n                    // swap token0\n                    temp_ = _getSwapAndDeposit(\n                        temp_, // token0 to divide and swap\n                        c2_.token1ImaginaryReserves, // token1 imaginary reserves\n                        c2_.token0ImaginaryReserves, // token0 imaginary reserves\n                        c2_.token0RealReserves, // token0 real reserves\n                        c2_.token1RealReserves // token1 real reserves\n                    );\n                } else if (temp2_ > 0) {\n                    // swap token1\n                    temp_ = _getSwapAndDeposit(\n                        temp2_, // token1 to divide and swap\n                        c2_.token0ImaginaryReserves, // token0 imaginary reserves\n                        c2_.token1ImaginaryReserves, // token1 imaginary reserves\n                        c2_.token1RealReserves, // token1 real reserves\n                        c2_.token0RealReserves // token0 real reserves\n                    );\n                } else {\n                    // maybe possible to happen due to some precision issue that both are 0\n                    revert FluidDexError(ErrorTypes.DexT1__DepositAmtsZero);\n                }\n\n                // new shares minted from swap & deposit\n                temp_ = (temp_ * totalSupplyShares_) / 1e18;\n                // adding fee in case of swap & deposit\n                // 1 - fee. If fee is 1% then without fee will be 1e6 - 1e4\n                // temp_ => withdraw fee\n                temp_ = (temp_ * (SIX_DECIMALS - ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n                // final new shares to mint for user\n                shares_ += temp_;\n                // final new collateral shares\n                totalSupplyShares_ += temp_;\n            } else {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidCollateralReserves);\n            }\n\n            if (estimate_) revert FluidDexLiquidityOutput(shares_);\n\n            if (shares_ < minSharesAmt_) revert FluidDexError(ErrorTypes.DexT1__SharesMintedLess);\n\n            if (token0Amt_ > 0) {\n                _verifyToken1Reserves(\n                    (c_.token0RealReserves + d_.token0AmtAdjusted),\n                    (c_.token1RealReserves + d_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                temp_ = token0Amt_;\n                _depositOrPaybackInLiquidity(TOKEN_0, temp_, 0);\n            }\n\n            if (token1Amt_ > 0) {\n                _verifyToken0Reserves(\n                    (c_.token0RealReserves + d_.token0AmtAdjusted),\n                    (c_.token1RealReserves + d_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                temp_ = token1Amt_;\n                _depositOrPaybackInLiquidity(TOKEN_1, temp_, 0);\n            }\n\n            // userSupply_ => temp_\n            temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            // extracting exisiting shares and then adding new shares in it\n            temp_ = ((temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK));\n\n            // calculate current, updated (expanded etc.) withdrawal limit\n            // newWithdrawalLimit_ => temp2_\n            temp2_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, temp_);\n\n            temp_ += shares_;\n\n            _updatingUserSupplyDataOnStorage(userSupplyData_, temp_, temp2_);\n\n            // updating total col shares in storage\n            _updateSupplyShares(totalSupplyShares_);\n\n            emit LogDepositColLiquidity(token0Amt_, token1Amt_, shares_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartColNotEnabled);\n        }\n    }\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) public _onlyDelegateCall returns (uint shares_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userSupplyData_ = _userSupplyData[msg.sender];\n\n        if (userSupplyData_ & 1 == 0 && to_ != ADDRESS_DEAD) revert FluidDexError(ErrorTypes.DexT1__UserSupplyInNotOn);\n\n        WithdrawColMemory memory w_;\n\n        w_.to = (to_ == address(0)) ? msg.sender : to_;\n\n        // is smart collateral pool enabled\n        if ((dexVariables2_ & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            uint token0Reserves_ = _getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, pex_.supplyToken0ExchangePrice, true);\n            uint token1Reserves_ = _getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, pex_.supplyToken1ExchangePrice, false);\n            w_.token0ReservesInitial = token0Reserves_;\n            w_.token1ReservesInitial = token1Reserves_;\n\n            if (token0Amt_ > 0) {\n                w_.token0AmtAdjusted =\n                    (((token0Amt_ + 1) * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION) +\n                    1;\n                _verifySwapAndNonPerfectActions(w_.token0AmtAdjusted, token0Amt_);\n                _verifyRedeem(w_.token0AmtAdjusted, token0Reserves_);\n            }\n\n            if (token1Amt_ > 0) {\n                w_.token1AmtAdjusted =\n                    (((token1Amt_ + 1) * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION) +\n                    1;\n                _verifySwapAndNonPerfectActions(w_.token1AmtAdjusted, token1Amt_);\n                _verifyRedeem(w_.token1AmtAdjusted, token1Reserves_);\n            }\n\n            uint temp_;\n            uint temp2_;\n\n            uint totalSupplyShares_ = _totalSupplyShares & X128;\n            if ((token0Reserves_ > 0) && (token1Reserves_ > 0)) {\n                if (w_.token0AmtAdjusted > 0 && w_.token1AmtAdjusted > 0) {\n                    // mint shares in equal proportion\n                    // temp_ => expected shares from token0 withdraw\n                    temp_ = (w_.token0AmtAdjusted * 1e18) / token0Reserves_;\n                    // temp2_ => expected shares from token1 withdraw\n                    temp2_ = (w_.token1AmtAdjusted * 1e18) / token1Reserves_;\n                    if (temp_ > temp2_) {\n                        // use temp2_ shares\n                        shares_ = ((temp2_ * totalSupplyShares_) / 1e18);\n                        // temp_ => token0 to swap\n                        temp_ = ((temp_ - temp2_) * token0Reserves_) / 1e18;\n                        temp2_ = 0;\n                    } else if (temp2_ > temp_) {\n                        // use temp1_ shares\n                        shares_ = ((temp_ * totalSupplyShares_) / 1e18);\n                        // temp2_ => token1 to swap\n                        temp2_ = ((temp2_ - temp_) * token1Reserves_) / 1e18;\n                        temp_ = 0;\n                    } else {\n                        // if equal then revert as swap will not be needed anymore which can create some issue, better to use withdraw in perfect proportion for this\n                        revert FluidDexError(ErrorTypes.DexT1__InvalidWithdrawAmts);\n                    }\n\n                    // User withdrew in equal proportion here. Hence updating col reserves and the swap will happen on updated col reserves\n                    token0Reserves_ = token0Reserves_ - ((token0Reserves_ * shares_) / totalSupplyShares_);\n                    token1Reserves_ = token1Reserves_ - ((token1Reserves_ * shares_) / totalSupplyShares_);\n                    totalSupplyShares_ -= shares_;\n                } else if (w_.token0AmtAdjusted > 0) {\n                    temp_ = w_.token0AmtAdjusted;\n                    temp2_ = 0;\n                } else if (w_.token1AmtAdjusted > 0) {\n                    temp_ = 0;\n                    temp2_ = w_.token1AmtAdjusted;\n                } else {\n                    // user sent both amounts as 0\n                    revert FluidDexError(ErrorTypes.DexT1__WithdrawAmtsZero);\n                }\n\n                uint token0ImaginaryReservesOutsideRangpex_;\n                uint token1ImaginaryReservesOutsideRangpex_;\n\n                if (pex_.geometricMean < 1e27) {\n                    (\n                        token0ImaginaryReservesOutsideRangpex_,\n                        token1ImaginaryReservesOutsideRangpex_\n                    ) = _calculateReservesOutsideRange(\n                        pex_.geometricMean,\n                        pex_.upperRange,\n                        (token0Reserves_ - temp_),\n                        (token1Reserves_ - temp2_)\n                    );\n                } else {\n                    // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n                    // 1 / geometricMean for new geometricMean\n                    // 1 / lowerRange will become upper range\n                    // 1 / upperRange will become lower range\n                    (\n                        token1ImaginaryReservesOutsideRangpex_,\n                        token0ImaginaryReservesOutsideRangpex_\n                    ) = _calculateReservesOutsideRange(\n                        (1e54 / pex_.geometricMean),\n                        (1e54 / pex_.lowerRange),\n                        (token1Reserves_ - temp2_),\n                        (token0Reserves_ - temp_)\n                    );\n                }\n\n                if (temp_ > 0) {\n                    // swap into token0\n                    temp_ = _getWithdrawAndSwap(\n                        token0Reserves_, // token0 real reserves\n                        token1Reserves_, // token1 real reserves\n                        token0ImaginaryReservesOutsideRangpex_, // token0 imaginary reserves\n                        token1ImaginaryReservesOutsideRangpex_, // token1 imaginary reserves\n                        temp_ // token0 to divide and swap into\n                    );\n                } else if (temp2_ > 0) {\n                    // swap into token1\n                    temp_ = _getWithdrawAndSwap(\n                        token1Reserves_, // token1 real reserves\n                        token0Reserves_, // token0 real reserves\n                        token1ImaginaryReservesOutsideRangpex_, // token1 imaginary reserves\n                        token0ImaginaryReservesOutsideRangpex_, // token0 imaginary reserves\n                        temp2_ // token0 to divide and swap into\n                    );\n                } else {\n                    // maybe possible to happen due to some precision issue that both are 0\n                    revert FluidDexError(ErrorTypes.DexT1__WithdrawAmtsZero);\n                }\n\n                // shares to burn from withdraw & swap\n                temp_ = ((temp_ * totalSupplyShares_) / 1e18);\n                // adding fee in case of withdraw & swap\n                // 1 + fee. If fee is 1% then withdrawing withFepex_ will be 1e6 + 1e4\n                temp_ = (temp_ * (SIX_DECIMALS + ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n                // updating shares to burn for user\n                shares_ += temp_;\n                // final new collateral shares\n                totalSupplyShares_ -= temp_;\n            } else {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidCollateralReserves);\n            }\n\n            if (to_ == ADDRESS_DEAD) revert FluidDexLiquidityOutput(shares_);\n\n            if (shares_ > maxSharesAmt_) revert FluidDexError(ErrorTypes.DexT1__WithdrawExcessSharesBurn);\n\n            // userSupply_ => temp_\n            temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) withdrawal limit\n            // newWithdrawalLimit_ => temp2_\n            temp2_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, temp_);\n\n            temp_ -= shares_;\n\n            // withdrawal limit reached\n            if (temp_ < temp2_) revert FluidDexError(ErrorTypes.DexT1__WithdrawLimitReached);\n\n            _updatingUserSupplyDataOnStorage(userSupplyData_, temp_, temp2_);\n\n            // updating total col shares in storage\n            _updateSupplyShares(totalSupplyShares_);\n\n            if (w_.token0AmtAdjusted > 0) {\n                _verifyToken0Reserves(\n                    (w_.token0ReservesInitial - w_.token0AmtAdjusted),\n                    (w_.token1ReservesInitial - w_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // withdraw\n                temp_ = token0Amt_;\n                LIQUIDITY.operate(TOKEN_0, -int(temp_), 0, w_.to, address(0), new bytes(0));\n            }\n\n            if (w_.token1AmtAdjusted > 0) {\n                _verifyToken1Reserves(\n                    (w_.token0ReservesInitial - w_.token0AmtAdjusted),\n                    (w_.token1ReservesInitial - w_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // withdraw\n                temp_ = token1Amt_;\n                LIQUIDITY.operate(TOKEN_1, -int(temp_), 0, w_.to, address(0), new bytes(0));\n            }\n\n            emit LogWithdrawColLiquidity(token0Amt_, token1Amt_, shares_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartColNotEnabled);\n        }\n    }\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) public _onlyDelegateCall returns (uint withdrawAmt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userSupplyData_ = _userSupplyData[msg.sender];\n\n        if (userSupplyData_ & 1 == 0 && to_ != ADDRESS_DEAD) {\n            revert FluidDexError(ErrorTypes.DexT1__UserSupplyInNotOn);\n        }\n\n        to_ = (to_ == address(0)) ? msg.sender : to_;\n\n        if ((minToken0_ > 0 && minToken1_ > 0) || (minToken0_ == 0 && minToken1_ == 0)) {\n            // only 1 token should be > 0\n            revert FluidDexError(ErrorTypes.DexT1__InvalidWithdrawAmts);\n        }\n\n        // is smart collateral pool enabled\n        if ((dexVariables2_ & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            uint totalSupplyShares_ = _totalSupplyShares & X128;\n\n            _verifyRedeem(shares_, totalSupplyShares_);\n\n            uint token0Amt_;\n            uint token1Amt_;\n\n            CollateralReserves memory c_ = _getCollateralReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.supplyToken0ExchangePrice,\n                pex_.supplyToken1ExchangePrice\n            );\n\n            if ((c_.token0RealReserves == 0) || (c_.token1RealReserves == 0)) {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidCollateralReserves);\n            }\n            \n            CollateralReserves memory c2_ = _getUpdatedColReserves(shares_, totalSupplyShares_, c_, false);\n            // Storing exact token0 & token1 raw/adjusted withdrawal amount after burning shares\n            token0Amt_ = c_.token0RealReserves - c2_.token0RealReserves - 1;\n            token1Amt_ = c_.token1RealReserves - c2_.token1RealReserves - 1;\n\n            if (minToken0_ > 0) {\n                // user wants to withdraw entirely in token0, hence swapping token1 into token0\n                token0Amt_ += _getAmountOut(token1Amt_, c2_.token1ImaginaryReserves, c2_.token0ImaginaryReserves);\n                token1Amt_ = 0;\n                _verifyToken0Reserves(\n                    (c_.token0RealReserves - token0Amt_),\n                    c_.token1RealReserves,\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n\n                // converting token0Amt_ from raw/adjusted to normal token amount\n                token0Amt_ = (((token0Amt_ - 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) - 1;\n\n                // deducting fee on withdrawing in 1 token\n                token0Amt_ = (token0Amt_ * (SIX_DECIMALS - ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n\n                withdrawAmt_ = token0Amt_;\n                if (to_ == ADDRESS_DEAD) revert FluidDexLiquidityOutput(shares_);\n                if (withdrawAmt_ < minToken0_) revert FluidDexError(ErrorTypes.DexT1__WithdrawalNotEnough);\n            } else {\n                // user wants to withdraw entirely in token1, hence swapping token0 into token1\n                token1Amt_ += _getAmountOut(token0Amt_, c2_.token0ImaginaryReserves, c2_.token1ImaginaryReserves);\n                token0Amt_ = 0;\n                _verifyToken1Reserves(\n                    c_.token0RealReserves,\n                    (c_.token1RealReserves - token1Amt_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n\n                // converting token1Amt_ from raw/adjusted to normal token amount\n                token1Amt_ = (((token1Amt_ - 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) - 1;\n\n                // deducting fee on withdrawing in 1 token\n                token1Amt_ = (token1Amt_ * (SIX_DECIMALS - ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n\n                withdrawAmt_ = token1Amt_;\n                if (to_ == ADDRESS_DEAD) revert FluidDexLiquidityOutput(shares_);\n                if (withdrawAmt_ < minToken1_) revert FluidDexError(ErrorTypes.DexT1__WithdrawalNotEnough);\n            }\n\n            uint256 userSupply_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            userSupply_ = (userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) withdrawal limit\n            // temp_ => newWithdrawalLimit_\n            uint256 temp_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\n\n            userSupply_ -= shares_;\n\n            // withdraws below limit\n            if (userSupply_ < temp_) revert FluidDexError(ErrorTypes.DexT1__WithdrawLimitReached);\n\n            _updatingUserSupplyDataOnStorage(userSupplyData_, userSupply_, temp_);\n\n            totalSupplyShares_ = totalSupplyShares_ - shares_;\n            _updateSupplyShares(totalSupplyShares_);\n\n            // to avoid stack-too-deep error\n            temp_ = uint160(to_);\n            if (minToken0_ > 0) {\n                // withdraw\n                LIQUIDITY.operate(TOKEN_0, -int(token0Amt_), 0, address(uint160(temp_)), address(0), new bytes(0));\n            } else {\n                // withdraw\n                LIQUIDITY.operate(TOKEN_1, -int(token1Amt_), 0, address(uint160(temp_)), address(0), new bytes(0));\n            }\n\n            // to avoid stack-too-deep error\n            temp_ = shares_;\n            emit LogWithdrawColInOneToken(temp_, token0Amt_, token1Amt_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartColNotEnabled);\n        }\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/core/debtOperations.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SecondaryHelpers } from \"../helpers/secondaryHelpers.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @title FluidDexT1\n/// @notice Implements core logics for Fluid Dex protocol.\n/// Note Token transfers happen directly from user to Liquidity contract and vice-versa.\ncontract FluidDexT1OperationsDebt is SecondaryHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) SecondaryHelpers(constantViews_) {\n        // all implementations should be zero other than shift\n        if (\n            constantViews_.implementations.shift == address(0) ||\n            constantViews_.implementations.admin != address(0) ||\n            constantViews_.implementations.colOperations != address(0) ||\n            constantViews_.implementations.debtOperations != address(0) ||\n            constantViews_.implementations.perfectOperationsAndSwapOut != address(0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__InvalidImplementation);\n        }\n    }\n\n    modifier _onlyDelegateCall() {\n        // also indirectly checked by `_check` because pool can never be initialized as long as the initialize method\n        // is delegate call only, but just to be sure on Admin logic we add the modifier everywhere nonetheless.\n        if (address(this) == THIS_CONTRACT) {\n            revert FluidDexError(ErrorTypes.DexT1__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_ \n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) public _onlyDelegateCall returns (uint shares_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userBorrowData_ = _userBorrowData[msg.sender];\n\n        if (userBorrowData_ & 1 == 0 && to_ != ADDRESS_DEAD) revert FluidDexError(ErrorTypes.DexT1__UserDebtInNotOn);\n\n        BorrowDebtMemory memory b_;\n\n        b_.to = (to_ == address(0)) ? msg.sender : to_;\n\n        // is smart debt pool enabled\n        if (((dexVariables2_ >> 1) & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            uint token0Debt_ = _getLiquidityDebt(BORROW_TOKEN_0_SLOT, pex_.borrowToken0ExchangePrice, true);\n            uint token1Debt_ = _getLiquidityDebt(BORROW_TOKEN_1_SLOT, pex_.borrowToken1ExchangePrice, false);\n            b_.token0DebtInitial = token0Debt_;\n            b_.token1DebtInitial = token1Debt_;\n\n            if (token0Amt_ > 0) {\n                b_.token0AmtAdjusted =\n                    (((token0Amt_ + 1) * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION) +\n                    1;\n                _verifySwapAndNonPerfectActions(b_.token0AmtAdjusted, token0Amt_);\n                _verifyMint(b_.token0AmtAdjusted, token0Debt_);\n            }\n\n            if (token1Amt_ > 0) {\n                b_.token1AmtAdjusted =\n                    (((token1Amt_ + 1) * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION) +\n                    1;\n                _verifySwapAndNonPerfectActions(b_.token1AmtAdjusted, token1Amt_);\n                _verifyMint(b_.token1AmtAdjusted, token1Debt_);\n            }\n\n            uint temp_;\n            uint temp2_;\n\n            uint totalBorrowShares_ = _totalBorrowShares & X128;\n            if ((token0Debt_ > 0) && (token1Debt_ > 0)) {\n                if (b_.token0AmtAdjusted > 0 && b_.token1AmtAdjusted > 0) {\n                    // mint shares in equal proportion\n                    // temp_ => expected shares from token0 payback\n                    temp_ = (b_.token0AmtAdjusted * 1e18) / token0Debt_;\n                    // temp2_ => expected shares from token1 payback\n                    temp2_ = (b_.token1AmtAdjusted * 1e18) / token1Debt_;\n                    if (temp_ > temp2_) {\n                        // use temp2_ shares\n                        shares_ = (temp2_ * totalBorrowShares_) / 1e18;\n                        // temp_ => token0 to swap\n                        temp_ = ((temp_ - temp2_) * token0Debt_) / 1e18;\n                        temp2_ = 0;\n                    } else if (temp2_ > temp_) {\n                        // use temp1_ shares\n                        shares_ = (temp_ * totalBorrowShares_) / 1e18;\n                        // temp2_ => token1 to swap\n                        temp2_ = ((temp2_ - temp_) * token1Debt_) / 1e18;\n                        temp_ = 0;\n                    } else {\n                        // if equal then revert as swap will not be needed anymore which can create some issue, better to use perfect borrow in this case\n                        revert FluidDexError(ErrorTypes.DexT1__InvalidBorrowAmts);\n                    }\n\n                    // User borrowed in equal proportion here. Hence updating col reserves and the swap will happen on updated col reserves\n                    token0Debt_ = token0Debt_ + (token0Debt_ * shares_) / totalBorrowShares_;\n                    token1Debt_ = token1Debt_ + (token1Debt_ * shares_) / totalBorrowShares_;\n                    totalBorrowShares_ += shares_;\n                } else if (b_.token0AmtAdjusted > 0) {\n                    temp_ = b_.token0AmtAdjusted;\n                    temp2_ = 0;\n                } else if (b_.token1AmtAdjusted > 0) {\n                    temp_ = 0;\n                    temp2_ = b_.token1AmtAdjusted;\n                } else {\n                    // user sent both amounts as 0\n                    revert FluidDexError(ErrorTypes.DexT1__InvalidBorrowAmts);\n                }\n\n                uint token0FinalImaginaryReserves_;\n                uint token1FinalImaginaryReserves_;\n\n                if (pex_.geometricMean < 1e27) {\n                    (, , token0FinalImaginaryReserves_, token1FinalImaginaryReserves_) = _calculateDebtReserves(\n                        pex_.geometricMean,\n                        pex_.lowerRange,\n                        (token0Debt_ + temp_),\n                        (token1Debt_ + temp2_)\n                    );\n                } else {\n                    // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n                    // 1 / geometricMean for new geometricMean\n                    // 1 / lowerRange will become upper range\n                    // 1 / upperRange will become lower range\n                    (, , token1FinalImaginaryReserves_, token0FinalImaginaryReserves_) = _calculateDebtReserves(\n                        (1e54 / pex_.geometricMean),\n                        (1e54 / pex_.upperRange),\n                        (token1Debt_ + temp2_),\n                        (token0Debt_ + temp_)\n                    );\n                }\n\n                if (temp_ > 0) {\n                    // swap into token0\n                    temp_ = _getBorrowAndSwap(\n                        token0Debt_, // token0 debt\n                        token1Debt_, // token1 debt\n                        token0FinalImaginaryReserves_, // token0 imaginary reserves\n                        token1FinalImaginaryReserves_, // token1 imaginary reserves\n                        temp_ // token0 to divide and swap into\n                    );\n                } else if (temp2_ > 0) {\n                    // swap into token1\n                    temp_ = _getBorrowAndSwap(\n                        token1Debt_, // token1 debt\n                        token0Debt_, // token0 debt\n                        token1FinalImaginaryReserves_, // token1 imaginary reserves\n                        token0FinalImaginaryReserves_, // token0 imaginary reserves\n                        temp2_ // token1 to divide and swap into\n                    );\n                } else {\n                    // maybe possible to happen due to some precision issue that both are 0\n                    revert FluidDexError(ErrorTypes.DexT1__BorrowAmtsZero);\n                }\n\n                // new shares to mint from borrow & swap\n                temp_ = (temp_ * totalBorrowShares_) / 1e18;\n                // adding fee in case of borrow & swap\n                // 1 + fee. If fee is 1% then withdrawing withFepex_ will be 1e6 + 1e4\n                temp_ = (temp_ * (SIX_DECIMALS + ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n                // final new shares to mint for user\n                shares_ += temp_;\n                // final new debt shares\n                totalBorrowShares_ += temp_;\n            } else {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidDebtReserves);\n            }\n\n            if (to_ == ADDRESS_DEAD) revert FluidDexLiquidityOutput(shares_);\n\n            if (shares_ > maxSharesAmt_) revert FluidDexError(ErrorTypes.DexT1__BorrowExcessSharesMinted);\n\n            // extract user borrow amount\n            // userBorrow_ => temp_\n            temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) borrow limit\n            // newBorrowLimit_ => temp2_\n            temp2_ = DexCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, temp_);\n\n            temp_ += shares_;\n\n            // user above debt limit\n            if (temp_ > temp2_) revert FluidDexError(ErrorTypes.DexT1__DebtLimitReached);\n\n            _updatingUserBorrowDataOnStorage(userBorrowData_, temp_, temp2_);\n\n            if (b_.token0AmtAdjusted > 0) {\n                // comparing debt here rather than reserves to simply code, impact won't be much overall\n                _verifyToken1Reserves(\n                    (b_.token0DebtInitial + b_.token0AmtAdjusted),\n                    (b_.token1DebtInitial + b_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // assigning token0Amt_ to temp_ to avoid compilation error (I don't know why it's throwing when using token0Amt_ directly)\n                temp_ = token0Amt_;\n                // borrow\n                LIQUIDITY.operate(TOKEN_0, 0, int(temp_), address(0), b_.to, new bytes(0));\n            }\n\n            if (b_.token1AmtAdjusted > 0) {\n                // comparing debt here rather than reserves to simply code, impact won't be much overall\n                _verifyToken0Reserves(\n                    (b_.token0DebtInitial + b_.token0AmtAdjusted),\n                    (b_.token1DebtInitial + b_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // assigning token1Amt_ to temp_ to avoid compilation error (I don't know why it's throwing when using token0Amt_ directly)\n                temp_ = token1Amt_;\n                // borrow\n                LIQUIDITY.operate(TOKEN_1, 0, int(temp_), address(0), b_.to, new bytes(0));\n            }\n\n            // updating total debt shares in storage\n            _updateBorrowShares(totalBorrowShares_);\n\n            emit LogBorrowDebtLiquidity(token0Amt_, token1Amt_, shares_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartDebtNotEnabled);\n        }\n    }\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) public payable _onlyDelegateCall returns (uint shares_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userBorrowData_ = _userBorrowData[msg.sender];\n\n        if (userBorrowData_ & 1 == 0 && !estimate_) revert FluidDexError(ErrorTypes.DexT1__UserDebtInNotOn);\n\n        // is smart debt pool enabled\n        if (((dexVariables2_ >> 1) & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            PaybackDebtMemory memory p_;\n\n            DebtReserves memory d_ = _getDebtReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.borrowToken0ExchangePrice,\n                pex_.borrowToken1ExchangePrice\n            );\n            DebtReserves memory d2_ = d_;\n\n            if (token0Amt_ > 0) {\n                p_.token0AmtAdjusted =\n                    (((token0Amt_ - 1) * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION) -\n                    1;\n                _verifySwapAndNonPerfectActions(p_.token0AmtAdjusted, token0Amt_);\n                _verifyRedeem(p_.token0AmtAdjusted, d_.token0Debt);\n            }\n\n            if (token1Amt_ > 0) {\n                p_.token1AmtAdjusted =\n                    (((token1Amt_ - 1) * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION) -\n                    1;\n                _verifySwapAndNonPerfectActions(p_.token1AmtAdjusted, token1Amt_);\n                _verifyRedeem(p_.token1AmtAdjusted, d_.token1Debt);\n            }\n\n            uint temp_;\n            uint temp2_;\n\n            uint totalBorrowShares_ = _totalBorrowShares & X128;\n            if ((d_.token0Debt > 0) && (d_.token1Debt > 0)) {\n                if (p_.token0AmtAdjusted > 0 && p_.token1AmtAdjusted > 0) {\n                    // burn shares in equal proportion\n                    // temp_ => expected shares from token0 payback\n                    temp_ = (p_.token0AmtAdjusted * 1e18) / d_.token0Debt;\n                    // temp2_ => expected shares from token1 payback\n                    temp2_ = (p_.token1AmtAdjusted * 1e18) / d_.token1Debt;\n                    if (temp_ > temp2_) {\n                        // use temp2_ shares\n                        shares_ = ((temp2_ * totalBorrowShares_) / 1e18);\n                        // temp_ => token0 to swap\n                        temp_ = p_.token0AmtAdjusted - (temp2_ * p_.token0AmtAdjusted) / temp_;\n                        temp2_ = 0;\n                    } else if (temp2_ > temp_) {\n                        // use temp_ shares\n                        shares_ = ((temp_ * totalBorrowShares_) / 1e18);\n                        // temp2_ => token1 to swap\n                        temp2_ = p_.token1AmtAdjusted - ((temp_ * p_.token1AmtAdjusted) / temp2_); // to this\n                        temp_ = 0;\n                    } else {\n                        // if equal then revert as swap will not be needed anymore which can create some issue, better to use perfect payback in this case\n                        revert FluidDexError(ErrorTypes.DexT1__InvalidPaybackAmts);\n                    }\n\n                    // User paid back in equal proportion here. Hence updating debt reserves and the swap will happen on updated debt reserves\n                    d2_ = _getUpdateDebtReserves(\n                        shares_,\n                        totalBorrowShares_,\n                        d_,\n                        false // true if mint, false if burn\n                    );\n                    totalBorrowShares_ -= shares_;\n                } else if (p_.token0AmtAdjusted > 0) {\n                    temp_ = p_.token0AmtAdjusted;\n                    temp2_ = 0;\n                } else if (p_.token1AmtAdjusted > 0) {\n                    temp_ = 0;\n                    temp2_ = p_.token1AmtAdjusted;\n                } else {\n                    // user sent both amounts as 0\n                    revert FluidDexError(ErrorTypes.DexT1__InvalidPaybackAmts);\n                }\n\n                if (temp_ > 0) {\n                    // swap token0 into token1 and payback equally\n                    temp_ = _getSwapAndPayback(\n                        d2_.token0Debt,\n                        d2_.token1Debt,\n                        d2_.token0ImaginaryReserves,\n                        d2_.token1ImaginaryReserves,\n                        temp_\n                    );\n                } else if (temp2_ > 0) {\n                    // swap token1 into token0 and payback equally\n                    temp_ = _getSwapAndPayback(\n                        d2_.token1Debt,\n                        d2_.token0Debt,\n                        d2_.token1ImaginaryReserves,\n                        d2_.token0ImaginaryReserves,\n                        temp2_\n                    );\n                } else {\n                    // maybe possible to happen due to some precision issue that both are 0\n                    revert FluidDexError(ErrorTypes.DexT1__PaybackAmtsZero);\n                }\n\n                // new shares to burn from payback & swap\n                temp_ = ((temp_ * totalBorrowShares_) / 1e18);\n\n                // adding fee in case of payback & swap\n                // 1 - fee. If fee is 1% then withdrawing withFepex_ will be 1e6 - 1e4\n                temp_ = (temp_ * (SIX_DECIMALS - ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n                // final shares to burn for user\n                shares_ += temp_;\n                // final new debt shares\n                totalBorrowShares_ -= temp_;\n            } else {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidDebtReserves);\n            }\n\n            if (estimate_) revert FluidDexLiquidityOutput(shares_);\n\n            if (shares_ < minSharesAmt_) revert FluidDexError(ErrorTypes.DexT1__PaybackSharedBurnedLess);\n\n            if (token0Amt_ > 0) {\n                // comparing debt here rather than reserves to simply code, impact won't be much overall\n                _verifyToken0Reserves(\n                    (d_.token0Debt - p_.token0AmtAdjusted),\n                    (d_.token1Debt - p_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // payback\n                temp_ = token0Amt_;\n                _depositOrPaybackInLiquidity(TOKEN_0, 0, temp_);\n            }\n\n            if (token1Amt_ > 0) {\n                // comparing debt here rather than reserves to simply code, impact won't be much overall\n                _verifyToken1Reserves(\n                    (d_.token0Debt - p_.token0AmtAdjusted),\n                    (d_.token1Debt - p_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // payback\n                temp_ = token1Amt_;\n                _depositOrPaybackInLiquidity(TOKEN_1, 0, temp_);\n            }\n\n            // extract user borrow amount\n            // userBorrow_ => temp_\n            temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) borrow limit\n            // newBorrowLimit_ => temp2_\n            temp2_ = DexCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, temp_);\n\n            temp_ -= shares_;\n\n            _updatingUserBorrowDataOnStorage(userBorrowData_, temp_, temp2_);\n            // updating total debt shares in storage\n            _updateBorrowShares(totalBorrowShares_);\n\n            emit LogPaybackDebtLiquidity(token0Amt_, token1Amt_, shares_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartDebtNotEnabled);\n        }\n    }\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) public payable _onlyDelegateCall returns (uint paybackAmt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userBorrowData_ = _userBorrowData[msg.sender];\n\n        if (userBorrowData_ & 1 == 0 && !estimate_) revert FluidDexError(ErrorTypes.DexT1__UserDebtInNotOn);\n\n        if ((maxToken0_ > 0 && maxToken1_ > 0) || (maxToken0_ == 0 && maxToken1_ == 0)) {\n            // only 1 token should be > 0\n            revert FluidDexError(ErrorTypes.DexT1__InvalidWithdrawAmts);\n        }\n\n        // is smart debt pool enabled\n        if (((dexVariables2_ >> 1) & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            uint totalBorrowShares_ = _totalBorrowShares & X128;\n\n            _verifyRedeem(shares_, totalBorrowShares_);\n\n            uint token0Amt_;\n            uint token1Amt_;\n\n            // smart debt in enabled\n            DebtReserves memory d_ = _getDebtReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.borrowToken0ExchangePrice,\n                pex_.borrowToken1ExchangePrice\n            );\n\n            if ((d_.token0Debt == 0) || (d_.token1Debt == 0)) {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidDebtReserves);\n            }\n\n            // Removing debt liquidity in equal proportion\n            DebtReserves memory d2_ = _getUpdateDebtReserves(shares_, totalBorrowShares_, d_, false);\n\n            if (maxToken0_ > 0) {\n                // entire payback is in token0_\n                token0Amt_ = _getSwapAndPaybackOneTokenPerfectShares(\n                    d2_.token0ImaginaryReserves,\n                    d2_.token1ImaginaryReserves,\n                    d_.token0Debt,\n                    d_.token1Debt,\n                    d2_.token0RealReserves,\n                    d2_.token1RealReserves\n                );\n                _verifyToken0Reserves(\n                    (d_.token0Debt - token0Amt_),\n                    d_.token1Debt,\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n\n                // converting from raw/adjusted to normal token amounts\n                token0Amt_ = (((token0Amt_ + 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) + 1;\n\n                // adding fee on paying back in 1 token\n                token0Amt_ = (token0Amt_ * (SIX_DECIMALS + ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n\n                paybackAmt_ = token0Amt_;\n                if (estimate_) revert FluidDexSingleTokenOutput(paybackAmt_);\n                if (paybackAmt_ > maxToken0_) revert FluidDexError(ErrorTypes.DexT1__PaybackAmtTooHigh);\n                _depositOrPaybackInLiquidity(TOKEN_0, 0, paybackAmt_);\n            } else {\n                // entire payback is in token1_\n                token1Amt_ = _getSwapAndPaybackOneTokenPerfectShares(\n                    d2_.token1ImaginaryReserves,\n                    d2_.token0ImaginaryReserves,\n                    d_.token1Debt,\n                    d_.token0Debt,\n                    d2_.token1RealReserves,\n                    d2_.token0RealReserves\n                );\n                _verifyToken1Reserves(\n                    d_.token0Debt,\n                    (d_.token1Debt - token1Amt_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n\n                // converting from raw/adjusted to normal token amounts\n                token1Amt_ = (((token1Amt_ + 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) + 1;\n\n                // adding fee on paying back in 1 token\n                token1Amt_ = (token1Amt_ * (SIX_DECIMALS + ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n\n                paybackAmt_ = token1Amt_;\n                if (estimate_) revert FluidDexSingleTokenOutput(paybackAmt_);\n                if (paybackAmt_ > maxToken1_) revert FluidDexError(ErrorTypes.DexT1__PaybackAmtTooHigh);\n                _depositOrPaybackInLiquidity(TOKEN_1, 0, paybackAmt_);\n            }\n\n            // extract user borrow amount\n            uint256 userBorrow_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n            userBorrow_ = (userBorrow_ >> DEFAULT_EXPONENT_SIZE) << (userBorrow_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) borrow limit\n            // temp_ => newBorrowLimit_\n            uint256 temp_ = DexCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, userBorrow_);\n            userBorrow_ -= shares_;\n\n            _updatingUserBorrowDataOnStorage(userBorrowData_, userBorrow_, temp_);\n\n            totalBorrowShares_ = totalBorrowShares_ - shares_;\n            _updateBorrowShares(totalBorrowShares_);\n\n            // to avoid stack-too-deep error\n            temp_ = shares_;\n            emit LogPaybackDebtInOneToken(temp_, token0Amt_, token1Amt_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartDebtNotEnabled);\n        }\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/core/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { CoreHelpers } from \"../helpers/coreHelpers.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { IFluidDexT1 } from \"../../../interfaces/iDexT1.sol\";\n\ninterface IDexCallback {\n    function dexCallback(address token_, uint256 amount_) external;\n}\n\n/// @title FluidDexT1\n/// @notice Implements core logics for Fluid Dex protocol.\n/// Note Token transfers happen directly from user to Liquidity contract and vice-versa.\ncontract FluidDexT1 is CoreHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) CoreHelpers(constantViews_) {\n        // any implementations should not be zero\n        if (\n            constantViews_.implementations.shift == address(0) ||\n            constantViews_.implementations.admin == address(0) ||\n            constantViews_.implementations.colOperations == address(0) ||\n            constantViews_.implementations.debtOperations == address(0) ||\n            constantViews_.implementations.perfectOperationsAndSwapOut == address(0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__InvalidImplementation);\n        }\n    }\n\n    struct SwapInExtras {\n        address to;\n        uint amountOutMin;\n        bool isCallback;\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param extras_ Additional parameters for the swap:\n    ///   - to: Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    ///   - amountOutMin: The minimum amount of output tokens the user expects to receive\n    ///   - isCallback: If true, indicates that the input tokens should be transferred via a callback\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function _swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        SwapInExtras memory extras_\n    ) internal returns (uint256 amountOut_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        if ((dexVariables2_ >> 255) == 1) revert FluidDexError(ErrorTypes.DexT1__SwapAndArbitragePaused);\n\n        _check(dexVariables_, dexVariables2_);\n\n        if (extras_.to == address(0)) extras_.to = msg.sender;\n\n        SwapInMemory memory s_;\n\n        if (swap0to1_) {\n            (s_.tokenIn, s_.tokenOut) = (TOKEN_0, TOKEN_1);\n            unchecked {\n                s_.amtInAdjusted = (amountIn_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION;\n            }\n        } else {\n            (s_.tokenIn, s_.tokenOut) = (TOKEN_1, TOKEN_0);\n            unchecked {\n                s_.amtInAdjusted = (amountIn_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION;\n            }\n        }\n\n        _verifySwapAndNonPerfectActions(s_.amtInAdjusted, amountIn_);\n\n        PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n        if (msg.value > 0) {\n            if (msg.value != amountIn_) revert FluidDexError(ErrorTypes.DexT1__EthAndAmountInMisMatch);\n            if (s_.tokenIn != NATIVE_TOKEN) revert FluidDexError(ErrorTypes.DexT1__EthSentForNonNativeSwap);\n        }\n\n        // is smart collateral pool enabled\n        uint temp_ = dexVariables2_ & 1;\n        // is smart debt pool enabled\n        uint temp2_ = (dexVariables2_ >> 1) & 1;\n\n        uint temp3_;\n        uint temp4_;\n\n        // extracting fee\n        temp3_ = ((dexVariables2_ >> 2) & X17);\n        unchecked {\n            // revenueCut in 6 decimals, to have proper precision\n            // if fee = 1% and revenue cut = 10% then revenueCut = 1e8 - (10000 * 10) = 99900000\n            s_.revenueCut = EIGHT_DECIMALS - ((((dexVariables2_ >> 19) & X7) * temp3_));\n            // fee in 4 decimals\n            // 1 - fee. If fee is 1% then withoutFee will be 1e6 - 1e4\n            // s_.fee => 1 - withdraw fee\n            s_.fee = SIX_DECIMALS - temp3_;\n        }\n\n        CollateralReservesSwap memory cs_;\n        DebtReservesSwap memory ds_;\n        if (temp_ == 1) {\n            // smart collateral is enabled\n            {\n                CollateralReserves memory c_ = _getCollateralReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.supplyToken0ExchangePrice,\n                    pex_.supplyToken1ExchangePrice\n                );\n                if (swap0to1_) {\n                    (\n                        cs_.tokenInRealReserves,\n                        cs_.tokenOutRealReserves,\n                        cs_.tokenInImaginaryReserves,\n                        cs_.tokenOutImaginaryReserves\n                    ) = (\n                        c_.token0RealReserves,\n                        c_.token1RealReserves,\n                        c_.token0ImaginaryReserves,\n                        c_.token1ImaginaryReserves\n                    );\n                } else {\n                    (\n                        cs_.tokenInRealReserves,\n                        cs_.tokenOutRealReserves,\n                        cs_.tokenInImaginaryReserves,\n                        cs_.tokenOutImaginaryReserves\n                    ) = (\n                        c_.token1RealReserves,\n                        c_.token0RealReserves,\n                        c_.token1ImaginaryReserves,\n                        c_.token0ImaginaryReserves\n                    );\n                }\n            }\n        }\n\n        if (temp2_ == 1) {\n            // smart debt is enabled\n            {\n                DebtReserves memory d_ = _getDebtReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.borrowToken0ExchangePrice,\n                    pex_.borrowToken1ExchangePrice\n                );\n                if (swap0to1_) {\n                    (\n                        ds_.tokenInDebt,\n                        ds_.tokenOutDebt,\n                        ds_.tokenInRealReserves,\n                        ds_.tokenOutRealReserves,\n                        ds_.tokenInImaginaryReserves,\n                        ds_.tokenOutImaginaryReserves\n                    ) = (\n                        d_.token0Debt,\n                        d_.token1Debt,\n                        d_.token0RealReserves,\n                        d_.token1RealReserves,\n                        d_.token0ImaginaryReserves,\n                        d_.token1ImaginaryReserves\n                    );\n                } else {\n                    (\n                        ds_.tokenInDebt,\n                        ds_.tokenOutDebt,\n                        ds_.tokenInRealReserves,\n                        ds_.tokenOutRealReserves,\n                        ds_.tokenInImaginaryReserves,\n                        ds_.tokenOutImaginaryReserves\n                    ) = (\n                        d_.token1Debt,\n                        d_.token0Debt,\n                        d_.token1RealReserves,\n                        d_.token0RealReserves,\n                        d_.token1ImaginaryReserves,\n                        d_.token0ImaginaryReserves\n                    );\n                }\n            }\n        }\n\n        // limiting amtInAdjusted to be not more than 50% of both (collateral & debt) imaginary tokenIn reserves combined\n        // basically, if this throws that means user is trying to swap 0.5x tokenIn if current tokenIn imaginary reserves is x\n        // let's take x as token0 here, that means, initially the pool pricing might be:\n        // token1Reserve / x and new pool pricing will become token1Reserve / 1.5x (token1Reserve will decrease after swap but for simplicity ignoring that)\n        // So pool price is decreased by ~33.33% (oracle will throw error in this case as it only allows 5% price difference but better to limit it before hand)\n        unchecked {\n            if (s_.amtInAdjusted > ((cs_.tokenInImaginaryReserves + ds_.tokenInImaginaryReserves) / 2))\n                revert FluidDexError(ErrorTypes.DexT1__SwapInLimitingAmounts);\n        }\n\n        if (temp_ == 1 && temp2_ == 1) {\n            // unless both pools are enabled s_.swapRoutingAmt will be 0\n            s_.swapRoutingAmt = _swapRoutingIn(\n                s_.amtInAdjusted,\n                cs_.tokenOutImaginaryReserves,\n                cs_.tokenInImaginaryReserves,\n                ds_.tokenOutImaginaryReserves,\n                ds_.tokenInImaginaryReserves\n            );\n        }\n\n        // In below if else statement temps are:\n        // temp_ => deposit amt\n        // temp2_ => withdraw amt\n        // temp3_ => payback amt\n        // temp4_ => borrow amt\n        if (int(s_.amtInAdjusted) > s_.swapRoutingAmt && s_.swapRoutingAmt > 0) {\n            // swap will route from the both pools\n            // temp_ = amountInCol_\n            temp_ = uint(s_.swapRoutingAmt);\n            unchecked {\n                // temp3_ = amountInDebt_\n                temp3_ = s_.amtInAdjusted - temp_;\n            }\n\n            (temp2_, temp4_) = (0, 0);\n\n            // debt pool price will be the same as collateral pool after the swap\n            s_.withdrawTo = extras_.to;\n            s_.borrowTo = extras_.to;\n        } else if ((temp_ == 1 && temp2_ == 0) || (s_.swapRoutingAmt >= int(s_.amtInAdjusted))) {\n            // entire swap will route through collateral pool\n            (temp_, temp2_, temp3_, temp4_) = (s_.amtInAdjusted, 0, 0, 0);\n            // price can slightly differ from debt pool but difference will be very small. Probably <0.01% for active DEX pools.\n            s_.withdrawTo = extras_.to;\n        } else if ((temp_ == 0 && temp2_ == 1) || (s_.swapRoutingAmt <= 0)) {\n            // entire swap will route through debt pool\n            (temp_, temp2_, temp3_, temp4_) = (0, 0, s_.amtInAdjusted, 0);\n            // price can slightly differ from collateral pool but difference will be very small. Probably <0.01% for active DEX pools.\n            s_.borrowTo = extras_.to;\n        } else {\n            // swap should never reach this point but if it does then reverting\n            revert FluidDexError(ErrorTypes.DexT1__NoSwapRoute);\n        }\n\n        if (temp_ > 0) {\n            // temp2_ = amountOutCol_\n            temp2_ = _getAmountOut(\n                ((temp_ * s_.fee) / SIX_DECIMALS),\n                cs_.tokenInImaginaryReserves,\n                cs_.tokenOutImaginaryReserves\n            );\n            swap0to1_\n                ? _verifyToken1Reserves(\n                    (cs_.tokenInRealReserves + temp_),\n                    (cs_.tokenOutRealReserves - temp2_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                )\n                : _verifyToken0Reserves(\n                    (cs_.tokenOutRealReserves - temp2_),\n                    (cs_.tokenInRealReserves + temp_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                );\n        }\n        if (temp3_ > 0) {\n            // temp4_ = amountOutDebt_\n            temp4_ = _getAmountOut(\n                ((temp3_ * s_.fee) / SIX_DECIMALS),\n                ds_.tokenInImaginaryReserves,\n                ds_.tokenOutImaginaryReserves\n            );\n            swap0to1_\n                ? _verifyToken1Reserves(\n                    (ds_.tokenInRealReserves + temp3_),\n                    (ds_.tokenOutRealReserves - temp4_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                )\n                : _verifyToken0Reserves(\n                    (ds_.tokenOutRealReserves - temp4_),\n                    (ds_.tokenInRealReserves + temp3_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                );\n        }\n\n        // (temp_ + temp3_) == amountIn_ == msg.value (for native token), if there is revenue cut then this statement is not true\n        temp_ = (temp_ * s_.revenueCut) / EIGHT_DECIMALS;\n        temp3_ = (temp3_ * s_.revenueCut) / EIGHT_DECIMALS;\n\n        // from whatever pool higher amount of swap is routing we are taking that as final price, does not matter much because both pools final price should be same\n        if (temp_ > temp3_) {\n            // new pool price from col pool\n            s_.price = swap0to1_\n                ? ((cs_.tokenOutImaginaryReserves - temp2_) * 1e27) / (cs_.tokenInImaginaryReserves + temp_)\n                : ((cs_.tokenInImaginaryReserves + temp_) * 1e27) / (cs_.tokenOutImaginaryReserves - temp2_);\n        } else {\n            // new pool price from debt pool\n            s_.price = swap0to1_\n                ? ((ds_.tokenOutImaginaryReserves - temp4_) * 1e27) / (ds_.tokenInImaginaryReserves + temp3_)\n                : ((ds_.tokenInImaginaryReserves + temp3_) * 1e27) / (ds_.tokenOutImaginaryReserves - temp4_);\n        }\n\n        // converting into normal token amounts\n        if (swap0to1_) {\n            temp_ = ((temp_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\n            temp3_ = ((temp3_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\n            // only adding uncheck in out amount\n            unchecked {\n                temp2_ = ((temp2_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n                temp4_ = ((temp4_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n            }\n        } else {\n            temp_ = ((temp_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n            temp3_ = ((temp3_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n            // only adding uncheck in out amount\n            unchecked {\n                temp2_ = ((temp2_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\n                temp4_ = ((temp4_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\n            }\n        }\n\n        unchecked {\n            amountOut_ = temp2_ + temp4_;\n        }\n\n        // if address dead then reverting with amountOut\n        if (extras_.to == ADDRESS_DEAD) revert FluidDexSwapResult(amountOut_);\n\n        if (amountOut_ < extras_.amountOutMin) revert FluidDexError(ErrorTypes.DexT1__NotEnoughAmountOut);\n\n        // allocating to avoid stack-too-deep error\n        // not setting in the callbackData as last 2nd to avoid SKIP_TRANSFERS clashing\n        s_.data = abi.encode(amountIn_, extras_.isCallback, msg.sender); // true/false is to decide if dex should do callback or directly transfer from user\n        // deposit & payback token in at liquidity\n        LIQUIDITY.operate{ value: msg.value }(s_.tokenIn, int(temp_), -int(temp3_), address(0), address(0), s_.data);\n        // withdraw & borrow token out at liquidity\n        LIQUIDITY.operate(s_.tokenOut, -int(temp2_), int(temp4_), s_.withdrawTo, s_.borrowTo, new bytes(0));\n\n        // if hook exists then calling hook\n        temp_ = (dexVariables2_ >> 142) & X30;\n        if (temp_ > 0) {\n            s_.swap0to1 = swap0to1_;\n            _hookVerify(temp_, 1, s_.swap0to1, s_.price);\n        }\n\n        swap0to1_\n            ? _utilizationVerify(((dexVariables2_ >> 238) & X10), EXCHANGE_PRICE_TOKEN_1_SLOT)\n            : _utilizationVerify(((dexVariables2_ >> 228) & X10), EXCHANGE_PRICE_TOKEN_0_SLOT);\n\n        dexVariables = _updateOracle(s_.price, pex_.centerPrice, dexVariables_);\n\n        emit Swap(swap0to1_, amountIn_, amountOut_, extras_.to);\n    }\n\n    /// @dev Swap tokens with perfect amount in\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of tokens to swap in\n    /// @param amountOutMin_ The minimum amount of tokens to receive after swap\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) public payable returns (uint256 amountOut_) {\n        return _swapIn(swap0to1_, amountIn_, SwapInExtras(to_, amountOutMin_, false));\n    }\n\n    /// @dev Swap tokens with perfect amount in and callback functionality\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of tokens to swap in\n    /// @param amountOutMin_ The minimum amount of tokens to receive after swap\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapInWithCallback(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) public payable returns (uint256 amountOut_) {\n        return _swapIn(swap0to1_, amountIn_, SwapInExtras(to_, amountOutMin_, true));\n    }\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) public payable returns (uint256 amountIn_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev Swap tokens with perfect amount out and callback functionality\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOutWithCallback(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) public payable returns (uint256 amountIn_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) public payable returns (uint token0Amt_, uint token1Amt_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256, uint256));\n    }\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of withdrawn tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) public returns (uint token0Amt_, uint token1Amt_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256, uint256));\n    }\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of borrowed tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) public returns (uint token0Amt_, uint token1Amt_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256, uint256));\n    }\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) public payable returns (uint token0Amt_, uint token1Amt_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256, uint256));\n    }\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) public payable returns (uint shares_) {\n        return abi.decode(_spell(COL_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of withdrawn tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) public returns (uint shares_) {\n        return abi.decode(_spell(COL_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of borrowed tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) public returns (uint shares_) {\n        return abi.decode(_spell(DEBT_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) public payable returns (uint shares_) {\n        return abi.decode(_spell(DEBT_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of withdrawn tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) public returns (uint withdrawAmt_) {\n        return abi.decode(_spell(COL_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) public payable returns (uint paybackAmt_) {\n        return abi.decode(_spell(DEBT_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev liquidity callback for cheaper token transfers in case of deposit or payback.\n    /// only callable by Liquidity during an operation.\n    function liquidityCallback(address token_, uint amount_, bytes calldata data_) external {\n        if (msg.sender != address(LIQUIDITY)) revert FluidDexError(ErrorTypes.DexT1__MsgSenderNotLiquidity);\n        if (dexVariables & 1 == 0) revert FluidDexError(ErrorTypes.DexT1__ReentrancyBitShouldBeOn);\n        if (data_.length != 96) revert FluidDexError(ErrorTypes.DexT1__IncorrectDataLength);\n\n        (uint amountToSend_, bool isCallback_, address from_) = abi.decode(data_, (uint, bool, address));\n\n        if (amountToSend_ < amount_) revert FluidDexError(ErrorTypes.DexT1__AmountToSendLessThanAmount);\n\n        if (isCallback_) {\n            IDexCallback(from_).dexCallback(token_, amountToSend_);\n        } else {\n            SafeTransfer.safeTransferFrom(token_, from_, address(LIQUIDITY), amountToSend_);\n        }\n    }\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(\n        uint[] memory secondsAgos_\n    ) external view returns (Oracle[] memory twaps_, uint currentPrice_) {\n        OraclePriceMemory memory o_;\n\n        uint dexVariables_ = dexVariables;\n\n        if ((dexVariables_ >> 195) & 1 == 0) {\n            revert FluidDexError(ErrorTypes.DexT1__OracleNotActive);\n        }\n\n        twaps_ = new Oracle[](secondsAgos_.length);\n\n        uint totalTime_;\n        uint time_;\n\n        uint i;\n        uint secondsAgo_ = secondsAgos_[0];\n\n        currentPrice_ = (dexVariables_ >> 41) & X40;\n        currentPrice_ = (currentPrice_ >> DEFAULT_EXPONENT_SIZE) << (currentPrice_ & DEFAULT_EXPONENT_MASK);\n        uint price_ = currentPrice_;\n        o_.lowestPrice1by0 = currentPrice_;\n        o_.highestPrice1by0 = currentPrice_;\n\n        uint twap1by0_;\n        uint twap0by1_;\n\n        uint j;\n\n        o_.oracleSlot = (dexVariables_ >> 176) & X3;\n        o_.oracleMap = (dexVariables_ >> 179) & X16;\n        // if o_.oracleSlot == 7 then it'll enter the if statement in the below while loop\n        o_.oracle = o_.oracleSlot < 7 ? _oracle[o_.oracleMap] : 0;\n\n        uint slotData_;\n        uint percentDiff_;\n\n        if (((dexVariables_ >> 121) & X33) < block.timestamp) {\n            // last swap didn't occured in this block.\n            // hence last price is current price of pool & also the last price\n            time_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n        } else {\n            // last swap occured in this block, that means current price is active for 0 secs. Hence TWAP for it will be 0.\n            ++j;\n        }\n\n        while (true) {\n            if (j == 2) {\n                if (++o_.oracleSlot == 8) {\n                    o_.oracleSlot = 0;\n                    if (o_.oracleMap == 0) {\n                        o_.oracleMap = TOTAL_ORACLE_MAPPING;\n                    }\n                    o_.oracle = _oracle[--o_.oracleMap];\n                }\n\n                slotData_ = (o_.oracle >> (o_.oracleSlot * 32)) & X32;\n                if (slotData_ > 0) {\n                    time_ = slotData_ & X9;\n                    if (time_ == 0) {\n                        // time is in precision & sign bits\n                        time_ = slotData_ >> 9;\n                        // if o_.oracleSlot is 7 then precision & bits and stored in 1 less map\n                        if (o_.oracleSlot == 7) {\n                            o_.oracleSlot = 0;\n                            if (o_.oracleMap == 0) {\n                                o_.oracleMap = TOTAL_ORACLE_MAPPING;\n                            }\n                            o_.oracle = _oracle[--o_.oracleMap];\n                            slotData_ = o_.oracle & X32;\n                        } else {\n                            ++o_.oracleSlot;\n                            slotData_ = (o_.oracle >> (o_.oracleSlot * 32)) & X32;\n                        }\n                    }\n                    percentDiff_ = slotData_ >> 10;\n                    percentDiff_ = (ORACLE_LIMIT * percentDiff_) / X22;\n                    if (((slotData_ >> 9) & 1 == 1)) {\n                        // if positive then old price was lower than current hence subtracting\n                        price_ = price_ - (price_ * percentDiff_) / ORACLE_PRECISION;\n                    } else {\n                        // if negative then old price was higher than current hence adding\n                        price_ = price_ + (price_ * percentDiff_) / ORACLE_PRECISION;\n                    }\n                } else {\n                    // oracle data does not exist. Probably due to pool recently got initialized and not have much swaps.\n                    revert FluidDexError(ErrorTypes.DexT1__InsufficientOracleData);\n                }\n            } else if (j == 1) {\n                // last & last to last price\n                price_ = (dexVariables_ >> 1) & X40;\n                price_ = (price_ >> DEFAULT_EXPONENT_SIZE) << (price_ & DEFAULT_EXPONENT_MASK);\n                time_ = (dexVariables_ >> 154) & X22;\n                ++j;\n            } else if (j == 0) {\n                ++j;\n            }\n\n            totalTime_ += time_;\n            if (o_.lowestPrice1by0 > price_) o_.lowestPrice1by0 = price_;\n            if (o_.highestPrice1by0 < price_) o_.highestPrice1by0 = price_;\n            if (totalTime_ < secondsAgo_) {\n                twap1by0_ += price_ * time_;\n                twap0by1_ += (1e54 / price_) * time_;\n            } else {\n                time_ = time_ + secondsAgo_ - totalTime_;\n                twap1by0_ += price_ * time_;\n                twap0by1_ += (1e54 / price_) * time_;\n                // also auto checks that secondsAgos_ should not be == 0\n                twap1by0_ = twap1by0_ / secondsAgo_;\n                twap0by1_ = twap0by1_ / secondsAgo_;\n\n                twaps_[i] = Oracle(\n                    twap1by0_,\n                    o_.lowestPrice1by0,\n                    o_.highestPrice1by0,\n                    twap0by1_,\n                    (1e54 / o_.highestPrice1by0),\n                    (1e54 / o_.lowestPrice1by0)\n                );\n\n                // TWAP for next secondsAgo will start with price_\n                o_.lowestPrice1by0 = price_;\n                o_.highestPrice1by0 = price_;\n\n                while (++i < secondsAgos_.length) {\n                    // secondsAgo_ = [60, 15, 0]\n                    time_ = totalTime_ - secondsAgo_;\n                    // updating total time as new seconds ago started\n                    totalTime_ = time_;\n                    // also auto checks that secondsAgos_[i + 1] > secondsAgos_[i]\n                    secondsAgo_ = secondsAgos_[i] - secondsAgos_[i - 1];\n                    if (totalTime_ < secondsAgo_) {\n                        twap1by0_ = price_ * time_;\n                        twap0by1_ = (1e54 / price_) * time_;\n                        // if time_ comes out as 0 here then lowestPrice & highestPrice should not be price_, it should be next price_ that we will calculate\n                        if (time_ == 0) {\n                            o_.lowestPrice1by0 = type(uint).max;\n                            o_.highestPrice1by0 = 0;\n                        }\n                        break;\n                    } else {\n                        time_ = time_ + secondsAgo_ - totalTime_;\n                        // twap1by0_ = price_ here\n                        twap1by0_ = price_ * time_;\n                        // twap0by1_ = (1e54 / price_) * time_;\n                        twap0by1_ = (1e54 / price_) * time_;\n                        twap1by0_ = twap1by0_ / secondsAgo_;\n                        twap0by1_ = twap0by1_ / secondsAgo_;\n                        twaps_[i] = Oracle(\n                            twap1by0_,\n                            o_.lowestPrice1by0,\n                            o_.highestPrice1by0,\n                            twap0by1_,\n                            (1e54 / o_.highestPrice1by0),\n                            (1e54 / o_.lowestPrice1by0)\n                        );\n                    }\n                }\n                if (i == secondsAgos_.length) return (twaps_, currentPrice_); // oracle fetch over\n            }\n        }\n    }\n\n    function getPricesAndExchangePrices() public {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables, dexVariables2);\n\n        revert FluidDexPricesAndExchangeRates(pex_);\n    }\n\n    /// @dev Internal fallback function to handle calls to non-existent functions\n    /// @notice This function is called when a transaction is sent to the contract without matching any other function\n    /// @notice It checks if the caller is authorized, enables re-entrancy protection, delegates the call to the admin implementation, and then disables re-entrancy protection\n    /// @notice Only authorized callers (global or dex auth) can trigger this function\n    /// @notice This function uses assembly to perform a delegatecall to the admin implementation to update configs related to DEX\n    function _fallback() private {\n        if (!(DEX_FACTORY.isGlobalAuth(msg.sender) || DEX_FACTORY.isDexAuth(address(this), msg.sender))) {\n            revert FluidDexError(ErrorTypes.DexT1__NotAnAuth);\n        }\n\n        uint dexVariables_ = dexVariables;\n        if (dexVariables_ & 1 == 1) revert FluidDexError(ErrorTypes.DexT1__AlreadyEntered);\n        // enabling re-entrancy\n        dexVariables = dexVariables_ | 1;\n\n        // Delegate the current call to `ADMIN_IMPLEMENTATION`.\n        _spell(ADMIN_IMPLEMENTATION, msg.data);\n\n        // disabling re-entrancy\n        // directly fetching from storage so updates from Admin module will get auto covered\n        dexVariables = dexVariables & ~uint(1);\n    }\n\n    fallback() external payable {\n        _fallback();\n    }\n\n    receive() external payable {\n        if (msg.sig != 0x00000000) {\n            _fallback();\n        }\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_) {\n        constantsView_.dexId = DEX_ID;\n        constantsView_.liquidity = address(LIQUIDITY);\n        constantsView_.factory = address(DEX_FACTORY);\n        constantsView_.token0 = TOKEN_0;\n        constantsView_.token1 = TOKEN_1;\n        constantsView_.implementations.shift = SHIFT_IMPLEMENTATION;\n        constantsView_.implementations.admin = ADMIN_IMPLEMENTATION;\n        constantsView_.implementations.colOperations = COL_OPERATIONS_IMPLEMENTATION;\n        constantsView_.implementations.debtOperations = DEBT_OPERATIONS_IMPLEMENTATION;\n        constantsView_.implementations.perfectOperationsAndSwapOut = PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION;\n        constantsView_.deployerContract = DEPLOYER_CONTRACT;\n        constantsView_.supplyToken0Slot = SUPPLY_TOKEN_0_SLOT;\n        constantsView_.borrowToken0Slot = BORROW_TOKEN_0_SLOT;\n        constantsView_.supplyToken1Slot = SUPPLY_TOKEN_1_SLOT;\n        constantsView_.borrowToken1Slot = BORROW_TOKEN_1_SLOT;\n        constantsView_.exchangePriceToken0Slot = EXCHANGE_PRICE_TOKEN_0_SLOT;\n        constantsView_.exchangePriceToken1Slot = EXCHANGE_PRICE_TOKEN_1_SLOT;\n        constantsView_.oracleMapping = TOTAL_ORACLE_MAPPING;\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_) {\n        constantsView2_.token0NumeratorPrecision = TOKEN_0_NUMERATOR_PRECISION;\n        constantsView2_.token0DenominatorPrecision = TOKEN_0_DENOMINATOR_PRECISION;\n        constantsView2_.token1NumeratorPrecision = TOKEN_1_NUMERATOR_PRECISION;\n        constantsView2_.token1DenominatorPrecision = TOKEN_1_DENOMINATOR_PRECISION;\n    }\n\n    /// @notice Calculates the real and imaginary reserves for collateral tokens\n    /// @dev This function retrieves the supply of both tokens from the liquidity layer,\n    ///      adjusts them based on exchange prices, and calculates imaginary reserves\n    ///      based on the geometric mean and price range\n    /// @param geometricMean_ The geometric mean of the token prices\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0SupplyExchangePrice_ The exchange price for token0 from liquidity layer\n    /// @param token1SupplyExchangePrice_ The exchange price for token1 from liquidity layer\n    /// @return c_ A struct containing the calculated real and imaginary reserves for both tokens:\n    ///         - token0RealReserves: The real reserves of token0\n    ///         - token1RealReserves: The real reserves of token1\n    ///         - token0ImaginaryReserves: The imaginary reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary reserves of token1\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) public view returns (CollateralReserves memory c_) {\n        return\n            _getCollateralReserves(\n                geometricMean_,\n                upperRange_,\n                lowerRange_,\n                token0SupplyExchangePrice_,\n                token1SupplyExchangePrice_\n            );\n    }\n\n    /// @notice Calculates the debt reserves for both tokens\n    /// @param geometricMean_ The geometric mean of the upper and lower price ranges\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0BorrowExchangePrice_ The exchange price of token0 from liquidity layer\n    /// @param token1BorrowExchangePrice_ The exchange price of token1 from liquidity layer\n    /// @return d_ The calculated debt reserves for both tokens, containing:\n    ///         - token0Debt: The debt amount of token0\n    ///         - token1Debt: The debt amount of token1\n    ///         - token0RealReserves: The real reserves of token0 derived from token1 debt\n    ///         - token1RealReserves: The real reserves of token1 derived from token0 debt\n    ///         - token0ImaginaryReserves: The imaginary debt reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary debt reserves of token1\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) public view returns (DebtReserves memory d_) {\n        return\n            _getDebtReserves(\n                geometricMean_,\n                upperRange_,\n                lowerRange_,\n                token0BorrowExchangePrice_,\n                token1BorrowExchangePrice_\n            );\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/core/perfectOperationsAndSwapOut.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { UserHelpers } from \"../helpers/userHelpers.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @title FluidDexT1\n/// @notice Implements core logics for Fluid Dex protocol.\n/// Note Token transfers happen directly from user to Liquidity contract and vice-versa.\ncontract FluidDexT1PerfectOperationsAndSwapOut is UserHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) UserHelpers(constantViews_) {\n        // all implementations should be zero other than shift\n        if (\n            constantViews_.implementations.shift == address(0) ||\n            constantViews_.implementations.admin != address(0) ||\n            constantViews_.implementations.colOperations != address(0) ||\n            constantViews_.implementations.debtOperations != address(0) ||\n            constantViews_.implementations.perfectOperationsAndSwapOut != address(0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__InvalidImplementation);\n        }\n    }\n\n    modifier _onlyDelegateCall() {\n        // also indirectly checked by `_check` because pool can never be initialized as long as the initialize method\n        // is delegate call only, but just to be sure on Admin logic we add the modifier everywhere nonetheless.\n        if (address(this) == THIS_CONTRACT) {\n            revert FluidDexError(ErrorTypes.DexT1__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    struct SwapOutExtras {\n        address to;\n        uint amountInMax;\n        bool isCallback;\n    }\n\n    /// @dev Swap tokens with perfect amount out. If NATIVE_TOKEN is sent then msg.value should be passed as amountInMax, amountInMax - amountIn of ETH are sent back to msg.sender\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param extras_ Additional parameters for the swap:\n    ///   - to_: Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    ///   - amountInMax: The maximum amount of input tokens the user is willing to swap\n    ///   - isCallback: If true, indicates that the output tokens should be transferred via a callback\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function _swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        SwapOutExtras memory extras_\n    ) internal _onlyDelegateCall returns (uint256 amountIn_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        if ((dexVariables2_ >> 255) == 1) revert FluidDexError(ErrorTypes.DexT1__SwapAndArbitragePaused);\n\n        _check(dexVariables_, dexVariables2_);\n\n        if (extras_.to == address(0)) extras_.to = msg.sender;\n\n        SwapOutMemory memory s_;\n\n        if (swap0to1_) {\n            (s_.tokenIn, s_.tokenOut) = (TOKEN_0, TOKEN_1);\n            unchecked {\n                s_.amtOutAdjusted = (amountOut_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION;\n            }\n        } else {\n            (s_.tokenIn, s_.tokenOut) = (TOKEN_1, TOKEN_0);\n            unchecked {\n                s_.amtOutAdjusted = (amountOut_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION;\n            }\n        }\n\n        _verifySwapAndNonPerfectActions(s_.amtOutAdjusted, amountOut_);\n\n        PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n        if ((msg.value > 0) || ((s_.tokenIn == NATIVE_TOKEN) && (msg.value == 0))) {\n            if (msg.value != extras_.amountInMax) revert FluidDexError(ErrorTypes.DexT1__EthAndAmountInMisMatch);\n            if (s_.tokenIn != NATIVE_TOKEN) revert FluidDexError(ErrorTypes.DexT1__EthSentForNonNativeSwap);\n        }\n\n        // is smart collateral pool enabled\n        uint temp_ = dexVariables2_ & 1;\n        // is smart debt pool enabled\n        uint temp2_ = (dexVariables2_ >> 1) & 1;\n        uint temp3_;\n        uint temp4_;\n\n        // extracting fee\n        temp3_ = ((dexVariables2_ >> 2) & X17);\n        unchecked {\n            // revenueCut in 6 decimals, to have proper precision\n            // if fee = 1% and revenue cut = 10% then revenueCut = 1e8 - (10000 * 10) = 99900000\n            s_.revenueCut = EIGHT_DECIMALS - ((((dexVariables2_ >> 19) & X7) * temp3_));\n            // fee in 4 decimals\n            // 1 - fee. If fee is 1% then withoutFee will be 1e6 - 1e4\n            // s_.fee => 1 - withdraw fee\n            s_.fee = SIX_DECIMALS - temp3_;\n        }\n\n        CollateralReservesSwap memory cs_;\n        DebtReservesSwap memory ds_;\n        if (temp_ == 1) {\n            // smart collateral is enabled\n            {\n                CollateralReserves memory c_ = _getCollateralReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.supplyToken0ExchangePrice,\n                    pex_.supplyToken1ExchangePrice\n                );\n                if (swap0to1_) {\n                    (\n                        cs_.tokenInRealReserves,\n                        cs_.tokenOutRealReserves,\n                        cs_.tokenInImaginaryReserves,\n                        cs_.tokenOutImaginaryReserves\n                    ) = (\n                        c_.token0RealReserves,\n                        c_.token1RealReserves,\n                        c_.token0ImaginaryReserves,\n                        c_.token1ImaginaryReserves\n                    );\n                } else {\n                    (\n                        cs_.tokenInRealReserves,\n                        cs_.tokenOutRealReserves,\n                        cs_.tokenInImaginaryReserves,\n                        cs_.tokenOutImaginaryReserves\n                    ) = (\n                        c_.token1RealReserves,\n                        c_.token0RealReserves,\n                        c_.token1ImaginaryReserves,\n                        c_.token0ImaginaryReserves\n                    );\n                }\n            }\n        }\n\n        if (temp2_ == 1) {\n            // smart debt is enabled\n            {\n                DebtReserves memory d_ = _getDebtReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.borrowToken0ExchangePrice,\n                    pex_.borrowToken1ExchangePrice\n                );\n                if (swap0to1_) {\n                    (\n                        ds_.tokenInDebt,\n                        ds_.tokenOutDebt,\n                        ds_.tokenInRealReserves,\n                        ds_.tokenOutRealReserves,\n                        ds_.tokenInImaginaryReserves,\n                        ds_.tokenOutImaginaryReserves\n                    ) = (\n                        d_.token0Debt,\n                        d_.token1Debt,\n                        d_.token0RealReserves,\n                        d_.token1RealReserves,\n                        d_.token0ImaginaryReserves,\n                        d_.token1ImaginaryReserves\n                    );\n                } else {\n                    (\n                        ds_.tokenInDebt,\n                        ds_.tokenOutDebt,\n                        ds_.tokenInRealReserves,\n                        ds_.tokenOutRealReserves,\n                        ds_.tokenInImaginaryReserves,\n                        ds_.tokenOutImaginaryReserves\n                    ) = (\n                        d_.token1Debt,\n                        d_.token0Debt,\n                        d_.token1RealReserves,\n                        d_.token0RealReserves,\n                        d_.token1ImaginaryReserves,\n                        d_.token0ImaginaryReserves\n                    );\n                }\n            }\n        }\n\n        // limiting amtOutAdjusted to be not more than 50% of both (collateral & debt) imaginary tokenOut reserves combined\n        // basically, if this throws that means user is trying to swap 0.5x tokenOut if current tokenOut imaginary reserves is x\n        // let's take x as token0 here, that means, initially the pool pricing might be:\n        // token1Reserve / x and new pool pricing will become token1Reserve / 0.5x (token1Reserve will decrease after swap but for simplicity ignoring that)\n        // So pool price is increased by ~50% (oracle will throw error in this case as it only allows 5% price difference but better to limit it before hand)\n        unchecked {\n            if (s_.amtOutAdjusted > ((cs_.tokenOutImaginaryReserves + ds_.tokenOutImaginaryReserves) / 2))\n                revert FluidDexError(ErrorTypes.DexT1__SwapOutLimitingAmounts);\n        }\n\n        if (temp_ == 1 && temp2_ == 1) {\n            // if both pools are not enabled then s_.swapRoutingAmt will be 0\n            s_.swapRoutingAmt = _swapRoutingOut(\n                s_.amtOutAdjusted,\n                cs_.tokenInImaginaryReserves,\n                cs_.tokenOutImaginaryReserves,\n                ds_.tokenInImaginaryReserves,\n                ds_.tokenOutImaginaryReserves\n            );\n        }\n\n        // In below if else statement temps are:\n        // temp_ => withdraw amt\n        // temp2_ => deposit amt\n        // temp3_ => borrow amt\n        // temp4_ => payback amt\n        if (int(s_.amtOutAdjusted) > s_.swapRoutingAmt && s_.swapRoutingAmt > 0) {\n            // swap will route from both pools\n            // temp_ = amountOutCol_\n            temp_ = uint(s_.swapRoutingAmt);\n            unchecked {\n                // temp3_ = amountOutDebt_\n                temp3_ = s_.amtOutAdjusted - temp_;\n            }\n\n            (temp2_, temp4_) = (0, 0);\n\n            // debt pool price will be the same as collateral pool after the swap\n            s_.withdrawTo = extras_.to;\n            s_.borrowTo = extras_.to;\n        } else if ((temp_ == 1 && temp2_ == 0) || (s_.swapRoutingAmt >= int(s_.amtOutAdjusted))) {\n            // entire swap will route through collateral pool\n            (temp_, temp2_, temp3_, temp4_) = (s_.amtOutAdjusted, 0, 0, 0);\n            // price can slightly differ from debt pool but difference will be very small. Probably <0.01% for active DEX pools.\n            s_.withdrawTo = extras_.to;\n        } else if ((temp_ == 0 && temp2_ == 1) || (s_.swapRoutingAmt <= 0)) {\n            // entire swap will route through debt pool\n            (temp_, temp2_, temp3_, temp4_) = (0, 0, s_.amtOutAdjusted, 0);\n            // price can slightly differ from collateral pool but difference will be very small. Probably <0.01% for active DEX pools.\n            s_.borrowTo = extras_.to;\n        } else {\n            // swap should never reach this point but if it does then reverting\n            revert FluidDexError(ErrorTypes.DexT1__NoSwapRoute);\n        }\n\n        if (temp_ > 0) {\n            // temp2_ = amountInCol_\n            temp2_ = _getAmountIn(temp_, cs_.tokenInImaginaryReserves, cs_.tokenOutImaginaryReserves);\n            temp2_ = (temp2_ * SIX_DECIMALS) / s_.fee;\n            swap0to1_\n                ? _verifyToken1Reserves(\n                    (cs_.tokenInRealReserves + temp2_),\n                    (cs_.tokenOutRealReserves - temp_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                )\n                : _verifyToken0Reserves(\n                    (cs_.tokenOutRealReserves - temp_),\n                    (cs_.tokenInRealReserves + temp2_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                );\n        }\n        if (temp3_ > 0) {\n            // temp4_ = amountInDebt_\n            temp4_ = _getAmountIn(temp3_, ds_.tokenInImaginaryReserves, ds_.tokenOutImaginaryReserves);\n            temp4_ = (temp4_ * SIX_DECIMALS) / s_.fee;\n            swap0to1_\n                ? _verifyToken1Reserves(\n                    (ds_.tokenInRealReserves + temp4_),\n                    (ds_.tokenOutRealReserves - temp3_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                )\n                : _verifyToken0Reserves(\n                    (ds_.tokenOutRealReserves - temp3_),\n                    (ds_.tokenInRealReserves + temp4_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                );\n        }\n\n        amountIn_ = temp2_ + temp4_;\n\n        // cutting revenue off of amount in.\n        temp2_ = (temp2_ * s_.revenueCut) / EIGHT_DECIMALS;\n        temp4_ = (temp4_ * s_.revenueCut) / EIGHT_DECIMALS;\n\n        // from whatever pool higher amount of swap is routing we are taking that as final price, does not matter much because both pools final price should be same\n        if (temp_ > temp3_) {\n            // new pool price from col pool\n            s_.price = swap0to1_\n                ? ((cs_.tokenOutImaginaryReserves - temp_) * 1e27) / (cs_.tokenInImaginaryReserves + temp2_)\n                : ((cs_.tokenInImaginaryReserves + temp2_) * 1e27) / (cs_.tokenOutImaginaryReserves - temp_);\n        } else {\n            // new pool price from debt pool\n            s_.price = swap0to1_\n                ? ((ds_.tokenOutImaginaryReserves - temp3_) * 1e27) / (ds_.tokenInImaginaryReserves + temp4_)\n                : ((ds_.tokenInImaginaryReserves + temp4_) * 1e27) / (ds_.tokenOutImaginaryReserves - temp3_);\n        }\n\n        // Converting into normal token amounts\n        if (swap0to1_) {\n            // only adding uncheck in out amount\n            unchecked {\n                temp_ = (temp_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION;\n                temp3_ = (temp3_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION;\n            }\n            temp2_ = (temp2_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION;\n            temp4_ = (temp4_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION;\n            amountIn_ = (amountIn_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION;\n        } else {\n            // only adding uncheck in out amount\n            unchecked {\n                temp_ = (temp_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION;\n                temp3_ = (temp3_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION;\n            }\n            temp2_ = (temp2_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION;\n            temp4_ = (temp4_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION;\n            amountIn_ = (amountIn_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION;\n        }\n\n        // If address dead then reverting with amountIn\n        if (extras_.to == ADDRESS_DEAD) revert FluidDexSwapResult(amountIn_);\n\n        if (amountIn_ > extras_.amountInMax) revert FluidDexError(ErrorTypes.DexT1__ExceedsAmountInMax);\n\n        // allocating to avoid stack-too-deep error\n        // not setting in the callbackData as last 2nd to avoid SKIP_TRANSFERS clashing\n        s_.data = abi.encode(amountIn_, extras_.isCallback, msg.sender); // true/false is to decide if dex should do callback or directly transfer from user\n        // if native token then pass msg.value as amountIn_ else 0\n        s_.msgValue = (s_.tokenIn == NATIVE_TOKEN) ? amountIn_ : 0;\n        // Deposit & payback token in at liquidity\n        LIQUIDITY.operate{ value: s_.msgValue }(s_.tokenIn, int(temp2_), -int(temp4_), address(0), address(0), s_.data);\n        // Withdraw & borrow token out at liquidity\n        LIQUIDITY.operate(s_.tokenOut, -int(temp_), int(temp3_), s_.withdrawTo, s_.borrowTo, new bytes(0));\n\n        // If hook exists then calling hook\n        temp_ = (dexVariables2_ >> 142) & X30;\n        if (temp_ > 0) {\n            s_.swap0to1 = swap0to1_;\n            _hookVerify(temp_, 1, s_.swap0to1, s_.price);\n        }\n\n        swap0to1_\n            ? _utilizationVerify(((dexVariables2_ >> 238) & X10), EXCHANGE_PRICE_TOKEN_1_SLOT)\n            : _utilizationVerify(((dexVariables2_ >> 228) & X10), EXCHANGE_PRICE_TOKEN_0_SLOT);\n\n        dexVariables = _updateOracle(s_.price, pex_.centerPrice, dexVariables_);\n\n        if (s_.tokenIn == NATIVE_TOKEN && amountIn_ < extras_.amountInMax) {\n            unchecked {\n                SafeTransfer.safeTransferNative(msg.sender, extras_.amountInMax - amountIn_);\n            }\n        }\n\n        // to avoid stack too deep error\n        temp_ = amountOut_;\n        emit Swap(swap0to1_, amountIn_, temp_, extras_.to);\n    }\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint amountInMax_,\n        address to_\n    ) public payable _onlyDelegateCall returns (uint amountIn_) {\n        return _swapOut(swap0to1_, amountOut_, SwapOutExtras(to_, amountInMax_, false));\n    }\n\n    /// @dev Swap tokens with perfect amount out and callback functionality\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOutWithCallback(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) public payable returns (uint256 amountIn_) {\n        return _swapOut(swap0to1_, amountOut_, SwapOutExtras(to_, amountInMax_, true));\n    }\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) public payable _onlyDelegateCall returns (uint token0Amt_, uint token1Amt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userSupplyData_ = _userSupplyData[msg.sender];\n\n        // user collateral configs are not set yet\n        if (userSupplyData_ & 1 == 0 && !estimate_) revert FluidDexError(ErrorTypes.DexT1__UserSupplyInNotOn);\n\n        // is smart collateral pool enabled\n        if ((dexVariables2_ & 1) == 1) {\n            ExchangePrices memory ex_ = _getExchangePrices();\n\n            // smart col in enabled\n            uint totalSupplyShares_ = _totalSupplyShares & X128;\n\n            _verifyMint(shares_, totalSupplyShares_);\n\n            // Adding col liquidity in equal proportion\n            // Adding + 1, to keep protocol on the winning side\n            token0Amt_ =\n                (_getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, ex_.supplyToken0ExchangePrice, true) * shares_) /\n                totalSupplyShares_;\n            token1Amt_ =\n                (_getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, ex_.supplyToken1ExchangePrice, false) * shares_) /\n                totalSupplyShares_;\n\n            // converting back into normal token amounts\n            // Adding + 1, to keep protocol on the winning side\n            token0Amt_ = (((token0Amt_ + 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) + 1;\n            token1Amt_ = (((token1Amt_ + 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) + 1;\n\n            if (estimate_) revert FluidDexPerfectLiquidityOutput(token0Amt_, token1Amt_);\n\n            if (token0Amt_ > maxToken0Deposit_ || token1Amt_ > maxToken1Deposit_) {\n                revert FluidDexError(ErrorTypes.DexT1__AboveDepositMax);\n            }\n\n            _depositOrPaybackInLiquidity(TOKEN_0, token0Amt_, 0);\n\n            _depositOrPaybackInLiquidity(TOKEN_1, token1Amt_, 0);\n\n            uint userSupply_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            // extracting exisiting shares and then adding new shares in it\n            userSupply_ = ((userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK));\n\n            // calculate current, updated (expanded etc.) withdrawal limit\n            uint256 newWithdrawalLimit_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\n\n            userSupply_ += shares_;\n\n            // bigNumber the shares are not same as before\n            _updatingUserSupplyDataOnStorage(userSupplyData_, userSupply_, newWithdrawalLimit_);\n\n            _updateSupplyShares(totalSupplyShares_ + shares_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartColNotEnabled);\n        }\n\n        // uninitializing re-entrancy\n        dexVariables = dexVariables_;\n\n        emit LogDepositPerfectColLiquidity(shares_, token0Amt_, token1Amt_);\n    }\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) public _onlyDelegateCall returns (uint token0Amt_, uint token1Amt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userSupplyData_ = _userSupplyData[msg.sender];\n\n        if (userSupplyData_ & 1 == 0 && to_ != ADDRESS_DEAD) {\n            revert FluidDexError(ErrorTypes.DexT1__UserSupplyInNotOn);\n        }\n\n        to_ = (to_ == address(0)) ? msg.sender : to_;\n\n        // is smart collateral pool enabled\n        if ((dexVariables2_ & 1) == 1) {\n            ExchangePrices memory ex_ = _getExchangePrices();\n\n            uint totalSupplyShares_ = _totalSupplyShares & X128;\n\n            _verifyRedeem(shares_, totalSupplyShares_);\n\n            // smart col in enabled\n            // Withdrawing col liquidity in equal proportion\n            token0Amt_ =\n                (_getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, ex_.supplyToken0ExchangePrice, true) * shares_) /\n                totalSupplyShares_;\n            token1Amt_ =\n                (_getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, ex_.supplyToken1ExchangePrice, false) * shares_) /\n                totalSupplyShares_;\n\n            // converting back into normal token amounts\n            token0Amt_ = (((token0Amt_ - 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) - 1;\n            token1Amt_ = (((token1Amt_ - 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) - 1;\n\n            if (to_ == ADDRESS_DEAD) revert FluidDexPerfectLiquidityOutput(token0Amt_, token1Amt_);\n\n            if (token0Amt_ < minToken0Withdraw_ || token1Amt_ < minToken1Withdraw_) {\n                revert FluidDexError(ErrorTypes.DexT1__BelowWithdrawMin);\n            }\n\n            uint256 userSupply_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            userSupply_ = (userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) withdrawal limit\n            uint256 newWithdrawalLimit_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\n            userSupply_ -= shares_;\n\n            // withdraws below limit\n            if (userSupply_ < newWithdrawalLimit_) revert FluidDexError(ErrorTypes.DexT1__WithdrawLimitReached);\n\n            _updatingUserSupplyDataOnStorage(userSupplyData_, userSupply_, newWithdrawalLimit_);\n\n            totalSupplyShares_ = totalSupplyShares_ - shares_;\n            _updateSupplyShares(totalSupplyShares_);\n\n            // withdraw\n            // if token0Amt_ == 0 then Liqudity Layer will revert\n            LIQUIDITY.operate(TOKEN_0, -int(token0Amt_), 0, to_, address(0), new bytes(0));\n\n            // withdraw\n            // if token1Amt_ == 0 then Liqudity Layer will revert\n            LIQUIDITY.operate(TOKEN_1, -int(token1Amt_), 0, to_, address(0), new bytes(0));\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartColNotEnabled);\n        }\n\n        // uninitializing re-entrancy\n        dexVariables = dexVariables_;\n\n        emit LogWithdrawPerfectColLiquidity(shares_, token0Amt_, token1Amt_);\n    }\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) public _onlyDelegateCall returns (uint token0Amt_, uint token1Amt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userBorrowData_ = _userBorrowData[msg.sender];\n\n        // user debt configs are not set yet\n        if (userBorrowData_ & 1 == 0 && to_ != ADDRESS_DEAD) revert FluidDexError(ErrorTypes.DexT1__UserDebtInNotOn);\n\n        to_ = (to_ == address(0)) ? msg.sender : to_;\n\n        // is smart debt pool enabled\n        if (((dexVariables2_ >> 1) & 1) == 1) {\n            ExchangePrices memory ex_ = _getExchangePrices();\n\n            uint totalBorrowShares_ = _totalBorrowShares & X128;\n\n            _verifyMint(shares_, totalBorrowShares_);\n\n            // Adding debt liquidity in equal proportion\n            token0Amt_ =\n                (_getLiquidityDebt(BORROW_TOKEN_0_SLOT, ex_.borrowToken0ExchangePrice, true) * shares_) /\n                totalBorrowShares_;\n            token1Amt_ =\n                (_getLiquidityDebt(BORROW_TOKEN_1_SLOT, ex_.borrowToken1ExchangePrice, false) * shares_) /\n                totalBorrowShares_;\n            // converting back into normal token amounts\n            token0Amt_ = (((token0Amt_ - 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) - 1;\n            token1Amt_ = (((token1Amt_ - 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) - 1;\n\n            if (to_ == ADDRESS_DEAD) revert FluidDexPerfectLiquidityOutput(token0Amt_, token1Amt_);\n\n            if (token0Amt_ < minToken0Borrow_ || token1Amt_ < minToken1Borrow_) {\n                revert FluidDexError(ErrorTypes.DexT1__BelowBorrowMin);\n            }\n\n            // extract user borrow amount\n            uint256 userBorrow_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n            userBorrow_ = (userBorrow_ >> DEFAULT_EXPONENT_SIZE) << (userBorrow_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) borrow limit\n            uint256 newBorrowLimit_ = DexCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, userBorrow_);\n\n            userBorrow_ += shares_;\n\n            // user above debt limit\n            if (userBorrow_ > newBorrowLimit_) revert FluidDexError(ErrorTypes.DexT1__DebtLimitReached);\n\n            // borrow\n            // if token0Amt_ == 0 then Liqudity Layer will revert\n            LIQUIDITY.operate(TOKEN_0, 0, int(token0Amt_), address(0), to_, new bytes(0));\n\n            // borrow\n            // if token1Amt_ == 1 then Liqudity Layer will revert\n            LIQUIDITY.operate(TOKEN_1, 0, int(token1Amt_), address(0), to_, new bytes(0));\n\n            _updatingUserBorrowDataOnStorage(userBorrowData_, userBorrow_, newBorrowLimit_);\n\n            _updateBorrowShares(totalBorrowShares_ + shares_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartDebtNotEnabled);\n        }\n\n        // uninitializing re-entrancy\n        dexVariables = dexVariables_;\n\n        emit LogBorrowPerfectDebtLiquidity(shares_, token0Amt_, token1Amt_);\n    }\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) public payable _onlyDelegateCall returns (uint token0Amt_, uint token1Amt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userBorrowData_ = _userBorrowData[msg.sender];\n\n        if (userBorrowData_ & 1 == 0 && !estimate_) revert FluidDexError(ErrorTypes.DexT1__UserDebtInNotOn);\n\n        // is smart debt pool enabled\n        if (((dexVariables2_ >> 1) & 1) == 1) {\n            uint totalBorrowShares_ = _totalBorrowShares & X128;\n\n            ExchangePrices memory ex_ = _getExchangePrices();\n\n            _verifyRedeem(shares_, totalBorrowShares_);\n\n            // Removing debt liquidity in equal proportion\n            token0Amt_ =\n                (_getLiquidityDebt(BORROW_TOKEN_0_SLOT, ex_.borrowToken0ExchangePrice, true) * shares_) /\n                totalBorrowShares_;\n            token1Amt_ =\n                (_getLiquidityDebt(BORROW_TOKEN_1_SLOT, ex_.borrowToken1ExchangePrice, false) * shares_) /\n                totalBorrowShares_;\n            // converting back into normal token amounts\n            token0Amt_ = (((token0Amt_ + 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) + 1;\n            token1Amt_ = (((token1Amt_ + 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) + 1;\n\n            if (estimate_) revert FluidDexPerfectLiquidityOutput(token0Amt_, token1Amt_);\n\n            if (token0Amt_ > maxToken0Payback_ || token1Amt_ > maxToken1Payback_) {\n                revert FluidDexError(ErrorTypes.DexT1__AbovePaybackMax);\n            }\n\n            _depositOrPaybackInLiquidity(TOKEN_0, 0, token0Amt_);\n\n            _depositOrPaybackInLiquidity(TOKEN_1, 0, token1Amt_);\n\n            // extract user borrow amount\n            uint256 userBorrow_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n            userBorrow_ = (userBorrow_ >> DEFAULT_EXPONENT_SIZE) << (userBorrow_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) borrow limit\n            uint256 newBorrowLimit_ = DexCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, userBorrow_);\n\n            userBorrow_ -= shares_;\n\n            _updatingUserBorrowDataOnStorage(userBorrowData_, userBorrow_, newBorrowLimit_);\n\n            totalBorrowShares_ = totalBorrowShares_ - shares_;\n            _updateBorrowShares(totalBorrowShares_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartDebtNotEnabled);\n        }\n\n        // uninitializing re-entrancy\n        dexVariables = dexVariables_;\n\n        emit LogPaybackPerfectDebtLiquidity(shares_, token0Amt_, token1Amt_);\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/core/shift.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport { Variables } from \"../../common/variables.sol\";\nimport { ConstantVariables } from \"../../common/constantVariables.sol\";\nimport { Events } from \"../events.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { ICenterPrice } from \"../interfaces.sol\";\nimport { AddressCalcs } from \"../../../../../libraries/addressCalcs.sol\";\nimport { Error } from \"../../../error.sol\";\n\ncontract FluidDexT1Shift is Variables, ConstantVariables, Events, Error {\n    address private immutable DEPLOYER_CONTRACT;\n\n    address private immutable THIS_CONTRACT;\n\n    constructor(address deployerContract_) {\n        DEPLOYER_CONTRACT = deployerContract_;\n        THIS_CONTRACT = address(this);\n    }\n\n    modifier _onlyDelegateCall() {\n        // also indirectly checked by `_check` because pool can never be initialized as long as the initialize method\n        // is delegate call only, but just to be sure on Admin logic we add the modifier everywhere nonetheless.\n        if (address(this) == THIS_CONTRACT) {\n            revert FluidDexError(ErrorTypes.DexT1__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev This function calculates the new value of a parameter after a shifting process.\n    /// @param current_ The current value is the final value where the shift ends\n    /// @param old_ The old value from where shifting started.\n    /// @param timePassed_ The time passed since shifting started.\n    /// @param shiftDuration_ The total duration of the shift when old_ reaches current_\n    /// @return The new value of the parameter after the shift.\n    function _calcShiftingDone(\n        uint current_,\n        uint old_,\n        uint timePassed_,\n        uint shiftDuration_\n    ) internal pure returns (uint) {\n        if (current_ > old_) {\n            uint diff_ = current_ - old_;\n            current_ = old_ + ((diff_ * timePassed_) / shiftDuration_);\n        } else {\n            uint diff_ = old_ - current_;\n            current_ = old_ - ((diff_ * timePassed_) / shiftDuration_);\n        }\n        return current_;\n    }\n\n    /// @dev Calculates the new upper and lower range values during an active range shift\n    /// @param upperRange_ The target upper range value\n    /// @param lowerRange_ The target lower range value\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\n    /// @return The updated upper range, lower range, and dexVariables2\n    /// @notice This function handles the gradual shifting of range values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcRangeShifting(\n        uint upperRange_,\n        uint lowerRange_,\n        uint dexVariables2_\n    ) public _onlyDelegateCall returns (uint, uint, uint) {\n        uint rangeShift_ = _rangeShift;\n        uint oldUpperRange_ = rangeShift_ & X20;\n        uint oldLowerRange_ = (rangeShift_ >> 20) & X20;\n        uint shiftDuration_ = (rangeShift_ >> 40) & X20;\n        uint startTimeStamp_ = ((rangeShift_ >> 60) & X33);\n        if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n            // shifting fully done\n            delete _rangeShift;\n            // making active shift as 0 because shift is over\n            // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates from this function and _calcThresholdShifting.\n            dexVariables2_ = dexVariables2 & ~uint(1 << 26);\n            dexVariables2 = dexVariables2_;\n            return (upperRange_, lowerRange_, dexVariables2_);\n        }\n        uint timePassed_ = block.timestamp - startTimeStamp_;\n        return (\n            _calcShiftingDone(upperRange_, oldUpperRange_, timePassed_, shiftDuration_),\n            _calcShiftingDone(lowerRange_, oldLowerRange_, timePassed_, shiftDuration_),\n            dexVariables2_\n        );\n    }\n\n    /// @dev Calculates the new upper and lower threshold values during an active threshold shift\n    /// @param upperThreshold_ The target upper threshold value\n    /// @param lowerThreshold_ The target lower threshold value\n    /// @param thresholdTime_ The time passed since shifting started\n    /// @return The updated upper threshold, lower threshold, and threshold time\n    /// @notice This function handles the gradual shifting of threshold values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcThresholdShifting(\n        uint upperThreshold_,\n        uint lowerThreshold_,\n        uint thresholdTime_\n    ) public _onlyDelegateCall returns (uint, uint, uint) {\n        uint thresholdShift_ = _thresholdShift;\n        uint oldUpperThreshold_ = thresholdShift_ & X20;\n        uint oldLowerThreshold_ = (thresholdShift_ >> 20) & X20;\n        uint shiftDuration_ = (thresholdShift_ >> 40) & X20;\n        uint startTimeStamp_ = ((thresholdShift_ >> 60) & X33);\n        uint oldThresholdTime_ = (thresholdShift_ >> 93) & X24;\n        if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n            // shifting fully done\n            delete _thresholdShift;\n            // making active shift as 0 because shift is over\n            // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates from this function and _calcRangeShifting.\n            dexVariables2 = dexVariables2 & ~uint(1 << 67);\n            return (upperThreshold_, lowerThreshold_, thresholdTime_);\n        }\n        uint timePassed_ = block.timestamp - startTimeStamp_;\n        return (\n            _calcShiftingDone(upperThreshold_, oldUpperThreshold_, timePassed_, shiftDuration_),\n            _calcShiftingDone(lowerThreshold_, oldLowerThreshold_, timePassed_, shiftDuration_),\n            _calcShiftingDone(thresholdTime_, oldThresholdTime_, timePassed_, shiftDuration_)\n        );\n    }\n\n    /// @dev Calculates the new center price during an active price shift\n    /// @param dexVariables_ The current state of dex variables\n    /// @param dexVariables2_ Additional dex variables\n    /// @return newCenterPrice_ The updated center price\n    /// @notice This function gradually shifts the center price towards a new target price over time\n    /// @notice It uses an external price source (via ICenterPrice) to determine the target price\n    /// @notice The shift continues until the current price reaches the target, or the shift duration ends\n    /// @notice Once the shift is complete, it updates the state and clears the shift data\n    /// @notice The shift rate is dynamic and depends on:\n    /// @notice - Time remaining in the shift duration\n    /// @notice - The new center price (fetched externally, which may change)\n    /// @notice - The current (old) center price\n    /// @notice This results in a fuzzy shifting mechanism where the rate can change as these parameters evolve\n    /// @notice The externally fetched new center price is expected to not differ significantly from the last externally fetched center price\n    function _calcCenterPrice(\n        uint dexVariables_,\n        uint dexVariables2_\n    ) public _onlyDelegateCall returns (uint newCenterPrice_) {\n        uint oldCenterPrice_ = (dexVariables_ >> 81) & X40;\n        oldCenterPrice_ = (oldCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (oldCenterPrice_ & DEFAULT_EXPONENT_MASK);\n        uint centerPriceShift_ = _centerPriceShift;\n        uint startTimeStamp_ = centerPriceShift_ & X33;\n        uint percent_ = (centerPriceShift_ >> 33) & X20;\n        uint time_ = (centerPriceShift_ >> 53) & X20;\n\n        uint fromTimeStamp_ = (dexVariables_ >> 121) & X33;\n        fromTimeStamp_ = fromTimeStamp_ > startTimeStamp_ ? fromTimeStamp_ : startTimeStamp_;\n\n        newCenterPrice_ = ICenterPrice(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, ((dexVariables2_ >> 112) & X30)))\n            .centerPrice();\n        uint priceShift_ = (oldCenterPrice_ * percent_ * (block.timestamp - fromTimeStamp_)) / (time_ * SIX_DECIMALS);\n\n        if (newCenterPrice_ > oldCenterPrice_) {\n            // shift on positive side\n            oldCenterPrice_ += priceShift_;\n            if (newCenterPrice_ > oldCenterPrice_) {\n                newCenterPrice_ = oldCenterPrice_;\n            } else {\n                // shifting fully done\n                delete _centerPriceShift;\n                // making active shift as 0 because shift is over\n                // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\n                dexVariables2 = dexVariables2 & ~uint(1 << 248);\n            }\n        } else {\n            unchecked {\n                oldCenterPrice_ = oldCenterPrice_ > priceShift_ ? oldCenterPrice_ - priceShift_ : 0;\n                // In case of oldCenterPrice_ ending up 0, which could happen when a lot of time has passed (pool has no swaps for many days or weeks)\n                // then below we get into the else logic which will fully conclude shifting and return newCenterPrice_\n                // as it was fetched from the external center price source.\n                // not ideal that this would ever happen unless the pool is not in use and all/most users have left leaving not enough liquidity to trade on\n            }\n            if (newCenterPrice_ < oldCenterPrice_) {\n                newCenterPrice_ = oldCenterPrice_;\n            } else {\n                // shifting fully done\n                delete _centerPriceShift;\n                // making active shift as 0 because shift is over\n                // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\n                dexVariables2 = dexVariables2 & ~uint(1 << 248);\n            }\n        }\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Events {\n    /// @notice Emitted on token swaps\n    /// @param swap0to1 Indicates whether the swap is from token0 to token1 or vice-versa.\n    /// @param amountIn The amount of tokens to be sent to the vault to swap.\n    /// @param amountOut The amount of tokens user got from the swap.\n    /// @param to Recepient of swapped tokens.\n    event Swap(bool swap0to1, uint256 amountIn, uint256 amountOut, address to);\n\n    /// @notice Emitted when liquidity is added with shares specified.\n    /// @param shares Expected exact shares to be received.\n    /// @param token0Amt Amount of token0 deposited.\n    /// @param token0Amt Amount of token1 deposited.\n    event LogDepositPerfectColLiquidity(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when liquidity is withdrawn with shares specified.\n    /// @param shares shares burned\n    /// @param token0Amt Amount of token0 withdrawn.\n    /// @param token1Amt Amount of token1 withdrawn.\n    event LogWithdrawPerfectColLiquidity(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when liquidity is borrowed with shares specified.\n    /// @param shares shares minted\n    /// @param token0Amt Amount of token0 borrowed.\n    /// @param token1Amt Amount of token1 borrowed.\n    event LogBorrowPerfectDebtLiquidity(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when liquidity is paid back with shares specified.\n    /// @param shares shares burned\n    /// @param token0Amt Amount of token0 paid back.\n    /// @param token1Amt Amount of token1 paid back.\n    event LogPaybackPerfectDebtLiquidity(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when liquidity is deposited with specified token0 & token1 amount\n    /// @param amount0 Amount of token0 deposited.\n    /// @param amount1 Amount of token1 deposited.\n    /// @param shares Amount of shares minted.\n    event LogDepositColLiquidity(uint amount0, uint amount1, uint shares);\n\n    /// @notice Emitted when liquidity is withdrawn with specified token0 & token1 amount\n    /// @param amount0 Amount of token0 withdrawn.\n    /// @param amount1 Amount of token1 withdrawn.\n    /// @param shares Amount of shares burned.\n    event LogWithdrawColLiquidity(uint amount0, uint amount1, uint shares);\n\n    /// @notice Emitted when liquidity is borrowed with specified token0 & token1 amount\n    /// @param amount0 Amount of token0 borrowed.\n    /// @param amount1 Amount of token1 borrowed.\n    /// @param shares Amount of shares minted.\n    event LogBorrowDebtLiquidity(uint amount0, uint amount1, uint shares);\n\n    /// @notice Emitted when liquidity is paid back with specified token0 & token1 amount\n    /// @param amount0 Amount of token0 paid back.\n    /// @param amount1 Amount of token1 paid back.\n    /// @param shares Amount of shares burned.\n    event LogPaybackDebtLiquidity(uint amount0, uint amount1, uint shares);\n\n    /// @notice Emitted when liquidity is withdrawn with shares specified into one token only.\n    /// @param shares shares burned\n    /// @param token0Amt Amount of token0 withdrawn.\n    /// @param token1Amt Amount of token1 withdrawn.\n    event LogWithdrawColInOneToken(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when liquidity is paid back with shares specified from one token only.\n    /// @param shares shares burned\n    /// @param token0Amt Amount of token0 paid back.\n    /// @param token1Amt Amount of token1 paid back.\n    event LogPaybackDebtInOneToken(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when internal arbitrage between 2 pools happen\n    /// @param routing if positive then routing is amtIn of token0 in deposit & borrow else token0 withdraw & payback\n    /// @param amtOut if routing is positive then token1 withdraw & payback amount else token1 deposit & borrow\n    event LogArbitrage(int routing, uint amtOut);\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/helpers/coreHelpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport { Variables } from \"../../common/variables.sol\";\nimport { ImmutableVariables } from \"../immutableVariables.sol\";\nimport { Events } from \"../events.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { IHook, ICenterPrice } from \"../interfaces.sol\";\nimport { LiquiditySlotsLink } from \"../../../../../libraries/liquiditySlotsLink.sol\";\nimport { LiquidityCalcs } from \"../../../../../libraries/liquidityCalcs.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { AddressCalcs } from \"../../../../../libraries/addressCalcs.sol\";\n\ninterface IShifting {\n    /// @dev Calculates the new upper and lower range values during an active range shift\n    /// @param upperRange_ The target upper range value\n    /// @param lowerRange_ The target lower range value\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\n    /// @return The updated upper range, lower range, and dexVariables2\n    function _calcRangeShifting(\n        uint upperRange_,\n        uint lowerRange_,\n        uint dexVariables2_\n    ) external returns (uint, uint, uint);\n\n    /// @dev Calculates the new threshold values during an active threshold shift\n    /// @param upperThreshold_ The target upper threshold value\n    /// @param lowerThreshold_ The target lower threshold value\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\n    /// @return The updated upper threshold, lower threshold, and dexVariables2\n    function _calcThresholdShifting(\n        uint upperThreshold_,\n        uint lowerThreshold_,\n        uint dexVariables2_\n    ) external returns (uint, uint, uint);\n\n    /// @dev Calculates the new center price during an active center price shift\n    /// @param centerPrice_ The current center price\n    /// @return The updated center price\n    function _calcCenterPrice(uint centerPrice_) external returns (uint);\n}\n\nabstract contract CoreHelpers is Variables, ImmutableVariables, Events {\n    using BigMathMinified for uint256;\n\n    /// @dev            do any arbitrary call\n    /// @param target_  Address to which the call needs to be delegated\n    /// @param data_    Data to execute at the delegated address\n    function _spell(address target_, bytes memory data_) internal returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            if iszero(succeeded) {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n\n    /// @dev Given an input amount of asset and pair reserves, returns the maximum output amount of the other asset\n    /// @param amountIn_ The amount of input asset.\n    /// @param iReserveIn_ Imaginary token reserve with input amount.\n    /// @param iReserveOut_ Imaginary token reserve of output amount.\n    function _getAmountOut(\n        uint256 amountIn_,\n        uint iReserveIn_,\n        uint iReserveOut_\n    ) internal pure returns (uint256 amountOut_) {\n        unchecked {\n            // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\n            uint256 numerator_ = amountIn_ * iReserveOut_;\n            uint256 denominator_ = iReserveIn_ + amountIn_;\n\n            // Using the swap formula: (AmountIn * iReserveY) / (iReserveX + AmountIn)\n            amountOut_ = numerator_ / denominator_;\n        }\n    }\n\n    /// @dev Given an output amount of asset and pair reserves, returns the input amount of the other asset\n    /// @param amountOut_ Desired output amount of the asset.\n    /// @param iReserveIn_ Imaginary token reserve of input amount.\n    /// @param iReserveOut_ Imaginary token reserve of output amount.\n    function _getAmountIn(\n        uint256 amountOut_,\n        uint iReserveIn_,\n        uint iReserveOut_\n    ) internal pure returns (uint256 amountIn_) {\n        // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\n        uint256 numerator_ = amountOut_ * iReserveIn_;\n        uint256 denominator_ = iReserveOut_ - amountOut_;\n\n        // Using the swap formula: (AmountOut * iReserveX) / (iReserveY - AmountOut)\n        amountIn_ = numerator_ / denominator_;\n    }\n\n    /// @param t total amount in\n    /// @param x imaginary reserves of token out of collateral\n    /// @param y imaginary reserves of token in of collateral\n    /// @param x2 imaginary reserves of token out of debt\n    /// @param y2 imaginary reserves of token in of debt\n    /// @return a_ how much swap should go through collateral pool. Remaining will go from debt\n    /// note if a < 0 then entire trade route through debt pool and debt pool arbitrage with col pool\n    /// note if a > t then entire trade route through col pool and col pool arbitrage with debt pool\n    /// note if a > 0 & a < t then swap will route through both pools\n    function _swapRoutingIn(uint t, uint x, uint y, uint x2, uint y2) internal pure returns (int a_) {\n        // Main equations:\n        // 1. out = x * a / (y + a)\n        // 2. out2 = x2 * (t - a) / (y2 + (t - a))\n        // final price should be same\n        // 3. (y + a) / (x - out) = (y2 + (t - a)) / (x2 - out2)\n        // derivation: https://chatgpt.com/share/dce6f381-ee5f-4d5f-b6ea-5996e84d5b57\n\n        // adding 1e18 precision\n        uint xyRoot_ = FixedPointMathLib.sqrt(x * y * 1e18);\n        uint x2y2Root_ = FixedPointMathLib.sqrt(x2 * y2 * 1e18);\n\n        a_ = (int(y2 * xyRoot_ + t * xyRoot_) - int(y * x2y2Root_)) / int(xyRoot_ + x2y2Root_);\n    }\n\n    /// @param t total amount out\n    /// @param x imaginary reserves of token in of collateral\n    /// @param y imaginary reserves of token out of collateral\n    /// @param x2 imaginary reserves of token in of debt\n    /// @param y2 imaginary reserves of token out of debt\n    /// @return a_ how much swap should go through collateral pool. Remaining will go from debt\n    /// note if a < 0 then entire trade route through debt pool and debt pool arbitrage with col pool\n    /// note if a > t then entire trade route through col pool and col pool arbitrage with debt pool\n    /// note if a > 0 & a < t then swap will route through both pools\n    function _swapRoutingOut(uint t, uint x, uint y, uint x2, uint y2) internal pure returns (int a_) {\n        // Main equations:\n        // 1. in = (x * a) / (y - a)\n        // 2. in2 = (x2 * (t - a)) / (y2 - (t - a))\n        // final price should be same\n        // 3. (y - a) / (x + in) = (y2 - (t - a)) / (x2 + in2)\n        // derivation: https://chatgpt.com/share/6585bc28-841f-49ec-aea2-1e5c5b7f4fa9\n\n        // adding 1e18 precision\n        uint xyRoot_ = FixedPointMathLib.sqrt(x * y * 1e18);\n        uint x2y2Root_ = FixedPointMathLib.sqrt(x2 * y2 * 1e18);\n\n        // 1e18 precision gets cancelled out in division\n        a_ = (int(t * xyRoot_ + y * x2y2Root_) - int(y2 * xyRoot_)) / int(xyRoot_ + x2y2Root_);\n    }\n\n    function _utilizationVerify(uint utilizationLimit_, bytes32 exchangePriceSlot_) internal view {\n        if (utilizationLimit_ < THREE_DECIMALS) {\n            utilizationLimit_ = utilizationLimit_ * 10;\n            // extracting utilization of token from liquidity layer\n            uint liquidityLayerUtilization_ = LIQUIDITY.readFromStorage(exchangePriceSlot_);\n            liquidityLayerUtilization_ =\n                (liquidityLayerUtilization_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) &\n                X14;\n            // Note: this can go slightly above the utilization limit if no update is written to storage at liquidity layer\n            // if swap was not big enough to go far enough above or any other storage update threshold write cause there\n            // so just to keep in mind when configuring the actual limit reachable can be utilizationLimit_ + storageUpdateThreshold at Liquidity\n            if (liquidityLayerUtilization_ > utilizationLimit_)\n                revert FluidDexError(ErrorTypes.DexT1__LiquidityLayerTokenUtilizationCapReached);\n        }\n    }\n\n    function _check(uint dexVariables_, uint dexVariables2_) internal {\n        if (dexVariables_ & 1 == 1) revert FluidDexError(ErrorTypes.DexT1__AlreadyEntered);\n        if (dexVariables2_ & 3 == 0) revert FluidDexError(ErrorTypes.DexT1__PoolNotInitialized);\n        // enabling re-entrancy\n        dexVariables = dexVariables_ | 1;\n    }\n\n    /// @dev if token0 reserves are too low w.r.t token1 then revert, this is to avoid edge case scenario and making sure that precision on calculations should be high enough\n    function _verifyToken0Reserves(\n        uint token0Reserves_,\n        uint token1Reserves_,\n        uint centerPrice_,\n        uint minLiquidity_\n    ) internal pure {\n        if (((token0Reserves_) < ((token1Reserves_ * 1e27) / (centerPrice_ * minLiquidity_)))) {\n            revert FluidDexError(ErrorTypes.DexT1__TokenReservesTooLow);\n        }\n    }\n\n    /// @dev if token1 reserves are too low w.r.t token0 then revert, this is to avoid edge case scenario and making sure that precision on calculations should be high enough\n    function _verifyToken1Reserves(\n        uint token0Reserves_,\n        uint token1Reserves_,\n        uint centerPrice_,\n        uint minLiquidity_\n    ) internal pure {\n        if (((token1Reserves_) < ((token0Reserves_ * centerPrice_) / (1e27 * minLiquidity_)))) {\n            revert FluidDexError(ErrorTypes.DexT1__TokenReservesTooLow);\n        }\n    }\n\n    function _verifySwapAndNonPerfectActions(uint amountAdjusted_, uint amount_) internal pure {\n        // after shifting amount should not become 0\n        // limiting to six decimals which means in case of USDC, USDT it's 1 wei, for WBTC 100 wei, for ETH 1000 gwei\n        if (amountAdjusted_ < SIX_DECIMALS || amountAdjusted_ > X96 || amount_ < TWO_DECIMALS || amount_ > X128)\n            revert FluidDexError(ErrorTypes.DexT1__LimitingAmountsSwapAndNonPerfectActions);\n    }\n\n    /// @dev Calculates the new upper and lower range values during an active range shift\n    /// @param upperRange_ The target upper range value\n    /// @param lowerRange_ The target lower range value\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\n    /// @return The updated upper range, lower range, and dexVariables2\n    /// @notice This function handles the gradual shifting of range values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcRangeShifting(\n        uint upperRange_,\n        uint lowerRange_,\n        uint dexVariables2_\n    ) internal returns (uint, uint, uint) {\n        return\n            abi.decode(\n                _spell(\n                    SHIFT_IMPLEMENTATION,\n                    abi.encodeWithSelector(\n                        IShifting._calcRangeShifting.selector,\n                        upperRange_,\n                        lowerRange_,\n                        dexVariables2_\n                    )\n                ),\n                (uint, uint, uint)\n            );\n    }\n\n    /// @dev Calculates the new upper and lower threshold values during an active threshold shift\n    /// @param upperThreshold_ The target upper threshold value\n    /// @param lowerThreshold_ The target lower threshold value\n    /// @param thresholdTime_ The time passed since shifting started\n    /// @return The updated upper threshold, lower threshold, and threshold time\n    /// @notice This function handles the gradual shifting of threshold values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcThresholdShifting(\n        uint upperThreshold_,\n        uint lowerThreshold_,\n        uint thresholdTime_\n    ) internal returns (uint, uint, uint) {\n        return\n            abi.decode(\n                _spell(\n                    SHIFT_IMPLEMENTATION,\n                    abi.encodeWithSelector(\n                        IShifting._calcThresholdShifting.selector,\n                        upperThreshold_,\n                        lowerThreshold_,\n                        thresholdTime_\n                    )\n                ),\n                (uint, uint, uint)\n            );\n    }\n\n    /// @dev Calculates the new center price during an active price shift\n    /// @param dexVariables_ The current state of dex variables\n    /// @param dexVariables2_ Additional dex variables\n    /// @return newCenterPrice_ The updated center price\n    /// @notice This function gradually shifts the center price towards a new target price over time\n    /// @notice It uses an external price source (via ICenterPrice) to determine the target price\n    /// @notice The shift continues until the current price reaches the target, or the shift duration ends\n    /// @notice Once the shift is complete, it updates the state and clears the shift data\n    /// @notice The shift rate is dynamic and depends on:\n    /// @notice - Time remaining in the shift duration\n    /// @notice - The new center price (fetched externally, which may change)\n    /// @notice - The current (old) center price\n    /// @notice This results in a fuzzy shifting mechanism where the rate can change as these parameters evolve\n    /// @notice The externally fetched new center price is expected to not differ significantly from the last externally fetched center price\n    function _calcCenterPrice(uint dexVariables_, uint dexVariables2_) internal returns (uint newCenterPrice_) {\n        return\n            abi.decode(\n                _spell(\n                    SHIFT_IMPLEMENTATION,\n                    abi.encodeWithSelector(IShifting._calcCenterPrice.selector, dexVariables_, dexVariables2_)\n                ),\n                (uint)\n            );\n    }\n\n    /// @notice Calculates and returns the current prices and exchange prices for the pool\n    /// @param dexVariables_ The first set of DEX variables containing various pool parameters\n    /// @param dexVariables2_ The second set of DEX variables containing additional pool parameters\n    /// @return pex_ A struct containing the calculated prices and exchange prices:\n    ///         - pex_.lastStoredPrice: The last stored price in 1e27 decimals\n    ///         - pex_.centerPrice: The calculated or fetched center price in 1e27 decimals\n    ///         - pex_.upperRange: The upper range price limit in 1e27 decimals\n    ///         - pex_.lowerRange: The lower range price limit in 1e27 decimals\n    ///         - pex_.geometricMean: The geometric mean of upper range & lower range in 1e27 decimals\n    ///         - pex_.supplyToken0ExchangePrice: The current exchange price for supplying token0\n    ///         - pex_.borrowToken0ExchangePrice: The current exchange price for borrowing token0\n    ///         - pex_.supplyToken1ExchangePrice: The current exchange price for supplying token1\n    ///         - pex_.borrowToken1ExchangePrice: The current exchange price for borrowing token1\n    /// @dev This function performs the following operations:\n    ///      1. Determines the center price (either from storage, external source, or calculated)\n    ///      2. Retrieves the last stored price from dexVariables_\n    ///      3. Calculates the upper and lower range prices based on the center price and range percentages\n    ///      4. Checks if rebalancing is needed based on threshold settings\n    ///      5. Adjusts prices if necessary based on the time elapsed and threshold conditions\n    ///      6. Update the dexVariables2_ if changes were made\n    ///      7. Returns the calculated prices and exchange prices in the PricesAndExchangePrice struct\n    function _getPricesAndExchangePrices(\n        uint dexVariables_,\n        uint dexVariables2_\n    ) internal returns (PricesAndExchangePrice memory pex_) {\n        uint centerPrice_;\n\n        if (((dexVariables2_ >> 248) & 1) == 0) {\n            // centerPrice_ => center price hook\n            centerPrice_ = (dexVariables2_ >> 112) & X30;\n            if (centerPrice_ == 0) {\n                centerPrice_ = (dexVariables_ >> 81) & X40;\n                centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n            } else {\n                // center price should be fetched from external source. For exmaple, in case of wstETH <> ETH pool,\n                // we would want the center price to be pegged to wstETH exchange rate into ETH\n                centerPrice_ = ICenterPrice(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, centerPrice_)).centerPrice();\n            }\n        } else {\n            // an active centerPrice_ shift is going on\n            centerPrice_ = _calcCenterPrice(dexVariables_, dexVariables2_);\n        }\n\n        uint lastStoredPrice_ = (dexVariables_ >> 41) & X40;\n        lastStoredPrice_ = (lastStoredPrice_ >> DEFAULT_EXPONENT_SIZE) << (lastStoredPrice_ & DEFAULT_EXPONENT_MASK);\n\n        uint upperRange_ = ((dexVariables2_ >> 27) & X20);\n        uint lowerRange_ = ((dexVariables2_ >> 47) & X20);\n        if (((dexVariables2_ >> 26) & 1) == 1) {\n            // an active range shift is going on\n            (upperRange_, lowerRange_, dexVariables2_) = _calcRangeShifting(upperRange_, lowerRange_, dexVariables2_);\n        }\n\n        unchecked {\n            // adding into unchecked because upperRange_ & lowerRange_ can only be > 0 & < SIX_DECIMALS\n            // 1% = 1e4, 100% = 1e6\n            upperRange_ = (centerPrice_ * SIX_DECIMALS) / (SIX_DECIMALS - upperRange_);\n            // 1% = 1e4, 100% = 1e6\n            lowerRange_ = (centerPrice_ * (SIX_DECIMALS - lowerRange_)) / SIX_DECIMALS;\n        }\n\n        bool changed_;\n        {\n            // goal will be to keep threshold percents 0 if center price is fetched from external source\n            // checking if threshold are set non 0 then only rebalancing is on\n            if (((dexVariables2_ >> 68) & X20) > 0) {\n                uint upperThreshold_ = (dexVariables2_ >> 68) & X10;\n                uint lowerThreshold_ = (dexVariables2_ >> 78) & X10;\n                uint shiftingTime_ = (dexVariables2_ >> 88) & X24;\n                if (((dexVariables2_ >> 67) & 1) == 1) {\n                    // if active shift is going on for threshold then calculate threshold real time\n                    (upperThreshold_, lowerThreshold_, shiftingTime_) = _calcThresholdShifting(\n                        upperThreshold_,\n                        lowerThreshold_,\n                        shiftingTime_\n                    );\n                }\n\n                unchecked {\n                    if (\n                        lastStoredPrice_ >\n                        (centerPrice_ +\n                            ((upperRange_ - centerPrice_) * (THREE_DECIMALS - upperThreshold_)) /\n                            THREE_DECIMALS)\n                    ) {\n                        uint timeElapsed_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n                        // price shifting towards upper range\n                        if (timeElapsed_ < shiftingTime_) {\n                            centerPrice_ = centerPrice_ + ((upperRange_ - centerPrice_) * timeElapsed_) / shiftingTime_;\n                        } else {\n                            // 100% price shifted\n                            centerPrice_ = upperRange_;\n                        }\n                        changed_ = true;\n                    } else if (\n                        lastStoredPrice_ <\n                        (centerPrice_ -\n                            ((centerPrice_ - lowerRange_) * (THREE_DECIMALS - lowerThreshold_)) /\n                            THREE_DECIMALS)\n                    ) {\n                        uint timeElapsed_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n                        // price shifting towards lower range\n                        if (timeElapsed_ < shiftingTime_) {\n                            centerPrice_ = centerPrice_ - ((centerPrice_ - lowerRange_) * timeElapsed_) / shiftingTime_;\n                        } else {\n                            // 100% price shifted\n                            centerPrice_ = lowerRange_;\n                        }\n                        changed_ = true;\n                    }\n                }\n            }\n        }\n\n        // temp_ => max center price\n        uint temp_ = (dexVariables2_ >> 172) & X28;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n        if (centerPrice_ > temp_) {\n            // if center price is greater than max center price\n            centerPrice_ = temp_;\n            changed_ = true;\n        } else {\n            // check if center price is less than min center price\n            // temp_ => min center price\n            temp_ = (dexVariables2_ >> 200) & X28;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n            if (centerPrice_ < temp_) {\n                centerPrice_ = temp_;\n                changed_ = true;\n            }\n        }\n\n        // if centerPrice_ is changed then calculating upper and lower range again\n        if (changed_) {\n            upperRange_ = ((dexVariables2_ >> 27) & X20);\n            lowerRange_ = ((dexVariables2_ >> 47) & X20);\n            if (((dexVariables2_ >> 26) & 1) == 1) {\n                (upperRange_, lowerRange_, dexVariables2_) = _calcRangeShifting(\n                    upperRange_,\n                    lowerRange_,\n                    dexVariables2_\n                );\n            }\n\n            unchecked {\n                // adding into unchecked because upperRange_ & lowerRange_ can only be > 0 & < SIX_DECIMALS\n                // 1% = 1e4, 100% = 1e6\n                upperRange_ = (centerPrice_ * SIX_DECIMALS) / (SIX_DECIMALS - upperRange_);\n                // 1% = 1e4, 100% = 1e6\n                lowerRange_ = (centerPrice_ * (SIX_DECIMALS - lowerRange_)) / SIX_DECIMALS;\n            }\n        }\n\n        pex_.lastStoredPrice = lastStoredPrice_;\n        pex_.centerPrice = centerPrice_;\n        pex_.upperRange = upperRange_;\n        pex_.lowerRange = lowerRange_;\n\n        unchecked {\n            if (upperRange_ < 1e38) {\n                // 1e38 * 1e38 = 1e76 which is less than max uint limit\n                pex_.geometricMean = FixedPointMathLib.sqrt(upperRange_ * lowerRange_);\n            } else {\n                // upperRange_ price is pretty large hence lowerRange_ will also be pretty large\n                pex_.geometricMean = FixedPointMathLib.sqrt((upperRange_ / 1e18) * (lowerRange_ / 1e18)) * 1e18;\n            }\n        }\n\n        // Exchange price will remain same as Liquidity Layer\n        (pex_.supplyToken0ExchangePrice, pex_.borrowToken0ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_0_SLOT)\n        );\n\n        (pex_.supplyToken1ExchangePrice, pex_.borrowToken1ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_1_SLOT)\n        );\n    }\n\n    /// @dev getting reserves outside range.\n    /// @param gp_ is geometric mean pricing of upper percent & lower percent\n    /// @param pa_ price of upper range or lower range\n    /// @param rx_ real reserves of token0 or token1\n    /// @param ry_ whatever is rx_ the other will be ry_\n    function _calculateReservesOutsideRange(\n        uint gp_,\n        uint pa_,\n        uint rx_,\n        uint ry_\n    ) internal pure returns (uint xa_, uint yb_) {\n        // equations we have:\n        // 1. x*y = k\n        // 2. xa*ya = k\n        // 3. xb*yb = k\n        // 4. Pa = ya / xa = upperRange_ (known)\n        // 5. Pb = yb / xb = lowerRange_ (known)\n        // 6. x - xa = rx = real reserve of x (known)\n        // 7. y - yb = ry = real reserve of y (known)\n        // With solving we get:\n        // ((Pa*Pb)^(1/2) - Pa)*xa^2 + (rx * (Pa*Pb)^(1/2) + ry)*xa + rx*ry = 0\n        // yb = yb = xa * (Pa * Pb)^(1/2)\n\n        // xa = (GP⋅rx + ry + (-rx⋅ry⋅4⋅(GP - Pa) + (GP⋅rx + ry)^2)^0.5) / (2Pa - 2GP)\n        // multiply entire equation by 1e27 to remove the price decimals precision of 1e27\n        // xa = (GP⋅rx + ry⋅1e27 + (rx⋅ry⋅4⋅(Pa - GP)⋅1e27 + (GP⋅rx + ry⋅1e27)^2)^0.5) / 2*(Pa - GP)\n        // dividing the equation with 2*(Pa - GP). Pa is always > GP so answer will be positive.\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅4⋅(Pa - GP)⋅1e27) / 4*(Pa - GP)^2) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅1e27) / (Pa - GP)) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n\n        // dividing in 3 parts for simplification:\n        // part1 = (Pa - GP)\n        // part2 = (GP⋅rx + ry⋅1e27) / (2*part1)\n        // part3 = rx⋅ry\n        // note: part1 will almost always be < 1e28 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e29\n        uint p1_ = pa_ - gp_;\n        uint p2_ = ((gp_ * rx_) + (ry_ * 1e27)) / (2 * p1_);\n        uint p3_ = rx_ * ry_;\n        // to avoid overflowing\n        p3_ = (p3_ < 1e50) ? ((p3_ * 1e27) / p1_) : (p3_ / p1_) * 1e27;\n\n        // xa = part2 + (part3 + (part2 * part2))^(1/2)\n        // yb = xa_ * gp_\n        xa_ = p2_ + FixedPointMathLib.sqrt((p3_ + (p2_ * p2_)));\n        yb_ = (xa_ * gp_) / 1e27;\n    }\n\n    /// @dev Retrieves collateral amount from liquidity layer for a given token\n    /// @param supplyTokenSlot_ The storage slot for the supply token data\n    /// @param tokenExchangePrice_ The exchange price of the token\n    /// @param isToken0_ Boolean indicating if the token is token0 (true) or token1 (false)\n    /// @return tokenSupply_ The calculated liquidity collateral amount\n    function _getLiquidityCollateral(\n        bytes32 supplyTokenSlot_,\n        uint tokenExchangePrice_,\n        bool isToken0_\n    ) internal view returns (uint tokenSupply_) {\n        uint tokenSupplyData_ = LIQUIDITY.readFromStorage(supplyTokenSlot_);\n        tokenSupply_ = (tokenSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n        tokenSupply_ = (tokenSupply_ >> DEFAULT_EXPONENT_SIZE) << (tokenSupply_ & DEFAULT_EXPONENT_MASK);\n\n        if (tokenSupplyData_ & 1 == 1) {\n            // supply with interest is on\n            unchecked {\n                tokenSupply_ = (tokenSupply_ * tokenExchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n            }\n        }\n\n        unchecked {\n            tokenSupply_ = isToken0_\n                ? ((tokenSupply_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\n                : ((tokenSupply_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\n        }\n    }\n\n    /// @notice Calculates the real and imaginary reserves for collateral tokens\n    /// @dev This function retrieves the supply of both tokens from the liquidity layer,\n    ///      adjusts them based on exchange prices, and calculates imaginary reserves\n    ///      based on the geometric mean and price range\n    /// @param geometricMean_ The geometric mean of the token prices\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0SupplyExchangePrice_ The exchange price for token0 from liquidity layer\n    /// @param token1SupplyExchangePrice_ The exchange price for token1 from liquidity layer\n    /// @return c_ A struct containing the calculated real and imaginary reserves for both tokens:\n    ///         - token0RealReserves: The real reserves of token0\n    ///         - token1RealReserves: The real reserves of token1\n    ///         - token0ImaginaryReserves: The imaginary reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary reserves of token1\n    function _getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) internal view returns (CollateralReserves memory c_) {\n        uint token0Supply_ = _getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, token0SupplyExchangePrice_, true);\n        uint token1Supply_ = _getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, token1SupplyExchangePrice_, false);\n\n        if (geometricMean_ < 1e27) {\n            (c_.token0ImaginaryReserves, c_.token1ImaginaryReserves) = _calculateReservesOutsideRange(\n                geometricMean_,\n                upperRange_,\n                token0Supply_,\n                token1Supply_\n            );\n        } else {\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n            // 1 / geometricMean for new geometricMean\n            // 1 / lowerRange will become upper range\n            // 1 / upperRange will become lower range\n            (c_.token1ImaginaryReserves, c_.token0ImaginaryReserves) = _calculateReservesOutsideRange(\n                (1e54 / geometricMean_),\n                (1e54 / lowerRange_),\n                token1Supply_,\n                token0Supply_\n            );\n        }\n\n        c_.token0RealReserves = token0Supply_;\n        c_.token1RealReserves = token1Supply_;\n        unchecked {\n            c_.token0ImaginaryReserves += token0Supply_;\n            c_.token1ImaginaryReserves += token1Supply_;\n        }\n    }\n\n    /// @notice Calculates the real and imaginary debt reserves for both tokens\n    /// @dev This function uses a quadratic equation to determine the debt reserves\n    ///      based on the geometric mean price and the current debt amounts\n    /// @param gp_ The geometric mean price of upper range & lower range\n    /// @param pb_ The price of lower range\n    /// @param dx_ The debt amount of one token\n    /// @param dy_ The debt amount of the other token\n    /// @return rx_ The real debt reserve of the first token\n    /// @return ry_ The real debt reserve of the second token\n    /// @return irx_ The imaginary debt reserve of the first token\n    /// @return iry_ The imaginary debt reserve of the second token\n    function _calculateDebtReserves(\n        uint gp_,\n        uint pb_,\n        uint dx_,\n        uint dy_\n    ) internal pure returns (uint rx_, uint ry_, uint irx_, uint iry_) {\n        // Assigning letter to knowns:\n        // c = debtA\n        // d = debtB\n        // e = upperPrice\n        // f = lowerPrice\n        // g = upperPrice^1/2\n        // h = lowerPrice^1/2\n\n        // c = 1\n        // d = 2000\n        // e = 2222.222222\n        // f = 1800\n        // g = 2222.222222^1/2\n        // h = 1800^1/2\n\n        // Assigning letter to unknowns:\n        // w = realDebtReserveA\n        // x = realDebtReserveB\n        // y = imaginaryDebtReserveA\n        // z = imaginaryDebtReserveB\n        // k = k\n\n        // below quadratic will give answer of realDebtReserveB\n        // A, B, C of quadratic equation:\n        // A = h\n        // B = dh - cfg\n        // C = -cfdh\n\n        // A = lowerPrice^1/2\n        // B = debtB⋅lowerPrice^1/2 - debtA⋅lowerPrice⋅upperPrice^1/2\n        // C = -(debtA⋅lowerPrice⋅debtB⋅lowerPrice^1/2)\n\n        // x = (cfg − dh + (4cdf(h^2)+(cfg−dh)^2))^(1/2)) / 2h\n        // simplifying dividing by h, note h = f^1/2\n        // x = ((c⋅g⋅(f^1/2) − d) / 2 + ((4⋅c⋅d⋅f⋅f) / (4h^2) + ((c⋅f⋅g) / 2h − (d⋅h) / 2h)^2))^(1/2))\n        // x = ((c⋅g⋅(f^1/2) − d) / 2 + ((c⋅d⋅f) + ((c⋅g⋅(f^1/2) − d) / 2)^2))^(1/2))\n\n        // dividing in 3 parts for simplification:\n        // part1 = (c⋅g⋅(f^1/2) − d) / 2\n        // part2 = (c⋅d⋅f)\n        // x = (part1 + (part2 + part1^2)^(1/2))\n        // note: part1 will almost always be < 1e27 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e28\n\n        // part1 = ((debtA * upperPrice^1/2 * lowerPrice^1/2) - debtB) / 2\n        // note: upperPrice^1/2 * lowerPrice^1/2 = geometric mean\n        // part1 = ((debtA * geometricMean) - debtB) / 2\n        // part2 = debtA * debtB * lowerPrice\n\n        // converting decimals properly as price is in 1e27 decimals\n        // part1 = ((debtA * geometricMean) - (debtB * 1e27)) / (2 * 1e27)\n        // part2 = (debtA * debtB * lowerPrice) / 1e27\n        // final x equals:\n        // x = (part1 + (part2 + part1^2)^(1/2))\n        int p1_ = (int(dx_ * gp_) - int(dy_ * 1e27)) / (2 * 1e27);\n        uint p2_ = (dx_ * dy_);\n        p2_ = p2_ < 1e50 ? (p2_ * pb_) / 1e27 : (p2_ / 1e27) * pb_;\n        ry_ = uint(p1_ + int(FixedPointMathLib.sqrt((p2_ + uint(p1_ * p1_)))));\n\n        // finding z:\n        // x^2 - zx + cfz = 0\n        // z*(x - cf) = x^2\n        // z = x^2 / (x - cf)\n        // z = x^2 / (x - debtA * lowerPrice)\n        // converting decimals properly as price is in 1e27 decimals\n        // z = (x^2 * 1e27) / ((x * 1e27) - (debtA * lowerPrice))\n\n        iry_ = ((ry_ * 1e27) - (dx_ * pb_));\n        if (iry_ < SIX_DECIMALS) {\n            // almost impossible situation to ever get here\n            revert FluidDexError(ErrorTypes.DexT1__DebtReservesTooLow);\n        }\n        if (ry_ < 1e25) {\n            iry_ = (ry_ * ry_ * 1e27) / iry_;\n        } else {\n            // note: it can never result in negative as final result will always be in positive\n            iry_ = (ry_ * ry_) / (iry_ / 1e27);\n        }\n\n        // finding y\n        // x = z * c / (y + c)\n        // y + c = z * c / x\n        // y = (z * c / x) - c\n        // y = (z * debtA / x) - debtA\n        irx_ = ((iry_ * dx_) / ry_) - dx_;\n\n        // finding w\n        // w = y * d / (z + d)\n        // w = (y * debtB) / (z + debtB)\n        rx_ = (irx_ * dy_) / (iry_ + dy_);\n    }\n\n    /// @notice Calculates the debt amount for a given token from liquidity layer\n    /// @param borrowTokenSlot_ The storage slot for the token's borrow data\n    /// @param tokenExchangePrice_ The current exchange price of the token\n    /// @param isToken0_ Boolean indicating if this is for token0 (true) or token1 (false)\n    /// @return tokenDebt_ The calculated debt amount for the token\n    function _getLiquidityDebt(\n        bytes32 borrowTokenSlot_,\n        uint tokenExchangePrice_,\n        bool isToken0_\n    ) internal view returns (uint tokenDebt_) {\n        uint tokenBorrowData_ = LIQUIDITY.readFromStorage(borrowTokenSlot_);\n\n        tokenDebt_ = (tokenBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n        tokenDebt_ = (tokenDebt_ >> 8) << (tokenDebt_ & X8);\n\n        if (tokenBorrowData_ & 1 == 1) {\n            // borrow with interest is on\n            unchecked {\n                tokenDebt_ = (tokenDebt_ * tokenExchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n            }\n        }\n\n        unchecked {\n            tokenDebt_ = isToken0_\n                ? ((tokenDebt_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\n                : ((tokenDebt_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\n        }\n    }\n\n    /// @notice Calculates the debt reserves for both tokens\n    /// @param geometricMean_ The geometric mean of the upper and lower price ranges\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0BorrowExchangePrice_ The exchange price of token0 from liquidity layer\n    /// @param token1BorrowExchangePrice_ The exchange price of token1 from liquidity layer\n    /// @return d_ The calculated debt reserves for both tokens, containing:\n    ///         - token0Debt: The debt amount of token0\n    ///         - token1Debt: The debt amount of token1\n    ///         - token0RealReserves: The real reserves of token0 derived from token1 debt\n    ///         - token1RealReserves: The real reserves of token1 derived from token0 debt\n    ///         - token0ImaginaryReserves: The imaginary debt reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary debt reserves of token1\n    function _getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) internal view returns (DebtReserves memory d_) {\n        uint token0Debt_ = _getLiquidityDebt(BORROW_TOKEN_0_SLOT, token0BorrowExchangePrice_, true);\n        uint token1Debt_ = _getLiquidityDebt(BORROW_TOKEN_1_SLOT, token1BorrowExchangePrice_, false);\n\n        d_.token0Debt = token0Debt_;\n        d_.token1Debt = token1Debt_;\n\n        if (geometricMean_ < 1e27) {\n            (\n                d_.token0RealReserves,\n                d_.token1RealReserves,\n                d_.token0ImaginaryReserves,\n                d_.token1ImaginaryReserves\n            ) = _calculateDebtReserves(geometricMean_, lowerRange_, token0Debt_, token1Debt_);\n        } else {\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n            // 1 / geometricMean for new geometricMean\n            // 1 / lowerRange will become upper range\n            // 1 / upperRange will become lower range\n            (\n                d_.token1RealReserves,\n                d_.token0RealReserves,\n                d_.token1ImaginaryReserves,\n                d_.token0ImaginaryReserves\n            ) = _calculateDebtReserves((1e54 / geometricMean_), (1e54 / upperRange_), token1Debt_, token0Debt_);\n        }\n    }\n\n    function _updateOracle(uint newPrice_, uint centerPrice_, uint dexVariables_) internal returns (uint) {\n        if (((dexVariables_ >> 195) & 1) == 0) {\n            // if oracle is not active then just returning updated DEX variable\n            newPrice_ = newPrice_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN);\n\n            return (dexVariables_ & 0xfffffffffffffffffffffffffc00000000000000000000000000000000000001) |\n                (newPrice_ << 1) |\n                (newPrice_ << 41) |\n                (centerPrice_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN) << 81) |\n                (block.timestamp << 121);\n        }\n\n        // time difference between last & current swap\n        uint timeDiff_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n\n        uint temp_;\n        uint temp2_;\n        uint temp3_;\n\n        if (timeDiff_ > 0) {\n            // update oracle\n\n            // olderPrice_ => temp_\n            temp_ = (dexVariables_ >> 1) & X40;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // oldPrice_ => temp2_\n            temp2_ = (dexVariables_ >> 41) & X40;\n            temp2_ = (temp2_ >> DEFAULT_EXPONENT_SIZE) << (temp2_ & DEFAULT_EXPONENT_MASK);\n\n            // check newPrice_ & oldPrice_ difference should not be more than 5%\n            // old price w.r.t new price\n            int priceDiff_ = int(ORACLE_PRECISION) - int((temp2_ * ORACLE_PRECISION) / newPrice_);\n\n            unchecked {\n                if ((priceDiff_ > int(ORACLE_LIMIT)) || (priceDiff_ < -int(ORACLE_LIMIT))) {\n                    // if oracle price difference is more than 5% then revert\n                    // in 1 swap price should only change by <= 5%\n                    // if a total fall by let's say 8% then in current block price can only fall by 5% and\n                    // in next block it'll fall the remaining 3%\n                    revert FluidDexError(ErrorTypes.DexT1__OracleUpdateHugeSwapDiff);\n                }\n            }\n\n            unchecked {\n                // older price w.r.t old price\n                priceDiff_ = int(ORACLE_PRECISION) - int((temp_ * ORACLE_PRECISION) / temp2_);\n            }\n\n            // priceDiffInPercentAndSign_ => temp3_\n            // priceDiff_ will always be lower than ORACLE_LIMIT due to above check\n            unchecked {\n                if (priceDiff_ < 0) {\n                    temp3_ = ((uint(-priceDiff_) * X22) / ORACLE_LIMIT) << 1;\n                } else {\n                    // if greater than or equal to 0 then make sign flag 1\n                    temp3_ = (((uint(priceDiff_) * X22) / ORACLE_LIMIT) << 1) | 1;\n                }\n            }\n\n            if (timeDiff_ > X22) {\n                // if time difference is this then that means DEX has been inactive ~45 days\n                // that means oracle price of this DEX should not be used.\n                timeDiff_ = X22;\n            }\n\n            // temp_ => lastTimeDiff_\n            temp_ = (dexVariables_ >> 154) & X22;\n            uint nextOracleSlot_ = ((dexVariables_ >> 176) & X3);\n            uint oracleMap_ = (dexVariables_ >> 179) & X16;\n            if (temp_ > X9) {\n                if (nextOracleSlot_ > 0) {\n                    // if greater than 0 then current slot has 2 or more oracle slot empty\n                    // First 9 bits are of time, so not using that\n                    temp3_ = (temp3_ << 41) | (temp_ << 9);\n                    _oracle[oracleMap_] = _oracle[oracleMap_] | (temp3_ << (--nextOracleSlot_ * 32));\n                    if (nextOracleSlot_ > 0) {\n                        --nextOracleSlot_;\n                    } else {\n                        // if == 0 that means the oracle slots will get filled and shift to next oracle map\n                        nextOracleSlot_ = 7;\n                        unchecked {\n                            oracleMap_ = (oracleMap_ + 1) % TOTAL_ORACLE_MAPPING;\n                        }\n                        _oracle[oracleMap_] = 0;\n                    }\n                } else {\n                    // if == 0\n                    // then seconds will be in last map\n                    // precision will be in last map + 1\n                    // Storing precision & sign slot in first precision & sign slot and leaving time slot empty\n                    temp3_ = temp3_ << 9;\n                    _oracle[oracleMap_] = _oracle[oracleMap_] | temp3_;\n                    nextOracleSlot_ = 6; // storing 6 here as 7 is going to occupied right now\n                    unchecked {\n                        oracleMap_ = (oracleMap_ + 1) % TOTAL_ORACLE_MAPPING;\n                    }\n                    // Storing time in 2nd precision & sign and leaving time slot empty\n                    _oracle[oracleMap_] = temp_ << ((7 * 32) + 9);\n                }\n            } else {\n                temp3_ = (temp3_ << 9) | temp_;\n                unchecked {\n                    if (nextOracleSlot_ < 7) {\n                        _oracle[oracleMap_] = _oracle[oracleMap_] | (temp3_ << (nextOracleSlot_ * 32));\n                    } else {\n                        _oracle[oracleMap_] = temp3_ << ((7 * 32));\n                    }\n                }\n                if (nextOracleSlot_ > 0) {\n                    --nextOracleSlot_;\n                } else {\n                    nextOracleSlot_ = 7;\n                    unchecked {\n                        oracleMap_ = (oracleMap_ + 1) % TOTAL_ORACLE_MAPPING;\n                    }\n                    _oracle[oracleMap_] = 0;\n                }\n            }\n\n            // doing this due to stack too deep error when using params memory variables\n            temp_ = newPrice_;\n            temp2_ = centerPrice_;\n            temp3_ = dexVariables_;\n\n            // then update last price\n            temp3_ =\n                (temp3_ & 0xfffffffffffffff8000000000000000000000000000000000000000000000001) |\n                (((temp3_ >> 41) & X40) << 1) |\n                (temp_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN) << 41) |\n                (temp2_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN) << 81) |\n                (block.timestamp << 121) |\n                (timeDiff_ << 154) |\n                (nextOracleSlot_ << 176) |\n                (oracleMap_ << 179);\n        } else {\n            // temp_ => oldCenterPrice\n            temp_ = (dexVariables_ >> 81) & X40;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // Ensure that the center price is within the acceptable range of the old center price if it's not the first swap in the same block\n            unchecked {\n                if (\n                    (centerPrice_ < (((EIGHT_DECIMALS - 1) * temp_) / EIGHT_DECIMALS)) ||\n                    (centerPrice_ > (((EIGHT_DECIMALS + 1) * temp_) / EIGHT_DECIMALS))\n                ) {\n                    revert FluidDexError(ErrorTypes.DexT1__CenterPriceOutOfRange);\n                }\n            }\n\n            // olderPrice_ => temp_\n            temp_ = (dexVariables_ >> 1) & X40;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // check newPrice_ & olderPrice_ difference should not be more than 5%\n            // older price w.r.t new price\n            int priceDiff_ = int(ORACLE_PRECISION) - int((temp_ * ORACLE_PRECISION) / newPrice_);\n\n            if ((priceDiff_ > int(ORACLE_LIMIT)) || (priceDiff_ < -int(ORACLE_LIMIT))) {\n                // if oracle price difference is more than 5% then revert\n                // in 1 swap price should only change by <= 5%\n                // if a total fall by let's say 8% then in current block price can only fall by 5% and\n                // in next block it'll fall the remaining 3%\n                revert FluidDexError(ErrorTypes.DexT1__OracleUpdateHugeSwapDiff);\n            }\n\n            // doing this due to stack too deep error when using params memory variables\n            temp_ = newPrice_;\n            temp3_ = dexVariables_;\n            // 2nd swap in same block no need to update anything around oracle, only need to update last swap price in dexVariables\n            temp3_ =\n                (temp3_ & 0xfffffffffffffffffffffffffffffffffffffffffffe0000000001ffffffffff) |\n                (temp_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN) << 41);\n        }\n\n        return temp3_;\n    }\n\n    function _hookVerify(uint hookAddress_, uint mode_, bool swap0to1_, uint price_) internal {\n        try\n            IHook(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, hookAddress_)).dexPrice(\n                mode_,\n                swap0to1_,\n                TOKEN_0,\n                TOKEN_1,\n                price_\n            )\n        returns (bool isOk_) {\n            if (!isOk_) revert FluidDexError(ErrorTypes.DexT1__HookReturnedFalse);\n        } catch (bytes memory /*lowLevelData*/) {\n            // skip checking hook nothing\n        }\n    }\n\n    function _updateSupplyShares(uint newTotalShares_) internal {\n        uint totalSupplyShares_ = _totalSupplyShares;\n\n        // new total shares are greater than old total shares && new total shares are greater than max supply shares\n        if (\n            (newTotalShares_ > (totalSupplyShares_ & X128)) && \n            newTotalShares_ > (totalSupplyShares_ >> 128)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__SupplySharesOverflow);\n        }\n\n        // keeping max supply shares intact\n        _totalSupplyShares = ((totalSupplyShares_ >> 128) << 128) | newTotalShares_;\n    }\n\n    function _updateBorrowShares(uint newTotalShares_) internal {\n        uint totalBorrowShares_ = _totalBorrowShares;\n\n        // new total shares are greater than old total shares && new total shares are greater than max borrow shares\n        if (\n            (newTotalShares_ > (totalBorrowShares_ & X128)) && \n            newTotalShares_ > (totalBorrowShares_ >> 128)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__BorrowSharesOverflow);\n        }\n\n        // keeping max borrow shares intact\n        _totalBorrowShares = ((totalBorrowShares_ >> 128) << 128) | newTotalShares_;\n    }\n\n    constructor(ConstantViews memory constantViews_) ImmutableVariables(constantViews_) {}\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/helpers/secondaryHelpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport { UserHelpers } from \"./userHelpers.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { AddressCalcs } from \"../../../../../libraries/addressCalcs.sol\";\n\nabstract contract SecondaryHelpers is UserHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) UserHelpers(constantViews_) {}\n\n    /// @param c_ tokenA amount to swap and deposit\n    /// @param d_ tokenB imaginary reserves\n    /// @param e_ tokenA imaginary reserves\n    /// @param f_ tokenA real reserves\n    /// @param i_ tokenB real reserves\n    function _getSwapAndDeposit(uint c_, uint d_, uint e_, uint f_, uint i_) internal pure returns (uint shares_) {\n        // swap and deposit in equal proportion\n\n        // tokenAx = c\n        // imaginaryTokenBReserves = d\n        // imaginaryTokenAReserves = e\n        // tokenAReserves = f\n        // tokenBReserves = i\n\n        // Quadratic equations, A, B & C are:\n        // A = i\n        // B = (ie - ic + dc + fd)\n        // C = -iec\n\n        // final equation:\n        // token to swap = (−(c⋅d−c⋅i+d⋅f+e⋅i) + (4⋅c⋅e⋅i^2 + (c⋅d−c⋅i+d⋅f+e⋅i)^2)^0.5) / 2⋅i\n        // B = (c⋅d−c⋅i+d⋅f+e⋅i)\n        // token to swap = (−B + (4⋅c⋅e⋅i^2 + (B)^2)^0.5) / 2⋅i\n        // simplifying above equation by dividing the entire equation by i:\n        // token to swap = (−B/i + (4⋅c⋅e + (B/i)^2)^0.5) / 2\n        // note: d > i always, so dividing won't be an issue\n\n        // temp_ => B/i\n        uint temp_ = (c_ * d_ + d_ * f_ + e_ * i_ - c_ * i_) / i_;\n        uint temp2_ = 4 * c_ * e_;\n        uint amtToSwap_ = (FixedPointMathLib.sqrt((temp2_ + (temp_ * temp_))) - temp_) / 2;\n\n        // Ensure the amount to swap is within reasonable bounds:\n        // - Not greater than 99.9999% of the input amount (c_)\n        // - Not less than 0.0001% of the input amount (c_)\n        // This prevents extreme scenarios and maybe potential precision issues\n        if ((amtToSwap_ > ((c_ * (SIX_DECIMALS - 1)) / SIX_DECIMALS)) || (amtToSwap_ < (c_ / SIX_DECIMALS)))\n            revert FluidDexError(ErrorTypes.DexT1__SwapAndDepositTooLowOrTooHigh);\n\n        // temp_ => amt0ToDeposit\n        temp_ = c_ - amtToSwap_;\n        // (imaginaryTokenBReserves * amtToSwap_) / (imaginaryTokenAReserves + amtToSwap_)\n        // temp2_ => amt1ToDeposit_\n        temp2_ = (d_ * amtToSwap_) / (e_ + amtToSwap_);\n\n        // temp_ => shares1\n        temp_ = (temp_ * 1e18) / (f_ + amtToSwap_);\n        // temp2_ => shares1\n        temp2_ = (temp2_ * 1e18) / (i_ - temp2_);\n        // temp_ & temp2 should be same. Although, due to some possible precision loss taking the lower one\n        shares_ = temp_ > temp2_ ? temp2_ : temp_;\n    }\n\n    /// @notice Updates collateral reserves based on minting or burning of shares\n    /// @param newShares_ The number of new shares being minted or burned\n    /// @param totalOldShares_ The total number of shares before the operation\n    /// @param c_ The current collateral reserves\n    /// @param mintOrBurn_ True if minting shares, false if burning shares\n    /// @return c2_ The updated collateral reserves after the operation\n    function _getUpdatedColReserves(\n        uint newShares_,\n        uint totalOldShares_,\n        CollateralReserves memory c_,\n        bool mintOrBurn_ // true if mint, false if burn\n    ) internal pure returns (CollateralReserves memory c2_) {\n        if (mintOrBurn_) {\n            // If minting, increase reserves proportionally to new shares\n            c2_.token0RealReserves = c_.token0RealReserves + (c_.token0RealReserves * newShares_) / totalOldShares_;\n            c2_.token1RealReserves = c_.token1RealReserves + (c_.token1RealReserves * newShares_) / totalOldShares_;\n            c2_.token0ImaginaryReserves =\n                c_.token0ImaginaryReserves +\n                (c_.token0ImaginaryReserves * newShares_) /\n                totalOldShares_;\n            c2_.token1ImaginaryReserves =\n                c_.token1ImaginaryReserves +\n                (c_.token1ImaginaryReserves * newShares_) /\n                totalOldShares_;\n        } else {\n            // If burning, decrease reserves proportionally to burned shares\n            c2_.token0RealReserves = c_.token0RealReserves - ((c_.token0RealReserves * newShares_) / totalOldShares_);\n            c2_.token1RealReserves = c_.token1RealReserves - ((c_.token1RealReserves * newShares_) / totalOldShares_);\n            c2_.token0ImaginaryReserves =\n                c_.token0ImaginaryReserves -\n                ((c_.token0ImaginaryReserves * newShares_) / totalOldShares_);\n            c2_.token1ImaginaryReserves =\n                c_.token1ImaginaryReserves -\n                ((c_.token1ImaginaryReserves * newShares_) / totalOldShares_);\n        }\n        return c2_;\n    }\n\n    /// @param c_ tokenA current real reserves (aka reserves before withdraw & swap)\n    /// @param d_ tokenB current real reserves (aka reserves before withdraw & swap)\n    /// @param e_ tokenA: final imaginary reserves - real reserves (aka reserves outside range after withdraw & swap)\n    /// @param f_ tokenB: final imaginary reserves - real reserves (aka reserves outside range after withdraw & swap)\n    /// @param g_ tokenA perfect amount to withdraw\n    function _getWithdrawAndSwap(uint c_, uint d_, uint e_, uint f_, uint g_) internal pure returns (uint shares_) {\n        // Equations we have:\n        // 1. tokenAxa / tokenBxb = tokenAReserves / tokenBReserves (Withdraw in equal proportion)\n        // 2. newTokenAReserves = tokenAReserves - tokenAxa\n        // 3. newTokenBReserves = tokenBReserves - tokenBxb\n        // 4 (known). finalTokenAReserves = tokenAReserves - tokenAx\n        // 5 (known). finalTokenBReserves = tokenBReserves\n\n        // Note: Xnew * Ynew = k = Xfinal * Yfinal (Xfinal & Yfinal is final imaginary reserve of token A & B).\n        // Now as we know finalTokenAReserves & finalTokenAReserves, hence we can also calculate\n        // imaginaryReserveMinusRealReservesA = finalImaginaryAReserves - finalTokenAReserves\n        // imaginaryReserveMinusRealReservesB = finalImaginaryBReserves - finalTokenBReserves\n        // Swaps only happen on real reserves hence before and after swap imaginaryReserveMinusRealReservesA &\n        // imaginaryReserveMinusRealReservesB should have exactly the same value.\n\n        // 6. newImaginaryTokenAReserves = imaginaryReserveMinusRealReservesA + newTokenAReserves\n        // newImaginaryTokenAReserves = imaginaryReserveMinusRealReservesA + tokenAReserves - tokenAxa\n        // 7. newImaginaryTokenBReserves = imaginaryReserveMinusRealReservesB + newTokenBReserves\n        // newImaginaryTokenBReserves = imaginaryReserveMinusRealReservesB + tokenBReserves - tokenBxb\n        // 8. tokenAxb = (newImaginaryTokenAReserves * tokenBxb) / (newImaginaryTokenBReserves + tokenBxb)\n        // 9. tokenAxa + tokenAxb = tokenAx\n\n        // simplifying knowns in 1 letter to make things clear:\n        // c = tokenAReserves\n        // d = tokenBReserves\n        // e = imaginaryReserveMinusRealReservesA\n        // f = imaginaryReserveMinusRealReservesB\n        // g = tokenAx\n\n        // A, B, C of quadratic are:\n        // A = d\n        // B = -(de + 2cd + cf)\n        // C = cfg + cdg\n\n        // tokenAxa = ((d⋅e + 2⋅c⋅d + c⋅f) - ((d⋅e + 2⋅c⋅d + c⋅f)^2 - 4⋅d⋅(c⋅f⋅g + c⋅d⋅g))^0.5) / 2d\n        // dividing 2d first to avoid overflowing\n        // B = (d⋅e + 2⋅c⋅d + c⋅f) / 2d\n        // (B - ((B)^2 - (4⋅d⋅(c⋅f⋅g + c⋅d⋅g) / 4⋅d^2))^0.5)\n        // (B - ((B)^2 - ((c⋅f⋅g + c⋅d⋅g) / d))^0.5)\n\n        // temp_ = B/2A\n        uint temp_ = (d_ * e_ + 2 * c_ * d_ + c_ * f_) / (2 * d_);\n        // temp2_ = 4AC / 4A^2 = C / A\n        // to avoid overflowing in any case multiplying with g_ later\n        uint temp2_ = (((c_ * f_) / d_) + c_) * g_;\n\n        // tokenAxa = (-B - (B^2 - 4AC)^0.5) / 2A\n        uint tokenAxa_ = temp_ - FixedPointMathLib.sqrt((temp_ * temp_) - temp2_);\n\n        // Ensure the amount to withdraw is within reasonable bounds:\n        // - Not greater than 99.9999% of the input amount (g_)\n        // - Not less than 0.0001% of the input amount (g_)\n        // This prevents extreme scenarios and maybe potential precision issues\n        if (tokenAxa_ > ((g_ * SIX_DECIMALS - 1) / SIX_DECIMALS) || tokenAxa_ < (g_ / SIX_DECIMALS))\n            revert FluidDexError(ErrorTypes.DexT1__WithdrawAndSwapTooLowOrTooHigh);\n\n        shares_ = (tokenAxa_ * 1e18) / c_;\n    }\n\n    /// @param c_ tokenA current debt before swap (aka debt before borrow & swap)\n    /// @param d_ tokenB current debt before swap (aka debt before borrow & swap)\n    /// @param e_ tokenA final imaginary reserves (reserves after borrow & swap)\n    /// @param f_ tokenB final imaginary reserves (reserves after borrow & swap)\n    /// @param g_ tokenA perfect amount to borrow\n    function _getBorrowAndSwap(uint c_, uint d_, uint e_, uint f_, uint g_) internal pure returns (uint shares_) {\n        // 1. tokenAxa / tokenADebt = tokenBxb / tokenBDebt (borrowing in equal proportion)\n        // 2. newImaginaryTokenAReserves = tokenAFinalImaginaryReserves + tokenAxb\n        // 3. newImaginaryTokenBReserves = tokenBFinalImaginaryReserves - tokenBxb\n        // // Note: I assumed reserve of tokenA and debt of token A while solving which is fine.\n        // // But in other places I use debtA to find reserveB\n        // 4. tokenAxb = (newImaginaryTokenAReserves * tokenBxb) / (newImaginaryTokenBReserves + tokenBxb)\n        // 5. tokenAxa + tokenAxb = tokenAx\n\n        // Inserting 2 & 3 into 4:\n        // 6. tokenAxb = ((tokenAFinalImaginaryReserves + tokenAxb) * tokenBxb) / ((tokenBFinalImaginaryReserves - tokenBxb) + tokenBxb)\n        // 6. tokenAxb = ((tokenAFinalImaginaryReserves + tokenAxb) * tokenBxb) / (tokenBFinalImaginaryReserves)\n\n        // Making 1 in terms of tokenBxb:\n        // 1. tokenBxb = tokenAxa * tokenBDebt / tokenADebt\n\n        // Inserting 5 into 6:\n        // 7. (tokenAx - tokenAxa) = ((tokenAFinalImaginaryReserves + (tokenAx - tokenAxa)) * tokenBxb) / (tokenBFinalImaginaryReserves)\n\n        // Inserting 1 into 7:\n        // 8. (tokenAx - tokenAxa) * tokenBFinalImaginaryReserves = ((tokenAFinalImaginaryReserves + (tokenAx - tokenAxa)) * (tokenAxa * tokenBDebt / tokenADebt))\n\n        // Replacing knowns with:\n        // c = tokenADebt\n        // d = tokenBDebt\n        // e = tokenAFinalImaginaryReserves\n        // f = tokenBFinalImaginaryReserves\n        // g = tokenAx\n\n        // 8. (g - tokenAxa) * f * c = ((e + (g - tokenAxa)) * (tokenAxa * d))\n        // 8. cfg - cf*tokenAxa = de*tokenAxa + dg*tokenAxa - d*tokenAxa^2\n        // 8. d*tokenAxa^2 - cf*tokenAxa - de*tokenAxa - dg*tokenAxa + cfg = 0\n        // 8. d*tokenAxa^2 - (cf + de + dg)*tokenAxa + cfg = 0\n\n        // A, B, C of quadratic are:\n        // A = d\n        // B = -(cf + de + dg)\n        // C = cfg\n\n        // temp_ = B/2A\n        uint temp_ = (c_ * f_ + d_ * e_ + d_ * g_) / (2 * d_);\n\n        // temp2_ = 4AC / 4A^2 = C / A\n        // to avoid overflowing in any case multiplying with g_ later\n        uint temp2_ = (c_ * f_ * g_) / d_;\n\n        // tokenAxa = (-B - (B^2 - 4AC)^0.5) / 2A\n        uint tokenAxa_ = temp_ - FixedPointMathLib.sqrt((temp_ * temp_) - temp2_);\n\n        // Ensure the amount to borrow is within reasonable bounds:\n        // - Not greater than 99.9999% of the input amount (g_)\n        // - Not less than 0.0001% of the input amount (g_)\n        // This prevents extreme scenarios and maybe potential precision issues\n        if (tokenAxa_ > ((g_ * SIX_DECIMALS - 1) / SIX_DECIMALS) || tokenAxa_ < (g_ / SIX_DECIMALS))\n            revert FluidDexError(ErrorTypes.DexT1__BorrowAndSwapTooLowOrTooHigh);\n\n        // rounding up borrow shares to mint for user\n        shares_ = ((tokenAxa_ + 1) * 1e18) / c_;\n    }\n\n    /// @notice Updates debt and reserves based on minting or burning shares\n    /// @param shares_ The number of shares to mint or burn\n    /// @param totalShares_ The total number of shares before the operation\n    /// @param d_ The current debt and reserves\n    /// @param mintOrBurn_ True if minting, false if burning\n    /// @return d2_ The updated debt and reserves\n    /// @dev This function calculates the new debt and reserves when minting or burning shares.\n    /// @dev It updates the following for both tokens:\n    /// @dev - Debt\n    /// @dev - Real Reserves\n    /// @dev - Imaginary Reserves\n    /// @dev The calculation is done proportionally based on the ratio of shares to total shares.\n    /// @dev For minting, it adds the proportional amount.\n    /// @dev For burning, it subtracts the proportional amount.\n    function _getUpdateDebtReserves(\n        uint shares_,\n        uint totalShares_,\n        DebtReserves memory d_,\n        bool mintOrBurn_ // true if mint, false if burn\n    ) internal pure returns (DebtReserves memory d2_) {\n        if (mintOrBurn_) {\n            d2_.token0Debt = d_.token0Debt + (d_.token0Debt * shares_) / totalShares_;\n            d2_.token1Debt = d_.token1Debt + (d_.token1Debt * shares_) / totalShares_;\n            d2_.token0RealReserves = d_.token0RealReserves + (d_.token0RealReserves * shares_) / totalShares_;\n            d2_.token1RealReserves = d_.token1RealReserves + (d_.token1RealReserves * shares_) / totalShares_;\n            d2_.token0ImaginaryReserves =\n                d_.token0ImaginaryReserves +\n                (d_.token0ImaginaryReserves * shares_) /\n                totalShares_;\n            d2_.token1ImaginaryReserves =\n                d_.token1ImaginaryReserves +\n                (d_.token1ImaginaryReserves * shares_) /\n                totalShares_;\n        } else {\n            d2_.token0Debt = d_.token0Debt - (d_.token0Debt * shares_) / totalShares_;\n            d2_.token1Debt = d_.token1Debt - (d_.token1Debt * shares_) / totalShares_;\n            d2_.token0RealReserves = d_.token0RealReserves - (d_.token0RealReserves * shares_) / totalShares_;\n            d2_.token1RealReserves = d_.token1RealReserves - (d_.token1RealReserves * shares_) / totalShares_;\n            d2_.token0ImaginaryReserves =\n                d_.token0ImaginaryReserves -\n                (d_.token0ImaginaryReserves * shares_) /\n                totalShares_;\n            d2_.token1ImaginaryReserves =\n                d_.token1ImaginaryReserves -\n                (d_.token1ImaginaryReserves * shares_) /\n                totalShares_;\n        }\n\n        return d2_;\n    }\n\n    /// @param a_ tokenA new imaginary reserves (imaginary reserves after perfect payback but not swap yet)\n    /// @param b_ tokenB new imaginary reserves (imaginary reserves after perfect payback but not swap yet)\n    /// @param c_ tokenA current debt\n    /// @param d_ tokenB current debt & final debt (tokenB current & final debt remains same)\n    /// @param i_ tokenA new reserves (reserves after perfect payback but not swap yet)\n    /// @param j_ tokenB new reserves (reserves after perfect payback but not swap yet)\n    function _getSwapAndPaybackOneTokenPerfectShares(\n        uint a_,\n        uint b_,\n        uint c_,\n        uint d_,\n        uint i_,\n        uint j_\n    ) internal pure returns (uint tokenAmt_) {\n        // l_ => tokenA reserves outside range\n        uint l_ = a_ - i_;\n        // m_ => tokenB reserves outside range\n        uint m_ = b_ - j_;\n        // w_ => new K or final K will be same, xy = k\n        uint w_ = a_ * b_;\n        // z_ => final reserveB full, when entire debt is in tokenA\n        uint z_ = w_ / l_;\n        // y_ => final reserveA full, when entire debt is in tokenB\n        uint y_ = w_ / m_;\n        // v_ = final reserveB\n        uint v_ = z_ - m_ - d_;\n        // x_ = final tokenA debt\n        uint x_ = (v_ * y_) / (m_ + v_);\n\n        // amountA to payback, this amount will get swapped into tokenB to payback in perfect proportion\n        tokenAmt_ = c_ - x_;\n\n        // Ensure the amount to swap and payback is within reasonable bounds:\n        // - Not greater than 99.9999% of the current debt (c_)\n        // This prevents extreme scenarios where almost all debt is getting paid after swap,\n        // which could maybe lead to precision issues & edge cases\n        if ((tokenAmt_ > (c_ * (SIX_DECIMALS - 1)) / SIX_DECIMALS))\n            revert FluidDexError(ErrorTypes.DexT1__SwapAndPaybackTooLowOrTooHigh);\n    }\n\n    /// @param c_ tokenA debt before swap & payback\n    /// @param d_ tokenB debt before swap & payback\n    /// @param e_ tokenA imaginary reserves before swap & payback\n    /// @param f_ tokenB imaginary reserves before swap & payback\n    /// @param g_ tokenA perfect amount to payback\n    function _getSwapAndPayback(uint c_, uint d_, uint e_, uint f_, uint g_) internal pure returns (uint shares_) {\n        // 1. tokenAxa / newTokenADebt = tokenBxb / newTokenBDebt (borrowing in equal proportion)\n        // 2. newTokenADebt = tokenADebt - tokenAxb\n        // 3. newTokenBDebt = tokenBDebt + tokenBxb\n        // 4. imaginaryTokenAReserves = Calculated above from debtA\n        // 5. imaginaryTokenBReserves = Calculated above from debtA\n        // // Note: I assumed reserveA and debtA for same tokenA\n        // // But in other places I used debtA to find reserveB\n        // 6. tokenBxb = (imaginaryTokenBReserves * tokenAxb) / (imaginaryTokenAReserves + tokenAxb)\n        // 7. tokenAxa + tokenAxb = tokenAx\n\n        // Unknowns in the above equations are:\n        // tokenAxa, tokenAxb, tokenBxb\n\n        // simplifying knowns in 1 letter to make things clear:\n        // c = tokenADebt\n        // d = tokenBDebt\n        // e = imaginaryTokenAReserves\n        // f = imaginaryTokenBReserves\n        // g = tokenAx\n\n        // Restructuring 1:\n        // 1. newTokenBDebt = (tokenBxb * newTokenADebt) / tokenAxa\n\n        // Inserting 1 in 3:\n        // 8. (tokenBxb * newTokenADebt) / tokenAxa = tokenBDebt + tokenBxb\n\n        // Refactoring 8 w.r.t tokenBxb:\n        // 8. (tokenBxb * newTokenADebt) - tokenAxa * tokenBxb = tokenBDebt * tokenAxa\n        // 8. tokenBxb * (newTokenADebt - tokenAxa) = tokenBDebt * tokenAxa\n        // 8. tokenBxb = (tokenBDebt * tokenAxa) / (newTokenADebt - tokenAxa)\n\n        // Inserting 2 in 8:\n        // 9. tokenBxb = (tokenBDebt * tokenAxa) / (tokenADebt - tokenAxb - tokenAxa)\n        // 9. tokenBxb = (tokenBDebt * tokenAxa) / (tokenADebt - tokenAx)\n\n        // Inserting 9 in 6:\n        // 10. (tokenBDebt * tokenAxa) / (tokenADebt - tokenAx) = (imaginaryTokenBReserves * tokenAxb) / (imaginaryTokenAReserves + tokenAxb)\n        // 10. (tokenBDebt * (tokenAx - tokenAxb)) / (tokenADebt - tokenAx) = (imaginaryTokenBReserves * tokenAxb) / (imaginaryTokenAReserves + tokenAxb)\n\n        // Replacing with single digits:\n        // 10. (d * (g - tokenAxb)) / (c - g) = (f * tokenAxb) / (e + tokenAxb)\n        // 10. d * (g - tokenAxb) * (e + tokenAxb) = (f * tokenAxb) * (c - g)\n        // 10. deg + dg*tokenAxb - de*tokenAxb - d*tokenAxb^2 = cf*tokenAxb - fg*tokenAxb\n        // 10. d*tokenAxb^2 + cf*tokenAxb - fg*tokenAxb + de*tokenAxb - dg*tokenAxb - deg = 0\n        // 10. d*tokenAxb^2 + (cf - fg + de - dg)*tokenAxb - deg = 0\n\n        // A = d\n        // B = (cf + de - fg - dg)\n        // C = -deg\n\n        // Solving Quadratic will give the value for tokenAxb, now that \"tokenAxb\" is known we can also know:\n        // tokenAxa & tokenBxb\n\n        // temp_ => B/A\n        uint temp_ = (c_ * f_ + d_ * e_ - f_ * g_ - d_ * g_) / d_;\n\n        // temp2_ = -AC / A^2\n        uint temp2_ = 4 * e_ * g_;\n\n        uint amtToSwap_ = (FixedPointMathLib.sqrt((temp2_ + (temp_ * temp_))) - temp_) / 2;\n\n        // Ensure the amount to swap is within reasonable bounds:\n        // - Not greater than 99.9999% of the input amount (g_)\n        // - Not less than 0.0001% of the input amount (g_)\n        // This prevents extreme scenarios and maybe potential precision issues\n        if ((amtToSwap_ > (g_ * (SIX_DECIMALS - 1)) / SIX_DECIMALS) || (amtToSwap_ < (g_ / SIX_DECIMALS)))\n            revert FluidDexError(ErrorTypes.DexT1__SwapAndPaybackTooLowOrTooHigh);\n\n        // temp_ => amt0ToPayback\n        temp_ = g_ - amtToSwap_;\n        // (imaginaryTokenBReserves * amtToSwap_) / (imaginaryTokenAReserves + amtToSwap_)\n        // temp2_ => amt1ToPayback\n        temp2_ = (f_ * amtToSwap_) / (e_ + amtToSwap_);\n\n        // temp_ => shares0\n        temp_ = (temp_ * 1e18) / (c_ - amtToSwap_);\n        // temp_ => shares1\n        temp2_ = (temp2_ * 1e18) / (d_ + temp2_);\n        // temp_ & temp2 should be same. Although, due to some possible precision loss taking the lower one\n        shares_ = temp_ > temp2_ ? temp2_ : temp_;\n    }\n\n    /// @dev This function performs arbitrage between the collateral and debt pools\n    /// @param dexVariables_ The current state of dex variables\n    /// @param dexVariables2_ Additional dex variables\n    /// @param pex_ Struct containing prices and exchange rates\n    /// @notice This function is called after user operations to balance the pools\n    /// @notice It swaps tokens between the collateral and debt pools to align their prices\n    /// @notice The function updates the oracle price based on the arbitrage results\n    function _arbitrage(uint dexVariables_, uint dexVariables2_, PricesAndExchangePrice memory pex_) internal {\n        if ((dexVariables2_ >> 255) == 1) revert FluidDexError(ErrorTypes.DexT1__SwapAndArbitragePaused);\n\n        CollateralReserves memory c_;\n        DebtReserves memory d_;\n        uint price_;\n        if ((dexVariables2_ & 1) == 1) {\n            c_ = _getCollateralReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.supplyToken0ExchangePrice,\n                pex_.supplyToken1ExchangePrice\n            );\n        }\n        if ((dexVariables2_ & 2) == 2) {\n            d_ = _getDebtReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.borrowToken0ExchangePrice,\n                pex_.borrowToken1ExchangePrice\n            );\n        }\n        if ((dexVariables2_ & 3) < 3) {\n            price_ = ((dexVariables2_ & 1) == 1)\n                ? ((c_.token1ImaginaryReserves) * 1e27) / (c_.token0ImaginaryReserves)\n                : ((d_.token1ImaginaryReserves) * 1e27) / (d_.token0ImaginaryReserves);\n            // arbitrage should only happen if both smart debt & smart collateral are enabled\n            // Storing in storage, it will also uninitialize re-entrancy\n            dexVariables = _updateOracle(price_, pex_.centerPrice, dexVariables_);\n            return;\n        }\n\n        uint temp_;\n        uint amtOut_;\n        uint amtIn_;\n\n        // both smart debt & smart collateral enabled\n\n        // always swapping token0 into token1\n        int a_ = _swapRoutingIn(\n            0,\n            c_.token1ImaginaryReserves,\n            c_.token0ImaginaryReserves,\n            d_.token1ImaginaryReserves,\n            d_.token0ImaginaryReserves\n        );\n        if (a_ > 0) {\n            // swap will route through col pool\n            temp_ = uint(a_);\n            amtOut_ = _getAmountOut(temp_, c_.token0ImaginaryReserves, c_.token1ImaginaryReserves);\n            amtIn_ = _getAmountIn(temp_, d_.token1ImaginaryReserves, d_.token0ImaginaryReserves);\n\n            // new pool price\n            // debt pool price will be the same as collateral pool after the swap\n            // note: updating price here as in next line amtOut_ will get updated to normal amounts\n            price_ = ((c_.token1ImaginaryReserves - amtOut_) * 1e27) / (c_.token0ImaginaryReserves + temp_);\n\n            // converting into normal token form from DEX precisions\n            a_ = (((a_) * int(TOKEN_0_DENOMINATOR_PRECISION)) / int(TOKEN_0_NUMERATOR_PRECISION));\n            amtOut_ = (((amtOut_) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n            amtIn_ = (((amtIn_) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n\n            // deposit token0 and borrow token0\n            // withdraw token1 and payback token1\n            LIQUIDITY.operate(TOKEN_0, a_, a_, address(0), address(this), abi.encode(SKIP_TRANSFERS, address(this)));\n            LIQUIDITY.operate(\n                TOKEN_1,\n                -int(amtOut_),\n                -int(amtIn_),\n                address(this),\n                address(0),\n                abi.encode(SKIP_TRANSFERS, address(this))\n            );\n        } else if (a_ < 0) {\n            // swap will route through debt pool\n            temp_ = uint(-a_);\n            amtOut_ = _getAmountOut(temp_, d_.token0ImaginaryReserves, d_.token1ImaginaryReserves);\n            amtIn_ = _getAmountIn(temp_, c_.token1ImaginaryReserves, c_.token0ImaginaryReserves);\n\n            // new pool price\n            // debt pool price will be the same as collateral pool after the swap\n            // note: updating price here as in next line amtOut_ will get updated to normal amounts\n            price_ = ((d_.token1ImaginaryReserves - amtOut_) * 1e27) / (d_.token0ImaginaryReserves + temp_);\n\n            // converting into normal token form from DEX precisions\n            a_ = ((a_ * int(TOKEN_0_DENOMINATOR_PRECISION)) / int(TOKEN_0_NUMERATOR_PRECISION));\n            amtOut_ = ((amtOut_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n            amtIn_ = (((amtIn_) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n\n            // payback token0 and withdraw token0\n            // deposit token1 and borrow token1\n            LIQUIDITY.operate(TOKEN_0, a_, a_, address(this), address(0), abi.encode(SKIP_TRANSFERS, address(this)));\n            LIQUIDITY.operate(\n                TOKEN_1,\n                int(amtIn_),\n                int(amtOut_),\n                address(0),\n                address(this),\n                abi.encode(SKIP_TRANSFERS, address(this))\n            );\n        } else {\n            // reverting if nothing to arbitrage. Naturally to get here will have very low probability\n            revert FluidDexError(ErrorTypes.DexT1__NothingToArbitrage);\n        }\n\n        // if hook exists then calling hook\n        temp_ = (dexVariables2_ >> 142) & X30;\n        if (temp_ > 0) {\n            uint lastPrice_ = (dexVariables_ >> 41) & X40;\n            lastPrice_ = (lastPrice_ >> DEFAULT_EXPONENT_SIZE) << (lastPrice_ & DEFAULT_EXPONENT_MASK);\n            _hookVerify(temp_, 2, lastPrice_ > price_, price_);\n        }\n\n        // Storing in storage, it will also uninitialize re-entrancy\n        dexVariables = _updateOracle(price_, pex_.centerPrice, dexVariables_);\n\n        emit LogArbitrage(a_, amtOut_);\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/helpers/userHelpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport { CoreHelpers } from \"./coreHelpers.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { LiquidityCalcs } from \"../../../../../libraries/liquidityCalcs.sol\";\n\nabstract contract UserHelpers is CoreHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) CoreHelpers(constantViews_) {}\n\n    function _verifyMint(uint amt_, uint totalAmt_) internal pure {\n        // not minting too less shares or too more\n        // If totalAmt_ is worth $1 then user can at max mint $1B of new amt_ at once.\n        // If totalAmt_ is worth $1B then user have to mint min of $1 of amt_.\n        if (amt_ < (totalAmt_ / NINE_DECIMALS) || amt_ > (totalAmt_ * NINE_DECIMALS)) {\n            revert FluidDexError(ErrorTypes.DexT1__MintAmtOverflow);\n        }\n    }\n\n    function _verifyRedeem(uint amt_, uint totalAmt_) internal pure {\n        // If burning of amt_ is > 99.99% of totalAmt_ at once, then revert.\n        if (amt_ > ((totalAmt_ * 9999) / FOUR_DECIMALS)) {\n            revert FluidDexError(ErrorTypes.DexT1__BurnAmtOverflow);\n        }\n    }\n\n    function _getExchangePrices() internal view returns (ExchangePrices memory ex_) {\n        // Exchange price will remain same as Liquidity Layer\n        (ex_.supplyToken0ExchangePrice, ex_.borrowToken0ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_0_SLOT)\n        );\n\n        (ex_.supplyToken1ExchangePrice, ex_.borrowToken1ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_1_SLOT)\n        );\n    }\n\n    function _updatingUserSupplyDataOnStorage(\n        uint userSupplyData_,\n        uint userSupply_,\n        uint newWithdrawalLimit_\n    ) internal {\n        // calculate withdrawal limit to store as previous withdrawal limit in storage\n        newWithdrawalLimit_ = DexCalcs.calcWithdrawalLimitAfterOperate(\n            userSupplyData_,\n            userSupply_,\n            newWithdrawalLimit_\n        );\n\n        userSupply_ = userSupply_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_DOWN\n        );\n\n        newWithdrawalLimit_ = newWithdrawalLimit_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_DOWN\n        );\n\n        if (((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64) == userSupply_) {\n            // make sure that shares amount is not so small that it wouldn't affect storage update. if a difference\n            // is present then rounding will be in the right direction to avoid any potential manipulation.\n            revert FluidDexError(ErrorTypes.DexT1__SharesAmountInsufficient);\n        }\n\n        // Updating on storage, copied exactly the same from Liquidity Layer\n        _userSupplyData[msg.sender] =\n            // mask to update bits 1-161 (supply amount, withdrawal limit, timestamp)\n            (userSupplyData_ & 0xfffffffffffffffffffffffc0000000000000000000000000000000000000001) |\n            (userSupply_ << DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) | // converted to BigNumber can not overflow\n            (newWithdrawalLimit_ << DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) | // converted to BigNumber can not overflow\n            (block.timestamp << DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP);\n    }\n\n    function _updatingUserBorrowDataOnStorage(uint userBorrowData_, uint userBorrow_, uint newBorrowLimit_) internal {\n        // calculate borrow limit to store as previous borrow limit in storage\n        newBorrowLimit_ = DexCalcs.calcBorrowLimitAfterOperate(userBorrowData_, userBorrow_, newBorrowLimit_);\n\n        // Converting user's borrowings into bignumber\n        userBorrow_ = userBorrow_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_UP\n        );\n\n        // Converting borrow limit into bignumber\n        newBorrowLimit_ = newBorrowLimit_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_DOWN\n        );\n\n        if (((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64) == userBorrow_) {\n            // make sure that shares amount is not so small that it wouldn't affect storage update. if a difference\n            // is present then rounding will be in the right direction to avoid any potential manipulation.\n            revert FluidDexError(ErrorTypes.DexT1__SharesAmountInsufficient);\n        }\n\n        // Updating on storage, copied exactly the same from Liquidity Layer\n        _userBorrowData[msg.sender] =\n            // mask to update bits 1-161 (borrow amount, borrow limit, timestamp)\n            (userBorrowData_ & 0xfffffffffffffffffffffffc0000000000000000000000000000000000000001) |\n            (userBorrow_ << DexSlotsLink.BITS_USER_BORROW_AMOUNT) | // converted to BigNumber can not overflow\n            (newBorrowLimit_ << DexSlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) | // converted to BigNumber can not overflow\n            (block.timestamp << DexSlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP);\n    }\n\n    /// @notice Deposits or pays back in liquidity\n    /// @param token_ The token to deposit or pay back\n    /// @param depositAmt_ The amount to deposit\n    /// @param paybackAmt_ The amount to pay back\n    function _depositOrPaybackInLiquidity(address token_, uint depositAmt_, uint paybackAmt_) internal {\n        // both cannot be greater than 0\n        // if both are 0 then liquidity layer will revert\n        // only 1 should be greater than 0\n        if (depositAmt_ > 0 && paybackAmt_ > 0) revert();\n        if (token_ == NATIVE_TOKEN) {\n            uint amt_ = depositAmt_ > 0 ? depositAmt_ : paybackAmt_;\n            if (msg.value > amt_) {\n                SafeTransfer.safeTransferNative(msg.sender, msg.value - amt_);\n            } else if (msg.value < amt_) {\n                revert FluidDexError(ErrorTypes.DexT1__MsgValueLowOnDepositOrPayback);\n            }\n            LIQUIDITY.operate{ value: amt_ }(\n                token_,\n                int(depositAmt_),\n                -int(paybackAmt_),\n                address(0),\n                address(0),\n                new bytes(0)\n            );\n        } else {\n            LIQUIDITY.operate(\n                token_,\n                int(depositAmt_),\n                -int(paybackAmt_),\n                address(0),\n                address(0),\n                abi.encode((depositAmt_ + paybackAmt_), true, msg.sender)\n            );\n        }\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/immutableVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../../../liquidity/interfaces/iLiquidity.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { ConstantVariables } from \"../common/constantVariables.sol\";\nimport { IFluidDexFactory } from \"../../interfaces/iDexFactory.sol\";\nimport { Error } from \"../../error.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\n\nabstract contract ImmutableVariables is ConstantVariables, Structs, Error {\n    /*//////////////////////////////////////////////////////////////\n                          CONSTANTS / IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public immutable DEX_ID;\n\n    /// @dev Address of token 0\n    address internal immutable TOKEN_0;\n\n    /// @dev Address of token 1\n    address internal immutable TOKEN_1;\n\n    address internal immutable THIS_CONTRACT;\n\n    uint256 internal immutable TOKEN_0_NUMERATOR_PRECISION;\n    uint256 internal immutable TOKEN_0_DENOMINATOR_PRECISION;\n    uint256 internal immutable TOKEN_1_NUMERATOR_PRECISION;\n    uint256 internal immutable TOKEN_1_DENOMINATOR_PRECISION;\n\n    /// @dev Address of liquidity contract\n    IFluidLiquidity internal immutable LIQUIDITY;\n\n    /// @dev Address of DEX factory contract\n    IFluidDexFactory internal immutable DEX_FACTORY;\n\n    /// @dev Address of Shift implementation\n    address internal immutable SHIFT_IMPLEMENTATION;\n\n    /// @dev Address of Admin implementation\n    address internal immutable ADMIN_IMPLEMENTATION;\n\n    /// @dev Address of Col Operations implementation\n    address internal immutable COL_OPERATIONS_IMPLEMENTATION;\n\n    /// @dev Address of Debt Operations implementation\n    address internal immutable DEBT_OPERATIONS_IMPLEMENTATION;\n\n    /// @dev Address of Perfect Operations and Swap Out implementation\n    address internal immutable PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION;\n\n    /// @dev Address of contract used for deploying center price & hook related contract\n    address internal immutable DEPLOYER_CONTRACT;\n\n    /// @dev Liquidity layer slots\n    bytes32 internal immutable SUPPLY_TOKEN_0_SLOT;\n    bytes32 internal immutable BORROW_TOKEN_0_SLOT;\n    bytes32 internal immutable SUPPLY_TOKEN_1_SLOT;\n    bytes32 internal immutable BORROW_TOKEN_1_SLOT;\n    bytes32 internal immutable EXCHANGE_PRICE_TOKEN_0_SLOT;\n    bytes32 internal immutable EXCHANGE_PRICE_TOKEN_1_SLOT;\n    uint256 internal immutable TOTAL_ORACLE_MAPPING;\n\n    function _calcNumeratorAndDenominator(\n        address token_\n    ) private view returns (uint256 numerator_, uint256 denominator_) {\n        uint256 decimals_ = _decimals(token_);\n        if (decimals_ > TOKENS_DECIMALS_PRECISION) {\n            numerator_ = 1;\n            denominator_ = 10 ** (decimals_ - TOKENS_DECIMALS_PRECISION);\n        } else {\n            numerator_ = 10 ** (TOKENS_DECIMALS_PRECISION - decimals_);\n            denominator_ = 1;\n        }\n    }\n\n    constructor(ConstantViews memory constants_) {\n        THIS_CONTRACT = address(this);\n\n        DEX_ID = constants_.dexId;\n        LIQUIDITY = IFluidLiquidity(constants_.liquidity);\n        DEX_FACTORY = IFluidDexFactory(constants_.factory);\n\n        TOKEN_0 = constants_.token0;\n        TOKEN_1 = constants_.token1;\n\n        if (TOKEN_0 >= TOKEN_1) revert FluidDexError(ErrorTypes.DexT1__Token0ShouldBeSmallerThanToken1);\n\n        (TOKEN_0_NUMERATOR_PRECISION, TOKEN_0_DENOMINATOR_PRECISION) = _calcNumeratorAndDenominator(TOKEN_0);\n        (TOKEN_1_NUMERATOR_PRECISION, TOKEN_1_DENOMINATOR_PRECISION) = _calcNumeratorAndDenominator(TOKEN_1);\n\n        if (constants_.implementations.shift != address(0)) {\n            SHIFT_IMPLEMENTATION = constants_.implementations.shift;\n        } else {\n            SHIFT_IMPLEMENTATION = address(this);\n        }\n        if (constants_.implementations.admin != address(0)) {\n            ADMIN_IMPLEMENTATION = constants_.implementations.admin;\n        } else {\n            ADMIN_IMPLEMENTATION = address(this);\n        }\n        if (constants_.implementations.colOperations != address(0)) {\n            COL_OPERATIONS_IMPLEMENTATION = constants_.implementations.colOperations;\n        } else {\n            COL_OPERATIONS_IMPLEMENTATION = address(this);\n        }\n        if (constants_.implementations.debtOperations != address(0)) {\n            DEBT_OPERATIONS_IMPLEMENTATION = constants_.implementations.debtOperations;\n        } else {\n            DEBT_OPERATIONS_IMPLEMENTATION = address(this);\n        }\n        if (constants_.implementations.perfectOperationsAndSwapOut != address(0)) {\n            PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION = constants_.implementations.perfectOperationsAndSwapOut;\n        } else {\n            PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION = address(this);\n        }\n\n        DEPLOYER_CONTRACT = constants_.deployerContract;\n\n        SUPPLY_TOKEN_0_SLOT = constants_.supplyToken0Slot;\n        BORROW_TOKEN_0_SLOT = constants_.borrowToken0Slot;\n        SUPPLY_TOKEN_1_SLOT = constants_.supplyToken1Slot;\n        BORROW_TOKEN_1_SLOT = constants_.borrowToken1Slot;\n        EXCHANGE_PRICE_TOKEN_0_SLOT = constants_.exchangePriceToken0Slot;\n        EXCHANGE_PRICE_TOKEN_1_SLOT = constants_.exchangePriceToken1Slot;\n\n        if (constants_.oracleMapping > X16) revert FluidDexError(ErrorTypes.DexT1__OracleMappingOverflow);\n\n        TOTAL_ORACLE_MAPPING = constants_.oracleMapping;\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/interfaces.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ninterface IHook {\n    /// @notice Hook function to check for liquidation opportunities before external swaps\n    /// @dev The primary use of this hook is to check if a particular pair vault has liquidation available.\n    ///      If liquidation is available, it gives priority to the liquidation process before allowing external swaps.\n    ///      In most cases, this hook will not be set.\n    /// @param id_ Identifier for the operation type: 1 for swap, 2 for internal arbitrage\n    /// @param swap0to1_ Direction of the swap: true if swapping token0 for token1, false otherwise\n    /// @param token0_ Address of the first token in the pair\n    /// @param token1_ Address of the second token in the pair\n    /// @param price_ The price ratio of token1 to token0, expressed with 27 decimal places\n    /// @return isOk_ Boolean indicating whether the operation should proceed\n    function dexPrice(\n        uint id_,\n        bool swap0to1_,\n        address token0_,\n        address token1_,\n        uint price_\n    ) external returns (bool isOk_);\n}\n\ninterface ICenterPrice {\n    /// @notice Retrieves the center price for the pool\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\n    /// @return price The current price ratio of token1 to token0, expressed with 27 decimal places\n    function centerPrice() external returns (uint price);\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct ExchangePrices {\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct CollateralReservesSwap {\n        uint tokenInRealReserves;\n        uint tokenOutRealReserves;\n        uint tokenInImaginaryReserves;\n        uint tokenOutImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReservesSwap {\n        uint tokenInDebt;\n        uint tokenOutDebt;\n        uint tokenInRealReserves;\n        uint tokenOutRealReserves;\n        uint tokenInImaginaryReserves;\n        uint tokenOutImaginaryReserves;\n    }\n\n    struct SwapInMemory {\n        address tokenIn;\n        address tokenOut;\n        uint256 amtInAdjusted;\n        address withdrawTo;\n        address borrowTo;\n        uint price; // price of pool after swap\n        uint fee; // fee of pool\n        uint revenueCut; // revenue cut of pool\n        bool swap0to1;\n        int swapRoutingAmt;\n        bytes data; // just added to avoid stack-too-deep error\n    }\n\n    struct SwapOutMemory {\n        address tokenIn;\n        address tokenOut;\n        uint256 amtOutAdjusted;\n        address withdrawTo;\n        address borrowTo;\n        uint price; // price of pool after swap\n        uint fee;\n        uint revenueCut; // revenue cut of pool\n        bool swap0to1;\n        int swapRoutingAmt;\n        bytes data; // just added to avoid stack-too-deep error\n        uint msgValue;\n    }\n\n    struct DepositColMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0ReservesInitial;\n        uint256 token1ReservesInitial;\n    }\n\n    struct WithdrawColMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0ReservesInitial;\n        uint256 token1ReservesInitial;\n        address to;\n    }\n\n    struct BorrowDebtMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0DebtInitial;\n        uint256 token1DebtInitial;\n        address to;\n    }\n\n    struct PaybackDebtMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0DebtInitial;\n        uint256 token1DebtInitial;\n    }\n\n    struct OraclePriceMemory {\n        uint lowestPrice1by0;\n        uint highestPrice1by0;\n        uint oracleSlot;\n        uint oracleMap;\n        uint oracle;\n    }\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndSwapOut;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVault.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\ninterface IFluidVault {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice returns the vault id\n    function TYPE() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Tokens {\n        address token0;\n        address token1;\n    }\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address operateImplementation;\n        address adminImplementation;\n        address secondaryImplementation;\n        address deployer; // address which deploys oracle\n        address supply; // either liquidity layer or DEX protocol\n        address borrow; // either liquidity layer or DEX protocol\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\n        uint256 vaultId;\n        uint256 vaultType;\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n\n    function rebalance(\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_\n    ) external returns (int supplyAmt_, int borrowAmt_);\n\n    /// @notice reverts with FluidLiquidateResult\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\ninterface IFluidVaultFactory is IERC721Enumerable {\n    /// @notice Minting an NFT Vault for the user\n    function mint(uint256 vaultId_, address user_) external returns (uint256 tokenId_);\n\n    /// @notice returns owner of Vault which is also an NFT\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /// @notice Global auth is auth for all vaults\n    function isGlobalAuth(address auth_) external view returns (bool);\n\n    /// @notice Vault auth is auth for a specific vault\n    function isVaultAuth(address vault_, address auth_) external view returns (bool);\n\n    /// @notice Total vaults deployed.\n    function totalVaults() external view returns (uint256);\n\n    /// @notice Compute vaultAddress\n    function getVaultAddress(uint256 vaultId) external view returns (address);\n\n    /// @notice read uint256 `result_` for a storage `slot_` key\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT1.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidVaultT1 {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address adminImplementation;\n        address secondaryImplementation;\n        address supplyToken;\n        address borrowToken;\n        uint8 supplyDecimals;\n        uint8 borrowDecimals;\n        uint vaultId;\n        bytes32 liquiditySupplyExchangePriceSlot;\n        bytes32 liquidityBorrowExchangePriceSlot;\n        bytes32 liquidityUserSupplySlot;\n        bytes32 liquidityUserBorrowSlot;\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    function operate(\n        uint256 nftId_, // if 0 then new position\n        int256 newCol_, // if negative then withdraw\n        int256 newDebt_, // if negative then payback\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint actualDebtAmt_, uint actualColAmt_);\n\n    function absorb() external;\n\n    function rebalance() external payable returns (int supplyAmt_, int borrowAmt_);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n}\n"
    },
    "solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
    },
    "solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    },
    "solmate/src/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}