{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/infiniteProxy/interfaces/iProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IProxy {\n    function setAdmin(address newAdmin_) external;\n\n    function setDummyImplementation(address newDummyImplementation_) external;\n\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\n\n    function removeImplementation(address implementation_) external;\n\n    function getAdmin() external view returns (address);\n\n    function getDummyImplementation() external view returns (address);\n\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\n\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/bigMathMinified.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\nlibrary BigMathMinified {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/dexCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\nimport { DexSlotsLink } from \"./dexSlotsLink.sol\";\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// @DEV ATTENTION: ON ANY CHANGES HERE, MAKE SURE THAT LOGIC IN VAULTS WILL STILL BE VALID.\n// SOME CODE THERE ASSUMES DEXCALCS == LIQUIDITYCALCS.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n/// @notice implements calculation methods used for Fluid Dex such as updated withdrawal / borrow limits.\nlibrary DexCalcs {\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) &\n            X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ = block.timestamp - ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ = block.timestamp - ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n}\n"
    },
    "contracts/libraries/dexSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\nlibrary DexSlotsLink {\n    /// @dev storage slot for variables at Dex\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\n    /// @dev storage slot for variables2 at Dex\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\n    /// @dev storage slot for total supply shares at Dex\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\n    /// @dev storage slot for user supply mapping at Dex\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\n    /// @dev storage slot for total borrow shares at Dex\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\n    /// @dev storage slot for user borrow mapping at Dex\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\n    /// @dev storage slot for oracle mapping at Dex\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\n    /// @dev storage slot for range and threshold shifts at Dex\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\n    /// @dev storage slot for center price shift at Dex\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n}\n"
    },
    "contracts/libraries/liquidityCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\nimport { LiquiditySlotsLink } from \"./liquiditySlotsLink.sol\";\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\n\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\n/// borrow rate, withdrawal / borrow limits, revenue amount.\nlibrary LiquidityCalcs {\n    error FluidLiquidityCalcsError(uint256 errorId_);\n\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\n    event BorrowRateMaxCap();\n\n    /// @dev constants as from Liquidity variables.sol\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X15 = 0x7fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                  CALC EXCHANGE PRICES                  /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\n    function calcExchangePrices(\n        uint256 exchangePricesAndConfig_\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\n        // Extracting exchange prices\n        supplyExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\n            X64;\n        borrowExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\n            X64;\n\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\n        }\n\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\n\n        unchecked {\n            // last timestamp can not be > current timestamp\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\n\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\n                X15;\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // calculate new borrow exchange price.\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\n            borrowExchangePrice_ +=\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\n\n            // FOR SUPPLY EXCHANGE PRICE:\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\n            //\n            // Example:\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\n            // yield is 10 (so half a year must have passed).\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 20%) = 62,5%\n            // supplyRate = (40% * (100% - 10%)) * = 36% * 62,5% = 22.5%\n            // increase in supplyExchangePrice, assuming 100 as previous price.\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\n\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\n\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\n\n            if (temp_ == 1) {\n                // if no raw supply: no exchange price update needed\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\n            if (temp_ & 1 == 1) {\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n                temp_ = temp_ >> 1;\n\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\n                // in the if statement a little above.\n\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\n                // so ratioSupplyYield must come out as 2.5 (250%).\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\n                temp_ =\n                    // utilization * (100% + 100% / supplyRatio)\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\n                    (FOUR_DECIMALS);\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\n            } else {\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n                temp_ = temp_ >> 1;\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\n\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\n                temp_ =\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\n                    (1e27 *\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\n                        (FOUR_DECIMALS + temp_)) /\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\n            }\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\n\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\n            if (borrowRatio_ & 1 == 1) {\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\n\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\n            } else {\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\n            }\n\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\n\n            // 2. calculate supply rate\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\n            // but more suppliers not earning interest.\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\n                temp_ * // ratioSupplyYield\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\n\n            // 3. calculate increase in supply exchange price\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                     CALC REVENUE                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\n    /// and the current balance of the Fluid liquidity contract for the token.\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\n    /// @return revenueAmount_ collectable revenue amount\n    function calcRevenue(\n        uint256 totalAmounts_,\n        uint256 exchangePricesAndConfig_,\n        uint256 liquidityTokenBalance_\n    ) internal view returns (uint256 revenueAmount_) {\n        // @dev no need to super-optimize this method as it is only used by admin\n\n        // calculate the new exchange prices based on earned interest\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\n\n        // total supply = interest free + with interest converted from raw\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\n\n        if (totalSupply_ > 0) {\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\n            // ensure there is no possible case because of rounding etc. where this would revert,\n            // explicitly check if >\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\n            // can only be revenue.\n        } else {\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\n            revenueAmount_ = liquidityTokenBalance_;\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ =\n                block.timestamp -\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ =\n                block.timestamp -\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC RATES                        /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev Calculates new borrow rate from utilization for a token\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\n        // extract rate version: 4 bits (0xF) starting from bit 0\n        uint256 rateVersion_ = (rateData_ & 0xF);\n\n        if (rateVersion_ == 1) {\n            rate_ = calcRateV1(rateData_, utilization_);\n        } else if (rateVersion_ == 2) {\n            rate_ = calcRateV2(rateData_, utilization_);\n        } else {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\n        }\n\n        if (rate_ > X16) {\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\n            // this is unlikely to ever happen if configs stay within expected levels.\n            rate_ = X16;\n            // emit event to more easily become aware\n            emit BorrowRateMaxCap();\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e2 precision\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v1 (one kink) ------------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // else utilization is greater than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\n            x1_ = kink1_;\n            x2_ = FOUR_DECIMALS; // 100%\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e4 precision\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v2 (two kinks) -----------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 156 bits => 100-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink1\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\n            if (utilization_ < kink2_) {\n                // if utilization is less than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                x1_ = kink1_;\n                x2_ = kink2_;\n            } else {\n                // else utilization is greater than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\n                x1_ = kink2_;\n                x2_ = FOUR_DECIMALS;\n            }\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\n    function getTotalSupply(\n        uint256 totalAmounts_,\n        uint256 supplyExchangePrice_\n    ) internal pure returns (uint256 totalSupply_) {\n        // totalSupply_ => supplyInterestFree\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\n    function getTotalBorrow(\n        uint256 totalAmounts_,\n        uint256 borrowExchangePrice_\n    ) internal pure returns (uint256 totalBorrow_) {\n        // totalBorrow_ => borrowInterestFree\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n}\n"
    },
    "contracts/libraries/liquiditySlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\nlibrary LiquiditySlotsLink {\n    /// @dev storage slot for status at Liquidity\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\n    /// @dev storage slot for auths mapping at Liquidity\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\n    /// @dev storage slot for guardians mapping at Liquidity\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\n    /// @dev storage slot for user class mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\n    /// @dev storage slot for rateData mapping at Liquidity\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\n    /// @dev storage slot for totalAmounts mapping at Liquidity\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\n    /// @dev storage slot for user supply double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\n    /// @dev storage slot for user borrow double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // ExchangePricesAndConfig\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\n\n    // RateData:\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\n    // RateData: V1\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\n    // RateData: V2\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\n\n    // TotalAmounts\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\n\n    // Configs2\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/safeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\n\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\nlibrary SafeTransfer {\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 20000; // pass max. 20k gas for native transfers\n\n    error FluidSafeTransferError(uint256 errorId_);\n\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from_\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of `token_` to `to_`.\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of ` native token to `to_`.\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\n    function safeTransferNative(address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n}\n"
    },
    "contracts/libraries/storageRead.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements a method to read uint256 data from storage at a bytes32 storage slot key.\ncontract StorageRead {\n    function readFromStorage(bytes32 slot_) public view returns (uint256 result_) {\n        assembly {\n            result_ := sload(slot_) // read value from the storage slot\n        }\n    }\n}\n"
    },
    "contracts/liquidity/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    /// @notice struct to set borrow rate data for version 1\n    struct RateDataV1Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\n        uint256 kink;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink;\n        ///\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set borrow rate data for version 2\n    struct RateDataV2Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\n        uint256 kink1;\n        ///\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\n        uint256 kink2;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink1;\n        ///\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\n        uint256 rateAtUtilizationKink2;\n        ///\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set token config\n    struct TokenConfig {\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\n        uint256 fee;\n        ///\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\n        uint256 threshold;\n        ///\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\n        uint256 maxUtilization;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/liquidity/interfaces/iLiquidity.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IProxy } from \"../../infiniteProxy/interfaces/iProxy.sol\";\nimport { Structs as AdminModuleStructs } from \"../adminModule/structs.sol\";\n\ninterface IFluidLiquidityAdmin {\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\n    /// @param authsStatus_ array of structs setting allowed status for an address.\n    ///                     status true => add auth, false => remove auth\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\n\n    /// @notice adds/removes guardians. Only callable by Governance.\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\n    ///                         status true => add guardian, false => remove guardian\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\n\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\n    /// @param revenueCollector_  new revenue collector address\n    function updateRevenueCollector(address revenueCollector_) external;\n\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\n    /// @param newStatus_ new status\n    ///        status = 2 -> pause, status = 1 -> resume.\n    function changeStatus(uint256 newStatus_) external;\n\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\n\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\n\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\n    ///         Only callable by Auths.\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\n\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\n    ///         Only callable by Auths.\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\n\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param token_ token address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\n\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\n\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to pause operations for\n    /// @param supplyTokens_  token addresses to pause withdrawals for\n    /// @param borrowTokens_  token addresses to pause borrowings for\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to unpause operations for\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\n    /// @param borrowTokens_  token addresses to unpause borrowings for\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\n    /// @param tokens_  array of tokens to collect revenue for\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\n    function collectRevenue(address[] calldata tokens_) external;\n\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\n    /// @param tokens_ tokens to update exchange prices for\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\n    function updateExchangePrices(\n        address[] calldata tokens_\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\n}\n\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\n    /// @notice Single function which handles supply, withdraw, borrow & payback\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\n    /// @param withdrawTo_ if withdrawal then to which address\n    /// @param borrowTo_ if borrow then to which address\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\n    /// @return memVar3_ updated supplyExchangePrice\n    /// @return memVar4_ updated borrowExchangePrice\n    /// @dev to trigger skipping in / out transfers (gas optimization):\n    /// -  ` callbackData_` MUST be encoded so that \"from\" address is the last 20 bytes in the last 32 bytes slot,\n    ///     also for native token operations where liquidityCallback is not triggered!\n    ///     from address must come at last position if there is more data. I.e. encode like:\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\n    /// -   this \"from\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\n    ///     in the slot before (bytes 32 to 63)\n    /// -   `msg.value` must be 0.\n    /// -   Amounts must be either:\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\n}\n\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\n"
    },
    "contracts/periphery/wallet/wallet/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC721 } from \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\nimport { SafeTransfer } from \"../../../libraries/safeTransfer.sol\";\n\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { IFluidVaultFactory } from \"../../../protocols/vault/interfaces/iVaultFactory.sol\";\nimport { IFluidVaultT1 } from \"../../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { IFluidVault } from \"../../../protocols/vault/interfaces/iVault.sol\";\n\n\ninterface IFluidWalletFactory {\n    function WALLET_PROXY() external view returns(address);\n}\n\ninterface InstaFlashReceiverInterface {\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata _data\n    ) external returns (bool);\n}\n\nabstract contract FluidWalletVariables {\n    /***********************************|\n    |   Constants/Immutables            |\n    |__________________________________*/\n    string public constant VERSION = \"1.1.0\";\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 internal constant X32 = 0xffffffff;\n\n    address public immutable VAULT_FACTORY;\n    address public immutable FLUID_WALLET_FACTORY;\n\n    /***********************************|\n    |           Slot 0                  |\n    |__________________________________*/\n    /// @dev owner address of this wallet. It is initialized while deploying the wallet for the user.\n    address public owner;\n\n    /***********************************|\n    |           Slot 1                  |\n    |__________________________________*/\n    /// @dev transient allow hash used to signal allowing certain entry into methods such as executeOperation etc.\n    bytes32 internal _transientAllowHash;\n    \n    function _resetTransientStorage() internal {\n        assembly {\n            sstore(1, 1) // Store 1 in the transient storage 1\n        }\n    }\n}\n\ncontract FluidWalletErrorsAndEvents {\n    error FluidWallet__NotAllowed();\n    error FluidWallet__ToHexDigit();\n    error FluidWallet__Unauthorized();\n\n    event Executed(\n        address indexed owner,\n        uint256 indexed tokenId\n    );\n\n    event ExecutedCast(address indexed owner);\n\n    struct Action {\n        address target;\n        bytes data;\n        uint256 value;\n        uint8 operation;\n    }\n}\n\ncontract FluidWalletImplementation is FluidWalletVariables, FluidWalletErrorsAndEvents {\n    \n    constructor(\n        address vaultFactory_,\n        address fluidWalletFactory_\n    ) {\n        VAULT_FACTORY = vaultFactory_;\n        FLUID_WALLET_FACTORY = fluidWalletFactory_;\n    }\n\n    /// @dev                    ERC721 callback used Fluid Vault Factory and executes actions encoded in `data_`\n    ///                         Caller should be Fluid Wallet Factory.\n    /// @param operator_        operator_ caller to transfer the the given token ID\n    /// @param from_            from_ previous owner of the given token ID\n    /// @param tokenId_         tokenId_ id of the ERC721\n    /// @param data_            data bytes containing the `abi.encoded()` actions that are executed like in `Action[]` & `owner`\n    function onERC721Received(\n        address operator_,\n        address from_,\n        uint256 tokenId_,\n        bytes calldata data_\n    ) external returns (bytes4) {\n        if (msg.sender != address(VAULT_FACTORY)) revert FluidWallet__NotAllowed();\n        if (operator_ != from_) revert FluidWallet__NotAllowed();\n        if (operator_ != FLUID_WALLET_FACTORY) revert FluidWallet__NotAllowed();\n\n        (address owner_, Action[] memory actions_) = abi.decode(data_, (address, Action[]));\n\n        /// @dev validate owner by computing wallet address.\n        _validateOwner(owner_);\n\n        /// @dev execute actions.\n        _executeActions(actions_);\n\n        /// @dev reset _transientAllowHash to prevent reentrancy\n        _resetTransientStorage();\n\n        // Transfer tokenId back to main owner\n        if (IERC721(VAULT_FACTORY).ownerOf(tokenId_) == address(this)) {\n            IERC721(VAULT_FACTORY).transferFrom(address(this), owner_, tokenId_);\n        }\n\n        // sweep vault specific tokens to owner address\n        _sweepTokens(owner_, tokenId_);\n\n        emit Executed(owner_, tokenId_);\n\n        return this.onERC721Received.selector;\n    }\n\n    function cast(\n        Action[] memory actions_\n    ) public {\n        /// @dev validate owner by computing wallet address.\n        _validateOwner(msg.sender);\n\n        /// @dev execute actions.\n        _executeActions(actions_);\n\n        /// @dev reset _transientAllowHash to prevent reentrancy\n        _resetTransientStorage();\n\n        emit ExecutedCast(msg.sender);\n    }\n    \n\n    /***********************************|\n    |         FLASHLOAN CALLBACK        |\n    |__________________________________*/\n\n    /// @dev                    callback used by Instadapp Flashloan Aggregator, executes operations while owning\n    ///                         the flashloaned amounts. `data_` must contain actions, one of them must pay back flashloan\n    // /// @param assets_       assets_ received a flashloan for\n    // /// @param amounts_      flashloaned amounts for each asset\n    // /// @param premiums_     fees to pay for the flashloan\n    /// @param initiator_       flashloan initiator -> must be this contract\n    /// @param data_            data bytes containing the `abi.encoded()` actions that are executed like in `CastParams.actions`\n\n    function executeOperation(\n        address[] calldata /* assets */,\n        uint256[] calldata /* amounts */,\n        uint256[] calldata /* premiums */,\n        address initiator_,\n        bytes calldata data_\n    ) external returns (bool) {\n        if (\n            !(_transientAllowHash ==\n                bytes32(keccak256(abi.encode(data_, block.timestamp))) &&\n                initiator_ == address(this))\n        ) {\n            revert FluidWallet__Unauthorized();\n        }\n\n        _executeActions(abi.decode(data_, (Action[])));\n\n        return true;\n    }\n\n    /***********************************|\n    |         INTERNAL HELPERS          |\n    |__________________________________*/\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping\n    function _calculateStorageSlotUintMapping(uint256 slot_, uint key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    struct VaultConstants {\n        address supplyToken0;\n        address supplyToken1;\n        address borrowToken0;\n        address borrowToken1;\n    }\n\n    function _sweepTokens(address owner_, uint256 tokenId_) internal {\n        uint256 tokenConfig_ = IFluidVaultFactory(VAULT_FACTORY).readFromStorage(_calculateStorageSlotUintMapping(3, tokenId_));\n        address vaultAddress_ = IFluidVaultFactory(VAULT_FACTORY).getVaultAddress((tokenConfig_ >> 192) & X32);\n\n        VaultConstants memory constants_ = _getVaultConstants(vaultAddress_);\n\n        _flushTokens(constants_.supplyToken0, owner_);\n        _flushTokens(constants_.supplyToken1, owner_);\n        _flushTokens(constants_.borrowToken0, owner_);\n        _flushTokens(constants_.borrowToken1, owner_);\n    }\n\n    function _getVaultConstants(address vault_) internal view returns (VaultConstants memory constants_) {\n        if (vault_.code.length == 0) {\n            return constants_;\n        }\n        try IFluidVault(vault_).TYPE() returns (uint256 type_) {\n            IFluidVault.ConstantViews memory vaultConstants_ = IFluidVault(vault_).constantsView();\n\n            constants_.supplyToken0 = vaultConstants_.supplyToken.token0;\n            constants_.supplyToken1 = vaultConstants_.supplyToken.token1;\n            constants_.borrowToken0 = vaultConstants_.borrowToken.token0;\n            constants_.borrowToken1 = vaultConstants_.borrowToken.token1;\n        } catch {\n            IFluidVaultT1.ConstantViews memory vaultConstants_ = IFluidVaultT1(vault_).constantsView();\n            \n            constants_.supplyToken0 = vaultConstants_.supplyToken;\n            constants_.supplyToken1 = address(0);\n            constants_.borrowToken0 = vaultConstants_.borrowToken;\n            constants_.borrowToken1 = address(0);\n        }\n    }\n\n    function _flushTokens(address token_, address owner_) internal {\n        if (token_ == address(0)) return;\n\n        if (token_ == ETH_ADDRESS) {\n            uint256 balance_ = address(this).balance;\n            \n            if (balance_ > 0) SafeTransfer.safeTransferNative(payable(owner_), balance_);\n        } else {\n            uint256 balance_ = IERC20(token_).balanceOf(address(this));\n\n            if (balance_ > 0) SafeTransfer.safeTransfer(token_, owner_, balance_);\n        }\n    }\n\n    /// @dev validate `owner` by recomputing fluid address.\n    function _validateOwner(address owner_) internal view {\n        address wallet_ = Clones.predictDeterministicAddress(\n            IFluidWalletFactory(FLUID_WALLET_FACTORY).WALLET_PROXY(),\n            keccak256(abi.encode(owner_)),\n            FLUID_WALLET_FACTORY\n        );\n        if (wallet_ != address(this)) revert FluidWallet__NotAllowed();\n    }\n\n    /// @dev executes `actions_` with respective target, calldata, operation etc.\n    function _executeActions(Action[] memory actions_) internal {\n       uint256 actionsLength_ = actions_.length;\n        for (uint256 i; i < actionsLength_; ) {\n            Action memory action_ = actions_[i];\n\n            // execute action\n            bool success_;\n            bytes memory result_;\n            if (action_.operation == 0) {\n                // call (operation = 0)\n\n                // low-level call will return success true also if action target is not even a contract.\n                // we do not explicitly check for this, default interaction is via UI which can check and handle this.\n                // Also applies to delegatecall etc.\n                (success_, result_) = action_.target.call{ value: action_.value }(action_.data);\n\n                // handle action failure right after external call to better detect out of gas errors\n                if (!success_) {\n                    _handleActionFailure(i, result_);\n                }\n            } else if (action_.operation == 1) {\n                // delegatecall (operation = 1)\n\n                (success_, result_) = action_.target.delegatecall(action_.data);\n\n                // reset _transientAllowHash to make sure it can not be set up in any way for reentrancy\n                _resetTransientStorage();\n\n                // handle action failure right after external call to better detect out of gas errors\n                if (!success_) {\n                    _handleActionFailure(i, result_);\n                }\n            } else if (action_.operation == 2) {\n                // flashloan (operation = 2)\n                // flashloan is always executed via .call, flashloan aggregator uses `msg.sender`, so .delegatecall\n                // wouldn't send funds to this contract but rather to the original sender.\n\n                bytes memory data_ = action_.data;\n                assembly {\n                    data_ := add(data_, 4) // Skip function selector (4 bytes)\n                }\n                // get actions data from calldata action_.data. Only supports InstaFlashAggregatorInterface\n                (, , , data_, ) = abi.decode(data_, (address[], uint256[], uint256, bytes, bytes));\n\n                // set allowHash to signal allowed entry into executeOperation()\n                _transientAllowHash = bytes32(\n                    keccak256(abi.encode(data_, block.timestamp))\n                );\n\n                // handle action failure right after external call to better detect out of gas errors\n                (success_, result_) = action_.target.call{ value: action_.value }(action_.data);\n\n                if (!success_) {\n                    _handleActionFailure(i, result_);\n                }\n\n                // reset _transientAllowHash to prevent reentrancy during actions execution\n                _resetTransientStorage();\n            } else {\n                // either operation does not exist or the id was not set according to what the action wants to execute\n                revert(string.concat(Strings.toString(i), \"_FLUID__INVALID_ID_OR_OPERATION\"));\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev handles failure of an action execution depending on error cause,\n    /// decoding and reverting with `result_` as reason string.\n    function _handleActionFailure(uint256 i_, bytes memory result_) internal pure {\n        revert(string.concat(Strings.toString(i_), _getRevertReasonFromReturnedData(result_)));\n    }\n\n    uint256 internal constant REVERT_REASON_MAX_LENGTH = 250;\n\n    /// @dev Get the revert reason from the returnedData (supports Panic, Error & Custom Errors).\n    /// Based on https://github.com/superfluid-finance/protocol-monorepo/blob/dev/packages/ethereum-contracts/contracts/libs/CallUtils.sol\n    /// This is needed in order to provide some human-readable revert message from a call.\n    /// @param returnedData_ revert data of the call\n    /// @return reason_      revert reason\n    function _getRevertReasonFromReturnedData(\n        bytes memory returnedData_\n    ) internal pure returns (string memory reason_) {\n        if (returnedData_.length < 4) {\n            // case 1: catch all\n            return \"_REASON_NOT_DEFINED\";\n        }\n\n        bytes4 errorSelector_;\n        assembly {\n            errorSelector_ := mload(add(returnedData_, 0x20))\n        }\n        if (errorSelector_ == bytes4(0x4e487b71)) {\n            // case 2: Panic(uint256), selector 0x4e487b71 (Defined since 0.8.0)\n            // ref: https://docs.soliditylang.org/en/v0.8.0/control-structures.html#panic-via-assert-and-error-via-require)\n\n            // convert last byte to hex digits -> string to decode the panic code\n            bytes memory result_ = new bytes(2);\n            result_[0] = _toHexDigit(uint8(returnedData_[returnedData_.length - 1]) / 16);\n            result_[1] = _toHexDigit(uint8(returnedData_[returnedData_.length - 1]) % 16);\n            reason_ = string.concat(\"_TARGET_PANICKED: 0x\", string(result_));\n        } else if (errorSelector_ == bytes4(0x08c379a0)) {\n            // case 3: Error(string), selector 0x08c379a0 (Defined at least since 0.7.0)\n            // based on https://ethereum.stackexchange.com/a/83577\n            assembly {\n                returnedData_ := add(returnedData_, 0x04)\n            }\n            reason_ = string.concat(\"_\", abi.decode(returnedData_, (string)));\n        } else {\n            // case 4: Custom errors (Defined since 0.8.0)\n\n            // convert bytes4 selector to string, params are ignored...\n            // based on https://ethereum.stackexchange.com/a/111876\n            bytes memory result_ = new bytes(8);\n            for (uint256 i; i < 4; ) {\n                // use unchecked as i is < 4 and division. also errorSelector can not underflow\n                unchecked {\n                    result_[2 * i] = _toHexDigit(uint8(errorSelector_[i]) / 16);\n                    result_[2 * i + 1] = _toHexDigit(uint8(errorSelector_[i]) % 16);\n                    ++i;\n                }\n            }\n            reason_ = string.concat(\"_CUSTOM_ERROR: 0x\", string(result_));\n        }\n\n        {\n            // truncate reason_ string to REVERT_REASON_MAX_LENGTH for reserveGas used to ensure Cast event is emitted\n            if (bytes(reason_).length > REVERT_REASON_MAX_LENGTH) {\n                bytes memory reasonBytes_ = bytes(reason_);\n                uint256 maxLength_ = REVERT_REASON_MAX_LENGTH + 1; // cheaper than <= in each loop\n                bytes memory truncatedRevertReason_ = new bytes(maxLength_);\n                for (uint256 i; i < maxLength_; ) {\n                    truncatedRevertReason_[i] = reasonBytes_[i];\n\n                    unchecked {\n                        ++i;\n                    }\n                }\n                reason_ = string(truncatedRevertReason_);\n            }\n        }\n    }\n\n    /// @dev used to convert bytes4 selector to string\n    function _toHexDigit(uint8 d) internal pure returns (bytes1) {\n        // use unchecked as the operations with d can not over / underflow\n        unchecked {\n            if (d < 10) {\n                return bytes1(uint8(bytes1(\"0\")) + d);\n            }\n            if (d < 16) {\n                return bytes1(uint8(bytes1(\"a\")) + d - 10);\n            }\n        }\n        revert FluidWallet__ToHexDigit();\n    }\n}"
    },
    "contracts/protocols/dex/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs } from \"./poolT1/coreModule/structs.sol\";\n\nabstract contract Error {\n    error FluidDexError(uint256 errorId_);\n\n    error FluidDexFactoryError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares_);\n\n    error FluidDexPricesAndExchangeRates(Structs.PricesAndExchangePrice pex_);\n}\n"
    },
    "contracts/protocols/dex/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |             DexT1                 | \n    |__________________________________*/\n\n    /// @notice thrown at reentrancy\n    uint256 internal constant DexT1__AlreadyEntered = 51001;\n\n    uint256 internal constant DexT1__NotAnAuth = 51002;\n\n    uint256 internal constant DexT1__SmartColNotEnabled = 51003;\n\n    uint256 internal constant DexT1__SmartDebtNotEnabled = 51004;\n\n    uint256 internal constant DexT1__PoolNotInitialized = 51005;\n\n    uint256 internal constant DexT1__TokenReservesTooLow = 51006;\n\n    uint256 internal constant DexT1__EthAndAmountInMisMatch = 51007;\n\n    uint256 internal constant DexT1__EthSentForNonNativeSwap = 51008;\n\n    uint256 internal constant DexT1__NoSwapRoute = 51009;\n\n    uint256 internal constant DexT1__NotEnoughAmountOut = 51010;\n\n    uint256 internal constant DexT1__LiquidityLayerTokenUtilizationCapReached = 51011;\n\n    uint256 internal constant DexT1__HookReturnedFalse = 51012;\n\n    // Either user's config are not set or user is paused\n    uint256 internal constant DexT1__UserSupplyInNotOn = 51013;\n\n    // Either user's config are not set or user is paused\n    uint256 internal constant DexT1__UserDebtInNotOn = 51014;\n\n    // Thrown when contract asks for more token0 or token1 than what user's wants to give on deposit\n    uint256 internal constant DexT1__AboveDepositMax = 51015;\n\n    uint256 internal constant DexT1__MsgValueLowOnDepositOrPayback = 51016;\n\n    uint256 internal constant DexT1__WithdrawLimitReached = 51017;\n\n    // Thrown when contract gives less token0 or token1 than what user's wants on withdraw\n    uint256 internal constant DexT1__BelowWithdrawMin = 51018;\n\n    uint256 internal constant DexT1__DebtLimitReached = 51019;\n\n    // Thrown when contract gives less token0 or token1 than what user's wants on borrow\n    uint256 internal constant DexT1__BelowBorrowMin = 51020;\n\n    // Thrown when contract asks for more token0 or token1 than what user's wants on payback\n    uint256 internal constant DexT1__AbovePaybackMax = 51021;\n\n    uint256 internal constant DexT1__InvalidDepositAmts = 51022;\n\n    uint256 internal constant DexT1__DepositAmtsZero = 51023;\n\n    uint256 internal constant DexT1__SharesMintedLess = 51024;\n\n    uint256 internal constant DexT1__WithdrawalNotEnough = 51025;\n\n    uint256 internal constant DexT1__InvalidWithdrawAmts = 51026;\n\n    uint256 internal constant DexT1__WithdrawAmtsZero = 51027;\n\n    uint256 internal constant DexT1__WithdrawExcessSharesBurn = 51028;\n\n    uint256 internal constant DexT1__InvalidBorrowAmts = 51029;\n\n    uint256 internal constant DexT1__BorrowAmtsZero = 51030;\n\n    uint256 internal constant DexT1__BorrowExcessSharesMinted = 51031;\n\n    uint256 internal constant DexT1__PaybackAmtTooHigh = 51032;\n\n    uint256 internal constant DexT1__InvalidPaybackAmts = 51033;\n\n    uint256 internal constant DexT1__PaybackAmtsZero = 51034;\n\n    uint256 internal constant DexT1__PaybackSharedBurnedLess = 51035;\n\n    uint256 internal constant DexT1__NothingToArbitrage = 51036;\n\n    uint256 internal constant DexT1__MsgSenderNotLiquidity = 51037;\n\n    // On liquidity callback reentrancy bit should be on\n    uint256 internal constant DexT1__ReentrancyBitShouldBeOn = 51038;\n\n    // Thrown is reentrancy is already on and someone tries to fetch oracle price. Should not be possible to this\n    uint256 internal constant DexT1__OraclePriceFetchAlreadyEntered = 51039;\n\n    // Thrown when swap changes the current price by more than 5%\n    uint256 internal constant DexT1__OracleUpdateHugeSwapDiff = 51040;\n\n    uint256 internal constant DexT1__Token0ShouldBeSmallerThanToken1 = 51041;\n\n    uint256 internal constant DexT1__OracleMappingOverflow = 51042;\n\n    /// @notice thrown if governance has paused the swapping & arbitrage so only perfect functions are usable\n    uint256 internal constant DexT1__SwapAndArbitragePaused = 51043;\n\n    uint256 internal constant DexT1__ExceedsAmountInMax = 51044;\n\n    /// @notice thrown if amount in is too high or too low\n    uint256 internal constant DexT1__SwapInLimitingAmounts = 51045;\n\n    /// @notice thrown if amount out is too high or too low\n    uint256 internal constant DexT1__SwapOutLimitingAmounts = 51046;\n\n    uint256 internal constant DexT1__MintAmtOverflow = 51047;\n\n    uint256 internal constant DexT1__BurnAmtOverflow = 51048;\n\n    uint256 internal constant DexT1__LimitingAmountsSwapAndNonPerfectActions = 51049;\n\n    uint256 internal constant DexT1__InsufficientOracleData = 51050;\n\n    uint256 internal constant DexT1__SharesAmountInsufficient = 51051;\n\n    uint256 internal constant DexT1__CenterPriceOutOfRange = 51052;\n\n    uint256 internal constant DexT1__DebtReservesTooLow = 51053;\n\n    uint256 internal constant DexT1__SwapAndDepositTooLowOrTooHigh = 51054;\n\n    uint256 internal constant DexT1__WithdrawAndSwapTooLowOrTooHigh = 51055;\n\n    uint256 internal constant DexT1__BorrowAndSwapTooLowOrTooHigh = 51056;\n\n    uint256 internal constant DexT1__SwapAndPaybackTooLowOrTooHigh = 51057;\n\n    uint256 internal constant DexT1__InvalidImplementation = 51058;\n\n    uint256 internal constant DexT1__OnlyDelegateCallAllowed = 51059;\n\n    uint256 internal constant DexT1__IncorrectDataLength = 51060;\n\n    uint256 internal constant DexT1__AmountToSendLessThanAmount = 51061;\n\n    uint256 internal constant DexT1__InvalidCollateralReserves = 51062;\n\n    uint256 internal constant DexT1__InvalidDebtReserves = 51063;\n\n    uint256 internal constant DexT1__SupplySharesOverflow = 51064;\n\n    uint256 internal constant DexT1__BorrowSharesOverflow = 51065;\n\n    uint256 internal constant DexT1__OracleNotActive = 51066;\n\n    /***********************************|\n    |            DEX Admin              | \n    |__________________________________*/\n\n    /// @notice thrown when pool is not initialized\n    uint256 internal constant DexT1Admin__PoolNotInitialized = 52001;\n\n    uint256 internal constant DexT1Admin__SmartColIsAlreadyOn = 52002;\n\n    uint256 internal constant DexT1Admin__SmartDebtIsAlreadyOn = 52003;\n\n    /// @notice thrown when any of the configs value overflow the maximum limit\n    uint256 internal constant DexT1Admin__ConfigOverflow = 52004;\n\n    uint256 internal constant DexT1Admin__AddressNotAContract = 52005;\n\n    uint256 internal constant DexT1Admin__InvalidParams = 52006;\n\n    uint256 internal constant DexT1Admin__UserNotDefined = 52007;\n\n    uint256 internal constant DexT1Admin__OnlyDelegateCallAllowed = 52008;\n\n    uint256 internal constant DexT1Admin__UnexpectedPoolState = 52009;\n\n    /// @notice thrown when trying to pause or unpause but user is already in the target pause state\n    uint256 internal constant DexT1Admin__InvalidPauseToggle = 52009;\n\n    /***********************************|\n    |            DEX Factory            | \n    |__________________________________*/\n\n    uint256 internal constant DexFactory__InvalidOperation = 53001;\n    uint256 internal constant DexFactory__Unauthorized = 53002;\n    uint256 internal constant DexFactory__SameTokenNotAllowed = 53003;\n    uint256 internal constant DexFactory__TokenConfigNotProper = 53004;\n    uint256 internal constant DexFactory__InvalidParams = 53005;\n    uint256 internal constant DexFactory__OnlyDelegateCallAllowed = 53006;\n    uint256 internal constant DexFactory__InvalidDexAddress = 53007;\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexFactory {\n    /// @notice Global auth is auth for all dexes\n    function isGlobalAuth(address auth_) external view returns (bool);\n\n    /// @notice Dex auth is auth for a specific dex\n    function isDexAuth(address vault_, address auth_) external view returns (bool);\n\n    /// @notice Total dexes deployed.\n    function totalDexes() external view returns (uint256);\n\n    /// @notice Compute dexAddress\n    function getDexAddress(uint256 dexId_) external view returns (address);\n\n    /// @notice read uint256 `result_` for a storage `slot_` key\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexT1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexT1 {\n    error FluidDexError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares);\n\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\n\n    /// @notice returns the dex id\n    function DEX_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndOracle;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) external view returns (CollateralReserves memory c_);\n\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) external view returns (DebtReserves memory d_);\n\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\n    function getPricesAndExchangePrices() external;\n\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) external returns (\n        uint withdrawAmt_\n    );\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) external payable returns (\n        uint paybackAmt_\n    );\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(\n        uint[] memory secondsAgos_\n    ) external view returns (\n        Oracle[] memory twaps_,\n        uint currentPrice_\n    );\n}\n"
    },
    "contracts/protocols/dex/poolT1/common/constantVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { StorageRead } from \"../../../../libraries/storageRead.sol\";\n\ninterface ITokenDecimals {\n    function decimals() external view returns (uint8);\n}\n\nabstract contract ConstantVariables is StorageRead {\n    /*//////////////////////////////////////////////////////////////\n                          CONSTANTS / IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    address internal constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 internal constant NATIVE_TOKEN_DECIMALS = 18;\n    address internal constant ADDRESS_DEAD = 0x000000000000000000000000000000000000dEaD;\n    uint256 internal constant TOKENS_DECIMALS_PRECISION = 12;\n    uint256 internal constant TOKENS_DECIMALS = 1e12;\n\n    uint256 internal constant SMALL_COEFFICIENT_SIZE = 10;\n    uint256 internal constant DEFAULT_COEFFICIENT_SIZE = 56;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant X2 = 0x3;\n    uint256 internal constant X3 = 0x7;\n    uint256 internal constant X5 = 0x1f;\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X8 = 0xff;\n    uint256 internal constant X9 = 0x1ff;\n    uint256 internal constant X10 = 0x3ff;\n    uint256 internal constant X11 = 0x7ff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X17 = 0x1ffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X20 = 0xfffff;\n    uint256 internal constant X22 = 0x3fffff;\n    uint256 internal constant X23 = 0x7fffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X28 = 0xfffffff;\n    uint256 internal constant X30 = 0x3fffffff;\n    uint256 internal constant X32 = 0xffffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X40 = 0xffffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n    uint256 internal constant X96 = 0xffffffffffffffffffffffff;\n    uint256 internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n\n    uint256 internal constant TWO_DECIMALS = 1e2;\n    uint256 internal constant THREE_DECIMALS = 1e3;\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant FIVE_DECIMALS = 1e5;\n    uint256 internal constant SIX_DECIMALS = 1e6;\n    uint256 internal constant EIGHT_DECIMALS = 1e8;\n    uint256 internal constant NINE_DECIMALS = 1e9;\n\n    uint256 internal constant PRICE_PRECISION = 1e27;\n\n    uint256 internal constant ORACLE_PRECISION = 1e18; // 100%\n    uint256 internal constant ORACLE_LIMIT = 5 * 1e16; // 5%\n\n    /// after swap token0 reserves should not be less than token1InToken0 / MINIMUM_LIQUIDITY_SWAP\n    /// after swap token1 reserves should not be less than token0InToken1 / MINIMUM_LIQUIDITY_SWAP\n    uint256 internal constant MINIMUM_LIQUIDITY_SWAP = 1e4;\n\n    /// after user operations (deposit, withdraw, borrow, payback) token0 reserves should not be less than token1InToken0 / MINIMUM_LIQUIDITY_USER_OPERATIONS\n    /// after user operations (deposit, withdraw, borrow, payback) token1 reserves should not be less than token0InToken0 / MINIMUM_LIQUIDITY_USER_OPERATIONS\n    uint256 internal constant MINIMUM_LIQUIDITY_USER_OPERATIONS = 1e6;\n\n    /// To skip transfers in liquidity layer if token in & out is same and liquidity layer is on the winning side\n    bytes32 internal constant SKIP_TRANSFERS = keccak256(bytes(\"SKIP_TRANSFERS\"));\n\n    function _decimals(address token_) internal view returns (uint256) {\n        return (token_ == NATIVE_TOKEN) ? NATIVE_TOKEN_DECIMALS : ITokenDecimals(token_).decimals();\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/common/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Variables {\n    /*//////////////////////////////////////////////////////////////\n                          STORAGE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// First 1 bit  => 0 => re-entrancy. If 0 then allow transaction to go, else throw.\n    /// Next 40 bits => 1-40 => last to last stored price. BigNumber (32 bits precision, 8 bits exponent)\n    /// Next 40 bits => 41-80 => last stored price of pool. BigNumber (32 bits precision, 8 bits exponent)\n    /// Next 40 bits => 81-120 => center price. Center price from where the ranges will be calculated. BigNumber (32 bits precision, 8 bits exponent)\n    /// Next 33 bits => 121-153 => last interaction time stamp\n    /// Next 22 bits => 154-175 => max 4194303 seconds (~1165 hrs, ~48.5 days), time difference between last to last and last price stored\n    /// Next 3 bits  => 176-178 => oracle checkpoint, if 0 then first slot, if 7 then last slot\n    /// Next 16 bits => 179-194 => current mapping or oracle, after every 8 transaction it will increase by 1. Max capacity is 65535 but it can be lower than that check dexVariables2\n    /// Next 1 bit  => 195 => is oracle active?\n    uint internal dexVariables;\n\n    /// Next  1 bit  => 0 => is smart collateral enabled?\n    /// Next  1 bit  => 1 => is smart debt enabled?\n    /// Next 17 bits => 2-18 => fee (1% = 10000, max value: 100000 = 10%, fee should not be more than 10%)\n    /// Next  7 bits => 19-25 => revenue cut from fee (1 = 1%, 100 = 100%). If fee is 1000 = 0.1% and revenue cut is 10 = 10% then governance get 0.01% of every swap\n    /// Next  1 bit  => 26 => percent active change going on or not, 0 = false, 1 = true, if true than that means governance has updated the below percents and the update should happen with a specified time.\n    /// Next 20 bits => 27-46 => upperPercent (1% = 10000, max value: 104.8575%) upperRange - upperRange * upperPercent = centerPrice. Hence, upperRange = centerPrice / (1 - upperPercent)\n    /// Next 20 bits => 47-66 => lowerPercent. lowerRange = centerPrice - centerPrice * lowerPercent.\n    /// Next  1 bit  => 67 => threshold percent active change going on or not, 0 = false, 1 = true, if true than that means governance has updated the below percents and the update should happen with a specified time.\n    /// Next 10 bits => 68-77 => upper shift threshold percent, 1 = 0.1%. 1000 = 100%. if currentPrice > (centerPrice + (upperRange - centerPrice) * (1000 - upperShiftThresholdPercent) / 1000) then trigger shift\n    /// Next 10 bits => 78-87 => lower shift threshold percent, 1 = 0.1%. 1000 = 100%. if currentPrice < (centerPrice - (centerPrice - lowerRange) * (1000 - lowerShiftThresholdPercent) / 1000) then trigger shift\n    /// Next 24 bits => 88-111 => Shifting time (~194 days) (rate = (% up + % down) / time ?)\n    /// Next 30 bits => 112-131 => Address of center price if center price should be fetched externally, for example, for wstETH <> ETH pool, fetch wstETH exchange rate into stETH from wstETH contract.\n    /// Why fetch it externally? Because let's say pool width is 0.1% and wstETH temporarily got depeg of 0.5% then pool will start to shift to newer pricing\n    /// but we don't want pool to shift to 0.5% because we know the depeg will recover so to avoid the loss for users.\n    /// Next 30 bits => 142-171 => Hooks bits, calculate hook address by storing deployment nonce from factory.\n    /// Next 28 bits => 172-199 => max center price. BigNumber (20 bits precision, 8 bits exponent)\n    /// Next 28 bits => 200-227 => min center price. BigNumber (20 bits precision, 8 bits exponent)\n    /// Next 10 bits => 228-237 => utilization limit of token0. Max value 1000 = 100%, if 100% then no need to check the utilization.\n    /// Next 10 bits => 238-247 => utilization limit of token1. Max value 1000 = 100%, if 100% then no need to check the utilization.\n    /// Next 1  bit  => 248     => is center price shift active\n    /// Last 1  bit  => 255     => Pause swap & arbitrage (only perfect functions will be usable), if we need to pause entire DEX then that can be done through pausing DEX on Liquidity Layer\n    uint internal dexVariables2;\n\n    /// first 128 bits => 0-127 => total supply shares\n    /// last 128 bits => 128-255 => max supply shares\n    uint internal _totalSupplyShares;\n\n    /// @dev user supply data: user -> data\n    /// Aside from 1st bit, entire bits here are same as liquidity layer _userSupplyData. Hence exact same supply & borrow limit library can be used\n    /// First  1 bit  =>       0 => is user allowed to supply? 0 = not allowed, 1 = allowed\n    /// Next  64 bits =>   1- 64 => user supply amount/shares; BigMath: 56 | 8\n    /// Next  64 bits =>  65-128 => previous user withdrawal limit; BigMath: 56 | 8\n    /// Next  33 bits => 129-161 => last triggered process timestamp (enough until 16 March 2242 -> max value 8589934591)\n    /// Next  14 bits => 162-175 => expand withdrawal limit percentage (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383).\n    ///                             @dev shrinking is instant\n    /// Next  24 bits => 176-199 => withdrawal limit expand duration in seconds.(Max value 16_777_215; ~4_660 hours, ~194 days)\n    /// Next  18 bits => 200-217 => base withdrawal limit: below this, 100% withdrawals can be done (aka shares can be burned); BigMath: 10 | 8\n    /// Next  38 bits => 218-255 => empty for future use\n    mapping(address => uint) internal _userSupplyData;\n\n    /// first 128 bits => 0-127 => total borrow shares\n    /// last 128 bits => 128-255 => max borrow shares\n    uint internal _totalBorrowShares;\n\n    /// @dev user borrow data: user -> data\n    /// Aside from 1st bit, entire bits here are same as liquidity layer _userBorrowData. Hence exact same supply & borrow limit library function can be used\n    /// First  1 bit  =>       0 => is user allowed to borrow? 0 = not allowed, 1 = allowed\n    /// Next  64 bits =>   1- 64 => user debt amount/shares; BigMath: 56 | 8\n    /// Next  64 bits =>  65-128 => previous user debt ceiling; BigMath: 56 | 8\n    /// Next  33 bits => 129-161 => last triggered process timestamp (enough until 16 March 2242 -> max value 8589934591)\n    /// Next  14 bits => 162-175 => expand debt ceiling percentage (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    ///                             @dev shrinking is instant\n    /// Next  24 bits => 176-199 => debt ceiling expand duration in seconds (Max value 16_777_215; ~4_660 hours, ~194 days)\n    /// Next  18 bits => 200-217 => base debt ceiling: below this, there's no debt ceiling limits; BigMath: 10 | 8\n    /// Next  18 bits => 218-235 => max debt ceiling: absolute maximum debt ceiling can expand to; BigMath: 10 | 8\n    /// Next  20 bits => 236-255 => empty for future use\n    mapping(address => uint) internal _userBorrowData;\n\n    /// Price difference between last swap of last block & last swap of new block\n    /// If last swap happened at Block B - 4 and next swap happened after 4 blocks at Block B then it will store that difference\n    /// considering time difference between these 4 blocks is 48 seconds, hence time will be stored as 48\n    /// New oracle update:\n    /// time to 9 bits and precision to 22 bits\n    /// if time exceeds 9 bits which is 511 sec or ~8.5 min then we will use 2 oracle slot to store the data\n    /// we will leave the both time slot as 0 and on first sign + precision slot we will store time and\n    /// on second sign + precision slot we will store sign & precision\n    /// First 9 bits =>   0-  8 => time, 511 seconds\n    /// Next   1 bit  =>  9     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits =>  10- 31 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits =>  32- 40 => time, 511 seconds\n    /// Next   1 bit  =>  41     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits =>  42- 63 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits =>  64- 72 => time, 511 seconds\n    /// Next   1 bit  =>  73     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits =>  74- 95 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits =>  96-104 => time, 511 seconds\n    /// Next   1 bit  => 105     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits => 106-127 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits => 128-136 => time, 511 seconds\n    /// Next   1 bit  => 137     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits => 138-159 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits => 160-168 => time, 511 seconds\n    /// Next   1 bit  => 169     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits => 170-191 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits => 192-200 => time, 511 seconds\n    /// Next   1 bit  => 201     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits => 202-223 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits => 224-232 => time, 511 seconds\n    /// Next   1 bit  => 233     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits => 234-255 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    mapping(uint => uint) internal _oracle;\n\n    /// First 20 bits =>  0-19 => old upper shift\n    /// Next  20 bits => 20-39 => old lower shift\n    /// Next  20 bits => 40-59 => in seconds, ~12 days max, shift can last for max ~12 days\n    /// Next  33 bits => 60-92 => timestamp of when the shift has started.\n    uint128 internal _rangeShift;\n\n    /// First 10 bits =>  0- 9 => old upper shift\n    /// Next  10 bits => 10-19 => empty so we can use same helper function\n    /// Next  10 bits => 20-29 => old lower shift\n    /// Next  10 bits => 30-39 => empty so we can use same helper function\n    /// Next  20 bits => 40-59 => in seconds, ~12 days max, shift can last for max ~12 days\n    /// Next  33 bits => 60-92 => timestamp of when the shift has started.\n    /// Next  24 bits => 93-116 => old threshold time\n    uint128 internal _thresholdShift;\n\n    /// Shifting is fuzzy and with time it'll keep on getting closer and then eventually get over\n    /// First 33 bits => 0 -32 => starting timestamp\n    /// Next  20 bits => 33-52 => % shift\n    /// Next  20 bits => 53-72 => time to shift that percent\n    uint256 internal _centerPriceShift;\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/core/colOperations.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SecondaryHelpers } from \"../helpers/secondaryHelpers.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @title FluidDexT1\n/// @notice Implements core logics for Fluid Dex protocol.\n/// Note Token transfers happen directly from user to Liquidity contract and vice-versa.\ncontract FluidDexT1OperationsCol is SecondaryHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) SecondaryHelpers(constantViews_) {\n        // all implementations should be zero other than shift\n        if (\n            constantViews_.implementations.shift == address(0) ||\n            constantViews_.implementations.admin != address(0) ||\n            constantViews_.implementations.colOperations != address(0) ||\n            constantViews_.implementations.debtOperations != address(0) ||\n            constantViews_.implementations.perfectOperationsAndSwapOut != address(0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__InvalidImplementation);\n        }\n    }\n\n    modifier _onlyDelegateCall() {\n        // also indirectly checked by `_check` because pool can never be initialized as long as the initialize method\n        // is delegate call only, but just to be sure on Admin logic we add the modifier everywhere nonetheless.\n        if (address(this) == THIS_CONTRACT) {\n            revert FluidDexError(ErrorTypes.DexT1__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) public payable _onlyDelegateCall returns (uint shares_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userSupplyData_ = _userSupplyData[msg.sender];\n\n        if (userSupplyData_ & 1 == 0 && !estimate_) revert FluidDexError(ErrorTypes.DexT1__UserSupplyInNotOn);\n\n        // is smart collateral pool enabled\n        if ((dexVariables2_ & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            DepositColMemory memory d_;\n\n            CollateralReserves memory c_ = _getCollateralReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.supplyToken0ExchangePrice,\n                pex_.supplyToken1ExchangePrice\n            );\n            CollateralReserves memory c2_ = c_;\n\n            if (token0Amt_ > 0) {\n                d_.token0AmtAdjusted =\n                    (((token0Amt_ - 1) * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION) -\n                    1;\n                _verifySwapAndNonPerfectActions(d_.token0AmtAdjusted, token0Amt_);\n                _verifyMint(d_.token0AmtAdjusted, c_.token0RealReserves);\n            }\n\n            if (token1Amt_ > 0) {\n                d_.token1AmtAdjusted =\n                    (((token1Amt_ - 1) * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION) -\n                    1;\n                _verifySwapAndNonPerfectActions(d_.token1AmtAdjusted, token1Amt_);\n                _verifyMint(d_.token1AmtAdjusted, c_.token1RealReserves);\n            }\n\n            uint temp_;\n            uint temp2_;\n\n            uint totalSupplyShares_ = _totalSupplyShares & X128;\n            if ((c_.token0RealReserves > 0) && (c_.token1RealReserves > 0)) {\n                if (d_.token0AmtAdjusted > 0 && d_.token1AmtAdjusted > 0) {\n                    // mint shares in equal proportion\n                    // temp_ => expected shares from token0 deposit\n                    temp_ = (d_.token0AmtAdjusted * 1e18) / c_.token0RealReserves;\n                    // temp2_ => expected shares from token1 deposit\n                    temp2_ = (d_.token1AmtAdjusted * 1e18) / c_.token1RealReserves;\n                    if (temp_ > temp2_) {\n                        // use temp2_ shares\n                        shares_ = (temp2_ * totalSupplyShares_) / 1e18;\n                        // temp_ => token0 to swap\n                        temp_ = ((temp_ - temp2_) * c_.token0RealReserves) / 1e18;\n                        temp2_ = 0;\n                    } else if (temp2_ > temp_) {\n                        // use temp_ shares\n                        shares_ = (temp_ * totalSupplyShares_) / 1e18;\n                        // temp2_ => token1 to swap\n                        temp2_ = ((temp2_ - temp_) * c_.token1RealReserves) / 1e18;\n                        temp_ = 0;\n                    } else {\n                        // if equal then revert as swap will not be needed anymore which can create some issue, better to use depositPerfect in this case\n                        revert FluidDexError(ErrorTypes.DexT1__InvalidDepositAmts);\n                    }\n\n                    // User deposited in equal proportion here. Hence updating col reserves and the swap will happen on updated col reserves\n                    c2_ = _getUpdatedColReserves(shares_, totalSupplyShares_, c_, true);\n\n                    totalSupplyShares_ += shares_;\n                } else if (d_.token0AmtAdjusted > 0) {\n                    temp_ = d_.token0AmtAdjusted;\n                    temp2_ = 0;\n                } else if (d_.token1AmtAdjusted > 0) {\n                    temp_ = 0;\n                    temp2_ = d_.token1AmtAdjusted;\n                } else {\n                    // user sent both amounts as 0\n                    revert FluidDexError(ErrorTypes.DexT1__InvalidDepositAmts);\n                }\n\n                if (temp_ > 0) {\n                    // swap token0\n                    temp_ = _getSwapAndDeposit(\n                        temp_, // token0 to divide and swap\n                        c2_.token1ImaginaryReserves, // token1 imaginary reserves\n                        c2_.token0ImaginaryReserves, // token0 imaginary reserves\n                        c2_.token0RealReserves, // token0 real reserves\n                        c2_.token1RealReserves // token1 real reserves\n                    );\n                } else if (temp2_ > 0) {\n                    // swap token1\n                    temp_ = _getSwapAndDeposit(\n                        temp2_, // token1 to divide and swap\n                        c2_.token0ImaginaryReserves, // token0 imaginary reserves\n                        c2_.token1ImaginaryReserves, // token1 imaginary reserves\n                        c2_.token1RealReserves, // token1 real reserves\n                        c2_.token0RealReserves // token0 real reserves\n                    );\n                } else {\n                    // maybe possible to happen due to some precision issue that both are 0\n                    revert FluidDexError(ErrorTypes.DexT1__DepositAmtsZero);\n                }\n\n                // new shares minted from swap & deposit\n                temp_ = (temp_ * totalSupplyShares_) / 1e18;\n                // adding fee in case of swap & deposit\n                // 1 - fee. If fee is 1% then without fee will be 1e6 - 1e4\n                // temp_ => withdraw fee\n                temp_ = (temp_ * (SIX_DECIMALS - ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n                // final new shares to mint for user\n                shares_ += temp_;\n                // final new collateral shares\n                totalSupplyShares_ += temp_;\n            } else {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidCollateralReserves);\n            }\n\n            if (estimate_) revert FluidDexLiquidityOutput(shares_);\n\n            if (shares_ < minSharesAmt_) revert FluidDexError(ErrorTypes.DexT1__SharesMintedLess);\n\n            if (token0Amt_ > 0) {\n                _verifyToken1Reserves(\n                    (c_.token0RealReserves + d_.token0AmtAdjusted),\n                    (c_.token1RealReserves + d_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                temp_ = token0Amt_;\n                _depositOrPaybackInLiquidity(TOKEN_0, temp_, 0);\n            }\n\n            if (token1Amt_ > 0) {\n                _verifyToken0Reserves(\n                    (c_.token0RealReserves + d_.token0AmtAdjusted),\n                    (c_.token1RealReserves + d_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                temp_ = token1Amt_;\n                _depositOrPaybackInLiquidity(TOKEN_1, temp_, 0);\n            }\n\n            // userSupply_ => temp_\n            temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            // extracting exisiting shares and then adding new shares in it\n            temp_ = ((temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK));\n\n            // calculate current, updated (expanded etc.) withdrawal limit\n            // newWithdrawalLimit_ => temp2_\n            temp2_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, temp_);\n\n            temp_ += shares_;\n\n            _updatingUserSupplyDataOnStorage(userSupplyData_, temp_, temp2_);\n\n            // updating total col shares in storage\n            _updateSupplyShares(totalSupplyShares_);\n\n            emit LogDepositColLiquidity(token0Amt_, token1Amt_, shares_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartColNotEnabled);\n        }\n    }\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) public _onlyDelegateCall returns (uint shares_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userSupplyData_ = _userSupplyData[msg.sender];\n\n        if (userSupplyData_ & 1 == 0 && to_ != ADDRESS_DEAD) revert FluidDexError(ErrorTypes.DexT1__UserSupplyInNotOn);\n\n        WithdrawColMemory memory w_;\n\n        w_.to = (to_ == address(0)) ? msg.sender : to_;\n\n        // is smart collateral pool enabled\n        if ((dexVariables2_ & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            uint token0Reserves_ = _getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, pex_.supplyToken0ExchangePrice, true);\n            uint token1Reserves_ = _getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, pex_.supplyToken1ExchangePrice, false);\n            w_.token0ReservesInitial = token0Reserves_;\n            w_.token1ReservesInitial = token1Reserves_;\n\n            if (token0Amt_ > 0) {\n                unchecked {\n                    w_.token0AmtAdjusted =\n                        (((token0Amt_ + 1) * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION) +\n                        1;\n                }\n                _verifySwapAndNonPerfectActions(w_.token0AmtAdjusted, token0Amt_);\n                _verifyRedeem(w_.token0AmtAdjusted, token0Reserves_);\n            }\n\n            if (token1Amt_ > 0) {\n                unchecked {\n                    w_.token1AmtAdjusted =\n                        (((token1Amt_ + 1) * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION) +\n                        1;\n                }\n                _verifySwapAndNonPerfectActions(w_.token1AmtAdjusted, token1Amt_);\n                _verifyRedeem(w_.token1AmtAdjusted, token1Reserves_);\n            }\n\n            uint temp_;\n            uint temp2_;\n\n            uint totalSupplyShares_ = _totalSupplyShares & X128;\n            if ((token0Reserves_ > 0) && (token1Reserves_ > 0)) {\n                if (w_.token0AmtAdjusted > 0 && w_.token1AmtAdjusted > 0) {\n                    // mint shares in equal proportion\n                    // temp_ => expected shares from token0 withdraw\n                    temp_ = (w_.token0AmtAdjusted * 1e18) / token0Reserves_;\n                    // temp2_ => expected shares from token1 withdraw\n                    temp2_ = (w_.token1AmtAdjusted * 1e18) / token1Reserves_;\n                    if (temp_ > temp2_) {\n                        // use temp2_ shares\n                        shares_ = ((temp2_ * totalSupplyShares_) / 1e18);\n                        // temp_ => token0 to swap\n                        temp_ = ((temp_ - temp2_) * token0Reserves_) / 1e18;\n                        temp2_ = 0;\n                    } else if (temp2_ > temp_) {\n                        // use temp1_ shares\n                        shares_ = ((temp_ * totalSupplyShares_) / 1e18);\n                        // temp2_ => token1 to swap\n                        temp2_ = ((temp2_ - temp_) * token1Reserves_) / 1e18;\n                        temp_ = 0;\n                    } else {\n                        // if equal then revert as swap will not be needed anymore which can create some issue, better to use withdraw in perfect proportion for this\n                        revert FluidDexError(ErrorTypes.DexT1__InvalidWithdrawAmts);\n                    }\n\n                    // User withdrew in equal proportion here. Hence updating col reserves and the swap will happen on updated col reserves\n                    token0Reserves_ = token0Reserves_ - ((token0Reserves_ * shares_) / totalSupplyShares_);\n                    token1Reserves_ = token1Reserves_ - ((token1Reserves_ * shares_) / totalSupplyShares_);\n                    totalSupplyShares_ -= shares_;\n                } else if (w_.token0AmtAdjusted > 0) {\n                    temp_ = w_.token0AmtAdjusted;\n                    temp2_ = 0;\n                } else if (w_.token1AmtAdjusted > 0) {\n                    temp_ = 0;\n                    temp2_ = w_.token1AmtAdjusted;\n                } else {\n                    // user sent both amounts as 0\n                    revert FluidDexError(ErrorTypes.DexT1__WithdrawAmtsZero);\n                }\n\n                uint token0ImaginaryReservesOutsideRangpex_;\n                uint token1ImaginaryReservesOutsideRangpex_;\n\n                if (pex_.geometricMean < 1e27) {\n                    (\n                        token0ImaginaryReservesOutsideRangpex_,\n                        token1ImaginaryReservesOutsideRangpex_\n                    ) = _calculateReservesOutsideRange(\n                        pex_.geometricMean,\n                        pex_.upperRange,\n                        (token0Reserves_ - temp_),\n                        (token1Reserves_ - temp2_)\n                    );\n                } else {\n                    // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n                    // 1 / geometricMean for new geometricMean\n                    // 1 / lowerRange will become upper range\n                    // 1 / upperRange will become lower range\n                    (\n                        token1ImaginaryReservesOutsideRangpex_,\n                        token0ImaginaryReservesOutsideRangpex_\n                    ) = _calculateReservesOutsideRange(\n                        (1e54 / pex_.geometricMean),\n                        (1e54 / pex_.lowerRange),\n                        (token1Reserves_ - temp2_),\n                        (token0Reserves_ - temp_)\n                    );\n                }\n\n                if (temp_ > 0) {\n                    // swap into token0\n                    temp_ = _getWithdrawAndSwap(\n                        token0Reserves_, // token0 real reserves\n                        token1Reserves_, // token1 real reserves\n                        token0ImaginaryReservesOutsideRangpex_, // token0 imaginary reserves\n                        token1ImaginaryReservesOutsideRangpex_, // token1 imaginary reserves\n                        temp_ // token0 to divide and swap into\n                    );\n                } else if (temp2_ > 0) {\n                    // swap into token1\n                    temp_ = _getWithdrawAndSwap(\n                        token1Reserves_, // token1 real reserves\n                        token0Reserves_, // token0 real reserves\n                        token1ImaginaryReservesOutsideRangpex_, // token1 imaginary reserves\n                        token0ImaginaryReservesOutsideRangpex_, // token0 imaginary reserves\n                        temp2_ // token0 to divide and swap into\n                    );\n                } else {\n                    // maybe possible to happen due to some precision issue that both are 0\n                    revert FluidDexError(ErrorTypes.DexT1__WithdrawAmtsZero);\n                }\n\n                // shares to burn from withdraw & swap\n                temp_ = ((temp_ * totalSupplyShares_) / 1e18);\n                // adding fee in case of withdraw & swap\n                // 1 + fee. If fee is 1% then withdrawing withFepex_ will be 1e6 + 1e4\n                temp_ = (temp_ * (SIX_DECIMALS + ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n                // updating shares to burn for user\n                shares_ += temp_;\n                // final new collateral shares\n                totalSupplyShares_ -= temp_;\n            } else {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidCollateralReserves);\n            }\n\n            if (to_ == ADDRESS_DEAD) revert FluidDexLiquidityOutput(shares_);\n\n            if (shares_ > maxSharesAmt_) revert FluidDexError(ErrorTypes.DexT1__WithdrawExcessSharesBurn);\n\n            // userSupply_ => temp_\n            temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) withdrawal limit\n            // newWithdrawalLimit_ => temp2_\n            temp2_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, temp_);\n\n            temp_ -= shares_;\n\n            // withdrawal limit reached\n            if (temp_ < temp2_) revert FluidDexError(ErrorTypes.DexT1__WithdrawLimitReached);\n\n            _updatingUserSupplyDataOnStorage(userSupplyData_, temp_, temp2_);\n\n            // updating total col shares in storage\n            _updateSupplyShares(totalSupplyShares_);\n\n            if (w_.token0AmtAdjusted > 0) {\n                _verifyToken0Reserves(\n                    (w_.token0ReservesInitial - w_.token0AmtAdjusted),\n                    (w_.token1ReservesInitial - w_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // withdraw\n                temp_ = token0Amt_;\n                LIQUIDITY.operate(TOKEN_0, -int(temp_), 0, w_.to, address(0), new bytes(0));\n            }\n\n            if (w_.token1AmtAdjusted > 0) {\n                _verifyToken1Reserves(\n                    (w_.token0ReservesInitial - w_.token0AmtAdjusted),\n                    (w_.token1ReservesInitial - w_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // withdraw\n                temp_ = token1Amt_;\n                LIQUIDITY.operate(TOKEN_1, -int(temp_), 0, w_.to, address(0), new bytes(0));\n            }\n\n            emit LogWithdrawColLiquidity(token0Amt_, token1Amt_, shares_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartColNotEnabled);\n        }\n    }\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) public _onlyDelegateCall returns (uint withdrawAmt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userSupplyData_ = _userSupplyData[msg.sender];\n\n        if (userSupplyData_ & 1 == 0 && to_ != ADDRESS_DEAD) {\n            revert FluidDexError(ErrorTypes.DexT1__UserSupplyInNotOn);\n        }\n\n        to_ = (to_ == address(0)) ? msg.sender : to_;\n\n        if ((minToken0_ > 0 && minToken1_ > 0) || (minToken0_ == 0 && minToken1_ == 0)) {\n            // only 1 token should be > 0\n            revert FluidDexError(ErrorTypes.DexT1__InvalidWithdrawAmts);\n        }\n\n        // is smart collateral pool enabled\n        if ((dexVariables2_ & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            uint totalSupplyShares_ = _totalSupplyShares & X128;\n\n            _verifyRedeem(shares_, totalSupplyShares_);\n\n            uint token0Amt_;\n            uint token1Amt_;\n\n            CollateralReserves memory c_ = _getCollateralReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.supplyToken0ExchangePrice,\n                pex_.supplyToken1ExchangePrice\n            );\n\n            if ((c_.token0RealReserves == 0) || (c_.token1RealReserves == 0)) {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidCollateralReserves);\n            }\n\n            CollateralReserves memory c2_ = _getUpdatedColReserves(shares_, totalSupplyShares_, c_, false);\n            // Storing exact token0 & token1 raw/adjusted withdrawal amount after burning shares\n            token0Amt_ = c_.token0RealReserves - c2_.token0RealReserves - 1;\n            token1Amt_ = c_.token1RealReserves - c2_.token1RealReserves - 1;\n\n            if (minToken0_ > 0) {\n                // user wants to withdraw entirely in token0, hence swapping token1 into token0\n                token0Amt_ += _getAmountOut(token1Amt_, c2_.token1ImaginaryReserves, c2_.token0ImaginaryReserves);\n                token1Amt_ = 0;\n                _verifyToken0Reserves(\n                    (c_.token0RealReserves - token0Amt_),\n                    c_.token1RealReserves,\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n\n                // converting token0Amt_ from raw/adjusted to normal token amount\n                token0Amt_ = (((token0Amt_ - 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) - 1;\n\n                // deducting fee on withdrawing in 1 token\n                token0Amt_ = (token0Amt_ * (SIX_DECIMALS - ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n\n                withdrawAmt_ = token0Amt_;\n                if (to_ == ADDRESS_DEAD) revert FluidDexLiquidityOutput(shares_);\n                if (withdrawAmt_ < minToken0_) revert FluidDexError(ErrorTypes.DexT1__WithdrawalNotEnough);\n            } else {\n                // user wants to withdraw entirely in token1, hence swapping token0 into token1\n                token1Amt_ += _getAmountOut(token0Amt_, c2_.token0ImaginaryReserves, c2_.token1ImaginaryReserves);\n                token0Amt_ = 0;\n                _verifyToken1Reserves(\n                    c_.token0RealReserves,\n                    (c_.token1RealReserves - token1Amt_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n\n                // converting token1Amt_ from raw/adjusted to normal token amount\n                token1Amt_ = (((token1Amt_ - 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) - 1;\n\n                // deducting fee on withdrawing in 1 token\n                token1Amt_ = (token1Amt_ * (SIX_DECIMALS - ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n\n                withdrawAmt_ = token1Amt_;\n                if (to_ == ADDRESS_DEAD) revert FluidDexLiquidityOutput(shares_);\n                if (withdrawAmt_ < minToken1_) revert FluidDexError(ErrorTypes.DexT1__WithdrawalNotEnough);\n            }\n\n            uint256 userSupply_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            userSupply_ = (userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) withdrawal limit\n            // temp_ => newWithdrawalLimit_\n            uint256 temp_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\n\n            userSupply_ -= shares_;\n\n            // withdraws below limit\n            if (userSupply_ < temp_) revert FluidDexError(ErrorTypes.DexT1__WithdrawLimitReached);\n\n            _updatingUserSupplyDataOnStorage(userSupplyData_, userSupply_, temp_);\n\n            totalSupplyShares_ = totalSupplyShares_ - shares_;\n            _updateSupplyShares(totalSupplyShares_);\n\n            // to avoid stack-too-deep error\n            temp_ = uint160(to_);\n            if (minToken0_ > 0) {\n                // withdraw\n                LIQUIDITY.operate(TOKEN_0, -int(token0Amt_), 0, address(uint160(temp_)), address(0), new bytes(0));\n            } else {\n                // withdraw\n                LIQUIDITY.operate(TOKEN_1, -int(token1Amt_), 0, address(uint160(temp_)), address(0), new bytes(0));\n            }\n\n            // to avoid stack-too-deep error\n            temp_ = shares_;\n            emit LogWithdrawColInOneToken(temp_, token0Amt_, token1Amt_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartColNotEnabled);\n        }\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/core/debtOperations.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SecondaryHelpers } from \"../helpers/secondaryHelpers.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @title FluidDexT1\n/// @notice Implements core logics for Fluid Dex protocol.\n/// Note Token transfers happen directly from user to Liquidity contract and vice-versa.\ncontract FluidDexT1OperationsDebt is SecondaryHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) SecondaryHelpers(constantViews_) {\n        // all implementations should be zero other than shift\n        if (\n            constantViews_.implementations.shift == address(0) ||\n            constantViews_.implementations.admin != address(0) ||\n            constantViews_.implementations.colOperations != address(0) ||\n            constantViews_.implementations.debtOperations != address(0) ||\n            constantViews_.implementations.perfectOperationsAndSwapOut != address(0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__InvalidImplementation);\n        }\n    }\n\n    modifier _onlyDelegateCall() {\n        // also indirectly checked by `_check` because pool can never be initialized as long as the initialize method\n        // is delegate call only, but just to be sure on Admin logic we add the modifier everywhere nonetheless.\n        if (address(this) == THIS_CONTRACT) {\n            revert FluidDexError(ErrorTypes.DexT1__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_ \n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) public _onlyDelegateCall returns (uint shares_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userBorrowData_ = _userBorrowData[msg.sender];\n\n        if (userBorrowData_ & 1 == 0 && to_ != ADDRESS_DEAD) revert FluidDexError(ErrorTypes.DexT1__UserDebtInNotOn);\n\n        BorrowDebtMemory memory b_;\n\n        b_.to = (to_ == address(0)) ? msg.sender : to_;\n\n        // is smart debt pool enabled\n        if (((dexVariables2_ >> 1) & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            uint token0Debt_ = _getLiquidityDebt(BORROW_TOKEN_0_SLOT, pex_.borrowToken0ExchangePrice, true);\n            uint token1Debt_ = _getLiquidityDebt(BORROW_TOKEN_1_SLOT, pex_.borrowToken1ExchangePrice, false);\n            b_.token0DebtInitial = token0Debt_;\n            b_.token1DebtInitial = token1Debt_;\n\n            if (token0Amt_ > 0) {\n                b_.token0AmtAdjusted =\n                    (((token0Amt_ + 1) * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION) +\n                    1;\n                _verifySwapAndNonPerfectActions(b_.token0AmtAdjusted, token0Amt_);\n                _verifyMint(b_.token0AmtAdjusted, token0Debt_);\n            }\n\n            if (token1Amt_ > 0) {\n                b_.token1AmtAdjusted =\n                    (((token1Amt_ + 1) * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION) +\n                    1;\n                _verifySwapAndNonPerfectActions(b_.token1AmtAdjusted, token1Amt_);\n                _verifyMint(b_.token1AmtAdjusted, token1Debt_);\n            }\n\n            uint temp_;\n            uint temp2_;\n\n            uint totalBorrowShares_ = _totalBorrowShares & X128;\n            if ((token0Debt_ > 0) && (token1Debt_ > 0)) {\n                if (b_.token0AmtAdjusted > 0 && b_.token1AmtAdjusted > 0) {\n                    // mint shares in equal proportion\n                    // temp_ => expected shares from token0 payback\n                    temp_ = (b_.token0AmtAdjusted * 1e18) / token0Debt_;\n                    // temp2_ => expected shares from token1 payback\n                    temp2_ = (b_.token1AmtAdjusted * 1e18) / token1Debt_;\n                    if (temp_ > temp2_) {\n                        // use temp2_ shares\n                        shares_ = (temp2_ * totalBorrowShares_) / 1e18;\n                        // temp_ => token0 to swap\n                        temp_ = ((temp_ - temp2_) * token0Debt_) / 1e18;\n                        temp2_ = 0;\n                    } else if (temp2_ > temp_) {\n                        // use temp1_ shares\n                        shares_ = (temp_ * totalBorrowShares_) / 1e18;\n                        // temp2_ => token1 to swap\n                        temp2_ = ((temp2_ - temp_) * token1Debt_) / 1e18;\n                        temp_ = 0;\n                    } else {\n                        // if equal then revert as swap will not be needed anymore which can create some issue, better to use perfect borrow in this case\n                        revert FluidDexError(ErrorTypes.DexT1__InvalidBorrowAmts);\n                    }\n\n                    // User borrowed in equal proportion here. Hence updating col reserves and the swap will happen on updated col reserves\n                    token0Debt_ = token0Debt_ + (token0Debt_ * shares_) / totalBorrowShares_;\n                    token1Debt_ = token1Debt_ + (token1Debt_ * shares_) / totalBorrowShares_;\n                    totalBorrowShares_ += shares_;\n                } else if (b_.token0AmtAdjusted > 0) {\n                    temp_ = b_.token0AmtAdjusted;\n                    temp2_ = 0;\n                } else if (b_.token1AmtAdjusted > 0) {\n                    temp_ = 0;\n                    temp2_ = b_.token1AmtAdjusted;\n                } else {\n                    // user sent both amounts as 0\n                    revert FluidDexError(ErrorTypes.DexT1__InvalidBorrowAmts);\n                }\n\n                uint token0FinalImaginaryReserves_;\n                uint token1FinalImaginaryReserves_;\n\n                if (pex_.geometricMean < 1e27) {\n                    (, , token0FinalImaginaryReserves_, token1FinalImaginaryReserves_) = _calculateDebtReserves(\n                        pex_.geometricMean,\n                        pex_.lowerRange,\n                        (token0Debt_ + temp_),\n                        (token1Debt_ + temp2_)\n                    );\n                } else {\n                    // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n                    // 1 / geometricMean for new geometricMean\n                    // 1 / lowerRange will become upper range\n                    // 1 / upperRange will become lower range\n                    (, , token1FinalImaginaryReserves_, token0FinalImaginaryReserves_) = _calculateDebtReserves(\n                        (1e54 / pex_.geometricMean),\n                        (1e54 / pex_.upperRange),\n                        (token1Debt_ + temp2_),\n                        (token0Debt_ + temp_)\n                    );\n                }\n\n                if (temp_ > 0) {\n                    // swap into token0\n                    temp_ = _getBorrowAndSwap(\n                        token0Debt_, // token0 debt\n                        token1Debt_, // token1 debt\n                        token0FinalImaginaryReserves_, // token0 imaginary reserves\n                        token1FinalImaginaryReserves_, // token1 imaginary reserves\n                        temp_ // token0 to divide and swap into\n                    );\n                } else if (temp2_ > 0) {\n                    // swap into token1\n                    temp_ = _getBorrowAndSwap(\n                        token1Debt_, // token1 debt\n                        token0Debt_, // token0 debt\n                        token1FinalImaginaryReserves_, // token1 imaginary reserves\n                        token0FinalImaginaryReserves_, // token0 imaginary reserves\n                        temp2_ // token1 to divide and swap into\n                    );\n                } else {\n                    // maybe possible to happen due to some precision issue that both are 0\n                    revert FluidDexError(ErrorTypes.DexT1__BorrowAmtsZero);\n                }\n\n                // new shares to mint from borrow & swap\n                temp_ = (temp_ * totalBorrowShares_) / 1e18;\n                // adding fee in case of borrow & swap\n                // 1 + fee. If fee is 1% then withdrawing withFepex_ will be 1e6 + 1e4\n                temp_ = (temp_ * (SIX_DECIMALS + ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n                // final new shares to mint for user\n                shares_ += temp_;\n                // final new debt shares\n                totalBorrowShares_ += temp_;\n            } else {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidDebtReserves);\n            }\n\n            if (to_ == ADDRESS_DEAD) revert FluidDexLiquidityOutput(shares_);\n\n            if (shares_ > maxSharesAmt_) revert FluidDexError(ErrorTypes.DexT1__BorrowExcessSharesMinted);\n\n            // extract user borrow amount\n            // userBorrow_ => temp_\n            temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) borrow limit\n            // newBorrowLimit_ => temp2_\n            temp2_ = DexCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, temp_);\n\n            temp_ += shares_;\n\n            // user above debt limit\n            if (temp_ > temp2_) revert FluidDexError(ErrorTypes.DexT1__DebtLimitReached);\n\n            _updatingUserBorrowDataOnStorage(userBorrowData_, temp_, temp2_);\n\n            if (b_.token0AmtAdjusted > 0) {\n                // comparing debt here rather than reserves to simply code, impact won't be much overall\n                _verifyToken1Reserves(\n                    (b_.token0DebtInitial + b_.token0AmtAdjusted),\n                    (b_.token1DebtInitial + b_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // assigning token0Amt_ to temp_ to avoid compilation error (I don't know why it's throwing when using token0Amt_ directly)\n                temp_ = token0Amt_;\n                // borrow\n                LIQUIDITY.operate(TOKEN_0, 0, int(temp_), address(0), b_.to, new bytes(0));\n            }\n\n            if (b_.token1AmtAdjusted > 0) {\n                // comparing debt here rather than reserves to simply code, impact won't be much overall\n                _verifyToken0Reserves(\n                    (b_.token0DebtInitial + b_.token0AmtAdjusted),\n                    (b_.token1DebtInitial + b_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // assigning token1Amt_ to temp_ to avoid compilation error (I don't know why it's throwing when using token0Amt_ directly)\n                temp_ = token1Amt_;\n                // borrow\n                LIQUIDITY.operate(TOKEN_1, 0, int(temp_), address(0), b_.to, new bytes(0));\n            }\n\n            // updating total debt shares in storage\n            _updateBorrowShares(totalBorrowShares_);\n\n            emit LogBorrowDebtLiquidity(token0Amt_, token1Amt_, shares_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartDebtNotEnabled);\n        }\n    }\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) public payable _onlyDelegateCall returns (uint shares_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userBorrowData_ = _userBorrowData[msg.sender];\n\n        if (userBorrowData_ & 1 == 0 && !estimate_) revert FluidDexError(ErrorTypes.DexT1__UserDebtInNotOn);\n\n        // is smart debt pool enabled\n        if (((dexVariables2_ >> 1) & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            PaybackDebtMemory memory p_;\n\n            DebtReserves memory d_ = _getDebtReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.borrowToken0ExchangePrice,\n                pex_.borrowToken1ExchangePrice\n            );\n            DebtReserves memory d2_ = d_;\n\n            if (token0Amt_ > 0) {\n                p_.token0AmtAdjusted =\n                    (((token0Amt_ - 1) * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION) -\n                    1;\n                _verifySwapAndNonPerfectActions(p_.token0AmtAdjusted, token0Amt_);\n                _verifyRedeem(p_.token0AmtAdjusted, d_.token0Debt);\n            }\n\n            if (token1Amt_ > 0) {\n                p_.token1AmtAdjusted =\n                    (((token1Amt_ - 1) * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION) -\n                    1;\n                _verifySwapAndNonPerfectActions(p_.token1AmtAdjusted, token1Amt_);\n                _verifyRedeem(p_.token1AmtAdjusted, d_.token1Debt);\n            }\n\n            uint temp_;\n            uint temp2_;\n\n            uint totalBorrowShares_ = _totalBorrowShares & X128;\n            if ((d_.token0Debt > 0) && (d_.token1Debt > 0)) {\n                if (p_.token0AmtAdjusted > 0 && p_.token1AmtAdjusted > 0) {\n                    // burn shares in equal proportion\n                    // temp_ => expected shares from token0 payback\n                    temp_ = (p_.token0AmtAdjusted * 1e18) / d_.token0Debt;\n                    // temp2_ => expected shares from token1 payback\n                    temp2_ = (p_.token1AmtAdjusted * 1e18) / d_.token1Debt;\n                    if (temp_ > temp2_) {\n                        // use temp2_ shares\n                        shares_ = ((temp2_ * totalBorrowShares_) / 1e18);\n                        // temp_ => token0 to swap\n                        temp_ = p_.token0AmtAdjusted - (temp2_ * p_.token0AmtAdjusted) / temp_;\n                        temp2_ = 0;\n                    } else if (temp2_ > temp_) {\n                        // use temp_ shares\n                        shares_ = ((temp_ * totalBorrowShares_) / 1e18);\n                        // temp2_ => token1 to swap\n                        temp2_ = p_.token1AmtAdjusted - ((temp_ * p_.token1AmtAdjusted) / temp2_); // to this\n                        temp_ = 0;\n                    } else {\n                        // if equal then revert as swap will not be needed anymore which can create some issue, better to use perfect payback in this case\n                        revert FluidDexError(ErrorTypes.DexT1__InvalidPaybackAmts);\n                    }\n\n                    // User paid back in equal proportion here. Hence updating debt reserves and the swap will happen on updated debt reserves\n                    d2_ = _getUpdateDebtReserves(\n                        shares_,\n                        totalBorrowShares_,\n                        d_,\n                        false // true if mint, false if burn\n                    );\n                    totalBorrowShares_ -= shares_;\n                } else if (p_.token0AmtAdjusted > 0) {\n                    temp_ = p_.token0AmtAdjusted;\n                    temp2_ = 0;\n                } else if (p_.token1AmtAdjusted > 0) {\n                    temp_ = 0;\n                    temp2_ = p_.token1AmtAdjusted;\n                } else {\n                    // user sent both amounts as 0\n                    revert FluidDexError(ErrorTypes.DexT1__InvalidPaybackAmts);\n                }\n\n                if (temp_ > 0) {\n                    // swap token0 into token1 and payback equally\n                    temp_ = _getSwapAndPayback(\n                        d2_.token0Debt,\n                        d2_.token1Debt,\n                        d2_.token0ImaginaryReserves,\n                        d2_.token1ImaginaryReserves,\n                        temp_\n                    );\n                } else if (temp2_ > 0) {\n                    // swap token1 into token0 and payback equally\n                    temp_ = _getSwapAndPayback(\n                        d2_.token1Debt,\n                        d2_.token0Debt,\n                        d2_.token1ImaginaryReserves,\n                        d2_.token0ImaginaryReserves,\n                        temp2_\n                    );\n                } else {\n                    // maybe possible to happen due to some precision issue that both are 0\n                    revert FluidDexError(ErrorTypes.DexT1__PaybackAmtsZero);\n                }\n\n                // new shares to burn from payback & swap\n                temp_ = ((temp_ * totalBorrowShares_) / 1e18);\n\n                // adding fee in case of payback & swap\n                // 1 - fee. If fee is 1% then withdrawing withFepex_ will be 1e6 - 1e4\n                temp_ = (temp_ * (SIX_DECIMALS - ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n                // final shares to burn for user\n                shares_ += temp_;\n                // final new debt shares\n                totalBorrowShares_ -= temp_;\n            } else {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidDebtReserves);\n            }\n\n            if (estimate_) revert FluidDexLiquidityOutput(shares_);\n\n            if (shares_ < minSharesAmt_) revert FluidDexError(ErrorTypes.DexT1__PaybackSharedBurnedLess);\n\n            if (token0Amt_ > 0) {\n                // comparing debt here rather than reserves to simply code, impact won't be much overall\n                _verifyToken0Reserves(\n                    (d_.token0Debt - p_.token0AmtAdjusted),\n                    (d_.token1Debt - p_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // payback\n                temp_ = token0Amt_;\n                _depositOrPaybackInLiquidity(TOKEN_0, 0, temp_);\n            }\n\n            if (token1Amt_ > 0) {\n                // comparing debt here rather than reserves to simply code, impact won't be much overall\n                _verifyToken1Reserves(\n                    (d_.token0Debt - p_.token0AmtAdjusted),\n                    (d_.token1Debt - p_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // payback\n                temp_ = token1Amt_;\n                _depositOrPaybackInLiquidity(TOKEN_1, 0, temp_);\n            }\n\n            // extract user borrow amount\n            // userBorrow_ => temp_\n            temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) borrow limit\n            // newBorrowLimit_ => temp2_\n            temp2_ = DexCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, temp_);\n\n            temp_ -= shares_;\n\n            _updatingUserBorrowDataOnStorage(userBorrowData_, temp_, temp2_);\n            // updating total debt shares in storage\n            _updateBorrowShares(totalBorrowShares_);\n\n            emit LogPaybackDebtLiquidity(token0Amt_, token1Amt_, shares_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartDebtNotEnabled);\n        }\n    }\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) public payable _onlyDelegateCall returns (uint paybackAmt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userBorrowData_ = _userBorrowData[msg.sender];\n\n        if (userBorrowData_ & 1 == 0 && !estimate_) revert FluidDexError(ErrorTypes.DexT1__UserDebtInNotOn);\n\n        if ((maxToken0_ > 0 && maxToken1_ > 0) || (maxToken0_ == 0 && maxToken1_ == 0)) {\n            // only 1 token should be > 0\n            revert FluidDexError(ErrorTypes.DexT1__InvalidWithdrawAmts);\n        }\n\n        // is smart debt pool enabled\n        if (((dexVariables2_ >> 1) & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            uint totalBorrowShares_ = _totalBorrowShares & X128;\n\n            _verifyRedeem(shares_, totalBorrowShares_);\n\n            uint token0Amt_;\n            uint token1Amt_;\n\n            // smart debt in enabled\n            DebtReserves memory d_ = _getDebtReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.borrowToken0ExchangePrice,\n                pex_.borrowToken1ExchangePrice\n            );\n\n            if ((d_.token0Debt == 0) || (d_.token1Debt == 0)) {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidDebtReserves);\n            }\n\n            // Removing debt liquidity in equal proportion\n            DebtReserves memory d2_ = _getUpdateDebtReserves(shares_, totalBorrowShares_, d_, false);\n\n            if (maxToken0_ > 0) {\n                // entire payback is in token0_\n                token0Amt_ = _getSwapAndPaybackOneTokenPerfectShares(\n                    d2_.token0ImaginaryReserves,\n                    d2_.token1ImaginaryReserves,\n                    d_.token0Debt,\n                    d_.token1Debt,\n                    d2_.token0RealReserves,\n                    d2_.token1RealReserves\n                );\n                _verifyToken0Reserves(\n                    (d_.token0Debt - token0Amt_),\n                    d_.token1Debt,\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n\n                // converting from raw/adjusted to normal token amounts\n                token0Amt_ = (((token0Amt_ + 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) + 1;\n\n                // adding fee on paying back in 1 token\n                token0Amt_ = (token0Amt_ * (SIX_DECIMALS + ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n\n                paybackAmt_ = token0Amt_;\n                if (estimate_) revert FluidDexSingleTokenOutput(paybackAmt_);\n                if (paybackAmt_ > maxToken0_) revert FluidDexError(ErrorTypes.DexT1__PaybackAmtTooHigh);\n                _depositOrPaybackInLiquidity(TOKEN_0, 0, paybackAmt_);\n            } else {\n                // entire payback is in token1_\n                token1Amt_ = _getSwapAndPaybackOneTokenPerfectShares(\n                    d2_.token1ImaginaryReserves,\n                    d2_.token0ImaginaryReserves,\n                    d_.token1Debt,\n                    d_.token0Debt,\n                    d2_.token1RealReserves,\n                    d2_.token0RealReserves\n                );\n                _verifyToken1Reserves(\n                    d_.token0Debt,\n                    (d_.token1Debt - token1Amt_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n\n                // converting from raw/adjusted to normal token amounts\n                token1Amt_ = (((token1Amt_ + 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) + 1;\n\n                // adding fee on paying back in 1 token\n                token1Amt_ = (token1Amt_ * (SIX_DECIMALS + ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n\n                paybackAmt_ = token1Amt_;\n                if (estimate_) revert FluidDexSingleTokenOutput(paybackAmt_);\n                if (paybackAmt_ > maxToken1_) revert FluidDexError(ErrorTypes.DexT1__PaybackAmtTooHigh);\n                _depositOrPaybackInLiquidity(TOKEN_1, 0, paybackAmt_);\n            }\n\n            // extract user borrow amount\n            uint256 userBorrow_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n            userBorrow_ = (userBorrow_ >> DEFAULT_EXPONENT_SIZE) << (userBorrow_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) borrow limit\n            // temp_ => newBorrowLimit_\n            uint256 temp_ = DexCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, userBorrow_);\n            userBorrow_ -= shares_;\n\n            _updatingUserBorrowDataOnStorage(userBorrowData_, userBorrow_, temp_);\n\n            totalBorrowShares_ = totalBorrowShares_ - shares_;\n            _updateBorrowShares(totalBorrowShares_);\n\n            // to avoid stack-too-deep error\n            temp_ = shares_;\n            emit LogPaybackDebtInOneToken(temp_, token0Amt_, token1Amt_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartDebtNotEnabled);\n        }\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/core/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { CoreHelpers } from \"../helpers/coreHelpers.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { IFluidDexT1 } from \"../../../interfaces/iDexT1.sol\";\n\ninterface IDexCallback {\n    function dexCallback(address token_, uint256 amount_) external;\n}\n\n/// @title FluidDexT1\n/// @notice Implements core logics for Fluid Dex protocol.\n/// Note Token transfers happen directly from user to Liquidity contract and vice-versa.\ncontract FluidDexT1 is CoreHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) CoreHelpers(constantViews_) {\n        // any implementations should not be zero\n        if (\n            constantViews_.implementations.shift == address(0) ||\n            constantViews_.implementations.admin == address(0) ||\n            constantViews_.implementations.colOperations == address(0) ||\n            constantViews_.implementations.debtOperations == address(0) ||\n            constantViews_.implementations.perfectOperationsAndSwapOut == address(0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__InvalidImplementation);\n        }\n    }\n\n    struct SwapInExtras {\n        address to;\n        uint amountOutMin;\n        bool isCallback;\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param extras_ Additional parameters for the swap:\n    ///   - to: Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    ///   - amountOutMin: The minimum amount of output tokens the user expects to receive\n    ///   - isCallback: If true, indicates that the input tokens should be transferred via a callback\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function _swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        SwapInExtras memory extras_\n    ) internal returns (uint256 amountOut_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        if ((dexVariables2_ >> 255) == 1) revert FluidDexError(ErrorTypes.DexT1__SwapAndArbitragePaused);\n\n        _check(dexVariables_, dexVariables2_);\n\n        if (extras_.to == address(0)) extras_.to = msg.sender;\n\n        SwapInMemory memory s_;\n\n        if (swap0to1_) {\n            (s_.tokenIn, s_.tokenOut) = (TOKEN_0, TOKEN_1);\n            unchecked {\n                s_.amtInAdjusted = (amountIn_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION;\n            }\n        } else {\n            (s_.tokenIn, s_.tokenOut) = (TOKEN_1, TOKEN_0);\n            unchecked {\n                s_.amtInAdjusted = (amountIn_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION;\n            }\n        }\n\n        _verifySwapAndNonPerfectActions(s_.amtInAdjusted, amountIn_);\n\n        PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n        if (msg.value > 0) {\n            if (msg.value != amountIn_) revert FluidDexError(ErrorTypes.DexT1__EthAndAmountInMisMatch);\n            if (s_.tokenIn != NATIVE_TOKEN) revert FluidDexError(ErrorTypes.DexT1__EthSentForNonNativeSwap);\n        }\n\n        // is smart collateral pool enabled\n        uint temp_ = dexVariables2_ & 1;\n        // is smart debt pool enabled\n        uint temp2_ = (dexVariables2_ >> 1) & 1;\n\n        uint temp3_;\n        uint temp4_;\n\n        // extracting fee\n        temp3_ = ((dexVariables2_ >> 2) & X17);\n        unchecked {\n            // revenueCut in 6 decimals, to have proper precision\n            // if fee = 1% and revenue cut = 10% then revenueCut = 1e8 - (10000 * 10) = 99900000\n            s_.revenueCut = EIGHT_DECIMALS - ((((dexVariables2_ >> 19) & X7) * temp3_));\n            // fee in 4 decimals\n            // 1 - fee. If fee is 1% then withoutFee will be 1e6 - 1e4\n            // s_.fee => 1 - withdraw fee\n            s_.fee = SIX_DECIMALS - temp3_;\n        }\n\n        CollateralReservesSwap memory cs_;\n        DebtReservesSwap memory ds_;\n        if (temp_ == 1) {\n            // smart collateral is enabled\n            {\n                CollateralReserves memory c_ = _getCollateralReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.supplyToken0ExchangePrice,\n                    pex_.supplyToken1ExchangePrice\n                );\n                if (swap0to1_) {\n                    (\n                        cs_.tokenInRealReserves,\n                        cs_.tokenOutRealReserves,\n                        cs_.tokenInImaginaryReserves,\n                        cs_.tokenOutImaginaryReserves\n                    ) = (\n                        c_.token0RealReserves,\n                        c_.token1RealReserves,\n                        c_.token0ImaginaryReserves,\n                        c_.token1ImaginaryReserves\n                    );\n                } else {\n                    (\n                        cs_.tokenInRealReserves,\n                        cs_.tokenOutRealReserves,\n                        cs_.tokenInImaginaryReserves,\n                        cs_.tokenOutImaginaryReserves\n                    ) = (\n                        c_.token1RealReserves,\n                        c_.token0RealReserves,\n                        c_.token1ImaginaryReserves,\n                        c_.token0ImaginaryReserves\n                    );\n                }\n            }\n        }\n\n        if (temp2_ == 1) {\n            // smart debt is enabled\n            {\n                DebtReserves memory d_ = _getDebtReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.borrowToken0ExchangePrice,\n                    pex_.borrowToken1ExchangePrice\n                );\n                if (swap0to1_) {\n                    (\n                        ds_.tokenInDebt,\n                        ds_.tokenOutDebt,\n                        ds_.tokenInRealReserves,\n                        ds_.tokenOutRealReserves,\n                        ds_.tokenInImaginaryReserves,\n                        ds_.tokenOutImaginaryReserves\n                    ) = (\n                        d_.token0Debt,\n                        d_.token1Debt,\n                        d_.token0RealReserves,\n                        d_.token1RealReserves,\n                        d_.token0ImaginaryReserves,\n                        d_.token1ImaginaryReserves\n                    );\n                } else {\n                    (\n                        ds_.tokenInDebt,\n                        ds_.tokenOutDebt,\n                        ds_.tokenInRealReserves,\n                        ds_.tokenOutRealReserves,\n                        ds_.tokenInImaginaryReserves,\n                        ds_.tokenOutImaginaryReserves\n                    ) = (\n                        d_.token1Debt,\n                        d_.token0Debt,\n                        d_.token1RealReserves,\n                        d_.token0RealReserves,\n                        d_.token1ImaginaryReserves,\n                        d_.token0ImaginaryReserves\n                    );\n                }\n            }\n        }\n\n        // limiting amtInAdjusted to be not more than 50% of both (collateral & debt) imaginary tokenIn reserves combined\n        // basically, if this throws that means user is trying to swap 0.5x tokenIn if current tokenIn imaginary reserves is x\n        // let's take x as token0 here, that means, initially the pool pricing might be:\n        // token1Reserve / x and new pool pricing will become token1Reserve / 1.5x (token1Reserve will decrease after swap but for simplicity ignoring that)\n        // So pool price is decreased by ~33.33% (oracle will throw error in this case as it only allows 5% price difference but better to limit it before hand)\n        unchecked {\n            if (s_.amtInAdjusted > ((cs_.tokenInImaginaryReserves + ds_.tokenInImaginaryReserves) / 2))\n                revert FluidDexError(ErrorTypes.DexT1__SwapInLimitingAmounts);\n        }\n\n        if (temp_ == 1 && temp2_ == 1) {\n            // unless both pools are enabled s_.swapRoutingAmt will be 0\n            s_.swapRoutingAmt = _swapRoutingIn(\n                s_.amtInAdjusted,\n                cs_.tokenOutImaginaryReserves,\n                cs_.tokenInImaginaryReserves,\n                ds_.tokenOutImaginaryReserves,\n                ds_.tokenInImaginaryReserves\n            );\n        }\n\n        // In below if else statement temps are:\n        // temp_ => deposit amt\n        // temp2_ => withdraw amt\n        // temp3_ => payback amt\n        // temp4_ => borrow amt\n        if (int(s_.amtInAdjusted) > s_.swapRoutingAmt && s_.swapRoutingAmt > 0) {\n            // swap will route from the both pools\n            // temp_ = amountInCol_\n            temp_ = uint(s_.swapRoutingAmt);\n            unchecked {\n                // temp3_ = amountInDebt_\n                temp3_ = s_.amtInAdjusted - temp_;\n            }\n\n            (temp2_, temp4_) = (0, 0);\n\n            // debt pool price will be the same as collateral pool after the swap\n            s_.withdrawTo = extras_.to;\n            s_.borrowTo = extras_.to;\n        } else if ((temp_ == 1 && temp2_ == 0) || (s_.swapRoutingAmt >= int(s_.amtInAdjusted))) {\n            // entire swap will route through collateral pool\n            (temp_, temp2_, temp3_, temp4_) = (s_.amtInAdjusted, 0, 0, 0);\n            // price can slightly differ from debt pool but difference will be very small. Probably <0.01% for active DEX pools.\n            s_.withdrawTo = extras_.to;\n        } else if ((temp_ == 0 && temp2_ == 1) || (s_.swapRoutingAmt <= 0)) {\n            // entire swap will route through debt pool\n            (temp_, temp2_, temp3_, temp4_) = (0, 0, s_.amtInAdjusted, 0);\n            // price can slightly differ from collateral pool but difference will be very small. Probably <0.01% for active DEX pools.\n            s_.borrowTo = extras_.to;\n        } else {\n            // swap should never reach this point but if it does then reverting\n            revert FluidDexError(ErrorTypes.DexT1__NoSwapRoute);\n        }\n\n        if (temp_ > 0) {\n            // temp2_ = amountOutCol_\n            temp2_ = _getAmountOut(\n                ((temp_ * s_.fee) / SIX_DECIMALS),\n                cs_.tokenInImaginaryReserves,\n                cs_.tokenOutImaginaryReserves\n            );\n            swap0to1_\n                ? _verifyToken1Reserves(\n                    (cs_.tokenInRealReserves + temp_),\n                    (cs_.tokenOutRealReserves - temp2_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                )\n                : _verifyToken0Reserves(\n                    (cs_.tokenOutRealReserves - temp2_),\n                    (cs_.tokenInRealReserves + temp_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                );\n        }\n        if (temp3_ > 0) {\n            // temp4_ = amountOutDebt_\n            temp4_ = _getAmountOut(\n                ((temp3_ * s_.fee) / SIX_DECIMALS),\n                ds_.tokenInImaginaryReserves,\n                ds_.tokenOutImaginaryReserves\n            );\n            swap0to1_\n                ? _verifyToken1Reserves(\n                    (ds_.tokenInRealReserves + temp3_),\n                    (ds_.tokenOutRealReserves - temp4_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                )\n                : _verifyToken0Reserves(\n                    (ds_.tokenOutRealReserves - temp4_),\n                    (ds_.tokenInRealReserves + temp3_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                );\n        }\n\n        // (temp_ + temp3_) == amountIn_ == msg.value (for native token), if there is revenue cut then this statement is not true\n        temp_ = (temp_ * s_.revenueCut) / EIGHT_DECIMALS;\n        temp3_ = (temp3_ * s_.revenueCut) / EIGHT_DECIMALS;\n\n        // from whatever pool higher amount of swap is routing we are taking that as final price, does not matter much because both pools final price should be same\n        if (temp_ > temp3_) {\n            // new pool price from col pool\n            s_.price = swap0to1_\n                ? ((cs_.tokenOutImaginaryReserves - temp2_) * 1e27) / (cs_.tokenInImaginaryReserves + temp_)\n                : ((cs_.tokenInImaginaryReserves + temp_) * 1e27) / (cs_.tokenOutImaginaryReserves - temp2_);\n        } else {\n            // new pool price from debt pool\n            s_.price = swap0to1_\n                ? ((ds_.tokenOutImaginaryReserves - temp4_) * 1e27) / (ds_.tokenInImaginaryReserves + temp3_)\n                : ((ds_.tokenInImaginaryReserves + temp3_) * 1e27) / (ds_.tokenOutImaginaryReserves - temp4_);\n        }\n\n        // converting into normal token amounts\n        if (swap0to1_) {\n            temp_ = ((temp_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\n            temp3_ = ((temp3_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\n            // only adding uncheck in out amount\n            unchecked {\n                temp2_ = ((temp2_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n                temp4_ = ((temp4_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n            }\n        } else {\n            temp_ = ((temp_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n            temp3_ = ((temp3_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n            // only adding uncheck in out amount\n            unchecked {\n                temp2_ = ((temp2_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\n                temp4_ = ((temp4_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\n            }\n        }\n\n        unchecked {\n            amountOut_ = temp2_ + temp4_;\n        }\n\n        // if address dead then reverting with amountOut\n        if (extras_.to == ADDRESS_DEAD) revert FluidDexSwapResult(amountOut_);\n\n        if (amountOut_ < extras_.amountOutMin) revert FluidDexError(ErrorTypes.DexT1__NotEnoughAmountOut);\n\n        // allocating to avoid stack-too-deep error\n        // not setting in the callbackData as last 2nd to avoid SKIP_TRANSFERS clashing\n        s_.data = abi.encode(amountIn_, extras_.isCallback, msg.sender); // true/false is to decide if dex should do callback or directly transfer from user\n        // deposit & payback token in at liquidity\n        LIQUIDITY.operate{ value: msg.value }(s_.tokenIn, int(temp_), -int(temp3_), address(0), address(0), s_.data);\n        // withdraw & borrow token out at liquidity\n        LIQUIDITY.operate(s_.tokenOut, -int(temp2_), int(temp4_), s_.withdrawTo, s_.borrowTo, new bytes(0));\n\n        // if hook exists then calling hook\n        temp_ = (dexVariables2_ >> 142) & X30;\n        if (temp_ > 0) {\n            s_.swap0to1 = swap0to1_;\n            _hookVerify(temp_, 1, s_.swap0to1, s_.price);\n        }\n\n        swap0to1_\n            ? _utilizationVerify(((dexVariables2_ >> 238) & X10), EXCHANGE_PRICE_TOKEN_1_SLOT)\n            : _utilizationVerify(((dexVariables2_ >> 228) & X10), EXCHANGE_PRICE_TOKEN_0_SLOT);\n\n        dexVariables = _updateOracle(s_.price, pex_.centerPrice, dexVariables_);\n\n        emit Swap(swap0to1_, amountIn_, amountOut_, extras_.to);\n    }\n\n    /// @dev Swap tokens with perfect amount in\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of tokens to swap in\n    /// @param amountOutMin_ The minimum amount of tokens to receive after swap\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) public payable returns (uint256 amountOut_) {\n        return _swapIn(swap0to1_, amountIn_, SwapInExtras(to_, amountOutMin_, false));\n    }\n\n    /// @dev Swap tokens with perfect amount in and callback functionality\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of tokens to swap in\n    /// @param amountOutMin_ The minimum amount of tokens to receive after swap\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapInWithCallback(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) public payable returns (uint256 amountOut_) {\n        return _swapIn(swap0to1_, amountIn_, SwapInExtras(to_, amountOutMin_, true));\n    }\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) public payable returns (uint256 amountIn_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev Swap tokens with perfect amount out and callback functionality\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOutWithCallback(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) public payable returns (uint256 amountIn_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) public payable returns (uint token0Amt_, uint token1Amt_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256, uint256));\n    }\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of withdrawn tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) public returns (uint token0Amt_, uint token1Amt_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256, uint256));\n    }\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of borrowed tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) public returns (uint token0Amt_, uint token1Amt_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256, uint256));\n    }\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) public payable returns (uint token0Amt_, uint token1Amt_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256, uint256));\n    }\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) public payable returns (uint shares_) {\n        return abi.decode(_spell(COL_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of withdrawn tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) public returns (uint shares_) {\n        return abi.decode(_spell(COL_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of borrowed tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) public returns (uint shares_) {\n        return abi.decode(_spell(DEBT_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) public payable returns (uint shares_) {\n        return abi.decode(_spell(DEBT_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of withdrawn tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) public returns (uint withdrawAmt_) {\n        return abi.decode(_spell(COL_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) public payable returns (uint paybackAmt_) {\n        return abi.decode(_spell(DEBT_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev liquidity callback for cheaper token transfers in case of deposit or payback.\n    /// only callable by Liquidity during an operation.\n    function liquidityCallback(address token_, uint amount_, bytes calldata data_) external {\n        if (msg.sender != address(LIQUIDITY)) revert FluidDexError(ErrorTypes.DexT1__MsgSenderNotLiquidity);\n        if (dexVariables & 1 == 0) revert FluidDexError(ErrorTypes.DexT1__ReentrancyBitShouldBeOn);\n        if (data_.length != 96) revert FluidDexError(ErrorTypes.DexT1__IncorrectDataLength);\n\n        (uint amountToSend_, bool isCallback_, address from_) = abi.decode(data_, (uint, bool, address));\n\n        if (amountToSend_ < amount_) revert FluidDexError(ErrorTypes.DexT1__AmountToSendLessThanAmount);\n\n        if (isCallback_) {\n            IDexCallback(from_).dexCallback(token_, amountToSend_);\n        } else {\n            SafeTransfer.safeTransferFrom(token_, from_, address(LIQUIDITY), amountToSend_);\n        }\n    }\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(\n        uint[] memory secondsAgos_\n    ) external view returns (Oracle[] memory twaps_, uint currentPrice_) {\n        OraclePriceMemory memory o_;\n\n        uint dexVariables_ = dexVariables;\n\n        if ((dexVariables_ >> 195) & 1 == 0) {\n            revert FluidDexError(ErrorTypes.DexT1__OracleNotActive);\n        }\n\n        twaps_ = new Oracle[](secondsAgos_.length);\n\n        uint totalTime_;\n        uint time_;\n\n        uint i;\n        uint secondsAgo_ = secondsAgos_[0];\n\n        currentPrice_ = (dexVariables_ >> 41) & X40;\n        currentPrice_ = (currentPrice_ >> DEFAULT_EXPONENT_SIZE) << (currentPrice_ & DEFAULT_EXPONENT_MASK);\n        uint price_ = currentPrice_;\n        o_.lowestPrice1by0 = currentPrice_;\n        o_.highestPrice1by0 = currentPrice_;\n\n        uint twap1by0_;\n        uint twap0by1_;\n\n        uint j;\n\n        o_.oracleSlot = (dexVariables_ >> 176) & X3;\n        o_.oracleMap = (dexVariables_ >> 179) & X16;\n        // if o_.oracleSlot == 7 then it'll enter the if statement in the below while loop\n        o_.oracle = o_.oracleSlot < 7 ? _oracle[o_.oracleMap] : 0;\n\n        uint slotData_;\n        uint percentDiff_;\n\n        if (((dexVariables_ >> 121) & X33) < block.timestamp) {\n            // last swap didn't occured in this block.\n            // hence last price is current price of pool & also the last price\n            time_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n        } else {\n            // last swap occured in this block, that means current price is active for 0 secs. Hence TWAP for it will be 0.\n            ++j;\n        }\n\n        while (true) {\n            if (j == 2) {\n                if (++o_.oracleSlot == 8) {\n                    o_.oracleSlot = 0;\n                    if (o_.oracleMap == 0) {\n                        o_.oracleMap = TOTAL_ORACLE_MAPPING;\n                    }\n                    o_.oracle = _oracle[--o_.oracleMap];\n                }\n\n                slotData_ = (o_.oracle >> (o_.oracleSlot * 32)) & X32;\n                if (slotData_ > 0) {\n                    time_ = slotData_ & X9;\n                    if (time_ == 0) {\n                        // time is in precision & sign bits\n                        time_ = slotData_ >> 9;\n                        // if o_.oracleSlot is 7 then precision & bits and stored in 1 less map\n                        if (o_.oracleSlot == 7) {\n                            o_.oracleSlot = 0;\n                            if (o_.oracleMap == 0) {\n                                o_.oracleMap = TOTAL_ORACLE_MAPPING;\n                            }\n                            o_.oracle = _oracle[--o_.oracleMap];\n                            slotData_ = o_.oracle & X32;\n                        } else {\n                            ++o_.oracleSlot;\n                            slotData_ = (o_.oracle >> (o_.oracleSlot * 32)) & X32;\n                        }\n                    }\n                    percentDiff_ = slotData_ >> 10;\n                    percentDiff_ = (ORACLE_LIMIT * percentDiff_) / X22;\n                    if (((slotData_ >> 9) & 1 == 1)) {\n                        // if positive then old price was lower than current hence subtracting\n                        price_ = price_ - (price_ * percentDiff_) / ORACLE_PRECISION;\n                    } else {\n                        // if negative then old price was higher than current hence adding\n                        price_ = price_ + (price_ * percentDiff_) / ORACLE_PRECISION;\n                    }\n                } else {\n                    // oracle data does not exist. Probably due to pool recently got initialized and not have much swaps.\n                    revert FluidDexError(ErrorTypes.DexT1__InsufficientOracleData);\n                }\n            } else if (j == 1) {\n                // last & last to last price\n                price_ = (dexVariables_ >> 1) & X40;\n                price_ = (price_ >> DEFAULT_EXPONENT_SIZE) << (price_ & DEFAULT_EXPONENT_MASK);\n                time_ = (dexVariables_ >> 154) & X22;\n                ++j;\n            } else if (j == 0) {\n                ++j;\n            }\n\n            totalTime_ += time_;\n            if (o_.lowestPrice1by0 > price_) o_.lowestPrice1by0 = price_;\n            if (o_.highestPrice1by0 < price_) o_.highestPrice1by0 = price_;\n            if (totalTime_ < secondsAgo_) {\n                twap1by0_ += price_ * time_;\n                twap0by1_ += (1e54 / price_) * time_;\n            } else {\n                time_ = time_ + secondsAgo_ - totalTime_;\n                twap1by0_ += price_ * time_;\n                twap0by1_ += (1e54 / price_) * time_;\n                // also auto checks that secondsAgos_ should not be == 0\n                twap1by0_ = twap1by0_ / secondsAgo_;\n                twap0by1_ = twap0by1_ / secondsAgo_;\n\n                twaps_[i] = Oracle(\n                    twap1by0_,\n                    o_.lowestPrice1by0,\n                    o_.highestPrice1by0,\n                    twap0by1_,\n                    (1e54 / o_.highestPrice1by0),\n                    (1e54 / o_.lowestPrice1by0)\n                );\n\n                // TWAP for next secondsAgo will start with price_\n                o_.lowestPrice1by0 = price_;\n                o_.highestPrice1by0 = price_;\n\n                while (++i < secondsAgos_.length) {\n                    // secondsAgo_ = [60, 15, 0]\n                    time_ = totalTime_ - secondsAgo_;\n                    // updating total time as new seconds ago started\n                    totalTime_ = time_;\n                    // also auto checks that secondsAgos_[i + 1] > secondsAgos_[i]\n                    secondsAgo_ = secondsAgos_[i] - secondsAgos_[i - 1];\n                    if (totalTime_ < secondsAgo_) {\n                        twap1by0_ = price_ * time_;\n                        twap0by1_ = (1e54 / price_) * time_;\n                        // if time_ comes out as 0 here then lowestPrice & highestPrice should not be price_, it should be next price_ that we will calculate\n                        if (time_ == 0) {\n                            o_.lowestPrice1by0 = type(uint).max;\n                            o_.highestPrice1by0 = 0;\n                        }\n                        break;\n                    } else {\n                        time_ = time_ + secondsAgo_ - totalTime_;\n                        // twap1by0_ = price_ here\n                        twap1by0_ = price_ * time_;\n                        // twap0by1_ = (1e54 / price_) * time_;\n                        twap0by1_ = (1e54 / price_) * time_;\n                        twap1by0_ = twap1by0_ / secondsAgo_;\n                        twap0by1_ = twap0by1_ / secondsAgo_;\n                        twaps_[i] = Oracle(\n                            twap1by0_,\n                            o_.lowestPrice1by0,\n                            o_.highestPrice1by0,\n                            twap0by1_,\n                            (1e54 / o_.highestPrice1by0),\n                            (1e54 / o_.lowestPrice1by0)\n                        );\n                    }\n                }\n                if (i == secondsAgos_.length) return (twaps_, currentPrice_); // oracle fetch over\n            }\n        }\n    }\n\n    function getPricesAndExchangePrices() public {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables, dexVariables2);\n\n        revert FluidDexPricesAndExchangeRates(pex_);\n    }\n\n    /// @dev Internal fallback function to handle calls to non-existent functions\n    /// @notice This function is called when a transaction is sent to the contract without matching any other function\n    /// @notice It checks if the caller is authorized, enables re-entrancy protection, delegates the call to the admin implementation, and then disables re-entrancy protection\n    /// @notice Only authorized callers (global or dex auth) can trigger this function\n    /// @notice This function uses assembly to perform a delegatecall to the admin implementation to update configs related to DEX\n    function _fallback() private {\n        if (!(DEX_FACTORY.isGlobalAuth(msg.sender) || DEX_FACTORY.isDexAuth(address(this), msg.sender))) {\n            revert FluidDexError(ErrorTypes.DexT1__NotAnAuth);\n        }\n\n        uint dexVariables_ = dexVariables;\n        if (dexVariables_ & 1 == 1) revert FluidDexError(ErrorTypes.DexT1__AlreadyEntered);\n        // enabling re-entrancy\n        dexVariables = dexVariables_ | 1;\n\n        // Delegate the current call to `ADMIN_IMPLEMENTATION`.\n        _spell(ADMIN_IMPLEMENTATION, msg.data);\n\n        // disabling re-entrancy\n        // directly fetching from storage so updates from Admin module will get auto covered\n        dexVariables = dexVariables & ~uint(1);\n    }\n\n    fallback() external payable {\n        _fallback();\n    }\n\n    receive() external payable {\n        if (msg.sig != 0x00000000) {\n            _fallback();\n        }\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_) {\n        constantsView_.dexId = DEX_ID;\n        constantsView_.liquidity = address(LIQUIDITY);\n        constantsView_.factory = address(DEX_FACTORY);\n        constantsView_.token0 = TOKEN_0;\n        constantsView_.token1 = TOKEN_1;\n        constantsView_.implementations.shift = SHIFT_IMPLEMENTATION;\n        constantsView_.implementations.admin = ADMIN_IMPLEMENTATION;\n        constantsView_.implementations.colOperations = COL_OPERATIONS_IMPLEMENTATION;\n        constantsView_.implementations.debtOperations = DEBT_OPERATIONS_IMPLEMENTATION;\n        constantsView_.implementations.perfectOperationsAndSwapOut = PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION;\n        constantsView_.deployerContract = DEPLOYER_CONTRACT;\n        constantsView_.supplyToken0Slot = SUPPLY_TOKEN_0_SLOT;\n        constantsView_.borrowToken0Slot = BORROW_TOKEN_0_SLOT;\n        constantsView_.supplyToken1Slot = SUPPLY_TOKEN_1_SLOT;\n        constantsView_.borrowToken1Slot = BORROW_TOKEN_1_SLOT;\n        constantsView_.exchangePriceToken0Slot = EXCHANGE_PRICE_TOKEN_0_SLOT;\n        constantsView_.exchangePriceToken1Slot = EXCHANGE_PRICE_TOKEN_1_SLOT;\n        constantsView_.oracleMapping = TOTAL_ORACLE_MAPPING;\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_) {\n        constantsView2_.token0NumeratorPrecision = TOKEN_0_NUMERATOR_PRECISION;\n        constantsView2_.token0DenominatorPrecision = TOKEN_0_DENOMINATOR_PRECISION;\n        constantsView2_.token1NumeratorPrecision = TOKEN_1_NUMERATOR_PRECISION;\n        constantsView2_.token1DenominatorPrecision = TOKEN_1_DENOMINATOR_PRECISION;\n    }\n\n    /// @notice Calculates the real and imaginary reserves for collateral tokens\n    /// @dev This function retrieves the supply of both tokens from the liquidity layer,\n    ///      adjusts them based on exchange prices, and calculates imaginary reserves\n    ///      based on the geometric mean and price range\n    /// @param geometricMean_ The geometric mean of the token prices\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0SupplyExchangePrice_ The exchange price for token0 from liquidity layer\n    /// @param token1SupplyExchangePrice_ The exchange price for token1 from liquidity layer\n    /// @return c_ A struct containing the calculated real and imaginary reserves for both tokens:\n    ///         - token0RealReserves: The real reserves of token0\n    ///         - token1RealReserves: The real reserves of token1\n    ///         - token0ImaginaryReserves: The imaginary reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary reserves of token1\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) public view returns (CollateralReserves memory c_) {\n        return\n            _getCollateralReserves(\n                geometricMean_,\n                upperRange_,\n                lowerRange_,\n                token0SupplyExchangePrice_,\n                token1SupplyExchangePrice_\n            );\n    }\n\n    /// @notice Calculates the debt reserves for both tokens\n    /// @param geometricMean_ The geometric mean of the upper and lower price ranges\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0BorrowExchangePrice_ The exchange price of token0 from liquidity layer\n    /// @param token1BorrowExchangePrice_ The exchange price of token1 from liquidity layer\n    /// @return d_ The calculated debt reserves for both tokens, containing:\n    ///         - token0Debt: The debt amount of token0\n    ///         - token1Debt: The debt amount of token1\n    ///         - token0RealReserves: The real reserves of token0 derived from token1 debt\n    ///         - token1RealReserves: The real reserves of token1 derived from token0 debt\n    ///         - token0ImaginaryReserves: The imaginary debt reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary debt reserves of token1\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) public view returns (DebtReserves memory d_) {\n        return\n            _getDebtReserves(\n                geometricMean_,\n                upperRange_,\n                lowerRange_,\n                token0BorrowExchangePrice_,\n                token1BorrowExchangePrice_\n            );\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/core/perfectOperationsAndSwapOut.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { UserHelpers } from \"../helpers/userHelpers.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @title FluidDexT1\n/// @notice Implements core logics for Fluid Dex protocol.\n/// Note Token transfers happen directly from user to Liquidity contract and vice-versa.\ncontract FluidDexT1PerfectOperationsAndSwapOut is UserHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) UserHelpers(constantViews_) {\n        // all implementations should be zero other than shift\n        if (\n            constantViews_.implementations.shift == address(0) ||\n            constantViews_.implementations.admin != address(0) ||\n            constantViews_.implementations.colOperations != address(0) ||\n            constantViews_.implementations.debtOperations != address(0) ||\n            constantViews_.implementations.perfectOperationsAndSwapOut != address(0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__InvalidImplementation);\n        }\n    }\n\n    modifier _onlyDelegateCall() {\n        // also indirectly checked by `_check` because pool can never be initialized as long as the initialize method\n        // is delegate call only, but just to be sure on Admin logic we add the modifier everywhere nonetheless.\n        if (address(this) == THIS_CONTRACT) {\n            revert FluidDexError(ErrorTypes.DexT1__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    struct SwapOutExtras {\n        address to;\n        uint amountInMax;\n        bool isCallback;\n    }\n\n    /// @dev Swap tokens with perfect amount out. If NATIVE_TOKEN is sent then msg.value should be passed as amountInMax, amountInMax - amountIn of ETH are sent back to msg.sender\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param extras_ Additional parameters for the swap:\n    ///   - to_: Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    ///   - amountInMax: The maximum amount of input tokens the user is willing to swap\n    ///   - isCallback: If true, indicates that the output tokens should be transferred via a callback\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function _swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        SwapOutExtras memory extras_\n    ) internal _onlyDelegateCall returns (uint256 amountIn_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        if ((dexVariables2_ >> 255) == 1) revert FluidDexError(ErrorTypes.DexT1__SwapAndArbitragePaused);\n\n        _check(dexVariables_, dexVariables2_);\n\n        if (extras_.to == address(0)) extras_.to = msg.sender;\n\n        SwapOutMemory memory s_;\n\n        if (swap0to1_) {\n            (s_.tokenIn, s_.tokenOut) = (TOKEN_0, TOKEN_1);\n            unchecked {\n                s_.amtOutAdjusted = (amountOut_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION;\n            }\n        } else {\n            (s_.tokenIn, s_.tokenOut) = (TOKEN_1, TOKEN_0);\n            unchecked {\n                s_.amtOutAdjusted = (amountOut_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION;\n            }\n        }\n\n        _verifySwapAndNonPerfectActions(s_.amtOutAdjusted, amountOut_);\n\n        PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n        if ((msg.value > 0) || ((s_.tokenIn == NATIVE_TOKEN) && (msg.value == 0))) {\n            if (msg.value != extras_.amountInMax) revert FluidDexError(ErrorTypes.DexT1__EthAndAmountInMisMatch);\n            if (s_.tokenIn != NATIVE_TOKEN) revert FluidDexError(ErrorTypes.DexT1__EthSentForNonNativeSwap);\n        }\n\n        // is smart collateral pool enabled\n        uint temp_ = dexVariables2_ & 1;\n        // is smart debt pool enabled\n        uint temp2_ = (dexVariables2_ >> 1) & 1;\n        uint temp3_;\n        uint temp4_;\n\n        // extracting fee\n        temp3_ = ((dexVariables2_ >> 2) & X17);\n        unchecked {\n            // revenueCut in 6 decimals, to have proper precision\n            // if fee = 1% and revenue cut = 10% then revenueCut = 1e8 - (10000 * 10) = 99900000\n            s_.revenueCut = EIGHT_DECIMALS - ((((dexVariables2_ >> 19) & X7) * temp3_));\n            // fee in 4 decimals\n            // 1 - fee. If fee is 1% then withoutFee will be 1e6 - 1e4\n            // s_.fee => 1 - withdraw fee\n            s_.fee = SIX_DECIMALS - temp3_;\n        }\n\n        CollateralReservesSwap memory cs_;\n        DebtReservesSwap memory ds_;\n        if (temp_ == 1) {\n            // smart collateral is enabled\n            {\n                CollateralReserves memory c_ = _getCollateralReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.supplyToken0ExchangePrice,\n                    pex_.supplyToken1ExchangePrice\n                );\n                if (swap0to1_) {\n                    (\n                        cs_.tokenInRealReserves,\n                        cs_.tokenOutRealReserves,\n                        cs_.tokenInImaginaryReserves,\n                        cs_.tokenOutImaginaryReserves\n                    ) = (\n                        c_.token0RealReserves,\n                        c_.token1RealReserves,\n                        c_.token0ImaginaryReserves,\n                        c_.token1ImaginaryReserves\n                    );\n                } else {\n                    (\n                        cs_.tokenInRealReserves,\n                        cs_.tokenOutRealReserves,\n                        cs_.tokenInImaginaryReserves,\n                        cs_.tokenOutImaginaryReserves\n                    ) = (\n                        c_.token1RealReserves,\n                        c_.token0RealReserves,\n                        c_.token1ImaginaryReserves,\n                        c_.token0ImaginaryReserves\n                    );\n                }\n            }\n        }\n\n        if (temp2_ == 1) {\n            // smart debt is enabled\n            {\n                DebtReserves memory d_ = _getDebtReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.borrowToken0ExchangePrice,\n                    pex_.borrowToken1ExchangePrice\n                );\n                if (swap0to1_) {\n                    (\n                        ds_.tokenInDebt,\n                        ds_.tokenOutDebt,\n                        ds_.tokenInRealReserves,\n                        ds_.tokenOutRealReserves,\n                        ds_.tokenInImaginaryReserves,\n                        ds_.tokenOutImaginaryReserves\n                    ) = (\n                        d_.token0Debt,\n                        d_.token1Debt,\n                        d_.token0RealReserves,\n                        d_.token1RealReserves,\n                        d_.token0ImaginaryReserves,\n                        d_.token1ImaginaryReserves\n                    );\n                } else {\n                    (\n                        ds_.tokenInDebt,\n                        ds_.tokenOutDebt,\n                        ds_.tokenInRealReserves,\n                        ds_.tokenOutRealReserves,\n                        ds_.tokenInImaginaryReserves,\n                        ds_.tokenOutImaginaryReserves\n                    ) = (\n                        d_.token1Debt,\n                        d_.token0Debt,\n                        d_.token1RealReserves,\n                        d_.token0RealReserves,\n                        d_.token1ImaginaryReserves,\n                        d_.token0ImaginaryReserves\n                    );\n                }\n            }\n        }\n\n        // limiting amtOutAdjusted to be not more than 50% of both (collateral & debt) imaginary tokenOut reserves combined\n        // basically, if this throws that means user is trying to swap 0.5x tokenOut if current tokenOut imaginary reserves is x\n        // let's take x as token0 here, that means, initially the pool pricing might be:\n        // token1Reserve / x and new pool pricing will become token1Reserve / 0.5x (token1Reserve will decrease after swap but for simplicity ignoring that)\n        // So pool price is increased by ~50% (oracle will throw error in this case as it only allows 5% price difference but better to limit it before hand)\n        unchecked {\n            if (s_.amtOutAdjusted > ((cs_.tokenOutImaginaryReserves + ds_.tokenOutImaginaryReserves) / 2))\n                revert FluidDexError(ErrorTypes.DexT1__SwapOutLimitingAmounts);\n        }\n\n        if (temp_ == 1 && temp2_ == 1) {\n            // if both pools are not enabled then s_.swapRoutingAmt will be 0\n            s_.swapRoutingAmt = _swapRoutingOut(\n                s_.amtOutAdjusted,\n                cs_.tokenInImaginaryReserves,\n                cs_.tokenOutImaginaryReserves,\n                ds_.tokenInImaginaryReserves,\n                ds_.tokenOutImaginaryReserves\n            );\n        }\n\n        // In below if else statement temps are:\n        // temp_ => withdraw amt\n        // temp2_ => deposit amt\n        // temp3_ => borrow amt\n        // temp4_ => payback amt\n        if (int(s_.amtOutAdjusted) > s_.swapRoutingAmt && s_.swapRoutingAmt > 0) {\n            // swap will route from both pools\n            // temp_ = amountOutCol_\n            temp_ = uint(s_.swapRoutingAmt);\n            unchecked {\n                // temp3_ = amountOutDebt_\n                temp3_ = s_.amtOutAdjusted - temp_;\n            }\n\n            (temp2_, temp4_) = (0, 0);\n\n            // debt pool price will be the same as collateral pool after the swap\n            s_.withdrawTo = extras_.to;\n            s_.borrowTo = extras_.to;\n        } else if ((temp_ == 1 && temp2_ == 0) || (s_.swapRoutingAmt >= int(s_.amtOutAdjusted))) {\n            // entire swap will route through collateral pool\n            (temp_, temp2_, temp3_, temp4_) = (s_.amtOutAdjusted, 0, 0, 0);\n            // price can slightly differ from debt pool but difference will be very small. Probably <0.01% for active DEX pools.\n            s_.withdrawTo = extras_.to;\n        } else if ((temp_ == 0 && temp2_ == 1) || (s_.swapRoutingAmt <= 0)) {\n            // entire swap will route through debt pool\n            (temp_, temp2_, temp3_, temp4_) = (0, 0, s_.amtOutAdjusted, 0);\n            // price can slightly differ from collateral pool but difference will be very small. Probably <0.01% for active DEX pools.\n            s_.borrowTo = extras_.to;\n        } else {\n            // swap should never reach this point but if it does then reverting\n            revert FluidDexError(ErrorTypes.DexT1__NoSwapRoute);\n        }\n\n        if (temp_ > 0) {\n            // temp2_ = amountInCol_\n            temp2_ = _getAmountIn(temp_, cs_.tokenInImaginaryReserves, cs_.tokenOutImaginaryReserves);\n            temp2_ = (temp2_ * SIX_DECIMALS) / s_.fee;\n            swap0to1_\n                ? _verifyToken1Reserves(\n                    (cs_.tokenInRealReserves + temp2_),\n                    (cs_.tokenOutRealReserves - temp_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                )\n                : _verifyToken0Reserves(\n                    (cs_.tokenOutRealReserves - temp_),\n                    (cs_.tokenInRealReserves + temp2_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                );\n        }\n        if (temp3_ > 0) {\n            // temp4_ = amountInDebt_\n            temp4_ = _getAmountIn(temp3_, ds_.tokenInImaginaryReserves, ds_.tokenOutImaginaryReserves);\n            temp4_ = (temp4_ * SIX_DECIMALS) / s_.fee;\n            swap0to1_\n                ? _verifyToken1Reserves(\n                    (ds_.tokenInRealReserves + temp4_),\n                    (ds_.tokenOutRealReserves - temp3_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                )\n                : _verifyToken0Reserves(\n                    (ds_.tokenOutRealReserves - temp3_),\n                    (ds_.tokenInRealReserves + temp4_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                );\n        }\n\n        amountIn_ = temp2_ + temp4_;\n\n        // cutting revenue off of amount in.\n        temp2_ = (temp2_ * s_.revenueCut) / EIGHT_DECIMALS;\n        temp4_ = (temp4_ * s_.revenueCut) / EIGHT_DECIMALS;\n\n        // from whatever pool higher amount of swap is routing we are taking that as final price, does not matter much because both pools final price should be same\n        if (temp_ > temp3_) {\n            // new pool price from col pool\n            s_.price = swap0to1_\n                ? ((cs_.tokenOutImaginaryReserves - temp_) * 1e27) / (cs_.tokenInImaginaryReserves + temp2_)\n                : ((cs_.tokenInImaginaryReserves + temp2_) * 1e27) / (cs_.tokenOutImaginaryReserves - temp_);\n        } else {\n            // new pool price from debt pool\n            s_.price = swap0to1_\n                ? ((ds_.tokenOutImaginaryReserves - temp3_) * 1e27) / (ds_.tokenInImaginaryReserves + temp4_)\n                : ((ds_.tokenInImaginaryReserves + temp4_) * 1e27) / (ds_.tokenOutImaginaryReserves - temp3_);\n        }\n\n        // Converting into normal token amounts\n        if (swap0to1_) {\n            // only adding uncheck in out amount\n            unchecked {\n                temp_ = (temp_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION;\n                temp3_ = (temp3_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION;\n            }\n            temp2_ = (temp2_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION;\n            temp4_ = (temp4_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION;\n            amountIn_ = (amountIn_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION;\n        } else {\n            // only adding uncheck in out amount\n            unchecked {\n                temp_ = (temp_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION;\n                temp3_ = (temp3_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION;\n            }\n            temp2_ = (temp2_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION;\n            temp4_ = (temp4_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION;\n            amountIn_ = (amountIn_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION;\n        }\n\n        // If address dead then reverting with amountIn\n        if (extras_.to == ADDRESS_DEAD) revert FluidDexSwapResult(amountIn_);\n\n        if (amountIn_ > extras_.amountInMax) revert FluidDexError(ErrorTypes.DexT1__ExceedsAmountInMax);\n\n        // allocating to avoid stack-too-deep error\n        // not setting in the callbackData as last 2nd to avoid SKIP_TRANSFERS clashing\n        s_.data = abi.encode(amountIn_, extras_.isCallback, msg.sender); // true/false is to decide if dex should do callback or directly transfer from user\n        // if native token then pass msg.value as amountIn_ else 0\n        s_.msgValue = (s_.tokenIn == NATIVE_TOKEN) ? amountIn_ : 0;\n        // Deposit & payback token in at liquidity\n        LIQUIDITY.operate{ value: s_.msgValue }(s_.tokenIn, int(temp2_), -int(temp4_), address(0), address(0), s_.data);\n        // Withdraw & borrow token out at liquidity\n        LIQUIDITY.operate(s_.tokenOut, -int(temp_), int(temp3_), s_.withdrawTo, s_.borrowTo, new bytes(0));\n\n        // If hook exists then calling hook\n        temp_ = (dexVariables2_ >> 142) & X30;\n        if (temp_ > 0) {\n            s_.swap0to1 = swap0to1_;\n            _hookVerify(temp_, 1, s_.swap0to1, s_.price);\n        }\n\n        swap0to1_\n            ? _utilizationVerify(((dexVariables2_ >> 238) & X10), EXCHANGE_PRICE_TOKEN_1_SLOT)\n            : _utilizationVerify(((dexVariables2_ >> 228) & X10), EXCHANGE_PRICE_TOKEN_0_SLOT);\n\n        dexVariables = _updateOracle(s_.price, pex_.centerPrice, dexVariables_);\n\n        if (s_.tokenIn == NATIVE_TOKEN && amountIn_ < extras_.amountInMax) {\n            unchecked {\n                SafeTransfer.safeTransferNative(msg.sender, extras_.amountInMax - amountIn_);\n            }\n        }\n\n        // to avoid stack too deep error\n        temp_ = amountOut_;\n        emit Swap(swap0to1_, amountIn_, temp_, extras_.to);\n    }\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint amountInMax_,\n        address to_\n    ) public payable _onlyDelegateCall returns (uint amountIn_) {\n        return _swapOut(swap0to1_, amountOut_, SwapOutExtras(to_, amountInMax_, false));\n    }\n\n    /// @dev Swap tokens with perfect amount out and callback functionality\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOutWithCallback(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) public payable returns (uint256 amountIn_) {\n        return _swapOut(swap0to1_, amountOut_, SwapOutExtras(to_, amountInMax_, true));\n    }\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) public payable _onlyDelegateCall returns (uint token0Amt_, uint token1Amt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userSupplyData_ = _userSupplyData[msg.sender];\n\n        // user collateral configs are not set yet\n        if (userSupplyData_ & 1 == 0 && !estimate_) revert FluidDexError(ErrorTypes.DexT1__UserSupplyInNotOn);\n\n        // is smart collateral pool enabled\n        if ((dexVariables2_ & 1) == 1) {\n            ExchangePrices memory ex_ = _getExchangePrices();\n\n            // smart col in enabled\n            uint totalSupplyShares_ = _totalSupplyShares & X128;\n\n            _verifyMint(shares_, totalSupplyShares_);\n\n            // Adding col liquidity in equal proportion\n            // Adding + 1, to keep protocol on the winning side\n            token0Amt_ =\n                (_getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, ex_.supplyToken0ExchangePrice, true) * shares_) /\n                totalSupplyShares_;\n            token1Amt_ =\n                (_getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, ex_.supplyToken1ExchangePrice, false) * shares_) /\n                totalSupplyShares_;\n\n            // converting back into normal token amounts\n            // Adding + 1, to keep protocol on the winning side\n            token0Amt_ = (((token0Amt_ + 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) + 1;\n            token1Amt_ = (((token1Amt_ + 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) + 1;\n\n            if (estimate_) revert FluidDexPerfectLiquidityOutput(token0Amt_, token1Amt_);\n\n            if (token0Amt_ > maxToken0Deposit_ || token1Amt_ > maxToken1Deposit_) {\n                revert FluidDexError(ErrorTypes.DexT1__AboveDepositMax);\n            }\n\n            _depositOrPaybackInLiquidity(TOKEN_0, token0Amt_, 0);\n\n            _depositOrPaybackInLiquidity(TOKEN_1, token1Amt_, 0);\n\n            uint userSupply_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            // extracting exisiting shares and then adding new shares in it\n            userSupply_ = ((userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK));\n\n            // calculate current, updated (expanded etc.) withdrawal limit\n            uint256 newWithdrawalLimit_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\n\n            userSupply_ += shares_;\n\n            // bigNumber the shares are not same as before\n            _updatingUserSupplyDataOnStorage(userSupplyData_, userSupply_, newWithdrawalLimit_);\n\n            _updateSupplyShares(totalSupplyShares_ + shares_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartColNotEnabled);\n        }\n\n        // uninitializing re-entrancy\n        dexVariables = dexVariables_;\n\n        emit LogDepositPerfectColLiquidity(shares_, token0Amt_, token1Amt_);\n    }\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) public _onlyDelegateCall returns (uint token0Amt_, uint token1Amt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userSupplyData_ = _userSupplyData[msg.sender];\n\n        if (userSupplyData_ & 1 == 0 && to_ != ADDRESS_DEAD) {\n            revert FluidDexError(ErrorTypes.DexT1__UserSupplyInNotOn);\n        }\n\n        to_ = (to_ == address(0)) ? msg.sender : to_;\n\n        // is smart collateral pool enabled\n        if ((dexVariables2_ & 1) == 1) {\n            ExchangePrices memory ex_ = _getExchangePrices();\n\n            uint totalSupplyShares_ = _totalSupplyShares & X128;\n\n            _verifyRedeem(shares_, totalSupplyShares_);\n\n            // smart col in enabled\n            // Withdrawing col liquidity in equal proportion\n            token0Amt_ =\n                (_getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, ex_.supplyToken0ExchangePrice, true) * shares_) /\n                totalSupplyShares_;\n            token1Amt_ =\n                (_getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, ex_.supplyToken1ExchangePrice, false) * shares_) /\n                totalSupplyShares_;\n\n            // converting back into normal token amounts\n            token0Amt_ = (((token0Amt_ - 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) - 1;\n            token1Amt_ = (((token1Amt_ - 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) - 1;\n\n            if (to_ == ADDRESS_DEAD) revert FluidDexPerfectLiquidityOutput(token0Amt_, token1Amt_);\n\n            if (token0Amt_ < minToken0Withdraw_ || token1Amt_ < minToken1Withdraw_) {\n                revert FluidDexError(ErrorTypes.DexT1__BelowWithdrawMin);\n            }\n\n            uint256 userSupply_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            userSupply_ = (userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) withdrawal limit\n            uint256 newWithdrawalLimit_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\n            userSupply_ -= shares_;\n\n            // withdraws below limit\n            if (userSupply_ < newWithdrawalLimit_) revert FluidDexError(ErrorTypes.DexT1__WithdrawLimitReached);\n\n            _updatingUserSupplyDataOnStorage(userSupplyData_, userSupply_, newWithdrawalLimit_);\n\n            totalSupplyShares_ = totalSupplyShares_ - shares_;\n            _updateSupplyShares(totalSupplyShares_);\n\n            // withdraw\n            // if token0Amt_ == 0 then Liqudity Layer will revert\n            LIQUIDITY.operate(TOKEN_0, -int(token0Amt_), 0, to_, address(0), new bytes(0));\n\n            // withdraw\n            // if token1Amt_ == 0 then Liqudity Layer will revert\n            LIQUIDITY.operate(TOKEN_1, -int(token1Amt_), 0, to_, address(0), new bytes(0));\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartColNotEnabled);\n        }\n\n        // uninitializing re-entrancy\n        dexVariables = dexVariables_;\n\n        emit LogWithdrawPerfectColLiquidity(shares_, token0Amt_, token1Amt_);\n    }\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) public _onlyDelegateCall returns (uint token0Amt_, uint token1Amt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userBorrowData_ = _userBorrowData[msg.sender];\n\n        // user debt configs are not set yet\n        if (userBorrowData_ & 1 == 0 && to_ != ADDRESS_DEAD) revert FluidDexError(ErrorTypes.DexT1__UserDebtInNotOn);\n\n        to_ = (to_ == address(0)) ? msg.sender : to_;\n\n        // is smart debt pool enabled\n        if (((dexVariables2_ >> 1) & 1) == 1) {\n            ExchangePrices memory ex_ = _getExchangePrices();\n\n            uint totalBorrowShares_ = _totalBorrowShares & X128;\n\n            _verifyMint(shares_, totalBorrowShares_);\n\n            // Adding debt liquidity in equal proportion\n            token0Amt_ =\n                (_getLiquidityDebt(BORROW_TOKEN_0_SLOT, ex_.borrowToken0ExchangePrice, true) * shares_) /\n                totalBorrowShares_;\n            token1Amt_ =\n                (_getLiquidityDebt(BORROW_TOKEN_1_SLOT, ex_.borrowToken1ExchangePrice, false) * shares_) /\n                totalBorrowShares_;\n            // converting back into normal token amounts\n            token0Amt_ = (((token0Amt_ - 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) - 1;\n            token1Amt_ = (((token1Amt_ - 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) - 1;\n\n            if (to_ == ADDRESS_DEAD) revert FluidDexPerfectLiquidityOutput(token0Amt_, token1Amt_);\n\n            if (token0Amt_ < minToken0Borrow_ || token1Amt_ < minToken1Borrow_) {\n                revert FluidDexError(ErrorTypes.DexT1__BelowBorrowMin);\n            }\n\n            // extract user borrow amount\n            uint256 userBorrow_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n            userBorrow_ = (userBorrow_ >> DEFAULT_EXPONENT_SIZE) << (userBorrow_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) borrow limit\n            uint256 newBorrowLimit_ = DexCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, userBorrow_);\n\n            userBorrow_ += shares_;\n\n            // user above debt limit\n            if (userBorrow_ > newBorrowLimit_) revert FluidDexError(ErrorTypes.DexT1__DebtLimitReached);\n\n            // borrow\n            // if token0Amt_ == 0 then Liqudity Layer will revert\n            LIQUIDITY.operate(TOKEN_0, 0, int(token0Amt_), address(0), to_, new bytes(0));\n\n            // borrow\n            // if token1Amt_ == 1 then Liqudity Layer will revert\n            LIQUIDITY.operate(TOKEN_1, 0, int(token1Amt_), address(0), to_, new bytes(0));\n\n            _updatingUserBorrowDataOnStorage(userBorrowData_, userBorrow_, newBorrowLimit_);\n\n            _updateBorrowShares(totalBorrowShares_ + shares_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartDebtNotEnabled);\n        }\n\n        // uninitializing re-entrancy\n        dexVariables = dexVariables_;\n\n        emit LogBorrowPerfectDebtLiquidity(shares_, token0Amt_, token1Amt_);\n    }\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) public payable _onlyDelegateCall returns (uint token0Amt_, uint token1Amt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userBorrowData_ = _userBorrowData[msg.sender];\n\n        if (userBorrowData_ & 1 == 0 && !estimate_) revert FluidDexError(ErrorTypes.DexT1__UserDebtInNotOn);\n\n        // is smart debt pool enabled\n        if (((dexVariables2_ >> 1) & 1) == 1) {\n            uint totalBorrowShares_ = _totalBorrowShares & X128;\n\n            ExchangePrices memory ex_ = _getExchangePrices();\n\n            _verifyRedeem(shares_, totalBorrowShares_);\n\n            // Removing debt liquidity in equal proportion\n            token0Amt_ =\n                (_getLiquidityDebt(BORROW_TOKEN_0_SLOT, ex_.borrowToken0ExchangePrice, true) * shares_) /\n                totalBorrowShares_;\n            token1Amt_ =\n                (_getLiquidityDebt(BORROW_TOKEN_1_SLOT, ex_.borrowToken1ExchangePrice, false) * shares_) /\n                totalBorrowShares_;\n            // converting back into normal token amounts\n            token0Amt_ = (((token0Amt_ + 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) + 1;\n            token1Amt_ = (((token1Amt_ + 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) + 1;\n\n            if (estimate_) revert FluidDexPerfectLiquidityOutput(token0Amt_, token1Amt_);\n\n            if (token0Amt_ > maxToken0Payback_ || token1Amt_ > maxToken1Payback_) {\n                revert FluidDexError(ErrorTypes.DexT1__AbovePaybackMax);\n            }\n\n            _depositOrPaybackInLiquidity(TOKEN_0, 0, token0Amt_);\n\n            _depositOrPaybackInLiquidity(TOKEN_1, 0, token1Amt_);\n\n            // extract user borrow amount\n            uint256 userBorrow_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n            userBorrow_ = (userBorrow_ >> DEFAULT_EXPONENT_SIZE) << (userBorrow_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) borrow limit\n            uint256 newBorrowLimit_ = DexCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, userBorrow_);\n\n            userBorrow_ -= shares_;\n\n            _updatingUserBorrowDataOnStorage(userBorrowData_, userBorrow_, newBorrowLimit_);\n\n            totalBorrowShares_ = totalBorrowShares_ - shares_;\n            _updateBorrowShares(totalBorrowShares_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartDebtNotEnabled);\n        }\n\n        // uninitializing re-entrancy\n        dexVariables = dexVariables_;\n\n        emit LogPaybackPerfectDebtLiquidity(shares_, token0Amt_, token1Amt_);\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Events {\n    /// @notice Emitted on token swaps\n    /// @param swap0to1 Indicates whether the swap is from token0 to token1 or vice-versa.\n    /// @param amountIn The amount of tokens to be sent to the vault to swap.\n    /// @param amountOut The amount of tokens user got from the swap.\n    /// @param to Recepient of swapped tokens.\n    event Swap(bool swap0to1, uint256 amountIn, uint256 amountOut, address to);\n\n    /// @notice Emitted when liquidity is added with shares specified.\n    /// @param shares Expected exact shares to be received.\n    /// @param token0Amt Amount of token0 deposited.\n    /// @param token0Amt Amount of token1 deposited.\n    event LogDepositPerfectColLiquidity(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when liquidity is withdrawn with shares specified.\n    /// @param shares shares burned\n    /// @param token0Amt Amount of token0 withdrawn.\n    /// @param token1Amt Amount of token1 withdrawn.\n    event LogWithdrawPerfectColLiquidity(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when liquidity is borrowed with shares specified.\n    /// @param shares shares minted\n    /// @param token0Amt Amount of token0 borrowed.\n    /// @param token1Amt Amount of token1 borrowed.\n    event LogBorrowPerfectDebtLiquidity(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when liquidity is paid back with shares specified.\n    /// @param shares shares burned\n    /// @param token0Amt Amount of token0 paid back.\n    /// @param token1Amt Amount of token1 paid back.\n    event LogPaybackPerfectDebtLiquidity(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when liquidity is deposited with specified token0 & token1 amount\n    /// @param amount0 Amount of token0 deposited.\n    /// @param amount1 Amount of token1 deposited.\n    /// @param shares Amount of shares minted.\n    event LogDepositColLiquidity(uint amount0, uint amount1, uint shares);\n\n    /// @notice Emitted when liquidity is withdrawn with specified token0 & token1 amount\n    /// @param amount0 Amount of token0 withdrawn.\n    /// @param amount1 Amount of token1 withdrawn.\n    /// @param shares Amount of shares burned.\n    event LogWithdrawColLiquidity(uint amount0, uint amount1, uint shares);\n\n    /// @notice Emitted when liquidity is borrowed with specified token0 & token1 amount\n    /// @param amount0 Amount of token0 borrowed.\n    /// @param amount1 Amount of token1 borrowed.\n    /// @param shares Amount of shares minted.\n    event LogBorrowDebtLiquidity(uint amount0, uint amount1, uint shares);\n\n    /// @notice Emitted when liquidity is paid back with specified token0 & token1 amount\n    /// @param amount0 Amount of token0 paid back.\n    /// @param amount1 Amount of token1 paid back.\n    /// @param shares Amount of shares burned.\n    event LogPaybackDebtLiquidity(uint amount0, uint amount1, uint shares);\n\n    /// @notice Emitted when liquidity is withdrawn with shares specified into one token only.\n    /// @param shares shares burned\n    /// @param token0Amt Amount of token0 withdrawn.\n    /// @param token1Amt Amount of token1 withdrawn.\n    event LogWithdrawColInOneToken(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when liquidity is paid back with shares specified from one token only.\n    /// @param shares shares burned\n    /// @param token0Amt Amount of token0 paid back.\n    /// @param token1Amt Amount of token1 paid back.\n    event LogPaybackDebtInOneToken(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when internal arbitrage between 2 pools happen\n    /// @param routing if positive then routing is amtIn of token0 in deposit & borrow else token0 withdraw & payback\n    /// @param amtOut if routing is positive then token1 withdraw & payback amount else token1 deposit & borrow\n    event LogArbitrage(int routing, uint amtOut);\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/helpers/coreHelpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport { Variables } from \"../../common/variables.sol\";\nimport { ImmutableVariables } from \"../immutableVariables.sol\";\nimport { Events } from \"../events.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { IHook, ICenterPrice } from \"../interfaces.sol\";\nimport { LiquiditySlotsLink } from \"../../../../../libraries/liquiditySlotsLink.sol\";\nimport { LiquidityCalcs } from \"../../../../../libraries/liquidityCalcs.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { AddressCalcs } from \"../../../../../libraries/addressCalcs.sol\";\n\ninterface IShifting {\n    /// @dev Calculates the new upper and lower range values during an active range shift\n    /// @param upperRange_ The target upper range value\n    /// @param lowerRange_ The target lower range value\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\n    /// @return The updated upper range, lower range, and dexVariables2\n    function _calcRangeShifting(\n        uint upperRange_,\n        uint lowerRange_,\n        uint dexVariables2_\n    ) external returns (uint, uint, uint);\n\n    /// @dev Calculates the new threshold values during an active threshold shift\n    /// @param upperThreshold_ The target upper threshold value\n    /// @param lowerThreshold_ The target lower threshold value\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\n    /// @return The updated upper threshold, lower threshold, and dexVariables2\n    function _calcThresholdShifting(\n        uint upperThreshold_,\n        uint lowerThreshold_,\n        uint dexVariables2_\n    ) external returns (uint, uint, uint);\n\n    /// @dev Calculates the new center price during an active center price shift\n    /// @param dexVariables_ The current state of dex variables\n    /// @param dexVariables2_ Additional dex variables\n    /// @return The updated center price\n    function _calcCenterPrice(\n        uint dexVariables_,\n        uint dexVariables2_\n    ) external returns (uint);\n}\n\nabstract contract CoreHelpers is Variables, ImmutableVariables, Events {\n    using BigMathMinified for uint256;\n\n    /// @dev            do any arbitrary call\n    /// @param target_  Address to which the call needs to be delegated\n    /// @param data_    Data to execute at the delegated address\n    function _spell(address target_, bytes memory data_) internal returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            if iszero(succeeded) {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n\n    /// @dev Given an input amount of asset and pair reserves, returns the maximum output amount of the other asset\n    /// @param amountIn_ The amount of input asset.\n    /// @param iReserveIn_ Imaginary token reserve with input amount.\n    /// @param iReserveOut_ Imaginary token reserve of output amount.\n    function _getAmountOut(\n        uint256 amountIn_,\n        uint iReserveIn_,\n        uint iReserveOut_\n    ) internal pure returns (uint256 amountOut_) {\n        unchecked {\n            // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\n            uint256 numerator_ = amountIn_ * iReserveOut_;\n            uint256 denominator_ = iReserveIn_ + amountIn_;\n\n            // Using the swap formula: (AmountIn * iReserveY) / (iReserveX + AmountIn)\n            amountOut_ = numerator_ / denominator_;\n        }\n    }\n\n    /// @dev Given an output amount of asset and pair reserves, returns the input amount of the other asset\n    /// @param amountOut_ Desired output amount of the asset.\n    /// @param iReserveIn_ Imaginary token reserve of input amount.\n    /// @param iReserveOut_ Imaginary token reserve of output amount.\n    function _getAmountIn(\n        uint256 amountOut_,\n        uint iReserveIn_,\n        uint iReserveOut_\n    ) internal pure returns (uint256 amountIn_) {\n        // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\n        uint256 numerator_ = amountOut_ * iReserveIn_;\n        uint256 denominator_ = iReserveOut_ - amountOut_;\n\n        // Using the swap formula: (AmountOut * iReserveX) / (iReserveY - AmountOut)\n        amountIn_ = numerator_ / denominator_;\n    }\n\n    /// @param t total amount in\n    /// @param x imaginary reserves of token out of collateral\n    /// @param y imaginary reserves of token in of collateral\n    /// @param x2 imaginary reserves of token out of debt\n    /// @param y2 imaginary reserves of token in of debt\n    /// @return a_ how much swap should go through collateral pool. Remaining will go from debt\n    /// note if a < 0 then entire trade route through debt pool and debt pool arbitrage with col pool\n    /// note if a > t then entire trade route through col pool and col pool arbitrage with debt pool\n    /// note if a > 0 & a < t then swap will route through both pools\n    function _swapRoutingIn(uint t, uint x, uint y, uint x2, uint y2) internal pure returns (int a_) {\n        // Main equations:\n        // 1. out = x * a / (y + a)\n        // 2. out2 = x2 * (t - a) / (y2 + (t - a))\n        // final price should be same\n        // 3. (y + a) / (x - out) = (y2 + (t - a)) / (x2 - out2)\n        // derivation: https://chatgpt.com/share/dce6f381-ee5f-4d5f-b6ea-5996e84d5b57\n\n        // adding 1e18 precision\n        uint xyRoot_ = FixedPointMathLib.sqrt(x * y * 1e18);\n        uint x2y2Root_ = FixedPointMathLib.sqrt(x2 * y2 * 1e18);\n\n        a_ = (int(y2 * xyRoot_ + t * xyRoot_) - int(y * x2y2Root_)) / int(xyRoot_ + x2y2Root_);\n    }\n\n    /// @param t total amount out\n    /// @param x imaginary reserves of token in of collateral\n    /// @param y imaginary reserves of token out of collateral\n    /// @param x2 imaginary reserves of token in of debt\n    /// @param y2 imaginary reserves of token out of debt\n    /// @return a_ how much swap should go through collateral pool. Remaining will go from debt\n    /// note if a < 0 then entire trade route through debt pool and debt pool arbitrage with col pool\n    /// note if a > t then entire trade route through col pool and col pool arbitrage with debt pool\n    /// note if a > 0 & a < t then swap will route through both pools\n    function _swapRoutingOut(uint t, uint x, uint y, uint x2, uint y2) internal pure returns (int a_) {\n        // Main equations:\n        // 1. in = (x * a) / (y - a)\n        // 2. in2 = (x2 * (t - a)) / (y2 - (t - a))\n        // final price should be same\n        // 3. (y - a) / (x + in) = (y2 - (t - a)) / (x2 + in2)\n        // derivation: https://chatgpt.com/share/6585bc28-841f-49ec-aea2-1e5c5b7f4fa9\n\n        // adding 1e18 precision\n        uint xyRoot_ = FixedPointMathLib.sqrt(x * y * 1e18);\n        uint x2y2Root_ = FixedPointMathLib.sqrt(x2 * y2 * 1e18);\n\n        // 1e18 precision gets cancelled out in division\n        a_ = (int(t * xyRoot_ + y * x2y2Root_) - int(y2 * xyRoot_)) / int(xyRoot_ + x2y2Root_);\n    }\n\n    function _utilizationVerify(uint utilizationLimit_, bytes32 exchangePriceSlot_) internal view {\n        if (utilizationLimit_ < THREE_DECIMALS) {\n            utilizationLimit_ = utilizationLimit_ * 10;\n            // extracting utilization of token from liquidity layer\n            uint liquidityLayerUtilization_ = LIQUIDITY.readFromStorage(exchangePriceSlot_);\n            liquidityLayerUtilization_ =\n                (liquidityLayerUtilization_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) &\n                X14;\n            // Note: this can go slightly above the utilization limit if no update is written to storage at liquidity layer\n            // if swap was not big enough to go far enough above or any other storage update threshold write cause there\n            // so just to keep in mind when configuring the actual limit reachable can be utilizationLimit_ + storageUpdateThreshold at Liquidity\n            if (liquidityLayerUtilization_ > utilizationLimit_)\n                revert FluidDexError(ErrorTypes.DexT1__LiquidityLayerTokenUtilizationCapReached);\n        }\n    }\n\n    function _check(uint dexVariables_, uint dexVariables2_) internal {\n        if (dexVariables_ & 1 == 1) revert FluidDexError(ErrorTypes.DexT1__AlreadyEntered);\n        if (dexVariables2_ & 3 == 0) revert FluidDexError(ErrorTypes.DexT1__PoolNotInitialized);\n        // enabling re-entrancy\n        dexVariables = dexVariables_ | 1;\n    }\n\n    /// @dev if token0 reserves are too low w.r.t token1 then revert, this is to avoid edge case scenario and making sure that precision on calculations should be high enough\n    function _verifyToken0Reserves(\n        uint token0Reserves_,\n        uint token1Reserves_,\n        uint centerPrice_,\n        uint minLiquidity_\n    ) internal pure {\n        if (((token0Reserves_) < ((token1Reserves_ * 1e27) / (centerPrice_ * minLiquidity_)))) {\n            revert FluidDexError(ErrorTypes.DexT1__TokenReservesTooLow);\n        }\n    }\n\n    /// @dev if token1 reserves are too low w.r.t token0 then revert, this is to avoid edge case scenario and making sure that precision on calculations should be high enough\n    function _verifyToken1Reserves(\n        uint token0Reserves_,\n        uint token1Reserves_,\n        uint centerPrice_,\n        uint minLiquidity_\n    ) internal pure {\n        if (((token1Reserves_) < ((token0Reserves_ * centerPrice_) / (1e27 * minLiquidity_)))) {\n            revert FluidDexError(ErrorTypes.DexT1__TokenReservesTooLow);\n        }\n    }\n\n    function _verifySwapAndNonPerfectActions(uint amountAdjusted_, uint amount_) internal pure {\n        // after shifting amount should not become 0\n        // limiting to six decimals which means in case of USDC, USDT it's 1 wei, for WBTC 100 wei, for ETH 1000 gwei\n        if (amountAdjusted_ < SIX_DECIMALS || amountAdjusted_ > X96 || amount_ < TWO_DECIMALS || amount_ > X128)\n            revert FluidDexError(ErrorTypes.DexT1__LimitingAmountsSwapAndNonPerfectActions);\n    }\n\n    /// @dev Calculates the new upper and lower range values during an active range shift\n    /// @param upperRange_ The target upper range value\n    /// @param lowerRange_ The target lower range value\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\n    /// @return The updated upper range, lower range, and dexVariables2\n    /// @notice This function handles the gradual shifting of range values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcRangeShifting(\n        uint upperRange_,\n        uint lowerRange_,\n        uint dexVariables2_\n    ) internal returns (uint, uint, uint) {\n        return\n            abi.decode(\n                _spell(\n                    SHIFT_IMPLEMENTATION,\n                    abi.encodeWithSelector(\n                        IShifting._calcRangeShifting.selector,\n                        upperRange_,\n                        lowerRange_,\n                        dexVariables2_\n                    )\n                ),\n                (uint, uint, uint)\n            );\n    }\n\n    /// @dev Calculates the new upper and lower threshold values during an active threshold shift\n    /// @param upperThreshold_ The target upper threshold value\n    /// @param lowerThreshold_ The target lower threshold value\n    /// @param thresholdTime_ The time passed since shifting started\n    /// @return The updated upper threshold, lower threshold, and threshold time\n    /// @notice This function handles the gradual shifting of threshold values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcThresholdShifting(\n        uint upperThreshold_,\n        uint lowerThreshold_,\n        uint thresholdTime_\n    ) internal returns (uint, uint, uint) {\n        return\n            abi.decode(\n                _spell(\n                    SHIFT_IMPLEMENTATION,\n                    abi.encodeWithSelector(\n                        IShifting._calcThresholdShifting.selector,\n                        upperThreshold_,\n                        lowerThreshold_,\n                        thresholdTime_\n                    )\n                ),\n                (uint, uint, uint)\n            );\n    }\n\n    /// @dev Calculates the new center price during an active price shift\n    /// @param dexVariables_ The current state of dex variables\n    /// @param dexVariables2_ Additional dex variables\n    /// @return newCenterPrice_ The updated center price\n    /// @notice This function gradually shifts the center price towards a new target price over time\n    /// @notice It uses an external price source (via ICenterPrice) to determine the target price\n    /// @notice The shift continues until the current price reaches the target, or the shift duration ends\n    /// @notice Once the shift is complete, it updates the state and clears the shift data\n    /// @notice The shift rate is dynamic and depends on:\n    /// @notice - Time remaining in the shift duration\n    /// @notice - The new center price (fetched externally, which may change)\n    /// @notice - The current (old) center price\n    /// @notice This results in a fuzzy shifting mechanism where the rate can change as these parameters evolve\n    /// @notice The externally fetched new center price is expected to not differ significantly from the last externally fetched center price\n    function _calcCenterPrice(uint dexVariables_, uint dexVariables2_) internal returns (uint newCenterPrice_) {\n        return\n            abi.decode(\n                _spell(\n                    SHIFT_IMPLEMENTATION,\n                    abi.encodeWithSelector(IShifting._calcCenterPrice.selector, dexVariables_, dexVariables2_)\n                ),\n                (uint)\n            );\n    }\n\n    /// @notice Calculates and returns the current prices and exchange prices for the pool\n    /// @param dexVariables_ The first set of DEX variables containing various pool parameters\n    /// @param dexVariables2_ The second set of DEX variables containing additional pool parameters\n    /// @return pex_ A struct containing the calculated prices and exchange prices:\n    ///         - pex_.lastStoredPrice: The last stored price in 1e27 decimals\n    ///         - pex_.centerPrice: The calculated or fetched center price in 1e27 decimals\n    ///         - pex_.upperRange: The upper range price limit in 1e27 decimals\n    ///         - pex_.lowerRange: The lower range price limit in 1e27 decimals\n    ///         - pex_.geometricMean: The geometric mean of upper range & lower range in 1e27 decimals\n    ///         - pex_.supplyToken0ExchangePrice: The current exchange price for supplying token0\n    ///         - pex_.borrowToken0ExchangePrice: The current exchange price for borrowing token0\n    ///         - pex_.supplyToken1ExchangePrice: The current exchange price for supplying token1\n    ///         - pex_.borrowToken1ExchangePrice: The current exchange price for borrowing token1\n    /// @dev This function performs the following operations:\n    ///      1. Determines the center price (either from storage, external source, or calculated)\n    ///      2. Retrieves the last stored price from dexVariables_\n    ///      3. Calculates the upper and lower range prices based on the center price and range percentages\n    ///      4. Checks if rebalancing is needed based on threshold settings\n    ///      5. Adjusts prices if necessary based on the time elapsed and threshold conditions\n    ///      6. Update the dexVariables2_ if changes were made\n    ///      7. Returns the calculated prices and exchange prices in the PricesAndExchangePrice struct\n    function _getPricesAndExchangePrices(\n        uint dexVariables_,\n        uint dexVariables2_\n    ) internal returns (PricesAndExchangePrice memory pex_) {\n        uint centerPrice_;\n\n        if (((dexVariables2_ >> 248) & 1) == 0) {\n            // centerPrice_ => center price hook\n            centerPrice_ = (dexVariables2_ >> 112) & X30;\n            if (centerPrice_ == 0) {\n                centerPrice_ = (dexVariables_ >> 81) & X40;\n                centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n            } else {\n                // center price should be fetched from external source. For exmaple, in case of wstETH <> ETH pool,\n                // we would want the center price to be pegged to wstETH exchange rate into ETH\n                centerPrice_ = ICenterPrice(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, centerPrice_)).centerPrice();\n            }\n        } else {\n            // an active centerPrice_ shift is going on\n            centerPrice_ = _calcCenterPrice(dexVariables_, dexVariables2_);\n        }\n\n        uint lastStoredPrice_ = (dexVariables_ >> 41) & X40;\n        lastStoredPrice_ = (lastStoredPrice_ >> DEFAULT_EXPONENT_SIZE) << (lastStoredPrice_ & DEFAULT_EXPONENT_MASK);\n\n        uint upperRange_ = ((dexVariables2_ >> 27) & X20);\n        uint lowerRange_ = ((dexVariables2_ >> 47) & X20);\n        if (((dexVariables2_ >> 26) & 1) == 1) {\n            // an active range shift is going on\n            (upperRange_, lowerRange_, dexVariables2_) = _calcRangeShifting(upperRange_, lowerRange_, dexVariables2_);\n        }\n\n        unchecked {\n            // adding into unchecked because upperRange_ & lowerRange_ can only be > 0 & < SIX_DECIMALS\n            // 1% = 1e4, 100% = 1e6\n            upperRange_ = (centerPrice_ * SIX_DECIMALS) / (SIX_DECIMALS - upperRange_);\n            // 1% = 1e4, 100% = 1e6\n            lowerRange_ = (centerPrice_ * (SIX_DECIMALS - lowerRange_)) / SIX_DECIMALS;\n        }\n\n        bool changed_;\n        {\n            // goal will be to keep threshold percents 0 if center price is fetched from external source\n            // checking if threshold are set non 0 then only rebalancing is on\n            if (((dexVariables2_ >> 68) & X20) > 0) {\n                uint upperThreshold_ = (dexVariables2_ >> 68) & X10;\n                uint lowerThreshold_ = (dexVariables2_ >> 78) & X10;\n                uint shiftingTime_ = (dexVariables2_ >> 88) & X24;\n                if (((dexVariables2_ >> 67) & 1) == 1) {\n                    // if active shift is going on for threshold then calculate threshold real time\n                    (upperThreshold_, lowerThreshold_, shiftingTime_) = _calcThresholdShifting(\n                        upperThreshold_,\n                        lowerThreshold_,\n                        shiftingTime_\n                    );\n                }\n\n                unchecked {\n                    if (\n                        lastStoredPrice_ >\n                        (centerPrice_ +\n                            ((upperRange_ - centerPrice_) * (THREE_DECIMALS - upperThreshold_)) /\n                            THREE_DECIMALS)\n                    ) {\n                        uint timeElapsed_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n                        // price shifting towards upper range\n                        if (timeElapsed_ < shiftingTime_) {\n                            centerPrice_ = centerPrice_ + ((upperRange_ - centerPrice_) * timeElapsed_) / shiftingTime_;\n                        } else {\n                            // 100% price shifted\n                            centerPrice_ = upperRange_;\n                        }\n                        changed_ = true;\n                    } else if (\n                        lastStoredPrice_ <\n                        (centerPrice_ -\n                            ((centerPrice_ - lowerRange_) * (THREE_DECIMALS - lowerThreshold_)) /\n                            THREE_DECIMALS)\n                    ) {\n                        uint timeElapsed_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n                        // price shifting towards lower range\n                        if (timeElapsed_ < shiftingTime_) {\n                            centerPrice_ = centerPrice_ - ((centerPrice_ - lowerRange_) * timeElapsed_) / shiftingTime_;\n                        } else {\n                            // 100% price shifted\n                            centerPrice_ = lowerRange_;\n                        }\n                        changed_ = true;\n                    }\n                }\n            }\n        }\n\n        // temp_ => max center price\n        uint temp_ = (dexVariables2_ >> 172) & X28;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n        if (centerPrice_ > temp_) {\n            // if center price is greater than max center price\n            centerPrice_ = temp_;\n            changed_ = true;\n        } else {\n            // check if center price is less than min center price\n            // temp_ => min center price\n            temp_ = (dexVariables2_ >> 200) & X28;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n            if (centerPrice_ < temp_) {\n                centerPrice_ = temp_;\n                changed_ = true;\n            }\n        }\n\n        // if centerPrice_ is changed then calculating upper and lower range again\n        if (changed_) {\n            upperRange_ = ((dexVariables2_ >> 27) & X20);\n            lowerRange_ = ((dexVariables2_ >> 47) & X20);\n            if (((dexVariables2_ >> 26) & 1) == 1) {\n                (upperRange_, lowerRange_, dexVariables2_) = _calcRangeShifting(\n                    upperRange_,\n                    lowerRange_,\n                    dexVariables2_\n                );\n            }\n\n            unchecked {\n                // adding into unchecked because upperRange_ & lowerRange_ can only be > 0 & < SIX_DECIMALS\n                // 1% = 1e4, 100% = 1e6\n                upperRange_ = (centerPrice_ * SIX_DECIMALS) / (SIX_DECIMALS - upperRange_);\n                // 1% = 1e4, 100% = 1e6\n                lowerRange_ = (centerPrice_ * (SIX_DECIMALS - lowerRange_)) / SIX_DECIMALS;\n            }\n        }\n\n        pex_.lastStoredPrice = lastStoredPrice_;\n        pex_.centerPrice = centerPrice_;\n        pex_.upperRange = upperRange_;\n        pex_.lowerRange = lowerRange_;\n\n        unchecked {\n            if (upperRange_ < 1e38) {\n                // 1e38 * 1e38 = 1e76 which is less than max uint limit\n                pex_.geometricMean = FixedPointMathLib.sqrt(upperRange_ * lowerRange_);\n            } else {\n                // upperRange_ price is pretty large hence lowerRange_ will also be pretty large\n                pex_.geometricMean = FixedPointMathLib.sqrt((upperRange_ / 1e18) * (lowerRange_ / 1e18)) * 1e18;\n            }\n        }\n\n        // Exchange price will remain same as Liquidity Layer\n        (pex_.supplyToken0ExchangePrice, pex_.borrowToken0ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_0_SLOT)\n        );\n\n        (pex_.supplyToken1ExchangePrice, pex_.borrowToken1ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_1_SLOT)\n        );\n    }\n\n    /// @dev getting reserves outside range.\n    /// @param gp_ is geometric mean pricing of upper percent & lower percent\n    /// @param pa_ price of upper range or lower range\n    /// @param rx_ real reserves of token0 or token1\n    /// @param ry_ whatever is rx_ the other will be ry_\n    function _calculateReservesOutsideRange(\n        uint gp_,\n        uint pa_,\n        uint rx_,\n        uint ry_\n    ) internal pure returns (uint xa_, uint yb_) {\n        // equations we have:\n        // 1. x*y = k\n        // 2. xa*ya = k\n        // 3. xb*yb = k\n        // 4. Pa = ya / xa = upperRange_ (known)\n        // 5. Pb = yb / xb = lowerRange_ (known)\n        // 6. x - xa = rx = real reserve of x (known)\n        // 7. y - yb = ry = real reserve of y (known)\n        // With solving we get:\n        // ((Pa*Pb)^(1/2) - Pa)*xa^2 + (rx * (Pa*Pb)^(1/2) + ry)*xa + rx*ry = 0\n        // yb = yb = xa * (Pa * Pb)^(1/2)\n\n        // xa = (GP⋅rx + ry + (-rx⋅ry⋅4⋅(GP - Pa) + (GP⋅rx + ry)^2)^0.5) / (2Pa - 2GP)\n        // multiply entire equation by 1e27 to remove the price decimals precision of 1e27\n        // xa = (GP⋅rx + ry⋅1e27 + (rx⋅ry⋅4⋅(Pa - GP)⋅1e27 + (GP⋅rx + ry⋅1e27)^2)^0.5) / 2*(Pa - GP)\n        // dividing the equation with 2*(Pa - GP). Pa is always > GP so answer will be positive.\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅4⋅(Pa - GP)⋅1e27) / 4*(Pa - GP)^2) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅1e27) / (Pa - GP)) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n\n        // dividing in 3 parts for simplification:\n        // part1 = (Pa - GP)\n        // part2 = (GP⋅rx + ry⋅1e27) / (2*part1)\n        // part3 = rx⋅ry\n        // note: part1 will almost always be < 1e28 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e29\n        uint p1_ = pa_ - gp_;\n        uint p2_ = ((gp_ * rx_) + (ry_ * 1e27)) / (2 * p1_);\n        uint p3_ = rx_ * ry_;\n        // to avoid overflowing\n        p3_ = (p3_ < 1e50) ? ((p3_ * 1e27) / p1_) : (p3_ / p1_) * 1e27;\n\n        // xa = part2 + (part3 + (part2 * part2))^(1/2)\n        // yb = xa_ * gp_\n        xa_ = p2_ + FixedPointMathLib.sqrt((p3_ + (p2_ * p2_)));\n        yb_ = (xa_ * gp_) / 1e27;\n    }\n\n    /// @dev Retrieves collateral amount from liquidity layer for a given token\n    /// @param supplyTokenSlot_ The storage slot for the supply token data\n    /// @param tokenExchangePrice_ The exchange price of the token\n    /// @param isToken0_ Boolean indicating if the token is token0 (true) or token1 (false)\n    /// @return tokenSupply_ The calculated liquidity collateral amount\n    function _getLiquidityCollateral(\n        bytes32 supplyTokenSlot_,\n        uint tokenExchangePrice_,\n        bool isToken0_\n    ) internal view returns (uint tokenSupply_) {\n        uint tokenSupplyData_ = LIQUIDITY.readFromStorage(supplyTokenSlot_);\n        tokenSupply_ = (tokenSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n        tokenSupply_ = (tokenSupply_ >> DEFAULT_EXPONENT_SIZE) << (tokenSupply_ & DEFAULT_EXPONENT_MASK);\n\n        if (tokenSupplyData_ & 1 == 1) {\n            // supply with interest is on\n            unchecked {\n                tokenSupply_ = (tokenSupply_ * tokenExchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n            }\n        }\n\n        unchecked {\n            tokenSupply_ = isToken0_\n                ? ((tokenSupply_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\n                : ((tokenSupply_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\n        }\n    }\n\n    /// @notice Calculates the real and imaginary reserves for collateral tokens\n    /// @dev This function retrieves the supply of both tokens from the liquidity layer,\n    ///      adjusts them based on exchange prices, and calculates imaginary reserves\n    ///      based on the geometric mean and price range\n    /// @param geometricMean_ The geometric mean of the token prices\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0SupplyExchangePrice_ The exchange price for token0 from liquidity layer\n    /// @param token1SupplyExchangePrice_ The exchange price for token1 from liquidity layer\n    /// @return c_ A struct containing the calculated real and imaginary reserves for both tokens:\n    ///         - token0RealReserves: The real reserves of token0\n    ///         - token1RealReserves: The real reserves of token1\n    ///         - token0ImaginaryReserves: The imaginary reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary reserves of token1\n    function _getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) internal view returns (CollateralReserves memory c_) {\n        uint token0Supply_ = _getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, token0SupplyExchangePrice_, true);\n        uint token1Supply_ = _getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, token1SupplyExchangePrice_, false);\n\n        if (geometricMean_ < 1e27) {\n            (c_.token0ImaginaryReserves, c_.token1ImaginaryReserves) = _calculateReservesOutsideRange(\n                geometricMean_,\n                upperRange_,\n                token0Supply_,\n                token1Supply_\n            );\n        } else {\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n            // 1 / geometricMean for new geometricMean\n            // 1 / lowerRange will become upper range\n            // 1 / upperRange will become lower range\n            (c_.token1ImaginaryReserves, c_.token0ImaginaryReserves) = _calculateReservesOutsideRange(\n                (1e54 / geometricMean_),\n                (1e54 / lowerRange_),\n                token1Supply_,\n                token0Supply_\n            );\n        }\n\n        c_.token0RealReserves = token0Supply_;\n        c_.token1RealReserves = token1Supply_;\n        unchecked {\n            c_.token0ImaginaryReserves += token0Supply_;\n            c_.token1ImaginaryReserves += token1Supply_;\n        }\n    }\n\n    /// @notice Calculates the real and imaginary debt reserves for both tokens\n    /// @dev This function uses a quadratic equation to determine the debt reserves\n    ///      based on the geometric mean price and the current debt amounts\n    /// @param gp_ The geometric mean price of upper range & lower range\n    /// @param pb_ The price of lower range\n    /// @param dx_ The debt amount of one token\n    /// @param dy_ The debt amount of the other token\n    /// @return rx_ The real debt reserve of the first token\n    /// @return ry_ The real debt reserve of the second token\n    /// @return irx_ The imaginary debt reserve of the first token\n    /// @return iry_ The imaginary debt reserve of the second token\n    function _calculateDebtReserves(\n        uint gp_,\n        uint pb_,\n        uint dx_,\n        uint dy_\n    ) internal pure returns (uint rx_, uint ry_, uint irx_, uint iry_) {\n        // Assigning letter to knowns:\n        // c = debtA\n        // d = debtB\n        // e = upperPrice\n        // f = lowerPrice\n        // g = upperPrice^1/2\n        // h = lowerPrice^1/2\n\n        // c = 1\n        // d = 2000\n        // e = 2222.222222\n        // f = 1800\n        // g = 2222.222222^1/2\n        // h = 1800^1/2\n\n        // Assigning letter to unknowns:\n        // w = realDebtReserveA\n        // x = realDebtReserveB\n        // y = imaginaryDebtReserveA\n        // z = imaginaryDebtReserveB\n        // k = k\n\n        // below quadratic will give answer of realDebtReserveB\n        // A, B, C of quadratic equation:\n        // A = h\n        // B = dh - cfg\n        // C = -cfdh\n\n        // A = lowerPrice^1/2\n        // B = debtB⋅lowerPrice^1/2 - debtA⋅lowerPrice⋅upperPrice^1/2\n        // C = -(debtA⋅lowerPrice⋅debtB⋅lowerPrice^1/2)\n\n        // x = (cfg − dh + (4cdf(h^2)+(cfg−dh)^2))^(1/2)) / 2h\n        // simplifying dividing by h, note h = f^1/2\n        // x = ((c⋅g⋅(f^1/2) − d) / 2 + ((4⋅c⋅d⋅f⋅f) / (4h^2) + ((c⋅f⋅g) / 2h − (d⋅h) / 2h)^2))^(1/2))\n        // x = ((c⋅g⋅(f^1/2) − d) / 2 + ((c⋅d⋅f) + ((c⋅g⋅(f^1/2) − d) / 2)^2))^(1/2))\n\n        // dividing in 3 parts for simplification:\n        // part1 = (c⋅g⋅(f^1/2) − d) / 2\n        // part2 = (c⋅d⋅f)\n        // x = (part1 + (part2 + part1^2)^(1/2))\n        // note: part1 will almost always be < 1e27 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e28\n\n        // part1 = ((debtA * upperPrice^1/2 * lowerPrice^1/2) - debtB) / 2\n        // note: upperPrice^1/2 * lowerPrice^1/2 = geometric mean\n        // part1 = ((debtA * geometricMean) - debtB) / 2\n        // part2 = debtA * debtB * lowerPrice\n\n        // converting decimals properly as price is in 1e27 decimals\n        // part1 = ((debtA * geometricMean) - (debtB * 1e27)) / (2 * 1e27)\n        // part2 = (debtA * debtB * lowerPrice) / 1e27\n        // final x equals:\n        // x = (part1 + (part2 + part1^2)^(1/2))\n        int p1_ = (int(dx_ * gp_) - int(dy_ * 1e27)) / (2 * 1e27);\n        uint p2_ = (dx_ * dy_);\n        p2_ = p2_ < 1e50 ? (p2_ * pb_) / 1e27 : (p2_ / 1e27) * pb_;\n        ry_ = uint(p1_ + int(FixedPointMathLib.sqrt((p2_ + uint(p1_ * p1_)))));\n\n        // finding z:\n        // x^2 - zx + cfz = 0\n        // z*(x - cf) = x^2\n        // z = x^2 / (x - cf)\n        // z = x^2 / (x - debtA * lowerPrice)\n        // converting decimals properly as price is in 1e27 decimals\n        // z = (x^2 * 1e27) / ((x * 1e27) - (debtA * lowerPrice))\n\n        iry_ = ((ry_ * 1e27) - (dx_ * pb_));\n        if (iry_ < SIX_DECIMALS) {\n            // almost impossible situation to ever get here\n            revert FluidDexError(ErrorTypes.DexT1__DebtReservesTooLow);\n        }\n        if (ry_ < 1e25) {\n            iry_ = (ry_ * ry_ * 1e27) / iry_;\n        } else {\n            // note: it can never result in negative as final result will always be in positive\n            iry_ = (ry_ * ry_) / (iry_ / 1e27);\n        }\n\n        // finding y\n        // x = z * c / (y + c)\n        // y + c = z * c / x\n        // y = (z * c / x) - c\n        // y = (z * debtA / x) - debtA\n        irx_ = ((iry_ * dx_) / ry_) - dx_;\n\n        // finding w\n        // w = y * d / (z + d)\n        // w = (y * debtB) / (z + debtB)\n        rx_ = (irx_ * dy_) / (iry_ + dy_);\n    }\n\n    /// @notice Calculates the debt amount for a given token from liquidity layer\n    /// @param borrowTokenSlot_ The storage slot for the token's borrow data\n    /// @param tokenExchangePrice_ The current exchange price of the token\n    /// @param isToken0_ Boolean indicating if this is for token0 (true) or token1 (false)\n    /// @return tokenDebt_ The calculated debt amount for the token\n    function _getLiquidityDebt(\n        bytes32 borrowTokenSlot_,\n        uint tokenExchangePrice_,\n        bool isToken0_\n    ) internal view returns (uint tokenDebt_) {\n        uint tokenBorrowData_ = LIQUIDITY.readFromStorage(borrowTokenSlot_);\n\n        tokenDebt_ = (tokenBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n        tokenDebt_ = (tokenDebt_ >> 8) << (tokenDebt_ & X8);\n\n        if (tokenBorrowData_ & 1 == 1) {\n            // borrow with interest is on\n            unchecked {\n                tokenDebt_ = (tokenDebt_ * tokenExchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n            }\n        }\n\n        unchecked {\n            tokenDebt_ = isToken0_\n                ? ((tokenDebt_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\n                : ((tokenDebt_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\n        }\n    }\n\n    /// @notice Calculates the debt reserves for both tokens\n    /// @param geometricMean_ The geometric mean of the upper and lower price ranges\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0BorrowExchangePrice_ The exchange price of token0 from liquidity layer\n    /// @param token1BorrowExchangePrice_ The exchange price of token1 from liquidity layer\n    /// @return d_ The calculated debt reserves for both tokens, containing:\n    ///         - token0Debt: The debt amount of token0\n    ///         - token1Debt: The debt amount of token1\n    ///         - token0RealReserves: The real reserves of token0 derived from token1 debt\n    ///         - token1RealReserves: The real reserves of token1 derived from token0 debt\n    ///         - token0ImaginaryReserves: The imaginary debt reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary debt reserves of token1\n    function _getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) internal view returns (DebtReserves memory d_) {\n        uint token0Debt_ = _getLiquidityDebt(BORROW_TOKEN_0_SLOT, token0BorrowExchangePrice_, true);\n        uint token1Debt_ = _getLiquidityDebt(BORROW_TOKEN_1_SLOT, token1BorrowExchangePrice_, false);\n\n        d_.token0Debt = token0Debt_;\n        d_.token1Debt = token1Debt_;\n\n        if (geometricMean_ < 1e27) {\n            (\n                d_.token0RealReserves,\n                d_.token1RealReserves,\n                d_.token0ImaginaryReserves,\n                d_.token1ImaginaryReserves\n            ) = _calculateDebtReserves(geometricMean_, lowerRange_, token0Debt_, token1Debt_);\n        } else {\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n            // 1 / geometricMean for new geometricMean\n            // 1 / lowerRange will become upper range\n            // 1 / upperRange will become lower range\n            (\n                d_.token1RealReserves,\n                d_.token0RealReserves,\n                d_.token1ImaginaryReserves,\n                d_.token0ImaginaryReserves\n            ) = _calculateDebtReserves((1e54 / geometricMean_), (1e54 / upperRange_), token1Debt_, token0Debt_);\n        }\n    }\n\n    function _priceDiffCheck(uint oldPrice_, uint newPrice_) internal pure returns (int priceDiff_) {\n        // check newPrice_ & oldPrice_ difference should not be more than 5%\n        // old price w.r.t new price\n        priceDiff_ = int(ORACLE_PRECISION) - int((oldPrice_ * ORACLE_PRECISION) / newPrice_);\n\n        unchecked {\n            if ((priceDiff_ > int(ORACLE_LIMIT)) || (priceDiff_ < -int(ORACLE_LIMIT))) {\n                // if oracle price difference is more than 5% then revert\n                // in 1 swap price should only change by <= 5%\n                // if a total fall by let's say 8% then in current block price can only fall by 5% and\n                // in next block it'll fall the remaining 3%\n                revert FluidDexError(ErrorTypes.DexT1__OracleUpdateHugeSwapDiff);\n            }\n        }\n    }\n\n    function _updateOracle(uint newPrice_, uint centerPrice_, uint dexVariables_) internal returns (uint) {\n        // time difference between last & current swap\n        uint timeDiff_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n        uint temp_;\n        uint temp2_;\n        uint temp3_;\n\n        if (timeDiff_ == 0) {\n            // doesn't matter if oracle is on or off when timediff = 0 code for both is same\n\n            // temp_ => oldCenterPrice\n            temp_ = (dexVariables_ >> 81) & X40;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // Ensure that the center price is within the acceptable range of the old center price if it's not the first swap in the same block\n            unchecked {\n                if (\n                    (centerPrice_ < (((EIGHT_DECIMALS - 1) * temp_) / EIGHT_DECIMALS)) ||\n                    (centerPrice_ > (((EIGHT_DECIMALS + 1) * temp_) / EIGHT_DECIMALS))\n                ) {\n                    revert FluidDexError(ErrorTypes.DexT1__CenterPriceOutOfRange);\n                }\n            }\n\n            // olderPrice_ => temp_\n            temp_ = (dexVariables_ >> 1) & X40;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            _priceDiffCheck(temp_, newPrice_);\n\n            // 2nd swap in same block no need to update anything around oracle, only need to update last swap price in dexVariables\n            return ((dexVariables_ & 0xfffffffffffffffffffffffffffffffffffffffffffe0000000001ffffffffff) |\n                (newPrice_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN) << 41));\n        }\n\n        if (((dexVariables_ >> 195) & 1) == 0) {\n            // if oracle is not active then just returning updated DEX variable\n            temp_ = ((dexVariables_ >> 41) & X40);\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            _priceDiffCheck(temp_, newPrice_);\n            \n            return ((dexVariables_ & 0xfffffffffffffffffffffffffc00000000000000000000000000000000000001) |\n                (((dexVariables_ >> 41) & X40) << 1) |\n                (newPrice_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN) << 41) |\n                (centerPrice_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN) << 81) |\n                (block.timestamp << 121));\n        } else {\n            // oracle is active hence update oracle\n\n            // olderPrice_ => temp_\n            temp_ = (dexVariables_ >> 1) & X40;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // oldPrice_ => temp2_\n            temp2_ = (dexVariables_ >> 41) & X40;\n            temp2_ = (temp2_ >> DEFAULT_EXPONENT_SIZE) << (temp2_ & DEFAULT_EXPONENT_MASK);\n\n            int priceDiff_ = _priceDiffCheck(temp2_, newPrice_);\n\n            unchecked {\n                // older price w.r.t old price\n                priceDiff_ = int(ORACLE_PRECISION) - int((temp_ * ORACLE_PRECISION) / temp2_);\n            }\n\n            // priceDiffInPercentAndSign_ => temp3_\n            // priceDiff_ will always be lower than ORACLE_LIMIT due to above check\n            unchecked {\n                if (priceDiff_ < 0) {\n                    temp3_ = ((uint(-priceDiff_) * X22) / ORACLE_LIMIT) << 1;\n                } else {\n                    // if greater than or equal to 0 then make sign flag 1\n                    temp3_ = (((uint(priceDiff_) * X22) / ORACLE_LIMIT) << 1) | 1;\n                }\n            }\n\n            if (timeDiff_ > X22) {\n                // if time difference is this then that means DEX has been inactive ~45 days\n                // that means oracle price of this DEX should not be used.\n                timeDiff_ = X22;\n            }\n\n            // temp_ => lastTimeDiff_\n            temp_ = (dexVariables_ >> 154) & X22;\n            uint nextOracleSlot_ = ((dexVariables_ >> 176) & X3);\n            uint oracleMap_ = (dexVariables_ >> 179) & X16;\n            if (temp_ > X9) {\n                if (nextOracleSlot_ > 0) {\n                    // if greater than 0 then current slot has 2 or more oracle slot empty\n                    // First 9 bits are of time, so not using that\n                    temp3_ = (temp3_ << 41) | (temp_ << 9);\n                    _oracle[oracleMap_] = _oracle[oracleMap_] | (temp3_ << (--nextOracleSlot_ * 32));\n                    if (nextOracleSlot_ > 0) {\n                        --nextOracleSlot_;\n                    } else {\n                        // if == 0 that means the oracle slots will get filled and shift to next oracle map\n                        nextOracleSlot_ = 7;\n                        unchecked {\n                            oracleMap_ = (oracleMap_ + 1) % TOTAL_ORACLE_MAPPING;\n                        }\n                        _oracle[oracleMap_] = 0;\n                    }\n                } else {\n                    // if == 0\n                    // then seconds will be in last map\n                    // precision will be in last map + 1\n                    // Storing precision & sign slot in first precision & sign slot and leaving time slot empty\n                    temp3_ = temp3_ << 9;\n                    _oracle[oracleMap_] = _oracle[oracleMap_] | temp3_;\n                    nextOracleSlot_ = 6; // storing 6 here as 7 is going to occupied right now\n                    unchecked {\n                        oracleMap_ = (oracleMap_ + 1) % TOTAL_ORACLE_MAPPING;\n                    }\n                    // Storing time in 2nd precision & sign and leaving time slot empty\n                    _oracle[oracleMap_] = temp_ << ((7 * 32) + 9);\n                }\n            } else {\n                temp3_ = (temp3_ << 9) | temp_;\n                unchecked {\n                    if (nextOracleSlot_ < 7) {\n                        _oracle[oracleMap_] = _oracle[oracleMap_] | (temp3_ << (nextOracleSlot_ * 32));\n                    } else {\n                        _oracle[oracleMap_] = temp3_ << ((7 * 32));\n                    }\n                }\n                if (nextOracleSlot_ > 0) {\n                    --nextOracleSlot_;\n                } else {\n                    nextOracleSlot_ = 7;\n                    unchecked {\n                        oracleMap_ = (oracleMap_ + 1) % TOTAL_ORACLE_MAPPING;\n                    }\n                    _oracle[oracleMap_] = 0;\n                }\n            }\n\n            // doing this due to stack too deep error when using params memory variables\n            temp_ = newPrice_;\n            temp2_ = centerPrice_;\n            temp3_ = dexVariables_;\n\n            // then update last price\n            return ((temp3_ & 0xfffffffffffffff8000000000000000000000000000000000000000000000001) |\n                (((temp3_ >> 41) & X40) << 1) |\n                (temp_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN) << 41) |\n                (temp2_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN) << 81) |\n                (block.timestamp << 121) |\n                (timeDiff_ << 154) |\n                (nextOracleSlot_ << 176) |\n                (oracleMap_ << 179));\n        }\n    }\n\n    function _hookVerify(uint hookAddress_, uint mode_, bool swap0to1_, uint price_) internal {\n        try\n            IHook(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, hookAddress_)).dexPrice(\n                mode_,\n                swap0to1_,\n                TOKEN_0,\n                TOKEN_1,\n                price_\n            )\n        returns (bool isOk_) {\n            if (!isOk_) revert FluidDexError(ErrorTypes.DexT1__HookReturnedFalse);\n        } catch (bytes memory /*lowLevelData*/) {\n            // skip checking hook nothing\n        }\n    }\n\n    function _updateSupplyShares(uint newTotalShares_) internal {\n        uint totalSupplyShares_ = _totalSupplyShares;\n\n        // new total shares are greater than old total shares && new total shares are greater than max supply shares\n        if (\n            (newTotalShares_ > (totalSupplyShares_ & X128)) && \n            newTotalShares_ > (totalSupplyShares_ >> 128)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__SupplySharesOverflow);\n        }\n\n        // keeping max supply shares intact\n        _totalSupplyShares = ((totalSupplyShares_ >> 128) << 128) | newTotalShares_;\n    }\n\n    function _updateBorrowShares(uint newTotalShares_) internal {\n        uint totalBorrowShares_ = _totalBorrowShares;\n\n        // new total shares are greater than old total shares && new total shares are greater than max borrow shares\n        if (\n            (newTotalShares_ > (totalBorrowShares_ & X128)) && \n            newTotalShares_ > (totalBorrowShares_ >> 128)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__BorrowSharesOverflow);\n        }\n\n        // keeping max borrow shares intact\n        _totalBorrowShares = ((totalBorrowShares_ >> 128) << 128) | newTotalShares_;\n    }\n\n    constructor(ConstantViews memory constantViews_) ImmutableVariables(constantViews_) {}\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/helpers/secondaryHelpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport { UserHelpers } from \"./userHelpers.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { AddressCalcs } from \"../../../../../libraries/addressCalcs.sol\";\n\nabstract contract SecondaryHelpers is UserHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) UserHelpers(constantViews_) {}\n\n    /// @param c_ tokenA amount to swap and deposit\n    /// @param d_ tokenB imaginary reserves\n    /// @param e_ tokenA imaginary reserves\n    /// @param f_ tokenA real reserves\n    /// @param i_ tokenB real reserves\n    function _getSwapAndDeposit(uint c_, uint d_, uint e_, uint f_, uint i_) internal pure returns (uint shares_) {\n        // swap and deposit in equal proportion\n\n        // tokenAx = c\n        // imaginaryTokenBReserves = d\n        // imaginaryTokenAReserves = e\n        // tokenAReserves = f\n        // tokenBReserves = i\n\n        // Quadratic equations, A, B & C are:\n        // A = i\n        // B = (ie - ic + dc + fd)\n        // C = -iec\n\n        // final equation:\n        // token to swap = (−(c⋅d−c⋅i+d⋅f+e⋅i) + (4⋅c⋅e⋅i^2 + (c⋅d−c⋅i+d⋅f+e⋅i)^2)^0.5) / 2⋅i\n        // B = (c⋅d−c⋅i+d⋅f+e⋅i)\n        // token to swap = (−B + (4⋅c⋅e⋅i^2 + (B)^2)^0.5) / 2⋅i\n        // simplifying above equation by dividing the entire equation by i:\n        // token to swap = (−B/i + (4⋅c⋅e + (B/i)^2)^0.5) / 2\n        // note: d > i always, so dividing won't be an issue\n\n        // temp_ => B/i\n        uint temp_ = (c_ * d_ + d_ * f_ + e_ * i_ - c_ * i_) / i_;\n        uint temp2_ = 4 * c_ * e_;\n        uint amtToSwap_ = (FixedPointMathLib.sqrt((temp2_ + (temp_ * temp_))) - temp_) / 2;\n\n        // Ensure the amount to swap is within reasonable bounds:\n        // - Not greater than 99.9999% of the input amount (c_)\n        // - Not less than 0.0001% of the input amount (c_)\n        // This prevents extreme scenarios and maybe potential precision issues\n        if ((amtToSwap_ > ((c_ * (SIX_DECIMALS - 1)) / SIX_DECIMALS)) || (amtToSwap_ < (c_ / SIX_DECIMALS)))\n            revert FluidDexError(ErrorTypes.DexT1__SwapAndDepositTooLowOrTooHigh);\n\n        // temp_ => amt0ToDeposit\n        temp_ = c_ - amtToSwap_;\n        // (imaginaryTokenBReserves * amtToSwap_) / (imaginaryTokenAReserves + amtToSwap_)\n        // temp2_ => amt1ToDeposit_\n        temp2_ = (d_ * amtToSwap_) / (e_ + amtToSwap_);\n\n        // temp_ => shares1\n        temp_ = (temp_ * 1e18) / (f_ + amtToSwap_);\n        // temp2_ => shares1\n        temp2_ = (temp2_ * 1e18) / (i_ - temp2_);\n        // temp_ & temp2 should be same. Although, due to some possible precision loss taking the lower one\n        shares_ = temp_ > temp2_ ? temp2_ : temp_;\n    }\n\n    /// @notice Updates collateral reserves based on minting or burning of shares\n    /// @param newShares_ The number of new shares being minted or burned\n    /// @param totalOldShares_ The total number of shares before the operation\n    /// @param c_ The current collateral reserves\n    /// @param mintOrBurn_ True if minting shares, false if burning shares\n    /// @return c2_ The updated collateral reserves after the operation\n    function _getUpdatedColReserves(\n        uint newShares_,\n        uint totalOldShares_,\n        CollateralReserves memory c_,\n        bool mintOrBurn_ // true if mint, false if burn\n    ) internal pure returns (CollateralReserves memory c2_) {\n        if (mintOrBurn_) {\n            // If minting, increase reserves proportionally to new shares\n            c2_.token0RealReserves = c_.token0RealReserves + (c_.token0RealReserves * newShares_) / totalOldShares_;\n            c2_.token1RealReserves = c_.token1RealReserves + (c_.token1RealReserves * newShares_) / totalOldShares_;\n            c2_.token0ImaginaryReserves =\n                c_.token0ImaginaryReserves +\n                (c_.token0ImaginaryReserves * newShares_) /\n                totalOldShares_;\n            c2_.token1ImaginaryReserves =\n                c_.token1ImaginaryReserves +\n                (c_.token1ImaginaryReserves * newShares_) /\n                totalOldShares_;\n        } else {\n            // If burning, decrease reserves proportionally to burned shares\n            c2_.token0RealReserves = c_.token0RealReserves - ((c_.token0RealReserves * newShares_) / totalOldShares_);\n            c2_.token1RealReserves = c_.token1RealReserves - ((c_.token1RealReserves * newShares_) / totalOldShares_);\n            c2_.token0ImaginaryReserves =\n                c_.token0ImaginaryReserves -\n                ((c_.token0ImaginaryReserves * newShares_) / totalOldShares_);\n            c2_.token1ImaginaryReserves =\n                c_.token1ImaginaryReserves -\n                ((c_.token1ImaginaryReserves * newShares_) / totalOldShares_);\n        }\n        return c2_;\n    }\n\n    /// @param c_ tokenA current real reserves (aka reserves before withdraw & swap)\n    /// @param d_ tokenB current real reserves (aka reserves before withdraw & swap)\n    /// @param e_ tokenA: final imaginary reserves - real reserves (aka reserves outside range after withdraw & swap)\n    /// @param f_ tokenB: final imaginary reserves - real reserves (aka reserves outside range after withdraw & swap)\n    /// @param g_ tokenA perfect amount to withdraw\n    function _getWithdrawAndSwap(uint c_, uint d_, uint e_, uint f_, uint g_) internal pure returns (uint shares_) {\n        // Equations we have:\n        // 1. tokenAxa / tokenBxb = tokenAReserves / tokenBReserves (Withdraw in equal proportion)\n        // 2. newTokenAReserves = tokenAReserves - tokenAxa\n        // 3. newTokenBReserves = tokenBReserves - tokenBxb\n        // 4 (known). finalTokenAReserves = tokenAReserves - tokenAx\n        // 5 (known). finalTokenBReserves = tokenBReserves\n\n        // Note: Xnew * Ynew = k = Xfinal * Yfinal (Xfinal & Yfinal is final imaginary reserve of token A & B).\n        // Now as we know finalTokenAReserves & finalTokenAReserves, hence we can also calculate\n        // imaginaryReserveMinusRealReservesA = finalImaginaryAReserves - finalTokenAReserves\n        // imaginaryReserveMinusRealReservesB = finalImaginaryBReserves - finalTokenBReserves\n        // Swaps only happen on real reserves hence before and after swap imaginaryReserveMinusRealReservesA &\n        // imaginaryReserveMinusRealReservesB should have exactly the same value.\n\n        // 6. newImaginaryTokenAReserves = imaginaryReserveMinusRealReservesA + newTokenAReserves\n        // newImaginaryTokenAReserves = imaginaryReserveMinusRealReservesA + tokenAReserves - tokenAxa\n        // 7. newImaginaryTokenBReserves = imaginaryReserveMinusRealReservesB + newTokenBReserves\n        // newImaginaryTokenBReserves = imaginaryReserveMinusRealReservesB + tokenBReserves - tokenBxb\n        // 8. tokenAxb = (newImaginaryTokenAReserves * tokenBxb) / (newImaginaryTokenBReserves + tokenBxb)\n        // 9. tokenAxa + tokenAxb = tokenAx\n\n        // simplifying knowns in 1 letter to make things clear:\n        // c = tokenAReserves\n        // d = tokenBReserves\n        // e = imaginaryReserveMinusRealReservesA\n        // f = imaginaryReserveMinusRealReservesB\n        // g = tokenAx\n\n        // A, B, C of quadratic are:\n        // A = d\n        // B = -(de + 2cd + cf)\n        // C = cfg + cdg\n\n        // tokenAxa = ((d⋅e + 2⋅c⋅d + c⋅f) - ((d⋅e + 2⋅c⋅d + c⋅f)^2 - 4⋅d⋅(c⋅f⋅g + c⋅d⋅g))^0.5) / 2d\n        // dividing 2d first to avoid overflowing\n        // B = (d⋅e + 2⋅c⋅d + c⋅f) / 2d\n        // (B - ((B)^2 - (4⋅d⋅(c⋅f⋅g + c⋅d⋅g) / 4⋅d^2))^0.5)\n        // (B - ((B)^2 - ((c⋅f⋅g + c⋅d⋅g) / d))^0.5)\n\n        // temp_ = B/2A\n        uint temp_ = (d_ * e_ + 2 * c_ * d_ + c_ * f_) / (2 * d_);\n        // temp2_ = 4AC / 4A^2 = C / A\n        // to avoid overflowing in any case multiplying with g_ later\n        uint temp2_ = (((c_ * f_) / d_) + c_) * g_;\n\n        // tokenAxa = (-B - (B^2 - 4AC)^0.5) / 2A\n        uint tokenAxa_ = temp_ - FixedPointMathLib.sqrt((temp_ * temp_) - temp2_);\n\n        // Ensure the amount to withdraw is within reasonable bounds:\n        // - Not greater than 99.9999% of the input amount (g_)\n        // - Not less than 0.0001% of the input amount (g_)\n        // This prevents extreme scenarios and maybe potential precision issues\n        if (tokenAxa_ > ((g_ * (SIX_DECIMALS - 1)) / SIX_DECIMALS) || tokenAxa_ < (g_ / SIX_DECIMALS))\n            revert FluidDexError(ErrorTypes.DexT1__WithdrawAndSwapTooLowOrTooHigh);\n\n        shares_ = (tokenAxa_ * 1e18) / c_;\n    }\n\n    /// @param c_ tokenA current debt before swap (aka debt before borrow & swap)\n    /// @param d_ tokenB current debt before swap (aka debt before borrow & swap)\n    /// @param e_ tokenA final imaginary reserves (reserves after borrow & swap)\n    /// @param f_ tokenB final imaginary reserves (reserves after borrow & swap)\n    /// @param g_ tokenA perfect amount to borrow\n    function _getBorrowAndSwap(uint c_, uint d_, uint e_, uint f_, uint g_) internal pure returns (uint shares_) {\n        // 1. tokenAxa / tokenADebt = tokenBxb / tokenBDebt (borrowing in equal proportion)\n        // 2. newImaginaryTokenAReserves = tokenAFinalImaginaryReserves + tokenAxb\n        // 3. newImaginaryTokenBReserves = tokenBFinalImaginaryReserves - tokenBxb\n        // // Note: I assumed reserve of tokenA and debt of token A while solving which is fine.\n        // // But in other places I use debtA to find reserveB\n        // 4. tokenAxb = (newImaginaryTokenAReserves * tokenBxb) / (newImaginaryTokenBReserves + tokenBxb)\n        // 5. tokenAxa + tokenAxb = tokenAx\n\n        // Inserting 2 & 3 into 4:\n        // 6. tokenAxb = ((tokenAFinalImaginaryReserves + tokenAxb) * tokenBxb) / ((tokenBFinalImaginaryReserves - tokenBxb) + tokenBxb)\n        // 6. tokenAxb = ((tokenAFinalImaginaryReserves + tokenAxb) * tokenBxb) / (tokenBFinalImaginaryReserves)\n\n        // Making 1 in terms of tokenBxb:\n        // 1. tokenBxb = tokenAxa * tokenBDebt / tokenADebt\n\n        // Inserting 5 into 6:\n        // 7. (tokenAx - tokenAxa) = ((tokenAFinalImaginaryReserves + (tokenAx - tokenAxa)) * tokenBxb) / (tokenBFinalImaginaryReserves)\n\n        // Inserting 1 into 7:\n        // 8. (tokenAx - tokenAxa) * tokenBFinalImaginaryReserves = ((tokenAFinalImaginaryReserves + (tokenAx - tokenAxa)) * (tokenAxa * tokenBDebt / tokenADebt))\n\n        // Replacing knowns with:\n        // c = tokenADebt\n        // d = tokenBDebt\n        // e = tokenAFinalImaginaryReserves\n        // f = tokenBFinalImaginaryReserves\n        // g = tokenAx\n\n        // 8. (g - tokenAxa) * f * c = ((e + (g - tokenAxa)) * (tokenAxa * d))\n        // 8. cfg - cf*tokenAxa = de*tokenAxa + dg*tokenAxa - d*tokenAxa^2\n        // 8. d*tokenAxa^2 - cf*tokenAxa - de*tokenAxa - dg*tokenAxa + cfg = 0\n        // 8. d*tokenAxa^2 - (cf + de + dg)*tokenAxa + cfg = 0\n\n        // A, B, C of quadratic are:\n        // A = d\n        // B = -(cf + de + dg)\n        // C = cfg\n\n        // temp_ = B/2A\n        uint temp_ = (c_ * f_ + d_ * e_ + d_ * g_) / (2 * d_);\n\n        // temp2_ = 4AC / 4A^2 = C / A\n        // to avoid overflowing in any case multiplying with g_ later\n        uint temp2_ = (c_ * f_ * g_) / d_;\n\n        // tokenAxa = (-B - (B^2 - 4AC)^0.5) / 2A\n        uint tokenAxa_ = temp_ - FixedPointMathLib.sqrt((temp_ * temp_) - temp2_);\n\n        // Ensure the amount to borrow is within reasonable bounds:\n        // - Not greater than 99.9999% of the input amount (g_)\n        // - Not less than 0.0001% of the input amount (g_)\n        // This prevents extreme scenarios and maybe potential precision issues\n        if (tokenAxa_ > ((g_ * (SIX_DECIMALS - 1)) / SIX_DECIMALS) || tokenAxa_ < (g_ / SIX_DECIMALS))\n            revert FluidDexError(ErrorTypes.DexT1__BorrowAndSwapTooLowOrTooHigh);\n\n        // rounding up borrow shares to mint for user\n        shares_ = ((tokenAxa_ + 1) * 1e18) / c_;\n    }\n\n    /// @notice Updates debt and reserves based on minting or burning shares\n    /// @param shares_ The number of shares to mint or burn\n    /// @param totalShares_ The total number of shares before the operation\n    /// @param d_ The current debt and reserves\n    /// @param mintOrBurn_ True if minting, false if burning\n    /// @return d2_ The updated debt and reserves\n    /// @dev This function calculates the new debt and reserves when minting or burning shares.\n    /// @dev It updates the following for both tokens:\n    /// @dev - Debt\n    /// @dev - Real Reserves\n    /// @dev - Imaginary Reserves\n    /// @dev The calculation is done proportionally based on the ratio of shares to total shares.\n    /// @dev For minting, it adds the proportional amount.\n    /// @dev For burning, it subtracts the proportional amount.\n    function _getUpdateDebtReserves(\n        uint shares_,\n        uint totalShares_,\n        DebtReserves memory d_,\n        bool mintOrBurn_ // true if mint, false if burn\n    ) internal pure returns (DebtReserves memory d2_) {\n        if (mintOrBurn_) {\n            d2_.token0Debt = d_.token0Debt + (d_.token0Debt * shares_) / totalShares_;\n            d2_.token1Debt = d_.token1Debt + (d_.token1Debt * shares_) / totalShares_;\n            d2_.token0RealReserves = d_.token0RealReserves + (d_.token0RealReserves * shares_) / totalShares_;\n            d2_.token1RealReserves = d_.token1RealReserves + (d_.token1RealReserves * shares_) / totalShares_;\n            d2_.token0ImaginaryReserves =\n                d_.token0ImaginaryReserves +\n                (d_.token0ImaginaryReserves * shares_) /\n                totalShares_;\n            d2_.token1ImaginaryReserves =\n                d_.token1ImaginaryReserves +\n                (d_.token1ImaginaryReserves * shares_) /\n                totalShares_;\n        } else {\n            d2_.token0Debt = d_.token0Debt - (d_.token0Debt * shares_) / totalShares_;\n            d2_.token1Debt = d_.token1Debt - (d_.token1Debt * shares_) / totalShares_;\n            d2_.token0RealReserves = d_.token0RealReserves - (d_.token0RealReserves * shares_) / totalShares_;\n            d2_.token1RealReserves = d_.token1RealReserves - (d_.token1RealReserves * shares_) / totalShares_;\n            d2_.token0ImaginaryReserves =\n                d_.token0ImaginaryReserves -\n                (d_.token0ImaginaryReserves * shares_) /\n                totalShares_;\n            d2_.token1ImaginaryReserves =\n                d_.token1ImaginaryReserves -\n                (d_.token1ImaginaryReserves * shares_) /\n                totalShares_;\n        }\n\n        return d2_;\n    }\n\n    /// @param a_ tokenA new imaginary reserves (imaginary reserves after perfect payback but not swap yet)\n    /// @param b_ tokenB new imaginary reserves (imaginary reserves after perfect payback but not swap yet)\n    /// @param c_ tokenA current debt\n    /// @param d_ tokenB current debt & final debt (tokenB current & final debt remains same)\n    /// @param i_ tokenA new reserves (reserves after perfect payback but not swap yet)\n    /// @param j_ tokenB new reserves (reserves after perfect payback but not swap yet)\n    function _getSwapAndPaybackOneTokenPerfectShares(\n        uint a_,\n        uint b_,\n        uint c_,\n        uint d_,\n        uint i_,\n        uint j_\n    ) internal pure returns (uint tokenAmt_) {\n        // l_ => tokenA reserves outside range\n        uint l_ = a_ - i_;\n        // m_ => tokenB reserves outside range\n        uint m_ = b_ - j_;\n        // w_ => new K or final K will be same, xy = k\n        uint w_ = a_ * b_;\n        // z_ => final reserveB full, when entire debt is in tokenA\n        uint z_ = w_ / l_;\n        // y_ => final reserveA full, when entire debt is in tokenB\n        uint y_ = w_ / m_;\n        // v_ = final reserveB\n        uint v_ = z_ - m_ - d_;\n        // x_ = final tokenA debt\n        uint x_ = (v_ * y_) / (m_ + v_);\n\n        // amountA to payback, this amount will get swapped into tokenB to payback in perfect proportion\n        tokenAmt_ = c_ - x_;\n\n        // Ensure the amount to swap and payback is within reasonable bounds:\n        // - Not greater than 99.9999% of the current debt (c_)\n        // This prevents extreme scenarios where almost all debt is getting paid after swap,\n        // which could maybe lead to precision issues & edge cases\n        if ((tokenAmt_ > (c_ * (SIX_DECIMALS - 1)) / SIX_DECIMALS))\n            revert FluidDexError(ErrorTypes.DexT1__SwapAndPaybackTooLowOrTooHigh);\n    }\n\n    /// @param c_ tokenA debt before swap & payback\n    /// @param d_ tokenB debt before swap & payback\n    /// @param e_ tokenA imaginary reserves before swap & payback\n    /// @param f_ tokenB imaginary reserves before swap & payback\n    /// @param g_ tokenA perfect amount to payback\n    function _getSwapAndPayback(uint c_, uint d_, uint e_, uint f_, uint g_) internal pure returns (uint shares_) {\n        // 1. tokenAxa / newTokenADebt = tokenBxb / newTokenBDebt (borrowing in equal proportion)\n        // 2. newTokenADebt = tokenADebt - tokenAxb\n        // 3. newTokenBDebt = tokenBDebt + tokenBxb\n        // 4. imaginaryTokenAReserves = Calculated above from debtA\n        // 5. imaginaryTokenBReserves = Calculated above from debtA\n        // // Note: I assumed reserveA and debtA for same tokenA\n        // // But in other places I used debtA to find reserveB\n        // 6. tokenBxb = (imaginaryTokenBReserves * tokenAxb) / (imaginaryTokenAReserves + tokenAxb)\n        // 7. tokenAxa + tokenAxb = tokenAx\n\n        // Unknowns in the above equations are:\n        // tokenAxa, tokenAxb, tokenBxb\n\n        // simplifying knowns in 1 letter to make things clear:\n        // c = tokenADebt\n        // d = tokenBDebt\n        // e = imaginaryTokenAReserves\n        // f = imaginaryTokenBReserves\n        // g = tokenAx\n\n        // Restructuring 1:\n        // 1. newTokenBDebt = (tokenBxb * newTokenADebt) / tokenAxa\n\n        // Inserting 1 in 3:\n        // 8. (tokenBxb * newTokenADebt) / tokenAxa = tokenBDebt + tokenBxb\n\n        // Refactoring 8 w.r.t tokenBxb:\n        // 8. (tokenBxb * newTokenADebt) - tokenAxa * tokenBxb = tokenBDebt * tokenAxa\n        // 8. tokenBxb * (newTokenADebt - tokenAxa) = tokenBDebt * tokenAxa\n        // 8. tokenBxb = (tokenBDebt * tokenAxa) / (newTokenADebt - tokenAxa)\n\n        // Inserting 2 in 8:\n        // 9. tokenBxb = (tokenBDebt * tokenAxa) / (tokenADebt - tokenAxb - tokenAxa)\n        // 9. tokenBxb = (tokenBDebt * tokenAxa) / (tokenADebt - tokenAx)\n\n        // Inserting 9 in 6:\n        // 10. (tokenBDebt * tokenAxa) / (tokenADebt - tokenAx) = (imaginaryTokenBReserves * tokenAxb) / (imaginaryTokenAReserves + tokenAxb)\n        // 10. (tokenBDebt * (tokenAx - tokenAxb)) / (tokenADebt - tokenAx) = (imaginaryTokenBReserves * tokenAxb) / (imaginaryTokenAReserves + tokenAxb)\n\n        // Replacing with single digits:\n        // 10. (d * (g - tokenAxb)) / (c - g) = (f * tokenAxb) / (e + tokenAxb)\n        // 10. d * (g - tokenAxb) * (e + tokenAxb) = (f * tokenAxb) * (c - g)\n        // 10. deg + dg*tokenAxb - de*tokenAxb - d*tokenAxb^2 = cf*tokenAxb - fg*tokenAxb\n        // 10. d*tokenAxb^2 + cf*tokenAxb - fg*tokenAxb + de*tokenAxb - dg*tokenAxb - deg = 0\n        // 10. d*tokenAxb^2 + (cf - fg + de - dg)*tokenAxb - deg = 0\n\n        // A = d\n        // B = (cf + de - fg - dg)\n        // C = -deg\n\n        // Solving Quadratic will give the value for tokenAxb, now that \"tokenAxb\" is known we can also know:\n        // tokenAxa & tokenBxb\n\n        // temp_ => B/A\n        uint temp_ = (c_ * f_ + d_ * e_ - f_ * g_ - d_ * g_) / d_;\n\n        // temp2_ = -AC / A^2\n        uint temp2_ = 4 * e_ * g_;\n\n        uint amtToSwap_ = (FixedPointMathLib.sqrt((temp2_ + (temp_ * temp_))) - temp_) / 2;\n\n        // Ensure the amount to swap is within reasonable bounds:\n        // - Not greater than 99.9999% of the input amount (g_)\n        // - Not less than 0.0001% of the input amount (g_)\n        // This prevents extreme scenarios and maybe potential precision issues\n        if ((amtToSwap_ > (g_ * (SIX_DECIMALS - 1)) / SIX_DECIMALS) || (amtToSwap_ < (g_ / SIX_DECIMALS)))\n            revert FluidDexError(ErrorTypes.DexT1__SwapAndPaybackTooLowOrTooHigh);\n\n        // temp_ => amt0ToPayback\n        temp_ = g_ - amtToSwap_;\n        // (imaginaryTokenBReserves * amtToSwap_) / (imaginaryTokenAReserves + amtToSwap_)\n        // temp2_ => amt1ToPayback\n        temp2_ = (f_ * amtToSwap_) / (e_ + amtToSwap_);\n\n        // temp_ => shares0\n        temp_ = (temp_ * 1e18) / (c_ - amtToSwap_);\n        // temp_ => shares1\n        temp2_ = (temp2_ * 1e18) / (d_ + temp2_);\n        // temp_ & temp2 should be same. Although, due to some possible precision loss taking the lower one\n        shares_ = temp_ > temp2_ ? temp2_ : temp_;\n    }\n\n    /// @dev This function performs arbitrage between the collateral and debt pools\n    /// @param dexVariables_ The current state of dex variables\n    /// @param dexVariables2_ Additional dex variables\n    /// @param pex_ Struct containing prices and exchange rates\n    /// @notice This function is called after user operations to balance the pools\n    /// @notice It swaps tokens between the collateral and debt pools to align their prices\n    /// @notice The function updates the oracle price based on the arbitrage results\n    function _arbitrage(uint dexVariables_, uint dexVariables2_, PricesAndExchangePrice memory pex_) internal {\n        if ((dexVariables2_ >> 255) == 1) revert FluidDexError(ErrorTypes.DexT1__SwapAndArbitragePaused);\n\n        CollateralReserves memory c_;\n        DebtReserves memory d_;\n        uint price_;\n        if ((dexVariables2_ & 1) == 1) {\n            c_ = _getCollateralReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.supplyToken0ExchangePrice,\n                pex_.supplyToken1ExchangePrice\n            );\n        }\n        if ((dexVariables2_ & 2) == 2) {\n            d_ = _getDebtReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.borrowToken0ExchangePrice,\n                pex_.borrowToken1ExchangePrice\n            );\n        }\n        if ((dexVariables2_ & 3) < 3) {\n            price_ = ((dexVariables2_ & 1) == 1)\n                ? ((c_.token1ImaginaryReserves) * 1e27) / (c_.token0ImaginaryReserves)\n                : ((d_.token1ImaginaryReserves) * 1e27) / (d_.token0ImaginaryReserves);\n            // arbitrage should only happen if both smart debt & smart collateral are enabled\n            // Storing in storage, it will also uninitialize re-entrancy\n            dexVariables = _updateOracle(price_, pex_.centerPrice, dexVariables_);\n            return;\n        }\n\n        uint temp_;\n        uint amtOut_;\n        uint amtIn_;\n\n        // both smart debt & smart collateral enabled\n\n        // always swapping token0 into token1\n        int a_ = _swapRoutingIn(\n            0,\n            c_.token1ImaginaryReserves,\n            c_.token0ImaginaryReserves,\n            d_.token1ImaginaryReserves,\n            d_.token0ImaginaryReserves\n        );\n        if (a_ > 0) {\n            // swap will route through col pool\n            temp_ = uint(a_);\n            amtOut_ = _getAmountOut(temp_, c_.token0ImaginaryReserves, c_.token1ImaginaryReserves);\n            amtIn_ = _getAmountIn(temp_, d_.token1ImaginaryReserves, d_.token0ImaginaryReserves);\n\n            // new pool price\n            // debt pool price will be the same as collateral pool after the swap\n            // note: updating price here as in next line amtOut_ will get updated to normal amounts\n            price_ = ((c_.token1ImaginaryReserves - amtOut_) * 1e27) / (c_.token0ImaginaryReserves + temp_);\n\n            // converting into normal token form from DEX precisions\n            a_ = (((a_) * int(TOKEN_0_DENOMINATOR_PRECISION)) / int(TOKEN_0_NUMERATOR_PRECISION));\n            amtOut_ = (((amtOut_) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n            amtIn_ = (((amtIn_) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n\n            // deposit token0 and borrow token0\n            // withdraw token1 and payback token1\n            LIQUIDITY.operate(TOKEN_0, a_, a_, address(0), address(this), abi.encode(SKIP_TRANSFERS, address(this)));\n            LIQUIDITY.operate(\n                TOKEN_1,\n                -int(amtOut_),\n                -int(amtIn_),\n                address(this),\n                address(0),\n                abi.encode(SKIP_TRANSFERS, address(this))\n            );\n        } else if (a_ < 0) {\n            // swap will route through debt pool\n            temp_ = uint(-a_);\n            amtOut_ = _getAmountOut(temp_, d_.token0ImaginaryReserves, d_.token1ImaginaryReserves);\n            amtIn_ = _getAmountIn(temp_, c_.token1ImaginaryReserves, c_.token0ImaginaryReserves);\n\n            // new pool price\n            // debt pool price will be the same as collateral pool after the swap\n            // note: updating price here as in next line amtOut_ will get updated to normal amounts\n            price_ = ((d_.token1ImaginaryReserves - amtOut_) * 1e27) / (d_.token0ImaginaryReserves + temp_);\n\n            // converting into normal token form from DEX precisions\n            a_ = ((a_ * int(TOKEN_0_DENOMINATOR_PRECISION)) / int(TOKEN_0_NUMERATOR_PRECISION));\n            amtOut_ = ((amtOut_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n            amtIn_ = (((amtIn_) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n\n            // payback token0 and withdraw token0\n            // deposit token1 and borrow token1\n            LIQUIDITY.operate(TOKEN_0, a_, a_, address(this), address(0), abi.encode(SKIP_TRANSFERS, address(this)));\n            LIQUIDITY.operate(\n                TOKEN_1,\n                int(amtIn_),\n                int(amtOut_),\n                address(0),\n                address(this),\n                abi.encode(SKIP_TRANSFERS, address(this))\n            );\n        } else {\n            // reverting if nothing to arbitrage. Naturally to get here will have very low probability\n            revert FluidDexError(ErrorTypes.DexT1__NothingToArbitrage);\n        }\n\n        // if hook exists then calling hook\n        temp_ = (dexVariables2_ >> 142) & X30;\n        if (temp_ > 0) {\n            uint lastPrice_ = (dexVariables_ >> 41) & X40;\n            lastPrice_ = (lastPrice_ >> DEFAULT_EXPONENT_SIZE) << (lastPrice_ & DEFAULT_EXPONENT_MASK);\n            _hookVerify(temp_, 2, lastPrice_ > price_, price_);\n        }\n\n        // Storing in storage, it will also uninitialize re-entrancy\n        dexVariables = _updateOracle(price_, pex_.centerPrice, dexVariables_);\n\n        emit LogArbitrage(a_, amtOut_);\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/helpers/userHelpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport { CoreHelpers } from \"./coreHelpers.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { LiquidityCalcs } from \"../../../../../libraries/liquidityCalcs.sol\";\n\nabstract contract UserHelpers is CoreHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) CoreHelpers(constantViews_) {}\n\n    function _verifyMint(uint amt_, uint totalAmt_) internal pure {\n        // not minting too less shares or too more\n        // If totalAmt_ is worth $1 then user can at max mint $1B of new amt_ at once.\n        // If totalAmt_ is worth $1B then user have to mint min of $1 of amt_.\n        if (amt_ < (totalAmt_ / NINE_DECIMALS) || amt_ > (totalAmt_ * NINE_DECIMALS)) {\n            revert FluidDexError(ErrorTypes.DexT1__MintAmtOverflow);\n        }\n    }\n\n    function _verifyRedeem(uint amt_, uint totalAmt_) internal pure {\n        // If burning of amt_ is > 99.99% of totalAmt_ or if amt_ is less than totalAmt_ / 1e9 then revert.\n        if (amt_ > ((totalAmt_ * 9999) / FOUR_DECIMALS) || (amt_ < (totalAmt_ / NINE_DECIMALS))) {\n            revert FluidDexError(ErrorTypes.DexT1__BurnAmtOverflow);\n        }\n    }\n\n    function _getExchangePrices() internal view returns (ExchangePrices memory ex_) {\n        // Exchange price will remain same as Liquidity Layer\n        (ex_.supplyToken0ExchangePrice, ex_.borrowToken0ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_0_SLOT)\n        );\n\n        (ex_.supplyToken1ExchangePrice, ex_.borrowToken1ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_1_SLOT)\n        );\n    }\n\n    function _updatingUserSupplyDataOnStorage(\n        uint userSupplyData_,\n        uint userSupply_,\n        uint newWithdrawalLimit_\n    ) internal {\n        // calculate withdrawal limit to store as previous withdrawal limit in storage\n        newWithdrawalLimit_ = DexCalcs.calcWithdrawalLimitAfterOperate(\n            userSupplyData_,\n            userSupply_,\n            newWithdrawalLimit_\n        );\n\n        userSupply_ = userSupply_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_DOWN\n        );\n\n        newWithdrawalLimit_ = newWithdrawalLimit_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_DOWN\n        );\n\n        if (((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64) == userSupply_) {\n            // make sure that shares amount is not so small that it wouldn't affect storage update. if a difference\n            // is present then rounding will be in the right direction to avoid any potential manipulation.\n            revert FluidDexError(ErrorTypes.DexT1__SharesAmountInsufficient);\n        }\n\n        // Updating on storage, copied exactly the same from Liquidity Layer\n        _userSupplyData[msg.sender] =\n            // mask to update bits 1-161 (supply amount, withdrawal limit, timestamp)\n            (userSupplyData_ & 0xfffffffffffffffffffffffc0000000000000000000000000000000000000001) |\n            (userSupply_ << DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) | // converted to BigNumber can not overflow\n            (newWithdrawalLimit_ << DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) | // converted to BigNumber can not overflow\n            (block.timestamp << DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP);\n    }\n\n    function _updatingUserBorrowDataOnStorage(uint userBorrowData_, uint userBorrow_, uint newBorrowLimit_) internal {\n        // calculate borrow limit to store as previous borrow limit in storage\n        newBorrowLimit_ = DexCalcs.calcBorrowLimitAfterOperate(userBorrowData_, userBorrow_, newBorrowLimit_);\n\n        // Converting user's borrowings into bignumber\n        userBorrow_ = userBorrow_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_UP\n        );\n\n        // Converting borrow limit into bignumber\n        newBorrowLimit_ = newBorrowLimit_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_DOWN\n        );\n\n        if (((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64) == userBorrow_) {\n            // make sure that shares amount is not so small that it wouldn't affect storage update. if a difference\n            // is present then rounding will be in the right direction to avoid any potential manipulation.\n            revert FluidDexError(ErrorTypes.DexT1__SharesAmountInsufficient);\n        }\n\n        // Updating on storage, copied exactly the same from Liquidity Layer\n        _userBorrowData[msg.sender] =\n            // mask to update bits 1-161 (borrow amount, borrow limit, timestamp)\n            (userBorrowData_ & 0xfffffffffffffffffffffffc0000000000000000000000000000000000000001) |\n            (userBorrow_ << DexSlotsLink.BITS_USER_BORROW_AMOUNT) | // converted to BigNumber can not overflow\n            (newBorrowLimit_ << DexSlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) | // converted to BigNumber can not overflow\n            (block.timestamp << DexSlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP);\n    }\n\n    /// @notice Deposits or pays back in liquidity\n    /// @param token_ The token to deposit or pay back\n    /// @param depositAmt_ The amount to deposit\n    /// @param paybackAmt_ The amount to pay back\n    function _depositOrPaybackInLiquidity(address token_, uint depositAmt_, uint paybackAmt_) internal {\n        // both cannot be greater than 0\n        // if both are 0 then liquidity layer will revert\n        // only 1 should be greater than 0\n        if (depositAmt_ > 0 && paybackAmt_ > 0) revert();\n        if (token_ == NATIVE_TOKEN) {\n            uint amt_ = depositAmt_ > 0 ? depositAmt_ : paybackAmt_;\n            if (msg.value > amt_) {\n                SafeTransfer.safeTransferNative(msg.sender, msg.value - amt_);\n            } else if (msg.value < amt_) {\n                revert FluidDexError(ErrorTypes.DexT1__MsgValueLowOnDepositOrPayback);\n            }\n            LIQUIDITY.operate{ value: amt_ }(\n                token_,\n                int(depositAmt_),\n                -int(paybackAmt_),\n                address(0),\n                address(0),\n                new bytes(0)\n            );\n        } else {\n            LIQUIDITY.operate(\n                token_,\n                int(depositAmt_),\n                -int(paybackAmt_),\n                address(0),\n                address(0),\n                abi.encode((depositAmt_ + paybackAmt_), true, msg.sender)\n            );\n        }\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/immutableVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../../../liquidity/interfaces/iLiquidity.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { ConstantVariables } from \"../common/constantVariables.sol\";\nimport { IFluidDexFactory } from \"../../interfaces/iDexFactory.sol\";\nimport { Error } from \"../../error.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\n\nabstract contract ImmutableVariables is ConstantVariables, Structs, Error {\n    /*//////////////////////////////////////////////////////////////\n                          CONSTANTS / IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public immutable DEX_ID;\n\n    /// @dev Address of token 0\n    address internal immutable TOKEN_0;\n\n    /// @dev Address of token 1\n    address internal immutable TOKEN_1;\n\n    address internal immutable THIS_CONTRACT;\n\n    uint256 internal immutable TOKEN_0_NUMERATOR_PRECISION;\n    uint256 internal immutable TOKEN_0_DENOMINATOR_PRECISION;\n    uint256 internal immutable TOKEN_1_NUMERATOR_PRECISION;\n    uint256 internal immutable TOKEN_1_DENOMINATOR_PRECISION;\n\n    /// @dev Address of liquidity contract\n    IFluidLiquidity internal immutable LIQUIDITY;\n\n    /// @dev Address of DEX factory contract\n    IFluidDexFactory internal immutable DEX_FACTORY;\n\n    /// @dev Address of Shift implementation\n    address internal immutable SHIFT_IMPLEMENTATION;\n\n    /// @dev Address of Admin implementation\n    address internal immutable ADMIN_IMPLEMENTATION;\n\n    /// @dev Address of Col Operations implementation\n    address internal immutable COL_OPERATIONS_IMPLEMENTATION;\n\n    /// @dev Address of Debt Operations implementation\n    address internal immutable DEBT_OPERATIONS_IMPLEMENTATION;\n\n    /// @dev Address of Perfect Operations and Swap Out implementation\n    address internal immutable PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION;\n\n    /// @dev Address of contract used for deploying center price & hook related contract\n    address internal immutable DEPLOYER_CONTRACT;\n\n    /// @dev Liquidity layer slots\n    bytes32 internal immutable SUPPLY_TOKEN_0_SLOT;\n    bytes32 internal immutable BORROW_TOKEN_0_SLOT;\n    bytes32 internal immutable SUPPLY_TOKEN_1_SLOT;\n    bytes32 internal immutable BORROW_TOKEN_1_SLOT;\n    bytes32 internal immutable EXCHANGE_PRICE_TOKEN_0_SLOT;\n    bytes32 internal immutable EXCHANGE_PRICE_TOKEN_1_SLOT;\n    uint256 internal immutable TOTAL_ORACLE_MAPPING;\n\n    function _calcNumeratorAndDenominator(\n        address token_\n    ) private view returns (uint256 numerator_, uint256 denominator_) {\n        uint256 decimals_ = _decimals(token_);\n        if (decimals_ > TOKENS_DECIMALS_PRECISION) {\n            numerator_ = 1;\n            denominator_ = 10 ** (decimals_ - TOKENS_DECIMALS_PRECISION);\n        } else {\n            numerator_ = 10 ** (TOKENS_DECIMALS_PRECISION - decimals_);\n            denominator_ = 1;\n        }\n    }\n\n    constructor(ConstantViews memory constants_) {\n        THIS_CONTRACT = address(this);\n\n        DEX_ID = constants_.dexId;\n        LIQUIDITY = IFluidLiquidity(constants_.liquidity);\n        DEX_FACTORY = IFluidDexFactory(constants_.factory);\n\n        TOKEN_0 = constants_.token0;\n        TOKEN_1 = constants_.token1;\n\n        if (TOKEN_0 >= TOKEN_1) revert FluidDexError(ErrorTypes.DexT1__Token0ShouldBeSmallerThanToken1);\n\n        (TOKEN_0_NUMERATOR_PRECISION, TOKEN_0_DENOMINATOR_PRECISION) = _calcNumeratorAndDenominator(TOKEN_0);\n        (TOKEN_1_NUMERATOR_PRECISION, TOKEN_1_DENOMINATOR_PRECISION) = _calcNumeratorAndDenominator(TOKEN_1);\n\n        if (constants_.implementations.shift != address(0)) {\n            SHIFT_IMPLEMENTATION = constants_.implementations.shift;\n        } else {\n            SHIFT_IMPLEMENTATION = address(this);\n        }\n        if (constants_.implementations.admin != address(0)) {\n            ADMIN_IMPLEMENTATION = constants_.implementations.admin;\n        } else {\n            ADMIN_IMPLEMENTATION = address(this);\n        }\n        if (constants_.implementations.colOperations != address(0)) {\n            COL_OPERATIONS_IMPLEMENTATION = constants_.implementations.colOperations;\n        } else {\n            COL_OPERATIONS_IMPLEMENTATION = address(this);\n        }\n        if (constants_.implementations.debtOperations != address(0)) {\n            DEBT_OPERATIONS_IMPLEMENTATION = constants_.implementations.debtOperations;\n        } else {\n            DEBT_OPERATIONS_IMPLEMENTATION = address(this);\n        }\n        if (constants_.implementations.perfectOperationsAndSwapOut != address(0)) {\n            PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION = constants_.implementations.perfectOperationsAndSwapOut;\n        } else {\n            PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION = address(this);\n        }\n\n        DEPLOYER_CONTRACT = constants_.deployerContract;\n\n        SUPPLY_TOKEN_0_SLOT = constants_.supplyToken0Slot;\n        BORROW_TOKEN_0_SLOT = constants_.borrowToken0Slot;\n        SUPPLY_TOKEN_1_SLOT = constants_.supplyToken1Slot;\n        BORROW_TOKEN_1_SLOT = constants_.borrowToken1Slot;\n        EXCHANGE_PRICE_TOKEN_0_SLOT = constants_.exchangePriceToken0Slot;\n        EXCHANGE_PRICE_TOKEN_1_SLOT = constants_.exchangePriceToken1Slot;\n\n        if (constants_.oracleMapping > X16) revert FluidDexError(ErrorTypes.DexT1__OracleMappingOverflow);\n\n        TOTAL_ORACLE_MAPPING = constants_.oracleMapping;\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/interfaces.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ninterface IHook {\n    /// @notice Hook function to check for liquidation opportunities before external swaps\n    /// @dev The primary use of this hook is to check if a particular pair vault has liquidation available.\n    ///      If liquidation is available, it gives priority to the liquidation process before allowing external swaps.\n    ///      In most cases, this hook will not be set.\n    /// @param id_ Identifier for the operation type: 1 for swap, 2 for internal arbitrage\n    /// @param swap0to1_ Direction of the swap: true if swapping token0 for token1, false otherwise\n    /// @param token0_ Address of the first token in the pair\n    /// @param token1_ Address of the second token in the pair\n    /// @param price_ The price ratio of token1 to token0, expressed with 27 decimal places\n    /// @return isOk_ Boolean indicating whether the operation should proceed\n    function dexPrice(\n        uint id_,\n        bool swap0to1_,\n        address token0_,\n        address token1_,\n        uint price_\n    ) external returns (bool isOk_);\n}\n\ninterface ICenterPrice {\n    /// @notice Retrieves the center price for the pool\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\n    /// @return price The current price ratio of token1 to token0, expressed with 27 decimal places\n    function centerPrice() external returns (uint price);\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct ExchangePrices {\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct CollateralReservesSwap {\n        uint tokenInRealReserves;\n        uint tokenOutRealReserves;\n        uint tokenInImaginaryReserves;\n        uint tokenOutImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReservesSwap {\n        uint tokenInDebt;\n        uint tokenOutDebt;\n        uint tokenInRealReserves;\n        uint tokenOutRealReserves;\n        uint tokenInImaginaryReserves;\n        uint tokenOutImaginaryReserves;\n    }\n\n    struct SwapInMemory {\n        address tokenIn;\n        address tokenOut;\n        uint256 amtInAdjusted;\n        address withdrawTo;\n        address borrowTo;\n        uint price; // price of pool after swap\n        uint fee; // fee of pool\n        uint revenueCut; // revenue cut of pool\n        bool swap0to1;\n        int swapRoutingAmt;\n        bytes data; // just added to avoid stack-too-deep error\n    }\n\n    struct SwapOutMemory {\n        address tokenIn;\n        address tokenOut;\n        uint256 amtOutAdjusted;\n        address withdrawTo;\n        address borrowTo;\n        uint price; // price of pool after swap\n        uint fee;\n        uint revenueCut; // revenue cut of pool\n        bool swap0to1;\n        int swapRoutingAmt;\n        bytes data; // just added to avoid stack-too-deep error\n        uint msgValue;\n    }\n\n    struct DepositColMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0ReservesInitial;\n        uint256 token1ReservesInitial;\n    }\n\n    struct WithdrawColMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0ReservesInitial;\n        uint256 token1ReservesInitial;\n        address to;\n    }\n\n    struct BorrowDebtMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0DebtInitial;\n        uint256 token1DebtInitial;\n        address to;\n    }\n\n    struct PaybackDebtMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0DebtInitial;\n        uint256 token1DebtInitial;\n    }\n\n    struct OraclePriceMemory {\n        uint lowestPrice1by0;\n        uint highestPrice1by0;\n        uint oracleSlot;\n        uint oracleMap;\n        uint oracle;\n    }\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndSwapOut;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n}\n"
    },
    "contracts/protocols/lending/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Error {\n    error FluidLendingError(uint256 errorId_);\n}\n"
    },
    "contracts/protocols/lending/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |               fToken              | \n    |__________________________________*/\n\n    /// @notice thrown when a deposit amount is too small to increase BigMath stored balance in Liquidity.\n    /// precision of BigMath is 1e12, so if token holds 120_000_000_000 USDC, min amount to make a difference would be 0.1 USDC.\n    /// i.e. user would send a very small deposit which mints no shares -> revert\n    uint256 internal constant fToken__DepositInsignificant = 20001;\n\n    /// @notice thrown when minimum output amount is not reached, e.g. for minimum shares minted (deposit) or\n    ///         minimum assets received (redeem)\n    uint256 internal constant fToken__MinAmountOut = 20002;\n\n    /// @notice thrown when maximum amount is surpassed, e.g. for maximum shares burned (withdraw) or\n    ///         maximum assets input (mint)\n    uint256 internal constant fToken__MaxAmount = 20003;\n\n    /// @notice thrown when invalid params are sent to a method, e.g. zero address\n    uint256 internal constant fToken__InvalidParams = 20004;\n\n    /// @notice thrown when an unauthorized caller is trying to execute an auth-protected method\n    uint256 internal constant fToken__Unauthorized = 20005;\n\n    /// @notice thrown when a with permit / signature method is called from msg.sender that is the owner.\n    /// Should call the method without permit instead if msg.sender is the owner.\n    uint256 internal constant fToken__PermitFromOwnerCall = 20006;\n\n    /// @notice thrown when a reentrancy is detected.\n    uint256 internal constant fToken__Reentrancy = 20007;\n\n    /// @notice thrown when _tokenExchangePrice overflows type(uint64).max\n    uint256 internal constant fToken__ExchangePriceOverflow = 20008;\n\n    /// @notice thrown when msg.sender is not rebalancer\n    uint256 internal constant fToken__NotRebalancer = 20009;\n\n    /// @notice thrown when rebalance is called with msg.value > 0 for non NativeUnderlying fToken\n    uint256 internal constant fToken__NotNativeUnderlying = 20010;\n\n    /// @notice thrown when the received new liquidity exchange price is of unexpected value (< than the old one)\n    uint256 internal constant fToken__LiquidityExchangePriceUnexpected = 20011;\n\n    /***********************************|\n    |     fToken Native Underlying      | \n    |__________________________________*/\n\n    /// @notice thrown when native deposit is called but sent along `msg.value` does not cover the deposit amount\n    uint256 internal constant fTokenNativeUnderlying__TransferInsufficient = 21001;\n\n    /// @notice thrown when a liquidity callback is called for a native token operation\n    uint256 internal constant fTokenNativeUnderlying__UnexpectedLiquidityCallback = 21002;\n\n    /***********************************|\n    |         Lending Factory         | \n    |__________________________________*/\n\n    /// @notice thrown when a method is called with invalid params\n    uint256 internal constant LendingFactory__InvalidParams = 22001;\n\n    /// @notice thrown when the provided input param address is zero\n    uint256 internal constant LendingFactory__ZeroAddress = 22002;\n\n    /// @notice thrown when the token already exists\n    uint256 internal constant LendingFactory__TokenExists = 22003;\n\n    /// @notice thrown when the fToken has not yet been configured at Liquidity\n    uint256 internal constant LendingFactory__LiquidityNotConfigured = 22004;\n\n    /// @notice thrown when an unauthorized caller is trying to execute an auth-protected method\n    uint256 internal constant LendingFactory__Unauthorized = 22005;\n\n    /***********************************|\n    |   Lending Rewards Rate Model      | \n    |__________________________________*/\n\n    /// @notice thrown when invalid params are given as input\n    uint256 internal constant LendingRewardsRateModel__InvalidParams = 23001;\n\n    /// @notice thrown when calculated rewards rate is exceeding the maximum rate\n    uint256 internal constant LendingRewardsRateModel__MaxRate = 23002;\n\n    /// @notice thrown when start is called by any other address other than initiator\n    uint256 internal constant LendingRewardsRateModel__NotTheInitiator = 23003;\n\n    /// @notice thrown when start is called after the rewards are already started\n    uint256 internal constant LendingRewardsRateModel__AlreadyStarted = 23004;\n\n    /// @notice thrown when the provided input param address is zero\n    uint256 internal constant LendingRewardsRateModel__ZeroAddress = 23005;\n}\n"
    },
    "contracts/protocols/lending/fToken/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLendingRewardsRateModel  } from \"../interfaces/iLendingRewardsRateModel.sol\";\n\nabstract contract Events {\n    /// @notice emitted whenever admin updates rewards rate model\n    event LogUpdateRewards(IFluidLendingRewardsRateModel  indexed rewardsRateModel);\n\n    /// @notice emitted whenever rebalance is executed to fund difference between Liquidity deposit and totalAssets()\n    ///         as rewards through the rebalancer.\n    event LogRebalance(uint256 assets);\n\n    /// @notice emitted whenever exchange rates are updated\n    event LogUpdateRates(uint256 tokenExchangePrice, uint256 liquidityExchangePrice);\n\n    /// @notice emitted whenever funds for a certain `token` are rescued to Liquidity\n    event LogRescueFunds(address indexed token);\n\n    /// @notice emitted whenever rebalancer address is updated\n    event LogUpdateRebalancer(address indexed rebalancer);\n}\n"
    },
    "contracts/protocols/lending/fToken/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ERC20, IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { IAllowanceTransfer } from \"../interfaces/permit2/iAllowanceTransfer.sol\";\nimport { IFluidLendingRewardsRateModel } from \"../interfaces/iLendingRewardsRateModel.sol\";\nimport { IFluidLendingFactory } from \"../interfaces/iLendingFactory.sol\";\nimport { IFToken, IFTokenAdmin } from \"../interfaces/iFToken.sol\";\nimport { LiquidityCalcs } from \"../../../libraries/liquidityCalcs.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\nimport { LiquiditySlotsLink } from \"../../../libraries/liquiditySlotsLink.sol\";\nimport { SafeTransfer } from \"../../../libraries/safeTransfer.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\nimport { Variables } from \"./variables.sol\";\nimport { Events } from \"./events.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\n\n/// @dev ReentrancyGuard based on OpenZeppelin implementation.\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.8/contracts/security/ReentrancyGuard.sol\nabstract contract ReentrancyGuard is Error, Variables {\n    uint8 internal constant REENTRANCY_NOT_ENTERED = 1;\n    uint8 internal constant REENTRANCY_ENTERED = 2;\n\n    constructor() {\n        _status = REENTRANCY_NOT_ENTERED;\n    }\n\n    /// @dev checks that no reentrancy occurs, reverts if so. Calling the method in the modifier reduces\n    /// bytecode size as modifiers are inlined into bytecode\n    function _checkReentrancy() internal {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status != REENTRANCY_NOT_ENTERED) {\n            revert FluidLendingError(ErrorTypes.fToken__Reentrancy);\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = REENTRANCY_ENTERED;\n    }\n\n    /// @dev Prevents a contract from calling itself, directly or indirectly.\n    /// See OpenZeppelin implementation for more info\n    modifier nonReentrant() {\n        _checkReentrancy();\n\n        _;\n\n        // storing original value triggers a refund (see https://eips.ethereum.org/EIPS/eip-2200)\n        _status = REENTRANCY_NOT_ENTERED;\n    }\n}\n\n/// @dev internal methods for fToken contracts\nabstract contract fTokenCore is Error, IERC4626, IFToken, Variables, Events, ReentrancyGuard {\n    using FixedPointMathLib for uint256;\n\n    /// @dev Gets current (updated) Liquidity supply exchange price for the underyling asset\n    function _getLiquidityExchangePrice() internal view returns (uint256 supplyExchangePrice_) {\n        (supplyExchangePrice_, ) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(LIQUIDITY_EXCHANGE_PRICES_SLOT)\n        );\n    }\n\n    /// @dev Gets current Liquidity supply balance of `address(this)` for the underyling asset\n    function _getLiquidityBalance() internal view returns (uint256 balance_) {\n        // extract user supply amount\n        uint256 userSupplyRaw_ = BigMathMinified.fromBigNumber(\n            (LIQUIDITY.readFromStorage(LIQUIDITY_USER_SUPPLY_SLOT) >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) &\n                LiquidityCalcs.X64,\n            LiquidityCalcs.DEFAULT_EXPONENT_SIZE,\n            LiquidityCalcs.DEFAULT_EXPONENT_MASK\n        );\n\n        unchecked {\n            // can not overflow as userSupplyRaw_ can be maximally type(int128).max, liquidity exchange price type(uint64).max\n            return (userSupplyRaw_ * _getLiquidityExchangePrice()) / EXCHANGE_PRICES_PRECISION;\n        }\n    }\n\n    /// @dev Gets current Liquidity underlying token balance\n    function _getLiquidityUnderlyingBalance() internal view virtual returns (uint256) {\n        return ASSET.balanceOf(address(LIQUIDITY));\n    }\n\n    /// @dev Gets current withdrawable amount at Liquidity `withdrawalLimit_` (withdrawal limit or balance).\n    function _getLiquidityWithdrawable() internal view returns (uint256 withdrawalLimit_) {\n        uint256 userSupplyData_ = LIQUIDITY.readFromStorage(LIQUIDITY_USER_SUPPLY_SLOT);\n        uint256 userSupply_ = BigMathMinified.fromBigNumber(\n            (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & LiquidityCalcs.X64,\n            LiquidityCalcs.DEFAULT_EXPONENT_SIZE,\n            LiquidityCalcs.DEFAULT_EXPONENT_MASK\n        );\n        withdrawalLimit_ = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\n\n        // convert raw amounts to normal amounts\n        unchecked {\n            // can not overflow as userSupply_ can be maximally type(int128).max\n            // and withdrawalLimit is smaller than userSupply_\n            uint256 liquidityExchangePrice_ = _getLiquidityExchangePrice();\n            withdrawalLimit_ = (withdrawalLimit_ * liquidityExchangePrice_) / EXCHANGE_PRICES_PRECISION;\n            userSupply_ = (userSupply_ * liquidityExchangePrice_) / EXCHANGE_PRICES_PRECISION;\n        }\n\n        withdrawalLimit_ = userSupply_ > withdrawalLimit_ ? userSupply_ - withdrawalLimit_ : 0;\n\n        uint256 balanceAtLiquidity_ = _getLiquidityUnderlyingBalance();\n\n        return balanceAtLiquidity_ > withdrawalLimit_ ? withdrawalLimit_ : balanceAtLiquidity_;\n    }\n\n    /// @dev Calculates new token exchange price based on the current liquidity exchange price `newLiquidityExchangePrice_` and rewards rate.\n    /// @param newLiquidityExchangePrice_ new (current) liquidity exchange price\n    function _calculateNewTokenExchangePrice(\n        uint256 newLiquidityExchangePrice_\n    ) internal view returns (uint256 newTokenExchangePrice_, bool rewardsEnded_) {\n        uint256 oldTokenExchangePrice_ = _tokenExchangePrice;\n        uint256 oldLiquidityExchangePrice_ = _liquidityExchangePrice;\n\n        if (newLiquidityExchangePrice_ < oldLiquidityExchangePrice_) {\n            // liquidity exchange price should only ever increase. If not, something went wrong and avoid\n            // proceeding with unknown outcome.\n            revert FluidLendingError(ErrorTypes.fToken__LiquidityExchangePriceUnexpected);\n        }\n\n        uint256 totalReturnInPercent_; // rewardsRateInPercent + liquidityReturnInPercent\n        if (_rewardsActive) {\n            {\n                // get rewards rate per year\n                // only trigger call to rewardsRateModel if rewards are actually active to save gas\n                uint256 rewardsRate_;\n                uint256 rewardsStartTime_;\n                (rewardsRate_, rewardsEnded_, rewardsStartTime_) = _rewardsRateModel.getRate(\n                    // use old tokenExchangeRate to calculate the total assets input for the rewards rate\n                    (oldTokenExchangePrice_ * totalSupply()) / EXCHANGE_PRICES_PRECISION\n                );\n\n                if (rewardsRate_ > MAX_REWARDS_RATE || rewardsEnded_) {\n                    // rewardsRate is capped, if it is bigger > MAX_REWARDS_RATE, then the rewardsRateModel\n                    // is configured wrongly (which should not be possible). Setting rewards to 0 in that case here.\n                    rewardsRate_ = 0;\n                }\n\n                uint256 lastUpdateTimestamp_ = _lastUpdateTimestamp;\n                if (lastUpdateTimestamp_ < rewardsStartTime_) {\n                    // if last update was before the rewards started, make sure rewards actually only accrue\n                    // from the actual rewards start time, not from the last update timestamp to avoid overpayment.\n                    lastUpdateTimestamp_ = rewardsStartTime_;\n\n                    // Note: overpayment for block.timestamp being > rewards end time does not happen because\n                    // rewardsRate_ is forced 0 then.\n                }\n\n                // calculate rewards return in percent: (rewards_rate * time passed) / seconds_in_a_year.\n                unchecked {\n                    // rewardsRate * timeElapsed / SECONDS_PER_YEAR.\n                    // no safe checks needed here because timeElapsed can not underflow,\n                    // rewardsRate is in 1e12 at max value being MAX_REWARDS_RATE = 25e12\n                    // max value would be 25e12 * 8589934591 / 31536000 (with buffers) = 6.8e15\n                    totalReturnInPercent_ =\n                        (rewardsRate_ * (block.timestamp - lastUpdateTimestamp_)) /\n                        SECONDS_PER_YEAR;\n                }\n            }\n        }\n\n        unchecked {\n            // calculate liquidityReturnInPercent: (newLiquidityExchangePrice_ - oldLiquidityExchangePrice_) / oldLiquidityExchangePrice_.\n            // and add it to totalReturnInPercent_ that already holds rewardsRateInPercent_.\n            // max value (in absolute extreme unrealistic case) would be: 6.8e15 + (((max uint64 - 1e12) * 1e12) / 1e12) = 1.845e19\n            // oldLiquidityExchangePrice_ can not be 0, minimal value is 1e12. subtraction can not underflow because new exchange price\n            // can only be >= oldLiquidityExchangePrice_.\n            totalReturnInPercent_ +=\n                ((newLiquidityExchangePrice_ - oldLiquidityExchangePrice_) * 1e14) /\n                oldLiquidityExchangePrice_;\n        }\n\n        // newTokenExchangePrice_ = oldTokenExchangePrice_ + oldTokenExchangePrice_ * totalReturnInPercent_\n        newTokenExchangePrice_ = oldTokenExchangePrice_ + ((oldTokenExchangePrice_ * totalReturnInPercent_) / 1e14); // divided by 100% (1e14)\n    }\n\n    /// @dev calculates new exchange prices, updates values in storage and returns new tokenExchangePrice (with reward rates)\n    function _updateRates(\n        uint256 liquidityExchangePrice_,\n        bool forceUpdateStorage_\n    ) internal returns (uint256 tokenExchangePrice_) {\n        bool rewardsEnded_;\n        (tokenExchangePrice_, rewardsEnded_) = _calculateNewTokenExchangePrice(liquidityExchangePrice_);\n        if (_rewardsActive || forceUpdateStorage_) {\n            // Solidity will NOT cause a revert if values are too big to fit max uint type size. Explicitly check before\n            // writing to storage. Also see https://github.com/ethereum/solidity/issues/10195.\n            if (tokenExchangePrice_ > type(uint64).max) {\n                revert FluidLendingError(ErrorTypes.fToken__ExchangePriceOverflow);\n            }\n\n            _tokenExchangePrice = uint64(tokenExchangePrice_);\n            _liquidityExchangePrice = uint64(liquidityExchangePrice_);\n            _lastUpdateTimestamp = uint40(block.timestamp);\n\n            emit LogUpdateRates(tokenExchangePrice_, liquidityExchangePrice_);\n        }\n\n        if (rewardsEnded_) {\n            // set rewardsActive flag to false to save gas for all future exchange prices calculations,\n            // without having to explicitly require setting `updateRewards` to address zero.\n            // Note that it would be fine that even the current tx does not update exchange prices in storage,\n            // because if rewardsEnded_ is true, rewardsRate_ must be 0, so the only yield is from LIQUIDITY.\n            // But to be extra safe, writing to storage in that one case too before setting _rewardsActive to false.\n            _rewardsActive = false;\n        }\n\n        return tokenExchangePrice_;\n    }\n\n    /// @dev splits a bytes signature `sig` into `v`, `r`, `s`.\n    /// Taken from https://docs.soliditylang.org/en/v0.8.17/solidity-by-example.html\n    function _splitSignature(bytes memory sig) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\n        require(sig.length == 65);\n\n        assembly {\n            // first 32 bytes, after the length prefix.\n            r := mload(add(sig, 32))\n            // second 32 bytes.\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes).\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        return (v, r, s);\n    }\n\n    /// @dev Deposit `assets_` amount of tokens to Liquidity\n    /// @param assets_ The amount of tokens to deposit\n    /// @param liquidityCallbackData_ callback data passed to Liquidity for `liquidityCallback`\n    /// @return exchangePrice_ liquidity exchange price for token\n    function _depositToLiquidity(\n        uint256 assets_,\n        bytes memory liquidityCallbackData_\n    ) internal virtual returns (uint256 exchangePrice_) {\n        // @dev Note: Although there might be some small difference between the `assets_` amount and the actual amount\n        // accredited at Liquidity due to BigMath rounding down, this amount is so small that it can be ignored.\n        // because of BigMath precision of 7.2057594e16 for a coefficient size of 56, it would require >72 trillion DAI\n        // to \"benefit\" 1 DAI in additional shares minted. Considering gas cost + APR per second, this ensures such\n        // a manipulation attempt becomes extremely unlikely.\n\n        // send funds to Liquidity protocol to generate yield\n        (exchangePrice_, ) = LIQUIDITY.operate(\n            address(ASSET),\n            SafeCast.toInt256(assets_),\n            0,\n            address(0),\n            address(0),\n            liquidityCallbackData_ // callback data. -> \"from\" for transferFrom in `liquidityCallback`\n        );\n    }\n\n    /// @dev Withdraw `assets_` amount of tokens from Liquidity directly to `receiver_`\n    /// @param assets_    The amount of tokens to withdraw\n    /// @param receiver_  the receiver address of withdraw amount\n    /// @return exchangePrice_   liquidity exchange price for token\n    function _withdrawFromLiquidity(\n        uint256 assets_,\n        address receiver_\n    ) internal virtual returns (uint256 exchangePrice_) {\n        // @dev See similar comment in `_depositToLiquidity()` regarding burning a tiny bit of additional shares here\n        // because of inaccuracies in Liquidity userSupply BigMath being rounded down.\n\n        // get funds back from Liquidity protocol to send to the user\n        (exchangePrice_, ) = LIQUIDITY.operate(\n            address(ASSET),\n            -SafeCast.toInt256(assets_),\n            0,\n            receiver_,\n            address(0),\n            new bytes(0) // callback data -> withdraw doesn't trigger a callback\n        );\n    }\n\n    /// @dev deposits `assets_` into liquidity and mints shares for `receiver_`. Returns amount of `sharesMinted_`.\n    function _executeDeposit(\n        uint256 assets_,\n        address receiver_,\n        bytes memory liquidityCallbackData_\n    ) internal virtual validAddress(receiver_) returns (uint256 sharesMinted_) {\n        // send funds to Liquidity protocol to generate yield -> returns updated liquidityExchangePrice\n        uint256 tokenExchangePrice_ = _depositToLiquidity(assets_, liquidityCallbackData_);\n\n        // update the exchange prices\n        tokenExchangePrice_ = _updateRates(tokenExchangePrice_, false);\n\n        // calculate the shares to mint\n        // not using previewDeposit here because we just got newTokenExchangePrice_\n        sharesMinted_ = (assets_ * EXCHANGE_PRICES_PRECISION) / tokenExchangePrice_;\n\n        if (sharesMinted_ == 0) {\n            revert FluidLendingError(ErrorTypes.fToken__DepositInsignificant);\n        }\n\n        _mint(receiver_, sharesMinted_);\n\n        emit Deposit(msg.sender, receiver_, assets_, sharesMinted_);\n    }\n\n    /// @dev withdraws `assets_` from liquidity to `receiver_` and burns shares from `owner_`.\n    /// Returns amount of `sharesBurned_`.\n    /// requires nonReentrant! modifier on calling method otherwise ERC777s could reenter!\n    function _executeWithdraw(\n        uint256 assets_,\n        address receiver_,\n        address owner_\n    ) internal virtual validAddress(receiver_) returns (uint256 sharesBurned_) {\n        // burn shares for assets_ amount: assets_ * EXCHANGE_PRICES_PRECISION / updatedTokenTexchangePrice. Rounded up.\n        // Note to be extra safe we do the shares burn before the withdrawFromLiquidity, even though that would return the\n        // updated liquidityExchangePrice and thus save gas.\n        sharesBurned_ = assets_.mulDivUp(EXCHANGE_PRICES_PRECISION, _updateRates(_getLiquidityExchangePrice(), false));\n\n        /*\n            The `mulDivUp` function is designed to round up the result of multiplication followed by division. \n            Given non-zero `assets_` and the rounding-up behavior of this function, `sharesBurned_` will always \n            be at least 1 if there's any remainder in the division.\n            Thus, if `assets_` is non-zero, `sharesBurned_` can never be 0. The nature of the function ensures \n            that even the smallest fractional result (greater than 0) will be rounded up to 1. Hence, there's no need \n            to check for a rounding error that results in 0.\n            Furthermore, if `assets_` was 0, an error 'UserModule__OperateAmountsZero' would already have been thrown \n            during the `operate` function, ensuring the contract never reaches this point with a zero `assets_` value.\n            Note: If ever the logic or the function behavior changes in the future, this assertion may need to be reconsidered.\n        */\n\n        _burn(owner_, sharesBurned_);\n\n        // withdraw from liquidity directly to _receiver.\n        _withdrawFromLiquidity(assets_, receiver_);\n\n        emit Withdraw(msg.sender, receiver_, owner_, assets_, sharesBurned_);\n    }\n}\n\n/// @notice fToken view methods. Implements view methods for ERC4626 compatibility\nabstract contract fTokenViews is fTokenCore {\n    using FixedPointMathLib for uint256;\n\n    /// @inheritdoc IFToken\n    function getData()\n        public\n        view\n        returns (\n            IFluidLiquidity liquidity_,\n            IFluidLendingFactory lendingFactory_,\n            IFluidLendingRewardsRateModel lendingRewardsRateModel_,\n            IAllowanceTransfer permit2_,\n            address rebalancer_,\n            bool rewardsActive_,\n            uint256 liquidityBalance_,\n            uint256 liquidityExchangePrice_,\n            uint256 tokenExchangePrice_\n        )\n    {\n        liquidityExchangePrice_ = _getLiquidityExchangePrice();\n\n        bool rewardsEnded_;\n        (tokenExchangePrice_, rewardsEnded_) = _calculateNewTokenExchangePrice(liquidityExchangePrice_);\n\n        return (\n            LIQUIDITY,\n            LENDING_FACTORY,\n            _rewardsRateModel,\n            PERMIT2,\n            _rebalancer,\n            _rewardsActive && !rewardsEnded_,\n            _getLiquidityBalance(),\n            liquidityExchangePrice_,\n            tokenExchangePrice_\n        );\n    }\n\n    /// @inheritdoc IERC4626\n    function asset() public view virtual override returns (address) {\n        return address(ASSET);\n    }\n\n    /// @inheritdoc IERC4626\n    function totalAssets() public view virtual override returns (uint256) {\n        (uint256 tokenExchangePrice_, ) = _calculateNewTokenExchangePrice(_getLiquidityExchangePrice());\n        return\n            // all the underlying tokens are stored in Liquidity contract at all times\n            (tokenExchangePrice_ * totalSupply()) / EXCHANGE_PRICES_PRECISION;\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 assets_) public view virtual override returns (uint256) {\n        (uint256 tokenExchangePrice_, ) = _calculateNewTokenExchangePrice(_getLiquidityExchangePrice());\n        return assets_.mulDivDown(EXCHANGE_PRICES_PRECISION, tokenExchangePrice_);\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 shares_) public view virtual override returns (uint256) {\n        (uint256 tokenExchangePrice_, ) = _calculateNewTokenExchangePrice(_getLiquidityExchangePrice());\n        return shares_.mulDivDown(tokenExchangePrice_, EXCHANGE_PRICES_PRECISION);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice returned amount might be slightly different from actual amount at execution.\n    function previewDeposit(uint256 assets_) public view virtual override returns (uint256) {\n        return convertToShares(assets_);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 shares_) public view virtual override returns (uint256) {\n        (uint256 tokenExchangePrice_, ) = _calculateNewTokenExchangePrice(_getLiquidityExchangePrice());\n        return shares_.mulDivUp(tokenExchangePrice_, EXCHANGE_PRICES_PRECISION);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 assets_) public view virtual override returns (uint256) {\n        (uint256 tokenExchangePrice_, ) = _calculateNewTokenExchangePrice(_getLiquidityExchangePrice());\n        return assets_.mulDivUp(EXCHANGE_PRICES_PRECISION, tokenExchangePrice_);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice returned amount might be slightly different from actual amount at execution.\n    function previewRedeem(uint256 shares_) public view virtual override returns (uint256) {\n        return convertToAssets(shares_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        // read total supplyInterest_ for the token at Liquidity and convert from BigMath\n        uint256 supplyInterest_ = LIQUIDITY.readFromStorage(LIQUIDITY_TOTAL_AMOUNTS_SLOT) & LiquidityCalcs.X64;\n        supplyInterest_ =\n            (supplyInterest_ >> LiquidityCalcs.DEFAULT_EXPONENT_SIZE) <<\n            (supplyInterest_ & LiquidityCalcs.DEFAULT_EXPONENT_MASK);\n\n        unchecked {\n            // normalize from raw\n            supplyInterest_ = (supplyInterest_ * _getLiquidityExchangePrice()) / EXCHANGE_PRICES_PRECISION;\n            // compare against hardcoded max possible value for total supply considering BigMath rounding down:\n            // type(int128).max) after BigMath rounding (first 56 bits precision, then 71 bits getting set to 0)\n            // so 1111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000\n            // = 170141183460469229370504062281061498880. using minus 1\n            if (supplyInterest_ > 170141183460469229370504062281061498879) {\n                return 0;\n            }\n            // type(int128).max is the maximum interactable amount at Liquidity. But also total token amounts\n            // must not overflow type(int128).max, so max depositable is type(int128).max - totalSupply.\n            return uint256(uint128(type(int128).max)) - supplyInterest_;\n        }\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address) public view virtual override returns (uint256) {\n        return convertToShares(maxDeposit(address(0)));\n    }\n\n    /// @inheritdoc IERC4626\n    function maxWithdraw(address owner_) public view virtual override returns (uint256) {\n        uint256 maxWithdrawableAtLiquidity_ = _getLiquidityWithdrawable();\n        uint256 ownerBalance_ = convertToAssets(balanceOf(owner_));\n        return maxWithdrawableAtLiquidity_ < ownerBalance_ ? maxWithdrawableAtLiquidity_ : ownerBalance_;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxRedeem(address owner_) public view virtual override returns (uint256) {\n        uint256 maxWithdrawableAtLiquidity_ = convertToShares(_getLiquidityWithdrawable());\n        uint256 ownerBalance_ = balanceOf(owner_);\n        return maxWithdrawableAtLiquidity_ < ownerBalance_ ? maxWithdrawableAtLiquidity_ : ownerBalance_;\n    }\n\n    /// @inheritdoc IFToken\n    function minDeposit() public view returns (uint256) {\n        uint256 minBigMathRounding_ = 1 <<\n            (LIQUIDITY.readFromStorage(LIQUIDITY_TOTAL_AMOUNTS_SLOT) & LiquidityCalcs.DEFAULT_EXPONENT_MASK); // 1 << total supply exponent\n        uint256 previewMint_ = previewMint(1); // rounds up\n        return minBigMathRounding_ > previewMint_ ? minBigMathRounding_ : previewMint_;\n    }\n}\n\n/// @notice fToken admin related methods. fToken admins are Lending Factory auths. Possible actions are\n/// updating rewards, funding rewards, and rescuing any stuck funds (fToken contract itself never holds any funds).\nabstract contract fTokenAdmin is fTokenCore, fTokenViews {\n    /// @dev checks if `msg.sender` is an allowed auth at LendingFactory. internal method instead of modifier\n    ///      to reduce bytecode size.\n    function _checkIsLendingFactoryAuth() internal view {\n        if (!LENDING_FACTORY.isAuth(msg.sender)) {\n            revert FluidLendingError(ErrorTypes.fToken__Unauthorized);\n        }\n    }\n\n    /// @inheritdoc IFTokenAdmin\n    function updateRewards(IFluidLendingRewardsRateModel rewardsRateModel_) external {\n        _checkIsLendingFactoryAuth();\n\n        // @dev no check for address zero needed here, as that is actually explicitly checked where _rewardsRateModel\n        // is used. In fact it is beneficial to set _rewardsRateModel to address zero when there are no rewards.\n\n        // apply current rewards rate before updating to new one\n        updateRates();\n\n        _rewardsRateModel = rewardsRateModel_;\n\n        // set flag _rewardsActive\n        _rewardsActive = address(rewardsRateModel_) != address(0);\n\n        emit LogUpdateRewards(rewardsRateModel_);\n    }\n\n    /// @inheritdoc IFTokenAdmin\n    function rebalance() external payable virtual nonReentrant returns (uint256 assets_) {\n        if (msg.sender != _rebalancer) {\n            revert FluidLendingError(ErrorTypes.fToken__NotRebalancer);\n        }\n        if (msg.value > 0) {\n            revert FluidLendingError(ErrorTypes.fToken__NotNativeUnderlying);\n        }\n        // calculating difference in assets. if liquidity balance is bigger it'll throw which is an expected behaviour\n        assets_ = totalAssets() - _getLiquidityBalance();\n        // send funds to Liquidity protocol\n        uint256 liquidityExchangePrice_ = _depositToLiquidity(assets_, abi.encode(msg.sender));\n\n        // update the exchange prices, always updating on storage\n        _updateRates(liquidityExchangePrice_, true);\n\n        // no shares are minted when funding fToken contract for rewards\n\n        emit LogRebalance(assets_);\n    }\n\n    /// @inheritdoc IFTokenAdmin\n    function updateRebalancer(address newRebalancer_) public validAddress(newRebalancer_) {\n        _checkIsLendingFactoryAuth();\n\n        _rebalancer = newRebalancer_;\n\n        emit LogUpdateRebalancer(newRebalancer_);\n    }\n\n    /// @inheritdoc IFTokenAdmin\n    function updateRates() public returns (uint256 tokenExchangePrice_, uint256 liquidityExchangePrice_) {\n        liquidityExchangePrice_ = _getLiquidityExchangePrice();\n        tokenExchangePrice_ = _updateRates(liquidityExchangePrice_, true);\n    }\n\n    /// @inheritdoc IFTokenAdmin\n    //\n    // @dev this contract never holds any funds:\n    // -> deposited funds are directly sent to Liquidity.\n    // -> rewards are also stored at Liquidity.\n    function rescueFunds(address token_) external virtual nonReentrant {\n        _checkIsLendingFactoryAuth();\n        SafeTransfer.safeTransfer(address(token_), address(LIQUIDITY), IERC20(token_).balanceOf(address(this)));\n        emit LogRescueFunds(token_);\n    }\n}\n\n/// @notice fToken public executable actions: deposit, mint, mithdraw and redeem.\n/// All actions are optionally also available with an additional param to limit the maximum slippage, e.g. maximum\n/// assets used for minting x amount of shares.\nabstract contract fTokenActions is fTokenCore, fTokenViews {\n    /// @dev reverts if `amount_` is < `minAmountOut_`. Used to reduce bytecode size.\n    function _revertIfBelowMinAmountOut(uint256 amount_, uint256 minAmountOut_) internal pure {\n        if (amount_ < minAmountOut_) {\n            revert FluidLendingError(ErrorTypes.fToken__MinAmountOut);\n        }\n    }\n\n    /// @dev reverts if `amount_` is > `maxAmount_`. Used to reduce bytecode size.\n    function _revertIfAboveMaxAmount(uint256 amount_, uint256 maxAmount_) internal pure {\n        if (amount_ > maxAmount_) {\n            revert FluidLendingError(ErrorTypes.fToken__MaxAmount);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                DEPOSIT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626\n    /// @notice If `assets_` equals uint256.max then the whole balance of `msg.sender` is deposited.\n    ///         `assets_` must at least be `minDeposit()` amount; reverts `fToken__DepositInsignificant()` if not.\n    ///         Recommended to use `deposit()` with a `minAmountOut_` param instead to set acceptable limit.\n    /// @return shares_ actually minted shares\n    function deposit(\n        uint256 assets_,\n        address receiver_\n    ) public virtual override nonReentrant returns (uint256 shares_) {\n        if (assets_ == type(uint256).max) {\n            assets_ = ASSET.balanceOf(msg.sender);\n        }\n\n        // @dev transfer of tokens from `msg.sender` to liquidity contract happens via `liquidityCallback`\n        shares_ = _executeDeposit(assets_, receiver_, abi.encode(msg.sender));\n    }\n\n    /// @notice same as {fToken-deposit} but with an additional setting for minimum output amount.\n    /// reverts with `fToken__MinAmountOut()` if `minAmountOut_` of shares is not reached\n    function deposit(uint256 assets_, address receiver_, uint256 minAmountOut_) external returns (uint256 shares_) {\n        shares_ = deposit(assets_, receiver_);\n        _revertIfBelowMinAmountOut(shares_, minAmountOut_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                   MINT \n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626\n    /// @notice If `shares_` equals uint256.max then the whole balance of `msg.sender` is deposited.\n    ///         `shares_` must at least be `minMint()` amount; reverts `fToken__DepositInsignificant()` if not.\n    ///         Note there might be tiny inaccuracies between requested `shares_` and actually received shares amount.\n    ///         Recommended to use `deposit()` over mint because it is more gas efficient and less likely to revert.\n    ///         Recommended to use `mint()` with a `minAmountOut_` param instead to set acceptable limit.\n    /// @return assets_ deposited assets amount\n    function mint(uint256 shares_, address receiver_) public virtual override nonReentrant returns (uint256 assets_) {\n        if (shares_ == type(uint256).max) {\n            assets_ = ASSET.balanceOf(msg.sender);\n        } else {\n            // No need to check for rounding error, previewMint rounds up.\n            assets_ = previewMint(shares_);\n        }\n\n        // @dev transfer of tokens from `msg.sender` to liquidity contract happens via `liquidityCallback`\n\n        _executeDeposit(assets_, receiver_, abi.encode(msg.sender));\n    }\n\n    /// @notice same as {fToken-mint} but with an additional setting for maximum assets input amount.\n    /// reverts with `fToken__MaxAmount()` if `maxAssets_` of assets is surpassed to mint `shares_`.\n    function mint(uint256 shares_, address receiver_, uint256 maxAssets_) external returns (uint256 assets_) {\n        assets_ = mint(shares_, receiver_);\n        _revertIfAboveMaxAmount(assets_, maxAssets_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                WITHDRAW\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626\n    /// @notice If `assets_` equals uint256.max then the whole fToken balance of `owner_` is withdrawn. This does not\n    ///         consider withdrawal limit at Liquidity so best to check with `maxWithdraw()` before.\n    ///         Note there might be tiny inaccuracies between requested `assets_` and actually received assets amount.\n    ///         Recommended to use `withdraw()` with a `minAmountOut_` param instead to set acceptable limit.\n    /// @return shares_ burned shares\n    function withdraw(\n        uint256 assets_,\n        address receiver_,\n        address owner_\n    ) public virtual override nonReentrant returns (uint256 shares_) {\n        if (assets_ == type(uint256).max) {\n            assets_ = previewRedeem(balanceOf(owner_));\n        }\n        shares_ = _executeWithdraw(assets_, receiver_, owner_);\n\n        if (msg.sender != owner_) {\n            _spendAllowance(owner_, msg.sender, shares_);\n        }\n    }\n\n    /// @notice same as {fToken-withdraw} but with an additional setting for maximum shares burned.\n    /// reverts with `fToken__MaxAmount()` if `maxSharesBurn_` of shares burned is surpassed.\n    function withdraw(\n        uint256 assets_,\n        address receiver_,\n        address owner_,\n        uint256 maxSharesBurn_\n    ) external returns (uint256 shares_) {\n        shares_ = withdraw(assets_, receiver_, owner_);\n        _revertIfAboveMaxAmount(shares_, maxSharesBurn_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                REDEEM\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626\n    /// @notice If `shares_` equals uint256.max then the whole balance of `owner_` is withdrawn.This does not\n    ///         consider withdrawal limit at Liquidity so best to check with `maxRedeem()` before.\n    ///         Recommended to use `withdraw()` over redeem because it is more gas efficient and can set specific amount.\n    ///         Recommended to use `redeem()` with a `minAmountOut_` param instead to set acceptable limit.\n    /// @return assets_ withdrawn assets amount\n    function redeem(\n        uint256 shares_,\n        address receiver_,\n        address owner_\n    ) public virtual override nonReentrant returns (uint256 assets_) {\n        if (shares_ == type(uint256).max) {\n            shares_ = balanceOf(owner_);\n        }\n\n        assets_ = previewRedeem(shares_);\n\n        uint256 burnedShares_ = _executeWithdraw(assets_, receiver_, owner_);\n\n        if (msg.sender != owner_) {\n            _spendAllowance(owner_, msg.sender, burnedShares_);\n        }\n    }\n\n    /// @notice same as {fToken-redeem} but with an additional setting for minimum output amount.\n    /// reverts with `fToken__MinAmountOut()` if `minAmountOut_` of assets is not reached.\n    function redeem(\n        uint256 shares_,\n        address receiver_,\n        address owner_,\n        uint256 minAmountOut_\n    ) external returns (uint256 assets_) {\n        assets_ = redeem(shares_, receiver_, owner_);\n        _revertIfBelowMinAmountOut(assets_, minAmountOut_);\n    }\n}\n\n/// @notice fTokens support EIP-2612 permit approvals via signature so this contract implements\n/// withdrawals (withdraw / redeem) with signature used for approval of the fToken shares.\nabstract contract fTokenEIP2612Withdrawals is fTokenActions {\n    /// @dev creates `sharesToPermit_` allowance for `owner_` via EIP2612 `deadline_` and `signature_`\n    function _allowViaPermitEIP2612(\n        address owner_,\n        uint256 sharesToPermit_,\n        uint256 deadline_,\n        bytes calldata signature_\n    ) internal {\n        (uint8 v_, bytes32 r_, bytes32 s_) = _splitSignature(signature_);\n        // spender = msg.sender\n        permit(owner_, msg.sender, sharesToPermit_, deadline_, v_, r_, s_);\n    }\n\n    /// @notice withdraw amount of `assets_` with ERC-2612 permit signature for fToken approval.\n    /// `owner_` signs ERC-2612 permit `signature_` to give allowance of fTokens to `msg.sender`.\n    /// Note there might be tiny inaccuracies between requested `assets_` and actually received assets amount.\n    /// allowance via signature (`sharesToPermit_`) should cover `previewWithdraw(assets_)` plus a little buffer to avoid revert.\n    /// Inherent trust assumption that `msg.sender` will set `receiver_` and `maxSharesBurn_` as `owner_` intends\n    /// (which is always the case when giving allowance to some spender).\n    /// @param sharesToPermit_ shares amount to use for EIP2612 permit(). Should cover `previewWithdraw(assets_)` + small buffer.\n    /// @param assets_ amount of assets to withdraw\n    /// @param receiver_ receiver of withdrawn assets\n    /// @param owner_ owner to withdraw from (must be signature signer)\n    /// @param maxSharesBurn_ maximum accepted amount of shares burned\n    /// @param deadline_ deadline for signature validity\n    /// @param signature_  packed signature of signing the EIP712 hash for ERC-2612 permit\n    /// @return shares_ burned shares amount\n    function withdrawWithSignature(\n        uint256 sharesToPermit_,\n        uint256 assets_,\n        address receiver_,\n        address owner_,\n        uint256 maxSharesBurn_,\n        uint256 deadline_,\n        bytes calldata signature_\n    ) external virtual nonReentrant returns (uint256 shares_) {\n        if (msg.sender == owner_) {\n            // no sense in operating with permit if msg.sender is owner. should call normal `withdraw()` instead.\n            revert FluidLendingError(ErrorTypes.fToken__PermitFromOwnerCall);\n        }\n\n        // create allowance through signature_\n        _allowViaPermitEIP2612(owner_, sharesToPermit_, deadline_, signature_);\n\n        // execute withdraw to get shares_ to spend amount\n        shares_ = _executeWithdraw(assets_, receiver_, owner_);\n\n        _revertIfAboveMaxAmount(shares_, maxSharesBurn_);\n\n        _spendAllowance(owner_, msg.sender, shares_);\n    }\n\n    /// @notice redeem amount of `shares_` with ERC-2612 permit signature for fToken approval.\n    /// `owner_` signs ERC-2612 permit `signature_` to give allowance of fTokens to `msg.sender`.\n    /// Note there might be tiny inaccuracies between requested `shares_` to redeem and actually burned shares.\n    /// allowance via signature must cover `shares_` plus a tiny buffer.\n    /// Inherent trust assumption that `msg.sender` will set `receiver_` and `minAmountOut_` as `owner_` intends\n    ///       (which is always the case when giving allowance to some spender).\n    /// Recommended to use `withdraw()` over redeem because it is more gas efficient and can set specific amount.\n    /// @param shares_ amount of shares to redeem\n    /// @param receiver_ receiver of withdrawn assets\n    /// @param owner_ owner to withdraw from (must be signature signer)\n    /// @param minAmountOut_ minimum accepted amount of assets withdrawn\n    /// @param deadline_ deadline for signature validity\n    /// @param signature_  packed signature of signing the EIP712 hash for ERC-2612 permit\n    /// @return assets_ withdrawn assets amount\n    function redeemWithSignature(\n        uint256 shares_,\n        address receiver_,\n        address owner_,\n        uint256 minAmountOut_,\n        uint256 deadline_,\n        bytes calldata signature_\n    ) external virtual nonReentrant returns (uint256 assets_) {\n        if (msg.sender == owner_) {\n            // no sense in operating with permit if msg.sender is owner. should call normal `redeem()` instead.\n            revert FluidLendingError(ErrorTypes.fToken__PermitFromOwnerCall);\n        }\n\n        assets_ = previewRedeem(shares_);\n        _revertIfBelowMinAmountOut(assets_, minAmountOut_);\n\n        // create allowance through signature_\n        _allowViaPermitEIP2612(owner_, shares_, deadline_, signature_);\n\n        // execute withdraw to get actual shares to spend amount\n        uint256 sharesToSpend_ = _executeWithdraw(assets_, receiver_, owner_);\n\n        _spendAllowance(owner_, msg.sender, sharesToSpend_);\n    }\n}\n\n/// @notice implements fTokens support for deposit / mint via EIP-2612 permit.\n/// @dev methods revert if underlying asset does not support EIP-2612.\nabstract contract fTokenEIP2612Deposits is fTokenActions {\n    /// @notice deposit `assets_` amount with EIP-2612 Permit2 signature for underlying asset approval.\n    ///         IMPORTANT: This will revert if the underlying `asset()` does not support EIP-2612.\n    ///         reverts with `fToken__MinAmountOut()` if `minAmountOut_` of shares is not reached.\n    ///         `assets_` must at least be `minDeposit()` amount; reverts `fToken__DepositInsignificant()` if not.\n    /// @param assets_ amount of assets to deposit\n    /// @param receiver_ receiver of minted fToken shares\n    /// @param minAmountOut_ minimum accepted amount of shares minted\n    /// @param deadline_ deadline for signature validity\n    /// @param signature_  packed signature of signing the EIP712 hash for EIP-2612 Permit\n    /// @return shares_ amount of minted shares\n    function depositWithSignatureEIP2612(\n        uint256 assets_,\n        address receiver_,\n        uint256 minAmountOut_,\n        uint256 deadline_,\n        bytes calldata signature_\n    ) external returns (uint256 shares_) {\n        // create allowance through signature_ and spend it\n        (uint8 v_, bytes32 r_, bytes32 s_) = _splitSignature(signature_);\n\n        // EIP-2612 permit for underlying asset from owner (msg.sender) to spender (this contract)\n        IERC20Permit(address(ASSET)).permit(msg.sender, address(this), assets_, deadline_, v_, r_, s_);\n\n        // deposit() includes nonReentrant modifier which is enough to have from this point forward\n        shares_ = deposit(assets_, receiver_);\n        _revertIfBelowMinAmountOut(shares_, minAmountOut_);\n    }\n\n    /// @notice mint amount of `shares_` with EIP-2612 Permit signature for underlying asset approval.\n    ///         IMPORTANT: This will revert if the underlying `asset()` does not support EIP-2612.\n    ///         Signature should approve a little bit more than expected assets amount (`previewMint()`) to avoid reverts.\n    ///         `shares_` must at least be `minMint()` amount; reverts with `fToken__DepositInsignificant()` if not.\n    ///         Note there might be tiny inaccuracies between requested `shares_` and actually received shares amount.\n    ///         Recommended to use `deposit()` over mint because it is more gas efficient and less likely to revert.\n    /// @param shares_ amount of shares to mint\n    /// @param receiver_ receiver of minted fToken shares\n    /// @param maxAssets_ maximum accepted amount of assets used as input to mint `shares_`\n    /// @param deadline_ deadline for signature validity\n    /// @param signature_  packed signature of signing the EIP712 hash for EIP-2612 Permit\n    /// @return assets_ deposited assets amount\n    function mintWithSignatureEIP2612(\n        uint256 shares_,\n        address receiver_,\n        uint256 maxAssets_,\n        uint256 deadline_,\n        bytes calldata signature_\n    ) external returns (uint256 assets_) {\n        assets_ = previewMint(shares_);\n\n        // create allowance through signature_ and spend it\n        (uint8 v_, bytes32 r_, bytes32 s_) = _splitSignature(signature_);\n\n        // EIP-2612 permit for underlying asset from owner (msg.sender) to spender (this contract)\n        IERC20Permit(address(ASSET)).permit(msg.sender, address(this), assets_, deadline_, v_, r_, s_);\n\n        // mint() includes nonReentrant modifier which is enough to have from this point forward\n        assets_ = mint(shares_, receiver_);\n        _revertIfAboveMaxAmount(assets_, maxAssets_);\n    }\n}\n\n/// @notice implements fTokens support for deposit / mint via Permit2 signature.\nabstract contract fTokenPermit2Deposits is fTokenActions {\n    /// @inheritdoc IFToken\n    function depositWithSignature(\n        uint256 assets_,\n        address receiver_,\n        uint256 minAmountOut_,\n        IAllowanceTransfer.PermitSingle calldata permit_,\n        bytes calldata signature_\n    ) external nonReentrant returns (uint256 shares_) {\n        // give allowance to address(this) via Permit2 signature -> to spend allowance in LiquidityCallback\n        // to transfer funds directly from msg.sender to liquidity\n        PERMIT2.permit(\n            // owner - Who signed the permit and also holds the tokens\n            // @dev Note if this is modified to not be msg.sender, extra steps would be needed for security!\n            // the caller could use this signature and deposit to the balance of receiver_, which could be set to any address,\n            // because it is not included in the signature. Use permitWitnessTransferFrom in that case. Same for `minAmountOut_`.\n            msg.sender,\n            permit_, // permit message\n            signature_ // packed signature of signing the EIP712 hash of `permit_`\n        );\n\n        // @dev transfer of tokens from `msg.sender` to liquidity contract happens via `liquidityCallback`\n\n        shares_ = _executeDeposit(assets_, receiver_, abi.encode(true, msg.sender));\n        _revertIfBelowMinAmountOut(shares_, minAmountOut_);\n    }\n\n    /// @inheritdoc IFToken\n    function mintWithSignature(\n        uint256 shares_,\n        address receiver_,\n        uint256 maxAssets_,\n        IAllowanceTransfer.PermitSingle calldata permit_,\n        bytes calldata signature_\n    ) external nonReentrant returns (uint256 assets_) {\n        assets_ = previewMint(shares_);\n        _revertIfAboveMaxAmount(assets_, maxAssets_);\n\n        // give allowance to address(this) via Permit2 PermitSingle. to spend allowance in LiquidityCallback\n        // to transfer funds directly from msg.sender to liquidity\n        PERMIT2.permit(\n            // owner - Who signed the permit and also holds the tokens\n            // @dev Note if this is modified to not be msg.sender, extra steps would be needed for security!\n            // the caller could use this signature and deposit to the balance of receiver_, which could be set to any address,\n            // because it is not included in the signature. Use permitWitnessTransferFrom in that case. Same for `minAmountOut_`.\n            msg.sender,\n            permit_, // permit message\n            signature_ // packed signature of signing the EIP712 hash of `permit_`\n        );\n\n        // @dev transfer of tokens from `msg.sender` to liquidity contract happens via `liquidityCallback`\n\n        _executeDeposit(assets_, receiver_, abi.encode(true, msg.sender));\n    }\n}\n\n/// @title Fluid fToken (Lending with interest)\n/// @notice fToken is a token that can be used to supply liquidity to the Fluid Liquidity pool and earn interest for doing so.\n/// The fToken is backed by the underlying balance and can be redeemed for the underlying token at any time.\n/// The interest is earned via Fluid Liquidity, e.g. because borrowers pay a borrow rate on it. In addition, fTokens may also\n/// have active rewards going on that count towards the earned yield for fToken holders.\n/// @dev The fToken implements the ERC20 and ERC4626 standard, which means it can be transferred, minted and burned.\n/// The fToken supports EIP-2612 permit approvals via signature.\n/// The fToken implements withdrawals via EIP-2612 permits and deposits with Permit2 or EIP-2612 (if underlying supports it) signatures.\n/// fTokens are not upgradeable.\n/// @dev For view methods / accessing data, use the \"LendingResolver\" periphery contract.\n//\n// fTokens can only be deployed for underlying tokens that are listed at Liquidity (`_getLiquidityExchangePrice()` reverts\n// otherwise, which is called in the constructor).\ncontract fToken is fTokenAdmin, fTokenActions, fTokenEIP2612Withdrawals, fTokenPermit2Deposits, fTokenEIP2612Deposits {\n    /// @param liquidity_ liquidity contract address\n    /// @param lendingFactory_ lending factory contract address\n    /// @param asset_ underlying token address\n    constructor(\n        IFluidLiquidity liquidity_,\n        IFluidLendingFactory lendingFactory_,\n        IERC20 asset_\n    ) Variables(liquidity_, lendingFactory_, asset_) {\n        // set initial values for _liquidityExchangePrice, _tokenExchangePrice and _lastUpdateTimestamp\n        _liquidityExchangePrice = uint64(_getLiquidityExchangePrice());\n        _tokenExchangePrice = uint64(EXCHANGE_PRICES_PRECISION);\n        _lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /// @inheritdoc IERC20Metadata\n    function decimals() public view virtual override(ERC20, IERC20Metadata) returns (uint8) {\n        return DECIMALS;\n    }\n\n    /// @inheritdoc IFToken\n    function liquidityCallback(address token_, uint256 amount_, bytes calldata data_) external virtual override {\n        if (msg.sender != address(LIQUIDITY) || token_ != address(ASSET) || _status != REENTRANCY_ENTERED) {\n            // caller must be liquidity, token must match, and reentrancy status must be REENTRANCY_ENTERED\n            revert FluidLendingError(ErrorTypes.fToken__Unauthorized);\n        }\n\n        // callback data can be a) an address only b) an address + transfer via permit2 flag set to true\n        // for a) length will be 32, for b) length is 64\n        if (data_.length == 32) {\n            address from_ = abi.decode(data_, (address));\n\n            // transfer `amount_` from `from_` (original deposit msg.sender) to liquidity contract\n            SafeTransfer.safeTransferFrom(address(ASSET), from_, address(LIQUIDITY), amount_);\n        } else {\n            (bool isPermit2_, address from_) = abi.decode(data_, (bool, address));\n            if (!isPermit2_) {\n                // unexepcted liquidity callback data\n                revert FluidLendingError(ErrorTypes.fToken__InvalidParams);\n            }\n\n            // transfer `amount_` from `from_` (original deposit msg.sender) to liquidity contract via PERMIT2\n            PERMIT2.transferFrom(from_, address(LIQUIDITY), uint160(amount_), address(ASSET));\n        }\n    }\n}\n"
    },
    "contracts/protocols/lending/fToken/nativeUnderlying/fTokenNativeUnderlying.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { SafeTransfer } from \"../../../../libraries/safeTransfer.sol\";\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { fTokenCore, fTokenAdmin, fToken } from \"../main.sol\";\n\nimport { IWETH9 } from \"../../interfaces/external/iWETH9.sol\";\nimport { IFluidLendingFactory } from \"../../interfaces/iLendingFactory.sol\";\nimport { IFTokenAdmin, IFTokenNativeUnderlying, IFToken } from \"../../interfaces/iFToken.sol\";\nimport { IFluidLiquidity } from \"../../../../liquidity/interfaces/iLiquidity.sol\";\n\n/// @dev overrides certain methods from the inherited fToken used as base contract to make them compatible with\n/// the native token being used as underlying.\nabstract contract fTokenNativeUnderlyingOverrides is fToken, IFTokenNativeUnderlying {\n    using FixedPointMathLib for uint256;\n\n    /// @inheritdoc IFTokenNativeUnderlying\n    address public constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev gets asset address for liquidity slot links, overridden to set native token address\n    function _getLiquiditySlotLinksAsset() internal view virtual override returns (address) {\n        return NATIVE_TOKEN_ADDRESS;\n    }\n\n    /// @dev Gets current Liquidity underlying token balance\n    function _getLiquidityUnderlyingBalance() internal view virtual override returns (uint256) {\n        return address(LIQUIDITY).balance;\n    }\n\n    /// @inheritdoc IFTokenAdmin\n    function rescueFunds(address token_) external virtual override(IFTokenAdmin, fTokenAdmin) nonReentrant {\n        _checkIsLendingFactoryAuth();\n\n        if (token_ == NATIVE_TOKEN_ADDRESS) {\n            Address.sendValue(payable(address(LIQUIDITY)), address(this).balance);\n        } else {\n            SafeTransfer.safeTransfer(address(token_), address(LIQUIDITY), IERC20(token_).balanceOf(address(this)));\n        }\n\n        emit LogRescueFunds(token_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                REWARDS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc fTokenAdmin\n    function rebalance()\n        external\n        payable\n        virtual\n        override(IFTokenAdmin, fTokenAdmin)\n        nonReentrant\n        returns (uint256 assets_)\n    {\n        if (msg.sender != _rebalancer) {\n            revert FluidLendingError(ErrorTypes.fToken__NotRebalancer);\n        }\n        // calculating difference in assets. if liquidity balance is bigger it'll throw which is an expected behaviour\n        assets_ = totalAssets() - _getLiquidityBalance();\n\n        if (msg.value < assets_) {\n            assets_ = msg.value;\n        } else if (msg.value > assets_) {\n            // send back overfunded msg.value amount\n            Address.sendValue(payable(msg.sender), msg.value - assets_);\n        }\n\n        // send funds to Liquidity protocol to generate yield\n        uint256 liquidityExchangePrice_ = _depositToLiquidity(assets_, new bytes(0));\n\n        // update the exchange prices, always updating on storage\n        _updateRates(liquidityExchangePrice_, true);\n\n        // no shares are minted when funding fToken contract for rewards\n\n        emit LogRebalance(assets_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                DEPOSIT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc fTokenCore\n    function _depositToLiquidity(\n        uint256 assets_,\n        bytes memory liquidityCallbackData_\n    ) internal virtual override returns (uint256 exchangePrice_) {\n        // send funds to Liquidity protocol to generate yield, send along msg.value\n        (exchangePrice_, ) = LIQUIDITY.operate{ value: assets_ }(\n            NATIVE_TOKEN_ADDRESS, // deposit to Liquidity is always in native, also if user input is wrapped token\n            SafeCast.toInt256(assets_),\n            0,\n            address(0),\n            address(0),\n            liquidityCallbackData_ // callback data. -> \"from\" for transferFrom in `liquidityCallback`\n        );\n    }\n\n    /// @inheritdoc fTokenCore\n    function _executeDeposit(\n        uint256 assets_,\n        address receiver_,\n        // liquidityCallbackData_ not needed for native transfer, sent along as msg.value. But used to recognize Permit2 transfers.\n        bytes memory liquidityCallbackData_\n    ) internal virtual override returns (uint256 sharesMinted_) {\n        // transfer wrapped asset from user to this contract\n        if (liquidityCallbackData_.length > 32) {\n            // liquidityCallbackData_ with length > 32 can only be Permit2 as all others maximally encode from address\n            PERMIT2.transferFrom(msg.sender, address(this), uint160(assets_), address(ASSET));\n        } else {\n            SafeTransfer.safeTransferFrom(address(ASSET), msg.sender, address(this), assets_);\n        }\n\n        // convert WETH to native underlying token\n        IWETH9(address(ASSET)).withdraw(assets_);\n\n        // super._executeDeposit includes check for validAddress receiver_\n        return super._executeDeposit(assets_, receiver_, new bytes(0));\n    }\n\n    /// @dev deposits `msg.value` amount of native token into liquidity and mints shares for `receiver_`.\n    /// Returns amount of `sharesMinted_`.\n    function _executeDepositNative(address receiver_) internal virtual returns (uint256 sharesMinted_) {\n        // super._executeDeposit includes check for validAddress receiver_\n        return super._executeDeposit(msg.value, receiver_, new bytes(0));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                WITHDRAW\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc fTokenCore\n    function _withdrawFromLiquidity(\n        uint256 assets_,\n        address receiver_\n    ) internal virtual override returns (uint256 exchangePrice_) {\n        // get funds back from Liquidity protocol to send to the user\n        (exchangePrice_, ) = LIQUIDITY.operate(\n            NATIVE_TOKEN_ADDRESS, // withdraw from Liquidity is always in native, also if user output is wrapped token\n            -SafeCast.toInt256(assets_),\n            0,\n            receiver_,\n            address(0),\n            new bytes(0) // callback data -> withdraw doesn't trigger a callback\n        );\n    }\n\n    /// @inheritdoc fTokenCore\n    function _executeWithdraw(\n        uint256 assets_,\n        address receiver_,\n        address owner_\n    ) internal virtual override returns (uint256 sharesBurned_) {\n        // super._executeWithdraw includes check for validAddress(receiver_)\n\n        // withdraw from liquidity to this contract first to convert withdrawn native token to wrapped native for _receiver.\n        sharesBurned_ = super._executeWithdraw(assets_, address(this), owner_);\n\n        // convert received native underlying token to WETH and transfer to receiver_\n        IWETH9(address(ASSET)).deposit{ value: assets_ }();\n        SafeTransfer.safeTransfer(address(ASSET), receiver_, assets_);\n    }\n\n    /// @dev withdraws `assets_` from liquidity to `receiver_` and burns shares from `owner_`.\n    /// Returns amount of `sharesBurned_`.\n    function _executeWithdrawNative(\n        uint256 assets_,\n        address receiver_,\n        address owner_\n    ) internal virtual returns (uint256 sharesBurned_) {\n        // super._executeWithdraw includes check for validAddress(receiver_)\n        return super._executeWithdraw(assets_, receiver_, owner_);\n    }\n}\n\n/// @notice implements deposit / mint / withdraw / redeem actions with Native token being used as interaction token.\nabstract contract fTokenNativeUnderlyingActions is fTokenNativeUnderlyingOverrides {\n    /*//////////////////////////////////////////////////////////////\n                                DEPOSIT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFTokenNativeUnderlying\n    function depositNative(address receiver_) public payable nonReentrant returns (uint256 shares_) {\n        shares_ = _executeDepositNative(receiver_);\n    }\n\n    /// @inheritdoc IFTokenNativeUnderlying\n    function depositNative(address receiver_, uint256 minAmountOut_) external payable returns (uint256 shares_) {\n        shares_ = depositNative(receiver_);\n        _revertIfBelowMinAmountOut(shares_, minAmountOut_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                   MINT \n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFTokenNativeUnderlying\n    function mintNative(uint256 shares_, address receiver_) public payable nonReentrant returns (uint256 assets_) {\n        // No need to check for rounding error, previewMint rounds up.\n        assets_ = previewMint(shares_);\n\n        if (msg.value < assets_) {\n            // not enough msg.value sent along to cover mint shares amount\n            revert FluidLendingError(ErrorTypes.fTokenNativeUnderlying__TransferInsufficient);\n        }\n\n        _executeDepositNative(receiver_);\n    }\n\n    /// @inheritdoc IFTokenNativeUnderlying\n    function mintNative(\n        uint256 shares_,\n        address receiver_,\n        uint256 maxAssets_\n    ) external payable returns (uint256 assets_) {\n        assets_ = mintNative(shares_, receiver_);\n        _revertIfAboveMaxAmount(assets_, maxAssets_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                WITHDRAW\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFTokenNativeUnderlying\n    function withdrawNative(\n        uint256 assets_,\n        address receiver_,\n        address owner_\n    ) public nonReentrant returns (uint256 shares_) {\n        if (assets_ == type(uint256).max) {\n            assets_ = previewRedeem(balanceOf(msg.sender));\n        }\n\n        shares_ = _executeWithdrawNative(assets_, receiver_, owner_);\n\n        if (msg.sender != owner_) {\n            _spendAllowance(owner_, msg.sender, shares_);\n        }\n    }\n\n    /// @inheritdoc IFTokenNativeUnderlying\n    function withdrawNative(\n        uint256 assets_,\n        address receiver_,\n        address owner_,\n        uint256 maxSharesBurn_\n    ) external returns (uint256 shares_) {\n        shares_ = withdrawNative(assets_, receiver_, owner_);\n        _revertIfAboveMaxAmount(shares_, maxSharesBurn_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                REDEEM\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFTokenNativeUnderlying\n    function redeemNative(\n        uint256 shares_,\n        address receiver_,\n        address owner_\n    ) public nonReentrant returns (uint256 assets_) {\n        if (shares_ == type(uint256).max) {\n            shares_ = balanceOf(msg.sender);\n        }\n\n        assets_ = previewRedeem(shares_);\n\n        uint256 burnedShares_ = _executeWithdrawNative(assets_, receiver_, owner_);\n\n        if (msg.sender != owner_) {\n            _spendAllowance(owner_, msg.sender, burnedShares_);\n        }\n    }\n\n    /// @inheritdoc IFTokenNativeUnderlying\n    function redeemNative(\n        uint256 shares_,\n        address receiver_,\n        address owner_,\n        uint256 minAmountOut_\n    ) external returns (uint256 assets_) {\n        assets_ = redeemNative(shares_, receiver_, owner_);\n        _revertIfBelowMinAmountOut(assets_, minAmountOut_);\n    }\n}\n\n/// @notice fTokens support EIP-2612 permit approvals via signature so withdrawals are possible with signature.\n/// This contract implements those withdrawals for a native underlying asset.\nabstract contract fTokenNativeUnderlyingEIP2612Withdrawals is fTokenNativeUnderlyingActions {\n    /// @inheritdoc IFTokenNativeUnderlying\n    function withdrawWithSignatureNative(\n        uint256 sharesToPermit_,\n        uint256 assets_,\n        address receiver_,\n        address owner_,\n        uint256 maxSharesBurn_,\n        uint256 deadline_,\n        bytes calldata signature_\n    ) external nonReentrant returns (uint256 shares_) {\n        // @dev logic below is exactly the same as in {fTokenEIP2612Withdrawals-withdrawWithSignature}, just using\n        // _executeWithdrawNative instead of _executeWithdraw\n\n        if (msg.sender == owner_) {\n            // no sense in operating with permit if msg.sender is owner. should call normal `withdraw()` instead.\n            revert FluidLendingError(ErrorTypes.fToken__PermitFromOwnerCall);\n        }\n\n        // create allowance through signature_\n        _allowViaPermitEIP2612(owner_, sharesToPermit_, deadline_, signature_);\n\n        // execute withdraw to get shares_ to spend amount\n        shares_ = _executeWithdrawNative(assets_, receiver_, owner_);\n\n        _revertIfAboveMaxAmount(shares_, maxSharesBurn_);\n\n        _spendAllowance(owner_, msg.sender, shares_);\n    }\n\n    /// @inheritdoc IFTokenNativeUnderlying\n    function redeemWithSignatureNative(\n        uint256 shares_,\n        address receiver_,\n        address owner_,\n        uint256 minAmountOut_,\n        uint256 deadline_,\n        bytes calldata signature_\n    ) external nonReentrant returns (uint256 assets_) {\n        // @dev logic below is exactly the same as in {fTokenEIP2612Withdrawals-redeemWithSignature}, just using\n        // _executeWithdrawNative instead of _executeWithdraw\n\n        if (msg.sender == owner_) {\n            // no sense in operating with permit if msg.sender is owner. should call normal `redeem()` instead.\n            revert FluidLendingError(ErrorTypes.fToken__PermitFromOwnerCall);\n        }\n\n        assets_ = previewRedeem(shares_);\n        _revertIfBelowMinAmountOut(assets_, minAmountOut_);\n\n        // create allowance through signature_\n        _allowViaPermitEIP2612(owner_, shares_, deadline_, signature_);\n\n        // execute withdraw to get actual shares to spend amount\n        uint256 sharesToSpend_ = _executeWithdrawNative(assets_, receiver_, owner_);\n\n        _spendAllowance(owner_, msg.sender, sharesToSpend_);\n    }\n}\n\n/// @notice Same as the {fToken} contract but with support for native token as underlying asset.\n/// Actual underlying asset is the wrapped native ERC20 version (e.g. WETH), which acts like any other fToken.\n/// But in addition the fTokenNativeUnderlying also has methods for doing all the same actions via the native token.\ncontract fTokenNativeUnderlying is fTokenNativeUnderlyingEIP2612Withdrawals {\n    /// @param liquidity_ liquidity contract address\n    /// @param lendingFactory_ lending factory contract address\n    /// @param weth_ address of wrapped native token (e.g. WETH)\n    constructor(\n        IFluidLiquidity liquidity_,\n        IFluidLendingFactory lendingFactory_,\n        IWETH9 weth_\n    ) fToken(liquidity_, lendingFactory_, IERC20(address(weth_))) {}\n\n    /// @inheritdoc fToken\n    function liquidityCallback(\n        address /** token_ */,\n        uint256 /** amount_ */,\n        bytes calldata /** data_ */\n    ) external virtual override(IFToken, fToken) {\n        // not needed because msg.value is used directly\n        revert FluidLendingError(ErrorTypes.fTokenNativeUnderlying__UnexpectedLiquidityCallback);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/protocols/lending/fToken/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20, IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\nimport { IAllowanceTransfer } from \"../interfaces/permit2/iAllowanceTransfer.sol\";\nimport { LiquiditySlotsLink } from \"../../../libraries/liquiditySlotsLink.sol\";\nimport { IFToken } from \"../interfaces/iFToken.sol\";\nimport { IAllowanceTransfer } from \"../interfaces/permit2/iAllowanceTransfer.sol\";\nimport { IFluidLendingRewardsRateModel  } from \"../interfaces/iLendingRewardsRateModel.sol\";\nimport { IFluidLendingFactory } from \"../interfaces/iLendingFactory.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\n\nabstract contract Constants {\n    /// @dev permit2 contract, deployed to same address on EVM networks, see https://github.com/Uniswap/permit2\n    IAllowanceTransfer internal constant PERMIT2 = IAllowanceTransfer(0x000000000022D473030F116dDEE9F6B43aC78BA3);\n\n    /// @dev precision for exchange prices\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /// @dev max allowed reward rate is 50%\n    uint256 internal constant MAX_REWARDS_RATE = 50 * 1e12; // 50%;\n\n    /// @dev address of the Liquidity contract.\n    IFluidLiquidity internal immutable LIQUIDITY;\n\n    /// @dev address of the Lending factory contract.\n    IFluidLendingFactory internal immutable LENDING_FACTORY;\n\n    /// @dev address of the underlying asset contract.\n    IERC20 internal immutable ASSET;\n\n    /// @dev number of decimals for the fToken, same as ASSET\n    uint8 internal immutable DECIMALS;\n\n    /// @dev slot ids in Liquidity contract for underlying token.\n    /// Helps in low gas fetch from liquidity contract by skipping delegate call with `readFromStorage`\n    bytes32 internal immutable LIQUIDITY_EXCHANGE_PRICES_SLOT;\n    bytes32 internal immutable LIQUIDITY_TOTAL_AMOUNTS_SLOT;\n    bytes32 internal immutable LIQUIDITY_USER_SUPPLY_SLOT;\n\n    /// @param liquidity_ liquidity contract address\n    /// @param lendingFactory_ lending factory contract address\n    /// @param asset_ underlying token address\n    constructor(IFluidLiquidity liquidity_, IFluidLendingFactory lendingFactory_, IERC20 asset_) {\n        DECIMALS = IERC20Metadata(address(asset_)).decimals();\n        ASSET = asset_;\n        LIQUIDITY = liquidity_;\n        LENDING_FACTORY = lendingFactory_;\n\n        LIQUIDITY_EXCHANGE_PRICES_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            _getLiquiditySlotLinksAsset()\n        );\n        LIQUIDITY_TOTAL_AMOUNTS_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT,\n            _getLiquiditySlotLinksAsset()\n        );\n        LIQUIDITY_USER_SUPPLY_SLOT = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n            address(this),\n            _getLiquiditySlotLinksAsset()\n        );\n    }\n\n    /// @dev gets asset address for liquidity slot links, extracted to separate method so it can be overridden if needed\n    function _getLiquiditySlotLinksAsset() internal view virtual returns (address) {\n        return address(ASSET);\n    }\n}\n\nabstract contract Variables is ERC20, ERC20Permit, Error, Constants, IFToken {\n    /// @dev prefix for token name. fToken will append the underlying asset name\n    string private constant TOKEN_NAME_PREFIX = \"Fluid \";\n    /// @dev prefix for token symbol. fToken will append the underlying asset symbol\n    string private constant TOKEN_SYMBOL_PREFIX = \"f\";\n\n    // ------------ storage variables from inherited contracts come before vars here --------\n    // _________ ERC20 _______________\n    // ----------------------- slot 0 ---------------------------\n    // mapping(address => uint256) private _balances;\n\n    // ----------------------- slot 1 ---------------------------\n    // mapping(address => mapping(address => uint256)) private _allowances;\n\n    // ----------------------- slot 2 ---------------------------\n    // uint256 private _totalSupply;\n\n    // ----------------------- slot 3 ---------------------------\n    // string private _name;\n    // ----------------------- slot 4 ---------------------------\n    // string private _symbol;\n\n    // _________ ERC20Permit _______________\n    // ----------------------- slot 5 ---------------------------\n    // mapping(address => Counters.Counter) private _nonces;\n\n    // ----------------------- slot 6 ---------------------------\n    // bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    // ----------------------- slot 7 ---------------------------\n    /// @dev address of the LendingRewardsRateModel.\n    IFluidLendingRewardsRateModel  internal _rewardsRateModel;\n\n    // -> 12 bytes empty\n    uint96 private __placeholder_gap;\n\n    // ----------------------- slot 8 ---------------------------\n    // optimized to put all storage variables where a SSTORE happens on actions in the same storage slot\n\n    /// @dev exchange price for the underlying assset in the liquidity protocol (without rewards)\n    uint64 internal _liquidityExchangePrice; // in 1e12 -> (max value 18_446_744,073709551615)\n\n    /// @dev exchange price between fToken and the underlying assset (with rewards)\n    uint64 internal _tokenExchangePrice; // in 1e12 -> (max value 18_446_744,073709551615)\n\n    /// @dev timestamp when exchange prices were updated the last time\n    uint40 internal _lastUpdateTimestamp;\n\n    /// @dev status for reentrancy guard\n    uint8 internal _status;\n\n    /// @dev flag to signal if rewards are active without having to read slot 6\n    bool internal _rewardsActive;\n\n    // 72 bits empty (9 bytes)\n\n    // ----------------------- slot 9 ---------------------------\n    /// @dev rebalancer address allowed to call `rebalance()` and source for funding rewards (ReserveContract).\n    address internal _rebalancer;\n\n    /*//////////////////////////////////////////////////////////////\n                          CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @param liquidity_ liquidity contract address\n    /// @param lendingFactory_ lending factory contract address\n    /// @param asset_ underlying token address\n    constructor(\n        IFluidLiquidity liquidity_,\n        IFluidLendingFactory lendingFactory_,\n        IERC20 asset_\n    )\n        validAddress(address(liquidity_))\n        validAddress(address(lendingFactory_))\n        validAddress(address(asset_))\n        Constants(liquidity_, lendingFactory_, asset_)\n        ERC20(\n            string(abi.encodePacked(TOKEN_NAME_PREFIX, IERC20Metadata(address(asset_)).name())),\n            string(abi.encodePacked(TOKEN_SYMBOL_PREFIX, IERC20Metadata(address(asset_)).symbol()))\n        )\n        ERC20Permit(string(abi.encodePacked(TOKEN_NAME_PREFIX, IERC20Metadata(address(asset_)).name())))\n    {}\n\n    /// @dev checks that address is not the zero address, reverts if so. Calling the method in the modifier reduces\n    /// bytecode size as modifiers are inlined into bytecode\n    function _checkValidAddress(address value_) internal pure {\n        if (value_ == address(0)) {\n            revert FluidLendingError(ErrorTypes.fToken__InvalidParams);\n        }\n    }\n\n    /// @dev validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        _checkValidAddress(value_);\n        _;\n    }\n}\n"
    },
    "contracts/protocols/lending/interfaces/external/iWETH9.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWETH9 is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/protocols/lending/interfaces/iFToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\nimport { IAllowanceTransfer } from \"./permit2/iAllowanceTransfer.sol\";\nimport { IFluidLendingRewardsRateModel } from \"./iLendingRewardsRateModel.sol\";\nimport { IFluidLendingFactory } from \"./iLendingFactory.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\n\ninterface IFTokenAdmin {\n    /// @notice updates the rewards rate model contract.\n    ///         Only callable by LendingFactory auths.\n    /// @param rewardsRateModel_  the new rewards rate model contract address.\n    ///                           can be set to address(0) to set no rewards (to save gas)\n    function updateRewards(IFluidLendingRewardsRateModel rewardsRateModel_) external;\n\n    /// @notice Balances out the difference between fToken supply at Liquidity vs totalAssets().\n    ///         Deposits underlying from rebalancer address into Liquidity but doesn't mint any shares\n    ///         -> thus making deposit available as rewards.\n    ///         Only callable by rebalancer.\n    /// @return assets_ amount deposited to Liquidity\n    function rebalance() external payable returns (uint256 assets_);\n\n    /// @notice gets the liquidity exchange price of the underlying asset, calculates the updated exchange price (with reward rates)\n    ///         and writes those values to storage.\n    ///         Callable by anyone.\n    /// @return tokenExchangePrice_ exchange price of fToken share to underlying asset\n    /// @return liquidityExchangePrice_ exchange price at Liquidity for the underlying asset\n    function updateRates() external returns (uint256 tokenExchangePrice_, uint256 liquidityExchangePrice_);\n\n    /// @notice sends any potentially stuck funds to Liquidity contract. Only callable by LendingFactory auths.\n    function rescueFunds(address token_) external;\n\n    /// @notice Updates the rebalancer address (ReserveContract). Only callable by LendingFactory auths.\n    function updateRebalancer(address rebalancer_) external;\n}\n\ninterface IFToken is IERC4626, IFTokenAdmin {\n    /// @notice returns minimum amount required for deposit (rounded up)\n    function minDeposit() external view returns (uint256);\n\n    /// @notice returns config, rewards and exchange prices data in a single view method.\n    /// @return liquidity_ address of the Liquidity contract.\n    /// @return lendingFactory_ address of the Lending factory contract.\n    /// @return lendingRewardsRateModel_ address of the rewards rate model contract. changeable by LendingFactory auths.\n    /// @return permit2_ address of the Permit2 contract used for deposits / mint with signature\n    /// @return rebalancer_ address of the rebalancer allowed to execute `rebalance()`\n    /// @return rewardsActive_ true if rewards are currently active\n    /// @return liquidityBalance_ current Liquidity supply balance of `address(this)` for the underyling asset\n    /// @return liquidityExchangePrice_ (updated) exchange price for the underlying assset in the liquidity protocol (without rewards)\n    /// @return tokenExchangePrice_ (updated) exchange price between fToken and the underlying assset (with rewards)\n    function getData()\n        external\n        view\n        returns (\n            IFluidLiquidity liquidity_,\n            IFluidLendingFactory lendingFactory_,\n            IFluidLendingRewardsRateModel lendingRewardsRateModel_,\n            IAllowanceTransfer permit2_,\n            address rebalancer_,\n            bool rewardsActive_,\n            uint256 liquidityBalance_,\n            uint256 liquidityExchangePrice_,\n            uint256 tokenExchangePrice_\n        );\n\n    /// @notice transfers `amount_` of `token_` to liquidity. Only callable by liquidity contract.\n    /// @dev this callback is used to optimize gas consumption (reducing necessary token transfers).\n    function liquidityCallback(address token_, uint256 amount_, bytes calldata data_) external;\n\n    /// @notice deposit `assets_` amount with Permit2 signature for underlying asset approval.\n    ///         reverts with `fToken__MinAmountOut()` if `minAmountOut_` of shares is not reached.\n    ///         `assets_` must at least be `minDeposit()` amount; reverts otherwise.\n    /// @param assets_ amount of assets to deposit\n    /// @param receiver_ receiver of minted fToken shares\n    /// @param minAmountOut_ minimum accepted amount of shares minted\n    /// @param permit_ Permit2 permit message\n    /// @param signature_  packed signature of signing the EIP712 hash of `permit_`\n    /// @return shares_ amount of minted shares\n    function depositWithSignature(\n        uint256 assets_,\n        address receiver_,\n        uint256 minAmountOut_,\n        IAllowanceTransfer.PermitSingle calldata permit_,\n        bytes calldata signature_\n    ) external returns (uint256 shares_);\n\n    /// @notice mint amount of `shares_` with Permit2 signature for underlying asset approval.\n    ///         Signature should approve a little bit more than expected assets amount (`previewMint()`) to avoid reverts.\n    ///         `shares_` must at least be `minMint()` amount; reverts otherwise.\n    ///         Note there might be tiny inaccuracies between requested `shares_` and actually received shares amount.\n    ///         Recommended to use `deposit()` over mint because it is more gas efficient and less likely to revert.\n    /// @param shares_ amount of shares to mint\n    /// @param receiver_ receiver of minted fToken shares\n    /// @param maxAssets_ maximum accepted amount of assets used as input to mint `shares_`\n    /// @param permit_ Permit2 permit message\n    /// @param signature_  packed signature of signing the EIP712 hash of `permit_`\n    /// @return assets_ deposited assets amount\n    function mintWithSignature(\n        uint256 shares_,\n        address receiver_,\n        uint256 maxAssets_,\n        IAllowanceTransfer.PermitSingle calldata permit_,\n        bytes calldata signature_\n    ) external returns (uint256 assets_);\n}\n\ninterface IFTokenNativeUnderlying is IFToken {\n    /// @notice address that is mapped to the chain native token at Liquidity\n    function NATIVE_TOKEN_ADDRESS() external view returns (address);\n\n    /// @notice deposits `msg.value` amount of native token for `receiver_`.\n    ///         `msg.value` must be at least `minDeposit()` amount; reverts otherwise.\n    ///         Recommended to use `depositNative()` with a `minAmountOut_` param instead to set acceptable limit.\n    /// @return shares_ actually minted shares\n    function depositNative(address receiver_) external payable returns (uint256 shares_);\n\n    /// @notice same as {depositNative} but with an additional setting for minimum output amount.\n    /// reverts with `fToken__MinAmountOut()` if `minAmountOut_` of shares is not reached\n    function depositNative(address receiver_, uint256 minAmountOut_) external payable returns (uint256 shares_);\n\n    /// @notice mints `shares_` for `receiver_`, paying with underlying native token.\n    ///         `shares_` must at least be `minMint()` amount; reverts otherwise.\n    ///         `shares_` set to type(uint256).max not supported.\n    ///         Note there might be tiny inaccuracies between requested `shares_` and actually received shares amount.\n    ///         Recommended to use `depositNative()` over mint because it is more gas efficient and less likely to revert.\n    ///         Recommended to use `mintNative()` with a `minAmountOut_` param instead to set acceptable limit.\n    /// @return assets_ deposited assets amount\n    function mintNative(uint256 shares_, address receiver_) external payable returns (uint256 assets_);\n\n    /// @notice same as {mintNative} but with an additional setting for minimum output amount.\n    /// reverts with `fToken__MaxAmount()` if `maxAssets_` of assets is surpassed to mint `shares_`.\n    function mintNative(\n        uint256 shares_,\n        address receiver_,\n        uint256 maxAssets_\n    ) external payable returns (uint256 assets_);\n\n    /// @notice withdraws `assets_` amount in native underlying to `receiver_`, burning shares of `owner_`.\n    ///         If `assets_` equals uint256.max then the whole fToken balance of `owner_` is withdrawn.This does not\n    ///         consider withdrawal limit at liquidity so best to check with `maxWithdraw()` before.\n    ///         Note there might be tiny inaccuracies between requested `assets_` and actually received assets amount.\n    ///         Recommended to use `withdrawNative()` with a `maxSharesBurn_` param instead to set acceptable limit.\n    /// @return shares_ burned shares\n    function withdrawNative(uint256 assets_, address receiver_, address owner_) external returns (uint256 shares_);\n\n    /// @notice same as {withdrawNative} but with an additional setting for minimum output amount.\n    /// reverts with `fToken__MaxAmount()` if `maxSharesBurn_` of shares burned is surpassed.\n    function withdrawNative(\n        uint256 assets_,\n        address receiver_,\n        address owner_,\n        uint256 maxSharesBurn_\n    ) external returns (uint256 shares_);\n\n    /// @notice redeems `shares_` to native underlying to `receiver_`, burning shares of `owner_`.\n    ///         If `shares_` equals uint256.max then the whole balance of `owner_` is withdrawn.This does not\n    ///         consider withdrawal limit at liquidity so best to check with `maxRedeem()` before.\n    ///         Recommended to use `withdrawNative()` over redeem because it is more gas efficient and can set specific amount.\n    ///         Recommended to use `redeemNative()` with a `minAmountOut_` param instead to set acceptable limit.\n    /// @return assets_ withdrawn assets amount\n    function redeemNative(uint256 shares_, address receiver_, address owner_) external returns (uint256 assets_);\n\n    /// @notice same as {redeemNative} but with an additional setting for minimum output amount.\n    /// reverts with `fToken__MinAmountOut()` if `minAmountOut_` of assets is not reached.\n    function redeemNative(\n        uint256 shares_,\n        address receiver_,\n        address owner_,\n        uint256 minAmountOut_\n    ) external returns (uint256 assets_);\n\n    /// @notice withdraw amount of `assets_` in native token with ERC-2612 permit signature for fToken approval.\n    /// `owner_` signs ERC-2612 permit `signature_` to give allowance of fTokens to `msg.sender`.\n    /// Note there might be tiny inaccuracies between requested `assets_` and actually received assets amount.\n    /// allowance via signature should cover `previewWithdraw(assets_)` plus a little buffer to avoid revert.\n    /// Inherent trust assumption that `msg.sender` will set `receiver_` and `minAmountOut_` as `owner_` intends\n    /// (which is always the case when giving allowance to some spender).\n    /// @param sharesToPermit_ shares amount to use for EIP2612 permit(). Should cover `previewWithdraw(assets_)` + small buffer.\n    /// @param assets_ amount of assets to withdraw\n    /// @param receiver_ receiver of withdrawn assets\n    /// @param owner_ owner to withdraw from (must be signature signer)\n    /// @param maxSharesBurn_ maximum accepted amount of shares burned\n    /// @param deadline_ deadline for signature validity\n    /// @param signature_  packed signature of signing the EIP712 hash for ERC-2612 permit\n    /// @return shares_ burned shares amount\n    function withdrawWithSignatureNative(\n        uint256 sharesToPermit_,\n        uint256 assets_,\n        address receiver_,\n        address owner_,\n        uint256 maxSharesBurn_,\n        uint256 deadline_,\n        bytes calldata signature_\n    ) external returns (uint256 shares_);\n\n    /// @notice redeem amount of `shares_` as native token with ERC-2612 permit signature for fToken approval.\n    /// `owner_` signs ERC-2612 permit `signature_` to give allowance of fTokens to `msg.sender`.\n    /// Note there might be tiny inaccuracies between requested `shares_` to redeem and actually burned shares.\n    /// allowance via signature must cover `shares_` plus a tiny buffer.\n    /// Inherent trust assumption that `msg.sender` will set `receiver_` and `minAmountOut_` as `owner_` intends\n    ///       (which is always the case when giving allowance to some spender).\n    /// Recommended to use `withdrawNative()` over redeem because it is more gas efficient and can set specific amount.\n    /// @param shares_ amount of shares to redeem\n    /// @param receiver_ receiver of withdrawn assets\n    /// @param owner_ owner to withdraw from (must be signature signer)\n    /// @param minAmountOut_ minimum accepted amount of assets withdrawn\n    /// @param deadline_ deadline for signature validity\n    /// @param signature_  packed signature of signing the EIP712 hash for ERC-2612 permit\n    /// @return assets_ withdrawn assets amount\n    function redeemWithSignatureNative(\n        uint256 shares_,\n        address receiver_,\n        address owner_,\n        uint256 minAmountOut_,\n        uint256 deadline_,\n        bytes calldata signature_\n    ) external returns (uint256 assets_);\n}\n"
    },
    "contracts/protocols/lending/interfaces/iLendingFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\n\ninterface IFluidLendingFactoryAdmin {\n    /// @notice reads if a certain `auth_` address is an allowed auth or not. Owner is auth by default.\n    function isAuth(address auth_) external view returns (bool);\n\n    /// @notice              Sets an address as allowed auth or not. Only callable by owner.\n    /// @param auth_         address to set auth value for\n    /// @param allowed_      bool flag for whether address is allowed as auth or not\n    function setAuth(address auth_, bool allowed_) external;\n\n    /// @notice reads if a certain `deployer_` address is an allowed deployer or not. Owner is deployer by default.\n    function isDeployer(address deployer_) external view returns (bool);\n\n    /// @notice              Sets an address as allowed deployer or not. Only callable by owner.\n    /// @param deployer_     address to set deployer value for\n    /// @param allowed_      bool flag for whether address is allowed as deployer or not\n    function setDeployer(address deployer_, bool allowed_) external;\n\n    /// @notice              Sets the `creationCode_` bytecode for a certain `fTokenType_`. Only callable by auths.\n    /// @param fTokenType_   the fToken Type used to refer the creation code\n    /// @param creationCode_ contract creation code. can be set to bytes(0) to remove a previously available `fTokenType_`\n    function setFTokenCreationCode(string memory fTokenType_, bytes calldata creationCode_) external;\n\n    /// @notice creates token for `asset_` for a lending protocol with interest. Only callable by deployers.\n    /// @param  asset_              address of the asset\n    /// @param  fTokenType_         type of fToken:\n    /// - if it's the native token, it should use `NativeUnderlying`\n    /// - otherwise it should use `fToken`\n    /// - could be more types available, check `fTokenTypes()`\n    /// @param  isNativeUnderlying_ flag to signal fToken type that uses native underlying at Liquidity\n    /// @return token_              address of the created token\n    function createToken(\n        address asset_,\n        string calldata fTokenType_,\n        bool isNativeUnderlying_\n    ) external returns (address token_);\n}\n\ninterface IFluidLendingFactory is IFluidLendingFactoryAdmin {\n    /// @notice list of all created tokens\n    function allTokens() external view returns (address[] memory);\n\n    /// @notice list of all fToken types that can be deployed\n    function fTokenTypes() external view returns (string[] memory);\n\n    /// @notice returns the creation code for a certain `fTokenType_`\n    function fTokenCreationCode(string memory fTokenType_) external view returns (bytes memory);\n\n    /// @notice address of the Liquidity contract.\n    function LIQUIDITY() external view returns (IFluidLiquidity);\n\n    /// @notice computes deterministic token address for `asset_` for a lending protocol\n    /// @param  asset_      address of the asset\n    /// @param  fTokenType_         type of fToken:\n    /// - if it's the native token, it should use `NativeUnderlying`\n    /// - otherwise it should use `fToken`\n    /// - could be more types available, check `fTokenTypes()`\n    /// @return token_      detemrinistic address of the computed token\n    function computeToken(address asset_, string calldata fTokenType_) external view returns (address token_);\n}\n"
    },
    "contracts/protocols/lending/interfaces/iLendingRewardsRateModel.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidLendingRewardsRateModel {\n    /// @notice Calculates the current rewards rate (APR)\n    /// @param totalAssets_ amount of assets in the lending\n    /// @return rate_ rewards rate percentage per year with 1e12 RATE_PRECISION, e.g. 1e12 = 1%, 1e14 = 100%\n    /// @return ended_ flag to signal that rewards have ended (always 0 going forward)\n    /// @return startTime_ start time of rewards to compare against last update timestamp\n    function getRate(uint256 totalAssets_) external view returns (uint256 rate_, bool ended_, uint256 startTime_);\n\n    /// @notice Returns config constants for rewards rate model\n    function getConfig()\n        external\n        view\n        returns (\n            uint256 duration_,\n            uint256 startTime_,\n            uint256 endTime_,\n            uint256 startTvl_,\n            uint256 maxRate_,\n            uint256 rewardAmount_,\n            address initiator_\n        );\n}\n"
    },
    "contracts/protocols/lending/interfaces/permit2/iAllowanceTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// @title AllowanceTransfer\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\n/// @dev Requires user's token approval on the Permit2 contract\n/// from https://github.com/Uniswap/permit2/blob/main/src/interfaces/ISignatureTransfer.sol.\n/// Copyright (c) 2022 Uniswap Labs\ninterface IAllowanceTransfer {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /// @notice Thrown when an allowance on a token has expired.\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\n    error AllowanceExpired(uint256 deadline);\n\n    /// @notice Thrown when an allowance on a token has been depleted.\n    /// @param amount The maximum amount allowed\n    error InsufficientAllowance(uint256 amount);\n\n    /// @notice Thrown when too many nonces are invalidated.\n    error ExcessiveInvalidation();\n\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\n    event NonceInvalidation(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint48 newNonce,\n        uint48 oldNonce\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\n    event Approval(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\n    event Lockdown(address indexed owner, address token, address spender);\n\n    /// @notice The permit data for a token\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice The permit message signed for a single token allownce\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The permit message signed for multiple token allowances\n    struct PermitBatch {\n        // the permit data for multiple token allowances\n        PermitDetails[] details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The saved permissions\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice A token spender pair.\n    struct TokenSpenderPair {\n        // the token the spender is approved\n        address token;\n        // the spender address\n        address spender;\n    }\n\n    /// @notice Details for a token transfer.\n    struct AllowanceTransferDetails {\n        // the owner of the token\n        address from;\n        // the recipient of the token\n        address to;\n        // the amount of the token\n        uint160 amount;\n        // the token to be transferred\n        address token;\n    }\n\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\n    function allowance(\n        address user,\n        address token,\n        address spender\n    ) external view returns (uint160 amount, uint48 expiration, uint48 nonce);\n\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\n    /// @param token The token to approve\n    /// @param spender The spender address to approve\n    /// @param amount The approved amount of the token\n    /// @param expiration The timestamp at which the approval is no longer valid\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n\n    /// @notice Transfer approved tokens from one address to another\n    /// @param from The address to transfer from\n    /// @param to The address of the recipient\n    /// @param amount The amount of the token to transfer\n    /// @param token The token address to transfer\n    /// @dev Requires the from address to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n\n    /// @notice Transfer approved tokens in a batch\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\n    /// @dev Requires the from addresses to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n\n    /// @notice Enables performing a \"lockdown\" of the sender's Permit2 identity\n    /// by batch revoking approvals\n    /// @param approvals Array of approvals to revoke.\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n\n    /// @notice Invalidate nonces for a given (token, spender) pair\n    /// @param token The token to invalidate nonces for\n    /// @param spender The spender to invalidate nonces for\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVault.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\ninterface IFluidVault {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice returns the vault id\n    function TYPE() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Tokens {\n        address token0;\n        address token1;\n    }\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address operateImplementation;\n        address adminImplementation;\n        address secondaryImplementation;\n        address deployer; // address which deploys oracle\n        address supply; // either liquidity layer or DEX protocol\n        address borrow; // either liquidity layer or DEX protocol\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\n        uint256 vaultId;\n        uint256 vaultType;\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n\n    function rebalance(\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_\n    ) external returns (int supplyAmt_, int borrowAmt_);\n\n    /// @notice reverts with FluidLiquidateResult\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\ninterface IFluidVaultFactory is IERC721Enumerable {\n    /// @notice Minting an NFT Vault for the user\n    function mint(uint256 vaultId_, address user_) external returns (uint256 tokenId_);\n\n    /// @notice returns owner of Vault which is also an NFT\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /// @notice Global auth is auth for all vaults\n    function isGlobalAuth(address auth_) external view returns (bool);\n\n    /// @notice Vault auth is auth for a specific vault\n    function isVaultAuth(address vault_, address auth_) external view returns (bool);\n\n    /// @notice Total vaults deployed.\n    function totalVaults() external view returns (uint256);\n\n    /// @notice Compute vaultAddress\n    function getVaultAddress(uint256 vaultId) external view returns (address);\n\n    /// @notice read uint256 `result_` for a storage `slot_` key\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT1.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidVaultT1 {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address adminImplementation;\n        address secondaryImplementation;\n        address supplyToken;\n        address borrowToken;\n        uint8 supplyDecimals;\n        uint8 borrowDecimals;\n        uint vaultId;\n        bytes32 liquiditySupplyExchangePriceSlot;\n        bytes32 liquidityBorrowExchangePriceSlot;\n        bytes32 liquidityUserSupplySlot;\n        bytes32 liquidityUserBorrowSlot;\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    function operate(\n        uint256 nftId_, // if 0 then new position\n        int256 newCol_, // if negative then withdraw\n        int256 newDebt_, // if negative then payback\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint actualDebtAmt_, uint actualColAmt_);\n\n    function absorb() external;\n\n    function rebalance() external payable returns (int supplyAmt_, int borrowAmt_);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n}\n"
    },
    "solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}