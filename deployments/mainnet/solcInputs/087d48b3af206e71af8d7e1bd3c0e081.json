{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/infiniteProxy/interfaces/iProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IProxy {\n    function setAdmin(address newAdmin_) external;\n\n    function setDummyImplementation(address newDummyImplementation_) external;\n\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\n\n    function removeImplementation(address implementation_) external;\n\n    function getAdmin() external view returns (address);\n\n    function getDummyImplementation() external view returns (address);\n\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\n\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/liquidity/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    /// @notice struct to set borrow rate data for version 1\n    struct RateDataV1Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\n        uint256 kink;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink;\n        ///\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set borrow rate data for version 2\n    struct RateDataV2Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\n        uint256 kink1;\n        ///\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\n        uint256 kink2;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink1;\n        ///\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\n        uint256 rateAtUtilizationKink2;\n        ///\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set token config\n    struct TokenConfig {\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\n        uint256 fee;\n        ///\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\n        uint256 threshold;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/liquidity/interfaces/iLiquidity.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IProxy } from \"../../infiniteProxy/interfaces/iProxy.sol\";\nimport { Structs as AdminModuleStructs } from \"../adminModule/structs.sol\";\n\ninterface IFluidLiquidityAdmin {\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\n    /// @param authsStatus_ array of structs setting allowed status for an address.\n    ///                     status true => add auth, false => remove auth\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\n\n    /// @notice adds/removes guardians. Only callable by Governance.\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\n    ///                         status true => add guardian, false => remove guardian\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\n\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\n    /// @param revenueCollector_  new revenue collector address\n    function updateRevenueCollector(address revenueCollector_) external;\n\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\n    /// @param newStatus_ new status\n    ///        status = 2 -> pause, status = 1 -> resume.\n    function changeStatus(uint256 newStatus_) external;\n\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\n\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\n\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\n    ///         Only callable by Auths.\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\n\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\n    ///         Only callable by Auths.\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\n\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\n\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\n\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to pause operations for\n    /// @param supplyTokens_  token addresses to pause withdrawals for\n    /// @param borrowTokens_  token addresses to pause borrowings for\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to unpause operations for\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\n    /// @param borrowTokens_  token addresses to unpause borrowings for\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\n    /// @param tokens_  array of tokens to collect revenue for\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\n    function collectRevenue(address[] calldata tokens_) external;\n\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\n    /// @param tokens_ tokens to update exchange prices for\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\n    function updateExchangePrices(\n        address[] calldata tokens_\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\n}\n\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\n    /// @notice Single function which handles supply, withdraw, borrow & payback\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\n    /// @param withdrawTo_ if withdrawal then to which address\n    /// @param borrowTo_ if borrow then to which address\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\n    /// @return memVar3_ updated supplyExchangePrice\n    /// @return memVar4_ updated borrowExchangePrice\n    /// @dev to trigger skipping in / out transfers when in&out amounts balance themselves out (gas optimization):\n    /// -   supply(+) == borrow(+), withdraw(-) == payback(-).\n    /// -   `withdrawTo_` / `borrowTo_` must be msg.sender (protocol)\n    /// -   `callbackData_` MUST be encoded so that \"from\" address is at last 20 bytes (if this optimization is desired),\n    ///     also for native token operations where liquidityCallback is not triggered!\n    ///     from address must come at last position if there is more data. I.e. encode like:\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\n}\n\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\n"
    },
    "contracts/periphery/resolvers/liquidity/iLiquidityResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Structs as LiquidityStructs } from \"../../../periphery/resolvers/liquidity/structs.sol\";\n\ninterface IFluidLiquidityResolver {\n    /// @notice gets the `revenueAmount_` for a `token_`.\n    function getRevenue(address token_) external view returns (uint256 revenueAmount_);\n\n    /// @notice address of contract that gets sent the revenue. Configurable by governance\n    function getRevenueCollector() external view returns (address);\n\n    /// @notice Liquidity contract paused status: status = 1 -> normal. status = 2 -> paused.\n    function getStatus() external view returns (uint256);\n\n    /// @notice checks if `auth_` is an allowed auth on Liquidity.\n    /// Auths can set most config values. E.g. contracts that automate certain flows like e.g. adding a new fToken.\n    /// Governance can add/remove auths. Governance is auth by default.\n    function isAuth(address auth_) external view returns (uint256);\n\n    /// @notice checks if `guardian_` is an allowed Guardian on Liquidity.\n    /// Guardians can pause lower class users.\n    /// Governance can add/remove guardians. Governance is guardian by default.\n    function isGuardian(address guardian_) external view returns (uint256);\n\n    /// @notice gets user class for `user_`. Class defines which protocols can be paused by guardians.\n    /// Currently there are 2 classes: 0 can be paused by guardians. 1 cannot be paused by guardians.\n    /// New protocols are added as class 0 and will be upgraded to 1 over time.\n    function getUserClass(address user_) external view returns (uint256);\n\n    /// @notice gets exchangePricesAndConfig packed uint256 storage slot for `token_`.\n    function getExchangePricesAndConfig(address token_) external view returns (uint256);\n\n    /// @notice gets rateConfig packed uint256 storage slot for `token_`.\n    function getRateConfig(address token_) external view returns (uint256);\n\n    /// @notice gets totalAmounts packed uint256 storage slot for `token_`.\n    function getTotalAmounts(address token_) external view returns (uint256);\n\n    /// @notice gets userSupply data packed uint256 storage slot for `user_` and `token_`.\n    function getUserSupply(address user_, address token_) external view returns (uint256);\n\n    /// @notice gets userBorrow data packed uint256 storage slot for `user_` and `token_`.\n    function getUserBorrow(address user_, address token_) external view returns (uint256);\n\n    /// @notice returns all `listedTokens_` at the Liquidity contract. Once configured, a token can never be removed.\n    function listedTokens() external view returns (address[] memory listedTokens_);\n\n    /// @notice get the Rate config data `rateData_` for a `token_` compiled from the packed uint256 rateConfig storage slot\n    function getTokenRateData(address token_) external view returns (LiquidityStructs.RateData memory rateData_);\n\n    /// @notice get the Rate config datas `rateDatas_` for multiple `tokens_` compiled from the packed uint256 rateConfig storage slot\n    function getTokensRateData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.RateData[] memory rateDatas_);\n\n    /// @notice returns general data for `token_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokenData(\n        address token_\n    ) external view returns (LiquidityStructs.OverallTokenData memory overallTokenData_);\n\n    /// @notice returns general data for multiple `tokens_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokensData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserSupplyData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData memory userSupplyData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleSupplyData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserBorrowData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData memory userBorrowData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleBorrowData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `supplyTokens_`\n    ///     and returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `borrowTokens_`\n    function getUserMultipleBorrowSupplyData(\n        address user_,\n        address[] calldata supplyTokens_,\n        address[] calldata borrowTokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallSupplyTokensData_,\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallBorrowTokensData_\n        );\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs as AdminModuleStructs } from \"../../../liquidity/adminModule/structs.sol\";\n\nabstract contract Structs {\n    struct RateData {\n        uint256 version;\n        AdminModuleStructs.RateDataV1Params rateDataV1;\n        AdminModuleStructs.RateDataV2Params rateDataV2;\n    }\n\n    struct OverallTokenData {\n        uint256 borrowRate;\n        uint256 supplyRate;\n        uint256 fee; // revenue fee\n        uint256 lastStoredUtilization;\n        uint256 storageUpdateThreshold;\n        uint256 lastUpdateTimestamp;\n        uint256 supplyExchangePrice;\n        uint256 borrowExchangePrice;\n        uint256 supplyRawInterest;\n        uint256 supplyInterestFree;\n        uint256 borrowRawInterest;\n        uint256 borrowInterestFree;\n        uint256 totalSupply;\n        uint256 totalBorrow;\n        uint256 revenue;\n        RateData rateData;\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserSupplyData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 supply; // user supply amount\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\n        uint256 withdrawalLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\n        uint256 baseWithdrawalLimit;\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\n        uint256 withdrawableUntilLimit;\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserBorrowData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 borrow; // user borrow amount\n        uint256 borrowLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseBorrowLimit;\n        uint256 maxBorrowLimit;\n        uint256 borrowableUntilLimit;\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance\n    }\n}\n"
    },
    "contracts/periphery/resolvers/steth/iStETHResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IFluidLiquidityResolver } from \"../liquidity/iLiquidityResolver.sol\";\nimport { IFluidStETHQueue } from \"../../../protocols/steth/interfaces/iStETHQueue.sol\";\nimport { ILidoWithdrawalQueue } from \"../../../protocols/steth/interfaces/external/iLidoWithdrawalQueue.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\nimport { Structs as StETHQueueStructs } from \"../../../protocols/steth/structs.sol\";\nimport { Structs as LiquidityStructs } from \"../liquidity/structs.sol\";\n\ninterface IFluidStETHResolver {\n    /// @notice address of the stETHQueue contract\n    function STETH_QUEUE() external view returns (IFluidStETHQueue);\n\n    /// @notice address of the Lido Withdrawal Queue contract (0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1)\n    function LIDO_WITHDRAWAL_QUEUE() external view returns (ILidoWithdrawalQueue);\n\n    /// @notice address of the LiquidityResolver\n    function LIQUIDITY_RESOLVER() external view returns (IFluidLiquidityResolver);\n\n    /// @notice returns all constants and config values\n    function config()\n        external\n        view\n        returns (\n            IFluidLiquidity liquidity_,\n            ILidoWithdrawalQueue lidoWithdrawalQueue_,\n            IERC20 stETH_,\n            address owner_,\n            uint16 maxLTV_,\n            bool allowListActive_,\n            bool isPaused_,\n            LiquidityStructs.UserBorrowData memory userBorrowData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice checks if a linked claim for `claimTo_` and `claimTo_` is ready to be processed at Lido Withdrawal Queue\n    /// @param claimTo_ claimTo receiver to process the claim for\n    /// @param requestIdFrom_ Lido requestId from (start), as emitted at time of queuing via `LogQueue`\n    function isClaimable(address claimTo_, uint256 requestIdFrom_) external view returns (bool);\n\n    /// @notice reads if a certain `auth_` address is an allowed auth or not\n    function isAuth(address auth_) external view returns (bool);\n\n    /// @notice reads if a certain `guardian_` address is an allowed guardian or not\n    function isGuardian(address guardian_) external view returns (bool);\n\n    /// @notice reads if a certain `user_` address is an allowed user or not\n    function isUserAllowed(address user_) external view returns (bool);\n\n    /// @notice reads if the protocol is paused or not\n    function isPaused() external view returns (bool);\n\n    /// @notice reads a Claim struct containing necessary information for executing the claim process from the mapping\n    /// claimTo and requestIdFrom -> claims and the claimable status.\n    function claim(\n        address claimTo_,\n        uint256 requestIdFrom_\n    ) external view returns (StETHQueueStructs.Claim memory claim_, bool isClaimable_);\n\n    /// @notice returns borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for native token\n    function getUserBorrowData()\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData memory userBorrowData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n}\n"
    },
    "contracts/periphery/resolvers/steth/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IFluidLiquidityResolver } from \"../liquidity/iLiquidityResolver.sol\";\nimport { IFluidStETHResolver } from \"./iStETHResolver.sol\";\nimport { IFluidStETHQueue } from \"../../../protocols/steth/interfaces/iStETHQueue.sol\";\nimport { Structs as StETHQueueStructs } from \"../../../protocols/steth/structs.sol\";\nimport { ILidoWithdrawalQueue } from \"../../../protocols/steth/interfaces/external/iLidoWithdrawalQueue.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\nimport { Structs as LiquidityStructs } from \"../liquidity/structs.sol\";\n\n/// @notice Fluid StETH protocol resolver\n/// Implements various view-only methods to give easy access to StETH protocol data.\ncontract FluidStETHResolver is IFluidStETHResolver {\n    /// @inheritdoc IFluidStETHResolver\n    IFluidStETHQueue public immutable STETH_QUEUE;\n\n    /// @inheritdoc IFluidStETHResolver\n    ILidoWithdrawalQueue public immutable LIDO_WITHDRAWAL_QUEUE;\n\n    /// @inheritdoc IFluidStETHResolver\n    IFluidLiquidityResolver public immutable LIQUIDITY_RESOLVER;\n\n    /// @dev address that is mapped to the chain native token at Liquidity\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice thrown if an input param address is zero\n    error FluidStETHResolver__AddressZero();\n    /// @notice thrown if there is no Claim queued for the given input data\n    error FluidStETHResolver__NoClaimQueued();\n\n    constructor(IFluidStETHQueue stEthQueue_, IFluidLiquidityResolver liquidityResolver_, ILidoWithdrawalQueue lidoWithdrawalQueue_) {\n        if (address(stEthQueue_) == address(0) || address(liquidityResolver_) == address(0) || address(lidoWithdrawalQueue_) == address(0)) {\n            revert FluidStETHResolver__AddressZero();\n        }\n\n        STETH_QUEUE = stEthQueue_;\n        LIQUIDITY_RESOLVER = liquidityResolver_;\n        LIDO_WITHDRAWAL_QUEUE = lidoWithdrawalQueue_;\n    }\n\n    /// @inheritdoc IFluidStETHResolver\n    function isClaimable(address claimTo_, uint256 requestIdFrom_) public view returns (bool) {\n        StETHQueueStructs.Claim memory claim_ = STETH_QUEUE.claims(claimTo_, requestIdFrom_);\n\n        if (claim_.checkpoint == 0) {\n            revert FluidStETHResolver__NoClaimQueued();\n        }\n\n        uint256 requestsLength_ = claim_.requestIdTo - requestIdFrom_ + 1;\n        uint256[] memory requestIds_;\n        if (requestsLength_ == 1) {\n            // only one request id\n            requestIds_ = new uint256[](1);\n            requestIds_[0] = requestIdFrom_;\n            return LIDO_WITHDRAWAL_QUEUE.getWithdrawalStatus(requestIds_)[0].isFinalized;\n        }\n\n        // build requestIds array from `requestIdFrom` to `requestIdTo`\n        uint256 curRequest_ = requestIdFrom_;\n        for (uint256 i; i < requestsLength_; ) {\n            requestIds_[i] = curRequest_;\n\n            unchecked {\n                ++i;\n                ++curRequest_;\n            }\n        }\n\n        // get requests statuses\n        ILidoWithdrawalQueue.WithdrawalRequestStatus[] memory statuses_ = LIDO_WITHDRAWAL_QUEUE.getWithdrawalStatus(\n            requestIds_\n        );\n\n        // check for each status that it is finalized\n        for (uint256 i; i < requestsLength_; ) {\n            if (!statuses_[i].isFinalized) {\n                return false;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return true;\n    }\n\n    /// @inheritdoc IFluidStETHResolver\n    function config()\n        public\n        view\n        returns (\n            IFluidLiquidity liquidity_,\n            ILidoWithdrawalQueue lidoWithdrawalQueue_,\n            IERC20 stETH_,\n            address owner_,\n            uint16 maxLTV_,\n            bool allowListActive_,\n            bool isPaused_,\n            LiquidityStructs.UserBorrowData memory userBorrowData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        )\n    {\n        (liquidity_, lidoWithdrawalQueue_, stETH_) = STETH_QUEUE.constantsView();\n        maxLTV_ = STETH_QUEUE.maxLTV();\n        allowListActive_ = STETH_QUEUE.allowListActive();\n        owner_ = STETH_QUEUE.owner();\n        isPaused_ = STETH_QUEUE.isPaused();\n        (userBorrowData_, overallTokenData_) = getUserBorrowData();\n    }\n\n    /// @inheritdoc IFluidStETHResolver\n    function isAuth(address auth_) public view returns (bool) {\n        return STETH_QUEUE.isAuth(auth_);\n    }\n\n    /// @inheritdoc IFluidStETHResolver\n    function isGuardian(address guardian_) public view returns (bool) {\n        return STETH_QUEUE.isGuardian(guardian_);\n    }\n\n    /// @inheritdoc IFluidStETHResolver\n    function isUserAllowed(address user_) public view returns (bool) {\n        return STETH_QUEUE.isUserAllowed(user_);\n    }\n\n    /// @inheritdoc IFluidStETHResolver\n    function isPaused() public view returns (bool) {\n        return STETH_QUEUE.isPaused();\n    }\n\n    /// @inheritdoc IFluidStETHResolver\n    function claim(\n        address claimTo_,\n        uint256 requestIdFrom_\n    ) public view returns (StETHQueueStructs.Claim memory claim_, bool isClaimable_) {\n        claim_ = STETH_QUEUE.claims(claimTo_, requestIdFrom_);\n        isClaimable_ = isClaimable(claimTo_, requestIdFrom_);\n    }\n\n    /// @inheritdoc IFluidStETHResolver\n    function getUserBorrowData()\n        public\n        view\n        returns (\n            LiquidityStructs.UserBorrowData memory userBorrowData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        )\n    {\n        (userBorrowData_, overallTokenData_) = LIQUIDITY_RESOLVER.getUserBorrowData(\n            address(STETH_QUEUE),\n            NATIVE_TOKEN_ADDRESS\n        );\n    }\n}\n"
    },
    "contracts/protocols/steth/interfaces/external/iLidoWithdrawalQueue.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface ILidoWithdrawalQueue {\n    function balanceOf(address) external view returns (uint);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    // code below based on Lido WithdrawalQueueBase.sol\n    // see https://github.com/lidofinance/lido-dao/blob/v2.0.0/contracts/0.8.9/WithdrawalQueueBase.sol\n\n    /// @notice output format struct for `_getWithdrawalStatus()` method\n    struct WithdrawalRequestStatus {\n        /// @notice stETH token amount that was locked on withdrawal queue for this request\n        uint256 amountOfStETH;\n        /// @notice amount of stETH shares locked on withdrawal queue for this request\n        uint256 amountOfShares;\n        /// @notice address that can claim or transfer this request\n        address owner;\n        /// @notice timestamp of when the request was created, in seconds\n        uint256 timestamp;\n        /// @notice true, if request is finalized\n        bool isFinalized;\n        /// @notice true, if request is claimed. Request is claimable if (isFinalized && !isClaimed)\n        bool isClaimed;\n    }\n\n    /// @notice length of the checkpoint array. Last possible value for the hint.\n    ///  NB! checkpoints are indexed from 1, so it returns 0 if there is no checkpoints\n    function getLastCheckpointIndex() external view returns (uint256);\n\n    // code below based on Lido WithdrawalQueue.sol\n    // see https://github.com/lidofinance/lido-dao/blob/v2.0.0/contracts/0.8.9/WithdrawalQueue.sol\n\n    /// @notice Request the batch of stETH for withdrawal. Approvals for the passed amounts should be done before.\n    /// @param _amounts an array of stETH amount values.\n    ///  The standalone withdrawal request will be created for each item in the passed list.\n    /// @param _owner address that will be able to manage the created requests.\n    ///  If `address(0)` is passed, `msg.sender` will be used as owner.\n    /// @return requestIds an array of the created withdrawal request ids\n    function requestWithdrawals(\n        uint256[] calldata _amounts,\n        address _owner\n    ) external returns (uint256[] memory requestIds);\n\n    /// @notice Claim one`_requestId` request once finalized sending locked ether to the owner\n    /// @param _requestId request id to claim\n    /// @dev use unbounded loop to find a hint, which can lead to OOG\n    /// @dev\n    ///  Reverts if requestId or hint are not valid\n    ///  Reverts if request is not finalized or already claimed\n    ///  Reverts if msg sender is not an owner of request\n    function claimWithdrawal(uint256 _requestId) external;\n\n    /// @notice Claim a batch of withdrawal requests if they are finalized sending locked ether to the owner\n    /// @param _requestIds array of request ids to claim\n    /// @param _hints checkpoint hint for each id. Can be obtained with `findCheckpointHints()`\n    /// @dev\n    ///  Reverts if requestIds and hints arrays length differs\n    ///  Reverts if any requestId or hint in arguments are not valid\n    ///  Reverts if any request is not finalized or already claimed\n    ///  Reverts if msg sender is not an owner of the requests\n    function claimWithdrawals(uint256[] calldata _requestIds, uint256[] calldata _hints) external;\n\n    //// @notice Returns all withdrawal requests that belongs to the `_owner` address\n    ///\n    /// WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n    /// to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n    /// this function has an unbounded cost, and using it as part of a state-changing function may render the function\n    /// uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n    function getWithdrawalRequests(address _owner) external view returns (uint256[] memory requestsIds);\n\n    /// @notice Finds the list of hints for the given `_requestIds` searching among the checkpoints with indices\n    ///  in the range  `[_firstIndex, _lastIndex]`.\n    ///  NB! Array of request ids should be sorted\n    ///  NB! `_firstIndex` should be greater than 0, because checkpoint list is 1-based array\n    ///  Usage: findCheckpointHints(_requestIds, 1, getLastCheckpointIndex())\n    /// @param _requestIds ids of the requests sorted in the ascending order to get hints for\n    /// @param _firstIndex left boundary of the search range. Should be greater than 0\n    /// @param _lastIndex right boundary of the search range. Should be less than or equal to getLastCheckpointIndex()\n    /// @return hintIds array of hints used to find required checkpoint for the request\n    function findCheckpointHints(\n        uint256[] calldata _requestIds,\n        uint256 _firstIndex,\n        uint256 _lastIndex\n    ) external view returns (uint256[] memory hintIds);\n\n    /// @notice Returns status for requests with provided ids\n    /// @param _requestIds array of withdrawal request ids\n    function getWithdrawalStatus(\n        uint256[] calldata _requestIds\n    ) external view returns (WithdrawalRequestStatus[] memory statuses);\n\n    /// @notice maximum amount of stETH that is possible to withdraw by a single request\n    /// Prevents accumulating too much funds per single request fulfillment in the future.\n    /// @dev To withdraw larger amounts, it's recommended to split it to several requests\n    function MAX_STETH_WITHDRAWAL_AMOUNT() external view returns (uint256);\n\n    /// @notice minimum amount of stETH that is possible to withdraw by a single request\n    function MIN_STETH_WITHDRAWAL_AMOUNT() external view returns (uint256);\n\n    // code below based on Lido WithdrawalQueueERC721.sol\n    // see https://github.com/lidofinance/lido-dao/blob/v2.0.0/contracts/0.8.9/WithdrawalQueueERC721.sol\n\n    /// @notice Finalize requests from last finalized one up to `_lastRequestIdToBeFinalized`\n    /// @dev ether to finalize all the requests should be calculated using `prefinalize()` and sent along\n    function finalize(uint256 _lastRequestIdToBeFinalized, uint256 _maxShareRate) external payable;\n}\n"
    },
    "contracts/protocols/steth/interfaces/iStETHQueue.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { Structs } from \"../structs.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\nimport { ILidoWithdrawalQueue } from \"../interfaces/external/iLidoWithdrawalQueue.sol\";\n\ninterface IFluidStETHQueue {\n    /// @notice returns the constant values for LIQUIDITY, LIDO_WITHDRAWAL_QUEUE, STETH\n    function constantsView() external view returns (IFluidLiquidity, ILidoWithdrawalQueue, IERC20);\n\n    /// @notice gets an open Claim for `claimTo_` and `requestIdFrom_`\n    function claims(address claimTo_, uint256 requestIdFrom_) external view returns (Structs.Claim memory);\n\n    /// @notice reads if a certain `auth_` address is an allowed auth or not\n    function isAuth(address auth_) external view returns (bool);\n\n    /// @notice reads if a certain `guardian_` address is an allowed guardian or not\n    function isGuardian(address guardian_) external view returns (bool);\n\n    /// @notice reads if a certain `user_` address is an allowed user or not\n    function isUserAllowed(address user_) external view returns (bool);\n\n    /// @notice maximum allowed percentage of LTV (loan-to-value). E.g. 90% -> max. 90 ETH can be borrowed with 100 stETH\n    /// as collateral in withdrawal queue. ETH will be received at time of claim to cover the paid borrowed ETH amount.\n    /// In 1e2 (1% = 100, 90% = 9_000, 100% = 10_000).\n    /// Configurable by auths.\n    function maxLTV() external view returns (uint16);\n\n    /// @notice flag whether allow list behavior is enabled or not.\n    function allowListActive() external view returns (bool);\n\n    /// @notice reads if the protocol is paused or not\n    function isPaused() external view returns (bool);\n\n    /// @notice reads owner address\n    function owner() external view returns (address);\n}\n"
    },
    "contracts/protocols/steth/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    /// @notice Claim data struct for storage link to owner address\n    struct Claim {\n        /// @param borrowAmountRaw raw borrow amount at Liquidity. Multiply with borrowExchangePrice to get normal borrow amount\n        uint128 borrowAmountRaw;\n        /// @param checkpoint checkpoint at time of queue. optimizes finding checkpoint hints range at claim time.\n        uint48 checkpoint;\n        /// @param requestIdTo last request Id linked to the claim\n        uint40 requestIdTo;\n        // 5 bytes empty\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}