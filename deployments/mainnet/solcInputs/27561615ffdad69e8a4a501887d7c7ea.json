{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/deployer/interface.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidContractFactory {\n    function totalContracts() external view returns (uint256);\n\n    function getContractAddress(uint256 nonce_) external view returns (address contractAddress_);\n\n    function deployContract(\n        bytes calldata contractCode_\n    ) external returns (address contractAddress_);\n\n    function updateDeployer(address deployer_, uint16 count_) external;\n\n    function deployer(address deployer_) external view returns (uint256);\n\n}\n"
    },
    "contracts/infiniteProxy/interfaces/iProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IProxy {\n    function setAdmin(address newAdmin_) external;\n\n    function setDummyImplementation(address newDummyImplementation_) external;\n\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\n\n    function removeImplementation(address implementation_) external;\n\n    function getAdmin() external view returns (address);\n\n    function getDummyImplementation() external view returns (address);\n\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\n\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/bigMathMinified.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\nlibrary BigMathMinified {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/bytesSliceAndConcat.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary BytesSliceAndConcat {\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesConcat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    ) internal pure returns (bytes memory tempBytes) {\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesSlice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory tempBytes) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/libraries/dexCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\nimport { DexSlotsLink } from \"./dexSlotsLink.sol\";\n\n/// @notice implements calculation methods used for Fluid Dex such as updated withdrawal / borrow limits.\nlibrary DexCalcs {\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) &\n            X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ = block.timestamp - ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ = block.timestamp - ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n}\n"
    },
    "contracts/libraries/dexSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\nlibrary DexSlotsLink {\n    /// @dev storage slot for variables at Dex\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\n    /// @dev storage slot for variables2 at Dex\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\n    /// @dev storage slot for total supply shares at Dex\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\n    /// @dev storage slot for user supply mapping at Dex\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\n    /// @dev storage slot for total borrow shares at Dex\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\n    /// @dev storage slot for user borrow mapping at Dex\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\n    /// @dev storage slot for oracle mapping at Dex\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\n    /// @dev storage slot for range and threshold shifts at Dex\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\n    /// @dev storage slot for center price shift at Dex\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n}\n"
    },
    "contracts/libraries/fluidProtocolTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ninterface IFluidProtocol {\n    function TYPE() external view returns (uint256);\n}\n\n/// @notice implements helper methods to filter Fluid protocols by a certain type\nlibrary FluidProtocolTypes {\n    uint256 internal constant VAULT_T1_TYPE = 10000; // VaultT1 borrow protocol type vaults\n    uint256 internal constant VAULT_T2_SMART_COL_TYPE = 20000; // DEX protocol type vault\n    uint256 internal constant VAULT_T3_SMART_DEBT_TYPE = 30000; // DEX protocol type vault\n    uint256 internal constant VAULT_T4_SMART_COL_SMART_DEBT_TYPE = 40000; // DEX protocol type vault\n\n    /// @dev filters input `addresses_` by protocol `type_`. Input addresses must be actual Fluid protocols, otherwise\n    ///      they would be wrongly assumed to be VaultT1 even if they are not Fluid VaultT1 smart contracts.\n    ///      `type_` must be a listed constant type of this library.\n    ///      Example usage is to filter all vault addresses at the Vault factory by a certain type, e.g. to not include\n    ///      DEX protocol type vaults.\n    function filterBy(address[] memory addresses_, uint256 type_) internal view returns (address[] memory filtered_) {\n        uint256 curType_;\n        uint256 filteredProtocols_ = addresses_.length;\n        for (uint256 i; i < addresses_.length; ) {\n            try IFluidProtocol(addresses_[i]).TYPE() returns (uint256 protocolType_) {\n                curType_ = protocolType_;\n            } catch {\n                curType_ = VAULT_T1_TYPE;\n            }\n\n            if (curType_ != type_) {\n                addresses_[i] = address(0);\n                --filteredProtocols_;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        filtered_ = new address[](filteredProtocols_);\n        uint256 index_;\n        unchecked {\n            for (uint256 i; i < addresses_.length; ) {\n                if (addresses_[i] != address(0)) {\n                    filtered_[index_] = addresses_[i];\n                    ++index_;\n                }\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/liquidityCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\nimport { LiquiditySlotsLink } from \"./liquiditySlotsLink.sol\";\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\n\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\n/// borrow rate, withdrawal / borrow limits, revenue amount.\nlibrary LiquidityCalcs {\n    error FluidLiquidityCalcsError(uint256 errorId_);\n\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\n    event BorrowRateMaxCap();\n\n    /// @dev constants as from Liquidity variables.sol\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X15 = 0x7fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                  CALC EXCHANGE PRICES                  /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\n    function calcExchangePrices(\n        uint256 exchangePricesAndConfig_\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\n        // Extracting exchange prices\n        supplyExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\n            X64;\n        borrowExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\n            X64;\n\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\n        }\n\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\n\n        unchecked {\n            // last timestamp can not be > current timestamp\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\n\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\n                X15;\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // calculate new borrow exchange price.\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\n            borrowExchangePrice_ +=\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\n\n            // FOR SUPPLY EXCHANGE PRICE:\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\n            //\n            // Example:\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\n            // yield is 10 (so half a year must have passed).\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 20%) = 62,5%\n            // supplyRate = (40% * (100% - 10%)) * = 36% * 62,5% = 22.5%\n            // increase in supplyExchangePrice, assuming 100 as previous price.\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\n\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\n\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\n\n            if (temp_ == 1) {\n                // if no raw supply: no exchange price update needed\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\n            if (temp_ & 1 == 1) {\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n                temp_ = temp_ >> 1;\n\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\n                // in the if statement a little above.\n\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\n                // so ratioSupplyYield must come out as 2.5 (250%).\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\n                temp_ =\n                    // utilization * (100% + 100% / supplyRatio)\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\n                    (FOUR_DECIMALS);\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\n            } else {\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n                temp_ = temp_ >> 1;\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\n\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\n                temp_ =\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\n                    (1e27 *\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\n                        (FOUR_DECIMALS + temp_)) /\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\n            }\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\n\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\n            if (borrowRatio_ & 1 == 1) {\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\n\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\n            } else {\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\n            }\n\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\n\n            // 2. calculate supply rate\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\n            // but more suppliers not earning interest.\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\n                temp_ * // ratioSupplyYield\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\n\n            // 3. calculate increase in supply exchange price\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                     CALC REVENUE                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\n    /// and the current balance of the Fluid liquidity contract for the token.\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\n    /// @return revenueAmount_ collectable revenue amount\n    function calcRevenue(\n        uint256 totalAmounts_,\n        uint256 exchangePricesAndConfig_,\n        uint256 liquidityTokenBalance_\n    ) internal view returns (uint256 revenueAmount_) {\n        // @dev no need to super-optimize this method as it is only used by admin\n\n        // calculate the new exchange prices based on earned interest\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\n\n        // total supply = interest free + with interest converted from raw\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\n\n        if (totalSupply_ > 0) {\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\n            // ensure there is no possible case because of rounding etc. where this would revert,\n            // explicitly check if >\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\n            // can only be revenue.\n        } else {\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\n            revenueAmount_ = liquidityTokenBalance_;\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ =\n                block.timestamp -\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ =\n                block.timestamp -\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC RATES                        /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev Calculates new borrow rate from utilization for a token\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\n        // extract rate version: 4 bits (0xF) starting from bit 0\n        uint256 rateVersion_ = (rateData_ & 0xF);\n\n        if (rateVersion_ == 1) {\n            rate_ = calcRateV1(rateData_, utilization_);\n        } else if (rateVersion_ == 2) {\n            rate_ = calcRateV2(rateData_, utilization_);\n        } else {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\n        }\n\n        if (rate_ > X16) {\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\n            // this is unlikely to ever happen if configs stay within expected levels.\n            rate_ = X16;\n            // emit event to more easily become aware\n            emit BorrowRateMaxCap();\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e2 precision\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v1 (one kink) ------------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // else utilization is greater than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\n            x1_ = kink1_;\n            x2_ = FOUR_DECIMALS; // 100%\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e4 precision\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v2 (two kinks) -----------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 156 bits => 100-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink1\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\n            if (utilization_ < kink2_) {\n                // if utilization is less than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                x1_ = kink1_;\n                x2_ = kink2_;\n            } else {\n                // else utilization is greater than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\n                x1_ = kink2_;\n                x2_ = FOUR_DECIMALS;\n            }\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\n    function getTotalSupply(\n        uint256 totalAmounts_,\n        uint256 supplyExchangePrice_\n    ) internal pure returns (uint256 totalSupply_) {\n        // totalSupply_ => supplyInterestFree\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\n    function getTotalBorrow(\n        uint256 totalAmounts_,\n        uint256 borrowExchangePrice_\n    ) internal pure returns (uint256 totalBorrow_) {\n        // totalBorrow_ => borrowInterestFree\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n}\n"
    },
    "contracts/libraries/liquiditySlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\nlibrary LiquiditySlotsLink {\n    /// @dev storage slot for status at Liquidity\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\n    /// @dev storage slot for auths mapping at Liquidity\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\n    /// @dev storage slot for guardians mapping at Liquidity\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\n    /// @dev storage slot for user class mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\n    /// @dev storage slot for rateData mapping at Liquidity\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\n    /// @dev storage slot for totalAmounts mapping at Liquidity\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\n    /// @dev storage slot for user supply double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\n    /// @dev storage slot for user borrow double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // ExchangePricesAndConfig\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\n\n    // RateData:\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\n    // RateData: V1\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\n    // RateData: V2\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\n\n    // TotalAmounts\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\n\n    // Configs2\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/safeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\n\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\nlibrary SafeTransfer {\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 20000; // pass max. 20k gas for native transfers\n\n    error FluidSafeTransferError(uint256 errorId_);\n\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from_\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of `token_` to `to_`.\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of ` native token to `to_`.\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\n    function safeTransferNative(address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n}\n"
    },
    "contracts/libraries/storageRead.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements a method to read uint256 data from storage at a bytes32 storage slot key.\ncontract StorageRead {\n    function readFromStorage(bytes32 slot_) public view returns (uint256 result_) {\n        assembly {\n            result_ := sload(slot_) // read value from the storage slot\n        }\n    }\n}\n"
    },
    "contracts/liquidity/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    /// @notice struct to set borrow rate data for version 1\n    struct RateDataV1Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\n        uint256 kink;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink;\n        ///\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set borrow rate data for version 2\n    struct RateDataV2Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\n        uint256 kink1;\n        ///\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\n        uint256 kink2;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink1;\n        ///\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\n        uint256 rateAtUtilizationKink2;\n        ///\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set token config\n    struct TokenConfig {\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\n        uint256 fee;\n        ///\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\n        uint256 threshold;\n        ///\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\n        uint256 maxUtilization;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/liquidity/interfaces/iLiquidity.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IProxy } from \"../../infiniteProxy/interfaces/iProxy.sol\";\nimport { Structs as AdminModuleStructs } from \"../adminModule/structs.sol\";\n\ninterface IFluidLiquidityAdmin {\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\n    /// @param authsStatus_ array of structs setting allowed status for an address.\n    ///                     status true => add auth, false => remove auth\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\n\n    /// @notice adds/removes guardians. Only callable by Governance.\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\n    ///                         status true => add guardian, false => remove guardian\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\n\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\n    /// @param revenueCollector_  new revenue collector address\n    function updateRevenueCollector(address revenueCollector_) external;\n\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\n    /// @param newStatus_ new status\n    ///        status = 2 -> pause, status = 1 -> resume.\n    function changeStatus(uint256 newStatus_) external;\n\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\n\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\n\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\n    ///         Only callable by Auths.\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\n\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\n    ///         Only callable by Auths.\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\n\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param token_ token address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\n\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\n\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to pause operations for\n    /// @param supplyTokens_  token addresses to pause withdrawals for\n    /// @param borrowTokens_  token addresses to pause borrowings for\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to unpause operations for\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\n    /// @param borrowTokens_  token addresses to unpause borrowings for\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\n    /// @param tokens_  array of tokens to collect revenue for\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\n    function collectRevenue(address[] calldata tokens_) external;\n\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\n    /// @param tokens_ tokens to update exchange prices for\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\n    function updateExchangePrices(\n        address[] calldata tokens_\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\n}\n\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\n    /// @notice Single function which handles supply, withdraw, borrow & payback\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\n    /// @param withdrawTo_ if withdrawal then to which address\n    /// @param borrowTo_ if borrow then to which address\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\n    /// @return memVar3_ updated supplyExchangePrice\n    /// @return memVar4_ updated borrowExchangePrice\n    /// @dev to trigger skipping in / out transfers (gas optimization):\n    /// -  ` callbackData_` MUST be encoded so that \"from\" address is the last 20 bytes in the last 32 bytes slot,\n    ///     also for native token operations where liquidityCallback is not triggered!\n    ///     from address must come at last position if there is more data. I.e. encode like:\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\n    /// -   this \"from\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\n    ///     in the slot before (bytes 32 to 63)\n    /// -   `msg.value` must be 0.\n    /// -   Amounts must be either:\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\n}\n\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\n"
    },
    "contracts/periphery/resolvers/dex/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidityResolver } from \"../liquidity/iLiquidityResolver.sol\";\nimport { IFluidDexFactory } from \"../../../protocols/dex/interfaces/iDexFactory.sol\";\n\ninterface IFluidLiquidity {\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n\nabstract contract Variables {\n    IFluidDexFactory public immutable FACTORY;\n    IFluidLiquidity public immutable LIQUIDITY;\n    IFluidLiquidityResolver public immutable LIQUIDITY_RESOLVER;\n    /// @dev Address of contract used for deploying center price & hook related contract\n    address public immutable DEPLOYER_CONTRACT;\n\n    uint256 internal constant X2 = 0x3;\n    uint256 internal constant X3 = 0x7;\n    uint256 internal constant X5 = 0x1f;\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X8 = 0xff;\n    uint256 internal constant X9 = 0x1ff;\n    uint256 internal constant X10 = 0x3ff;\n    uint256 internal constant X11 = 0x7ff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X17 = 0x1ffff;\n    uint256 internal constant X20 = 0xfffff;\n    uint256 internal constant X22 = 0x3fffff;\n    uint256 internal constant X23 = 0x7fffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X28 = 0xfffffff;\n    uint256 internal constant X30 = 0x3fffffff;\n    uint256 internal constant X32 = 0xffffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X40 = 0xffffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    /// @dev address that is mapped to the chain native token\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    constructor(address factory_, address liquidity_, address liquidityResolver_, address deployer_) {\n        FACTORY = IFluidDexFactory(factory_);\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        LIQUIDITY_RESOLVER = IFluidLiquidityResolver(liquidityResolver_);\n        DEPLOYER_CONTRACT = deployer_;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexReserves/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { DexSlotsLink } from \"../../../libraries/dexSlotsLink.sol\";\nimport { BytesSliceAndConcat } from \"../../../libraries/bytesSliceAndConcat.sol\";\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { Variables } from \"./variables.sol\";\nimport { Structs } from \"./structs.sol\";\n\n/// @title DexFactoryViews\n/// @notice Abstract contract providing view functions for DEX factory-related operations\nabstract contract DexFactoryViews is Variables {\n    /// @notice Get the address of a Pool given its ID\n    /// @param poolId_ The ID of the Pool\n    /// @return pool_ The address of the Pool\n    function getPoolAddress(uint256 poolId_) public view returns (address pool_) {\n        return AddressCalcs.addressCalc(address(FACTORY), poolId_);\n    }\n\n    /// @notice Get the total number of Pools\n    /// @return The total number of Pools\n    function getTotalPools() public view returns (uint) {\n        return FACTORY.totalDexes();\n    }\n\n    /// @notice Get an array of all Pool addresses\n    /// @return pools_ An array containing all Pool addresses\n    function getAllPoolAddresses() public view returns (address[] memory pools_) {\n        uint totalPools_ = getTotalPools();\n        pools_ = new address[](totalPools_);\n        for (uint i = 0; i < totalPools_; i++) {\n            pools_[i] = getPoolAddress((i + 1));\n        }\n    }\n}\n\n/// @title DexPublicViews\n/// @notice Abstract contract providing view functions for DEX public data\nabstract contract DexPublicViews {\n    /// @notice Get the prices and exchange prices for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return pex_ A struct containing prices and exchange prices\n    /// @dev expected to be called via callStatic\n    function getDexPricesAndExchangePrices(\n        address dex_\n    ) public returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n        try IFluidDexT1(dex_).getPricesAndExchangePrices() {} catch (bytes memory lowLevelData_) {\n            bytes4 errorSelector_;\n            assembly {\n                // Extract the selector from the error data\n                errorSelector_ := mload(add(lowLevelData_, 0x20))\n            }\n            if (errorSelector_ == IFluidDexT1.FluidDexPricesAndExchangeRates.selector) {\n                pex_ = abi.decode(\n                    BytesSliceAndConcat.bytesSlice(lowLevelData_, 4, lowLevelData_.length - 4),\n                    (IFluidDexT1.PricesAndExchangePrice)\n                );\n            }\n        }\n    }\n\n    /// @notice Get the collateral reserves for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing collateral reserve information\n    /// @dev expected to be called via callStatic\n    function getDexCollateralReserves(address dex_) public returns (IFluidDexT1.CollateralReserves memory reserves_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        if ((dexVariables2_ & 1) != 1) {\n            // smart col not enabled\n            return IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            try\n                IFluidDexT1(dex_).getCollateralReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.supplyToken0ExchangePrice,\n                    pex_.supplyToken1ExchangePrice\n                )\n            returns (IFluidDexT1.CollateralReserves memory colReserves_) {\n                reserves_ = colReserves_;\n            } catch {\n                reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n            }\n        } catch {\n            reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n    }\n\n    /// @notice Get the debt reserves for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing debt reserve information\n    /// @dev expected to be called via callStatic\n    function getDexDebtReserves(address dex_) public returns (IFluidDexT1.DebtReserves memory reserves_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        if ((dexVariables2_ & 2) != 2) {\n            // smart debt not enabled\n            return IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            try\n                IFluidDexT1(dex_).getDebtReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.borrowToken0ExchangePrice,\n                    pex_.borrowToken1ExchangePrice\n                )\n            returns (IFluidDexT1.DebtReserves memory debtReserves_) {\n                reserves_ = debtReserves_;\n            } catch {\n                reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n            }\n        } catch {\n            reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n    }\n}\n\n/// @title DexConstantsViews\n/// @notice Abstract contract providing view functions for DEX constants\nabstract contract DexConstantsViews {\n    /// @notice returns all Pool constants\n    function getPoolConstantsView(address pool_) public view returns (IFluidDexT1.ConstantViews memory constantsView_) {\n        return IFluidDexT1(pool_).constantsView();\n    }\n\n    /// @notice returns all Pool constants 2\n    function getPoolConstantsView2(\n        address pool_\n    ) public view returns (IFluidDexT1.ConstantViews2 memory constantsView2_) {\n        return IFluidDexT1(pool_).constantsView2();\n    }\n\n    /// @notice Get the addresses of the tokens in a Pool\n    /// @param pool_ The address of the Pool\n    /// @return token0_ The address of token0 in the Pool\n    /// @return token1_ The address of token1 in the Pool\n    function getPoolTokens(address pool_) public view returns (address token0_, address token1_) {\n        IFluidDexT1.ConstantViews memory constantsView_ = IFluidDexT1(pool_).constantsView();\n        return (constantsView_.token0, constantsView_.token1);\n    }\n}\n\nabstract contract DexActionEstimates {\n    address private constant ADDRESS_DEAD = 0x000000000000000000000000000000000000dEaD;\n\n    /// @notice estimates swap IN tokens execution\n    /// @param dex_ Dex pool\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function estimateSwapIn(\n        address dex_,\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_\n    ) public payable returns (uint256 amountOut_) {\n        try IFluidDexT1(dex_).swapIn{ value: msg.value }(swap0to1_, amountIn_, amountOutMin_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (amountOut_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSwapResult.selector);\n        }\n    }\n\n    /// @notice estimates swap OUT tokens execution\n    /// @param dex_ Dex pool\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function estimateSwapOut(\n        address dex_,\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_\n    ) public payable returns (uint256 amountIn_) {\n        try IFluidDexT1(dex_).swapOut{ value: msg.value }(swap0to1_, amountOut_, amountInMax_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (amountIn_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSwapResult.selector);\n        }\n    }\n\n    function _decodeLowLevelUint1x(\n        bytes memory lowLevelData_,\n        bytes4 targetErrorSelector_\n    ) internal pure returns (uint value1_) {\n        if (lowLevelData_.length < 36) {\n            return 0;\n        }\n\n        bytes4 errorSelector_;\n        assembly {\n            // Extract the selector from the error data\n            errorSelector_ := mload(add(lowLevelData_, 0x20))\n        }\n        if (errorSelector_ == targetErrorSelector_) {\n            assembly {\n                value1_ := mload(add(lowLevelData_, 36))\n            }\n        }\n        // else => values remain 0\n    }\n}\n\n/// @notice Fluid Dex Reserves resolver\n/// Implements various view-only methods to give easy access to Dex protocol reserves data.\ncontract FluidDexReservesResolver is\n    Variables,\n    Structs,\n    DexFactoryViews,\n    DexConstantsViews,\n    DexPublicViews,\n    DexActionEstimates\n{\n    constructor(address factory_) Variables(factory_) {}\n\n    /// @notice Get a Pool's address and its token addresses\n    /// @param poolId_ The ID of the Pool\n    /// @return pool_ The Pool data\n    function getPool(uint256 poolId_) public view returns (Pool memory pool_) {\n        address poolAddress_ = getPoolAddress(poolId_);\n        (address token0_, address token1_) = getPoolTokens(poolAddress_);\n        return Pool(poolAddress_, token0_, token1_, getPoolFee(poolAddress_));\n    }\n\n    /// @notice Get a Pool's fee\n    /// @param pool_ The Pool address\n    /// @return fee_ The Pool fee as 1% = 10000\n    function getPoolFee(address pool_) public view returns (uint256 fee_) {\n        uint256 dexVariables2_ = IFluidDexT1(pool_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        return (dexVariables2_ >> 2) & X17;\n    }\n\n    /// @notice Get an array of all Pool addresses and their token addresses\n    /// @return pools_ An array containing all Pool data\n    function getAllPools() public view returns (Pool[] memory pools_) {\n        uint256 totalPools_ = getTotalPools();\n        pools_ = new Pool[](totalPools_);\n        for (uint256 i; i < totalPools_; i++) {\n            pools_[i] = getPool(i + 1);\n        }\n    }\n\n    /// @notice Get the token addresses, collateral reserves, and debt reserves for a given Pool address\n    /// @param pool_ The Pool address\n    /// @return poolReserves_ The Pool data with reserves\n    /// @dev expected to be called via callStatic\n    function getPoolReserves(address pool_) public returns (PoolWithReserves memory poolReserves_) {\n        (address token0_, address token1_) = getPoolTokens(pool_);\n        IFluidDexT1.CollateralReserves memory collateralReserves_ = getDexCollateralReserves(pool_);\n        IFluidDexT1.DebtReserves memory debtReserves_ = getDexDebtReserves(pool_);\n        return PoolWithReserves(pool_, token0_, token1_, getPoolFee(pool_), collateralReserves_, debtReserves_);\n    }\n\n    /// @notice Get an array of Pool addresses, their token addresses, collateral reserves, and debt reserves for a given array of Pool addresses\n    /// @param pools_ The array of Pool addresses\n    /// @return poolsReserves_ An array containing all Pool data with reserves\n    /// @dev expected to be called via callStatic\n    function getPoolsReserves(address[] memory pools_) public returns (PoolWithReserves[] memory poolsReserves_) {\n        poolsReserves_ = new PoolWithReserves[](pools_.length);\n        for (uint256 i; i < pools_.length; i++) {\n            poolsReserves_[i] = getPoolReserves(pools_[i]);\n        }\n    }\n\n    /// @notice Get an array of all Pool addresses, their token addresses, collateral reserves, and debt reserves\n    /// @return poolsReserves_ An array containing all Pool data with reserves\n    /// @dev expected to be called via callStatic\n    function getAllPoolsReserves() public returns (PoolWithReserves[] memory poolsReserves_) {\n        return getPoolsReserves(getAllPoolAddresses());\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexReserves/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\n\nabstract contract Structs {\n    struct Pool {\n        address pool;\n        address token0;\n        address token1;\n        uint256 fee;\n    }\n\n    struct PoolWithReserves {\n        address pool;\n        address token0;\n        address token1;\n        uint256 fee;\n        IFluidDexT1.CollateralReserves collateralReserves;\n        IFluidDexT1.DebtReserves debtReserves;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexReserves/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidDexFactory } from \"../../../protocols/dex/interfaces/iDexFactory.sol\";\n\nabstract contract Variables {\n    uint256 internal constant X17 = 0x1ffff;\n\n    IFluidDexFactory public immutable FACTORY;\n\n    constructor(address factory_) {\n        FACTORY = IFluidDexFactory(factory_);\n    }\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/iLiquidityResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Structs as LiquidityStructs } from \"../../../periphery/resolvers/liquidity/structs.sol\";\n\ninterface IFluidLiquidityResolver {\n    /// @notice gets the `revenueAmount_` for a `token_`.\n    function getRevenue(address token_) external view returns (uint256 revenueAmount_);\n\n    /// @notice address of contract that gets sent the revenue. Configurable by governance\n    function getRevenueCollector() external view returns (address);\n\n    /// @notice Liquidity contract paused status: status = 1 -> normal. status = 2 -> paused.\n    function getStatus() external view returns (uint256);\n\n    /// @notice checks if `auth_` is an allowed auth on Liquidity.\n    /// Auths can set most config values. E.g. contracts that automate certain flows like e.g. adding a new fToken.\n    /// Governance can add/remove auths. Governance is auth by default.\n    function isAuth(address auth_) external view returns (uint256);\n\n    /// @notice checks if `guardian_` is an allowed Guardian on Liquidity.\n    /// Guardians can pause lower class users.\n    /// Governance can add/remove guardians. Governance is guardian by default.\n    function isGuardian(address guardian_) external view returns (uint256);\n\n    /// @notice gets user class for `user_`. Class defines which protocols can be paused by guardians.\n    /// Currently there are 2 classes: 0 can be paused by guardians. 1 cannot be paused by guardians.\n    /// New protocols are added as class 0 and will be upgraded to 1 over time.\n    function getUserClass(address user_) external view returns (uint256);\n\n    /// @notice gets exchangePricesAndConfig packed uint256 storage slot for `token_`.\n    function getExchangePricesAndConfig(address token_) external view returns (uint256);\n\n    /// @notice gets rateConfig packed uint256 storage slot for `token_`.\n    function getRateConfig(address token_) external view returns (uint256);\n\n    /// @notice gets totalAmounts packed uint256 storage slot for `token_`.\n    function getTotalAmounts(address token_) external view returns (uint256);\n\n    /// @notice gets configs2 packed uint256 storage slot for `token_`.\n    function getConfigs2(address token_) external view returns (uint256);\n\n    /// @notice gets userSupply data packed uint256 storage slot for `user_` and `token_`.\n    function getUserSupply(address user_, address token_) external view returns (uint256);\n\n    /// @notice gets userBorrow data packed uint256 storage slot for `user_` and `token_`.\n    function getUserBorrow(address user_, address token_) external view returns (uint256);\n\n    /// @notice returns all `listedTokens_` at the Liquidity contract. Once configured, a token can never be removed.\n    function listedTokens() external view returns (address[] memory listedTokens_);\n\n    /// @notice get the Rate config data `rateData_` for a `token_` compiled from the packed uint256 rateConfig storage slot\n    function getTokenRateData(address token_) external view returns (LiquidityStructs.RateData memory rateData_);\n\n    /// @notice get the Rate config datas `rateDatas_` for multiple `tokens_` compiled from the packed uint256 rateConfig storage slot\n    function getTokensRateData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.RateData[] memory rateDatas_);\n\n    /// @notice returns general data for `token_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokenData(\n        address token_\n    ) external view returns (LiquidityStructs.OverallTokenData memory overallTokenData_);\n\n    /// @notice returns general data for multiple `tokens_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokensData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns general data for all `listedTokens()` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getAllOverallTokensData()\n        external\n        view\n        returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserSupplyData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData memory userSupplyData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleSupplyData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserBorrowData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData memory userBorrowData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleBorrowData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `supplyTokens_`\n    ///     and returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `borrowTokens_`\n    function getUserMultipleBorrowSupplyData(\n        address user_,\n        address[] calldata supplyTokens_,\n        address[] calldata borrowTokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallSupplyTokensData_,\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallBorrowTokensData_\n        );\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs as AdminModuleStructs } from \"../../../liquidity/adminModule/structs.sol\";\n\nabstract contract Structs {\n    struct RateData {\n        uint256 version;\n        AdminModuleStructs.RateDataV1Params rateDataV1;\n        AdminModuleStructs.RateDataV2Params rateDataV2;\n    }\n\n    struct OverallTokenData {\n        uint256 borrowRate;\n        uint256 supplyRate;\n        uint256 fee; // revenue fee\n        uint256 lastStoredUtilization;\n        uint256 storageUpdateThreshold;\n        uint256 lastUpdateTimestamp;\n        uint256 supplyExchangePrice;\n        uint256 borrowExchangePrice;\n        uint256 supplyRawInterest;\n        uint256 supplyInterestFree;\n        uint256 borrowRawInterest;\n        uint256 borrowInterestFree;\n        uint256 totalSupply;\n        uint256 totalBorrow;\n        uint256 revenue;\n        uint256 maxUtilization; // maximum allowed utilization\n        RateData rateData;\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserSupplyData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 supply; // user supply amount\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\n        uint256 withdrawalLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\n        uint256 baseWithdrawalLimit;\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\n        uint256 withdrawableUntilLimit;\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserBorrowData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 borrow; // user borrow amount\n        uint256 borrowLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseBorrowLimit;\n        uint256 maxBorrowLimit;\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\n    }\n}\n"
    },
    "contracts/protocols/dex/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs } from \"./poolT1/coreModule/structs.sol\";\n\nabstract contract Error {\n    error FluidDexError(uint256 errorId_);\n\n    error FluidDexFactoryError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares_);\n\n    error FluidDexPricesAndExchangeRates(Structs.PricesAndExchangePrice pex_);\n}\n"
    },
    "contracts/protocols/dex/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |             DexT1                 | \n    |__________________________________*/\n\n    /// @notice thrown at reentrancy\n    uint256 internal constant DexT1__AlreadyEntered = 51001;\n\n    uint256 internal constant DexT1__NotAnAuth = 51002;\n\n    uint256 internal constant DexT1__SmartColNotEnabled = 51003;\n\n    uint256 internal constant DexT1__SmartDebtNotEnabled = 51004;\n\n    uint256 internal constant DexT1__PoolNotInitialized = 51005;\n\n    uint256 internal constant DexT1__TokenReservesTooLow = 51006;\n\n    uint256 internal constant DexT1__EthAndAmountInMisMatch = 51007;\n\n    uint256 internal constant DexT1__EthSentForNonNativeSwap = 51008;\n\n    uint256 internal constant DexT1__NoSwapRoute = 51009;\n\n    uint256 internal constant DexT1__NotEnoughAmountOut = 51010;\n\n    uint256 internal constant DexT1__LiquidityLayerTokenUtilizationCapReached = 51011;\n\n    uint256 internal constant DexT1__HookReturnedFalse = 51012;\n\n    // Either user's config are not set or user is paused\n    uint256 internal constant DexT1__UserSupplyInNotOn = 51013;\n\n    // Either user's config are not set or user is paused\n    uint256 internal constant DexT1__UserDebtInNotOn = 51014;\n\n    // Thrown when contract asks for more token0 or token1 than what user's wants to give on deposit\n    uint256 internal constant DexT1__AboveDepositMax = 51015;\n\n    uint256 internal constant DexT1__MsgValueLowOnDepositOrPayback = 51016;\n\n    uint256 internal constant DexT1__WithdrawLimitReached = 51017;\n\n    // Thrown when contract gives less token0 or token1 than what user's wants on withdraw\n    uint256 internal constant DexT1__BelowWithdrawMin = 51018;\n\n    uint256 internal constant DexT1__DebtLimitReached = 51019;\n\n    // Thrown when contract gives less token0 or token1 than what user's wants on borrow\n    uint256 internal constant DexT1__BelowBorrowMin = 51020;\n\n    // Thrown when contract asks for more token0 or token1 than what user's wants on payback\n    uint256 internal constant DexT1__AbovePaybackMax = 51021;\n\n    uint256 internal constant DexT1__InvalidDepositAmts = 51022;\n\n    uint256 internal constant DexT1__DepositAmtsZero = 51023;\n\n    uint256 internal constant DexT1__SharesMintedLess = 51024;\n\n    uint256 internal constant DexT1__WithdrawalNotEnough = 51025;\n\n    uint256 internal constant DexT1__InvalidWithdrawAmts = 51026;\n\n    uint256 internal constant DexT1__WithdrawAmtsZero = 51027;\n\n    uint256 internal constant DexT1__WithdrawExcessSharesBurn = 51028;\n\n    uint256 internal constant DexT1__InvalidBorrowAmts = 51029;\n\n    uint256 internal constant DexT1__BorrowAmtsZero = 51030;\n\n    uint256 internal constant DexT1__BorrowExcessSharesMinted = 51031;\n\n    uint256 internal constant DexT1__PaybackAmtTooHigh = 51032;\n\n    uint256 internal constant DexT1__InvalidPaybackAmts = 51033;\n\n    uint256 internal constant DexT1__PaybackAmtsZero = 51034;\n\n    uint256 internal constant DexT1__PaybackSharedBurnedLess = 51035;\n\n    uint256 internal constant DexT1__NothingToArbitrage = 51036;\n\n    uint256 internal constant DexT1__MsgSenderNotLiquidity = 51037;\n\n    // On liquidity callback reentrancy bit should be on\n    uint256 internal constant DexT1__ReentrancyBitShouldBeOn = 51038;\n\n    // Thrown is reentrancy is already on and someone tries to fetch oracle price. Should not be possible to this\n    uint256 internal constant DexT1__OraclePriceFetchAlreadyEntered = 51039;\n\n    // Thrown when swap changes the current price by more than 5%\n    uint256 internal constant DexT1__OracleUpdateHugeSwapDiff = 51040;\n\n    uint256 internal constant DexT1__Token0ShouldBeSmallerThanToken1 = 51041;\n\n    uint256 internal constant DexT1__OracleMappingOverflow = 51042;\n\n    /// @notice thrown if governance has paused the swapping & arbitrage so only perfect functions are usable\n    uint256 internal constant DexT1__SwapAndArbitragePaused = 51043;\n\n    uint256 internal constant DexT1__ExceedsAmountInMax = 51044;\n\n    /// @notice thrown if amount in is too high or too low\n    uint256 internal constant DexT1__SwapInLimitingAmounts = 51045;\n\n    /// @notice thrown if amount out is too high or too low\n    uint256 internal constant DexT1__SwapOutLimitingAmounts = 51046;\n\n    uint256 internal constant DexT1__MintAmtOverflow = 51047;\n\n    uint256 internal constant DexT1__BurnAmtOverflow = 51048;\n\n    uint256 internal constant DexT1__LimitingAmountsSwapAndNonPerfectActions = 51049;\n\n    uint256 internal constant DexT1__InsufficientOracleData = 51050;\n\n    uint256 internal constant DexT1__SharesAmountInsufficient = 51051;\n\n    uint256 internal constant DexT1__CenterPriceOutOfRange = 51052;\n\n    uint256 internal constant DexT1__DebtReservesTooLow = 51053;\n\n    uint256 internal constant DexT1__SwapAndDepositTooLowOrTooHigh = 51054;\n\n    uint256 internal constant DexT1__WithdrawAndSwapTooLowOrTooHigh = 51055;\n\n    uint256 internal constant DexT1__BorrowAndSwapTooLowOrTooHigh = 51056;\n\n    uint256 internal constant DexT1__SwapAndPaybackTooLowOrTooHigh = 51057;\n\n    uint256 internal constant DexT1__InvalidImplementation = 51058;\n\n    uint256 internal constant DexT1__OnlyDelegateCallAllowed = 51059;\n\n    uint256 internal constant DexT1__IncorrectDataLength = 51060;\n\n    uint256 internal constant DexT1__AmountToSendLessThanAmount = 51061;\n\n    uint256 internal constant DexT1__InvalidCollateralReserves = 51062;\n\n    uint256 internal constant DexT1__InvalidDebtReserves = 51063;\n\n    /***********************************|\n    |            DEX Admin              | \n    |__________________________________*/\n\n    /// @notice thrown when pool is not initialized\n    uint256 internal constant DexT1Admin__PoolNotInitialized = 52001;\n\n    uint256 internal constant DexT1Admin__SmartColIsAlreadyOn = 52002;\n\n    uint256 internal constant DexT1Admin__SmartDebtIsAlreadyOn = 52003;\n\n    /// @notice thrown when any of the configs value overflow the maximum limit\n    uint256 internal constant DexT1Admin__ConfigOverflow = 52004;\n\n    uint256 internal constant DexT1Admin__AddressNotAContract = 52005;\n\n    uint256 internal constant DexT1Admin__InvalidParams = 52006;\n\n    uint256 internal constant DexT1Admin__UserNotDefined = 52007;\n\n    uint256 internal constant DexT1Admin__OnlyDelegateCallAllowed = 52008;\n\n    uint256 internal constant DexT1Admin__UnexpectedPoolState = 52009;\n\n    /// @notice thrown when trying to pause or unpause but user is already in the target pause state\n    uint256 internal constant DexT1Admin__InvalidPauseToggle = 52009;\n\n    /***********************************|\n    |            DEX Factory            | \n    |__________________________________*/\n\n    uint256 internal constant DexFactory__InvalidOperation = 53001;\n    uint256 internal constant DexFactory__Unauthorized = 53002;\n    uint256 internal constant DexFactory__SameTokenNotAllowed = 53003;\n    uint256 internal constant DexFactory__TokenConfigNotProper = 53004;\n    uint256 internal constant DexFactory__InvalidParams = 53005;\n    uint256 internal constant DexFactory__OnlyDelegateCallAllowed = 53006;\n    uint256 internal constant DexFactory__InvalidDexAddress = 53007;\n}\n"
    },
    "contracts/protocols/dex/factory/deploymentHelpers/miniDeployer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Owned } from \"solmate/src/auth/Owned.sol\";\n\n/// @title MiniDeployer\n/// @notice A contract that allows deployers to deploy any contract by passing the contract data in bytes\n/// @dev The main objective of this contract is to avoid storing contract addresses in our protocols which requires 160 bits of storage\n///      Instead, we can just store the nonce & deployment of this address to calculate the address realtime using \"AddressCalcs\" library\ncontract MiniDeployer is Owned {\n    /// @notice Thrown when an invalid operation is attempted\n    error MiniDeployer__InvalidOperation();\n\n    /// @notice Emitted when a new contract is deployed\n    event LogContractDeployed(address indexed contractAddress);\n\n    /// @notice Constructor to initialize the contract\n    /// @param owner_ The address of the contract owner\n    constructor(address owner_) Owned(owner_) {}\n\n    /// @notice Internal function to deploy a contract\n    /// @param bytecode_ The bytecode of the contract to deploy\n    /// @return address_ The address of the deployed contract\n    /// @dev Uses inline assembly for efficient deployment\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\n        if (bytecode_.length == 0) {\n            revert MiniDeployer__InvalidOperation();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\n        }\n        if (address_ == address(0)) {\n            revert MiniDeployer__InvalidOperation();\n        }\n    }\n\n    /// @notice Deploys a new contract\n    /// @param contractCode_ The bytecode of the contract to deploy\n    /// @return contractAddress_ The address of the deployed contract\n    /// @dev Decrements the deployer's allowed deployments count if not the owner\n    function deployContract(bytes calldata contractCode_) external onlyOwner returns (address contractAddress_) {\n        contractAddress_ = _deploy(contractCode_);\n\n        emit LogContractDeployed(contractAddress_);\n    }\n}\n"
    },
    "contracts/protocols/dex/factory/deploymentLogics/poolT1Logic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SSTORE2 } from \"solmate/src/utils/SSTORE2.sol\";\n\nimport { Error } from \"../../error.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { IFluidDexFactory } from \"../../interfaces/iDexFactory.sol\";\nimport { MiniDeployer } from \"../deploymentHelpers/miniDeployer.sol\";\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\nimport { BytesSliceAndConcat } from \"../../../../libraries/bytesSliceAndConcat.sol\";\n\nimport { IFluidDexT1 } from \"../../interfaces/iDexT1.sol\";\nimport { FluidDexT1Shift } from \"../../poolT1/coreModule/core/shift.sol\";\nimport { FluidDexT1Admin } from \"../../poolT1/adminModule/main.sol\";\nimport { FluidDexT1 } from \"../../poolT1/coreModule/core/main.sol\";\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ncontract FluidDexT1DeploymentLogic is Error {\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev SSTORE2 pointer for the PoolT1 creation code. Stored externally to reduce factory bytecode (in 2 parts)\n    address internal immutable POOL_T1_CREATIONCODE_ADDRESS_1;\n    address internal immutable POOL_T1_CREATIONCODE_ADDRESS_2;\n\n    /// @dev SSTORE2 pointers for the creation code of various operations contracts\n    address internal immutable COL_OPERATIONS_CREATIONCODE_ADDRESS;\n    address internal immutable DEBT_OPERATIONS_CREATIONCODE_ADDRESS;\n    address internal immutable PERFECT_OPERATIONS_AND_SWAP_OUT_CREATIONCODE_ADDRESS;\n\n    /// @notice address of liquidity contract\n    address public immutable LIQUIDITY;\n\n    /// @notice address of dexfactory contract\n    address public immutable DEX_FACTORY;\n\n    /// @notice address of Admin implementation\n    address public immutable ADMIN_IMPLEMENTATION;\n\n    /// @notice address of Shift implementation\n    address public immutable SHIFT_IMPLEMENTATION;\n\n    /// @notice address of Deployer Contract\n    address public immutable CONTRACT_DEPLOYER;\n\n    /// @notice address of MiniDeployer Contract\n    MiniDeployer public immutable MINI_DEPLOYER;\n\n    /// @notice address of this contract\n    address public immutable ADDRESS_THIS;\n\n    /// @notice Emitted when a new dexT1 is deployed.\n    /// @param dex The address of the newly deployed dex.\n    /// @param dexId The id of the newly deployed dex.\n    /// @param supplyToken The address of the supply token.\n    /// @param borrowToken The address of the borrow token.\n    event DexT1Deployed(address indexed dex, uint256 dexId, address indexed supplyToken, address indexed borrowToken);\n\n    /// @dev                            Deploys a contract using the CREATE opcode with the provided bytecode (`bytecode_`).\n    ///                                 This is an internal function, meant to be used within the contract to facilitate the deployment of other contracts.\n    /// @param bytecode_                The bytecode of the contract to be deployed.\n    /// @return address_                Returns the address of the deployed contract.\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\n        if (bytecode_.length == 0) {\n            revert FluidDexError(ErrorTypes.DexFactory__InvalidOperation);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\n        }\n        if (address_ == address(0)) {\n            revert FluidDexError(ErrorTypes.DexFactory__InvalidOperation);\n        }\n    }\n\n    constructor(\n        address liquidity_,\n        address dexFactory_,\n        address contractDeployer_,\n        address colOperations_,\n        address debtOperations_,\n        address perfectOperationsAndSwapOut_,\n        address mainAddress1_,\n        address mainAddress2_\n    ) {\n        LIQUIDITY = liquidity_;\n        DEX_FACTORY = dexFactory_;\n        CONTRACT_DEPLOYER = contractDeployer_;\n\n        \n        POOL_T1_CREATIONCODE_ADDRESS_1 = mainAddress1_;\n        POOL_T1_CREATIONCODE_ADDRESS_2 = mainAddress2_;\n\n        ADDRESS_THIS = address(this);\n\n        // Deploy mini deployer\n        MINI_DEPLOYER = new MiniDeployer(DEX_FACTORY);\n\n        // Deploy admin implementation\n        FluidDexT1Admin adminImplementation = new FluidDexT1Admin();\n        ADMIN_IMPLEMENTATION = address(adminImplementation);\n\n        // Deploy shift implementation\n        FluidDexT1Shift shiftImplementation = new FluidDexT1Shift(CONTRACT_DEPLOYER);\n        SHIFT_IMPLEMENTATION = address(shiftImplementation);\n\n        COL_OPERATIONS_CREATIONCODE_ADDRESS = colOperations_;\n        DEBT_OPERATIONS_CREATIONCODE_ADDRESS = debtOperations_;\n        PERFECT_OPERATIONS_AND_SWAP_OUT_CREATIONCODE_ADDRESS = perfectOperationsAndSwapOut_;\n    }\n\n    function dexT1(\n        address token0_,\n        address token1_,\n        uint256 oracleMapping_\n    ) external returns (bytes memory dexCreationBytecode_) {\n        if (address(this) == ADDRESS_THIS) revert FluidDexError(ErrorTypes.DexFactory__OnlyDelegateCallAllowed);\n\n        if (token0_ == token1_) revert FluidDexError(ErrorTypes.DexFactory__SameTokenNotAllowed);\n        if (token0_ > token1_) revert FluidDexError(ErrorTypes.DexFactory__TokenConfigNotProper);\n\n        IFluidDexT1.ConstantViews memory constants_;\n        constants_.liquidity = LIQUIDITY;\n        constants_.factory = address(this);\n        constants_.implementations.shift = SHIFT_IMPLEMENTATION;\n        constants_.deployerContract = CONTRACT_DEPLOYER;\n        constants_.token0 = token0_;\n        constants_.token1 = token1_;\n        constants_.dexId = IFluidDexFactory(address(this)).totalDexes();\n        constants_.oracleMapping = oracleMapping_;\n\n        address dex_ = IFluidDexFactory(address(this)).getDexAddress(constants_.dexId);\n\n        constants_ = _calculateLiquidityDexSlots(constants_, dex_);\n\n        // Deploy perfect operations and oracle implementation\n        address perfectOperationsAndOracle_ = MINI_DEPLOYER.deployContract(\n            abi.encodePacked(perfectOperationsCreationCode(), abi.encode(constants_))\n        );\n\n        // Deploy col operations implementation through mini deployer\n        address colOperations_ = MINI_DEPLOYER.deployContract(\n            abi.encodePacked(colOperationsCreationCode(), abi.encode(constants_))\n        );\n\n        // Deploy debt operations implementation\n        address debtOperations_ = MINI_DEPLOYER.deployContract(\n            abi.encodePacked(debtOperationsCreationCode(), abi.encode(constants_))\n        );\n\n        constants_.implementations.admin = ADMIN_IMPLEMENTATION;\n        constants_.implementations.perfectOperationsAndOracle = perfectOperationsAndOracle_;\n        constants_.implementations.colOperations = colOperations_;\n        constants_.implementations.debtOperations = debtOperations_;\n\n        dexCreationBytecode_ = abi.encodePacked(dexT1CreationBytecode(), abi.encode(constants_));\n\n        emit DexT1Deployed(dex_, constants_.dexId, token0_, token1_);\n\n        return dexCreationBytecode_;\n    }\n\n    /// @notice returns the stored DexT1 creation bytecode\n    function dexT1CreationBytecode() public view returns (bytes memory) {\n        return BytesSliceAndConcat.bytesConcat(SSTORE2.read(POOL_T1_CREATIONCODE_ADDRESS_1), SSTORE2.read(POOL_T1_CREATIONCODE_ADDRESS_2));\n    }\n\n    /// @dev Retrieves the creation code for the FluidDexT1OperationsCol contract\n    function colOperationsCreationCode() public view returns (bytes memory) {\n        return SSTORE2.read(COL_OPERATIONS_CREATIONCODE_ADDRESS);\n    }\n\n    /// @dev Retrieves the creation code for the FluidDexT1OperationsDebt contract\n    function debtOperationsCreationCode() public view returns (bytes memory) {\n        return SSTORE2.read(DEBT_OPERATIONS_CREATIONCODE_ADDRESS);\n    }\n\n    /// @dev Retrieves the creation code for the FluidDexT1PerfectOperations contract\n    function perfectOperationsCreationCode() public view returns (bytes memory) {\n        return SSTORE2.read(PERFECT_OPERATIONS_AND_SWAP_OUT_CREATIONCODE_ADDRESS);\n    }\n\n    /// @dev                          Calculates the liquidity dex slots for the given supply token, borrow token, and dex (`dex_`).\n    /// @param constants_             Constants struct as used in Dex T1\n    /// @param dex_                   The address of the dex.\n    /// @return liquidityDexSlots_    Returns the calculated liquidity dex slots set in the `IFluidDexT1.ConstantViews` struct.\n    function _calculateLiquidityDexSlots(\n        IFluidDexT1.ConstantViews memory constants_,\n        address dex_\n    ) private pure returns (IFluidDexT1.ConstantViews memory) {\n        constants_.supplyToken0Slot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n            dex_,\n            constants_.token0\n        );\n        constants_.borrowToken0Slot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n            dex_,\n            constants_.token0\n        );\n        constants_.supplyToken1Slot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n            dex_,\n            constants_.token1\n        );\n        constants_.borrowToken1Slot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n            dex_,\n            constants_.token1\n        );\n        constants_.exchangePriceToken0Slot = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            constants_.token0\n        );\n        constants_.exchangePriceToken1Slot = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            constants_.token1\n        );\n\n        return constants_;\n    }\n\n}\n"
    },
    "contracts/protocols/dex/factory/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Owned } from \"solmate/src/auth/Owned.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { StorageRead } from \"../../../libraries/storageRead.sol\";\n\nabstract contract DexFactoryVariables is Owned, StorageRead, Error {\n    /*//////////////////////////////////////////////////////////////\n                          STORAGE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    // ------------ storage variables from inherited contracts (Owned) come before vars here --------\n\n    // ----------------------- slot 0 ---------------------------\n    // address public owner; // from Owned\n\n    // 12 bytes empty\n\n    // ----------------------- slot 1  ---------------------------\n    /// @dev deployer can deploy new Dex Pool contract\n    /// owner can add/remove deployer.\n    /// Owner is deployer by default.\n    mapping(address => bool) internal _deployers;\n\n    // ----------------------- slot 2  ---------------------------\n    /// @dev global auths can update any dex pool config.\n    /// owner can add/remove global auths.\n    /// Owner is global auth by default.\n    mapping(address => bool) internal _globalAuths;\n\n    // ----------------------- slot 3  ---------------------------\n    /// @dev dex auths can update specific dex config.\n    /// owner can add/remove dex auths.\n    /// Owner is dex auth by default.\n    /// dex => auth => add/remove\n    mapping(address => mapping(address => bool)) internal _dexAuths;\n\n    // ----------------------- slot 4 ---------------------------\n    /// @dev total no of dexes deployed by the factory\n    /// only addresses that have deployer role or owner can deploy new dex pool.\n    uint256 internal _totalDexes;\n\n    // ----------------------- slot 5 ---------------------------\n    /// @dev dex deployment logics for deploying dex pool\n    /// These logic contracts hold the deployment logics of specific dexes and are called via .delegatecall inside deployDex().\n    /// only addresses that have owner can add/remove new dex deployment logic.\n    mapping(address => bool) internal _dexDeploymentLogics;\n\n    /*//////////////////////////////////////////////////////////////\n                          CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    constructor(address owner_) Owned(owner_) {}\n}\n\nabstract contract DexFactoryEvents {\n    /// @dev Emitted when a new dex is deployed.\n    /// @param dex The address of the newly deployed dex.\n    /// @param dexId The id of the newly deployed dex.\n    event LogDexDeployed(address indexed dex, uint256 indexed dexId);\n\n    /// @dev Emitted when the deployer is modified by owner.\n    /// @param deployer Address whose deployer status is updated.\n    /// @param allowed Indicates whether the address is authorized as a deployer or not.\n    event LogSetDeployer(address indexed deployer, bool indexed allowed);\n\n    /// @dev Emitted when the globalAuth is modified by owner.\n    /// @param globalAuth Address whose globalAuth status is updated.\n    /// @param allowed Indicates whether the address is authorized as a deployer or not.\n    event LogSetGlobalAuth(address indexed globalAuth, bool indexed allowed);\n\n    /// @dev Emitted when the dexAuth is modified by owner.\n    /// @param dexAuth Address whose dexAuth status is updated.\n    /// @param allowed Indicates whether the address is authorized as a deployer or not.\n    /// @param dex Address of the specific dex related to the authorization change.\n    event LogSetDexAuth(address indexed dexAuth, bool indexed allowed, address indexed dex);\n\n    /// @dev Emitted when the dex deployment logic is modified by owner.\n    /// @param dexDeploymentLogic The address of the dex deployment logic contract.\n    /// @param allowed  Indicates whether the address is authorized as a deployer or not.\n    event LogSetDexDeploymentLogic(address indexed dexDeploymentLogic, bool indexed allowed);\n}\n\nabstract contract DexFactoryCore is DexFactoryVariables, DexFactoryEvents {\n    constructor(address owner_) validAddress(owner_) DexFactoryVariables(owner_) {}\n\n    /// @dev validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidDexFactoryError(ErrorTypes.DexFactory__InvalidParams);\n        }\n        _;\n    }\n}\n\n/// @dev Implements Dex Factory auth-only callable methods. Owner / auths can set various config values and\n/// can define the allow-listed deployers.\nabstract contract DexFactoryAuth is DexFactoryCore {\n    /// @notice                         Sets an address (`deployer_`) as allowed deployer or not.\n    ///                                 This function can only be called by the owner.\n    /// @param deployer_                The address to be set as deployer.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to deploy dexes.\n    function setDeployer(address deployer_, bool allowed_) external onlyOwner validAddress(deployer_) {\n        _deployers[deployer_] = allowed_;\n\n        emit LogSetDeployer(deployer_, allowed_);\n    }\n\n    /// @notice                         Sets an address (`globalAuth_`) as a global authorization or not.\n    ///                                 This function can only be called by the owner.\n    /// @param globalAuth_              The address to be set as global authorization.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to update any dex config.\n    function setGlobalAuth(address globalAuth_, bool allowed_) external onlyOwner validAddress(globalAuth_) {\n        _globalAuths[globalAuth_] = allowed_;\n\n        emit LogSetGlobalAuth(globalAuth_, allowed_);\n    }\n\n    /// @notice                         Sets an address (`dexAuth_`) as allowed dex authorization or not for a specific dex (`dex_`).\n    ///                                 This function can only be called by the owner.\n    /// @param dex_                     The address of the dex for which the authorization is being set.\n    /// @param dexAuth_                 The address to be set as dex authorization.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to update the specific dex config.\n    function setDexAuth(address dex_, address dexAuth_, bool allowed_) external onlyOwner validAddress(dexAuth_) {\n        _dexAuths[dex_][dexAuth_] = allowed_;\n\n        emit LogSetDexAuth(dexAuth_, allowed_, dex_);\n    }\n\n    /// @notice                         Sets an address as allowed dex deployment logic (`deploymentLogic_`) contract or not.\n    ///                                 This function can only be called by the owner.\n    /// @param deploymentLogic_         The address of the dex deployment logic contract to be set.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to deploy new type of dex.\n    function setDexDeploymentLogic(\n        address deploymentLogic_,\n        bool allowed_\n    ) public onlyOwner validAddress(deploymentLogic_) {\n        _dexDeploymentLogics[deploymentLogic_] = allowed_;\n\n        emit LogSetDexDeploymentLogic(deploymentLogic_, allowed_);\n    }\n\n    /// @notice                         Spell allows owner aka governance to do any arbitrary call on factory\n    /// @param target_                  Address to which the call needs to be delegated\n    /// @param data_                    Data to execute at the delegated address\n    function spell(address target_, bytes memory data_) external onlyOwner returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n\n    /// @notice                         Checks if the provided address (`deployer_`) is authorized as a deployer.\n    /// @param deployer_                The address to be checked for deployer authorization.\n    /// @return                         Returns `true` if the address is a deployer, otherwise `false`.\n    function isDeployer(address deployer_) public view returns (bool) {\n        return _deployers[deployer_] || owner == deployer_;\n    }\n\n    /// @notice                         Checks if the provided address (`globalAuth_`) has global dex authorization privileges.\n    /// @param globalAuth_              The address to be checked for global authorization privileges.\n    /// @return                         Returns `true` if the given address has global authorization privileges, otherwise `false`.\n    function isGlobalAuth(address globalAuth_) public view returns (bool) {\n        return _globalAuths[globalAuth_] || owner == globalAuth_;\n    }\n\n    /// @notice                         Checks if the provided address (`dexAuth_`) has dex authorization privileges for the specified dex (`dex_`).\n    /// @param dex_                     The address of the dex to check.\n    /// @param dexAuth_                 The address to be checked for dex authorization privileges.\n    /// @return                         Returns `true` if the given address has dex authorization privileges for the specified dex, otherwise `false`.\n    function isDexAuth(address dex_, address dexAuth_) public view returns (bool) {\n        return _dexAuths[dex_][dexAuth_] || owner == dexAuth_;\n    }\n\n    /// @notice                         Checks if the provided (`dexDeploymentLogic_`) address has authorization for dex deployment.\n    /// @param dexDeploymentLogic_      The address of the dex deploy logic to check for authorization privileges.\n    /// @return                         Returns `true` if the given address has authorization privileges for dex deployment, otherwise `false`.\n    function isDexDeploymentLogic(address dexDeploymentLogic_) public view returns (bool) {\n        return _dexDeploymentLogics[dexDeploymentLogic_];\n    }\n}\n\n/// @dev implements DexFactory deploy dex related methods.\nabstract contract DexFactoryDeployment is DexFactoryCore, DexFactoryAuth {\n    /// @dev                            Deploys a contract using the CREATE opcode with the provided bytecode (`bytecode_`).\n    ///                                 This is an internal function, meant to be used within the contract to facilitate the deployment of other contracts.\n    /// @param bytecode_                The bytecode of the contract to be deployed.\n    /// @return address_                Returns the address of the deployed contract.\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\n        if (bytecode_.length == 0) {\n            revert FluidDexError(ErrorTypes.DexFactory__InvalidOperation);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\n        }\n        if (address_ == address(0)) {\n            revert FluidDexError(ErrorTypes.DexFactory__InvalidOperation);\n        }\n    }\n\n    /// @notice                       Deploys a new dex using the specified deployment logic `dexDeploymentLogic_` and data `dexDeploymentData_`.\n    ///                               Only accounts with deployer access or the owner can deploy a new dex.\n    /// @param dexDeploymentLogic_    The address of the dex deployment logic contract.\n    /// @param dexDeploymentData_     The data to be used for dex deployment.\n    /// @return dex_                  Returns the address of the newly deployed dex.\n    function deployDex(address dexDeploymentLogic_, bytes calldata dexDeploymentData_) external returns (address dex_) {\n        // Revert if msg.sender doesn't have deployer access or is an owner.\n        if (!isDeployer(msg.sender)) revert FluidDexError(ErrorTypes.DexFactory__Unauthorized);\n        // Revert if dexDeploymentLogic_ is not whitelisted.\n        if (!isDexDeploymentLogic(dexDeploymentLogic_)) revert FluidDexError(ErrorTypes.DexFactory__Unauthorized);\n\n        // Dex ID for the new dex and also acts as `nonce` for CREATE\n        uint256 dexId_ = ++_totalDexes;\n\n        // compute dex address for dex id.\n        dex_ = getDexAddress(dexId_);\n\n        // deploy the dex using dex deployment logic by making .delegatecall\n        (bool success_, bytes memory data_) = dexDeploymentLogic_.delegatecall(dexDeploymentData_);\n\n        if (!(success_ && dex_ == _deploy(abi.decode(data_, (bytes))) && isDex(dex_))) {\n            revert FluidDexError(ErrorTypes.DexFactory__InvalidDexAddress);\n        }\n\n        emit LogDexDeployed(dex_, dexId_);\n    }\n\n    /// @notice                       Computes the address of a dex based on its given ID (`dexId_`).\n    /// @param dexId_                 The ID of the dex.\n    /// @return dex_                  Returns the computed address of the dex.\n    function getDexAddress(uint256 dexId_) public view returns (address dex_) {\n        return AddressCalcs.addressCalc(address(this), dexId_);\n    }\n\n    /// @notice                         Checks if a given address (`dex_`) corresponds to a valid dex.\n    /// @param dex_                     The dex address to check.\n    /// @return                         Returns `true` if the given address corresponds to a valid dex, otherwise `false`.\n    function isDex(address dex_) public view returns (bool) {\n        if (dex_.code.length == 0) {\n            return false;\n        } else {\n            // DEX_ID() function signature is 0xf4b9a3fb\n            (bool success_, bytes memory data_) = dex_.staticcall(hex\"f4b9a3fb\");\n            return success_ && dex_ == getDexAddress(abi.decode(data_, (uint256)));\n        }\n    }\n\n    /// @notice                   Returns the total number of dexes deployed by the factory.\n    /// @return                   Returns the total number of dexes.\n    function totalDexes() external view returns (uint256) {\n        return _totalDexes;\n    }\n}\n\n/// @title Fluid DexFactory\n/// @notice creates Fluid dex protocol dexes, which are interacting with Fluid Liquidity to deposit / borrow funds.\n/// Dexes are created at a deterministic address, given an incrementing `dexId` (see `getDexAddress()`).\n/// Dexes can only be deployed by allow-listed deployer addresses.\n/// @dev Note the deployed dexes start out with no config at Liquidity contract.\n/// This must be done by Liquidity auths in a separate step, otherwise no deposits will be possible.\n/// This contract is not upgradeable. It supports adding new dex deployment logic contracts for new, future dexes.\ncontract FluidDexFactory is DexFactoryCore, DexFactoryAuth, DexFactoryDeployment {\n    constructor(address owner_) DexFactoryCore(owner_) {}\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexFactory {\n    /// @notice Global auth is auth for all dexes\n    function isGlobalAuth(address auth_) external view returns (bool);\n\n    /// @notice Dex auth is auth for a specific dex\n    function isDexAuth(address vault_, address auth_) external view returns (bool);\n\n    /// @notice Total dexes deployed.\n    function totalDexes() external view returns (uint256);\n\n    /// @notice Compute dexAddress\n    function getDexAddress(uint256 dexId_) external view returns (address);\n\n    /// @notice read uint256 `result_` for a storage `slot_` key\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexT1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexT1 {\n    error FluidDexError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares);\n\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\n\n    /// @notice returns the dex id\n    function DEX_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndOracle;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) external view returns (CollateralReserves memory c_);\n\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) external view returns (DebtReserves memory d_);\n\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\n    function getPricesAndExchangePrices() external;\n\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) external returns (\n        uint withdrawAmt_\n    );\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) external payable returns (\n        uint paybackAmt_\n    );\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(\n        uint[] memory secondsAgos_\n    ) external view returns (\n        Oracle[] memory twaps_,\n        uint currentPrice_\n    );\n}\n"
    },
    "contracts/protocols/dex/poolT1/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs } from \"./structs.sol\";\n\nabstract contract Events is Structs {\n    /// @dev Emitted when smart collateral is turned on\n    /// @param token0Amt The amount of token0 used for smart collateral\n    event LogTurnOnSmartCol(uint token0Amt);\n\n    /// @dev Emitted when smart debt is turned on\n    /// @param token0Amt The amount of token0 used for smart debt\n    event LogTurnOnSmartDebt(uint token0Amt);\n\n    /// @dev Emitted when fee and revenue cut are updated\n    /// @param fee The new fee value\n    /// @param revenueCut The new revenue cut value\n    event LogUpdateFeeAndRevenueCut(uint fee, uint revenueCut);\n\n    /// @dev Emitted when range percents are updated\n    /// @param upperPercent The new upper percent value\n    /// @param lowerPercent The new lower percent value\n    /// @param shiftTime The new shift time value\n    event LogUpdateRangePercents(uint upperPercent, uint lowerPercent, uint shiftTime);\n\n    /// @dev Emitted when threshold percent is updated\n    /// @param upperThresholdPercent The new upper threshold percent value\n    /// @param lowerThresholdPercent The new lower threshold percent value\n    /// @param thresholdShiftTime The new threshold shift time value\n    /// @param shiftTime The new shift time value\n    event LogUpdateThresholdPercent(\n        uint upperThresholdPercent,\n        uint lowerThresholdPercent,\n        uint thresholdShiftTime,\n        uint shiftTime\n    );\n\n    /// @dev Emitted when center price address is updated\n    /// @param centerPriceAddress The new center price address nonce\n    /// @param percent The new percent value\n    /// @param time The new time value\n    event LogUpdateCenterPriceAddress(uint centerPriceAddress, uint percent, uint time);\n\n    /// @dev Emitted when hook address is updated\n    /// @param hookAddress The new hook address nonce\n    event LogUpdateHookAddress(uint hookAddress);\n\n    /// @dev Emitted when center price limits are updated\n    /// @param maxCenterPrice The new maximum center price\n    /// @param minCenterPrice The new minimum center price\n    event LogUpdateCenterPriceLimits(uint maxCenterPrice, uint minCenterPrice);\n\n    /// @dev Emitted when utilization limit is updated\n    /// @param token0UtilizationLimit The new utilization limit for token0\n    /// @param token1UtilizationLimit The new utilization limit for token1\n    event LogUpdateUtilizationLimit(uint token0UtilizationLimit, uint token1UtilizationLimit);\n\n    /// @dev Emitted when user supply configs are updated\n    /// @param userSupplyConfigs The array of updated user supply configurations\n    event LogUpdateUserSupplyConfigs(UserSupplyConfig[] userSupplyConfigs);\n\n    /// @dev Emitted when user borrow configs are updated\n    /// @param userBorrowConfigs The array of updated user borrow configurations\n    event LogUpdateUserBorrowConfigs(UserBorrowConfig[] userBorrowConfigs);\n\n    /// @dev Emitted when a user is paused\n    /// @param user The address of the paused user\n    /// @param pauseSupply Whether supply operations are paused\n    /// @param pauseBorrow Whether borrow operations are paused\n    event LogPauseUser(address user, bool pauseSupply, bool pauseBorrow);\n\n    /// @dev Emitted when a user is unpaused\n    /// @param user The address of the unpaused user\n    /// @param unpauseSupply Whether supply operations are unpaused\n    /// @param unpauseBorrow Whether borrow operations are unpaused\n    event LogUnpauseUser(address user, bool unpauseSupply, bool unpauseBorrow);\n\n    /// @notice Emitted when the pool configuration is initialized\n    /// @param smartCol Whether smart collateral is enabled\n    /// @param smartDebt Whether smart debt is enabled\n    /// @param token0ColAmt The amount of token0 collateral\n    /// @param token0DebtAmt The amount of token0 debt\n    /// @param fee The fee percentage (in 4 decimals, 10000 = 1%)\n    /// @param revenueCut The revenue cut percentage (in 4 decimals, 100000 = 10%)\n    /// @param centerPriceAddress The nonce for the center price contract address\n    /// @param hookAddress The nonce for the hook contract address\n    event LogInitializePoolConfig(\n        bool smartCol,\n        bool smartDebt,\n        uint token0ColAmt,\n        uint token0DebtAmt,\n        uint fee,\n        uint revenueCut,\n        uint centerPriceAddress,\n        uint hookAddress\n    );\n\n    /// @notice Emitted when the price parameters are initialized\n    /// @param upperPercent The upper range percent (in 4 decimals, 10000 = 1%)\n    /// @param lowerPercent The lower range percent (in 4 decimals, 10000 = 1%)\n    /// @param upperShiftThreshold The upper shift threshold (in 4 decimals, 10000 = 1%)\n    /// @param lowerShiftThreshold The lower shift threshold (in 4 decimals, 10000 = 1%)\n    /// @param thresholdShiftTime The time for threshold shift (in seconds)\n    /// @param maxCenterPrice The maximum center price\n    /// @param minCenterPrice The minimum center price\n    event LogInitializePriceParams(\n        uint upperPercent,\n        uint lowerPercent,\n        uint upperShiftThreshold,\n        uint lowerShiftThreshold,\n        uint thresholdShiftTime,\n        uint maxCenterPrice,\n        uint minCenterPrice\n    );\n\n    /// @dev Emitted when swap and arbitrage are paused\n    event LogPauseSwapAndArbitrage();\n\n    /// @dev Emitted when swap and arbitrage are unpaused\n    event LogUnpauseSwapAndArbitrage();\n\n    /// @notice emitted when user withdrawal limit is updated\n    event LogUpdateUserWithdrawalLimit(address user, uint256 newLimit);\n\n    /// @dev Emitted when funds are rescued\n    /// @param token The address of the token\n    event LogRescueFunds(address token);\n}\n"
    },
    "contracts/protocols/dex/poolT1/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Variables } from \"../common/variables.sol\";\nimport { Events } from \"./events.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { ConstantVariables } from \"../common/constantVariables.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { IFluidDexT1 } from \"../../interfaces/iDexT1.sol\";\nimport { IFluidLiquidity } from \"../../../../liquidity/interfaces/iLiquidity.sol\";\nimport { SafeTransfer } from \"../../../../libraries/safeTransfer.sol\";\nimport { AddressCalcs } from \"../../../../libraries/addressCalcs.sol\";\nimport { DexSlotsLink } from \"../../../../libraries/dexSlotsLink.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @notice Fluid Dex protocol Admin Module contract.\n///         Implements admin related methods to set pool configs\n///         Methods are limited to be called via delegateCall only. Dex CoreModule (\"DexT1\" contract)\n///         is expected to call the methods implemented here after checking the msg.sender is authorized.\ncontract FluidDexT1Admin is ConstantVariables, Variables, Structs, Events, Error {\n    using BigMathMinified for uint256;\n\n    address private immutable ADDRESS_THIS;\n\n    constructor() {\n        ADDRESS_THIS = address(this);\n    }\n\n    modifier _onlyDelegateCall() {\n        // also indirectly checked by `_check` because pool can never be initialized as long as the initialize method\n        // is delegate call only, but just to be sure on Admin logic we add the modifier everywhere nonetheless.\n        if (address(this) == ADDRESS_THIS) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    modifier _check() {\n        if ((dexVariables2 & 3) == 0) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__PoolNotInitialized);\n        }\n        _;\n    }\n\n    /// @dev checks that `value_` address is a contract (which includes address zero check) or native address\n    function _checkIsContractOrNativeAddress(address value_) internal view {\n        if (value_.code.length == 0 && value_ != NATIVE_TOKEN) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__AddressNotAContract);\n        }\n    }\n\n    /// @dev checks that `value_` address is a contract (which includes address zero check)\n    function _checkIsContract(address value_) internal view {\n        if (value_.code.length == 0) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__AddressNotAContract);\n        }\n    }\n\n    function turnOnSmartCol(uint token0Amt_) public payable _check _onlyDelegateCall {\n        if (dexVariables2 & 1 == 1) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__SmartColIsAlreadyOn);\n        }\n        uint centerPrice_ = (dexVariables >> 81) & X40;\n        centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n        _turnOnSmartCol(token0Amt_, centerPrice_);\n\n        dexVariables2 = dexVariables2 | 1;\n\n        emit LogTurnOnSmartCol(token0Amt_);\n    }\n\n    function _turnOnSmartCol(uint token0Amt_, uint centerPrice_) internal {\n        IFluidDexT1.ConstantViews memory c_ = IFluidDexT1(address(this)).constantsView();\n        IFluidDexT1.ConstantViews2 memory c2_ = IFluidDexT1(address(this)).constantsView2();\n\n        uint token0AmtAdjusted_ = (token0Amt_ * c2_.token0NumeratorPrecision) / c2_.token0DenominatorPrecision;\n\n        uint token1AmtAdjusted_ = (centerPrice_ * token0AmtAdjusted_) / 1e27;\n\n        uint token1Amt_ = (token1AmtAdjusted_ * c2_.token1DenominatorPrecision) / c2_.token1NumeratorPrecision;\n\n        IFluidLiquidity liquidity_ = IFluidLiquidity(c_.liquidity);\n\n        // if both tokens are not native token and msg.value is sent, revert\n        if (msg.value > 0 && c_.token0 != NATIVE_TOKEN && c_.token1 != NATIVE_TOKEN) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n\n        address token_;\n        uint amt_;\n        for (uint i = 0; i < 2; i++) {\n            if (i == 0) {\n                token_ = c_.token0;\n                amt_ = token0Amt_;\n            } else {\n                token_ = c_.token1;\n                amt_ = token1Amt_;\n            }\n            if (token_ == NATIVE_TOKEN) {\n                if (msg.value > amt_) {\n                    SafeTransfer.safeTransferNative(msg.sender, msg.value - amt_);\n                } else if (msg.value < amt_) {\n                    revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n                }\n                // deposit\n                liquidity_.operate{ value: amt_ }(token_, int(amt_), 0, address(0), address(0), abi.encode(amt_, false, msg.sender));\n            } else {\n                // deposit\n                liquidity_.operate(token_, int(amt_), 0, address(0), address(0), abi.encode(amt_, false, msg.sender));\n            }\n        }\n\n        // minting shares according to whatever tokenAmt is bigger\n        // adding shares on storage but not adding shares for any user, hence locking these shares forever\n        // adjusted amounts are in 12 decimals, making shares in 18 decimals\n        _totalSupplyShares = (token0AmtAdjusted_ > token1AmtAdjusted_)\n            ? token0AmtAdjusted_ * 10 ** (18 - TOKENS_DECIMALS_PRECISION)\n            : token1AmtAdjusted_ * 10 ** (18 - TOKENS_DECIMALS_PRECISION);\n\n        if (_totalSupplyShares < NINE_DECIMALS) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__UnexpectedPoolState);\n        }\n    }\n\n    function turnOnSmartDebt(uint token0Amt_) public _check _onlyDelegateCall {\n        if (dexVariables2 & 2 == 2) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__SmartDebtIsAlreadyOn);\n        }\n        uint centerPrice_ = (dexVariables >> 81) & X40;\n        centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n        _turnOnSmartDebt(token0Amt_, centerPrice_);\n\n        dexVariables2 = dexVariables2 | 2;\n\n        emit LogTurnOnSmartDebt(token0Amt_);\n    }\n\n    /// @dev Can only borrow if DEX pool address borrow config is added in Liquidity Layer for both the tokens else Liquidity Layer will revert\n    /// governance will have access to _turnOnSmartDebt, technically governance here can borrow as much as limits are set\n    /// so it's governance responsibility that it borrows small amount between $100 - $10,000\n    /// Borrowing in 50:50 ratio (doesn't matter if pool configuration is set to 20:80, 30:70, etc, external swap will arbitrage & balance the pool)\n    function _turnOnSmartDebt(uint token0Amt_, uint centerPrice_) internal {\n        IFluidDexT1.ConstantViews memory c_ = IFluidDexT1(address(this)).constantsView();\n        IFluidDexT1.ConstantViews2 memory c2_ = IFluidDexT1(address(this)).constantsView2();\n\n        uint token0AmtAdjusted_ = (token0Amt_ * c2_.token0NumeratorPrecision) / c2_.token0DenominatorPrecision;\n\n        uint token1AmtAdjusted_ = (centerPrice_ * token0AmtAdjusted_) / 1e27;\n\n        uint token1Amt_ = (token1AmtAdjusted_ * c2_.token1DenominatorPrecision) / c2_.token1NumeratorPrecision;\n\n        IFluidLiquidity liquidity_ = IFluidLiquidity(c_.liquidity);\n\n        liquidity_.operate(c_.token0, 0, int(token0Amt_), address(0), TEAM_MULTISIG, new bytes(0));\n        liquidity_.operate(c_.token1, 0, int(token1Amt_), address(0), TEAM_MULTISIG, new bytes(0));\n\n        // minting shares as whatever tokenAmt is bigger\n        // adding shares on storage but not adding shares for any user, hence locking these shares forever\n        // adjusted amounts are in 12 decimals, making shares in 18 decimals\n        _totalBorrowShares = (token0AmtAdjusted_ > token1AmtAdjusted_)\n            ? token0AmtAdjusted_ * 10 ** (18 - TOKENS_DECIMALS_PRECISION)\n            : token1AmtAdjusted_ * 10 ** (18 - TOKENS_DECIMALS_PRECISION);\n\n        if (_totalBorrowShares < NINE_DECIMALS) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__UnexpectedPoolState);\n        }\n    }\n\n    /// @param fee_ in 4 decimals, 10000 = 1%\n    /// @param revenueCut_ in 4 decimals, 100000 = 10%, 10% cut on fee_, so if fee is 1% and cut is 10% then cut in swap amount will be 10% of 1% = 0.1%\n    function updateFeeAndRevenueCut(uint fee_, uint revenueCut_) public _check _onlyDelegateCall {\n        // cut is an integer in storage slot which is more than enough\n        // but from UI we are allowing to send in 4 decimals to maintain consistency & avoid human error in future\n        if (revenueCut_ != 0 && revenueCut_ < FOUR_DECIMALS) {\n            // human input error. should send 0 for wanting 0, not 0 because of precision reduction.\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n\n        revenueCut_ = revenueCut_ / FOUR_DECIMALS;\n\n        if (fee_ > FIVE_DECIMALS || revenueCut_ > TWO_DECIMALS) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n\n        dexVariables2 =\n            (dexVariables2 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC000003) |\n            (fee_ << 2) |\n            (revenueCut_ << 19);\n\n        emit LogUpdateFeeAndRevenueCut(fee_, revenueCut_ * FOUR_DECIMALS);\n    }\n\n    /// @param upperPercent_ in 4 decimals, 10000 = 1%\n    /// @param lowerPercent_ in 4 decimals, 10000 = 1%\n    /// @param shiftTime_ in secs, in how much time the upper percent configs change should be fully done\n    function updateRangePercents(\n        uint upperPercent_,\n        uint lowerPercent_,\n        uint shiftTime_\n    ) public _check _onlyDelegateCall {\n        uint dexVariables2_ = dexVariables2;\n        if (\n            (upperPercent_ > (SIX_DECIMALS - FOUR_DECIMALS)) || // capping range to 99%.\n            (lowerPercent_ > (SIX_DECIMALS - FOUR_DECIMALS)) || // capping range to 99%.\n            (upperPercent_ == 0) ||\n            (lowerPercent_ == 0) ||\n            (shiftTime_ > X20) ||\n            (((dexVariables2_ >> 26) & 1) == 1) // if last shift is still active then don't allow a newer shift\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n\n        dexVariables2 =\n            (dexVariables2_ & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF80000000003FFFFFF) |\n            (uint((shiftTime_ > 0) ? 1 : 0) << 26) |\n            (upperPercent_ << 27) |\n            (lowerPercent_ << 47);\n\n        uint oldUpperPercent_ = (dexVariables2_ >> 27) & X20;\n        uint oldLowerPercent_ = (dexVariables2_ >> 47) & X20;\n\n        if (shiftTime_ > 0) {\n            _rangeShift = uint128(\n                oldUpperPercent_ | (oldLowerPercent_ << 20) | (shiftTime_ << 40) | (block.timestamp << 60)\n            );\n        }\n        // Note _rangeShift is reset when the previous shift is fully completed, which is forced to have happened through if check above\n\n        emit LogUpdateRangePercents(upperPercent_, lowerPercent_, shiftTime_);\n    }\n\n    /// @param upperThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param lowerThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param thresholdShiftTime_ in secs, in how much time the threshold percent should take to shift the ranges\n    /// @param shiftTime_ in secs, in how much time the upper config changes should be fully done.\n    function updateThresholdPercent(\n        uint upperThresholdPercent_,\n        uint lowerThresholdPercent_,\n        uint thresholdShiftTime_,\n        uint shiftTime_\n    ) public _check _onlyDelegateCall {\n        uint dexVariables2_ = dexVariables2;\n\n        // thresholds are with 0.1% precision, hence removing last 3 decimals.\n        // we are allowing to send in 4 decimals to maintain consistency with other params\n        upperThresholdPercent_ = upperThresholdPercent_ / THREE_DECIMALS;\n        lowerThresholdPercent_ = lowerThresholdPercent_ / THREE_DECIMALS;\n        if (\n            (upperThresholdPercent_ > THREE_DECIMALS) ||\n            (lowerThresholdPercent_ > THREE_DECIMALS) ||\n            (thresholdShiftTime_ == 0) ||\n            (thresholdShiftTime_ > X24) ||\n            (upperThresholdPercent_ == 0) ||\n            (lowerThresholdPercent_ == 0) ||\n            (shiftTime_ > X20) ||\n            (((dexVariables2_ >> 67) & 1) == 1) // if last shift is still active then don't allow a newer shift\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n\n        dexVariables2 =\n            (dexVariables2_ & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000007FFFFFFFFFFFFFFFF) |\n            (uint((shiftTime_ > 0) ? 1 : 0) << 67) |\n            (upperThresholdPercent_ << 68) |\n            (lowerThresholdPercent_ << 78) |\n            (thresholdShiftTime_ << 88);\n\n        uint oldUpperThresholdPercent_ = (dexVariables2_ >> 68) & X10;\n        uint oldLowerThresholdPercent_ = (dexVariables2_ >> 78) & X10;\n        uint oldThresholdTime_ = (dexVariables2_ >> 88) & X24;\n\n        if (shiftTime_ > 0) {\n            _thresholdShift = uint128(\n                oldUpperThresholdPercent_ |\n                    (oldLowerThresholdPercent_ << 20) |\n                    (shiftTime_ << 40) |\n                    (block.timestamp << 60) |\n                    (oldThresholdTime_ << 93)\n            );\n        }\n        // Note _thresholdShift is reset when the previous shift is fully completed, which is forced to have happened through if check above\n\n        emit LogUpdateThresholdPercent(\n            upperThresholdPercent_ * THREE_DECIMALS,\n            lowerThresholdPercent_ * THREE_DECIMALS,\n            thresholdShiftTime_,\n            shiftTime_\n        );\n    }\n\n    /// @dev we are storing uint nonce from which we will calculate the contract address, to store an address we need 160 bits\n    /// which is quite a lot of storage slot\n    /// @param centerPriceAddress_ nonce < X30, this nonce will be used to calculate contract address\n    function updateCenterPriceAddress(\n        uint centerPriceAddress_,\n        uint percent_,\n        uint time_\n    ) public _check _onlyDelegateCall {\n        if ((centerPriceAddress_ > X30) || (percent_ == 0) || (percent_ > X20) || (time_ == 0) || (time_ > X20)) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n\n        if (centerPriceAddress_ > 0) {\n            IFluidDexT1.ConstantViews memory c_ = IFluidDexT1(address(this)).constantsView();\n            address centerPrice_ = AddressCalcs.addressCalc(c_.deployerContract, centerPriceAddress_);\n            _checkIsContract(centerPrice_);\n            // note: if address is made 0 then as well in the last swap currentPrice is updated on storage, so code will start using that automatically\n            dexVariables2 =\n                (dexVariables2 & 0xFeFFFFFFFFFFFFFFFFFFFFFFFFFFC0000000FFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n                (centerPriceAddress_ << 112) |\n                (uint(1) << 248);\n\n            _centerPriceShift = block.timestamp | (percent_ << 33) | (time_ << 53);\n        } else {\n            dexVariables2 = (dexVariables2 & 0xFeFFFFFFFFFFFFFFFFFFFFFFFFFFC0000000FFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n            _centerPriceShift = 0;\n        }\n\n        emit LogUpdateCenterPriceAddress(centerPriceAddress_, percent_, time_);\n    }\n\n    /// @dev we are storing uint nonce from which we will calculate the contract address, to store an address we need 160 bits\n    /// which is quite a lot of storage slot\n    /// @param hookAddress_ nonce < X30, this nonce will be used to calculate contract address\n    function updateHookAddress(uint hookAddress_) public _check _onlyDelegateCall {\n        if (hookAddress_ > X30) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n\n        if (hookAddress_ > 0) {\n            IFluidDexT1.ConstantViews memory c_ = IFluidDexT1(address(this)).constantsView();\n            address hook_ = AddressCalcs.addressCalc(c_.deployerContract, hookAddress_);\n            _checkIsContract(hook_);\n        }\n\n        dexVariables2 =\n            (dexVariables2 & 0xFFFFFFFFFFFFFFFFFFFFF00000003FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n            (hookAddress_ << 142);\n\n        emit LogUpdateHookAddress(hookAddress_);\n    }\n\n    function updateCenterPriceLimits(uint maxCenterPrice_, uint minCenterPrice_) public _check _onlyDelegateCall {\n        uint centerPrice_ = (dexVariables >> 81) & X40;\n        centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n\n        if (\n            (maxCenterPrice_ <= minCenterPrice_) ||\n            (centerPrice_ <= minCenterPrice_) ||\n            (centerPrice_ >= maxCenterPrice_) ||\n            (minCenterPrice_ == 0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n\n        dexVariables2 =\n            (dexVariables2 & 0xFFFFFFF00000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n            (maxCenterPrice_.toBigNumber(20, 8, BigMathMinified.ROUND_UP) << 172) |\n            (minCenterPrice_.toBigNumber(20, 8, BigMathMinified.ROUND_DOWN) << 200);\n\n        emit LogUpdateCenterPriceLimits(maxCenterPrice_, minCenterPrice_);\n    }\n\n    function updateUtilizationLimit(\n        uint token0UtilizationLimit_,\n        uint token1UtilizationLimit_\n    ) public _check _onlyDelegateCall {\n        if (\n            (token0UtilizationLimit_ != 0 && token0UtilizationLimit_ < THREE_DECIMALS) ||\n            (token1UtilizationLimit_ != 0 && token1UtilizationLimit_ < THREE_DECIMALS)\n        ) {\n            // human input error. should send 0 for wanting 0, not 0 because of precision reduction.\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n\n        token0UtilizationLimit_ = token0UtilizationLimit_ / THREE_DECIMALS;\n        token1UtilizationLimit_ = token1UtilizationLimit_ / THREE_DECIMALS;\n\n        if (token0UtilizationLimit_ > THREE_DECIMALS || token1UtilizationLimit_ > THREE_DECIMALS) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n\n        dexVariables2 =\n            (dexVariables2 & 0xFF00000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n            (token0UtilizationLimit_ << 228) |\n            (token1UtilizationLimit_ << 238);\n\n        emit LogUpdateUtilizationLimit(\n            token0UtilizationLimit_ * THREE_DECIMALS,\n            token1UtilizationLimit_ * THREE_DECIMALS\n        );\n    }\n\n    function updateUserSupplyConfigs(UserSupplyConfig[] memory userSupplyConfigs_) external _check _onlyDelegateCall {\n        uint256 userSupplyData_;\n\n        for (uint256 i; i < userSupplyConfigs_.length; ) {\n            _checkIsContract(userSupplyConfigs_[i].user);\n            if (userSupplyConfigs_[i].expandDuration == 0) {\n                // can not set expand duration to 0 as that could cause a division by 0 in LiquidityCalcs.\n                // having expand duration as 0 is anyway not an expected config so removing the possibility for that.\n                // if no expansion is wanted, simply set expandDuration to 1 and expandPercent to 0.\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n            }\n            if (userSupplyConfigs_[i].expandPercent > FOUR_DECIMALS) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n            }\n            if (userSupplyConfigs_[i].expandDuration > X24) {\n                // duration is max 24 bits\n                revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n            }\n            if (userSupplyConfigs_[i].baseWithdrawalLimit == 0) {\n                // base withdrawal limit can not be 0. As a side effect, this ensures that there is no supply config\n                // where all values would be 0, so configured users can be differentiated in the mapping.\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n            }\n            // @dev baseWithdrawalLimit has no max bits amount as it is in normal token amount & converted to BigNumber\n\n            // get current user config data from storage\n            userSupplyData_ = _userSupplyData[userSupplyConfigs_[i].user];\n\n            // Updating user data on storage\n            _userSupplyData[userSupplyConfigs_[i].user] =\n                // mask to update first bit + bits 162-217 (expand percentage, expand duration, base limit)\n                (userSupplyData_ & 0xfffffffffc00000000000003ffffffffffffffffffffffffffffffffffffffff) |\n                (1) |\n                (userSupplyConfigs_[i].expandPercent << DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) |\n                (userSupplyConfigs_[i].expandDuration << DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) |\n                // convert base withdrawal limit to BigNumber for storage (10 | 8). (below this, 100% can be withdrawn)\n                (userSupplyConfigs_[i].baseWithdrawalLimit.toBigNumber(\n                    SMALL_COEFFICIENT_SIZE,\n                    DEFAULT_EXPONENT_SIZE,\n                    BigMathMinified.ROUND_DOWN\n                ) << DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit LogUpdateUserSupplyConfigs(userSupplyConfigs_);\n    }\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, uint256 newLimit_) external _check _onlyDelegateCall {\n        _checkIsContract(user_);\n\n        // get current user config data from storage\n        uint256 userSupplyData_ = _userSupplyData[user_];\n        if (userSupplyData_ == 0) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__UserNotDefined);\n        }\n\n        // get current user supply amount\n        uint256 userSupply_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n        userSupply_ = (userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK);\n\n        // maxExpansionLimit_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        uint256 maxExpansionLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        maxExpansionLimit_ = userSupply_ - ((userSupply_ * maxExpansionLimit_) / FOUR_DECIMALS);\n\n        if (newLimit_ == 0 || newLimit_ < maxExpansionLimit_) {\n            // instant full expansion, and if that goes below base limit then fully down to 0.\n            // if we were to set a limit that goes below max expansion limit, then after 1 deposit or 1 withdrawal it would\n            // become based on the max expansion limit again (unless it goes below base limit), which can be confusing.\n            // Also updating base limit here to avoid the change after 1 interaction might have undesired effects.\n            // So limiting update to max. full expansion. If more is desired, this must be called again after some withdraws.\n            newLimit_ = maxExpansionLimit_;\n        } else if (newLimit_ == type(uint256).max || newLimit_ > userSupply_) {\n            // current withdrawable 0 (sets current user supply as limit).\n            newLimit_ = userSupply_;\n        }\n        // else => new limit is between > max expansion and < user supply.\n\n        // set input limit as new current limit. instant withdrawable will be userSupply_ - newLimit_\n\n        uint256 baseLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        baseLimit_ = (baseLimit_ >> DEFAULT_EXPONENT_SIZE) << (baseLimit_ & DEFAULT_EXPONENT_MASK);\n        if (userSupply_ < baseLimit_) {\n            newLimit_ = 0;\n            // Note if new limit goes below base limit, it follows default behavior: first there must be a withdrawal\n            // that brings user supply below base limit, then the limit will be set to 0.\n            // otherwise we would have the same problem as described above after 1 interaction.\n        }\n\n        // Update on storage\n        _userSupplyData[user_] =\n            // mask to update bits 65-161 (withdrawal limit, timestamp)\n            (userSupplyData_ & 0xFFFFFFFFFFFFFFFFFFFFFFFC000000000000000000000001FFFFFFFFFFFFFFFF) |\n            (newLimit_.toBigNumber(DEFAULT_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BigMathMinified.ROUND_DOWN) <<\n                DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) | // converted to BigNumber can not overflow\n            (block.timestamp << DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP);\n\n        emit LogUpdateUserWithdrawalLimit(user_, newLimit_);\n    }\n\n    function updateUserBorrowConfigs(UserBorrowConfig[] memory userBorrowConfigs_) external _check _onlyDelegateCall {\n        uint256 userBorrowData_;\n\n        for (uint256 i; i < userBorrowConfigs_.length; ) {\n            _checkIsContract(userBorrowConfigs_[i].user);\n            if (\n                // max debt ceiling must not be smaller than base debt ceiling. Also covers case where max = 0 but base > 0\n                userBorrowConfigs_[i].baseDebtCeiling > userBorrowConfigs_[i].maxDebtCeiling ||\n                // can not set expand duration to 0 as that could cause a division by 0 in LiquidityCalcs.\n                // having expand duration as 0 is anyway not an expected config so removing the possibility for that.\n                // if no expansion is wanted, simply set expandDuration to 1 and expandPercent to 0.\n                userBorrowConfigs_[i].expandDuration == 0\n            ) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n            }\n            if (userBorrowConfigs_[i].expandPercent > X14) {\n                // expandPercent is max 14 bits\n                revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n            }\n            if (userBorrowConfigs_[i].expandDuration > X24) {\n                // duration is max 24 bits\n                revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n            }\n            if (userBorrowConfigs_[i].baseDebtCeiling == 0 || userBorrowConfigs_[i].maxDebtCeiling == 0) {\n                // limits can not be 0. As a side effect, this ensures that there is no borrow config\n                // where all values would be 0, so configured users can be differentiated in the mapping.\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n            }\n            // @dev baseDebtCeiling & maxDebtCeiling have no max bits amount as they are in normal token amount\n            // and then converted to BigNumber\n\n            // get current user config data from storage\n            userBorrowData_ = _userBorrowData[userBorrowConfigs_[i].user];\n\n            // Updating user data on storage\n\n            _userBorrowData[userBorrowConfigs_[i].user] =\n                // mask to update first bit (mode) + bits 162-235 (debt limit values)\n                (userBorrowData_ & 0xfffff0000000000000000003ffffffffffffffffffffffffffffffffffffffff) |\n                (1) |\n                (userBorrowConfigs_[i].expandPercent << DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) |\n                (userBorrowConfigs_[i].expandDuration << DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) |\n                // convert base debt limit to BigNumber for storage (10 | 8). (borrow is always possible below this)\n                (userBorrowConfigs_[i].baseDebtCeiling.toBigNumber(\n                    SMALL_COEFFICIENT_SIZE,\n                    DEFAULT_EXPONENT_SIZE,\n                    BigMathMinified.ROUND_DOWN\n                ) << DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) |\n                // convert max debt limit to BigNumber for storage (10 | 8). (no borrowing ever possible above this)\n                (userBorrowConfigs_[i].maxDebtCeiling.toBigNumber(\n                    SMALL_COEFFICIENT_SIZE,\n                    DEFAULT_EXPONENT_SIZE,\n                    BigMathMinified.ROUND_DOWN\n                ) << DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit LogUpdateUserBorrowConfigs(userBorrowConfigs_);\n    }\n\n    function pauseUser(address user_, bool pauseSupply_, bool pauseBorrow_) public _onlyDelegateCall {\n        _checkIsContract(user_);\n\n        uint256 userData_;\n\n        if (pauseSupply_) {\n            // userData_ => userSupplyData_\n            userData_ = _userSupplyData[user_];\n            if (userData_ == 0) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__UserNotDefined);\n            }\n            if (userData_ & 1 == 0) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidPauseToggle);\n            }\n            // set first bit as 0, meaning all user's supply operations are paused\n            _userSupplyData[user_] = userData_ & (~uint(1));\n        }\n\n        if (pauseBorrow_) {\n            // userData_ => userBorrowData_\n            userData_ = _userBorrowData[user_];\n            if (userData_ == 0) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__UserNotDefined);\n            }\n            if (userData_ & 1 == 0) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidPauseToggle);\n            }\n            // set first bit as 0, meaning all user's borrow operations are paused\n            _userBorrowData[user_] = userData_ & (~uint(1));\n        }\n\n        emit LogPauseUser(user_, pauseSupply_, pauseBorrow_);\n    }\n\n    function unpauseUser(address user_, bool unpauseSupply_, bool unpauseBorrow_) public _onlyDelegateCall {\n        _checkIsContract(user_);\n\n        uint256 userData_;\n\n        if (unpauseSupply_) {\n            // userData_ => userSupplyData_\n            userData_ = _userSupplyData[user_];\n            if (userData_ == 0) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__UserNotDefined);\n            }\n            if (userData_ & 1 == 1) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidPauseToggle);\n            }\n\n            // set first bit as 1, meaning unpause\n            _userSupplyData[user_] = userData_ | 1;\n        }\n\n        if (unpauseBorrow_) {\n            // userData_ => userBorrowData_\n            userData_ = _userBorrowData[user_];\n            if (userData_ == 0) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__UserNotDefined);\n            }\n            if (userData_ & 1 == 1) {\n                revert FluidDexError(ErrorTypes.DexT1Admin__InvalidPauseToggle);\n            }\n\n            // set first bit as 1, meaning unpause\n            _userBorrowData[user_] = userData_ | 1;\n        }\n\n        emit LogUnpauseUser(user_, unpauseSupply_, unpauseBorrow_);\n    }\n\n    /// note we have not added updateUtilizationLimit in the params here because struct of InitializeVariables already has 16 variables\n    /// we might skip adding it and let it update through the indepdent function to keep initialize struct simple\n    function initialize(InitializeVariables memory i_) public payable _onlyDelegateCall {\n        _checkIsContract(TEAM_MULTISIG);\n\n        if (!(i_.smartCol || i_.smartDebt)) {\n            // either 1 should be on upon pool initialization\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n        // cut is an integer in storage slot which is more than enough\n        // but from UI we are allowing to send in 4 decimals to maintain consistency & avoid human error in future\n        if (i_.revenueCut != 0 && i_.revenueCut < FOUR_DECIMALS) {\n            // human input error. should send 0 for wanting 0, not 0 because of precision reduction.\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n\n        // revenue cut has no decimals\n        i_.revenueCut = i_.revenueCut / FOUR_DECIMALS;\n        i_.upperShiftThreshold = i_.upperShiftThreshold / THREE_DECIMALS;\n        i_.lowerShiftThreshold = i_.lowerShiftThreshold / THREE_DECIMALS;\n\n        if (\n            (i_.fee > FIVE_DECIMALS) || // fee cannot be more than 10%\n            (i_.revenueCut > TWO_DECIMALS) ||\n            (i_.upperPercent > (SIX_DECIMALS - FOUR_DECIMALS)) || // capping range to 99%.\n            (i_.lowerPercent > (SIX_DECIMALS - FOUR_DECIMALS)) || // capping range to 99%.\n            (i_.upperPercent == 0) ||\n            (i_.lowerPercent == 0) ||\n            (i_.upperShiftThreshold > THREE_DECIMALS) ||\n            (i_.lowerShiftThreshold > THREE_DECIMALS) ||\n            (i_.upperShiftThreshold == 0) ||\n            (i_.lowerShiftThreshold == 0) ||\n            (i_.thresholdShiftTime == 0) ||\n            (i_.thresholdShiftTime > X24) ||\n            (i_.centerPriceAddress > X30) ||\n            (i_.hookAddress > X30) ||\n            (i_.centerPrice <= i_.minCenterPrice) ||\n            (i_.centerPrice >= i_.maxCenterPrice) ||\n            (i_.minCenterPrice == 0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1Admin__ConfigOverflow);\n        }\n\n        uint dexVariables2_;\n\n        if (i_.smartCol) {\n            _turnOnSmartCol(i_.token0ColAmt, i_.centerPrice);\n            dexVariables2_ = dexVariables2_ | 1;\n        }\n\n        if (i_.smartDebt) {\n            _turnOnSmartDebt(i_.token0DebtAmt, i_.centerPrice);\n            dexVariables2_ = dexVariables2_ | 2;\n        }\n\n        i_.centerPrice = i_.centerPrice.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN);\n        // setting up initial dexVariables\n        dexVariables =\n            (i_.centerPrice << 1) |\n            (i_.centerPrice << 41) |\n            (i_.centerPrice << 81) |\n            (block.timestamp << 121) |\n            (60 << 154) | // just setting 60 seconds, no particular reason for it why \"60\"\n            (7 << 176);\n\n        dexVariables2 =\n            dexVariables2_ |\n            (i_.fee << 2) |\n            (i_.revenueCut << 19) |\n            (i_.upperPercent << 27) |\n            (i_.lowerPercent << 47) |\n            (i_.upperShiftThreshold << 68) |\n            (i_.lowerShiftThreshold << 78) |\n            (i_.thresholdShiftTime << 88) |\n            (i_.centerPriceAddress << 112) |\n            (i_.hookAddress << 142) |\n            (i_.maxCenterPrice.toBigNumber(20, 8, BigMathMinified.ROUND_UP) << 172) |\n            (i_.minCenterPrice.toBigNumber(20, 8, BigMathMinified.ROUND_DOWN) << 200) |\n            (THREE_DECIMALS << 228) | // setting initial token0 max utilization to 100%\n            (THREE_DECIMALS << 238); // setting initial token1 max utilization to 100%\n\n        emit LogInitializePoolConfig(\n            i_.smartCol,\n            i_.smartDebt,\n            i_.token0ColAmt,\n            i_.token0DebtAmt,\n            i_.fee,\n            i_.revenueCut * FOUR_DECIMALS,\n            i_.centerPriceAddress,\n            i_.hookAddress\n        );\n\n        emit LogInitializePriceParams(\n            i_.upperPercent,\n            i_.lowerPercent,\n            i_.upperShiftThreshold * THREE_DECIMALS,\n            i_.lowerShiftThreshold * THREE_DECIMALS,\n            i_.thresholdShiftTime,\n            i_.maxCenterPrice,\n            i_.minCenterPrice\n        );\n    }\n\n    function pauseSwapAndArbitrage() public _onlyDelegateCall {\n        uint dexVariables2_ = dexVariables2;\n        if ((dexVariables2_ >> 255) == 1) {\n            // already paused\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n        dexVariables2 = dexVariables2_ | (uint(1) << 255);\n\n        emit LogPauseSwapAndArbitrage();\n    }\n\n    function unpauseSwapAndArbitrage() public _onlyDelegateCall {\n        uint dexVariables2_ = dexVariables2;\n        if ((dexVariables2_ >> 255) == 0) {\n            // already unpaused\n            revert FluidDexError(ErrorTypes.DexT1Admin__InvalidParams);\n        }\n        dexVariables2 = (dexVariables2_ << 1) >> 1;\n\n        emit LogUnpauseSwapAndArbitrage();\n    }\n\n    /// @notice sends any potentially stuck funds to Liquidity contract.\n    /// @dev this contract never holds any funds as all operations send / receive funds from user <-> Liquidity.\n    function rescueFunds(address token_) external _onlyDelegateCall {\n        address liquidity_ = IFluidDexT1(address(this)).constantsView().liquidity;\n        if (token_ == NATIVE_TOKEN) {\n            SafeTransfer.safeTransferNative(liquidity_, address(this).balance);\n        } else {\n            SafeTransfer.safeTransfer(token_, liquidity_, IERC20(token_).balanceOf(address(this)));\n        }\n\n        emit LogRescueFunds(token_);\n    }\n}"
    },
    "contracts/protocols/dex/poolT1/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct InitializeVariables {\n        bool smartCol;\n        uint token0ColAmt;\n        bool smartDebt;\n        uint token0DebtAmt;\n        uint centerPrice;\n        uint fee;\n        uint revenueCut;\n        uint upperPercent;\n        uint lowerPercent;\n        uint upperShiftThreshold;\n        uint lowerShiftThreshold;\n        uint thresholdShiftTime;\n        uint centerPriceAddress;\n        uint hookAddress;\n        uint maxCenterPrice;\n        uint minCenterPrice;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/common/constantVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { StorageRead } from \"../../../../libraries/storageRead.sol\";\n\ninterface ITokenDecimals {\n    function decimals() external view returns (uint8);\n}\n\nabstract contract ConstantVariables is StorageRead {\n    /*//////////////////////////////////////////////////////////////\n                          CONSTANTS / IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    address internal constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 internal constant NATIVE_TOKEN_DECIMALS = 18;\n    address internal constant ADDRESS_DEAD = 0x000000000000000000000000000000000000dEaD;\n    uint256 internal constant TOKENS_DECIMALS_PRECISION = 12;\n    uint256 internal constant TOKENS_DECIMALS = 1e12;\n\n    uint256 internal constant SMALL_COEFFICIENT_SIZE = 10;\n    uint256 internal constant DEFAULT_COEFFICIENT_SIZE = 56;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant X2 = 0x3;\n    uint256 internal constant X3 = 0x7;\n    uint256 internal constant X5 = 0x1f;\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X8 = 0xff;\n    uint256 internal constant X9 = 0x1ff;\n    uint256 internal constant X10 = 0x3ff;\n    uint256 internal constant X11 = 0x7ff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X17 = 0x1ffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X20 = 0xfffff;\n    uint256 internal constant X22 = 0x3fffff;\n    uint256 internal constant X23 = 0x7fffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X28 = 0xfffffff;\n    uint256 internal constant X30 = 0x3fffffff;\n    uint256 internal constant X32 = 0xffffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X40 = 0xffffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n    uint256 internal constant X96 = 0xffffffffffffffffffffffff;\n    uint256 internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n\n    uint256 internal constant TWO_DECIMALS = 1e2;\n    uint256 internal constant THREE_DECIMALS = 1e3;\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant FIVE_DECIMALS = 1e5;\n    uint256 internal constant SIX_DECIMALS = 1e6;\n    uint256 internal constant EIGHT_DECIMALS = 1e8;\n    uint256 internal constant NINE_DECIMALS = 1e9;\n\n    uint256 internal constant PRICE_PRECISION = 1e27;\n\n    uint256 internal constant ORACLE_PRECISION = 1e18; // 100%\n    uint256 internal constant ORACLE_LIMIT = 5 * 1e16; // 5%\n\n    /// after swap token0 reserves should not be less than token1InToken0 / MINIMUM_LIQUIDITY_SWAP\n    /// after swap token1 reserves should not be less than token0InToken1 / MINIMUM_LIQUIDITY_SWAP\n    uint256 internal constant MINIMUM_LIQUIDITY_SWAP = 1e4;\n\n    /// after user operations (deposit, withdraw, borrow, payback) token0 reserves should not be less than token1InToken0 / MINIMUM_LIQUIDITY_USER_OPERATIONS\n    /// after user operations (deposit, withdraw, borrow, payback) token1 reserves should not be less than token0InToken0 / MINIMUM_LIQUIDITY_USER_OPERATIONS\n    uint256 internal constant MINIMUM_LIQUIDITY_USER_OPERATIONS = 1e6;\n\n    /// To skip transfers in liquidity layer if token in & out is same and liquidity layer is on the winning side\n    bytes32 internal constant SKIP_TRANSFERS = keccak256(bytes(\"SKIP_TRANSFERS\"));\n\n    function _decimals(address token_) internal view returns (uint256) {\n        return (token_ == NATIVE_TOKEN) ? NATIVE_TOKEN_DECIMALS : ITokenDecimals(token_).decimals();\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/common/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Variables {\n    /*//////////////////////////////////////////////////////////////\n                          STORAGE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// First 1 bit  => 0 => re-entrancy. If 0 then allow transaction to go, else throw.\n    /// Next 40 bits => 1-40 => last to last stored price. BigNumber (32 bits precision, 8 bits exponent)\n    /// Next 40 bits => 41-80 => last stored price of pool. BigNumber (32 bits precision, 8 bits exponent)\n    /// Next 40 bits => 81-120 => center price. Center price from where the ranges will be calculated. BigNumber (32 bits precision, 8 bits exponent)\n    /// Next 33 bits => 121-153 => last interaction time stamp\n    /// Next 22 bits => 154-175 => max 4194303 seconds (~1165 hrs, ~48.5 days), time difference between last to last and last price stored\n    /// Next 3 bits  => 176-178 => oracle checkpoint, if 0 then first slot, if 7 then last slot\n    /// Next 16 bits => 179-194 => current mapping or oracle, after every 8 transaction it will increase by 1. Max capacity is 65535 but it can be lower than that check dexVariables2\n    uint internal dexVariables;\n\n    /// Next  1 bit  => 0 => is smart collateral enabled?\n    /// Next  1 bit  => 1 => is smart debt enabled?\n    /// Next 17 bits => 2-18 => fee (1% = 10000, max value: 100000 = 10%, fee should not be more than 10%)\n    /// Next  7 bits => 19-25 => revenue cut from fee (1 = 1%, 100 = 100%). If fee is 1000 = 0.1% and revenue cut is 10 = 10% then governance get 0.01% of every swap\n    /// Next  1 bit  => 26 => percent active change going on or not, 0 = false, 1 = true, if true than that means governance has updated the below percents and the update should happen with a specified time.\n    /// Next 20 bits => 27-46 => upperPercent (1% = 10000, max value: 104.8575%) upperRange - upperRange * upperPercent = centerPrice. Hence, upperRange = centerPrice / (1 - upperPercent)\n    /// Next 20 bits => 47-66 => lowerPercent. lowerRange = centerPrice - centerPrice * lowerPercent.\n    /// Next  1 bit  => 67 => threshold percent active change going on or not, 0 = false, 1 = true, if true than that means governance has updated the below percents and the update should happen with a specified time.\n    /// Next 10 bits => 68-77 => upper shift threshold percent, 1 = 0.1%. 1000 = 100%. if currentPrice > (centerPrice + (upperRange - centerPrice) * (1000 - upperShiftThresholdPercent) / 1000) then trigger shift\n    /// Next 10 bits => 78-87 => lower shift threshold percent, 1 = 0.1%. 1000 = 100%. if currentPrice < (centerPrice - (centerPrice - lowerRange) * (1000 - lowerShiftThresholdPercent) / 1000) then trigger shift\n    /// Next 24 bits => 88-111 => Shifting time (~194 days) (rate = (% up + % down) / time ?)\n    /// Next 30 bits => 112-131 => Address of center price if center price should be fetched externally, for example, for wstETH <> ETH pool, fetch wstETH exchange rate into stETH from wstETH contract.\n    /// Why fetch it externally? Because let's say pool width is 0.1% and wstETH temporarily got depeg of 0.5% then pool will start to shift to newer pricing\n    /// but we don't want pool to shift to 0.5% because we know the depeg will recover so to avoid the loss for users.\n    /// Next 30 bits => 142-171 => Hooks bits, calculate hook address by storing deployment nonce from factory.\n    /// Next 28 bits => 172-199 => max center price. BigNumber (20 bits precision, 8 bits exponent)\n    /// Next 28 bits => 200-227 => min center price. BigNumber (20 bits precision, 8 bits exponent)\n    /// Next 10 bits => 228-237 => utilization limit of token0. Max value 1000 = 100%, if 100% then no need to check the utilization.\n    /// Next 10 bits => 238-247 => utilization limit of token1. Max value 1000 = 100%, if 100% then no need to check the utilization.\n    /// Next 1  bit  => 248     => is center price shift active\n    /// Last 1  bit  => 255     => Pause swap & arbitrage (only perfect functions will be usable), if we need to pause entire DEX then that can be done through pausing DEX on Liquidity Layer\n    uint internal dexVariables2;\n\n    uint internal _totalSupplyShares;\n\n    /// @dev user supply data: user -> data\n    /// Aside from 1st bit, entire bits here are same as liquidity layer _userSupplyData. Hence exact same supply & borrow limit library can be used\n    /// First  1 bit  =>       0 => is user allowed to supply? 0 = not allowed, 1 = allowed\n    /// Next  64 bits =>   1- 64 => user supply amount/shares; BigMath: 56 | 8\n    /// Next  64 bits =>  65-128 => previous user withdrawal limit; BigMath: 56 | 8\n    /// Next  33 bits => 129-161 => last triggered process timestamp (enough until 16 March 2242 -> max value 8589934591)\n    /// Next  14 bits => 162-175 => expand withdrawal limit percentage (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383).\n    ///                             @dev shrinking is instant\n    /// Next  24 bits => 176-199 => withdrawal limit expand duration in seconds.(Max value 16_777_215; ~4_660 hours, ~194 days)\n    /// Next  18 bits => 200-217 => base withdrawal limit: below this, 100% withdrawals can be done (aka shares can be burned); BigMath: 10 | 8\n    /// Next  38 bits => 218-255 => empty for future use\n    mapping(address => uint) internal _userSupplyData;\n\n    uint internal _totalBorrowShares;\n\n    /// @dev user borrow data: user -> data\n    /// Aside from 1st bit, entire bits here are same as liquidity layer _userBorrowData. Hence exact same supply & borrow limit library function can be used\n    /// First  1 bit  =>       0 => is user allowed to borrow? 0 = not allowed, 1 = allowed\n    /// Next  64 bits =>   1- 64 => user debt amount/shares; BigMath: 56 | 8\n    /// Next  64 bits =>  65-128 => previous user debt ceiling; BigMath: 56 | 8\n    /// Next  33 bits => 129-161 => last triggered process timestamp (enough until 16 March 2242 -> max value 8589934591)\n    /// Next  14 bits => 162-175 => expand debt ceiling percentage (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    ///                             @dev shrinking is instant\n    /// Next  24 bits => 176-199 => debt ceiling expand duration in seconds (Max value 16_777_215; ~4_660 hours, ~194 days)\n    /// Next  18 bits => 200-217 => base debt ceiling: below this, there's no debt ceiling limits; BigMath: 10 | 8\n    /// Next  18 bits => 218-235 => max debt ceiling: absolute maximum debt ceiling can expand to; BigMath: 10 | 8\n    /// Next  20 bits => 236-255 => empty for future use\n    mapping(address => uint) internal _userBorrowData;\n\n    /// Price difference between last swap of last block & last swap of new block\n    /// If last swap happened at Block B - 4 and next swap happened after 4 blocks at Block B then it will store that difference\n    /// considering time difference between these 4 blocks is 48 seconds, hence time will be stored as 48\n    /// New oracle update:\n    /// time to 9 bits and precision to 22 bits\n    /// if time exceeds 9 bits which is 511 sec or ~8.5 min then we will use 2 oracle slot to store the data\n    /// we will leave the both time slot as 0 and on first sign + precision slot we will store time and\n    /// on second sign + precision slot we will store sign & precision\n    /// First 9 bits =>   0-  8 => time, 511 seconds\n    /// Next   1 bit  =>  9     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits =>  10- 31 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits =>  32- 40 => time, 511 seconds\n    /// Next   1 bit  =>  41     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits =>  42- 63 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits =>  64- 72 => time, 511 seconds\n    /// Next   1 bit  =>  73     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits =>  74- 95 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits =>  96-104 => time, 511 seconds\n    /// Next   1 bit  => 105     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits => 106-127 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits => 128-136 => time, 511 seconds\n    /// Next   1 bit  => 137     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits => 138-159 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits => 160-168 => time, 511 seconds\n    /// Next   1 bit  => 169     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits => 170-191 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits => 192-200 => time, 511 seconds\n    /// Next   1 bit  => 201     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits => 202-223 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    /// Next  9 bits => 224-232 => time, 511 seconds\n    /// Next   1 bit  => 233     => sign of percent in change, if 1 then 0 or positive, else negative\n    /// Next  22 bits => 234-255 => 4194303, change in price, max change is capped to 5%, so 4194303 = 5%, 1 = 0.0000011920931797249746%\n    mapping(uint => uint) internal _oracle;\n\n    /// First 20 bits =>  0-19 => old upper shift\n    /// Next  20 bits => 20-39 => old lower shift\n    /// Next  20 bits => 40-59 => in seconds, ~12 days max, shift can last for max ~12 days\n    /// Next  33 bits => 60-92 => timestamp of when the shift has started.\n    uint128 internal _rangeShift;\n\n    /// First 10 bits =>  0- 9 => old upper shift\n    /// Next  10 bits => 10-19 => empty so we can use same helper function\n    /// Next  10 bits => 20-29 => old lower shift\n    /// Next  10 bits => 30-39 => empty so we can use same helper function\n    /// Next  20 bits => 40-59 => in seconds, ~12 days max, shift can last for max ~12 days\n    /// Next  33 bits => 60-92 => timestamp of when the shift has started.\n    /// Next  24 bits => 93-116 => old threshold time\n    uint128 internal _thresholdShift;\n\n    /// Shifting is fuzzy and with time it'll keep on getting closer and then eventually get over\n    /// First 33 bits => 0 -32 => starting timestamp\n    /// Next  20 bits => 33-52 => % shift\n    /// Next  20 bits => 53-72 => time to shift that percent\n    uint256 internal _centerPriceShift;\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/core/colOperations.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SecondaryHelpers } from \"../helpers/secondaryHelpers.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @title FluidDexT1\n/// @notice Implements core logics for Fluid Dex protocol.\n/// Note Token transfers happen directly from user to Liquidity contract and vice-versa.\ncontract FluidDexT1OperationsCol is SecondaryHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) SecondaryHelpers(constantViews_) {\n        // all implementations should be zero other than shift\n        if (\n            constantViews_.implementations.shift == address(0) ||\n            constantViews_.implementations.admin != address(0) ||\n            constantViews_.implementations.colOperations != address(0) ||\n            constantViews_.implementations.debtOperations != address(0) ||\n            constantViews_.implementations.perfectOperationsAndSwapOut != address(0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__InvalidImplementation);\n        }\n    }\n\n    modifier _onlyDelegateCall() {\n        // also indirectly checked by `_check` because pool can never be initialized as long as the initialize method\n        // is delegate call only, but just to be sure on Admin logic we add the modifier everywhere nonetheless.\n        if (address(this) == THIS_CONTRACT) {\n            revert FluidDexError(ErrorTypes.DexT1__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) public payable _onlyDelegateCall returns (uint shares_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userSupplyData_ = _userSupplyData[msg.sender];\n\n        if (userSupplyData_ & 1 == 0 && !estimate_) revert FluidDexError(ErrorTypes.DexT1__UserSupplyInNotOn);\n\n        // is smart collateral pool enabled\n        if ((dexVariables2_ & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            DepositColMemory memory d_;\n\n            CollateralReserves memory c_ = _getCollateralReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.supplyToken0ExchangePrice,\n                pex_.supplyToken1ExchangePrice\n            );\n            CollateralReserves memory c2_ = c_;\n\n            if (token0Amt_ > 0) {\n                d_.token0AmtAdjusted =\n                    (((token0Amt_ - 1) * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION) -\n                    1;\n                _verifySwapAndNonPerfectActions(d_.token0AmtAdjusted, token0Amt_);\n                _verifyMint(d_.token0AmtAdjusted, c_.token0RealReserves);\n            }\n\n            if (token1Amt_ > 0) {\n                d_.token1AmtAdjusted =\n                    (((token1Amt_ - 1) * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION) -\n                    1;\n                _verifySwapAndNonPerfectActions(d_.token1AmtAdjusted, token1Amt_);\n                _verifyMint(d_.token1AmtAdjusted, c_.token1RealReserves);\n            }\n\n            uint temp_;\n            uint temp2_;\n\n            uint totalSupplyShares_ = _totalSupplyShares;\n            if ((c_.token0RealReserves > 0) && (c_.token1RealReserves > 0)) {\n                if (d_.token0AmtAdjusted > 0 && d_.token1AmtAdjusted > 0) {\n                    // mint shares in equal proportion\n                    // temp_ => expected shares from token0 deposit\n                    temp_ = (d_.token0AmtAdjusted * 1e18) / c_.token0RealReserves;\n                    // temp2_ => expected shares from token1 deposit\n                    temp2_ = (d_.token1AmtAdjusted * 1e18) / c_.token1RealReserves;\n                    if (temp_ > temp2_) {\n                        // use temp2_ shares\n                        shares_ = (temp2_ * totalSupplyShares_) / 1e18;\n                        // temp_ => token0 to swap\n                        temp_ = ((temp_ - temp2_) * c_.token0RealReserves) / 1e18;\n                        temp2_ = 0;\n                    } else if (temp2_ > temp_) {\n                        // use temp_ shares\n                        shares_ = (temp_ * totalSupplyShares_) / 1e18;\n                        // temp2_ => token1 to swap\n                        temp2_ = ((temp2_ - temp_) * c_.token1RealReserves) / 1e18;\n                        temp_ = 0;\n                    } else {\n                        // if equal then revert as swap will not be needed anymore which can create some issue, better to use depositPerfect in this case\n                        revert FluidDexError(ErrorTypes.DexT1__InvalidDepositAmts);\n                    }\n\n                    // User deposited in equal proportion here. Hence updating col reserves and the swap will happen on updated col reserves\n                    c2_ = _getUpdatedColReserves(shares_, totalSupplyShares_, c_, true);\n\n                    totalSupplyShares_ += shares_;\n                } else if (d_.token0AmtAdjusted > 0) {\n                    temp_ = d_.token0AmtAdjusted;\n                    temp2_ = 0;\n                } else if (d_.token1AmtAdjusted > 0) {\n                    temp_ = 0;\n                    temp2_ = d_.token1AmtAdjusted;\n                } else {\n                    // user sent both amounts as 0\n                    revert FluidDexError(ErrorTypes.DexT1__InvalidDepositAmts);\n                }\n\n                if (temp_ > 0) {\n                    // swap token0\n                    temp_ = _getSwapAndDeposit(\n                        temp_, // token0 to divide and swap\n                        c2_.token1ImaginaryReserves, // token1 imaginary reserves\n                        c2_.token0ImaginaryReserves, // token0 imaginary reserves\n                        c2_.token0RealReserves, // token0 real reserves\n                        c2_.token1RealReserves // token1 real reserves\n                    );\n                } else if (temp2_ > 0) {\n                    // swap token1\n                    temp_ = _getSwapAndDeposit(\n                        temp2_, // token1 to divide and swap\n                        c2_.token0ImaginaryReserves, // token0 imaginary reserves\n                        c2_.token1ImaginaryReserves, // token1 imaginary reserves\n                        c2_.token1RealReserves, // token1 real reserves\n                        c2_.token0RealReserves // token0 real reserves\n                    );\n                } else {\n                    // maybe possible to happen due to some precision issue that both are 0\n                    revert FluidDexError(ErrorTypes.DexT1__DepositAmtsZero);\n                }\n\n                // new shares minted from swap & deposit\n                temp_ = (temp_ * totalSupplyShares_) / 1e18;\n                // adding fee in case of swap & deposit\n                // 1 - fee. If fee is 1% then without fee will be 1e6 - 1e4\n                // temp_ => withdraw fee\n                temp_ = (temp_ * (SIX_DECIMALS - ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n                // final new shares to mint for user\n                shares_ += temp_;\n                // final new collateral shares\n                totalSupplyShares_ += temp_;\n            } else {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidCollateralReserves);\n            }\n\n            if (estimate_) revert FluidDexLiquidityOutput(shares_);\n\n            if (shares_ < minSharesAmt_) revert FluidDexError(ErrorTypes.DexT1__SharesMintedLess);\n\n            if (token0Amt_ > 0) {\n                _verifyToken1Reserves(\n                    (c_.token0RealReserves + d_.token0AmtAdjusted),\n                    (c_.token1RealReserves + d_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                temp_ = token0Amt_;\n                _depositOrPaybackInLiquidity(TOKEN_0, temp_, 0);\n            }\n\n            if (token1Amt_ > 0) {\n                _verifyToken0Reserves(\n                    (c_.token0RealReserves + d_.token0AmtAdjusted),\n                    (c_.token1RealReserves + d_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                temp_ = token1Amt_;\n                _depositOrPaybackInLiquidity(TOKEN_1, temp_, 0);\n            }\n\n            // userSupply_ => temp_\n            temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            // extracting exisiting shares and then adding new shares in it\n            temp_ = ((temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK));\n\n            // calculate current, updated (expanded etc.) withdrawal limit\n            // newWithdrawalLimit_ => temp2_\n            temp2_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, temp_);\n\n            temp_ += shares_;\n\n            _updatingUserSupplyDataOnStorage(userSupplyData_, temp_, temp2_);\n\n            // updating total col shares in storage\n            _totalSupplyShares = totalSupplyShares_;\n\n            emit LogDepositColLiquidity(token0Amt_, token1Amt_, shares_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartColNotEnabled);\n        }\n    }\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) public _onlyDelegateCall returns (uint shares_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userSupplyData_ = _userSupplyData[msg.sender];\n\n        if (userSupplyData_ & 1 == 0 && to_ != ADDRESS_DEAD) revert FluidDexError(ErrorTypes.DexT1__UserSupplyInNotOn);\n\n        WithdrawColMemory memory w_;\n\n        w_.to = (to_ == address(0)) ? msg.sender : to_;\n\n        // is smart collateral pool enabled\n        if ((dexVariables2_ & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            uint token0Reserves_ = _getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, pex_.supplyToken0ExchangePrice, true);\n            uint token1Reserves_ = _getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, pex_.supplyToken1ExchangePrice, false);\n            w_.token0ReservesInitial = token0Reserves_;\n            w_.token1ReservesInitial = token1Reserves_;\n\n            if (token0Amt_ > 0) {\n                w_.token0AmtAdjusted =\n                    (((token0Amt_ + 1) * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION) +\n                    1;\n                _verifySwapAndNonPerfectActions(w_.token0AmtAdjusted, token0Amt_);\n                _verifyRedeem(w_.token0AmtAdjusted, token0Reserves_);\n            }\n\n            if (token1Amt_ > 0) {\n                w_.token1AmtAdjusted =\n                    (((token1Amt_ + 1) * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION) +\n                    1;\n                _verifySwapAndNonPerfectActions(w_.token1AmtAdjusted, token1Amt_);\n                _verifyRedeem(w_.token1AmtAdjusted, token1Reserves_);\n            }\n\n            uint temp_;\n            uint temp2_;\n\n            uint totalSupplyShares_ = _totalSupplyShares;\n            if ((token0Reserves_ > 0) && (token1Reserves_ > 0)) {\n                if (w_.token0AmtAdjusted > 0 && w_.token1AmtAdjusted > 0) {\n                    // mint shares in equal proportion\n                    // temp_ => expected shares from token0 withdraw\n                    temp_ = (w_.token0AmtAdjusted * 1e18) / token0Reserves_;\n                    // temp2_ => expected shares from token1 withdraw\n                    temp2_ = (w_.token1AmtAdjusted * 1e18) / token1Reserves_;\n                    if (temp_ > temp2_) {\n                        // use temp2_ shares\n                        shares_ = ((temp2_ * totalSupplyShares_) / 1e18);\n                        // temp_ => token0 to swap\n                        temp_ = ((temp_ - temp2_) * token0Reserves_) / 1e18;\n                        temp2_ = 0;\n                    } else if (temp2_ > temp_) {\n                        // use temp1_ shares\n                        shares_ = ((temp_ * totalSupplyShares_) / 1e18);\n                        // temp2_ => token1 to swap\n                        temp2_ = ((temp2_ - temp_) * token1Reserves_) / 1e18;\n                        temp_ = 0;\n                    } else {\n                        // if equal then revert as swap will not be needed anymore which can create some issue, better to use withdraw in perfect proportion for this\n                        revert FluidDexError(ErrorTypes.DexT1__InvalidWithdrawAmts);\n                    }\n\n                    // User withdrew in equal proportion here. Hence updating col reserves and the swap will happen on updated col reserves\n                    token0Reserves_ = token0Reserves_ - ((token0Reserves_ * shares_) / totalSupplyShares_);\n                    token1Reserves_ = token1Reserves_ - ((token1Reserves_ * shares_) / totalSupplyShares_);\n                    totalSupplyShares_ -= shares_;\n                } else if (w_.token0AmtAdjusted > 0) {\n                    temp_ = w_.token0AmtAdjusted;\n                    temp2_ = 0;\n                } else if (w_.token1AmtAdjusted > 0) {\n                    temp_ = 0;\n                    temp2_ = w_.token1AmtAdjusted;\n                } else {\n                    // user sent both amounts as 0\n                    revert FluidDexError(ErrorTypes.DexT1__WithdrawAmtsZero);\n                }\n\n                uint token0ImaginaryReservesOutsideRangpex_;\n                uint token1ImaginaryReservesOutsideRangpex_;\n\n                if (pex_.geometricMean < 1e27) {\n                    (\n                        token0ImaginaryReservesOutsideRangpex_,\n                        token1ImaginaryReservesOutsideRangpex_\n                    ) = _calculateReservesOutsideRange(\n                        pex_.geometricMean,\n                        pex_.upperRange,\n                        (token0Reserves_ - temp_),\n                        (token1Reserves_ - temp2_)\n                    );\n                } else {\n                    // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n                    // 1 / geometricMean for new geometricMean\n                    // 1 / lowerRange will become upper range\n                    // 1 / upperRange will become lower range\n                    (\n                        token1ImaginaryReservesOutsideRangpex_,\n                        token0ImaginaryReservesOutsideRangpex_\n                    ) = _calculateReservesOutsideRange(\n                        (1e54 / pex_.geometricMean),\n                        (1e54 / pex_.lowerRange),\n                        (token1Reserves_ - temp2_),\n                        (token0Reserves_ - temp_)\n                    );\n                }\n\n                if (temp_ > 0) {\n                    // swap into token0\n                    temp_ = _getWithdrawAndSwap(\n                        token0Reserves_, // token0 real reserves\n                        token1Reserves_, // token1 real reserves\n                        token0ImaginaryReservesOutsideRangpex_, // token0 imaginary reserves\n                        token1ImaginaryReservesOutsideRangpex_, // token1 imaginary reserves\n                        temp_ // token0 to divide and swap into\n                    );\n                } else if (temp2_ > 0) {\n                    // swap into token1\n                    temp_ = _getWithdrawAndSwap(\n                        token1Reserves_, // token1 real reserves\n                        token0Reserves_, // token0 real reserves\n                        token1ImaginaryReservesOutsideRangpex_, // token1 imaginary reserves\n                        token0ImaginaryReservesOutsideRangpex_, // token0 imaginary reserves\n                        temp2_ // token0 to divide and swap into\n                    );\n                } else {\n                    // maybe possible to happen due to some precision issue that both are 0\n                    revert FluidDexError(ErrorTypes.DexT1__WithdrawAmtsZero);\n                }\n\n                // shares to burn from withdraw & swap\n                temp_ = ((temp_ * totalSupplyShares_) / 1e18);\n                // adding fee in case of withdraw & swap\n                // 1 + fee. If fee is 1% then withdrawing withFepex_ will be 1e6 + 1e4\n                temp_ = (temp_ * (SIX_DECIMALS + ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n                // updating shares to burn for user\n                shares_ += temp_;\n                // final new collateral shares\n                totalSupplyShares_ -= temp_;\n            } else {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidCollateralReserves);\n            }\n\n            if (to_ == ADDRESS_DEAD) revert FluidDexLiquidityOutput(shares_);\n\n            if (shares_ > maxSharesAmt_) revert FluidDexError(ErrorTypes.DexT1__WithdrawExcessSharesBurn);\n\n            // userSupply_ => temp_\n            temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) withdrawal limit\n            // newWithdrawalLimit_ => temp2_\n            temp2_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, temp_);\n\n            temp_ -= shares_;\n\n            // withdrawal limit reached\n            if (temp_ < temp2_) revert FluidDexError(ErrorTypes.DexT1__WithdrawLimitReached);\n\n            _updatingUserSupplyDataOnStorage(userSupplyData_, temp_, temp2_);\n\n            // updating total col shares in storage\n            _totalSupplyShares = totalSupplyShares_;\n\n            if (w_.token0AmtAdjusted > 0) {\n                _verifyToken0Reserves(\n                    (w_.token0ReservesInitial - w_.token0AmtAdjusted),\n                    (w_.token1ReservesInitial - w_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // withdraw\n                temp_ = token0Amt_;\n                LIQUIDITY.operate(TOKEN_0, -int(temp_), 0, w_.to, address(0), new bytes(0));\n            }\n\n            if (w_.token1AmtAdjusted > 0) {\n                _verifyToken1Reserves(\n                    (w_.token0ReservesInitial - w_.token0AmtAdjusted),\n                    (w_.token1ReservesInitial - w_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // withdraw\n                temp_ = token1Amt_;\n                LIQUIDITY.operate(TOKEN_1, -int(temp_), 0, w_.to, address(0), new bytes(0));\n            }\n\n            emit LogWithdrawColLiquidity(token0Amt_, token1Amt_, shares_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartColNotEnabled);\n        }\n    }\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) public _onlyDelegateCall returns (uint withdrawAmt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userSupplyData_ = _userSupplyData[msg.sender];\n\n        if (userSupplyData_ & 1 == 0 && to_ != ADDRESS_DEAD) {\n            revert FluidDexError(ErrorTypes.DexT1__UserSupplyInNotOn);\n        }\n\n        to_ = (to_ == address(0)) ? msg.sender : to_;\n\n        if ((minToken0_ > 0 && minToken1_ > 0) || (minToken0_ == 0 && minToken1_ == 0)) {\n            // only 1 token should be > 0\n            revert FluidDexError(ErrorTypes.DexT1__InvalidWithdrawAmts);\n        }\n\n        // is smart collateral pool enabled\n        if ((dexVariables2_ & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            uint totalSupplyShares_ = _totalSupplyShares;\n\n            _verifyRedeem(shares_, totalSupplyShares_);\n\n            uint token0Amt_;\n            uint token1Amt_;\n\n            CollateralReserves memory c_ = _getCollateralReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.supplyToken0ExchangePrice,\n                pex_.supplyToken1ExchangePrice\n            );\n\n            if ((c_.token0RealReserves == 0) || (c_.token1RealReserves == 0)) {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidCollateralReserves);\n            }\n            \n            CollateralReserves memory c2_ = _getUpdatedColReserves(shares_, totalSupplyShares_, c_, false);\n            // Storing exact token0 & token1 raw/adjusted withdrawal amount after burning shares\n            token0Amt_ = c_.token0RealReserves - c2_.token0RealReserves - 1;\n            token1Amt_ = c_.token1RealReserves - c2_.token1RealReserves - 1;\n\n            if (minToken0_ > 0) {\n                // user wants to withdraw entirely in token0, hence swapping token1 into token0\n                token0Amt_ += _getAmountOut(token1Amt_, c2_.token1ImaginaryReserves, c2_.token0ImaginaryReserves);\n                token1Amt_ = 0;\n                _verifyToken0Reserves(\n                    (c_.token0RealReserves - token0Amt_),\n                    c_.token1RealReserves,\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n\n                // converting token0Amt_ from raw/adjusted to normal token amount\n                token0Amt_ = (((token0Amt_ - 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) - 1;\n\n                // deducting fee on withdrawing in 1 token\n                token0Amt_ = (token0Amt_ * (SIX_DECIMALS - ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n\n                withdrawAmt_ = token0Amt_;\n                if (to_ == ADDRESS_DEAD) revert FluidDexLiquidityOutput(shares_);\n                if (withdrawAmt_ < minToken0_) revert FluidDexError(ErrorTypes.DexT1__WithdrawalNotEnough);\n            } else {\n                // user wants to withdraw entirely in token1, hence swapping token0 into token1\n                token1Amt_ += _getAmountOut(token0Amt_, c2_.token0ImaginaryReserves, c2_.token1ImaginaryReserves);\n                token0Amt_ = 0;\n                _verifyToken1Reserves(\n                    c_.token0RealReserves,\n                    (c_.token1RealReserves - token1Amt_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n\n                // converting token1Amt_ from raw/adjusted to normal token amount\n                token1Amt_ = (((token1Amt_ - 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) - 1;\n\n                // deducting fee on withdrawing in 1 token\n                token1Amt_ = (token1Amt_ * (SIX_DECIMALS - ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n\n                withdrawAmt_ = token1Amt_;\n                if (to_ == ADDRESS_DEAD) revert FluidDexLiquidityOutput(shares_);\n                if (withdrawAmt_ < minToken1_) revert FluidDexError(ErrorTypes.DexT1__WithdrawalNotEnough);\n            }\n\n            uint256 userSupply_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            userSupply_ = (userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) withdrawal limit\n            // temp_ => newWithdrawalLimit_\n            uint256 temp_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\n\n            userSupply_ -= shares_;\n\n            // withdraws below limit\n            if (userSupply_ < temp_) revert FluidDexError(ErrorTypes.DexT1__WithdrawLimitReached);\n\n            _updatingUserSupplyDataOnStorage(userSupplyData_, userSupply_, temp_);\n\n            _totalSupplyShares = totalSupplyShares_ - shares_;\n\n            // to avoid stack-too-deep error\n            temp_ = uint160(to_);\n            if (minToken0_ > 0) {\n                // withdraw\n                LIQUIDITY.operate(TOKEN_0, -int(token0Amt_), 0, address(uint160(temp_)), address(0), new bytes(0));\n            } else {\n                // withdraw\n                LIQUIDITY.operate(TOKEN_1, -int(token1Amt_), 0, address(uint160(temp_)), address(0), new bytes(0));\n            }\n\n            // to avoid stack-too-deep error\n            temp_ = shares_;\n            emit LogWithdrawColInOneToken(temp_, token0Amt_, token1Amt_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartColNotEnabled);\n        }\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/core/debtOperations.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SecondaryHelpers } from \"../helpers/secondaryHelpers.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @title FluidDexT1\n/// @notice Implements core logics for Fluid Dex protocol.\n/// Note Token transfers happen directly from user to Liquidity contract and vice-versa.\ncontract FluidDexT1OperationsDebt is SecondaryHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) SecondaryHelpers(constantViews_) {\n        // all implementations should be zero other than shift\n        if (\n            constantViews_.implementations.shift == address(0) ||\n            constantViews_.implementations.admin != address(0) ||\n            constantViews_.implementations.colOperations != address(0) ||\n            constantViews_.implementations.debtOperations != address(0) ||\n            constantViews_.implementations.perfectOperationsAndSwapOut != address(0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__InvalidImplementation);\n        }\n    }\n\n    modifier _onlyDelegateCall() {\n        // also indirectly checked by `_check` because pool can never be initialized as long as the initialize method\n        // is delegate call only, but just to be sure on Admin logic we add the modifier everywhere nonetheless.\n        if (address(this) == THIS_CONTRACT) {\n            revert FluidDexError(ErrorTypes.DexT1__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_ \n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) public _onlyDelegateCall returns (uint shares_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userBorrowData_ = _userBorrowData[msg.sender];\n\n        if (userBorrowData_ & 1 == 0 && to_ != ADDRESS_DEAD) revert FluidDexError(ErrorTypes.DexT1__UserDebtInNotOn);\n\n        BorrowDebtMemory memory b_;\n\n        b_.to = (to_ == address(0)) ? msg.sender : to_;\n\n        // is smart debt pool enabled\n        if (((dexVariables2_ >> 1) & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            uint token0Debt_ = _getLiquidityDebt(BORROW_TOKEN_0_SLOT, pex_.borrowToken0ExchangePrice, true);\n            uint token1Debt_ = _getLiquidityDebt(BORROW_TOKEN_1_SLOT, pex_.borrowToken1ExchangePrice, false);\n            b_.token0DebtInitial = token0Debt_;\n            b_.token1DebtInitial = token1Debt_;\n\n            if (token0Amt_ > 0) {\n                b_.token0AmtAdjusted =\n                    (((token0Amt_ + 1) * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION) +\n                    1;\n                _verifySwapAndNonPerfectActions(b_.token0AmtAdjusted, token0Amt_);\n                _verifyMint(b_.token0AmtAdjusted, token0Debt_);\n            }\n\n            if (token1Amt_ > 0) {\n                b_.token1AmtAdjusted =\n                    (((token1Amt_ + 1) * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION) +\n                    1;\n                _verifySwapAndNonPerfectActions(b_.token1AmtAdjusted, token1Amt_);\n                _verifyMint(b_.token1AmtAdjusted, token1Debt_);\n            }\n\n            uint temp_;\n            uint temp2_;\n\n            uint totalBorrowShares_ = _totalBorrowShares;\n            if ((token0Debt_ > 0) && (token1Debt_ > 0)) {\n                if (b_.token0AmtAdjusted > 0 && b_.token1AmtAdjusted > 0) {\n                    // mint shares in equal proportion\n                    // temp_ => expected shares from token0 payback\n                    temp_ = (b_.token0AmtAdjusted * 1e18) / token0Debt_;\n                    // temp2_ => expected shares from token1 payback\n                    temp2_ = (b_.token1AmtAdjusted * 1e18) / token1Debt_;\n                    if (temp_ > temp2_) {\n                        // use temp2_ shares\n                        shares_ = (temp2_ * totalBorrowShares_) / 1e18;\n                        // temp_ => token0 to swap\n                        temp_ = ((temp_ - temp2_) * token0Debt_) / 1e18;\n                        temp2_ = 0;\n                    } else if (temp2_ > temp_) {\n                        // use temp1_ shares\n                        shares_ = (temp_ * totalBorrowShares_) / 1e18;\n                        // temp2_ => token1 to swap\n                        temp2_ = ((temp2_ - temp_) * token1Debt_) / 1e18;\n                        temp_ = 0;\n                    } else {\n                        // if equal then revert as swap will not be needed anymore which can create some issue, better to use perfect borrow in this case\n                        revert FluidDexError(ErrorTypes.DexT1__InvalidBorrowAmts);\n                    }\n\n                    // User borrowed in equal proportion here. Hence updating col reserves and the swap will happen on updated col reserves\n                    token0Debt_ = token0Debt_ + (token0Debt_ * shares_) / totalBorrowShares_;\n                    token1Debt_ = token1Debt_ + (token1Debt_ * shares_) / totalBorrowShares_;\n                    totalBorrowShares_ += shares_;\n                } else if (b_.token0AmtAdjusted > 0) {\n                    temp_ = b_.token0AmtAdjusted;\n                    temp2_ = 0;\n                } else if (b_.token1AmtAdjusted > 0) {\n                    temp_ = 0;\n                    temp2_ = b_.token1AmtAdjusted;\n                } else {\n                    // user sent both amounts as 0\n                    revert FluidDexError(ErrorTypes.DexT1__InvalidBorrowAmts);\n                }\n\n                uint token0FinalImaginaryReserves_;\n                uint token1FinalImaginaryReserves_;\n\n                if (pex_.geometricMean < 1e27) {\n                    (, , token0FinalImaginaryReserves_, token1FinalImaginaryReserves_) = _calculateDebtReserves(\n                        pex_.geometricMean,\n                        pex_.lowerRange,\n                        (token0Debt_ + temp_),\n                        (token1Debt_ + temp2_)\n                    );\n                } else {\n                    // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n                    // 1 / geometricMean for new geometricMean\n                    // 1 / lowerRange will become upper range\n                    // 1 / upperRange will become lower range\n                    (, , token1FinalImaginaryReserves_, token0FinalImaginaryReserves_) = _calculateDebtReserves(\n                        (1e54 / pex_.geometricMean),\n                        (1e54 / pex_.upperRange),\n                        (token1Debt_ + temp2_),\n                        (token0Debt_ + temp_)\n                    );\n                }\n\n                if (temp_ > 0) {\n                    // swap into token0\n                    temp_ = _getBorrowAndSwap(\n                        token0Debt_, // token0 debt\n                        token1Debt_, // token1 debt\n                        token0FinalImaginaryReserves_, // token0 imaginary reserves\n                        token1FinalImaginaryReserves_, // token1 imaginary reserves\n                        temp_ // token0 to divide and swap into\n                    );\n                } else if (temp2_ > 0) {\n                    // swap into token1\n                    temp_ = _getBorrowAndSwap(\n                        token1Debt_, // token1 debt\n                        token0Debt_, // token0 debt\n                        token1FinalImaginaryReserves_, // token1 imaginary reserves\n                        token0FinalImaginaryReserves_, // token0 imaginary reserves\n                        temp2_ // token1 to divide and swap into\n                    );\n                } else {\n                    // maybe possible to happen due to some precision issue that both are 0\n                    revert FluidDexError(ErrorTypes.DexT1__BorrowAmtsZero);\n                }\n\n                // new shares to mint from borrow & swap\n                temp_ = (temp_ * totalBorrowShares_) / 1e18;\n                // adding fee in case of borrow & swap\n                // 1 + fee. If fee is 1% then withdrawing withFepex_ will be 1e6 + 1e4\n                temp_ = (temp_ * (SIX_DECIMALS + ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n                // final new shares to mint for user\n                shares_ += temp_;\n                // final new debt shares\n                totalBorrowShares_ += temp_;\n            } else {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidDebtReserves);\n            }\n\n            if (to_ == ADDRESS_DEAD) revert FluidDexLiquidityOutput(shares_);\n\n            if (shares_ > maxSharesAmt_) revert FluidDexError(ErrorTypes.DexT1__BorrowExcessSharesMinted);\n\n            // extract user borrow amount\n            // userBorrow_ => temp_\n            temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) borrow limit\n            // newBorrowLimit_ => temp2_\n            temp2_ = DexCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, temp_);\n\n            temp_ += shares_;\n\n            // user above debt limit\n            if (temp_ > temp2_) revert FluidDexError(ErrorTypes.DexT1__DebtLimitReached);\n\n            _updatingUserBorrowDataOnStorage(userBorrowData_, temp_, temp2_);\n\n            if (b_.token0AmtAdjusted > 0) {\n                // comparing debt here rather than reserves to simply code, impact won't be much overall\n                _verifyToken1Reserves(\n                    (b_.token0DebtInitial + b_.token0AmtAdjusted),\n                    (b_.token1DebtInitial + b_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // assigning token0Amt_ to temp_ to avoid compilation error (I don't know why it's throwing when using token0Amt_ directly)\n                temp_ = token0Amt_;\n                // borrow\n                LIQUIDITY.operate(TOKEN_0, 0, int(temp_), address(0), b_.to, new bytes(0));\n            }\n\n            if (b_.token1AmtAdjusted > 0) {\n                // comparing debt here rather than reserves to simply code, impact won't be much overall\n                _verifyToken0Reserves(\n                    (b_.token0DebtInitial + b_.token0AmtAdjusted),\n                    (b_.token1DebtInitial + b_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // assigning token1Amt_ to temp_ to avoid compilation error (I don't know why it's throwing when using token0Amt_ directly)\n                temp_ = token1Amt_;\n                // borrow\n                LIQUIDITY.operate(TOKEN_1, 0, int(temp_), address(0), b_.to, new bytes(0));\n            }\n\n            // updating total debt shares in storage\n            _totalBorrowShares = totalBorrowShares_;\n\n            emit LogBorrowDebtLiquidity(token0Amt_, token1Amt_, shares_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartDebtNotEnabled);\n        }\n    }\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) public payable _onlyDelegateCall returns (uint shares_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userBorrowData_ = _userBorrowData[msg.sender];\n\n        if (userBorrowData_ & 1 == 0 && !estimate_) revert FluidDexError(ErrorTypes.DexT1__UserDebtInNotOn);\n\n        // is smart debt pool enabled\n        if (((dexVariables2_ >> 1) & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            PaybackDebtMemory memory p_;\n\n            DebtReserves memory d_ = _getDebtReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.borrowToken0ExchangePrice,\n                pex_.borrowToken1ExchangePrice\n            );\n            DebtReserves memory d2_ = d_;\n\n            if (token0Amt_ > 0) {\n                p_.token0AmtAdjusted =\n                    (((token0Amt_ - 1) * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION) -\n                    1;\n                _verifySwapAndNonPerfectActions(p_.token0AmtAdjusted, token0Amt_);\n                _verifyRedeem(p_.token0AmtAdjusted, d_.token0Debt);\n            }\n\n            if (token1Amt_ > 0) {\n                p_.token1AmtAdjusted =\n                    (((token1Amt_ - 1) * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION) -\n                    1;\n                _verifySwapAndNonPerfectActions(p_.token1AmtAdjusted, token1Amt_);\n                _verifyRedeem(p_.token1AmtAdjusted, d_.token1Debt);\n            }\n\n            uint temp_;\n            uint temp2_;\n\n            uint totalBorrowShares_ = _totalBorrowShares;\n            if ((d_.token0Debt > 0) && (d_.token1Debt > 0)) {\n                if (p_.token0AmtAdjusted > 0 && p_.token1AmtAdjusted > 0) {\n                    // burn shares in equal proportion\n                    // temp_ => expected shares from token0 payback\n                    temp_ = (p_.token0AmtAdjusted * 1e18) / d_.token0Debt;\n                    // temp2_ => expected shares from token1 payback\n                    temp2_ = (p_.token1AmtAdjusted * 1e18) / d_.token1Debt;\n                    if (temp_ > temp2_) {\n                        // use temp2_ shares\n                        shares_ = ((temp2_ * totalBorrowShares_) / 1e18);\n                        // temp_ => token0 to swap\n                        temp_ = p_.token0AmtAdjusted - (temp2_ * p_.token0AmtAdjusted) / temp_;\n                        temp2_ = 0;\n                    } else if (temp2_ > temp_) {\n                        // use temp_ shares\n                        shares_ = ((temp_ * totalBorrowShares_) / 1e18);\n                        // temp2_ => token1 to swap\n                        temp2_ = p_.token1AmtAdjusted - ((temp_ * p_.token1AmtAdjusted) / temp2_); // to this\n                        temp_ = 0;\n                    } else {\n                        // if equal then revert as swap will not be needed anymore which can create some issue, better to use perfect payback in this case\n                        revert FluidDexError(ErrorTypes.DexT1__InvalidPaybackAmts);\n                    }\n\n                    // User paid back in equal proportion here. Hence updating debt reserves and the swap will happen on updated debt reserves\n                    d2_ = _getUpdateDebtReserves(\n                        shares_,\n                        totalBorrowShares_,\n                        d_,\n                        false // true if mint, false if burn\n                    );\n                    totalBorrowShares_ -= shares_;\n                } else if (p_.token0AmtAdjusted > 0) {\n                    temp_ = p_.token0AmtAdjusted;\n                    temp2_ = 0;\n                } else if (p_.token1AmtAdjusted > 0) {\n                    temp_ = 0;\n                    temp2_ = p_.token1AmtAdjusted;\n                } else {\n                    // user sent both amounts as 0\n                    revert FluidDexError(ErrorTypes.DexT1__InvalidPaybackAmts);\n                }\n\n                if (temp_ > 0) {\n                    // swap token0 into token1 and payback equally\n                    temp_ = _getSwapAndPayback(\n                        d2_.token0Debt,\n                        d2_.token1Debt,\n                        d2_.token0ImaginaryReserves,\n                        d2_.token1ImaginaryReserves,\n                        temp_\n                    );\n                } else if (temp2_ > 0) {\n                    // swap token1 into token0 and payback equally\n                    temp_ = _getSwapAndPayback(\n                        d2_.token1Debt,\n                        d2_.token0Debt,\n                        d2_.token1ImaginaryReserves,\n                        d2_.token0ImaginaryReserves,\n                        temp2_\n                    );\n                } else {\n                    // maybe possible to happen due to some precision issue that both are 0\n                    revert FluidDexError(ErrorTypes.DexT1__PaybackAmtsZero);\n                }\n\n                // new shares to burn from payback & swap\n                temp_ = ((temp_ * totalBorrowShares_) / 1e18);\n\n                // adding fee in case of payback & swap\n                // 1 - fee. If fee is 1% then withdrawing withFepex_ will be 1e6 - 1e4\n                temp_ = (temp_ * (SIX_DECIMALS - ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n                // final shares to burn for user\n                shares_ += temp_;\n                // final new debt shares\n                totalBorrowShares_ -= temp_;\n            } else {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidDebtReserves);\n            }\n\n            if (estimate_) revert FluidDexLiquidityOutput(shares_);\n\n            if (shares_ < minSharesAmt_) revert FluidDexError(ErrorTypes.DexT1__PaybackSharedBurnedLess);\n\n            if (token0Amt_ > 0) {\n                // comparing debt here rather than reserves to simply code, impact won't be much overall\n                _verifyToken0Reserves(\n                    (d_.token0Debt - p_.token0AmtAdjusted),\n                    (d_.token1Debt - p_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // payback\n                temp_ = token0Amt_;\n                _depositOrPaybackInLiquidity(TOKEN_0, 0, temp_);\n            }\n\n            if (token1Amt_ > 0) {\n                // comparing debt here rather than reserves to simply code, impact won't be much overall\n                _verifyToken1Reserves(\n                    (d_.token0Debt - p_.token0AmtAdjusted),\n                    (d_.token1Debt - p_.token1AmtAdjusted),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n                // payback\n                temp_ = token1Amt_;\n                _depositOrPaybackInLiquidity(TOKEN_1, 0, temp_);\n            }\n\n            // extract user borrow amount\n            // userBorrow_ => temp_\n            temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) borrow limit\n            // newBorrowLimit_ => temp2_\n            temp2_ = DexCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, temp_);\n\n            temp_ -= shares_;\n\n            _updatingUserBorrowDataOnStorage(userBorrowData_, temp_, temp2_);\n            // updating total debt shares in storage\n            _totalBorrowShares = totalBorrowShares_;\n\n            emit LogPaybackDebtLiquidity(token0Amt_, token1Amt_, shares_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartDebtNotEnabled);\n        }\n    }\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) public payable _onlyDelegateCall returns (uint paybackAmt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userBorrowData_ = _userBorrowData[msg.sender];\n\n        if (userBorrowData_ & 1 == 0 && !estimate_) revert FluidDexError(ErrorTypes.DexT1__UserDebtInNotOn);\n\n        if ((maxToken0_ > 0 && maxToken1_ > 0) || (maxToken0_ == 0 && maxToken1_ == 0)) {\n            // only 1 token should be > 0\n            revert FluidDexError(ErrorTypes.DexT1__InvalidWithdrawAmts);\n        }\n\n        // is smart debt pool enabled\n        if (((dexVariables2_ >> 1) & 1) == 1) {\n            PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n            uint totalBorrowShares_ = _totalBorrowShares;\n\n            _verifyRedeem(shares_, totalBorrowShares_);\n\n            uint token0Amt_;\n            uint token1Amt_;\n\n            // smart debt in enabled\n            DebtReserves memory d_ = _getDebtReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.borrowToken0ExchangePrice,\n                pex_.borrowToken1ExchangePrice\n            );\n\n            if ((d_.token0Debt == 0) || (d_.token1Debt == 0)) {\n                revert FluidDexError(ErrorTypes.DexT1__InvalidDebtReserves);\n            }\n\n            // Removing debt liquidity in equal proportion\n            DebtReserves memory d2_ = _getUpdateDebtReserves(shares_, totalBorrowShares_, d_, false);\n\n            if (maxToken0_ > 0) {\n                // entire payback is in token0_\n                token0Amt_ = _getSwapAndPaybackOneTokenPerfectShares(\n                    d2_.token0ImaginaryReserves,\n                    d2_.token1ImaginaryReserves,\n                    d_.token0Debt,\n                    d_.token1Debt,\n                    d2_.token0RealReserves,\n                    d2_.token1RealReserves\n                );\n                _verifyToken0Reserves(\n                    (d_.token0Debt - token0Amt_),\n                    d_.token1Debt,\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n\n                // converting from raw/adjusted to normal token amounts\n                token0Amt_ = (((token0Amt_ + 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) + 1;\n\n                // adding fee on paying back in 1 token\n                token0Amt_ = (token0Amt_ * (SIX_DECIMALS + ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n\n                paybackAmt_ = token0Amt_;\n                if (estimate_) revert FluidDexSingleTokenOutput(paybackAmt_);\n                if (paybackAmt_ > maxToken0_) revert FluidDexError(ErrorTypes.DexT1__PaybackAmtTooHigh);\n                _depositOrPaybackInLiquidity(TOKEN_0, 0, paybackAmt_);\n            } else {\n                // entire payback is in token1_\n                token1Amt_ = _getSwapAndPaybackOneTokenPerfectShares(\n                    d2_.token1ImaginaryReserves,\n                    d2_.token0ImaginaryReserves,\n                    d_.token1Debt,\n                    d_.token0Debt,\n                    d2_.token1RealReserves,\n                    d2_.token0RealReserves\n                );\n                _verifyToken1Reserves(\n                    d_.token0Debt,\n                    (d_.token1Debt - token1Amt_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_USER_OPERATIONS\n                );\n\n                // converting from raw/adjusted to normal token amounts\n                token1Amt_ = (((token1Amt_ + 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) + 1;\n\n                // adding fee on paying back in 1 token\n                token1Amt_ = (token1Amt_ * (SIX_DECIMALS + ((dexVariables2_ >> 2) & X17))) / SIX_DECIMALS;\n\n                paybackAmt_ = token1Amt_;\n                if (estimate_) revert FluidDexSingleTokenOutput(paybackAmt_);\n                if (paybackAmt_ > maxToken1_) revert FluidDexError(ErrorTypes.DexT1__PaybackAmtTooHigh);\n                _depositOrPaybackInLiquidity(TOKEN_1, 0, paybackAmt_);\n            }\n\n            // extract user borrow amount\n            uint256 userBorrow_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n            userBorrow_ = (userBorrow_ >> DEFAULT_EXPONENT_SIZE) << (userBorrow_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) borrow limit\n            // temp_ => newBorrowLimit_\n            uint256 temp_ = DexCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, userBorrow_);\n            userBorrow_ -= shares_;\n\n            _updatingUserBorrowDataOnStorage(userBorrowData_, userBorrow_, temp_);\n\n            _totalBorrowShares = totalBorrowShares_ - shares_;\n\n            // to avoid stack-too-deep error\n            temp_ = shares_;\n            emit LogPaybackDebtInOneToken(temp_, token0Amt_, token1Amt_);\n\n            _arbitrage(dexVariables_, dexVariables2_, pex_);\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartDebtNotEnabled);\n        }\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/core/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { CoreHelpers } from \"../helpers/coreHelpers.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { IFluidDexT1 } from \"../../../interfaces/iDexT1.sol\";\n\ninterface IDexCallback {\n    function dexCallback(address token_, uint256 amount_) external;\n}\n\n/// @title FluidDexT1\n/// @notice Implements core logics for Fluid Dex protocol.\n/// Note Token transfers happen directly from user to Liquidity contract and vice-versa.\ncontract FluidDexT1 is CoreHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) CoreHelpers(constantViews_) {\n        // any implementations should not be zero\n        if (\n            constantViews_.implementations.shift == address(0) ||\n            constantViews_.implementations.admin == address(0) ||\n            constantViews_.implementations.colOperations == address(0) ||\n            constantViews_.implementations.debtOperations == address(0) ||\n            constantViews_.implementations.perfectOperationsAndSwapOut == address(0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__InvalidImplementation);\n        }\n    }\n\n    struct SwapInExtras {\n        address to;\n        uint amountOutMin;\n        bool isCallback;\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param extras_ Additional parameters for the swap:\n    ///   - to: Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    ///   - amountOutMin: The minimum amount of output tokens the user expects to receive\n    ///   - isCallback: If true, indicates that the input tokens should be transferred via a callback\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function _swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        SwapInExtras memory extras_\n    ) internal returns (uint256 amountOut_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        if ((dexVariables2_ >> 255) == 1) revert FluidDexError(ErrorTypes.DexT1__SwapAndArbitragePaused);\n\n        _check(dexVariables_, dexVariables2_);\n\n        if (extras_.to == address(0)) extras_.to = msg.sender;\n\n        SwapInMemory memory s_;\n\n        if (swap0to1_) {\n            (s_.tokenIn, s_.tokenOut) = (TOKEN_0, TOKEN_1);\n            unchecked {\n                s_.amtInAdjusted = (amountIn_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION;\n            }\n        } else {\n            (s_.tokenIn, s_.tokenOut) = (TOKEN_1, TOKEN_0);\n            unchecked {\n                s_.amtInAdjusted = (amountIn_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION;\n            }\n        }\n\n        _verifySwapAndNonPerfectActions(s_.amtInAdjusted, amountIn_);\n\n        PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n        if (msg.value > 0) {\n            if (msg.value != amountIn_) revert FluidDexError(ErrorTypes.DexT1__EthAndAmountInMisMatch);\n            if (s_.tokenIn != NATIVE_TOKEN) revert FluidDexError(ErrorTypes.DexT1__EthSentForNonNativeSwap);\n        }\n\n        // is smart collateral pool enabled\n        uint temp_ = dexVariables2_ & 1;\n        // is smart debt pool enabled\n        uint temp2_ = (dexVariables2_ >> 1) & 1;\n\n        uint temp3_;\n        uint temp4_;\n\n        // extracting fee\n        temp3_ = ((dexVariables2_ >> 2) & X17);\n        unchecked {\n            // converting revenue cut in 4 decimals, 1% = 10000\n            // If fee is 1% and revenue cut is 10% then 0.1 * 10000 = 1000\n            // hence revenueCut = 1e6 - 1000 = 999000\n            // s_.revenueCut => 1 - revenue cut\n            s_.revenueCut = SIX_DECIMALS - ((((dexVariables2_ >> 19) & X7) * temp3_) / 100);\n            // 1 - fee. If fee is 1% then withoutFee will be 1e6 - 1e4\n            // s_.fee => 1 - withdraw fee\n            s_.fee = SIX_DECIMALS - temp3_;\n        }\n\n        CollateralReservesSwap memory cs_;\n        DebtReservesSwap memory ds_;\n        if (temp_ == 1) {\n            // smart collateral is enabled\n            {\n                CollateralReserves memory c_ = _getCollateralReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.supplyToken0ExchangePrice,\n                    pex_.supplyToken1ExchangePrice\n                );\n                if (swap0to1_) {\n                    (\n                        cs_.tokenInRealReserves,\n                        cs_.tokenOutRealReserves,\n                        cs_.tokenInImaginaryReserves,\n                        cs_.tokenOutImaginaryReserves\n                    ) = (\n                        c_.token0RealReserves,\n                        c_.token1RealReserves,\n                        c_.token0ImaginaryReserves,\n                        c_.token1ImaginaryReserves\n                    );\n                } else {\n                    (\n                        cs_.tokenInRealReserves,\n                        cs_.tokenOutRealReserves,\n                        cs_.tokenInImaginaryReserves,\n                        cs_.tokenOutImaginaryReserves\n                    ) = (\n                        c_.token1RealReserves,\n                        c_.token0RealReserves,\n                        c_.token1ImaginaryReserves,\n                        c_.token0ImaginaryReserves\n                    );\n                }\n            }\n        }\n\n        if (temp2_ == 1) {\n            // smart debt is enabled\n            {\n                DebtReserves memory d_ = _getDebtReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.borrowToken0ExchangePrice,\n                    pex_.borrowToken1ExchangePrice\n                );\n                if (swap0to1_) {\n                    (\n                        ds_.tokenInDebt,\n                        ds_.tokenOutDebt,\n                        ds_.tokenInRealReserves,\n                        ds_.tokenOutRealReserves,\n                        ds_.tokenInImaginaryReserves,\n                        ds_.tokenOutImaginaryReserves\n                    ) = (\n                        d_.token0Debt,\n                        d_.token1Debt,\n                        d_.token0RealReserves,\n                        d_.token1RealReserves,\n                        d_.token0ImaginaryReserves,\n                        d_.token1ImaginaryReserves\n                    );\n                } else {\n                    (\n                        ds_.tokenInDebt,\n                        ds_.tokenOutDebt,\n                        ds_.tokenInRealReserves,\n                        ds_.tokenOutRealReserves,\n                        ds_.tokenInImaginaryReserves,\n                        ds_.tokenOutImaginaryReserves\n                    ) = (\n                        d_.token1Debt,\n                        d_.token0Debt,\n                        d_.token1RealReserves,\n                        d_.token0RealReserves,\n                        d_.token1ImaginaryReserves,\n                        d_.token0ImaginaryReserves\n                    );\n                }\n            }\n        }\n\n        // limiting amtInAdjusted to be not more than 50% of both (collateral & debt) imaginary tokenIn reserves combined\n        // basically, if this throws that means user is trying to swap 0.5x tokenIn if current tokenIn imaginary reserves is x\n        // let's take x as token0 here, that means, initially the pool pricing might be:\n        // token1Reserve / x and new pool pricing will become token1Reserve / 1.5x (token1Reserve will decrease after swap but for simplicity ignoring that)\n        // So pool price is decreased by ~33.33% (oracle will throw error in this case as it only allows 5% price difference but better to limit it before hand)\n        unchecked {\n            if (s_.amtInAdjusted > ((cs_.tokenInImaginaryReserves + ds_.tokenInImaginaryReserves) / 2))\n                revert FluidDexError(ErrorTypes.DexT1__SwapInLimitingAmounts);\n        }\n\n        if (temp_ == 1 && temp2_ == 1) {\n            // unless both pools are enabled s_.swapRoutingAmt will be 0\n            s_.swapRoutingAmt = _swapRoutingIn(\n                s_.amtInAdjusted,\n                cs_.tokenOutImaginaryReserves,\n                cs_.tokenInImaginaryReserves,\n                ds_.tokenOutImaginaryReserves,\n                ds_.tokenInImaginaryReserves\n            );\n        }\n\n        // In below if else statement temps are:\n        // temp_ => deposit amt\n        // temp2_ => withdraw amt\n        // temp3_ => payback amt\n        // temp4_ => borrow amt\n        if (int(s_.amtInAdjusted) > s_.swapRoutingAmt && s_.swapRoutingAmt > 0) {\n            // swap will route from the both pools\n            // temp_ = amountInCol_\n            temp_ = uint(s_.swapRoutingAmt);\n            unchecked {\n                // temp3_ = amountInDebt_\n                temp3_ = s_.amtInAdjusted - temp_;\n            }\n\n            (temp2_, temp4_) = (0, 0);\n\n            // debt pool price will be the same as collateral pool after the swap\n            s_.withdrawTo = extras_.to;\n            s_.borrowTo = extras_.to;\n        } else if ((temp_ == 1 && temp2_ == 0) || (s_.swapRoutingAmt >= int(s_.amtInAdjusted))) {\n            // entire swap will route through collateral pool\n            (temp_, temp2_, temp3_, temp4_) = (s_.amtInAdjusted, 0, 0, 0);\n            // price can slightly differ from debt pool but difference will be very small. Probably <0.01% for active DEX pools.\n            s_.withdrawTo = extras_.to;\n        } else if ((temp_ == 0 && temp2_ == 1) || (s_.swapRoutingAmt <= 0)) {\n            // entire swap will route through debt pool\n            (temp_, temp2_, temp3_, temp4_) = (0, 0, s_.amtInAdjusted, 0);\n            // price can slightly differ from collateral pool but difference will be very small. Probably <0.01% for active DEX pools.\n            s_.borrowTo = extras_.to;\n        } else {\n            // swap should never reach this point but if it does then reverting\n            revert FluidDexError(ErrorTypes.DexT1__NoSwapRoute);\n        }\n\n        if (temp_ > 0) {\n            // temp2_ = amountOutCol_\n            temp2_ = _getAmountOut(\n                ((temp_ * s_.fee) / SIX_DECIMALS),\n                cs_.tokenInImaginaryReserves,\n                cs_.tokenOutImaginaryReserves\n            );\n            swap0to1_\n                ? _verifyToken1Reserves(\n                    (cs_.tokenInRealReserves + temp_),\n                    (cs_.tokenOutRealReserves - temp2_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                )\n                : _verifyToken0Reserves(\n                    (cs_.tokenOutRealReserves - temp2_),\n                    (cs_.tokenInRealReserves + temp_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                );\n        }\n        if (temp3_ > 0) {\n            // temp4_ = amountOutDebt_\n            temp4_ = _getAmountOut(\n                ((temp3_ * s_.fee) / SIX_DECIMALS),\n                ds_.tokenInImaginaryReserves,\n                ds_.tokenOutImaginaryReserves\n            );\n            swap0to1_\n                ? _verifyToken1Reserves(\n                    (ds_.tokenInRealReserves + temp3_),\n                    (ds_.tokenOutRealReserves - temp4_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                )\n                : _verifyToken0Reserves(\n                    (ds_.tokenOutRealReserves - temp4_),\n                    (ds_.tokenInRealReserves + temp3_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                );\n        }\n\n        // (temp_ + temp3_) == amountIn_ == msg.value (for native token), if there is revenue cut then this statement is not true\n        temp_ = (temp_ * s_.revenueCut) / SIX_DECIMALS;\n        temp3_ = (temp3_ * s_.revenueCut) / SIX_DECIMALS;\n\n        // from whatever pool higher amount of swap is routing we are taking that as final price, does not matter much because both pools final price should be same\n        if (temp_ > temp3_) {\n            // new pool price from col pool\n            s_.price = swap0to1_\n                ? ((cs_.tokenOutImaginaryReserves - temp2_) * 1e27) / (cs_.tokenInImaginaryReserves + temp_)\n                : ((cs_.tokenInImaginaryReserves + temp_) * 1e27) / (cs_.tokenOutImaginaryReserves - temp2_);\n        } else {\n            // new pool price from debt pool\n            s_.price = swap0to1_\n                ? ((ds_.tokenOutImaginaryReserves - temp4_) * 1e27) / (ds_.tokenInImaginaryReserves + temp3_)\n                : ((ds_.tokenInImaginaryReserves + temp3_) * 1e27) / (ds_.tokenOutImaginaryReserves - temp4_);\n        }\n\n        // converting into normal token amounts\n        if (swap0to1_) {\n            temp_ = ((temp_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\n            temp3_ = ((temp3_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\n            // only adding uncheck in out amount\n            unchecked {\n                temp2_ = ((temp2_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n                temp4_ = ((temp4_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n            }\n        } else {\n            temp_ = ((temp_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n            temp3_ = ((temp3_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n            // only adding uncheck in out amount\n            unchecked {\n                temp2_ = ((temp2_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\n                temp4_ = ((temp4_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION);\n            }\n        }\n\n        unchecked {\n            amountOut_ = temp2_ + temp4_;\n        }\n\n        // if address dead then reverting with amountOut\n        if (extras_.to == ADDRESS_DEAD) revert FluidDexSwapResult(amountOut_);\n\n        if (amountOut_ < extras_.amountOutMin) revert FluidDexError(ErrorTypes.DexT1__NotEnoughAmountOut);\n\n        // allocating to avoid stack-too-deep error\n        // not setting in the callbackData as last 2nd to avoid SKIP_TRANSFERS clashing\n        s_.data = abi.encode(amountIn_, extras_.isCallback, msg.sender); // true/false is to decide if dex should do callback or directly transfer from user\n        // deposit & payback token in at liquidity\n        LIQUIDITY.operate{ value: msg.value }(s_.tokenIn, int(temp_), -int(temp3_), address(0), address(0), s_.data);\n        // withdraw & borrow token out at liquidity\n        LIQUIDITY.operate(s_.tokenOut, -int(temp2_), int(temp4_), s_.withdrawTo, s_.borrowTo, new bytes(0));\n\n        // if hook exists then calling hook\n        temp_ = (dexVariables2_ >> 142) & X30;\n        if (temp_ > 0) {\n            s_.swap0to1 = swap0to1_;\n            _hookVerify(temp_, 1, s_.swap0to1, s_.price);\n        }\n\n        swap0to1_\n            ? _utilizationVerify(((dexVariables2_ >> 238) & X10), EXCHANGE_PRICE_TOKEN_1_SLOT)\n            : _utilizationVerify(((dexVariables2_ >> 228) & X10), EXCHANGE_PRICE_TOKEN_0_SLOT);\n\n        dexVariables = _updateOracle(s_.price, pex_.centerPrice, dexVariables_);\n\n        emit Swap(swap0to1_, amountIn_, amountOut_, extras_.to);\n    }\n\n    /// @dev Swap tokens with perfect amount in\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of tokens to swap in\n    /// @param amountOutMin_ The minimum amount of tokens to receive after swap\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) public payable returns (uint256 amountOut_) {\n        return _swapIn(swap0to1_, amountIn_, SwapInExtras(to_, amountOutMin_, false));\n    }\n\n    /// @dev Swap tokens with perfect amount in and callback functionality\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of tokens to swap in\n    /// @param amountOutMin_ The minimum amount of tokens to receive after swap\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapInWithCallback(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) public payable returns (uint256 amountOut_) {\n        return _swapIn(swap0to1_, amountIn_, SwapInExtras(to_, amountOutMin_, true));\n    }\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) public payable returns (uint256 amountIn_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev Swap tokens with perfect amount out and callback functionality\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOutWithCallback(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) public payable returns (uint256 amountIn_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) public payable returns (uint token0Amt_, uint token1Amt_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256, uint256));\n    }\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of withdrawn tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) public returns (uint token0Amt_, uint token1Amt_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256, uint256));\n    }\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of borrowed tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) public returns (uint token0Amt_, uint token1Amt_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256, uint256));\n    }\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) public payable returns (uint token0Amt_, uint token1Amt_) {\n        return abi.decode(_spell(PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION, msg.data), (uint256, uint256));\n    }\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) public payable returns (uint shares_) {\n        return abi.decode(_spell(COL_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of withdrawn tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) public returns (uint shares_) {\n        return abi.decode(_spell(COL_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of borrowed tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) public returns (uint shares_) {\n        return abi.decode(_spell(DEBT_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) public payable returns (uint shares_) {\n        return abi.decode(_spell(DEBT_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of withdrawn tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) public returns (uint withdrawAmt_) {\n        return abi.decode(_spell(COL_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) public payable returns (uint paybackAmt_) {\n        return abi.decode(_spell(DEBT_OPERATIONS_IMPLEMENTATION, msg.data), (uint256));\n    }\n\n    /// @dev liquidity callback for cheaper token transfers in case of deposit or payback.\n    /// only callable by Liquidity during an operation.\n    function liquidityCallback(address token_, uint amount_, bytes calldata data_) external {\n        if (msg.sender != address(LIQUIDITY)) revert FluidDexError(ErrorTypes.DexT1__MsgSenderNotLiquidity);\n        if (dexVariables & 1 == 0) revert FluidDexError(ErrorTypes.DexT1__ReentrancyBitShouldBeOn);\n        if (data_.length != 96) revert FluidDexError(ErrorTypes.DexT1__IncorrectDataLength);\n\n        (uint amountToSend_, bool isCallback_, address from_) = abi.decode(data_, (uint, bool, address));\n\n        if (amountToSend_ < amount_) revert FluidDexError(ErrorTypes.DexT1__AmountToSendLessThanAmount);\n\n        if (isCallback_) {\n            IDexCallback(from_).dexCallback(token_, amountToSend_);\n        } else {\n            SafeTransfer.safeTransferFrom(token_, from_, address(LIQUIDITY), amountToSend_);\n        }\n    }\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(\n        uint[] memory secondsAgos_\n    ) external view returns (Oracle[] memory twaps_, uint currentPrice_) {\n        OraclePriceMemory memory o_;\n\n        uint dexVariables_ = dexVariables;\n        twaps_ = new Oracle[](secondsAgos_.length);\n\n        uint totalTime_;\n        uint time_;\n\n        uint i;\n        uint secondsAgo_ = secondsAgos_[0];\n\n        currentPrice_ = (dexVariables_ >> 41) & X40;\n        currentPrice_ = (currentPrice_ >> DEFAULT_EXPONENT_SIZE) << (currentPrice_ & DEFAULT_EXPONENT_MASK);\n        uint price_ = currentPrice_;\n        o_.lowestPrice1by0 = currentPrice_;\n        o_.highestPrice1by0 = currentPrice_;\n\n        uint twap1by0_;\n        uint twap0by1_;\n\n        uint j;\n\n        o_.oracleSlot = (dexVariables_ >> 176) & X3;\n        o_.oracleMap = (dexVariables_ >> 179) & X16;\n        // if o_.oracleSlot == 7 then it'll enter the if statement in the below while loop\n        o_.oracle = o_.oracleSlot < 7 ? _oracle[o_.oracleMap] : 0;\n\n        uint slotData_;\n        uint percentDiff_;\n\n        if (((dexVariables_ >> 121) & X33) < block.timestamp) {\n            // last swap didn't occured in this block.\n            // hence last price is current price of pool & also the last price\n            time_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n        } else {\n            // last swap occured in this block, that means current price is active for 0 secs. Hence TWAP for it will be 0.\n            ++j;\n        }\n\n        while (true) {\n            if (j == 2) {\n                if (++o_.oracleSlot == 8) {\n                    o_.oracleSlot = 0;\n                    if (o_.oracleMap == 0) {\n                        o_.oracleMap = TOTAL_ORACLE_MAPPING;\n                    }\n                    o_.oracle = _oracle[--o_.oracleMap];\n                }\n\n                slotData_ = (o_.oracle >> (o_.oracleSlot * 32)) & X32;\n                if (slotData_ > 0) {\n                    time_ = slotData_ & X9;\n                    if (time_ == 0) {\n                        // time is in precision & sign bits\n                        time_ = slotData_ >> 9;\n                        // if o_.oracleSlot is 7 then precision & bits and stored in 1 less map\n                        if (o_.oracleSlot == 7) {\n                            o_.oracleSlot = 0;\n                            if (o_.oracleMap == 0) {\n                                o_.oracleMap = TOTAL_ORACLE_MAPPING;\n                            }\n                            o_.oracle = _oracle[--o_.oracleMap];\n                            slotData_ = o_.oracle & X32;\n                        } else {\n                            ++o_.oracleSlot;\n                            slotData_ = (o_.oracle >> (o_.oracleSlot * 32)) & X32;\n                        }\n                    }\n                    percentDiff_ = slotData_ >> 10;\n                    percentDiff_ = (ORACLE_LIMIT * percentDiff_) / X22;\n                    if (((slotData_ >> 9) & 1 == 1)) {\n                        // if positive then old price was lower than current hence subtracting\n                        price_ = price_ - (price_ * percentDiff_) / ORACLE_PRECISION;\n                    } else {\n                        // if negative then old price was higher than current hence adding\n                        price_ = price_ + (price_ * percentDiff_) / ORACLE_PRECISION;\n                    }\n                } else {\n                    // oracle data does not exist. Probably due to pool recently got initialized and not have much swaps.\n                    revert FluidDexError(ErrorTypes.DexT1__InsufficientOracleData);\n                }\n            } else if (j == 1) {\n                // last & last to last price\n                price_ = (dexVariables_ >> 1) & X40;\n                price_ = (price_ >> DEFAULT_EXPONENT_SIZE) << (price_ & DEFAULT_EXPONENT_MASK);\n                time_ = (dexVariables_ >> 154) & X22;\n                ++j;\n            } else if (j == 0) {\n                ++j;\n            }\n\n            totalTime_ += time_;\n            if (o_.lowestPrice1by0 > price_) o_.lowestPrice1by0 = price_;\n            if (o_.highestPrice1by0 < price_) o_.highestPrice1by0 = price_;\n            if (totalTime_ < secondsAgo_) {\n                twap1by0_ += price_ * time_;\n                twap0by1_ += (1e54 / price_) * time_;\n            } else {\n                time_ = time_ + secondsAgo_ - totalTime_;\n                twap1by0_ += price_ * time_;\n                twap0by1_ += (1e54 / price_) * time_;\n                // also auto checks that secondsAgos_ should not be == 0\n                twap1by0_ = twap1by0_ / secondsAgo_;\n                twap0by1_ = twap0by1_ / secondsAgo_;\n\n                twaps_[i] = Oracle(\n                    twap1by0_,\n                    o_.lowestPrice1by0,\n                    o_.highestPrice1by0,\n                    twap0by1_,\n                    (1e54 / o_.highestPrice1by0),\n                    (1e54 / o_.lowestPrice1by0)\n                );\n\n                // TWAP for next secondsAgo will start with price_\n                o_.lowestPrice1by0 = price_;\n                o_.highestPrice1by0 = price_;\n\n                while (++i < secondsAgos_.length) {\n                    // secondsAgo_ = [60, 15, 0]\n                    time_ = totalTime_ - secondsAgo_;\n                    // updating total time as new seconds ago started\n                    totalTime_ = time_;\n                    // also auto checks that secondsAgos_[i + 1] > secondsAgos_[i]\n                    secondsAgo_ = secondsAgos_[i] - secondsAgos_[i - 1];\n                    if (totalTime_ < secondsAgo_) {\n                        twap1by0_ = price_ * time_;\n                        twap0by1_ = (1e54 / price_) * time_;\n                        // if time_ comes out as 0 here then lowestPrice & highestPrice should not be price_, it should be next price_ that we will calculate\n                        if (time_ == 0) {\n                            o_.lowestPrice1by0 = type(uint).max;\n                            o_.highestPrice1by0 = 0;\n                        }\n                        break;\n                    } else {\n                        time_ = time_ + secondsAgo_ - totalTime_;\n                        // twap1by0_ = price_ here\n                        twap1by0_ = price_ * time_;\n                        // twap0by1_ = (1e54 / price_) * time_;\n                        twap0by1_ = (1e54 / price_) * time_;\n                        twap1by0_ = twap1by0_ / secondsAgo_;\n                        twap0by1_ = twap0by1_ / secondsAgo_;\n                        twaps_[i] = Oracle(\n                            twap1by0_,\n                            o_.lowestPrice1by0,\n                            o_.highestPrice1by0,\n                            twap0by1_,\n                            (1e54 / o_.highestPrice1by0),\n                            (1e54 / o_.lowestPrice1by0)\n                        );\n                    }\n                }\n                if (i == secondsAgos_.length) return (twaps_, currentPrice_); // oracle fetch over\n            }\n        }\n    }\n\n    function getPricesAndExchangePrices() public {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables, dexVariables2);\n\n        revert FluidDexPricesAndExchangeRates(pex_);\n    }\n\n    /// @dev Internal fallback function to handle calls to non-existent functions\n    /// @notice This function is called when a transaction is sent to the contract without matching any other function\n    /// @notice It checks if the caller is authorized, enables re-entrancy protection, delegates the call to the admin implementation, and then disables re-entrancy protection\n    /// @notice Only authorized callers (global or dex auth) can trigger this function\n    /// @notice This function uses assembly to perform a delegatecall to the admin implementation to update configs related to DEX\n    function _fallback() private {\n        if (!(DEX_FACTORY.isGlobalAuth(msg.sender) || DEX_FACTORY.isDexAuth(address(this), msg.sender))) {\n            revert FluidDexError(ErrorTypes.DexT1__NotAnAuth);\n        }\n\n        uint dexVariables_ = dexVariables;\n        if (dexVariables_ & 1 == 1) revert FluidDexError(ErrorTypes.DexT1__AlreadyEntered);\n        // enabling re-entrancy\n        dexVariables = dexVariables_ | 1;\n\n        // Delegate the current call to `ADMIN_IMPLEMENTATION`.\n        _spell(ADMIN_IMPLEMENTATION, msg.data);\n\n        // disabling re-entrancy\n        // directly fetching from storage so updates from Admin module will get auto covered\n        dexVariables = dexVariables & ~uint(1);\n    }\n\n    fallback() external payable {\n        _fallback();\n    }\n\n    receive() external payable {\n        if (msg.sig != 0x00000000) {\n            _fallback();\n        }\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_) {\n        constantsView_.dexId = DEX_ID;\n        constantsView_.liquidity = address(LIQUIDITY);\n        constantsView_.factory = address(DEX_FACTORY);\n        constantsView_.token0 = TOKEN_0;\n        constantsView_.token1 = TOKEN_1;\n        constantsView_.implementations.shift = SHIFT_IMPLEMENTATION;\n        constantsView_.implementations.admin = ADMIN_IMPLEMENTATION;\n        constantsView_.implementations.colOperations = COL_OPERATIONS_IMPLEMENTATION;\n        constantsView_.implementations.debtOperations = DEBT_OPERATIONS_IMPLEMENTATION;\n        constantsView_.implementations.perfectOperationsAndSwapOut = PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION;\n        constantsView_.deployerContract = DEPLOYER_CONTRACT;\n        constantsView_.supplyToken0Slot = SUPPLY_TOKEN_0_SLOT;\n        constantsView_.borrowToken0Slot = BORROW_TOKEN_0_SLOT;\n        constantsView_.supplyToken1Slot = SUPPLY_TOKEN_1_SLOT;\n        constantsView_.borrowToken1Slot = BORROW_TOKEN_1_SLOT;\n        constantsView_.exchangePriceToken0Slot = EXCHANGE_PRICE_TOKEN_0_SLOT;\n        constantsView_.exchangePriceToken1Slot = EXCHANGE_PRICE_TOKEN_1_SLOT;\n        constantsView_.oracleMapping = TOTAL_ORACLE_MAPPING;\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_) {\n        constantsView2_.token0NumeratorPrecision = TOKEN_0_NUMERATOR_PRECISION;\n        constantsView2_.token0DenominatorPrecision = TOKEN_0_DENOMINATOR_PRECISION;\n        constantsView2_.token1NumeratorPrecision = TOKEN_1_NUMERATOR_PRECISION;\n        constantsView2_.token1DenominatorPrecision = TOKEN_1_DENOMINATOR_PRECISION;\n    }\n\n    /// @notice Calculates the real and imaginary reserves for collateral tokens\n    /// @dev This function retrieves the supply of both tokens from the liquidity layer,\n    ///      adjusts them based on exchange prices, and calculates imaginary reserves\n    ///      based on the geometric mean and price range\n    /// @param geometricMean_ The geometric mean of the token prices\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0SupplyExchangePrice_ The exchange price for token0 from liquidity layer\n    /// @param token1SupplyExchangePrice_ The exchange price for token1 from liquidity layer\n    /// @return c_ A struct containing the calculated real and imaginary reserves for both tokens:\n    ///         - token0RealReserves: The real reserves of token0\n    ///         - token1RealReserves: The real reserves of token1\n    ///         - token0ImaginaryReserves: The imaginary reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary reserves of token1\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) public view returns (CollateralReserves memory c_) {\n        return\n            _getCollateralReserves(\n                geometricMean_,\n                upperRange_,\n                lowerRange_,\n                token0SupplyExchangePrice_,\n                token1SupplyExchangePrice_\n            );\n    }\n\n    /// @notice Calculates the debt reserves for both tokens\n    /// @param geometricMean_ The geometric mean of the upper and lower price ranges\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0BorrowExchangePrice_ The exchange price of token0 from liquidity layer\n    /// @param token1BorrowExchangePrice_ The exchange price of token1 from liquidity layer\n    /// @return d_ The calculated debt reserves for both tokens, containing:\n    ///         - token0Debt: The debt amount of token0\n    ///         - token1Debt: The debt amount of token1\n    ///         - token0RealReserves: The real reserves of token0 derived from token1 debt\n    ///         - token1RealReserves: The real reserves of token1 derived from token0 debt\n    ///         - token0ImaginaryReserves: The imaginary debt reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary debt reserves of token1\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) public view returns (DebtReserves memory d_) {\n        return\n            _getDebtReserves(\n                geometricMean_,\n                upperRange_,\n                lowerRange_,\n                token0BorrowExchangePrice_,\n                token1BorrowExchangePrice_\n            );\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/core/perfectOperationsAndSwapOut.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { UserHelpers } from \"../helpers/userHelpers.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\n\n/// @title FluidDexT1\n/// @notice Implements core logics for Fluid Dex protocol.\n/// Note Token transfers happen directly from user to Liquidity contract and vice-versa.\ncontract FluidDexT1PerfectOperationsAndSwapOut is UserHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) UserHelpers(constantViews_) {\n        // all implementations should be zero other than shift\n        if (\n            constantViews_.implementations.shift == address(0) ||\n            constantViews_.implementations.admin != address(0) ||\n            constantViews_.implementations.colOperations != address(0) ||\n            constantViews_.implementations.debtOperations != address(0) ||\n            constantViews_.implementations.perfectOperationsAndSwapOut != address(0)\n        ) {\n            revert FluidDexError(ErrorTypes.DexT1__InvalidImplementation);\n        }\n    }\n\n    modifier _onlyDelegateCall() {\n        // also indirectly checked by `_check` because pool can never be initialized as long as the initialize method\n        // is delegate call only, but just to be sure on Admin logic we add the modifier everywhere nonetheless.\n        if (address(this) == THIS_CONTRACT) {\n            revert FluidDexError(ErrorTypes.DexT1__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    struct SwapOutExtras {\n        address to;\n        uint amountInMax;\n        bool isCallback;\n    }\n\n    /// @dev Swap tokens with perfect amount out. If NATIVE_TOKEN is sent then msg.value should be passed as amountInMax, amountInMax - amountIn of ETH are sent back to msg.sender\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param extras_ Additional parameters for the swap:\n    ///   - to_: Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    ///   - amountInMax: The maximum amount of input tokens the user is willing to swap\n    ///   - isCallback: If true, indicates that the output tokens should be transferred via a callback\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function _swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        SwapOutExtras memory extras_\n    ) internal _onlyDelegateCall returns (uint256 amountIn_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        if ((dexVariables2_ >> 255) == 1) revert FluidDexError(ErrorTypes.DexT1__SwapAndArbitragePaused);\n\n        _check(dexVariables_, dexVariables2_);\n\n        if (extras_.to == address(0)) extras_.to = msg.sender;\n\n        SwapOutMemory memory s_;\n\n        if (swap0to1_) {\n            (s_.tokenIn, s_.tokenOut) = (TOKEN_0, TOKEN_1);\n            unchecked {\n                s_.amtOutAdjusted = (amountOut_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION;\n            }\n        } else {\n            (s_.tokenIn, s_.tokenOut) = (TOKEN_1, TOKEN_0);\n            unchecked {\n                s_.amtOutAdjusted = (amountOut_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION;\n            }\n        }\n\n        _verifySwapAndNonPerfectActions(s_.amtOutAdjusted, amountOut_);\n\n        PricesAndExchangePrice memory pex_ = _getPricesAndExchangePrices(dexVariables_, dexVariables2_);\n\n        if (msg.value > 0) {\n            if (msg.value != extras_.amountInMax) revert FluidDexError(ErrorTypes.DexT1__EthAndAmountInMisMatch);\n            if (s_.tokenIn != NATIVE_TOKEN) revert FluidDexError(ErrorTypes.DexT1__EthSentForNonNativeSwap);\n        }\n\n        // is smart collateral pool enabled\n        uint temp_ = dexVariables2_ & 1;\n        // is smart debt pool enabled\n        uint temp2_ = (dexVariables2_ >> 1) & 1;\n        uint temp3_;\n        uint temp4_;\n\n        // extracting fee\n        temp3_ = ((dexVariables2_ >> 2) & X17);\n        unchecked {\n            // converting revenue cut in 4 decimals, 1% = 10000\n            // If fee is 1% and revenue cut is 10% then 0.1 * 10000 = 1000\n            // hence revenueCut = 1e6 - 1000 = 999000\n            // s_.revenueCut => 1 - revenue cut\n            s_.revenueCut = SIX_DECIMALS - ((((dexVariables2_ >> 19) & X7) * temp3_) / 100);\n            // 1 - fee. If fee is 1% then withoutFee will be 1e6 - 1e4\n            // s_.fee => 1 - withdraw fee\n            s_.fee = SIX_DECIMALS - temp3_;\n        }\n\n        CollateralReservesSwap memory cs_;\n        DebtReservesSwap memory ds_;\n        if (temp_ == 1) {\n            // smart collateral is enabled\n            {\n                CollateralReserves memory c_ = _getCollateralReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.supplyToken0ExchangePrice,\n                    pex_.supplyToken1ExchangePrice\n                );\n                if (swap0to1_) {\n                    (\n                        cs_.tokenInRealReserves,\n                        cs_.tokenOutRealReserves,\n                        cs_.tokenInImaginaryReserves,\n                        cs_.tokenOutImaginaryReserves\n                    ) = (\n                        c_.token0RealReserves,\n                        c_.token1RealReserves,\n                        c_.token0ImaginaryReserves,\n                        c_.token1ImaginaryReserves\n                    );\n                } else {\n                    (\n                        cs_.tokenInRealReserves,\n                        cs_.tokenOutRealReserves,\n                        cs_.tokenInImaginaryReserves,\n                        cs_.tokenOutImaginaryReserves\n                    ) = (\n                        c_.token1RealReserves,\n                        c_.token0RealReserves,\n                        c_.token1ImaginaryReserves,\n                        c_.token0ImaginaryReserves\n                    );\n                }\n            }\n        }\n\n        if (temp2_ == 1) {\n            // smart debt is enabled\n            {\n                DebtReserves memory d_ = _getDebtReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.borrowToken0ExchangePrice,\n                    pex_.borrowToken1ExchangePrice\n                );\n                if (swap0to1_) {\n                    (\n                        ds_.tokenInDebt,\n                        ds_.tokenOutDebt,\n                        ds_.tokenInRealReserves,\n                        ds_.tokenOutRealReserves,\n                        ds_.tokenInImaginaryReserves,\n                        ds_.tokenOutImaginaryReserves\n                    ) = (\n                        d_.token0Debt,\n                        d_.token1Debt,\n                        d_.token0RealReserves,\n                        d_.token1RealReserves,\n                        d_.token0ImaginaryReserves,\n                        d_.token1ImaginaryReserves\n                    );\n                } else {\n                    (\n                        ds_.tokenInDebt,\n                        ds_.tokenOutDebt,\n                        ds_.tokenInRealReserves,\n                        ds_.tokenOutRealReserves,\n                        ds_.tokenInImaginaryReserves,\n                        ds_.tokenOutImaginaryReserves\n                    ) = (\n                        d_.token1Debt,\n                        d_.token0Debt,\n                        d_.token1RealReserves,\n                        d_.token0RealReserves,\n                        d_.token1ImaginaryReserves,\n                        d_.token0ImaginaryReserves\n                    );\n                }\n            }\n        }\n\n        // limiting amtOutAdjusted to be not more than 50% of both (collateral & debt) imaginary tokenOut reserves combined\n        // basically, if this throws that means user is trying to swap 0.5x tokenOut if current tokenOut imaginary reserves is x\n        // let's take x as token0 here, that means, initially the pool pricing might be:\n        // token1Reserve / x and new pool pricing will become token1Reserve / 0.5x (token1Reserve will decrease after swap but for simplicity ignoring that)\n        // So pool price is increased by ~50% (oracle will throw error in this case as it only allows 5% price difference but better to limit it before hand)\n        unchecked {\n            if (s_.amtOutAdjusted > ((cs_.tokenOutImaginaryReserves + ds_.tokenOutImaginaryReserves) / 2))\n                revert FluidDexError(ErrorTypes.DexT1__SwapOutLimitingAmounts);\n        }\n\n        if (temp_ == 1 && temp2_ == 1) {\n            // if both pools are not enabled then s_.swapRoutingAmt will be 0\n            s_.swapRoutingAmt = _swapRoutingOut(\n                s_.amtOutAdjusted,\n                cs_.tokenInImaginaryReserves,\n                cs_.tokenOutImaginaryReserves,\n                ds_.tokenInImaginaryReserves,\n                ds_.tokenOutImaginaryReserves\n            );\n        }\n\n        // In below if else statement temps are:\n        // temp_ => withdraw amt\n        // temp2_ => deposit amt\n        // temp3_ => borrow amt\n        // temp4_ => payback amt\n        if (int(s_.amtOutAdjusted) > s_.swapRoutingAmt && s_.swapRoutingAmt > 0) {\n            // swap will route from both pools\n            // temp_ = amountOutCol_\n            temp_ = uint(s_.swapRoutingAmt);\n            unchecked {\n                // temp3_ = amountOutDebt_\n                temp3_ = s_.amtOutAdjusted - temp_;\n            }\n\n            (temp2_, temp4_) = (0, 0);\n\n            // debt pool price will be the same as collateral pool after the swap\n            s_.withdrawTo = extras_.to;\n            s_.borrowTo = extras_.to;\n        } else if ((temp_ == 1 && temp2_ == 0) || (s_.swapRoutingAmt >= int(s_.amtOutAdjusted))) {\n            // entire swap will route through collateral pool\n            (temp_, temp2_, temp3_, temp4_) = (s_.amtOutAdjusted, 0, 0, 0);\n            // price can slightly differ from debt pool but difference will be very small. Probably <0.01% for active DEX pools.\n            s_.withdrawTo = extras_.to;\n        } else if ((temp_ == 0 && temp2_ == 1) || (s_.swapRoutingAmt <= 0)) {\n            // entire swap will route through debt pool\n            (temp_, temp2_, temp3_, temp4_) = (0, 0, s_.amtOutAdjusted, 0);\n            // price can slightly differ from collateral pool but difference will be very small. Probably <0.01% for active DEX pools.\n            s_.borrowTo = extras_.to;\n        } else {\n            // swap should never reach this point but if it does then reverting\n            revert FluidDexError(ErrorTypes.DexT1__NoSwapRoute);\n        }\n\n        if (temp_ > 0) {\n            // temp2_ = amountInCol_\n            temp2_ = _getAmountIn(temp_, cs_.tokenInImaginaryReserves, cs_.tokenOutImaginaryReserves);\n            temp2_ = (temp2_ * SIX_DECIMALS) / s_.fee;\n            swap0to1_\n                ? _verifyToken1Reserves(\n                    (cs_.tokenInRealReserves + temp2_),\n                    (cs_.tokenOutRealReserves - temp_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                )\n                : _verifyToken0Reserves(\n                    (cs_.tokenOutRealReserves - temp_),\n                    (cs_.tokenInRealReserves + temp2_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                );\n        }\n        if (temp3_ > 0) {\n            // temp4_ = amountInDebt_\n            temp4_ = _getAmountIn(temp3_, ds_.tokenInImaginaryReserves, ds_.tokenOutImaginaryReserves);\n            temp4_ = (temp4_ * SIX_DECIMALS) / s_.fee;\n            swap0to1_\n                ? _verifyToken1Reserves(\n                    (ds_.tokenInRealReserves + temp4_),\n                    (ds_.tokenOutRealReserves - temp3_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                )\n                : _verifyToken0Reserves(\n                    (ds_.tokenOutRealReserves - temp3_),\n                    (ds_.tokenInRealReserves + temp4_),\n                    pex_.centerPrice,\n                    MINIMUM_LIQUIDITY_SWAP\n                );\n        }\n\n        amountIn_ = temp2_ + temp4_;\n\n        // cutting revenue off of amount in.\n        temp2_ = (temp2_ * s_.revenueCut) / SIX_DECIMALS;\n        temp4_ = (temp4_ * s_.revenueCut) / SIX_DECIMALS;\n\n        // from whatever pool higher amount of swap is routing we are taking that as final price, does not matter much because both pools final price should be same\n        if (temp_ > temp3_) {\n            // new pool price from col pool\n            s_.price = swap0to1_\n                ? ((cs_.tokenOutImaginaryReserves - temp_) * 1e27) / (cs_.tokenInImaginaryReserves + temp2_)\n                : ((cs_.tokenInImaginaryReserves + temp2_) * 1e27) / (cs_.tokenOutImaginaryReserves - temp_);\n        } else {\n            // new pool price from debt pool\n            s_.price = swap0to1_\n                ? ((ds_.tokenOutImaginaryReserves - temp3_) * 1e27) / (ds_.tokenInImaginaryReserves + temp4_)\n                : ((ds_.tokenInImaginaryReserves + temp4_) * 1e27) / (ds_.tokenOutImaginaryReserves - temp3_);\n        }\n\n        // Converting into normal token amounts\n        if (swap0to1_) {\n            // only adding uncheck in out amount\n            unchecked {\n                temp_ = (temp_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION;\n                temp3_ = (temp3_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION;\n            }\n            temp2_ = (temp2_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION;\n            temp4_ = (temp4_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION;\n            amountIn_ = (amountIn_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION;\n        } else {\n            // only adding uncheck in out amount\n            unchecked {\n                temp_ = (temp_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION;\n                temp3_ = (temp3_ * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION;\n            }\n            temp2_ = (temp2_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION;\n            temp4_ = (temp4_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION;\n            amountIn_ = (amountIn_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION;\n        }\n\n        // If address dead then reverting with amountIn\n        if (extras_.to == ADDRESS_DEAD) revert FluidDexSwapResult(amountIn_);\n\n        if (amountIn_ > extras_.amountInMax) revert FluidDexError(ErrorTypes.DexT1__ExceedsAmountInMax);\n\n        // allocating to avoid stack-too-deep error\n        // not setting in the callbackData as last 2nd to avoid SKIP_TRANSFERS clashing\n        s_.data = abi.encode(amountIn_, extras_.isCallback, msg.sender); // true/false is to decide if dex should do callback or directly transfer from user\n        // if native token then pass msg.value as amountIn_ else 0\n        s_.msgValue = (s_.tokenIn == NATIVE_TOKEN) ? amountIn_ : 0;\n        // Deposit & payback token in at liquidity\n        LIQUIDITY.operate{ value: s_.msgValue }(s_.tokenIn, int(temp2_), -int(temp4_), address(0), address(0), s_.data);\n        // Withdraw & borrow token out at liquidity\n        LIQUIDITY.operate(s_.tokenOut, -int(temp_), int(temp3_), s_.withdrawTo, s_.borrowTo, new bytes(0));\n\n        // If hook exists then calling hook\n        temp_ = (dexVariables2_ >> 142) & X30;\n        if (temp_ > 0) {\n            s_.swap0to1 = swap0to1_;\n            _hookVerify(temp_, 1, s_.swap0to1, s_.price);\n        }\n\n        swap0to1_\n            ? _utilizationVerify(((dexVariables2_ >> 238) & X10), EXCHANGE_PRICE_TOKEN_1_SLOT)\n            : _utilizationVerify(((dexVariables2_ >> 228) & X10), EXCHANGE_PRICE_TOKEN_0_SLOT);\n\n        dexVariables = _updateOracle(s_.price, pex_.centerPrice, dexVariables_);\n\n        if (s_.tokenIn == NATIVE_TOKEN && amountIn_ < extras_.amountInMax) {\n            unchecked {\n                SafeTransfer.safeTransferNative(msg.sender, extras_.amountInMax - amountIn_);\n            }\n        }\n\n        // to avoid stack too deep error\n        temp_ = amountOut_;\n        emit Swap(swap0to1_, amountIn_, temp_, extras_.to);\n    }\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint amountInMax_,\n        address to_\n    ) public payable _onlyDelegateCall returns (uint amountIn_) {\n        return _swapOut(swap0to1_, amountOut_, SwapOutExtras(to_, amountInMax_, false));\n    }\n\n    /// @dev Swap tokens with perfect amount out and callback functionality\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOutWithCallback(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) public payable returns (uint256 amountIn_) {\n        return _swapOut(swap0to1_, amountOut_, SwapOutExtras(to_, amountInMax_, true));\n    }\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) public payable _onlyDelegateCall returns (uint token0Amt_, uint token1Amt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userSupplyData_ = _userSupplyData[msg.sender];\n\n        // user collateral configs are not set yet\n        if (userSupplyData_ & 1 == 0 && !estimate_) revert FluidDexError(ErrorTypes.DexT1__UserSupplyInNotOn);\n\n        // is smart collateral pool enabled\n        if ((dexVariables2_ & 1) == 1) {\n            ExchangePrices memory ex_ = _getExchangePrices();\n\n            // smart col in enabled\n            uint totalSupplyShares_ = _totalSupplyShares;\n\n            _verifyMint(shares_, totalSupplyShares_);\n\n            // Adding col liquidity in equal proportion\n            // Adding + 1, to keep protocol on the winning side\n            token0Amt_ =\n                (_getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, ex_.supplyToken0ExchangePrice, true) * shares_) /\n                totalSupplyShares_;\n            token1Amt_ =\n                (_getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, ex_.supplyToken1ExchangePrice, false) * shares_) /\n                totalSupplyShares_;\n\n            // converting back into normal token amounts\n            // Adding + 1, to keep protocol on the winning side\n            token0Amt_ = (((token0Amt_ + 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) + 1;\n            token1Amt_ = (((token1Amt_ + 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) + 1;\n\n            if (estimate_) revert FluidDexPerfectLiquidityOutput(token0Amt_, token1Amt_);\n\n            if (token0Amt_ > maxToken0Deposit_ || token1Amt_ > maxToken1Deposit_) {\n                revert FluidDexError(ErrorTypes.DexT1__AboveDepositMax);\n            }\n\n            _depositOrPaybackInLiquidity(TOKEN_0, token0Amt_, 0);\n\n            _depositOrPaybackInLiquidity(TOKEN_1, token1Amt_, 0);\n\n            uint userSupply_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            // extracting exisiting shares and then adding new shares in it\n            userSupply_ = ((userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK));\n\n            // calculate current, updated (expanded etc.) withdrawal limit\n            uint256 newWithdrawalLimit_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\n\n            userSupply_ += shares_;\n\n            // bigNumber the shares are not same as before\n            _updatingUserSupplyDataOnStorage(userSupplyData_, userSupply_, newWithdrawalLimit_);\n\n            // updating total shares on storage\n            _totalSupplyShares = totalSupplyShares_ + shares_;\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartColNotEnabled);\n        }\n\n        // uninitializing re-entrancy\n        dexVariables = dexVariables_;\n\n        emit LogDepositPerfectColLiquidity(shares_, token0Amt_, token1Amt_);\n    }\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) public _onlyDelegateCall returns (uint token0Amt_, uint token1Amt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userSupplyData_ = _userSupplyData[msg.sender];\n\n        if (userSupplyData_ & 1 == 0 && to_ != ADDRESS_DEAD) {\n            revert FluidDexError(ErrorTypes.DexT1__UserSupplyInNotOn);\n        }\n\n        to_ = (to_ == address(0)) ? msg.sender : to_;\n\n        // is smart collateral pool enabled\n        if ((dexVariables2_ & 1) == 1) {\n            ExchangePrices memory ex_ = _getExchangePrices();\n\n            uint totalSupplyShares_ = _totalSupplyShares;\n\n            _verifyRedeem(shares_, totalSupplyShares_);\n\n            // smart col in enabled\n            // Withdrawing col liquidity in equal proportion\n            token0Amt_ =\n                (_getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, ex_.supplyToken0ExchangePrice, true) * shares_) /\n                totalSupplyShares_;\n            token1Amt_ =\n                (_getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, ex_.supplyToken1ExchangePrice, false) * shares_) /\n                totalSupplyShares_;\n\n            // converting back into normal token amounts\n            token0Amt_ = (((token0Amt_ - 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) - 1;\n            token1Amt_ = (((token1Amt_ - 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) - 1;\n\n            if (to_ == ADDRESS_DEAD) revert FluidDexPerfectLiquidityOutput(token0Amt_, token1Amt_);\n\n            if (token0Amt_ < minToken0Withdraw_ || token1Amt_ < minToken1Withdraw_) {\n                revert FluidDexError(ErrorTypes.DexT1__BelowWithdrawMin);\n            }\n\n            uint256 userSupply_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            userSupply_ = (userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) withdrawal limit\n            uint256 newWithdrawalLimit_ = DexCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\n            userSupply_ -= shares_;\n\n            // withdraws below limit\n            if (userSupply_ < newWithdrawalLimit_) revert FluidDexError(ErrorTypes.DexT1__WithdrawLimitReached);\n\n            _updatingUserSupplyDataOnStorage(userSupplyData_, userSupply_, newWithdrawalLimit_);\n\n            _totalSupplyShares = totalSupplyShares_ - shares_;\n\n            // withdraw\n            // if token0Amt_ == 0 then Liqudity Layer will revert\n            LIQUIDITY.operate(TOKEN_0, -int(token0Amt_), 0, to_, address(0), new bytes(0));\n\n            // withdraw\n            // if token1Amt_ == 0 then Liqudity Layer will revert\n            LIQUIDITY.operate(TOKEN_1, -int(token1Amt_), 0, to_, address(0), new bytes(0));\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartColNotEnabled);\n        }\n\n        // uninitializing re-entrancy\n        dexVariables = dexVariables_;\n\n        emit LogWithdrawPerfectColLiquidity(shares_, token0Amt_, token1Amt_);\n    }\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) public _onlyDelegateCall returns (uint token0Amt_, uint token1Amt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userBorrowData_ = _userBorrowData[msg.sender];\n\n        // user debt configs are not set yet\n        if (userBorrowData_ & 1 == 0 && to_ != ADDRESS_DEAD) revert FluidDexError(ErrorTypes.DexT1__UserDebtInNotOn);\n\n        to_ = (to_ == address(0)) ? msg.sender : to_;\n\n        // is smart debt pool enabled\n        if (((dexVariables2_ >> 1) & 1) == 1) {\n            ExchangePrices memory ex_ = _getExchangePrices();\n\n            uint totalBorrowShares_ = _totalBorrowShares;\n\n            _verifyMint(shares_, totalBorrowShares_);\n\n            // Adding debt liquidity in equal proportion\n            token0Amt_ =\n                (_getLiquidityDebt(BORROW_TOKEN_0_SLOT, ex_.borrowToken0ExchangePrice, true) * shares_) /\n                totalBorrowShares_;\n            token1Amt_ =\n                (_getLiquidityDebt(BORROW_TOKEN_1_SLOT, ex_.borrowToken1ExchangePrice, false) * shares_) /\n                totalBorrowShares_;\n            // converting back into normal token amounts\n            token0Amt_ = (((token0Amt_ - 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) - 1;\n            token1Amt_ = (((token1Amt_ - 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) - 1;\n\n            if (to_ == ADDRESS_DEAD) revert FluidDexPerfectLiquidityOutput(token0Amt_, token1Amt_);\n\n            if (token0Amt_ < minToken0Borrow_ || token1Amt_ < minToken1Borrow_) {\n                revert FluidDexError(ErrorTypes.DexT1__BelowBorrowMin);\n            }\n\n            // extract user borrow amount\n            uint256 userBorrow_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n            userBorrow_ = (userBorrow_ >> DEFAULT_EXPONENT_SIZE) << (userBorrow_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) borrow limit\n            uint256 newBorrowLimit_ = DexCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, userBorrow_);\n\n            userBorrow_ += shares_;\n\n            // user above debt limit\n            if (userBorrow_ > newBorrowLimit_) revert FluidDexError(ErrorTypes.DexT1__DebtLimitReached);\n\n            // borrow\n            // if token0Amt_ == 0 then Liqudity Layer will revert\n            LIQUIDITY.operate(TOKEN_0, 0, int(token0Amt_), address(0), to_, new bytes(0));\n\n            // borrow\n            // if token1Amt_ == 1 then Liqudity Layer will revert\n            LIQUIDITY.operate(TOKEN_1, 0, int(token1Amt_), address(0), to_, new bytes(0));\n\n            _updatingUserBorrowDataOnStorage(userBorrowData_, userBorrow_, newBorrowLimit_);\n\n            _totalBorrowShares = totalBorrowShares_ + shares_;\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartDebtNotEnabled);\n        }\n\n        // uninitializing re-entrancy\n        dexVariables = dexVariables_;\n\n        emit LogBorrowPerfectDebtLiquidity(shares_, token0Amt_, token1Amt_);\n    }\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) public payable _onlyDelegateCall returns (uint token0Amt_, uint token1Amt_) {\n        uint dexVariables_ = dexVariables;\n        uint dexVariables2_ = dexVariables2;\n\n        _check(dexVariables_, dexVariables2_);\n\n        uint userBorrowData_ = _userBorrowData[msg.sender];\n\n        if (userBorrowData_ & 1 == 0 && !estimate_) revert FluidDexError(ErrorTypes.DexT1__UserDebtInNotOn);\n\n        // is smart debt pool enabled\n        if (((dexVariables2_ >> 1) & 1) == 1) {\n            uint totalBorrowShares_ = _totalBorrowShares;\n\n            ExchangePrices memory ex_ = _getExchangePrices();\n\n            _verifyRedeem(shares_, totalBorrowShares_);\n\n            // Removing debt liquidity in equal proportion\n            token0Amt_ =\n                (_getLiquidityDebt(BORROW_TOKEN_0_SLOT, ex_.borrowToken0ExchangePrice, true) * shares_) /\n                totalBorrowShares_;\n            token1Amt_ =\n                (_getLiquidityDebt(BORROW_TOKEN_1_SLOT, ex_.borrowToken1ExchangePrice, false) * shares_) /\n                totalBorrowShares_;\n            // converting back into normal token amounts\n            token0Amt_ = (((token0Amt_ + 1) * TOKEN_0_DENOMINATOR_PRECISION) / TOKEN_0_NUMERATOR_PRECISION) + 1;\n            token1Amt_ = (((token1Amt_ + 1) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION) + 1;\n\n            if (estimate_) revert FluidDexPerfectLiquidityOutput(token0Amt_, token1Amt_);\n\n            if (token0Amt_ > maxToken0Payback_ || token1Amt_ > maxToken1Payback_) {\n                revert FluidDexError(ErrorTypes.DexT1__AbovePaybackMax);\n            }\n\n            _depositOrPaybackInLiquidity(TOKEN_0, 0, token0Amt_);\n\n            _depositOrPaybackInLiquidity(TOKEN_1, 0, token1Amt_);\n\n            // extract user borrow amount\n            uint256 userBorrow_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n            userBorrow_ = (userBorrow_ >> DEFAULT_EXPONENT_SIZE) << (userBorrow_ & DEFAULT_EXPONENT_MASK);\n\n            // calculate current, updated (expanded etc.) borrow limit\n            uint256 newBorrowLimit_ = DexCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, userBorrow_);\n\n            userBorrow_ -= shares_;\n\n            _updatingUserBorrowDataOnStorage(userBorrowData_, userBorrow_, newBorrowLimit_);\n\n            _totalBorrowShares = totalBorrowShares_ - shares_;\n        } else {\n            revert FluidDexError(ErrorTypes.DexT1__SmartDebtNotEnabled);\n        }\n\n        // uninitializing re-entrancy\n        dexVariables = dexVariables_;\n\n        emit LogPaybackPerfectDebtLiquidity(shares_, token0Amt_, token1Amt_);\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/core/shift.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport { Variables } from \"../../common/variables.sol\";\nimport { ConstantVariables } from \"../../common/constantVariables.sol\";\nimport { Events } from \"../events.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { ICenterPrice } from \"../interfaces.sol\";\nimport { AddressCalcs } from \"../../../../../libraries/addressCalcs.sol\";\nimport { Error } from \"../../../error.sol\";\n\ncontract FluidDexT1Shift is Variables, ConstantVariables, Events, Error {\n    address private immutable DEPLOYER_CONTRACT;\n\n    address private immutable THIS_CONTRACT;\n\n    constructor(address deployerContract_) {\n        DEPLOYER_CONTRACT = deployerContract_;\n        THIS_CONTRACT = address(this);\n    }\n\n    modifier _onlyDelegateCall() {\n        // also indirectly checked by `_check` because pool can never be initialized as long as the initialize method\n        // is delegate call only, but just to be sure on Admin logic we add the modifier everywhere nonetheless.\n        if (address(this) == THIS_CONTRACT) {\n            revert FluidDexError(ErrorTypes.DexT1__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev This function calculates the new value of a parameter after a shifting process.\n    /// @param current_ The current value is the final value where the shift ends\n    /// @param old_ The old value from where shifting started.\n    /// @param timePassed_ The time passed since shifting started.\n    /// @param shiftDuration_ The total duration of the shift when old_ reaches current_\n    /// @return The new value of the parameter after the shift.\n    function _calcShiftingDone(\n        uint current_,\n        uint old_,\n        uint timePassed_,\n        uint shiftDuration_\n    ) internal pure returns (uint) {\n        if (current_ > old_) {\n            uint diff_ = current_ - old_;\n            current_ = old_ + ((diff_ * timePassed_) / shiftDuration_);\n        } else {\n            uint diff_ = old_ - current_;\n            current_ = old_ - ((diff_ * timePassed_) / shiftDuration_);\n        }\n        return current_;\n    }\n\n    /// @dev Calculates the new upper and lower range values during an active range shift\n    /// @param upperRange_ The target upper range value\n    /// @param lowerRange_ The target lower range value\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\n    /// @return The updated upper range, lower range, and dexVariables2\n    /// @notice This function handles the gradual shifting of range values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcRangeShifting(\n        uint upperRange_,\n        uint lowerRange_,\n        uint dexVariables2_\n    ) public _onlyDelegateCall returns (uint, uint, uint) {\n        uint rangeShift_ = _rangeShift;\n        uint oldUpperRange_ = rangeShift_ & X20;\n        uint oldLowerRange_ = (rangeShift_ >> 20) & X20;\n        uint shiftDuration_ = (rangeShift_ >> 40) & X20;\n        uint startTimeStamp_ = ((rangeShift_ >> 60) & X33);\n        if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n            // shifting fully done\n            delete _rangeShift;\n            // making active shift as 0 because shift is over\n            // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates from this function and _calcThresholdShifting.\n            dexVariables2_ = dexVariables2 & ~uint(1 << 26);\n            dexVariables2 = dexVariables2_;\n            return (upperRange_, lowerRange_, dexVariables2_);\n        }\n        uint timePassed_ = block.timestamp - startTimeStamp_;\n        return (\n            _calcShiftingDone(upperRange_, oldUpperRange_, timePassed_, shiftDuration_),\n            _calcShiftingDone(lowerRange_, oldLowerRange_, timePassed_, shiftDuration_),\n            dexVariables2_\n        );\n    }\n\n    /// @dev Calculates the new upper and lower threshold values during an active threshold shift\n    /// @param upperThreshold_ The target upper threshold value\n    /// @param lowerThreshold_ The target lower threshold value\n    /// @param thresholdTime_ The time passed since shifting started\n    /// @return The updated upper threshold, lower threshold, and threshold time\n    /// @notice This function handles the gradual shifting of threshold values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcThresholdShifting(\n        uint upperThreshold_,\n        uint lowerThreshold_,\n        uint thresholdTime_\n    ) public _onlyDelegateCall returns (uint, uint, uint) {\n        uint thresholdShift_ = _thresholdShift;\n        uint oldUpperThreshold_ = thresholdShift_ & X20;\n        uint oldLowerThreshold_ = (thresholdShift_ >> 20) & X20;\n        uint shiftDuration_ = (thresholdShift_ >> 40) & X20;\n        uint startTimeStamp_ = ((thresholdShift_ >> 60) & X33);\n        uint oldThresholdTime_ = (thresholdShift_ >> 93) & X24;\n        if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n            // shifting fully done\n            delete _thresholdShift;\n            // making active shift as 0 because shift is over\n            // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates from this function and _calcRangeShifting.\n            dexVariables2 = dexVariables2 & ~uint(1 << 67);\n            return (upperThreshold_, lowerThreshold_, thresholdTime_);\n        }\n        uint timePassed_ = block.timestamp - startTimeStamp_;\n        return (\n            _calcShiftingDone(upperThreshold_, oldUpperThreshold_, timePassed_, shiftDuration_),\n            _calcShiftingDone(lowerThreshold_, oldLowerThreshold_, timePassed_, shiftDuration_),\n            _calcShiftingDone(thresholdTime_, oldThresholdTime_, timePassed_, shiftDuration_)\n        );\n    }\n\n    /// @dev Calculates the new center price during an active price shift\n    /// @param dexVariables_ The current state of dex variables\n    /// @param dexVariables2_ Additional dex variables\n    /// @return newCenterPrice_ The updated center price\n    /// @notice This function gradually shifts the center price towards a new target price over time\n    /// @notice It uses an external price source (via ICenterPrice) to determine the target price\n    /// @notice The shift continues until the current price reaches the target, or the shift duration ends\n    /// @notice Once the shift is complete, it updates the state and clears the shift data\n    /// @notice The shift rate is dynamic and depends on:\n    /// @notice - Time remaining in the shift duration\n    /// @notice - The new center price (fetched externally, which may change)\n    /// @notice - The current (old) center price\n    /// @notice This results in a fuzzy shifting mechanism where the rate can change as these parameters evolve\n    /// @notice The externally fetched new center price is expected to not differ significantly from the last externally fetched center price\n    function _calcCenterPrice(\n        uint dexVariables_,\n        uint dexVariables2_\n    ) public _onlyDelegateCall returns (uint newCenterPrice_) {\n        uint oldCenterPrice_ = (dexVariables_ >> 81) & X40;\n        oldCenterPrice_ = (oldCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (oldCenterPrice_ & DEFAULT_EXPONENT_MASK);\n        uint centerPriceShift_ = _centerPriceShift;\n        uint startTimeStamp_ = centerPriceShift_ & X33;\n        uint percent_ = (centerPriceShift_ >> 33) & X20;\n        uint time_ = (centerPriceShift_ >> 53) & X20;\n\n        uint fromTimeStamp_ = (dexVariables_ >> 121) & X33;\n        fromTimeStamp_ = fromTimeStamp_ > startTimeStamp_ ? fromTimeStamp_ : startTimeStamp_;\n\n        newCenterPrice_ = ICenterPrice(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, ((dexVariables2_ >> 112) & X30)))\n            .centerPrice();\n        uint priceShift_ = (oldCenterPrice_ * percent_ * (block.timestamp - fromTimeStamp_)) / (time_ * SIX_DECIMALS);\n\n        if (newCenterPrice_ > oldCenterPrice_) {\n            // shift on positive side\n            oldCenterPrice_ += priceShift_;\n            if (newCenterPrice_ > oldCenterPrice_) {\n                newCenterPrice_ = oldCenterPrice_;\n            } else {\n                // shifting fully done\n                delete _centerPriceShift;\n                // making active shift as 0 because shift is over\n                // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\n                dexVariables2 = dexVariables2 & ~uint(1 << 248);\n            }\n        } else {\n            unchecked {\n                oldCenterPrice_ = oldCenterPrice_ > priceShift_ ? oldCenterPrice_ - priceShift_ : 0;\n                // In case of oldCenterPrice_ ending up 0, which could happen when a lot of time has passed (pool has no swaps for many days or weeks)\n                // then below we get into the else logic which will fully conclude shifting and return newCenterPrice_\n                // as it was fetched from the external center price source.\n                // not ideal that this would ever happen unless the pool is not in use and all/most users have left leaving not enough liquidity to trade on\n            }\n            if (newCenterPrice_ < oldCenterPrice_) {\n                newCenterPrice_ = oldCenterPrice_;\n            } else {\n                // shifting fully done\n                delete _centerPriceShift;\n                // making active shift as 0 because shift is over\n                // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\n                dexVariables2 = dexVariables2 & ~uint(1 << 248);\n            }\n        }\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Events {\n    /// @notice Emitted on token swaps\n    /// @param swap0to1 Indicates whether the swap is from token0 to token1 or vice-versa.\n    /// @param amountIn The amount of tokens to be sent to the vault to swap.\n    /// @param amountOut The amount of tokens user got from the swap.\n    /// @param to Recepient of swapped tokens.\n    event Swap(bool swap0to1, uint256 amountIn, uint256 amountOut, address to);\n\n    /// @notice Emitted when liquidity is added with shares specified.\n    /// @param shares Expected exact shares to be received.\n    /// @param token0Amt Amount of token0 deposited.\n    /// @param token0Amt Amount of token1 deposited.\n    event LogDepositPerfectColLiquidity(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when liquidity is withdrawn with shares specified.\n    /// @param shares shares burned\n    /// @param token0Amt Amount of token0 withdrawn.\n    /// @param token1Amt Amount of token1 withdrawn.\n    event LogWithdrawPerfectColLiquidity(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when liquidity is borrowed with shares specified.\n    /// @param shares shares minted\n    /// @param token0Amt Amount of token0 borrowed.\n    /// @param token1Amt Amount of token1 borrowed.\n    event LogBorrowPerfectDebtLiquidity(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when liquidity is paid back with shares specified.\n    /// @param shares shares burned\n    /// @param token0Amt Amount of token0 paid back.\n    /// @param token1Amt Amount of token1 paid back.\n    event LogPaybackPerfectDebtLiquidity(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when liquidity is deposited with specified token0 & token1 amount\n    /// @param amount0 Amount of token0 deposited.\n    /// @param amount1 Amount of token1 deposited.\n    /// @param shares Amount of shares minted.\n    event LogDepositColLiquidity(uint amount0, uint amount1, uint shares);\n\n    /// @notice Emitted when liquidity is withdrawn with specified token0 & token1 amount\n    /// @param amount0 Amount of token0 withdrawn.\n    /// @param amount1 Amount of token1 withdrawn.\n    /// @param shares Amount of shares burned.\n    event LogWithdrawColLiquidity(uint amount0, uint amount1, uint shares);\n\n    /// @notice Emitted when liquidity is borrowed with specified token0 & token1 amount\n    /// @param amount0 Amount of token0 borrowed.\n    /// @param amount1 Amount of token1 borrowed.\n    /// @param shares Amount of shares minted.\n    event LogBorrowDebtLiquidity(uint amount0, uint amount1, uint shares);\n\n    /// @notice Emitted when liquidity is paid back with specified token0 & token1 amount\n    /// @param amount0 Amount of token0 paid back.\n    /// @param amount1 Amount of token1 paid back.\n    /// @param shares Amount of shares burned.\n    event LogPaybackDebtLiquidity(uint amount0, uint amount1, uint shares);\n\n    /// @notice Emitted when liquidity is withdrawn with shares specified into one token only.\n    /// @param shares shares burned\n    /// @param token0Amt Amount of token0 withdrawn.\n    /// @param token1Amt Amount of token1 withdrawn.\n    event LogWithdrawColInOneToken(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when liquidity is paid back with shares specified from one token only.\n    /// @param shares shares burned\n    /// @param token0Amt Amount of token0 paid back.\n    /// @param token1Amt Amount of token1 paid back.\n    event LogPaybackDebtInOneToken(uint shares, uint token0Amt, uint token1Amt);\n\n    /// @notice Emitted when internal arbitrage between 2 pools happen\n    /// @param routing if positive then routing is amtIn of token0 in deposit & borrow else token0 withdraw & payback\n    /// @param amtOut if routing is positive then token1 withdraw & payback amount else token1 deposit & borrow\n    event LogArbitrage(int routing, uint amtOut);\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/helpers/coreHelpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport { Variables } from \"../../common/variables.sol\";\nimport { ImmutableVariables } from \"../immutableVariables.sol\";\nimport { Events } from \"../events.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { IHook, ICenterPrice } from \"../interfaces.sol\";\nimport { LiquiditySlotsLink } from \"../../../../../libraries/liquiditySlotsLink.sol\";\nimport { LiquidityCalcs } from \"../../../../../libraries/liquidityCalcs.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { AddressCalcs } from \"../../../../../libraries/addressCalcs.sol\";\n\ninterface IShifting {\n    /// @dev Calculates the new upper and lower range values during an active range shift\n    /// @param upperRange_ The target upper range value\n    /// @param lowerRange_ The target lower range value\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\n    /// @return The updated upper range, lower range, and dexVariables2\n    function _calcRangeShifting(\n        uint upperRange_,\n        uint lowerRange_,\n        uint dexVariables2_\n    ) external returns (uint, uint, uint);\n\n    /// @dev Calculates the new threshold values during an active threshold shift\n    /// @param upperThreshold_ The target upper threshold value\n    /// @param lowerThreshold_ The target lower threshold value\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\n    /// @return The updated upper threshold, lower threshold, and dexVariables2\n    function _calcThresholdShifting(\n        uint upperThreshold_,\n        uint lowerThreshold_,\n        uint dexVariables2_\n    ) external returns (uint, uint, uint);\n\n    /// @dev Calculates the new center price during an active center price shift\n    /// @param centerPrice_ The current center price\n    /// @return The updated center price\n    function _calcCenterPrice(uint centerPrice_) external returns (uint);\n}\n\nabstract contract CoreHelpers is Variables, ImmutableVariables, Events {\n    using BigMathMinified for uint256;\n\n    /// @dev            do any arbitrary call\n    /// @param target_  Address to which the call needs to be delegated\n    /// @param data_    Data to execute at the delegated address\n    function _spell(address target_, bytes memory data_) internal returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            if iszero(succeeded) {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n\n    /// @dev Given an input amount of asset and pair reserves, returns the maximum output amount of the other asset\n    /// @param amountIn_ The amount of input asset.\n    /// @param iReserveIn_ Imaginary token reserve with input amount.\n    /// @param iReserveOut_ Imaginary token reserve of output amount.\n    function _getAmountOut(\n        uint256 amountIn_,\n        uint iReserveIn_,\n        uint iReserveOut_\n    ) internal pure returns (uint256 amountOut_) {\n        unchecked {\n            // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\n            uint256 numerator_ = amountIn_ * iReserveOut_;\n            uint256 denominator_ = iReserveIn_ + amountIn_;\n\n            // Using the swap formula: (AmountIn * iReserveY) / (iReserveX + AmountIn)\n            amountOut_ = numerator_ / denominator_;\n        }\n    }\n\n    /// @dev Given an output amount of asset and pair reserves, returns the input amount of the other asset\n    /// @param amountOut_ Desired output amount of the asset.\n    /// @param iReserveIn_ Imaginary token reserve of input amount.\n    /// @param iReserveOut_ Imaginary token reserve of output amount.\n    function _getAmountIn(\n        uint256 amountOut_,\n        uint iReserveIn_,\n        uint iReserveOut_\n    ) internal pure returns (uint256 amountIn_) {\n        // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\n        uint256 numerator_ = amountOut_ * iReserveIn_;\n        uint256 denominator_ = iReserveOut_ - amountOut_;\n\n        // Using the swap formula: (AmountOut * iReserveX) / (iReserveY - AmountOut)\n        amountIn_ = numerator_ / denominator_;\n    }\n\n    /// @param t total amount in\n    /// @param x imaginary reserves of token out of collateral\n    /// @param y imaginary reserves of token in of collateral\n    /// @param x2 imaginary reserves of token out of debt\n    /// @param y2 imaginary reserves of token in of debt\n    /// @return a_ how much swap should go through collateral pool. Remaining will go from debt\n    /// note if a < 0 then entire trade route through debt pool and debt pool arbitrage with col pool\n    /// note if a > t then entire trade route through col pool and col pool arbitrage with debt pool\n    /// note if a > 0 & a < t then swap will route through both pools\n    function _swapRoutingIn(uint t, uint x, uint y, uint x2, uint y2) internal pure returns (int a_) {\n        // Main equations:\n        // 1. out = x * a / (y + a)\n        // 2. out2 = x2 * (t - a) / (y2 + (t - a))\n        // final price should be same\n        // 3. (y + a) / (x - out) = (y2 + (t - a)) / (x2 - out2)\n        // derivation: https://chatgpt.com/share/dce6f381-ee5f-4d5f-b6ea-5996e84d5b57\n\n        // adding 1e18 precision\n        uint xyRoot_ = FixedPointMathLib.sqrt(x * y * 1e18);\n        uint x2y2Root_ = FixedPointMathLib.sqrt(x2 * y2 * 1e18);\n\n        a_ = (int(y2 * xyRoot_ + t * xyRoot_) - int(y * x2y2Root_)) / int(xyRoot_ + x2y2Root_);\n    }\n\n    /// @param t total amount out\n    /// @param x imaginary reserves of token in of collateral\n    /// @param y imaginary reserves of token out of collateral\n    /// @param x2 imaginary reserves of token in of debt\n    /// @param y2 imaginary reserves of token out of debt\n    /// @return a_ how much swap should go through collateral pool. Remaining will go from debt\n    /// note if a < 0 then entire trade route through debt pool and debt pool arbitrage with col pool\n    /// note if a > t then entire trade route through col pool and col pool arbitrage with debt pool\n    /// note if a > 0 & a < t then swap will route through both pools\n    function _swapRoutingOut(uint t, uint x, uint y, uint x2, uint y2) internal pure returns (int a_) {\n        // Main equations:\n        // 1. in = (x * a) / (y - a)\n        // 2. in2 = (x2 * (t - a)) / (y2 - (t - a))\n        // final price should be same\n        // 3. (y - a) / (x + in) = (y2 - (t - a)) / (x2 + in2)\n        // derivation: https://chatgpt.com/share/6585bc28-841f-49ec-aea2-1e5c5b7f4fa9\n\n        // adding 1e18 precision\n        uint xyRoot_ = FixedPointMathLib.sqrt(x * y * 1e18);\n        uint x2y2Root_ = FixedPointMathLib.sqrt(x2 * y2 * 1e18);\n\n        // 1e18 precision gets cancelled out in division\n        a_ = (int(t * xyRoot_ + y * x2y2Root_) - int(y2 * xyRoot_)) / int(xyRoot_ + x2y2Root_);\n    }\n\n    function _utilizationVerify(uint utilizationLimit_, bytes32 exchangePriceSlot_) internal view {\n        if (utilizationLimit_ < THREE_DECIMALS) {\n            utilizationLimit_ = utilizationLimit_ * 10;\n            // extracting utilization of token from liquidity layer\n            uint liquidityLayerUtilization_ = LIQUIDITY.readFromStorage(exchangePriceSlot_);\n            liquidityLayerUtilization_ =\n                (liquidityLayerUtilization_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) &\n                X14;\n            // Note: this can go slightly above the utilization limit if no update is written to storage at liquidity layer\n            // if swap was not big enough to go far enough above or any other storage update threshold write cause there\n            // so just to keep in mind when configuring the actual limit reachable can be utilizationLimit_ + storageUpdateThreshold at Liquidity\n            if (liquidityLayerUtilization_ > utilizationLimit_)\n                revert FluidDexError(ErrorTypes.DexT1__LiquidityLayerTokenUtilizationCapReached);\n        }\n    }\n\n    function _check(uint dexVariables_, uint dexVariables2_) internal {\n        if (dexVariables_ & 1 == 1) revert FluidDexError(ErrorTypes.DexT1__AlreadyEntered);\n        if (dexVariables2_ & 3 == 0) revert FluidDexError(ErrorTypes.DexT1__PoolNotInitialized);\n        // enabling re-entrancy\n        dexVariables = dexVariables_ | 1;\n    }\n\n    /// @dev if token0 reserves are too low w.r.t token1 then revert, this is to avoid edge case scenario and making sure that precision on calculations should be high enough\n    function _verifyToken0Reserves(\n        uint token0Reserves_,\n        uint token1Reserves_,\n        uint centerPrice_,\n        uint minLiquidity_\n    ) internal pure {\n        if (((token0Reserves_) < ((token1Reserves_ * 1e27) / (centerPrice_ * minLiquidity_)))) {\n            revert FluidDexError(ErrorTypes.DexT1__TokenReservesTooLow);\n        }\n    }\n\n    /// @dev if token1 reserves are too low w.r.t token0 then revert, this is to avoid edge case scenario and making sure that precision on calculations should be high enough\n    function _verifyToken1Reserves(\n        uint token0Reserves_,\n        uint token1Reserves_,\n        uint centerPrice_,\n        uint minLiquidity_\n    ) internal pure {\n        if (((token1Reserves_) < ((token0Reserves_ * centerPrice_) / (1e27 * minLiquidity_)))) {\n            revert FluidDexError(ErrorTypes.DexT1__TokenReservesTooLow);\n        }\n    }\n\n    function _verifySwapAndNonPerfectActions(uint amountAdjusted_, uint amount_) internal pure {\n        // after shifting amount should not become 0\n        // limiting to six decimals which means in case of USDC, USDT it's 1 wei, for WBTC 100 wei, for ETH 1000 gwei\n        if (amountAdjusted_ < SIX_DECIMALS || amountAdjusted_ > X96 || amount_ < TWO_DECIMALS || amount_ > X128)\n            revert FluidDexError(ErrorTypes.DexT1__LimitingAmountsSwapAndNonPerfectActions);\n    }\n\n    /// @dev Calculates the new upper and lower range values during an active range shift\n    /// @param upperRange_ The target upper range value\n    /// @param lowerRange_ The target lower range value\n    /// @param dexVariables2_ needed in case shift is ended and we need to update dexVariables2\n    /// @return The updated upper range, lower range, and dexVariables2\n    /// @notice This function handles the gradual shifting of range values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcRangeShifting(\n        uint upperRange_,\n        uint lowerRange_,\n        uint dexVariables2_\n    ) internal returns (uint, uint, uint) {\n        return\n            abi.decode(\n                _spell(\n                    SHIFT_IMPLEMENTATION,\n                    abi.encodeWithSelector(\n                        IShifting._calcRangeShifting.selector,\n                        upperRange_,\n                        lowerRange_,\n                        dexVariables2_\n                    )\n                ),\n                (uint, uint, uint)\n            );\n    }\n\n    /// @dev Calculates the new upper and lower threshold values during an active threshold shift\n    /// @param upperThreshold_ The target upper threshold value\n    /// @param lowerThreshold_ The target lower threshold value\n    /// @param thresholdTime_ The time passed since shifting started\n    /// @return The updated upper threshold, lower threshold, and threshold time\n    /// @notice This function handles the gradual shifting of threshold values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcThresholdShifting(\n        uint upperThreshold_,\n        uint lowerThreshold_,\n        uint thresholdTime_\n    ) internal returns (uint, uint, uint) {\n        return\n            abi.decode(\n                _spell(\n                    SHIFT_IMPLEMENTATION,\n                    abi.encodeWithSelector(\n                        IShifting._calcThresholdShifting.selector,\n                        upperThreshold_,\n                        lowerThreshold_,\n                        thresholdTime_\n                    )\n                ),\n                (uint, uint, uint)\n            );\n    }\n\n    /// @dev Calculates the new center price during an active price shift\n    /// @param dexVariables_ The current state of dex variables\n    /// @param dexVariables2_ Additional dex variables\n    /// @return newCenterPrice_ The updated center price\n    /// @notice This function gradually shifts the center price towards a new target price over time\n    /// @notice It uses an external price source (via ICenterPrice) to determine the target price\n    /// @notice The shift continues until the current price reaches the target, or the shift duration ends\n    /// @notice Once the shift is complete, it updates the state and clears the shift data\n    /// @notice The shift rate is dynamic and depends on:\n    /// @notice - Time remaining in the shift duration\n    /// @notice - The new center price (fetched externally, which may change)\n    /// @notice - The current (old) center price\n    /// @notice This results in a fuzzy shifting mechanism where the rate can change as these parameters evolve\n    /// @notice The externally fetched new center price is expected to not differ significantly from the last externally fetched center price\n    function _calcCenterPrice(uint dexVariables_, uint dexVariables2_) internal returns (uint newCenterPrice_) {\n        return\n            abi.decode(\n                _spell(\n                    SHIFT_IMPLEMENTATION,\n                    abi.encodeWithSelector(IShifting._calcCenterPrice.selector, dexVariables_, dexVariables2_)\n                ),\n                (uint)\n            );\n    }\n\n    /// @notice Calculates and returns the current prices and exchange prices for the pool\n    /// @param dexVariables_ The first set of DEX variables containing various pool parameters\n    /// @param dexVariables2_ The second set of DEX variables containing additional pool parameters\n    /// @return pex_ A struct containing the calculated prices and exchange prices:\n    ///         - pex_.lastStoredPrice: The last stored price in 1e27 decimals\n    ///         - pex_.centerPrice: The calculated or fetched center price in 1e27 decimals\n    ///         - pex_.upperRange: The upper range price limit in 1e27 decimals\n    ///         - pex_.lowerRange: The lower range price limit in 1e27 decimals\n    ///         - pex_.geometricMean: The geometric mean of upper range & lower range in 1e27 decimals\n    ///         - pex_.supplyToken0ExchangePrice: The current exchange price for supplying token0\n    ///         - pex_.borrowToken0ExchangePrice: The current exchange price for borrowing token0\n    ///         - pex_.supplyToken1ExchangePrice: The current exchange price for supplying token1\n    ///         - pex_.borrowToken1ExchangePrice: The current exchange price for borrowing token1\n    /// @dev This function performs the following operations:\n    ///      1. Determines the center price (either from storage, external source, or calculated)\n    ///      2. Retrieves the last stored price from dexVariables_\n    ///      3. Calculates the upper and lower range prices based on the center price and range percentages\n    ///      4. Checks if rebalancing is needed based on threshold settings\n    ///      5. Adjusts prices if necessary based on the time elapsed and threshold conditions\n    ///      6. Update the dexVariables2_ if changes were made\n    ///      7. Returns the calculated prices and exchange prices in the PricesAndExchangePrice struct\n    function _getPricesAndExchangePrices(\n        uint dexVariables_,\n        uint dexVariables2_\n    ) internal returns (PricesAndExchangePrice memory pex_) {\n        uint centerPrice_;\n\n        if (((dexVariables2_ >> 248) & 1) == 0) {\n            // centerPrice_ => center price hook\n            centerPrice_ = (dexVariables2_ >> 112) & X30;\n            if (centerPrice_ == 0) {\n                centerPrice_ = (dexVariables_ >> 81) & X40;\n                centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n            } else {\n                // center price should be fetched from external source. For exmaple, in case of wstETH <> ETH pool,\n                // we would want the center price to be pegged to wstETH exchange rate into ETH\n                centerPrice_ = ICenterPrice(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, centerPrice_)).centerPrice();\n            }\n        } else {\n            // an active centerPrice_ shift is going on\n            centerPrice_ = _calcCenterPrice(dexVariables_, dexVariables2_);\n        }\n\n        uint lastStoredPrice_ = (dexVariables_ >> 41) & X40;\n        lastStoredPrice_ = (lastStoredPrice_ >> DEFAULT_EXPONENT_SIZE) << (lastStoredPrice_ & DEFAULT_EXPONENT_MASK);\n\n        uint upperRange_ = ((dexVariables2_ >> 27) & X20);\n        uint lowerRange_ = ((dexVariables2_ >> 47) & X20);\n        if (((dexVariables2_ >> 26) & 1) == 1) {\n            // an active range shift is going on\n            (upperRange_, lowerRange_, dexVariables2_) = _calcRangeShifting(upperRange_, lowerRange_, dexVariables2_);\n        }\n\n        unchecked {\n            // adding into unchecked because upperRange_ & lowerRange_ can only be > 0 & < SIX_DECIMALS\n            // 1% = 1e4, 100% = 1e6\n            upperRange_ = (centerPrice_ * SIX_DECIMALS) / (SIX_DECIMALS - upperRange_);\n            // 1% = 1e4, 100% = 1e6\n            lowerRange_ = (centerPrice_ * (SIX_DECIMALS - lowerRange_)) / SIX_DECIMALS;\n        }\n\n        bool changed_;\n        {\n            // goal will be to keep threshold percents 0 if center price is fetched from external source\n            // checking if threshold are set non 0 then only rebalancing is on\n            if (((dexVariables2_ >> 68) & X20) > 0) {\n                uint upperThreshold_ = (dexVariables2_ >> 68) & X10;\n                uint lowerThreshold_ = (dexVariables2_ >> 78) & X10;\n                uint shiftingTime_ = (dexVariables2_ >> 88) & X24;\n                if (((dexVariables2_ >> 67) & 1) == 1) {\n                    // if active shift is going on for threshold then calculate threshold real time\n                    (upperThreshold_, lowerThreshold_, shiftingTime_) = _calcThresholdShifting(\n                        upperThreshold_,\n                        lowerThreshold_,\n                        shiftingTime_\n                    );\n                }\n\n                unchecked {\n                    if (\n                        lastStoredPrice_ >\n                        (centerPrice_ +\n                            ((upperRange_ - centerPrice_) * (THREE_DECIMALS - upperThreshold_)) /\n                            THREE_DECIMALS)\n                    ) {\n                        uint timeElapsed_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n                        // price shifting towards upper range\n                        if (timeElapsed_ < shiftingTime_) {\n                            centerPrice_ = centerPrice_ + ((upperRange_ - centerPrice_) * timeElapsed_) / shiftingTime_;\n                        } else {\n                            // 100% price shifted\n                            centerPrice_ = upperRange_;\n                        }\n                        changed_ = true;\n                    } else if (\n                        lastStoredPrice_ <\n                        (centerPrice_ -\n                            ((centerPrice_ - lowerRange_) * (THREE_DECIMALS - lowerThreshold_)) /\n                            THREE_DECIMALS)\n                    ) {\n                        uint timeElapsed_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n                        // price shifting towards lower range\n                        if (timeElapsed_ < shiftingTime_) {\n                            centerPrice_ = centerPrice_ - ((centerPrice_ - lowerRange_) * timeElapsed_) / shiftingTime_;\n                        } else {\n                            // 100% price shifted\n                            centerPrice_ = lowerRange_;\n                        }\n                        changed_ = true;\n                    }\n                }\n            }\n        }\n\n        // temp_ => max center price\n        uint temp_ = (dexVariables2_ >> 172) & X28;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n        if (centerPrice_ > temp_) {\n            // if center price is greater than max center price\n            centerPrice_ = temp_;\n            changed_ = true;\n        } else {\n            // check if center price is less than min center price\n            // temp_ => min center price\n            temp_ = (dexVariables2_ >> 200) & X28;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n            if (centerPrice_ < temp_) {\n                centerPrice_ = temp_;\n                changed_ = true;\n            }\n        }\n\n        // if centerPrice_ is changed then calculating upper and lower range again\n        if (changed_) {\n            upperRange_ = ((dexVariables2_ >> 27) & X20);\n            lowerRange_ = ((dexVariables2_ >> 47) & X20);\n            if (((dexVariables2_ >> 26) & 1) == 1) {\n                (upperRange_, lowerRange_, dexVariables2_) = _calcRangeShifting(\n                    upperRange_,\n                    lowerRange_,\n                    dexVariables2_\n                );\n            }\n\n            unchecked {\n                // adding into unchecked because upperRange_ & lowerRange_ can only be > 0 & < SIX_DECIMALS\n                // 1% = 1e4, 100% = 1e6\n                upperRange_ = (centerPrice_ * SIX_DECIMALS) / (SIX_DECIMALS - upperRange_);\n                // 1% = 1e4, 100% = 1e6\n                lowerRange_ = (centerPrice_ * (SIX_DECIMALS - lowerRange_)) / SIX_DECIMALS;\n            }\n        }\n\n        pex_.lastStoredPrice = lastStoredPrice_;\n        pex_.centerPrice = centerPrice_;\n        pex_.upperRange = upperRange_;\n        pex_.lowerRange = lowerRange_;\n\n        unchecked {\n            if (upperRange_ < 1e38) {\n                // 1e38 * 1e38 = 1e76 which is less than max uint limit\n                pex_.geometricMean = FixedPointMathLib.sqrt(upperRange_ * lowerRange_);\n            } else {\n                // upperRange_ price is pretty large hence lowerRange_ will also be pretty large\n                pex_.geometricMean = FixedPointMathLib.sqrt((upperRange_ / 1e18) * (lowerRange_ / 1e18)) * 1e18;\n            }\n        }\n\n        // Exchange price will remain same as Liquidity Layer\n        (pex_.supplyToken0ExchangePrice, pex_.borrowToken0ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_0_SLOT)\n        );\n\n        (pex_.supplyToken1ExchangePrice, pex_.borrowToken1ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_1_SLOT)\n        );\n    }\n\n    /// @dev getting reserves outside range.\n    /// @param gp_ is geometric mean pricing of upper percent & lower percent\n    /// @param pa_ price of upper range or lower range\n    /// @param rx_ real reserves of token0 or token1\n    /// @param ry_ whatever is rx_ the other will be ry_\n    function _calculateReservesOutsideRange(\n        uint gp_,\n        uint pa_,\n        uint rx_,\n        uint ry_\n    ) internal pure returns (uint xa_, uint yb_) {\n        // equations we have:\n        // 1. x*y = k\n        // 2. xa*ya = k\n        // 3. xb*yb = k\n        // 4. Pa = ya / xa = upperRange_ (known)\n        // 5. Pb = yb / xb = lowerRange_ (known)\n        // 6. x - xa = rx = real reserve of x (known)\n        // 7. y - yb = ry = real reserve of y (known)\n        // With solving we get:\n        // ((Pa*Pb)^(1/2) - Pa)*xa^2 + (rx * (Pa*Pb)^(1/2) + ry)*xa + rx*ry = 0\n        // yb = yb = xa * (Pa * Pb)^(1/2)\n\n        // xa = (GPrx + ry + (-rxry4(GP - Pa) + (GPrx + ry)^2)^0.5) / (2Pa - 2GP)\n        // multiply entire equation by 1e27 to remove the price decimals precision of 1e27\n        // xa = (GPrx + ry1e27 + (rxry4(Pa - GP)1e27 + (GPrx + ry1e27)^2)^0.5) / 2*(Pa - GP)\n        // dividing the equation with 2*(Pa - GP). Pa is always > GP so answer will be positive.\n        // xa = (((GPrx + ry1e27) / 2*(Pa - GP)) + (((rxry4(Pa - GP)1e27) / 4*(Pa - GP)^2) + ((GPrx + ry1e27) / 2*(Pa - GP))^2)^0.5)\n        // xa = (((GPrx + ry1e27) / 2*(Pa - GP)) + (((rxry1e27) / (Pa - GP)) + ((GPrx + ry1e27) / 2*(Pa - GP))^2)^0.5)\n\n        // dividing in 3 parts for simplification:\n        // part1 = (Pa - GP)\n        // part2 = (GPrx + ry1e27) / (2*part1)\n        // part3 = rxry\n        // note: part1 will almost always be < 1e28 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e29\n        uint p1_ = pa_ - gp_;\n        uint p2_ = ((gp_ * rx_) + (ry_ * 1e27)) / (2 * p1_);\n        uint p3_ = rx_ * ry_;\n        // to avoid overflowing\n        p3_ = (p3_ < 1e50) ? ((p3_ * 1e27) / p1_) : (p3_ / p1_) * 1e27;\n\n        // xa = part2 + (part3 + (part2 * part2))^(1/2)\n        // yb = xa_ * gp_\n        xa_ = p2_ + FixedPointMathLib.sqrt((p3_ + (p2_ * p2_)));\n        yb_ = (xa_ * gp_) / 1e27;\n    }\n\n    /// @dev Retrieves collateral amount from liquidity layer for a given token\n    /// @param supplyTokenSlot_ The storage slot for the supply token data\n    /// @param tokenExchangePrice_ The exchange price of the token\n    /// @param isToken0_ Boolean indicating if the token is token0 (true) or token1 (false)\n    /// @return tokenSupply_ The calculated liquidity collateral amount\n    function _getLiquidityCollateral(\n        bytes32 supplyTokenSlot_,\n        uint tokenExchangePrice_,\n        bool isToken0_\n    ) internal view returns (uint tokenSupply_) {\n        uint tokenSupplyData_ = LIQUIDITY.readFromStorage(supplyTokenSlot_);\n        tokenSupply_ = (tokenSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n        tokenSupply_ = (tokenSupply_ >> DEFAULT_EXPONENT_SIZE) << (tokenSupply_ & DEFAULT_EXPONENT_MASK);\n\n        if (tokenSupplyData_ & 1 == 1) {\n            // supply with interest is on\n            unchecked {\n                tokenSupply_ = (tokenSupply_ * tokenExchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n            }\n        }\n\n        unchecked {\n            tokenSupply_ = isToken0_\n                ? ((tokenSupply_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\n                : ((tokenSupply_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\n        }\n    }\n\n    /// @notice Calculates the real and imaginary reserves for collateral tokens\n    /// @dev This function retrieves the supply of both tokens from the liquidity layer,\n    ///      adjusts them based on exchange prices, and calculates imaginary reserves\n    ///      based on the geometric mean and price range\n    /// @param geometricMean_ The geometric mean of the token prices\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0SupplyExchangePrice_ The exchange price for token0 from liquidity layer\n    /// @param token1SupplyExchangePrice_ The exchange price for token1 from liquidity layer\n    /// @return c_ A struct containing the calculated real and imaginary reserves for both tokens:\n    ///         - token0RealReserves: The real reserves of token0\n    ///         - token1RealReserves: The real reserves of token1\n    ///         - token0ImaginaryReserves: The imaginary reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary reserves of token1\n    function _getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) internal view returns (CollateralReserves memory c_) {\n        uint token0Supply_ = _getLiquidityCollateral(SUPPLY_TOKEN_0_SLOT, token0SupplyExchangePrice_, true);\n        uint token1Supply_ = _getLiquidityCollateral(SUPPLY_TOKEN_1_SLOT, token1SupplyExchangePrice_, false);\n\n        if (geometricMean_ < 1e27) {\n            (c_.token0ImaginaryReserves, c_.token1ImaginaryReserves) = _calculateReservesOutsideRange(\n                geometricMean_,\n                upperRange_,\n                token0Supply_,\n                token1Supply_\n            );\n        } else {\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n            // 1 / geometricMean for new geometricMean\n            // 1 / lowerRange will become upper range\n            // 1 / upperRange will become lower range\n            (c_.token1ImaginaryReserves, c_.token0ImaginaryReserves) = _calculateReservesOutsideRange(\n                (1e54 / geometricMean_),\n                (1e54 / lowerRange_),\n                token1Supply_,\n                token0Supply_\n            );\n        }\n\n        c_.token0RealReserves = token0Supply_;\n        c_.token1RealReserves = token1Supply_;\n        unchecked {\n            c_.token0ImaginaryReserves += token0Supply_;\n            c_.token1ImaginaryReserves += token1Supply_;\n        }\n    }\n\n    /// @notice Calculates the real and imaginary debt reserves for both tokens\n    /// @dev This function uses a quadratic equation to determine the debt reserves\n    ///      based on the geometric mean price and the current debt amounts\n    /// @param gp_ The geometric mean price of upper range & lower range\n    /// @param pb_ The price of lower range\n    /// @param dx_ The debt amount of one token\n    /// @param dy_ The debt amount of the other token\n    /// @return rx_ The real debt reserve of the first token\n    /// @return ry_ The real debt reserve of the second token\n    /// @return irx_ The imaginary debt reserve of the first token\n    /// @return iry_ The imaginary debt reserve of the second token\n    function _calculateDebtReserves(\n        uint gp_,\n        uint pb_,\n        uint dx_,\n        uint dy_\n    ) internal pure returns (uint rx_, uint ry_, uint irx_, uint iry_) {\n        // Assigning letter to knowns:\n        // c = debtA\n        // d = debtB\n        // e = upperPrice\n        // f = lowerPrice\n        // g = upperPrice^1/2\n        // h = lowerPrice^1/2\n\n        // c = 1\n        // d = 2000\n        // e = 2222.222222\n        // f = 1800\n        // g = 2222.222222^1/2\n        // h = 1800^1/2\n\n        // Assigning letter to unknowns:\n        // w = realDebtReserveA\n        // x = realDebtReserveB\n        // y = imaginaryDebtReserveA\n        // z = imaginaryDebtReserveB\n        // k = k\n\n        // below quadratic will give answer of realDebtReserveB\n        // A, B, C of quadratic equation:\n        // A = h\n        // B = dh - cfg\n        // C = -cfdh\n\n        // A = lowerPrice^1/2\n        // B = debtBlowerPrice^1/2 - debtAlowerPriceupperPrice^1/2\n        // C = -(debtAlowerPricedebtBlowerPrice^1/2)\n\n        // x = (cfg  dh + (4cdf(h^2)+(cfgdh)^2))^(1/2)) / 2h\n        // simplifying dividing by h, note h = f^1/2\n        // x = ((cg(f^1/2)  d) / 2 + ((4cdff) / (4h^2) + ((cfg) / 2h  (dh) / 2h)^2))^(1/2))\n        // x = ((cg(f^1/2)  d) / 2 + ((cdf) + ((cg(f^1/2)  d) / 2)^2))^(1/2))\n\n        // dividing in 3 parts for simplification:\n        // part1 = (cg(f^1/2)  d) / 2\n        // part2 = (cdf)\n        // x = (part1 + (part2 + part1^2)^(1/2))\n        // note: part1 will almost always be < 1e27 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e28\n\n        // part1 = ((debtA * upperPrice^1/2 * lowerPrice^1/2) - debtB) / 2\n        // note: upperPrice^1/2 * lowerPrice^1/2 = geometric mean\n        // part1 = ((debtA * geometricMean) - debtB) / 2\n        // part2 = debtA * debtB * lowerPrice\n\n        // converting decimals properly as price is in 1e27 decimals\n        // part1 = ((debtA * geometricMean) - (debtB * 1e27)) / (2 * 1e27)\n        // part2 = (debtA * debtB * lowerPrice) / 1e27\n        // final x equals:\n        // x = (part1 + (part2 + part1^2)^(1/2))\n        int p1_ = (int(dx_ * gp_) - int(dy_ * 1e27)) / (2 * 1e27);\n        uint p2_ = (dx_ * dy_);\n        p2_ = p2_ < 1e50 ? (p2_ * pb_) / 1e27 : (p2_ / 1e27) * pb_;\n        ry_ = uint(p1_ + int(FixedPointMathLib.sqrt((p2_ + uint(p1_ * p1_)))));\n\n        // finding z:\n        // x^2 - zx + cfz = 0\n        // z*(x - cf) = x^2\n        // z = x^2 / (x - cf)\n        // z = x^2 / (x - debtA * lowerPrice)\n        // converting decimals properly as price is in 1e27 decimals\n        // z = (x^2 * 1e27) / ((x * 1e27) - (debtA * lowerPrice))\n\n        iry_ = ((ry_ * 1e27) - (dx_ * pb_));\n        if (iry_ < SIX_DECIMALS) {\n            // almost impossible situation to ever get here\n            revert FluidDexError(ErrorTypes.DexT1__DebtReservesTooLow);\n        }\n        if (ry_ < 1e25) {\n            iry_ = (ry_ * ry_ * 1e27) / iry_;\n        } else {\n            // note: it can never result in negative as final result will always be in positive\n            iry_ = (ry_ * ry_) / (iry_ / 1e27);\n        }\n\n        // finding y\n        // x = z * c / (y + c)\n        // y + c = z * c / x\n        // y = (z * c / x) - c\n        // y = (z * debtA / x) - debtA\n        irx_ = ((iry_ * dx_) / ry_) - dx_;\n\n        // finding w\n        // w = y * d / (z + d)\n        // w = (y * debtB) / (z + debtB)\n        rx_ = (irx_ * dy_) / (iry_ + dy_);\n    }\n\n    /// @notice Calculates the debt amount for a given token from liquidity layer\n    /// @param borrowTokenSlot_ The storage slot for the token's borrow data\n    /// @param tokenExchangePrice_ The current exchange price of the token\n    /// @param isToken0_ Boolean indicating if this is for token0 (true) or token1 (false)\n    /// @return tokenDebt_ The calculated debt amount for the token\n    function _getLiquidityDebt(\n        bytes32 borrowTokenSlot_,\n        uint tokenExchangePrice_,\n        bool isToken0_\n    ) internal view returns (uint tokenDebt_) {\n        uint tokenBorrowData_ = LIQUIDITY.readFromStorage(borrowTokenSlot_);\n\n        tokenDebt_ = (tokenBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n        tokenDebt_ = (tokenDebt_ >> 8) << (tokenDebt_ & X8);\n\n        if (tokenBorrowData_ & 1 == 1) {\n            // borrow with interest is on\n            unchecked {\n                tokenDebt_ = (tokenDebt_ * tokenExchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n            }\n        }\n\n        unchecked {\n            tokenDebt_ = isToken0_\n                ? ((tokenDebt_ * TOKEN_0_NUMERATOR_PRECISION) / TOKEN_0_DENOMINATOR_PRECISION)\n                : ((tokenDebt_ * TOKEN_1_NUMERATOR_PRECISION) / TOKEN_1_DENOMINATOR_PRECISION);\n        }\n    }\n\n    /// @notice Calculates the debt reserves for both tokens\n    /// @param geometricMean_ The geometric mean of the upper and lower price ranges\n    /// @param upperRange_ The upper price range\n    /// @param lowerRange_ The lower price range\n    /// @param token0BorrowExchangePrice_ The exchange price of token0 from liquidity layer\n    /// @param token1BorrowExchangePrice_ The exchange price of token1 from liquidity layer\n    /// @return d_ The calculated debt reserves for both tokens, containing:\n    ///         - token0Debt: The debt amount of token0\n    ///         - token1Debt: The debt amount of token1\n    ///         - token0RealReserves: The real reserves of token0 derived from token1 debt\n    ///         - token1RealReserves: The real reserves of token1 derived from token0 debt\n    ///         - token0ImaginaryReserves: The imaginary debt reserves of token0\n    ///         - token1ImaginaryReserves: The imaginary debt reserves of token1\n    function _getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) internal view returns (DebtReserves memory d_) {\n        uint token0Debt_ = _getLiquidityDebt(BORROW_TOKEN_0_SLOT, token0BorrowExchangePrice_, true);\n        uint token1Debt_ = _getLiquidityDebt(BORROW_TOKEN_1_SLOT, token1BorrowExchangePrice_, false);\n\n        d_.token0Debt = token0Debt_;\n        d_.token1Debt = token1Debt_;\n\n        if (geometricMean_ < 1e27) {\n            (\n                d_.token0RealReserves,\n                d_.token1RealReserves,\n                d_.token0ImaginaryReserves,\n                d_.token1ImaginaryReserves\n            ) = _calculateDebtReserves(geometricMean_, lowerRange_, token0Debt_, token1Debt_);\n        } else {\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n            // 1 / geometricMean for new geometricMean\n            // 1 / lowerRange will become upper range\n            // 1 / upperRange will become lower range\n            (\n                d_.token1RealReserves,\n                d_.token0RealReserves,\n                d_.token1ImaginaryReserves,\n                d_.token0ImaginaryReserves\n            ) = _calculateDebtReserves((1e54 / geometricMean_), (1e54 / upperRange_), token1Debt_, token0Debt_);\n        }\n    }\n\n    function _updateOracle(uint newPrice_, uint centerPrice_, uint dexVariables_) internal returns (uint) {\n        // time difference between last & current swap\n        uint timeDiff_ = block.timestamp - ((dexVariables_ >> 121) & X33);\n\n        uint temp_;\n        uint temp2_;\n        uint temp3_;\n\n        if (timeDiff_ > 0) {\n            // update oracle\n\n            // olderPrice_ => temp_\n            temp_ = (dexVariables_ >> 1) & X40;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // oldPrice_ => temp2_\n            temp2_ = (dexVariables_ >> 41) & X40;\n            temp2_ = (temp2_ >> DEFAULT_EXPONENT_SIZE) << (temp2_ & DEFAULT_EXPONENT_MASK);\n\n            // check newPrice_ & oldPrice_ difference should not be more than 5%\n            // old price w.r.t new price\n            int priceDiff_ = int(ORACLE_PRECISION) - int((temp2_ * ORACLE_PRECISION) / newPrice_);\n\n            unchecked {\n                if ((priceDiff_ > int(ORACLE_LIMIT)) || (priceDiff_ < -int(ORACLE_LIMIT))) {\n                    // if oracle price difference is more than 5% then revert\n                    // in 1 swap price should only change by <= 5%\n                    // if a total fall by let's say 8% then in current block price can only fall by 5% and\n                    // in next block it'll fall the remaining 3%\n                    revert FluidDexError(ErrorTypes.DexT1__OracleUpdateHugeSwapDiff);\n                }\n            }\n\n            unchecked {\n                // older price w.r.t old price\n                priceDiff_ = int(ORACLE_PRECISION) - int((temp_ * ORACLE_PRECISION) / temp2_);\n            }\n\n            // priceDiffInPercentAndSign_ => temp3_\n            // priceDiff_ will always be lower than ORACLE_LIMIT due to above check\n            unchecked {\n                if (priceDiff_ < 0) {\n                    temp3_ = ((uint(-priceDiff_) * X22) / ORACLE_LIMIT) << 1;\n                } else {\n                    // if greater than or equal to 0 then make sign flag 1\n                    temp3_ = (((uint(priceDiff_) * X22) / ORACLE_LIMIT) << 1) | 1;\n                }\n            }\n\n            if (timeDiff_ > X22) {\n                // if time difference is this then that means DEX has been inactive ~45 days\n                // that means oracle price of this DEX should not be used.\n                timeDiff_ = X22;\n            }\n\n            // temp_ => lastTimeDiff_\n            temp_ = (dexVariables_ >> 154) & X22;\n            uint nextOracleSlot_ = ((dexVariables_ >> 176) & X3);\n            uint oracleMap_ = (dexVariables_ >> 179) & X16;\n            if (temp_ > X9) {\n                if (nextOracleSlot_ > 0) {\n                    // if greater than 0 then current slot has 2 or more oracle slot empty\n                    // First 9 bits are of time, so not using that\n                    temp3_ = (temp3_ << 41) | (temp_ << 9);\n                    _oracle[oracleMap_] = _oracle[oracleMap_] | (temp3_ << (--nextOracleSlot_ * 32));\n                    if (nextOracleSlot_ > 0) {\n                        --nextOracleSlot_;\n                    } else {\n                        // if == 0 that means the oracle slots will get filled and shift to next oracle map\n                        nextOracleSlot_ = 7;\n                        unchecked {\n                            oracleMap_ = (oracleMap_ + 1) % TOTAL_ORACLE_MAPPING;\n                        }\n                        _oracle[oracleMap_] = 0;\n                    }\n                } else {\n                    // if == 0\n                    // then seconds will be in last map\n                    // precision will be in last map + 1\n                    // Storing precision & sign slot in first precision & sign slot and leaving time slot empty\n                    temp3_ = temp3_ << 9;\n                    _oracle[oracleMap_] = _oracle[oracleMap_] | temp3_;\n                    nextOracleSlot_ = 6; // storing 6 here as 7 is going to occupied right now\n                    unchecked {\n                        oracleMap_ = (oracleMap_ + 1) % TOTAL_ORACLE_MAPPING;\n                    }\n                    // Storing time in 2nd precision & sign and leaving time slot empty\n                    _oracle[oracleMap_] = temp_ << ((7 * 32) + 9);\n                }\n            } else {\n                temp3_ = (temp3_ << 9) | temp_;\n                unchecked {\n                    if (nextOracleSlot_ < 7) {\n                        _oracle[oracleMap_] = _oracle[oracleMap_] | (temp3_ << (nextOracleSlot_ * 32));\n                    } else {\n                        _oracle[oracleMap_] = temp3_ << ((7 * 32));\n                    }\n                }\n                if (nextOracleSlot_ > 0) {\n                    --nextOracleSlot_;\n                } else {\n                    nextOracleSlot_ = 7;\n                    unchecked {\n                        oracleMap_ = (oracleMap_ + 1) % TOTAL_ORACLE_MAPPING;\n                    }\n                    _oracle[oracleMap_] = 0;\n                }\n            }\n\n            // doing this due to stack too deep error when using params memory variables\n            temp_ = newPrice_;\n            temp2_ = centerPrice_;\n            temp3_ = dexVariables_;\n\n            // then update last price\n            temp3_ =\n                (temp3_ & 0xfffffffffffffff8000000000000000000000000000000000000000000000001) |\n                (((temp3_ >> 41) & X40) << 1) |\n                (temp_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN) << 41) |\n                (temp2_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN) << 81) |\n                (block.timestamp << 121) |\n                (timeDiff_ << 154) |\n                (nextOracleSlot_ << 176) |\n                (oracleMap_ << 179);\n        } else {\n            // temp_ => oldCenterPrice\n            temp_ = (dexVariables_ >> 81) & X40;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // Ensure that the center price is within the acceptable range of the old center price if it's not the first swap in the same block\n            unchecked {\n                if (\n                    (centerPrice_ < (((EIGHT_DECIMALS - 1) * temp_) / EIGHT_DECIMALS)) ||\n                    (centerPrice_ > (((EIGHT_DECIMALS + 1) * temp_) / EIGHT_DECIMALS))\n                ) {\n                    revert FluidDexError(ErrorTypes.DexT1__CenterPriceOutOfRange);\n                }\n            }\n\n            // olderPrice_ => temp_\n            temp_ = (dexVariables_ >> 1) & X40;\n            temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            // check newPrice_ & olderPrice_ difference should not be more than 5%\n            // older price w.r.t new price\n            int priceDiff_ = int(ORACLE_PRECISION) - int((temp_ * ORACLE_PRECISION) / newPrice_);\n\n            if ((priceDiff_ > int(ORACLE_LIMIT)) || (priceDiff_ < -int(ORACLE_LIMIT))) {\n                // if oracle price difference is more than 5% then revert\n                // in 1 swap price should only change by <= 5%\n                // if a total fall by let's say 8% then in current block price can only fall by 5% and\n                // in next block it'll fall the remaining 3%\n                revert FluidDexError(ErrorTypes.DexT1__OracleUpdateHugeSwapDiff);\n            }\n\n            // doing this due to stack too deep error when using params memory variables\n            temp_ = newPrice_;\n            temp3_ = dexVariables_;\n            // 2nd swap in same block no need to update anything around oracle, only need to update last swap price in dexVariables\n            temp3_ =\n                (temp3_ & 0xfffffffffffffffffffffffffffffffffffffffffffe0000000001ffffffffff) |\n                (temp_.toBigNumber(32, 8, BigMathMinified.ROUND_DOWN) << 41);\n        }\n\n        return temp3_;\n    }\n\n    function _hookVerify(uint hookAddress_, uint mode_, bool swap0to1_, uint price_) internal {\n        try\n            IHook(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, hookAddress_)).dexPrice(\n                mode_,\n                swap0to1_,\n                TOKEN_0,\n                TOKEN_1,\n                price_\n            )\n        returns (bool isOk_) {\n            if (!isOk_) revert FluidDexError(ErrorTypes.DexT1__HookReturnedFalse);\n        } catch (bytes memory /*lowLevelData*/) {\n            // skip checking hook nothing\n        }\n    }\n\n    constructor(ConstantViews memory constantViews_) ImmutableVariables(constantViews_) {}\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/helpers/secondaryHelpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport { UserHelpers } from \"./userHelpers.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { AddressCalcs } from \"../../../../../libraries/addressCalcs.sol\";\n\nabstract contract SecondaryHelpers is UserHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) UserHelpers(constantViews_) {}\n\n    /// @param c_ tokenA amount to swap and deposit\n    /// @param d_ tokenB imaginary reserves\n    /// @param e_ tokenA imaginary reserves\n    /// @param f_ tokenA real reserves\n    /// @param i_ tokenB real reserves\n    function _getSwapAndDeposit(uint c_, uint d_, uint e_, uint f_, uint i_) internal pure returns (uint shares_) {\n        // swap and deposit in equal proportion\n\n        // tokenAx = c\n        // imaginaryTokenBReserves = d\n        // imaginaryTokenAReserves = e\n        // tokenAReserves = f\n        // tokenBReserves = i\n\n        // Quadratic equations, A, B & C are:\n        // A = i\n        // B = (ie - ic + dc + fd)\n        // C = -iec\n\n        // final equation:\n        // token to swap = ((cdci+df+ei) + (4cei^2 + (cdci+df+ei)^2)^0.5) / 2i\n        // B = (cdci+df+ei)\n        // token to swap = (B + (4cei^2 + (B)^2)^0.5) / 2i\n        // simplifying above equation by dividing the entire equation by i:\n        // token to swap = (B/i + (4ce + (B/i)^2)^0.5) / 2\n        // note: d > i always, so dividing won't be an issue\n\n        // temp_ => B/i\n        uint temp_ = (c_ * d_ + d_ * f_ + e_ * i_ - c_ * i_) / i_;\n        uint temp2_ = 4 * c_ * e_;\n        uint amtToSwap_ = (FixedPointMathLib.sqrt((temp2_ + (temp_ * temp_))) - temp_) / 2;\n\n        // Ensure the amount to swap is within reasonable bounds:\n        // - Not greater than 99.9999% of the input amount (c_)\n        // - Not less than 0.0001% of the input amount (c_)\n        // This prevents extreme scenarios and maybe potential precision issues\n        if ((amtToSwap_ > ((c_ * (SIX_DECIMALS - 1)) / SIX_DECIMALS)) || (amtToSwap_ < (c_ / SIX_DECIMALS)))\n            revert FluidDexError(ErrorTypes.DexT1__SwapAndDepositTooLowOrTooHigh);\n\n        // temp_ => amt0ToDeposit\n        temp_ = c_ - amtToSwap_;\n        // (imaginaryTokenBReserves * amtToSwap_) / (imaginaryTokenAReserves + amtToSwap_)\n        // temp2_ => amt1ToDeposit_\n        temp2_ = (d_ * amtToSwap_) / (e_ + amtToSwap_);\n\n        // temp_ => shares1\n        temp_ = (temp_ * 1e18) / (f_ + amtToSwap_);\n        // temp2_ => shares1\n        temp2_ = (temp2_ * 1e18) / (i_ - temp2_);\n        // temp_ & temp2 should be same. Although, due to some possible precision loss taking the lower one\n        shares_ = temp_ > temp2_ ? temp2_ : temp_;\n    }\n\n    /// @notice Updates collateral reserves based on minting or burning of shares\n    /// @param newShares_ The number of new shares being minted or burned\n    /// @param totalOldShares_ The total number of shares before the operation\n    /// @param c_ The current collateral reserves\n    /// @param mintOrBurn_ True if minting shares, false if burning shares\n    /// @return c2_ The updated collateral reserves after the operation\n    function _getUpdatedColReserves(\n        uint newShares_,\n        uint totalOldShares_,\n        CollateralReserves memory c_,\n        bool mintOrBurn_ // true if mint, false if burn\n    ) internal pure returns (CollateralReserves memory c2_) {\n        if (mintOrBurn_) {\n            // If minting, increase reserves proportionally to new shares\n            c2_.token0RealReserves = c_.token0RealReserves + (c_.token0RealReserves * newShares_) / totalOldShares_;\n            c2_.token1RealReserves = c_.token1RealReserves + (c_.token1RealReserves * newShares_) / totalOldShares_;\n            c2_.token0ImaginaryReserves =\n                c_.token0ImaginaryReserves +\n                (c_.token0ImaginaryReserves * newShares_) /\n                totalOldShares_;\n            c2_.token1ImaginaryReserves =\n                c_.token1ImaginaryReserves +\n                (c_.token1ImaginaryReserves * newShares_) /\n                totalOldShares_;\n        } else {\n            // If burning, decrease reserves proportionally to burned shares\n            c2_.token0RealReserves = c_.token0RealReserves - ((c_.token0RealReserves * newShares_) / totalOldShares_);\n            c2_.token1RealReserves = c_.token1RealReserves - ((c_.token1RealReserves * newShares_) / totalOldShares_);\n            c2_.token0ImaginaryReserves =\n                c_.token0ImaginaryReserves -\n                ((c_.token0ImaginaryReserves * newShares_) / totalOldShares_);\n            c2_.token1ImaginaryReserves =\n                c_.token1ImaginaryReserves -\n                ((c_.token1ImaginaryReserves * newShares_) / totalOldShares_);\n        }\n        return c2_;\n    }\n\n    /// @param c_ tokenA current real reserves (aka reserves before withdraw & swap)\n    /// @param d_ tokenB current real reserves (aka reserves before withdraw & swap)\n    /// @param e_ tokenA: final imaginary reserves - real reserves (aka reserves outside range after withdraw & swap)\n    /// @param f_ tokenB: final imaginary reserves - real reserves (aka reserves outside range after withdraw & swap)\n    /// @param g_ tokenA perfect amount to withdraw\n    function _getWithdrawAndSwap(uint c_, uint d_, uint e_, uint f_, uint g_) internal pure returns (uint shares_) {\n        // Equations we have:\n        // 1. tokenAxa / tokenBxb = tokenAReserves / tokenBReserves (Withdraw in equal proportion)\n        // 2. newTokenAReserves = tokenAReserves - tokenAxa\n        // 3. newTokenBReserves = tokenBReserves - tokenBxb\n        // 4 (known). finalTokenAReserves = tokenAReserves - tokenAx\n        // 5 (known). finalTokenBReserves = tokenBReserves\n\n        // Note: Xnew * Ynew = k = Xfinal * Yfinal (Xfinal & Yfinal is final imaginary reserve of token A & B).\n        // Now as we know finalTokenAReserves & finalTokenAReserves, hence we can also calculate\n        // imaginaryReserveMinusRealReservesA = finalImaginaryAReserves - finalTokenAReserves\n        // imaginaryReserveMinusRealReservesB = finalImaginaryBReserves - finalTokenBReserves\n        // Swaps only happen on real reserves hence before and after swap imaginaryReserveMinusRealReservesA &\n        // imaginaryReserveMinusRealReservesB should have exactly the same value.\n\n        // 6. newImaginaryTokenAReserves = imaginaryReserveMinusRealReservesA + newTokenAReserves\n        // newImaginaryTokenAReserves = imaginaryReserveMinusRealReservesA + tokenAReserves - tokenAxa\n        // 7. newImaginaryTokenBReserves = imaginaryReserveMinusRealReservesB + newTokenBReserves\n        // newImaginaryTokenBReserves = imaginaryReserveMinusRealReservesB + tokenBReserves - tokenBxb\n        // 8. tokenAxb = (newImaginaryTokenAReserves * tokenBxb) / (newImaginaryTokenBReserves + tokenBxb)\n        // 9. tokenAxa + tokenAxb = tokenAx\n\n        // simplifying knowns in 1 letter to make things clear:\n        // c = tokenAReserves\n        // d = tokenBReserves\n        // e = imaginaryReserveMinusRealReservesA\n        // f = imaginaryReserveMinusRealReservesB\n        // g = tokenAx\n\n        // A, B, C of quadratic are:\n        // A = d\n        // B = -(de + 2cd + cf)\n        // C = cfg + cdg\n\n        // tokenAxa = ((de + 2cd + cf) - ((de + 2cd + cf)^2 - 4d(cfg + cdg))^0.5) / 2d\n        // dividing 2d first to avoid overflowing\n        // B = (de + 2cd + cf) / 2d\n        // (B - ((B)^2 - (4d(cfg + cdg) / 4d^2))^0.5)\n        // (B - ((B)^2 - ((cfg + cdg) / d))^0.5)\n\n        // temp_ = B/2A\n        uint temp_ = (d_ * e_ + 2 * c_ * d_ + c_ * f_) / (2 * d_);\n        // temp2_ = 4AC / 4A^2 = C / A\n        // to avoid overflowing in any case multiplying with g_ later\n        uint temp2_ = (((c_ * f_) / d_) + c_) * g_;\n\n        // tokenAxa = (-B - (B^2 - 4AC)^0.5) / 2A\n        uint tokenAxa_ = temp_ - FixedPointMathLib.sqrt((temp_ * temp_) - temp2_);\n\n        // Ensure the amount to withdraw is within reasonable bounds:\n        // - Not greater than 99.9999% of the input amount (g_)\n        // - Not less than 0.0001% of the input amount (g_)\n        // This prevents extreme scenarios and maybe potential precision issues\n        if (tokenAxa_ > ((g_ * SIX_DECIMALS - 1) / SIX_DECIMALS) || tokenAxa_ < (g_ / SIX_DECIMALS))\n            revert FluidDexError(ErrorTypes.DexT1__WithdrawAndSwapTooLowOrTooHigh);\n\n        shares_ = (tokenAxa_ * 1e18) / c_;\n    }\n\n    /// @param c_ tokenA current debt before swap (aka debt before borrow & swap)\n    /// @param d_ tokenB current debt before swap (aka debt before borrow & swap)\n    /// @param e_ tokenA final imaginary reserves (reserves after borrow & swap)\n    /// @param f_ tokenB final imaginary reserves (reserves after borrow & swap)\n    /// @param g_ tokenA perfect amount to borrow\n    function _getBorrowAndSwap(uint c_, uint d_, uint e_, uint f_, uint g_) internal pure returns (uint shares_) {\n        // 1. tokenAxa / tokenADebt = tokenBxb / tokenBDebt (borrowing in equal proportion)\n        // 2. newImaginaryTokenAReserves = tokenAFinalImaginaryReserves + tokenAxb\n        // 3. newImaginaryTokenBReserves = tokenBFinalImaginaryReserves - tokenBxb\n        // // Note: I assumed reserve of tokenA and debt of token A while solving which is fine.\n        // // But in other places I use debtA to find reserveB\n        // 4. tokenAxb = (newImaginaryTokenAReserves * tokenBxb) / (newImaginaryTokenBReserves + tokenBxb)\n        // 5. tokenAxa + tokenAxb = tokenAx\n\n        // Inserting 2 & 3 into 4:\n        // 6. tokenAxb = ((tokenAFinalImaginaryReserves + tokenAxb) * tokenBxb) / ((tokenBFinalImaginaryReserves - tokenBxb) + tokenBxb)\n        // 6. tokenAxb = ((tokenAFinalImaginaryReserves + tokenAxb) * tokenBxb) / (tokenBFinalImaginaryReserves)\n\n        // Making 1 in terms of tokenBxb:\n        // 1. tokenBxb = tokenAxa * tokenBDebt / tokenADebt\n\n        // Inserting 5 into 6:\n        // 7. (tokenAx - tokenAxa) = ((tokenAFinalImaginaryReserves + (tokenAx - tokenAxa)) * tokenBxb) / (tokenBFinalImaginaryReserves)\n\n        // Inserting 1 into 7:\n        // 8. (tokenAx - tokenAxa) * tokenBFinalImaginaryReserves = ((tokenAFinalImaginaryReserves + (tokenAx - tokenAxa)) * (tokenAxa * tokenBDebt / tokenADebt))\n\n        // Replacing knowns with:\n        // c = tokenADebt\n        // d = tokenBDebt\n        // e = tokenAFinalImaginaryReserves\n        // f = tokenBFinalImaginaryReserves\n        // g = tokenAx\n\n        // 8. (g - tokenAxa) * f * c = ((e + (g - tokenAxa)) * (tokenAxa * d))\n        // 8. cfg - cf*tokenAxa = de*tokenAxa + dg*tokenAxa - d*tokenAxa^2\n        // 8. d*tokenAxa^2 - cf*tokenAxa - de*tokenAxa - dg*tokenAxa + cfg = 0\n        // 8. d*tokenAxa^2 - (cf + de + dg)*tokenAxa + cfg = 0\n\n        // A, B, C of quadratic are:\n        // A = d\n        // B = -(cf + de + dg)\n        // C = cfg\n\n        // temp_ = B/2A\n        uint temp_ = (c_ * f_ + d_ * e_ + d_ * g_) / (2 * d_);\n\n        // temp2_ = 4AC / 4A^2 = C / A\n        // to avoid overflowing in any case multiplying with g_ later\n        uint temp2_ = (c_ * f_ * g_) / d_;\n\n        // tokenAxa = (-B - (B^2 - 4AC)^0.5) / 2A\n        uint tokenAxa_ = temp_ - FixedPointMathLib.sqrt((temp_ * temp_) - temp2_);\n\n        // Ensure the amount to borrow is within reasonable bounds:\n        // - Not greater than 99.9999% of the input amount (g_)\n        // - Not less than 0.0001% of the input amount (g_)\n        // This prevents extreme scenarios and maybe potential precision issues\n        if (tokenAxa_ > ((g_ * SIX_DECIMALS - 1) / SIX_DECIMALS) || tokenAxa_ < (g_ / SIX_DECIMALS))\n            revert FluidDexError(ErrorTypes.DexT1__BorrowAndSwapTooLowOrTooHigh);\n\n        shares_ = (tokenAxa_ * 1e18) / c_;\n    }\n\n    /// @notice Updates debt and reserves based on minting or burning shares\n    /// @param shares_ The number of shares to mint or burn\n    /// @param totalShares_ The total number of shares before the operation\n    /// @param d_ The current debt and reserves\n    /// @param mintOrBurn_ True if minting, false if burning\n    /// @return d2_ The updated debt and reserves\n    /// @dev This function calculates the new debt and reserves when minting or burning shares.\n    /// @dev It updates the following for both tokens:\n    /// @dev - Debt\n    /// @dev - Real Reserves\n    /// @dev - Imaginary Reserves\n    /// @dev The calculation is done proportionally based on the ratio of shares to total shares.\n    /// @dev For minting, it adds the proportional amount.\n    /// @dev For burning, it subtracts the proportional amount.\n    function _getUpdateDebtReserves(\n        uint shares_,\n        uint totalShares_,\n        DebtReserves memory d_,\n        bool mintOrBurn_ // true if mint, false if burn\n    ) internal pure returns (DebtReserves memory d2_) {\n        if (mintOrBurn_) {\n            d2_.token0Debt = d_.token0Debt + (d_.token0Debt * shares_) / totalShares_;\n            d2_.token1Debt = d_.token1Debt + (d_.token1Debt * shares_) / totalShares_;\n            d2_.token0RealReserves = d_.token0RealReserves + (d_.token0RealReserves * shares_) / totalShares_;\n            d2_.token1RealReserves = d_.token1RealReserves + (d_.token1RealReserves * shares_) / totalShares_;\n            d2_.token0ImaginaryReserves =\n                d_.token0ImaginaryReserves +\n                (d_.token0ImaginaryReserves * shares_) /\n                totalShares_;\n            d2_.token1ImaginaryReserves =\n                d_.token1ImaginaryReserves +\n                (d_.token1ImaginaryReserves * shares_) /\n                totalShares_;\n        } else {\n            d2_.token0Debt = d_.token0Debt - (d_.token0Debt * shares_) / totalShares_;\n            d2_.token1Debt = d_.token1Debt - (d_.token1Debt * shares_) / totalShares_;\n            d2_.token0RealReserves = d_.token0RealReserves - (d_.token0RealReserves * shares_) / totalShares_;\n            d2_.token1RealReserves = d_.token1RealReserves - (d_.token1RealReserves * shares_) / totalShares_;\n            d2_.token0ImaginaryReserves =\n                d_.token0ImaginaryReserves -\n                (d_.token0ImaginaryReserves * shares_) /\n                totalShares_;\n            d2_.token1ImaginaryReserves =\n                d_.token1ImaginaryReserves -\n                (d_.token1ImaginaryReserves * shares_) /\n                totalShares_;\n        }\n\n        return d2_;\n    }\n\n    /// @param a_ tokenA new imaginary reserves (imaginary reserves after perfect payback but not swap yet)\n    /// @param b_ tokenB new imaginary reserves (imaginary reserves after perfect payback but not swap yet)\n    /// @param c_ tokenA current debt\n    /// @param d_ tokenB current debt & final debt (tokenB current & final debt remains same)\n    /// @param i_ tokenA new reserves (reserves after perfect payback but not swap yet)\n    /// @param j_ tokenB new reserves (reserves after perfect payback but not swap yet)\n    function _getSwapAndPaybackOneTokenPerfectShares(\n        uint a_,\n        uint b_,\n        uint c_,\n        uint d_,\n        uint i_,\n        uint j_\n    ) internal pure returns (uint tokenAmt_) {\n        // l_ => tokenA reserves outside range\n        uint l_ = a_ - i_;\n        // m_ => tokenB reserves outside range\n        uint m_ = b_ - j_;\n        // w_ => new K or final K will be same, xy = k\n        uint w_ = a_ * b_;\n        // z_ => final reserveB full, when entire debt is in tokenA\n        uint z_ = w_ / l_;\n        // y_ => final reserveA full, when entire debt is in tokenB\n        uint y_ = w_ / m_;\n        // v_ = final reserveB\n        uint v_ = z_ - m_ - d_;\n        // x_ = final tokenA debt\n        uint x_ = (v_ * y_) / (m_ + v_);\n\n        // amountA to payback, this amount will get swapped into tokenB to payback in perfect proportion\n        tokenAmt_ = c_ - x_;\n\n        // Ensure the amount to swap and payback is within reasonable bounds:\n        // - Not greater than 99.9999% of the current debt (c_)\n        // This prevents extreme scenarios where almost all debt is getting paid after swap,\n        // which could maybe lead to precision issues & edge cases\n        if ((tokenAmt_ > (c_ * (SIX_DECIMALS - 1)) / SIX_DECIMALS))\n            revert FluidDexError(ErrorTypes.DexT1__SwapAndPaybackTooLowOrTooHigh);\n    }\n\n    /// @param c_ tokenA debt before swap & payback\n    /// @param d_ tokenB debt before swap & payback\n    /// @param e_ tokenA imaginary reserves before swap & payback\n    /// @param f_ tokenB imaginary reserves before swap & payback\n    /// @param g_ tokenA perfect amount to payback\n    function _getSwapAndPayback(uint c_, uint d_, uint e_, uint f_, uint g_) internal pure returns (uint shares_) {\n        // 1. tokenAxa / newTokenADebt = tokenBxb / newTokenBDebt (borrowing in equal proportion)\n        // 2. newTokenADebt = tokenADebt - tokenAxb\n        // 3. newTokenBDebt = tokenBDebt + tokenBxb\n        // 4. imaginaryTokenAReserves = Calculated above from debtA\n        // 5. imaginaryTokenBReserves = Calculated above from debtA\n        // // Note: I assumed reserveA and debtA for same tokenA\n        // // But in other places I used debtA to find reserveB\n        // 6. tokenBxb = (imaginaryTokenBReserves * tokenAxb) / (imaginaryTokenAReserves + tokenAxb)\n        // 7. tokenAxa + tokenAxb = tokenAx\n\n        // Unknowns in the above equations are:\n        // tokenAxa, tokenAxb, tokenBxb\n\n        // simplifying knowns in 1 letter to make things clear:\n        // c = tokenADebt\n        // d = tokenBDebt\n        // e = imaginaryTokenAReserves\n        // f = imaginaryTokenBReserves\n        // g = tokenAx\n\n        // Restructuring 1:\n        // 1. newTokenBDebt = (tokenBxb * newTokenADebt) / tokenAxa\n\n        // Inserting 1 in 3:\n        // 8. (tokenBxb * newTokenADebt) / tokenAxa = tokenBDebt + tokenBxb\n\n        // Refactoring 8 w.r.t tokenBxb:\n        // 8. (tokenBxb * newTokenADebt) - tokenAxa * tokenBxb = tokenBDebt * tokenAxa\n        // 8. tokenBxb * (newTokenADebt - tokenAxa) = tokenBDebt * tokenAxa\n        // 8. tokenBxb = (tokenBDebt * tokenAxa) / (newTokenADebt - tokenAxa)\n\n        // Inserting 2 in 8:\n        // 9. tokenBxb = (tokenBDebt * tokenAxa) / (tokenADebt - tokenAxb - tokenAxa)\n        // 9. tokenBxb = (tokenBDebt * tokenAxa) / (tokenADebt - tokenAx)\n\n        // Inserting 9 in 6:\n        // 10. (tokenBDebt * tokenAxa) / (tokenADebt - tokenAx) = (imaginaryTokenBReserves * tokenAxb) / (imaginaryTokenAReserves + tokenAxb)\n        // 10. (tokenBDebt * (tokenAx - tokenAxb)) / (tokenADebt - tokenAx) = (imaginaryTokenBReserves * tokenAxb) / (imaginaryTokenAReserves + tokenAxb)\n\n        // Replacing with single digits:\n        // 10. (d * (g - tokenAxb)) / (c - g) = (f * tokenAxb) / (e + tokenAxb)\n        // 10. d * (g - tokenAxb) * (e + tokenAxb) = (f * tokenAxb) * (c - g)\n        // 10. deg + dg*tokenAxb - de*tokenAxb - d*tokenAxb^2 = cf*tokenAxb - fg*tokenAxb\n        // 10. d*tokenAxb^2 + cf*tokenAxb - fg*tokenAxb + de*tokenAxb - dg*tokenAxb - deg = 0\n        // 10. d*tokenAxb^2 + (cf - fg + de - dg)*tokenAxb - deg = 0\n\n        // A = d\n        // B = (cf + de - fg - dg)\n        // C = -deg\n\n        // Solving Quadratic will give the value for tokenAxb, now that \"tokenAxb\" is known we can also know:\n        // tokenAxa & tokenBxb\n\n        // temp_ => B/A\n        uint temp_ = (c_ * f_ + d_ * e_ - f_ * g_ - d_ * g_) / d_;\n\n        // temp2_ = -AC / A^2\n        uint temp2_ = 4 * e_ * g_;\n\n        uint amtToSwap_ = (FixedPointMathLib.sqrt((temp2_ + (temp_ * temp_))) - temp_) / 2;\n\n        // Ensure the amount to swap is within reasonable bounds:\n        // - Not greater than 99.9999% of the input amount (g_)\n        // - Not less than 0.0001% of the input amount (g_)\n        // This prevents extreme scenarios and maybe potential precision issues\n        if ((amtToSwap_ > (g_ * (SIX_DECIMALS - 1)) / SIX_DECIMALS) || (amtToSwap_ < (g_ / SIX_DECIMALS)))\n            revert FluidDexError(ErrorTypes.DexT1__SwapAndPaybackTooLowOrTooHigh);\n\n        // temp_ => amt0ToPayback\n        temp_ = g_ - amtToSwap_;\n        // (imaginaryTokenBReserves * amtToSwap_) / (imaginaryTokenAReserves + amtToSwap_)\n        // temp2_ => amt1ToPayback\n        temp2_ = (f_ * amtToSwap_) / (e_ + amtToSwap_);\n\n        // temp_ => shares0\n        temp_ = (temp_ * 1e18) / (c_ - amtToSwap_);\n        // temp_ => shares1\n        temp2_ = (temp2_ * 1e18) / (d_ + temp2_);\n        // temp_ & temp2 should be same. Although, due to some possible precision loss taking the lower one\n        shares_ = temp_ > temp2_ ? temp2_ : temp_;\n    }\n\n    /// @dev This function performs arbitrage between the collateral and debt pools\n    /// @param dexVariables_ The current state of dex variables\n    /// @param dexVariables2_ Additional dex variables\n    /// @param pex_ Struct containing prices and exchange rates\n    /// @notice This function is called after user operations to balance the pools\n    /// @notice It swaps tokens between the collateral and debt pools to align their prices\n    /// @notice The function updates the oracle price based on the arbitrage results\n    function _arbitrage(uint dexVariables_, uint dexVariables2_, PricesAndExchangePrice memory pex_) internal {\n        if ((dexVariables2_ >> 255) == 1) revert FluidDexError(ErrorTypes.DexT1__SwapAndArbitragePaused);\n\n        CollateralReserves memory c_;\n        DebtReserves memory d_;\n        uint price_;\n        if ((dexVariables2_ & 1) == 1) {\n            c_ = _getCollateralReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.supplyToken0ExchangePrice,\n                pex_.supplyToken1ExchangePrice\n            );\n        }\n        if ((dexVariables2_ & 2) == 2) {\n            d_ = _getDebtReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.borrowToken0ExchangePrice,\n                pex_.borrowToken1ExchangePrice\n            );\n        }\n        if ((dexVariables2_ & 3) < 3) {\n            price_ = ((dexVariables2_ & 1) == 1)\n                ? ((c_.token1ImaginaryReserves) * 1e27) / (c_.token0ImaginaryReserves)\n                : ((d_.token1ImaginaryReserves) * 1e27) / (d_.token0ImaginaryReserves);\n            // arbitrage should only happen if both smart debt & smart collateral are enabled\n            // Storing in storage, it will also uninitialize re-entrancy\n            dexVariables = _updateOracle(price_, pex_.centerPrice, dexVariables_);\n            return;\n        }\n\n        uint temp_;\n        uint amtOut_;\n        uint amtIn_;\n\n        // both smart debt & smart collateral enabled\n\n        // always swapping token0 into token1\n        int a_ = _swapRoutingIn(\n            0,\n            c_.token1ImaginaryReserves,\n            c_.token0ImaginaryReserves,\n            d_.token1ImaginaryReserves,\n            d_.token0ImaginaryReserves\n        );\n        if (a_ > 0) {\n            // swap will route through col pool\n            temp_ = uint(a_);\n            amtOut_ = _getAmountOut(temp_, c_.token0ImaginaryReserves, c_.token1ImaginaryReserves);\n            amtIn_ = _getAmountIn(temp_, d_.token1ImaginaryReserves, d_.token0ImaginaryReserves);\n\n            // new pool price\n            // debt pool price will be the same as collateral pool after the swap\n            // note: updating price here as in next line amtOut_ will get updated to normal amounts\n            price_ = ((c_.token1ImaginaryReserves - amtOut_) * 1e27) / (c_.token0ImaginaryReserves + temp_);\n\n            // converting into normal token form from DEX precisions\n            a_ = (((a_) * int(TOKEN_0_DENOMINATOR_PRECISION)) / int(TOKEN_0_NUMERATOR_PRECISION));\n            amtOut_ = (((amtOut_) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n            amtIn_ = (((amtIn_) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n\n            // deposit token0 and borrow token0\n            // withdraw token1 and payback token1\n            LIQUIDITY.operate(TOKEN_0, a_, a_, address(0), address(this), abi.encode(SKIP_TRANSFERS, address(this)));\n            LIQUIDITY.operate(\n                TOKEN_1,\n                -int(amtOut_),\n                -int(amtIn_),\n                address(this),\n                address(0),\n                abi.encode(SKIP_TRANSFERS, address(this))\n            );\n        } else if (a_ < 0) {\n            // swap will route through debt pool\n            temp_ = uint(-a_);\n            amtOut_ = _getAmountOut(temp_, d_.token0ImaginaryReserves, d_.token1ImaginaryReserves);\n            amtIn_ = _getAmountIn(temp_, c_.token1ImaginaryReserves, c_.token0ImaginaryReserves);\n\n            // new pool price\n            // debt pool price will be the same as collateral pool after the swap\n            // note: updating price here as in next line amtOut_ will get updated to normal amounts\n            price_ = ((d_.token1ImaginaryReserves - amtOut_) * 1e27) / (d_.token0ImaginaryReserves + temp_);\n\n            // converting into normal token form from DEX precisions\n            a_ = ((a_ * int(TOKEN_0_DENOMINATOR_PRECISION)) / int(TOKEN_0_NUMERATOR_PRECISION));\n            amtOut_ = ((amtOut_ * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n            amtIn_ = (((amtIn_) * TOKEN_1_DENOMINATOR_PRECISION) / TOKEN_1_NUMERATOR_PRECISION);\n\n            // payback token0 and withdraw token0\n            // deposit token1 and borrow token1\n            LIQUIDITY.operate(TOKEN_0, a_, a_, address(this), address(0), abi.encode(SKIP_TRANSFERS, address(this)));\n            LIQUIDITY.operate(\n                TOKEN_1,\n                int(amtIn_),\n                int(amtOut_),\n                address(0),\n                address(this),\n                abi.encode(SKIP_TRANSFERS, address(this))\n            );\n        } else {\n            // reverting if nothing to arbitrage. Naturally to get here will have very low probability\n            revert FluidDexError(ErrorTypes.DexT1__NothingToArbitrage);\n        }\n\n        // if hook exists then calling hook\n        temp_ = (dexVariables2_ >> 142) & X30;\n        if (temp_ > 0) {\n            uint lastPrice_ = (dexVariables_ >> 41) & X40;\n            lastPrice_ = (lastPrice_ >> DEFAULT_EXPONENT_SIZE) << (lastPrice_ & DEFAULT_EXPONENT_MASK);\n            _hookVerify(temp_, 2, lastPrice_ > price_, price_);\n        }\n\n        // Storing in storage, it will also uninitialize re-entrancy\n        dexVariables = _updateOracle(price_, pex_.centerPrice, dexVariables_);\n\n        emit LogArbitrage(a_, amtOut_);\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/helpers/userHelpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport { CoreHelpers } from \"./coreHelpers.sol\";\nimport { ErrorTypes } from \"../../../errorTypes.sol\";\nimport { DexSlotsLink } from \"../../../../../libraries/dexSlotsLink.sol\";\nimport { DexCalcs } from \"../../../../../libraries/dexCalcs.sol\";\nimport { BigMathMinified } from \"../../../../../libraries/bigMathMinified.sol\";\nimport { SafeTransfer } from \"../../../../../libraries/safeTransfer.sol\";\nimport { LiquidityCalcs } from \"../../../../../libraries/liquidityCalcs.sol\";\n\nabstract contract UserHelpers is CoreHelpers {\n    using BigMathMinified for uint256;\n\n    constructor(ConstantViews memory constantViews_) CoreHelpers(constantViews_) {}\n\n    function _verifyMint(uint amt_, uint totalAmt_) internal pure {\n        // not minting too less shares or too more\n        // If totalAmt_ is worth $1 then user can at max mint $1B of new amt_ at once.\n        // If totalAmt_ is worth $1B then user have to mint min of $1 of amt_.\n        if (amt_ < (totalAmt_ / NINE_DECIMALS) || amt_ > (totalAmt_ * NINE_DECIMALS)) {\n            revert FluidDexError(ErrorTypes.DexT1__MintAmtOverflow);\n        }\n    }\n\n    function _verifyRedeem(uint amt_, uint totalAmt_) internal pure {\n        // If burning of amt_ is > 99.99% of totalAmt_ at once, then revert.\n        if (amt_ > ((totalAmt_ * 9999) / FOUR_DECIMALS)) {\n            revert FluidDexError(ErrorTypes.DexT1__BurnAmtOverflow);\n        }\n    }\n\n    function _getExchangePrices() internal view returns (ExchangePrices memory ex_) {\n        // Exchange price will remain same as Liquidity Layer\n        (ex_.supplyToken0ExchangePrice, ex_.borrowToken0ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_0_SLOT)\n        );\n\n        (ex_.supplyToken1ExchangePrice, ex_.borrowToken1ExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(EXCHANGE_PRICE_TOKEN_1_SLOT)\n        );\n    }\n\n    function _updatingUserSupplyDataOnStorage(\n        uint userSupplyData_,\n        uint userSupply_,\n        uint newWithdrawalLimit_\n    ) internal {\n        // calculate withdrawal limit to store as previous withdrawal limit in storage\n        newWithdrawalLimit_ = DexCalcs.calcWithdrawalLimitAfterOperate(\n            userSupplyData_,\n            userSupply_,\n            newWithdrawalLimit_\n        );\n\n        userSupply_ = userSupply_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_DOWN\n        );\n\n        newWithdrawalLimit_ = newWithdrawalLimit_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_DOWN\n        );\n\n        if (((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64) == userSupply_) {\n            // make sure that shares amount is not so small that it wouldn't affect storage update. if a difference\n            // is present then rounding will be in the right direction to avoid any potential manipulation.\n            revert FluidDexError(ErrorTypes.DexT1__SharesAmountInsufficient);\n        }\n\n        // Updating on storage, copied exactly the same from Liquidity Layer\n        _userSupplyData[msg.sender] =\n            // mask to update bits 1-161 (supply amount, withdrawal limit, timestamp)\n            (userSupplyData_ & 0xfffffffffffffffffffffffc0000000000000000000000000000000000000001) |\n            (userSupply_ << DexSlotsLink.BITS_USER_SUPPLY_AMOUNT) | // converted to BigNumber can not overflow\n            (newWithdrawalLimit_ << DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) | // converted to BigNumber can not overflow\n            (block.timestamp << DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP);\n    }\n\n    function _updatingUserBorrowDataOnStorage(uint userBorrowData_, uint userBorrow_, uint newBorrowLimit_) internal {\n        // calculate borrow limit to store as previous borrow limit in storage\n        newBorrowLimit_ = DexCalcs.calcBorrowLimitAfterOperate(userBorrowData_, userBorrow_, newBorrowLimit_);\n\n        // Converting user's borrowings into bignumber\n        userBorrow_ = userBorrow_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_UP\n        );\n\n        // Converting borrow limit into bignumber\n        newBorrowLimit_ = newBorrowLimit_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_DOWN\n        );\n\n        if (((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_AMOUNT) & X64) == userBorrow_) {\n            // make sure that shares amount is not so small that it wouldn't affect storage update. if a difference\n            // is present then rounding will be in the right direction to avoid any potential manipulation.\n            revert FluidDexError(ErrorTypes.DexT1__SharesAmountInsufficient);\n        }\n\n        // Updating on storage, copied exactly the same from Liquidity Layer\n        _userBorrowData[msg.sender] =\n            // mask to update bits 1-161 (borrow amount, borrow limit, timestamp)\n            (userBorrowData_ & 0xfffffffffffffffffffffffc0000000000000000000000000000000000000001) |\n            (userBorrow_ << DexSlotsLink.BITS_USER_BORROW_AMOUNT) | // converted to BigNumber can not overflow\n            (newBorrowLimit_ << DexSlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) | // converted to BigNumber can not overflow\n            (block.timestamp << DexSlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP);\n    }\n\n    /// @notice Deposits or pays back in liquidity\n    /// @param token_ The token to deposit or pay back\n    /// @param depositAmt_ The amount to deposit\n    /// @param paybackAmt_ The amount to pay back\n    function _depositOrPaybackInLiquidity(address token_, uint depositAmt_, uint paybackAmt_) internal {\n        // both cannot be greater than 0\n        // if both are 0 then liquidity layer will revert\n        // only 1 should be greater than 0\n        if (depositAmt_ > 0 && paybackAmt_ > 0) revert();\n        if (token_ == NATIVE_TOKEN) {\n            uint amt_ = depositAmt_ > 0 ? depositAmt_ : paybackAmt_;\n            if (msg.value > amt_) {\n                SafeTransfer.safeTransferNative(msg.sender, msg.value - amt_);\n            } else if (msg.value < amt_) {\n                revert FluidDexError(ErrorTypes.DexT1__MsgValueLowOnDepositOrPayback);\n            }\n            LIQUIDITY.operate{ value: amt_ }(\n                token_,\n                int(depositAmt_),\n                -int(paybackAmt_),\n                address(0),\n                address(0),\n                new bytes(0)\n            );\n        } else {\n            LIQUIDITY.operate(\n                token_,\n                int(depositAmt_),\n                -int(paybackAmt_),\n                address(0),\n                address(0),\n                abi.encode((depositAmt_ + paybackAmt_), true, msg.sender)\n            );\n        }\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/immutableVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../../../liquidity/interfaces/iLiquidity.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { ConstantVariables } from \"../common/constantVariables.sol\";\nimport { IFluidDexFactory } from \"../../interfaces/iDexFactory.sol\";\nimport { Error } from \"../../error.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\n\nabstract contract ImmutableVariables is ConstantVariables, Structs, Error {\n    /*//////////////////////////////////////////////////////////////\n                          CONSTANTS / IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public immutable DEX_ID;\n\n    /// @dev Address of token 0\n    address internal immutable TOKEN_0;\n\n    /// @dev Address of token 1\n    address internal immutable TOKEN_1;\n\n    address internal immutable THIS_CONTRACT;\n\n    uint256 internal immutable TOKEN_0_NUMERATOR_PRECISION;\n    uint256 internal immutable TOKEN_0_DENOMINATOR_PRECISION;\n    uint256 internal immutable TOKEN_1_NUMERATOR_PRECISION;\n    uint256 internal immutable TOKEN_1_DENOMINATOR_PRECISION;\n\n    /// @dev Address of liquidity contract\n    IFluidLiquidity internal immutable LIQUIDITY;\n\n    /// @dev Address of DEX factory contract\n    IFluidDexFactory internal immutable DEX_FACTORY;\n\n    /// @dev Address of Shift implementation\n    address internal immutable SHIFT_IMPLEMENTATION;\n\n    /// @dev Address of Admin implementation\n    address internal immutable ADMIN_IMPLEMENTATION;\n\n    /// @dev Address of Col Operations implementation\n    address internal immutable COL_OPERATIONS_IMPLEMENTATION;\n\n    /// @dev Address of Debt Operations implementation\n    address internal immutable DEBT_OPERATIONS_IMPLEMENTATION;\n\n    /// @dev Address of Perfect Operations and Swap Out implementation\n    address internal immutable PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION;\n\n    /// @dev Address of contract used for deploying center price & hook related contract\n    address internal immutable DEPLOYER_CONTRACT;\n\n    /// @dev Liquidity layer slots\n    bytes32 internal immutable SUPPLY_TOKEN_0_SLOT;\n    bytes32 internal immutable BORROW_TOKEN_0_SLOT;\n    bytes32 internal immutable SUPPLY_TOKEN_1_SLOT;\n    bytes32 internal immutable BORROW_TOKEN_1_SLOT;\n    bytes32 internal immutable EXCHANGE_PRICE_TOKEN_0_SLOT;\n    bytes32 internal immutable EXCHANGE_PRICE_TOKEN_1_SLOT;\n    uint256 internal immutable TOTAL_ORACLE_MAPPING;\n\n    function _calcNumeratorAndDenominator(\n        address token_\n    ) private view returns (uint256 numerator_, uint256 denominator_) {\n        uint256 decimals_ = _decimals(token_);\n        if (decimals_ > TOKENS_DECIMALS_PRECISION) {\n            numerator_ = 1;\n            denominator_ = 10 ** (decimals_ - TOKENS_DECIMALS_PRECISION);\n        } else {\n            numerator_ = 10 ** (TOKENS_DECIMALS_PRECISION - decimals_);\n            denominator_ = 1;\n        }\n    }\n\n    constructor(ConstantViews memory constants_) {\n        THIS_CONTRACT = address(this);\n\n        DEX_ID = constants_.dexId;\n        LIQUIDITY = IFluidLiquidity(constants_.liquidity);\n        DEX_FACTORY = IFluidDexFactory(constants_.factory);\n\n        TOKEN_0 = constants_.token0;\n        TOKEN_1 = constants_.token1;\n\n        if (TOKEN_0 >= TOKEN_1) revert FluidDexError(ErrorTypes.DexT1__Token0ShouldBeSmallerThanToken1);\n\n        (TOKEN_0_NUMERATOR_PRECISION, TOKEN_0_DENOMINATOR_PRECISION) = _calcNumeratorAndDenominator(TOKEN_0);\n        (TOKEN_1_NUMERATOR_PRECISION, TOKEN_1_DENOMINATOR_PRECISION) = _calcNumeratorAndDenominator(TOKEN_1);\n\n        if (constants_.implementations.shift != address(0)) {\n            SHIFT_IMPLEMENTATION = constants_.implementations.shift;\n        } else {\n            SHIFT_IMPLEMENTATION = address(this);\n        }\n        if (constants_.implementations.admin != address(0)) {\n            ADMIN_IMPLEMENTATION = constants_.implementations.admin;\n        } else {\n            ADMIN_IMPLEMENTATION = address(this);\n        }\n        if (constants_.implementations.colOperations != address(0)) {\n            COL_OPERATIONS_IMPLEMENTATION = constants_.implementations.colOperations;\n        } else {\n            COL_OPERATIONS_IMPLEMENTATION = address(this);\n        }\n        if (constants_.implementations.debtOperations != address(0)) {\n            DEBT_OPERATIONS_IMPLEMENTATION = constants_.implementations.debtOperations;\n        } else {\n            DEBT_OPERATIONS_IMPLEMENTATION = address(this);\n        }\n        if (constants_.implementations.perfectOperationsAndSwapOut != address(0)) {\n            PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION = constants_.implementations.perfectOperationsAndSwapOut;\n        } else {\n            PERFECT_OPERATIONS_AND_SWAP_OUT_IMPLEMENTATION = address(this);\n        }\n\n        DEPLOYER_CONTRACT = constants_.deployerContract;\n\n        SUPPLY_TOKEN_0_SLOT = constants_.supplyToken0Slot;\n        BORROW_TOKEN_0_SLOT = constants_.borrowToken0Slot;\n        SUPPLY_TOKEN_1_SLOT = constants_.supplyToken1Slot;\n        BORROW_TOKEN_1_SLOT = constants_.borrowToken1Slot;\n        EXCHANGE_PRICE_TOKEN_0_SLOT = constants_.exchangePriceToken0Slot;\n        EXCHANGE_PRICE_TOKEN_1_SLOT = constants_.exchangePriceToken1Slot;\n\n        if (constants_.oracleMapping > X16) revert FluidDexError(ErrorTypes.DexT1__OracleMappingOverflow);\n\n        TOTAL_ORACLE_MAPPING = constants_.oracleMapping;\n    }\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/interfaces.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ninterface IHook {\n    /// @notice Hook function to check for liquidation opportunities before external swaps\n    /// @dev The primary use of this hook is to check if a particular pair vault has liquidation available.\n    ///      If liquidation is available, it gives priority to the liquidation process before allowing external swaps.\n    ///      In most cases, this hook will not be set.\n    /// @param id_ Identifier for the operation type: 1 for swap, 2 for internal arbitrage\n    /// @param swap0to1_ Direction of the swap: true if swapping token0 for token1, false otherwise\n    /// @param token0_ Address of the first token in the pair\n    /// @param token1_ Address of the second token in the pair\n    /// @param price_ The price ratio of token1 to token0, expressed with 27 decimal places\n    /// @return isOk_ Boolean indicating whether the operation should proceed\n    function dexPrice(\n        uint id_,\n        bool swap0to1_,\n        address token0_,\n        address token1_,\n        uint price_\n    ) external returns (bool isOk_);\n}\n\ninterface ICenterPrice {\n    /// @notice Retrieves the center price for the pool\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\n    /// @return price The current price ratio of token1 to token0, expressed with 27 decimal places\n    function centerPrice() external returns (uint price);\n}\n"
    },
    "contracts/protocols/dex/poolT1/coreModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct ExchangePrices {\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct CollateralReservesSwap {\n        uint tokenInRealReserves;\n        uint tokenOutRealReserves;\n        uint tokenInImaginaryReserves;\n        uint tokenOutImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReservesSwap {\n        uint tokenInDebt;\n        uint tokenOutDebt;\n        uint tokenInRealReserves;\n        uint tokenOutRealReserves;\n        uint tokenInImaginaryReserves;\n        uint tokenOutImaginaryReserves;\n    }\n\n    struct SwapInMemory {\n        address tokenIn;\n        address tokenOut;\n        uint256 amtInAdjusted;\n        address withdrawTo;\n        address borrowTo;\n        uint price; // price of pool after swap\n        uint fee; // fee of pool\n        uint revenueCut; // revenue cut of pool\n        bool swap0to1;\n        int swapRoutingAmt;\n        bytes data; // just added to avoid stack-too-deep error\n    }\n\n    struct SwapOutMemory {\n        address tokenIn;\n        address tokenOut;\n        uint256 amtOutAdjusted;\n        address withdrawTo;\n        address borrowTo;\n        uint price; // price of pool after swap\n        uint fee;\n        uint revenueCut; // revenue cut of pool\n        bool swap0to1;\n        int swapRoutingAmt;\n        bytes data; // just added to avoid stack-too-deep error\n        uint msgValue;\n    }\n\n    struct DepositColMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0ReservesInitial;\n        uint256 token1ReservesInitial;\n    }\n\n    struct WithdrawColMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0ReservesInitial;\n        uint256 token1ReservesInitial;\n        address to;\n    }\n\n    struct BorrowDebtMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0DebtInitial;\n        uint256 token1DebtInitial;\n        address to;\n    }\n\n    struct PaybackDebtMemory {\n        uint256 token0AmtAdjusted;\n        uint256 token1AmtAdjusted;\n        uint256 token0DebtInitial;\n        uint256 token1DebtInitial;\n    }\n\n    struct OraclePriceMemory {\n        uint lowestPrice1by0;\n        uint highestPrice1by0;\n        uint oracleSlot;\n        uint oracleMap;\n        uint oracle;\n    }\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndSwapOut;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n}\n"
    },
    "contracts/protocols/vault/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Error {\n    error FluidVaultError(uint256 errorId_);\n\n    /// @notice used to simulate liquidation to find the maximum liquidatable amounts\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n}\n"
    },
    "contracts/protocols/vault/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |           Vault Factory           | \n    |__________________________________*/\n\n    uint256 internal constant VaultFactory__InvalidOperation = 30001;\n    uint256 internal constant VaultFactory__Unauthorized = 30002;\n    uint256 internal constant VaultFactory__SameTokenNotAllowed = 30003;\n    uint256 internal constant VaultFactory__InvalidParams = 30004;\n    uint256 internal constant VaultFactory__InvalidVault = 30005;\n    uint256 internal constant VaultFactory__InvalidVaultAddress = 30006;\n    uint256 internal constant VaultFactory__OnlyDelegateCallAllowed = 30007;\n\n    /***********************************|\n    |            Vault                  | \n    |__________________________________*/\n\n    /// @notice thrown at reentrancy\n    uint256 internal constant Vault__AlreadyEntered = 31001;\n\n    /// @notice thrown when user sends deposit & borrow amount as 0\n    uint256 internal constant Vault__InvalidOperateAmount = 31002;\n\n    /// @notice thrown when msg.value is not in sync with native token deposit or payback\n    uint256 internal constant Vault__InvalidMsgValueOperate = 31003;\n\n    /// @notice thrown when msg.sender is not the owner of the vault\n    uint256 internal constant Vault__NotAnOwner = 31004;\n\n    /// @notice thrown when user's position does not exist. Sending the wrong index from the frontend\n    uint256 internal constant Vault__TickIsEmpty = 31005;\n\n    /// @notice thrown when the user's position is above CF and the user tries to make it more risky by trying to withdraw or borrow\n    uint256 internal constant Vault__PositionAboveCF = 31006;\n\n    /// @notice thrown when the top tick is not initialized. Happens if the vault is totally new or all the user's left\n    uint256 internal constant Vault__TopTickDoesNotExist = 31007;\n\n    /// @notice thrown when msg.value in liquidate is not in sync payback\n    uint256 internal constant Vault__InvalidMsgValueLiquidate = 31008;\n\n    /// @notice thrown when slippage is more on liquidation than what the liquidator sent\n    uint256 internal constant Vault__ExcessSlippageLiquidation = 31009;\n\n    /// @notice thrown when msg.sender is not the rebalancer/reserve contract\n    uint256 internal constant Vault__NotRebalancer = 31010;\n\n    /// @notice thrown when NFT of one vault interacts with the NFT of other vault\n    uint256 internal constant Vault__NftNotOfThisVault = 31011;\n\n    /// @notice thrown when the token is not initialized on the liquidity contract\n    uint256 internal constant Vault__TokenNotInitialized = 31012;\n\n    /// @notice thrown when admin updates fallback if a non-auth calls vault\n    uint256 internal constant Vault__NotAnAuth = 31013;\n\n    /// @notice thrown in operate when user tries to witdhraw more collateral than deposited\n    uint256 internal constant Vault__ExcessCollateralWithdrawal = 31014;\n\n    /// @notice thrown in operate when user tries to payback more debt than borrowed\n    uint256 internal constant Vault__ExcessDebtPayback = 31015;\n\n    /// @notice thrown when user try to withdrawal more than operate's withdrawal limit\n    uint256 internal constant Vault__WithdrawMoreThanOperateLimit = 31016;\n\n    /// @notice thrown when caller of liquidityCallback is not Liquidity\n    uint256 internal constant Vault__InvalidLiquidityCallbackAddress = 31017;\n\n    /// @notice thrown when reentrancy is not already on\n    uint256 internal constant Vault__NotEntered = 31018;\n\n    /// @notice thrown when someone directly calls operate or secondary implementation contract\n    uint256 internal constant Vault__OnlyDelegateCallAllowed = 31019;\n\n    /// @notice thrown when the safeTransferFrom for a token amount failed\n    uint256 internal constant Vault__TransferFromFailed = 31020;\n\n    /// @notice thrown when exchange price overflows while updating on storage\n    uint256 internal constant Vault__ExchangePriceOverFlow = 31021;\n\n    /// @notice thrown when debt to liquidate amt is sent wrong\n    uint256 internal constant Vault__InvalidLiquidationAmt = 31022;\n\n    /// @notice thrown when user debt or collateral goes above 2**128 or below -2**128\n    uint256 internal constant Vault__UserCollateralDebtExceed = 31023;\n\n    /// @notice thrown if on liquidation branch debt becomes lower than 100\n    uint256 internal constant Vault__BranchDebtTooLow = 31024;\n\n    /// @notice thrown when tick's debt is less than 10000\n    uint256 internal constant Vault__TickDebtTooLow = 31025;\n\n    /// @notice thrown when the received new liquidity exchange price is of unexpected value (< than the old one)\n    uint256 internal constant Vault__LiquidityExchangePriceUnexpected = 31026;\n\n    /// @notice thrown when user's debt is less than 10000\n    uint256 internal constant Vault__UserDebtTooLow = 31027;\n\n    /// @notice thrown when on only payback and only deposit the ratio of position increases\n    uint256 internal constant Vault__InvalidPaybackOrDeposit = 31028;\n\n    /// @notice thrown when liquidation just happens of a single partial or when there's nothing to liquidate\n    uint256 internal constant Vault__InvalidLiquidation = 31029;\n\n    /// @notice thrown when msg.value is sent wrong in rebalance\n    uint256 internal constant Vault__InvalidMsgValueInRebalance = 31030;\n\n    /// @notice thrown when nothing rebalanced\n    uint256 internal constant Vault__NothingToRebalance = 31031;\n\n    /// @notice thrown on unforseen liquidation scenarios. Might never come in use.\n    uint256 internal constant Vault__LiquidationReverts = 31032;\n\n    /// @notice thrown when oracle price is > 1e54\n    uint256 internal constant Vault__InvalidOraclePrice = 31033;\n\n    /// @notice thrown when constants are not set properly via contructor\n    uint256 internal constant Vault__ImproperConstantsSetup = 31034;\n\n    /// @notice thrown when externally calling fetchLatestPosition function\n    uint256 internal constant Vault__FetchLatestPositionFailed = 31035;\n\n    /// @notice thrown when dex callback is not from dex\n    uint256 internal constant Vault__InvalidDexCallbackAddress = 31036;\n\n    /// @notice thrown when dex callback is already set\n    uint256 internal constant Vault__DexFromAddressAlreadySet = 31037;\n\n    /***********************************|\n    |              ERC721               | \n    |__________________________________*/\n\n    uint256 internal constant ERC721__InvalidParams = 32001;\n    uint256 internal constant ERC721__Unauthorized = 32002;\n    uint256 internal constant ERC721__InvalidOperation = 32003;\n    uint256 internal constant ERC721__UnsafeRecipient = 32004;\n    uint256 internal constant ERC721__OutOfBoundsIndex = 32005;\n\n    /***********************************|\n    |            Vault Admin            | \n    |__________________________________*/\n\n    /// @notice thrown when admin tries to setup invalid value which are crossing limits\n    uint256 internal constant VaultAdmin__ValueAboveLimit = 33001;\n\n    /// @notice when someone directly calls admin implementation contract\n    uint256 internal constant VaultAdmin__OnlyDelegateCallAllowed = 33002;\n\n    /// @notice thrown when auth sends NFT ID as 0 while collecting dust debt\n    uint256 internal constant VaultAdmin__NftIdShouldBeNonZero = 33003;\n\n    /// @notice thrown when trying to collect dust debt of NFT which is not of this vault\n    uint256 internal constant VaultAdmin__NftNotOfThisVault = 33004;\n\n    /// @notice thrown when dust debt of NFT is 0, meaning nothing to collect\n    uint256 internal constant VaultAdmin__DustDebtIsZero = 33005;\n\n    /// @notice thrown when final debt after liquidation is not 0, meaning position 100% liquidated\n    uint256 internal constant VaultAdmin__FinalDebtShouldBeZero = 33006;\n\n    /// @notice thrown when NFT is not liquidated state\n    uint256 internal constant VaultAdmin__NftNotLiquidated = 33007;\n\n    /// @notice thrown when total absorbed dust debt is 0\n    uint256 internal constant VaultAdmin__AbsorbedDustDebtIsZero = 33008;\n\n    /// @notice thrown when address is set as 0\n    uint256 internal constant VaultAdmin__AddressZeroNotAllowed = 33009;\n\n    /***********************************|\n    |            Vault Rewards          | \n    |__________________________________*/\n\n    uint256 internal constant VaultRewards__Unauthorized = 34001;\n    uint256 internal constant VaultRewards__AddressZero = 34002;\n    uint256 internal constant VaultRewards__InvalidParams = 34003;\n    uint256 internal constant VaultRewards__NewMagnifierSameAsOldMagnifier = 34004;\n    uint256 internal constant VaultRewards__NotTheInitiator = 34005;\n    uint256 internal constant VaultRewards__AlreadyStarted = 34006;\n    uint256 internal constant VaultRewards__RewardsNotStartedOrEnded = 34007;\n\n    /***********************************|\n    |          Vault DEX Types          | \n    |__________________________________*/\n\n    uint256 internal constant VaultDex__InvalidOperateAmount = 35001;\n    uint256 internal constant VaultDex__DebtSharesPaidMoreThanAvailableLiquidation = 35002;\n}\n"
    },
    "contracts/protocols/vault/factory/deploymentHelpers/miniDeployer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Owned } from \"solmate/src/auth/Owned.sol\";\n\n/// @title MiniDeployer\n/// @notice A contract that allows deployers to deploy any contract by passing the contract data in bytes\n/// @dev The main objective of this contract is to avoid storing contract addresses in our protocols which requires 160 bits of storage\n///      Instead, we can just store the nonce & deployment of this address to calculate the address realtime using \"AddressCalcs\" library\ncontract MiniDeployer is Owned {\n    /// @notice Thrown when an invalid operation is attempted\n    error MiniDeployer__InvalidOperation();\n\n    /// @notice Emitted when a new contract is deployed\n    event LogContractDeployed(address indexed contractAddress);\n\n    /// @notice Constructor to initialize the contract\n    /// @param owner_ The address of the contract owner\n    constructor(address owner_) Owned(owner_) {}\n\n    /// @notice Internal function to deploy a contract\n    /// @param bytecode_ The bytecode of the contract to deploy\n    /// @return address_ The address of the deployed contract\n    /// @dev Uses inline assembly for efficient deployment\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\n        if (bytecode_.length == 0) {\n            revert MiniDeployer__InvalidOperation();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\n        }\n        if (address_ == address(0)) {\n            revert MiniDeployer__InvalidOperation();\n        }\n    }\n\n    /// @notice Deploys a new contract\n    /// @param contractCode_ The bytecode of the contract to deploy\n    /// @return contractAddress_ The address of the deployed contract\n    /// @dev Decrements the deployer's allowed deployments count if not the owner\n    function deployContract(bytes calldata contractCode_) external onlyOwner returns (address contractAddress_) {\n        contractAddress_ = _deploy(contractCode_);\n\n        emit LogContractDeployed(contractAddress_);\n    }\n}\n"
    },
    "contracts/protocols/vault/factory/deploymentLogics/vaultT2Logic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SSTORE2 } from \"solmate/src/utils/SSTORE2.sol\";\nimport { MiniDeployer } from \"../deploymentHelpers/miniDeployer.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { IFluidVaultFactory } from \"../../interfaces/iVaultFactory.sol\";\nimport { IFluidDexFactory } from \"../../../dex/interfaces/iDexFactory.sol\";\n\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\nimport { DexSlotsLink } from \"../../../../libraries/dexSlotsLink.sol\";\n\nimport { FluidProtocolTypes } from \"../../../../libraries/fluidProtocolTypes.sol\";\n\nimport { IFluidVaultT2 } from \"../../interfaces/iVaultT2.sol\";\nimport { IFluidDexT1 } from \"../../../dex/interfaces/iDexT1.sol\";\n\nimport { IFluidContractFactory } from \"../../../../deployer/interface.sol\";\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ncontract FluidVaultT2DeploymentLogic is Error {\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice address of liquidity contract\n    address public immutable LIQUIDITY;\n\n    address public immutable DEX_FACTORY;\n\n    address public immutable DEPLOYER;\n\n    /// @notice address of MiniDeployer Contract\n    MiniDeployer public immutable MINI_DEPLOYER;\n\n    /// @notice address of Admin implementation\n    address public immutable ADMIN_IMPLEMENTATION;\n\n    /// @notice address of Secondary implementation\n    address public immutable SECONDARY_IMPLEMENTATION;\n\n    address public immutable VAULT_T2_CREATIONCODE_MAIN_OPERATE;\n\n    address public immutable VAULT_T2_CREATIONCODE_MAIN;\n\n    /// @notice address of this contract\n    address public immutable ADDRESS_THIS;\n\n    /// @notice Emitted when a new vaultT2 is deployed.\n    /// @param vault The address of the newly deployed vault.\n    /// @param vaultId The id of the newly deployed vault.\n    /// @param smartCol The address of the dex for which the smart collateral is used.\n    /// @param borrowToken The address of the borrow token.\n    event VaultT2Deployed(\n        address indexed vault,\n        uint256 vaultId,\n        address indexed smartCol,\n        address indexed borrowToken\n    );\n\n    /// @dev each vault type has different vaultAdminImplementation but same vaultSecondaryImplementatio\n    constructor(\n        address liquidity_,\n        address vaultFactory_,\n        address dexFactory_,\n        address deployer_,\n        address vaultAdminImplementation_,\n        address vaultSecondaryImplementation_,\n        address vaultOperateImplementation_,\n        address vaultMainImplementation_\n    ) {\n        LIQUIDITY = liquidity_;\n        DEX_FACTORY = dexFactory_;\n        DEPLOYER = deployer_;\n        ADMIN_IMPLEMENTATION = vaultAdminImplementation_;\n        SECONDARY_IMPLEMENTATION = vaultSecondaryImplementation_;\n\n        // Deploy mini deployer\n        MINI_DEPLOYER = new MiniDeployer(vaultFactory_);\n\n        VAULT_T2_CREATIONCODE_MAIN_OPERATE = vaultOperateImplementation_;\n\n        VAULT_T2_CREATIONCODE_MAIN = vaultMainImplementation_;\n\n        ADDRESS_THIS = address(this);\n    }\n\n    function vaultT2(address smartCol_, address borrowToken_) external returns (bytes memory vaultCreationBytecode_) {\n        if (address(this) == ADDRESS_THIS) revert FluidVaultError(ErrorTypes.VaultFactory__OnlyDelegateCallAllowed);\n\n        // also verifies that dex address is valid\n        IFluidDexT1.ConstantViews memory smartColConstants_ = IFluidDexT1(smartCol_).constantsView();\n\n        // verifying that borrow token is valid\n        if (borrowToken_ != NATIVE_TOKEN) IERC20(borrowToken_).decimals();\n\n        IFluidVaultT2.ConstantViews memory constants_;\n        constants_.liquidity = LIQUIDITY;\n        constants_.factory = address(this);\n        constants_.deployer = DEPLOYER;\n        constants_.adminImplementation = ADMIN_IMPLEMENTATION;\n        constants_.secondaryImplementation = SECONDARY_IMPLEMENTATION;\n        constants_.supply = smartCol_;\n        constants_.supplyToken.token0 = smartColConstants_.token0;\n        constants_.supplyToken.token1 = smartColConstants_.token1;\n        constants_.borrow = LIQUIDITY;\n        constants_.borrowToken.token0 = borrowToken_;\n        // borrowToken.token1 will remain 0\n        constants_.vaultId = IFluidVaultFactory(address(this)).totalVaults();\n        constants_.vaultType = FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE;\n\n        address vault_ = IFluidVaultFactory(address(this)).getVaultAddress(constants_.vaultId);\n\n        constants_ = _calculateLiquidityVaultSlots(constants_, vault_);\n\n        vaultCreationBytecode_ = abi.encodePacked(\n            SSTORE2.read(VAULT_T2_CREATIONCODE_MAIN_OPERATE),\n            abi.encode(constants_)\n        );\n\n        address operateImplementation_ = MINI_DEPLOYER.deployContract(vaultCreationBytecode_);\n\n        constants_.operateImplementation = operateImplementation_;\n\n        vaultCreationBytecode_ = abi.encodePacked(SSTORE2.read(VAULT_T2_CREATIONCODE_MAIN), abi.encode(constants_));\n\n        emit VaultT2Deployed(vault_, constants_.vaultId, smartCol_, borrowToken_);\n\n        return vaultCreationBytecode_;\n    }\n\n    function _calculateLiquidityVaultSlots(\n        IFluidVaultT2.ConstantViews memory constants_,\n        address vault_\n    ) private pure returns (IFluidVaultT2.ConstantViews memory) {\n        constants_.supplyExchangePriceSlot = bytes32(0);\n        constants_.borrowExchangePriceSlot = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            constants_.borrowToken.token0\n        );\n        constants_.userSupplySlot = DexSlotsLink.calculateMappingStorageSlot(\n            DexSlotsLink.DEX_USER_SUPPLY_MAPPING_SLOT,\n            vault_\n        );\n        constants_.userBorrowSlot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n            vault_,\n            constants_.borrowToken.token0\n        );\n        return constants_;\n    }\n}\n"
    },
    "contracts/protocols/vault/factory/deploymentLogics/vaultT3Logic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SSTORE2 } from \"solmate/src/utils/SSTORE2.sol\";\nimport { MiniDeployer } from \"../deploymentHelpers/miniDeployer.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { IFluidVaultFactory } from \"../../interfaces/iVaultFactory.sol\";\nimport { IFluidDexFactory } from \"../../../dex/interfaces/iDexFactory.sol\";\n\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\nimport { DexSlotsLink } from \"../../../../libraries/dexSlotsLink.sol\";\n\nimport { FluidProtocolTypes } from \"../../../../libraries/fluidProtocolTypes.sol\";\n\nimport { IFluidVaultT3 } from \"../../interfaces/iVaultT3.sol\";\nimport { IFluidDexT1 } from \"../../../dex/interfaces/iDexT1.sol\";\n\nimport { IFluidContractFactory } from \"../../../../deployer/interface.sol\";\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ncontract FluidVaultT3DeploymentLogic is Error {\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice address of liquidity contract\n    address public immutable LIQUIDITY;\n\n    address public immutable DEX_FACTORY;\n\n    address public immutable DEPLOYER;\n\n    /// @notice address of MiniDeployer Contract\n    MiniDeployer public immutable MINI_DEPLOYER;\n\n    /// @notice address of Admin implementation\n    address public immutable ADMIN_IMPLEMENTATION;\n\n    /// @notice address of Secondary implementation\n    address public immutable SECONDARY_IMPLEMENTATION;\n\n    address public immutable VAULT_T3_CREATIONCODE_MAIN_OPERATE;\n\n    address public immutable VAULT_T3_CREATIONCODE_MAIN;\n\n    /// @notice address of this contract\n    address public immutable ADDRESS_THIS;\n\n    /// @notice Emitted when a new vaultT3 is deployed.\n    /// @param vault The address of the newly deployed vault.\n    /// @param vaultId The id of the newly deployed vault.\n    /// @param supplyToken The address of the supply token.\n    /// @param smartDebt The address of the dex for which the smart debt is used.\n    event VaultT3Deployed(\n        address indexed vault,\n        uint256 vaultId,\n        address indexed supplyToken,\n        address indexed smartDebt\n    );\n\n    /// @dev each vault type has different vaultAdminImplementation but same vaultSecondaryImplementatio\n    constructor(\n        address liquidity_,\n        address vaultFactory_,\n        address dexFactory_,\n        address deployer_,\n        address vaultAdminImplementation_,\n        address vaultSecondaryImplementation_,\n        address vaultOperateImplementation_,\n        address vaultMainImplementation_\n    ) {\n        LIQUIDITY = liquidity_;\n        DEX_FACTORY = dexFactory_;\n        DEPLOYER = deployer_;\n        ADMIN_IMPLEMENTATION = vaultAdminImplementation_;\n        SECONDARY_IMPLEMENTATION = vaultSecondaryImplementation_;\n\n        // Deploy mini deployer\n        MINI_DEPLOYER = new MiniDeployer(vaultFactory_);\n\n        VAULT_T3_CREATIONCODE_MAIN_OPERATE = vaultOperateImplementation_;\n\n        VAULT_T3_CREATIONCODE_MAIN = vaultMainImplementation_;\n\n        ADDRESS_THIS = address(this);\n    }\n\n    function vaultT3(address supplyToken_, address smartDebt_) external returns (bytes memory vaultCreationBytecode_) {\n        if (address(this) == ADDRESS_THIS) revert FluidVaultError(ErrorTypes.VaultFactory__OnlyDelegateCallAllowed);\n\n        // verifying that supply token is valid\n        if (supplyToken_ != NATIVE_TOKEN) IERC20(supplyToken_).decimals();\n\n        // also verifies that dex address is valid\n        IFluidDexT1.ConstantViews memory smartDebtConstants_ = IFluidDexT1(smartDebt_).constantsView();\n\n        IFluidVaultT3.ConstantViews memory constants_;\n        constants_.liquidity = LIQUIDITY;\n        constants_.factory = address(this);\n        constants_.deployer = DEPLOYER;\n        constants_.adminImplementation = ADMIN_IMPLEMENTATION;\n        constants_.secondaryImplementation = SECONDARY_IMPLEMENTATION;\n        constants_.supply = LIQUIDITY;\n        constants_.supplyToken.token0 = supplyToken_;\n        // supplyToken.token1 will remain 0\n        constants_.borrow = smartDebt_;\n        constants_.borrowToken.token0 = smartDebtConstants_.token0;\n        constants_.borrowToken.token1 = smartDebtConstants_.token1;\n        constants_.vaultId = IFluidVaultFactory(address(this)).totalVaults();\n        constants_.vaultType = FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE;\n\n        address vault_ = IFluidVaultFactory(address(this)).getVaultAddress(constants_.vaultId);\n\n        constants_ = _calculateLiquidityVaultSlots(constants_, vault_);\n\n        vaultCreationBytecode_ = abi.encodePacked(\n            SSTORE2.read(VAULT_T3_CREATIONCODE_MAIN_OPERATE),\n            abi.encode(constants_)\n        );\n\n        address operateImplementation_ = MINI_DEPLOYER.deployContract(vaultCreationBytecode_);\n\n        constants_.operateImplementation = operateImplementation_;\n\n        vaultCreationBytecode_ = abi.encodePacked(SSTORE2.read(VAULT_T3_CREATIONCODE_MAIN), abi.encode(constants_));\n\n        emit VaultT3Deployed(vault_, constants_.vaultId, supplyToken_, smartDebt_);\n\n        return vaultCreationBytecode_;\n    }\n\n    function _calculateLiquidityVaultSlots(\n        IFluidVaultT3.ConstantViews memory constants_,\n        address vault_\n    ) private pure returns (IFluidVaultT3.ConstantViews memory) {\n        constants_.supplyExchangePriceSlot = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            constants_.supplyToken.token0\n        );\n        constants_.borrowExchangePriceSlot = bytes32(0);\n        constants_.userSupplySlot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n            vault_,\n            constants_.supplyToken.token0\n        );\n        constants_.userBorrowSlot = DexSlotsLink.calculateMappingStorageSlot(\n            DexSlotsLink.DEX_USER_BORROW_MAPPING_SLOT,\n            vault_\n        );\n        return constants_;\n    }\n}\n"
    },
    "contracts/protocols/vault/factory/deploymentLogics/vaultT4Logic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SSTORE2 } from \"solmate/src/utils/SSTORE2.sol\";\nimport { MiniDeployer } from \"../deploymentHelpers/miniDeployer.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { IFluidVaultFactory } from \"../../interfaces/iVaultFactory.sol\";\nimport { IFluidDexFactory } from \"../../../dex/interfaces/iDexFactory.sol\";\n\nimport { DexSlotsLink } from \"../../../../libraries/dexSlotsLink.sol\";\n\nimport { FluidProtocolTypes } from \"../../../../libraries/fluidProtocolTypes.sol\";\n\nimport { IFluidVaultT4 } from \"../../interfaces/iVaultT4.sol\";\nimport { IFluidDexT1 } from \"../../../dex/interfaces/iDexT1.sol\";\n\nimport { IFluidContractFactory } from \"../../../../deployer/interface.sol\";\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ncontract FluidVaultT4DeploymentLogic is Error {\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice address of liquidity contract\n    address public immutable LIQUIDITY;\n\n    address public immutable DEX_FACTORY;\n\n    address public immutable DEPLOYER;\n\n    /// @notice address of MiniDeployer Contract\n    MiniDeployer public immutable MINI_DEPLOYER;\n\n    /// @notice address of Admin implementation\n    address public immutable ADMIN_IMPLEMENTATION;\n\n    /// @notice address of Secondary implementation\n    address public immutable SECONDARY_IMPLEMENTATION;\n\n    address public immutable VAULT_T4_CREATIONCODE_MAIN_OPERATE;\n\n    address public immutable VAULT_T4_CREATIONCODE_MAIN;\n\n    /// @notice address of this contract\n    address public immutable ADDRESS_THIS;\n\n    /// @notice Emitted when a new vaultT4 is deployed.\n    /// @param vault The address of the newly deployed vault.\n    /// @param vaultId The id of the newly deployed vault.\n    /// @param smartCol The address of the dex for which the smart collateral is used.\n    /// @param smartDebt The address of the dex for which the smart debt is used.\n    event VaultT4Deployed(address indexed vault, uint256 vaultId, address indexed smartCol, address indexed smartDebt);\n\n    /// @dev each vault type has different vaultAdminImplementation but same vaultSecondaryImplementatio\n    constructor(\n        address liquidity_,\n        address vaultFactory_,\n        address dexFactory_,\n        address deployer_,\n        address vaultAdminImplementation_,\n        address vaultSecondaryImplementation_,\n        address vaultOperateImplementation_,\n        address vaultMainImplementation_\n    ) {\n        LIQUIDITY = liquidity_;\n        DEX_FACTORY = dexFactory_;\n        DEPLOYER = deployer_;\n        ADMIN_IMPLEMENTATION = vaultAdminImplementation_;\n        SECONDARY_IMPLEMENTATION = vaultSecondaryImplementation_;\n\n        // Deploy mini deployer\n        MINI_DEPLOYER = new MiniDeployer(vaultFactory_);\n\n        VAULT_T4_CREATIONCODE_MAIN_OPERATE = vaultOperateImplementation_;\n\n        VAULT_T4_CREATIONCODE_MAIN = vaultMainImplementation_;\n\n        ADDRESS_THIS = address(this);\n    }\n\n    function vaultT4(address smartCol_, address smartDebt_) external returns (bytes memory vaultCreationBytecode_) {\n        if (address(this) == ADDRESS_THIS) revert FluidVaultError(ErrorTypes.VaultFactory__OnlyDelegateCallAllowed);\n\n        // verifying that dex address are valid\n        IFluidDexT1.ConstantViews memory smartColConstants_ = IFluidDexT1(smartCol_).constantsView();\n        IFluidDexT1.ConstantViews memory smartDebtConstants_ = IFluidDexT1(smartDebt_).constantsView();\n\n        IFluidVaultT4.ConstantViews memory constants_;\n        constants_.liquidity = LIQUIDITY;\n        constants_.factory = address(this);\n        constants_.deployer = DEPLOYER;\n        constants_.adminImplementation = ADMIN_IMPLEMENTATION;\n        constants_.secondaryImplementation = SECONDARY_IMPLEMENTATION;\n        constants_.supply = smartCol_;\n        constants_.supplyToken.token0 = smartColConstants_.token0;\n        constants_.supplyToken.token1 = smartColConstants_.token1;\n        constants_.borrow = smartDebt_;\n        constants_.borrowToken.token0 = smartDebtConstants_.token0;\n        constants_.borrowToken.token1 = smartDebtConstants_.token1;\n        constants_.vaultId = IFluidVaultFactory(address(this)).totalVaults();\n        constants_.vaultType = FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE;\n\n        address vault_ = IFluidVaultFactory(address(this)).getVaultAddress(constants_.vaultId);\n\n        constants_ = _calculateLiquidityVaultSlots(constants_, vault_);\n\n        vaultCreationBytecode_ = abi.encodePacked(\n            SSTORE2.read(VAULT_T4_CREATIONCODE_MAIN_OPERATE),\n            abi.encode(constants_)\n        );\n\n        address operateImplementation_ = MINI_DEPLOYER.deployContract(vaultCreationBytecode_);\n\n        constants_.operateImplementation = operateImplementation_;\n\n        vaultCreationBytecode_ = abi.encodePacked(SSTORE2.read(VAULT_T4_CREATIONCODE_MAIN), abi.encode(constants_));\n\n        emit VaultT4Deployed(vault_, constants_.vaultId, smartCol_, smartDebt_);\n\n        return vaultCreationBytecode_;\n    }\n\n    function _calculateLiquidityVaultSlots(\n        IFluidVaultT4.ConstantViews memory constants_,\n        address vault_\n    ) private pure returns (IFluidVaultT4.ConstantViews memory) {\n        constants_.supplyExchangePriceSlot = bytes32(0);\n        constants_.borrowExchangePriceSlot = bytes32(0);\n        constants_.userSupplySlot = DexSlotsLink.calculateMappingStorageSlot(\n            DexSlotsLink.DEX_USER_SUPPLY_MAPPING_SLOT,\n            vault_\n        );\n        constants_.userBorrowSlot = DexSlotsLink.calculateMappingStorageSlot(\n            DexSlotsLink.DEX_USER_BORROW_MAPPING_SLOT,\n            vault_\n        );\n        return constants_;\n    }\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVault.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\ninterface IFluidVault {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice returns the vault id\n    function TYPE() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Tokens {\n        address token0;\n        address token1;\n    }\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address operateImplementation;\n        address adminImplementation;\n        address secondaryImplementation;\n        address deployer; // address which deploys oracle\n        address supply; // either liquidity layer or DEX protocol\n        address borrow; // either liquidity layer or DEX protocol\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\n        uint256 vaultId;\n        uint256 vaultType;\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n\n    function rebalance(\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_\n    ) external returns (int supplyAmt_, int borrowAmt_);\n\n    /// @notice reverts with FluidLiquidateResult\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\ninterface IFluidVaultFactory is IERC721Enumerable {\n    /// @notice Minting an NFT Vault for the user\n    function mint(uint256 vaultId_, address user_) external returns (uint256 tokenId_);\n\n    /// @notice returns owner of Vault which is also an NFT\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /// @notice Global auth is auth for all vaults\n    function isGlobalAuth(address auth_) external view returns (bool);\n\n    /// @notice Vault auth is auth for a specific vault\n    function isVaultAuth(address vault_, address auth_) external view returns (bool);\n\n    /// @notice Total vaults deployed.\n    function totalVaults() external view returns (uint256);\n\n    /// @notice Compute vaultAddress\n    function getVaultAddress(uint256 vaultId) external view returns (address);\n\n    /// @notice read uint256 `result_` for a storage `slot_` key\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT2.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFluidVault } from \"./iVault.sol\";\n\ninterface IFluidVaultT2 is IFluidVault {\n    function operate(\n        uint nftId_,\n        int newColToken0_,\n        int newColToken1_,\n        int colSharesMinMax_,\n        int newDebt_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function operatePerfect(\n        uint nftId_,\n        int perfectColShares_,\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int newDebt_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256[] memory r_\n        );\n\n    function liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint256 actualDebt_, uint256 actualColShares_, uint256 token0Col_, uint256 token1Col_);\n\n    function liquidatePerfect(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint256 actualDebt_, uint256 actualColShares_, uint256 token0Col_, uint256 token1Col_);\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT3.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFluidVault } from \"./iVault.sol\";\n\ninterface IFluidVaultT3 is IFluidVault {\n    function operate(\n        uint nftId_,\n        int newCol_,\n        int newDebtToken0_,\n        int newDebtToken1_,\n        int debtSharesMinMax_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function operatePerfect(\n        uint nftId_,\n        int newCol_,\n        int perfectDebtShares_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256[] memory r_\n        );\n\n    function liquidate(\n        uint256 token0DebtAmt_,\n        uint256 token1DebtAmt_,\n        uint256 debtSharesMin_,\n        uint256 colPerUnitDebt_,\n        address to_,\n        bool absorb_\n    ) external payable returns (uint256 actualDebtShares_, uint256 actualCol_);\n\n    function liquidatePerfect(\n        uint256 debtShares_,\n        uint256 token0DebtAmtPerUnitShares_,\n        uint256 token1DebtAmtPerUnitShares_,\n        uint256 colPerUnitDebt_,\n        address to_,\n        bool absorb_\n    )\n        external\n        payable\n        returns (uint256 actualDebtShares_, uint256 token0Debt_, uint256 token1Debt_, uint256 actualCol_);\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT4.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFluidVault } from \"./iVault.sol\";\n\ninterface IFluidVaultT4 is IFluidVault {\n    function operate(\n        uint nftId_,\n        int newColToken0_,\n        int newColToken1_,\n        int colSharesMinMax_,\n        int newDebtToken0_,\n        int newDebtToken1_,\n        int debtSharesMinMax_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function operatePerfect(\n        uint nftId_,\n        int perfectColShares_,\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int perfectDebtShares_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256[] memory r_\n        );\n\n    function liquidate(\n        uint256 token0DebtAmt_,\n        uint256 token1DebtAmt_,\n        uint256 debtSharesMin_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    )\n        external\n        payable\n        returns (uint256 actualDebtShares_, uint256 actualColShares_, uint256 token0Col_, uint256 token1Col_);\n\n    function liquidatePerfect(\n        uint256 debtShares_,\n        uint256 token0DebtAmtPerUnitShares_,\n        uint256 token1DebtAmtPerUnitShares_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    )\n        external\n        payable\n        returns (\n            uint256 actualDebtShares_,\n            uint256 token0Debt_,\n            uint256 token1Debt_,\n            uint256 actualColShares_,\n            uint256 token0Col_,\n            uint256 token1Col_\n        );\n}\n"
    },
    "solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
    },
    "solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    },
    "solmate/src/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}