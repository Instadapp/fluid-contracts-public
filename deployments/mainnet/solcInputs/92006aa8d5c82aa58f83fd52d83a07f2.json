{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/infiniteProxy/interfaces/iProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IProxy {\n    function setAdmin(address newAdmin_) external;\n\n    function setDummyImplementation(address newDummyImplementation_) external;\n\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\n\n    function removeImplementation(address implementation_) external;\n\n    function getAdmin() external view returns (address);\n\n    function getDummyImplementation() external view returns (address);\n\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\n\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/bigMathMinified.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\nlibrary BigMathMinified {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/bytesSliceAndConcat.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary BytesSliceAndConcat {\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesConcat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    ) internal pure returns (bytes memory tempBytes) {\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesSlice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory tempBytes) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/libraries/dexSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\nlibrary DexSlotsLink {\n    /// @dev storage slot for variables at Dex\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\n    /// @dev storage slot for variables2 at Dex\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\n    /// @dev storage slot for total supply shares at Dex\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\n    /// @dev storage slot for user supply mapping at Dex\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\n    /// @dev storage slot for total borrow shares at Dex\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\n    /// @dev storage slot for user borrow mapping at Dex\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\n    /// @dev storage slot for oracle mapping at Dex\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\n    /// @dev storage slot for range and threshold shifts at Dex\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\n    /// @dev storage slot for center price shift at Dex\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n\n    /***********************************|\n    |           SafeApprove             | \n    |__________________________________*/\n\n    /// @notice thrown when safe approve from for an ERC20 fails\n    uint256 internal constant SafeApprove__ApproveFailed = 81001;\n}\n"
    },
    "contracts/libraries/fluidProtocolTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ninterface IFluidProtocol {\n    function TYPE() external view returns (uint256);\n}\n\n/// @notice implements helper methods to filter Fluid protocols by a certain type\nlibrary FluidProtocolTypes {\n    uint256 internal constant VAULT_T1_TYPE = 10000; // VaultT1 borrow protocol type vaults\n    uint256 internal constant VAULT_T2_SMART_COL_TYPE = 20000; // DEX protocol type vault\n    uint256 internal constant VAULT_T3_SMART_DEBT_TYPE = 30000; // DEX protocol type vault\n    uint256 internal constant VAULT_T4_SMART_COL_SMART_DEBT_TYPE = 40000; // DEX protocol type vault\n\n    /// @dev filters input `addresses_` by protocol `type_`. Input addresses must be actual Fluid protocols, otherwise\n    ///      they would be wrongly assumed to be VaultT1 even if they are not Fluid VaultT1 smart contracts.\n    ///      `type_` must be a listed constant type of this library.\n    ///      Example usage is to filter all vault addresses at the Vault factory by a certain type, e.g. to not include\n    ///      DEX protocol type vaults.\n    function filterBy(address[] memory addresses_, uint256 type_) internal view returns (address[] memory filtered_) {\n        uint256 curType_;\n        uint256 filteredProtocols_ = addresses_.length;\n        for (uint256 i; i < addresses_.length; ) {\n            try IFluidProtocol(addresses_[i]).TYPE() returns (uint256 protocolType_) {\n                curType_ = protocolType_;\n            } catch {\n                curType_ = VAULT_T1_TYPE;\n            }\n\n            if (curType_ != type_) {\n                addresses_[i] = address(0);\n                --filteredProtocols_;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        filtered_ = new address[](filteredProtocols_);\n        uint256 index_;\n        unchecked {\n            for (uint256 i; i < addresses_.length; ) {\n                if (addresses_[i] != address(0)) {\n                    filtered_[index_] = addresses_[i];\n                    ++index_;\n                }\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/liquidityCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\nimport { LiquiditySlotsLink } from \"./liquiditySlotsLink.sol\";\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\n\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\n/// borrow rate, withdrawal / borrow limits, revenue amount.\nlibrary LiquidityCalcs {\n    error FluidLiquidityCalcsError(uint256 errorId_);\n\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\n    event BorrowRateMaxCap();\n\n    /// @dev constants as from Liquidity variables.sol\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X15 = 0x7fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                  CALC EXCHANGE PRICES                  /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\n    function calcExchangePrices(\n        uint256 exchangePricesAndConfig_\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\n        // Extracting exchange prices\n        supplyExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\n            X64;\n        borrowExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\n            X64;\n\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\n        }\n\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\n\n        unchecked {\n            // last timestamp can not be > current timestamp\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\n\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\n                X15;\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // calculate new borrow exchange price.\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\n            borrowExchangePrice_ +=\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\n\n            // FOR SUPPLY EXCHANGE PRICE:\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\n            //\n            // Example:\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\n            // yield is 10 (so half a year must have passed).\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 20%) = 62,5%\n            // supplyRate = (40% * (100% - 10%)) * = 36% * 62,5% = 22.5%\n            // increase in supplyExchangePrice, assuming 100 as previous price.\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\n\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\n\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\n\n            if (temp_ == 1) {\n                // if no raw supply: no exchange price update needed\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\n            if (temp_ & 1 == 1) {\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n                temp_ = temp_ >> 1;\n\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\n                // in the if statement a little above.\n\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\n                // so ratioSupplyYield must come out as 2.5 (250%).\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\n                temp_ =\n                    // utilization * (100% + 100% / supplyRatio)\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\n                    (FOUR_DECIMALS);\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\n            } else {\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n                temp_ = temp_ >> 1;\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\n\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\n                temp_ =\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\n                    (1e27 *\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\n                        (FOUR_DECIMALS + temp_)) /\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\n            }\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\n\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\n            if (borrowRatio_ & 1 == 1) {\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\n\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\n            } else {\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\n            }\n\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\n\n            // 2. calculate supply rate\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\n            // but more suppliers not earning interest.\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\n                temp_ * // ratioSupplyYield\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\n\n            // 3. calculate increase in supply exchange price\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                     CALC REVENUE                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\n    /// and the current balance of the Fluid liquidity contract for the token.\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\n    /// @return revenueAmount_ collectable revenue amount\n    function calcRevenue(\n        uint256 totalAmounts_,\n        uint256 exchangePricesAndConfig_,\n        uint256 liquidityTokenBalance_\n    ) internal view returns (uint256 revenueAmount_) {\n        // @dev no need to super-optimize this method as it is only used by admin\n\n        // calculate the new exchange prices based on earned interest\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\n\n        // total supply = interest free + with interest converted from raw\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\n\n        if (totalSupply_ > 0) {\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\n            // ensure there is no possible case because of rounding etc. where this would revert,\n            // explicitly check if >\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\n            // can only be revenue.\n        } else {\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\n            revenueAmount_ = liquidityTokenBalance_;\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ =\n                block.timestamp -\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ =\n                block.timestamp -\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC RATES                        /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev Calculates new borrow rate from utilization for a token\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\n        // extract rate version: 4 bits (0xF) starting from bit 0\n        uint256 rateVersion_ = (rateData_ & 0xF);\n\n        if (rateVersion_ == 1) {\n            rate_ = calcRateV1(rateData_, utilization_);\n        } else if (rateVersion_ == 2) {\n            rate_ = calcRateV2(rateData_, utilization_);\n        } else {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\n        }\n\n        if (rate_ > X16) {\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\n            // this is unlikely to ever happen if configs stay within expected levels.\n            rate_ = X16;\n            // emit event to more easily become aware\n            emit BorrowRateMaxCap();\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e2 precision\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v1 (one kink) ------------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // else utilization is greater than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\n            x1_ = kink1_;\n            x2_ = FOUR_DECIMALS; // 100%\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e4 precision\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v2 (two kinks) -----------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 156 bits => 100-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink1\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\n            if (utilization_ < kink2_) {\n                // if utilization is less than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                x1_ = kink1_;\n                x2_ = kink2_;\n            } else {\n                // else utilization is greater than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\n                x1_ = kink2_;\n                x2_ = FOUR_DECIMALS;\n            }\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\n    function getTotalSupply(\n        uint256 totalAmounts_,\n        uint256 supplyExchangePrice_\n    ) internal pure returns (uint256 totalSupply_) {\n        // totalSupply_ => supplyInterestFree\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\n    function getTotalBorrow(\n        uint256 totalAmounts_,\n        uint256 borrowExchangePrice_\n    ) internal pure returns (uint256 totalBorrow_) {\n        // totalBorrow_ => borrowInterestFree\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n}\n"
    },
    "contracts/libraries/liquiditySlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\nlibrary LiquiditySlotsLink {\n    /// @dev storage slot for status at Liquidity\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\n    /// @dev storage slot for auths mapping at Liquidity\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\n    /// @dev storage slot for guardians mapping at Liquidity\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\n    /// @dev storage slot for user class mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\n    /// @dev storage slot for rateData mapping at Liquidity\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\n    /// @dev storage slot for totalAmounts mapping at Liquidity\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\n    /// @dev storage slot for user supply double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\n    /// @dev storage slot for user borrow double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // ExchangePricesAndConfig\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\n\n    // RateData:\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\n    // RateData: V1\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\n    // RateData: V2\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\n\n    // TotalAmounts\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\n\n    // Configs2\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/safeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\n\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\nlibrary SafeTransfer {\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 20000; // pass max. 20k gas for native transfers\n\n    error FluidSafeTransferError(uint256 errorId_);\n\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from_\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of `token_` to `to_`.\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of ` native token to `to_`.\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\n    function safeTransferNative(address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n}\n"
    },
    "contracts/libraries/tickMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that calculates number \"tick\" and \"ratioX96\" from this: ratioX96 = (1.0015^tick) * 2^96\n/// @notice this library is used in Fluid Vault protocol for optimiziation.\n/// @dev \"tick\" supports between -32767 and 32767. \"ratioX96\" supports between 37075072 and 169307877264527972847801929085841449095838922544595\nlibrary TickMath {\n    /// The minimum tick that can be passed in getRatioAtTick. 1.0015**-32767\n    int24 internal constant MIN_TICK = -32767;\n    /// The maximum tick that can be passed in getRatioAtTick. 1.0015**32767\n    int24 internal constant MAX_TICK = 32767;\n\n    uint256 internal constant FACTOR00 = 0x100000000000000000000000000000000;\n    uint256 internal constant FACTOR01 = 0xff9dd7de423466c20352b1246ce4856f; // 2^128/1.0015**1 = 339772707859149738855091969477551883631\n    uint256 internal constant FACTOR02 = 0xff3bd55f4488ad277531fa1c725a66d0; // 2^128/1.0015**2 = 339263812140938331358054887146831636176\n    uint256 internal constant FACTOR03 = 0xfe78410fd6498b73cb96a6917f853259; // 2^128/1.0015**4 = 338248306163758188337119769319392490073\n    uint256 internal constant FACTOR04 = 0xfcf2d9987c9be178ad5bfeffaa123273; // 2^128/1.0015**8 = 336226404141693512316971918999264834163\n    uint256 internal constant FACTOR05 = 0xf9ef02c4529258b057769680fc6601b3; // 2^128/1.0015**16 = 332218786018727629051611634067491389875\n    uint256 internal constant FACTOR06 = 0xf402d288133a85a17784a411f7aba082; // 2^128/1.0015**32 = 324346285652234375371948336458280706178\n    uint256 internal constant FACTOR07 = 0xe895615b5beb6386553757b0352bda90; // 2^128/1.0015**64 = 309156521885964218294057947947195947664\n    uint256 internal constant FACTOR08 = 0xd34f17a00ffa00a8309940a15930391a; // 2^128/1.0015**128 = 280877777739312896540849703637713172762 \n    uint256 internal constant FACTOR09 = 0xae6b7961714e20548d88ea5123f9a0ff; // 2^128/1.0015**256 = 231843708922198649176471782639349113087\n    uint256 internal constant FACTOR10 = 0x76d6461f27082d74e0feed3b388c0ca1; // 2^128/1.0015**512 = 157961477267171621126394973980180876449\n    uint256 internal constant FACTOR11 = 0x372a3bfe0745d8b6b19d985d9a8b85bb; // 2^128/1.0015**1024 = 73326833024599564193373530205717235131\n    uint256 internal constant FACTOR12 = 0x0be32cbee48979763cf7247dd7bb539d; // 2^128/1.0015**2048 = 15801066890623697521348224657638773661\n    uint256 internal constant FACTOR13 = 0x8d4f70c9ff4924dac37612d1e2921e;   // 2^128/1.0015**4096 = 733725103481409245883800626999235102\n    uint256 internal constant FACTOR14 = 0x4e009ae5519380809a02ca7aec77;     // 2^128/1.0015**8192 = 1582075887005588088019997442108535\n    uint256 internal constant FACTOR15 = 0x17c45e641b6e95dee056ff10;         // 2^128/1.0015**16384 = 7355550435635883087458926352\n\n    /// The minimum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MIN_TICK). ~ Equivalent to `(1 << 96) * (1.0015**-32767)`\n    uint256 internal constant MIN_RATIOX96 = 37075072;\n    /// The maximum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MAX_TICK).\n    /// ~ Equivalent to `(1 << 96) * (1.0015**32767)`, rounding etc. leading to minor difference\n    uint256 internal constant MAX_RATIOX96 = 169307877264527972847801929085841449095838922544595;\n\n    uint256 internal constant ZERO_TICK_SCALED_RATIO = 0x1000000000000000000000000; // 1 << 96 // 79228162514264337593543950336\n    uint256 internal constant _1E26 = 1e26;\n\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return ratioX96 ratio = (debt amount/collateral amount)\n    function getRatioAtTick(int tick) internal pure returns (uint256 ratioX96) {\n        assembly {\n            let absTick_ := sub(xor(tick, sar(255, tick)), sar(255, tick))\n\n            if gt(absTick_, MAX_TICK) {\n                revert(0, 0)\n            }\n            let factor_ := FACTOR00\n            if and(absTick_, 0x1) {\n                factor_ := FACTOR01\n            }\n            if and(absTick_, 0x2) {\n                factor_ := shr(128, mul(factor_, FACTOR02))\n            }\n            if and(absTick_, 0x4) {\n                factor_ := shr(128, mul(factor_, FACTOR03))\n            }\n            if and(absTick_, 0x8) {\n                factor_ := shr(128, mul(factor_, FACTOR04))\n            }\n            if and(absTick_, 0x10) {\n                factor_ := shr(128, mul(factor_, FACTOR05))\n            }\n            if and(absTick_, 0x20) {\n                factor_ := shr(128, mul(factor_, FACTOR06))\n            }\n            if and(absTick_, 0x40) {\n                factor_ := shr(128, mul(factor_, FACTOR07))\n            }\n            if and(absTick_, 0x80) {\n                factor_ := shr(128, mul(factor_, FACTOR08))\n            }\n            if and(absTick_, 0x100) {\n                factor_ := shr(128, mul(factor_, FACTOR09))\n            }\n            if and(absTick_, 0x200) {\n                factor_ := shr(128, mul(factor_, FACTOR10))\n            }\n            if and(absTick_, 0x400) {\n                factor_ := shr(128, mul(factor_, FACTOR11))\n            }\n            if and(absTick_, 0x800) {\n                factor_ := shr(128, mul(factor_, FACTOR12))\n            }\n            if and(absTick_, 0x1000) {\n                factor_ := shr(128, mul(factor_, FACTOR13))\n            }\n            if and(absTick_, 0x2000) {\n                factor_ := shr(128, mul(factor_, FACTOR14))\n            }\n            if and(absTick_, 0x4000) {\n                factor_ := shr(128, mul(factor_, FACTOR15))\n            }\n\n            let precision_ := 0\n            if iszero(and(tick, 0x8000000000000000000000000000000000000000000000000000000000000000)) {\n                factor_ := div(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, factor_)\n                // we round up in the division so getTickAtRatio of the output price is always consistent\n                if mod(factor_, 0x100000000) {\n                    precision_ := 1\n                }\n            }\n            ratioX96 := add(shr(32, factor_), precision_)\n        }\n    }\n\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\n    /// @dev Throws if ratioX96 > max ratio || ratioX96 < min ratio\n    /// @param ratioX96 The input ratio; ratio = (debt amount/collateral amount)\n    /// @return tick The output tick for the above formula. Returns in round down form. if tick is 123.23 then 123, if tick is -123.23 then returns -124\n    /// @return perfectRatioX96 perfect ratio for the above tick\n    function getTickAtRatio(uint256 ratioX96) internal pure returns (int tick, uint perfectRatioX96) {\n        assembly {\n            if or(gt(ratioX96, MAX_RATIOX96), lt(ratioX96, MIN_RATIOX96)) {\n                revert(0, 0)\n            }\n\n            let cond := lt(ratioX96, ZERO_TICK_SCALED_RATIO)\n            let factor_\n\n            if iszero(cond) {\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\n                factor_ := div(mul(ratioX96, _1E26), ZERO_TICK_SCALED_RATIO)\n            }\n            if cond {\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\n                factor_ := div(mul(ZERO_TICK_SCALED_RATIO, _1E26), ratioX96)\n            }\n\n            // put in https://www.wolframalpha.com/ whole equation: (1.0015^tick) * 2^96 * 10^26 / 79228162514264337593543950336\n\n            // for tick = 16384\n            // ratioX96 = (1.0015^16384) * 2^96 = 3665252098134783297721995888537077351735\n            // 3665252098134783297721995888537077351735 * 10^26 / 79228162514264337593543950336 =\n            // 4626198540796508716348404308345255985.06131964639489434655721\n            if iszero(lt(factor_, 4626198540796508716348404308345255985)) {\n                tick := or(tick, 0x4000)\n                factor_ := div(mul(factor_, _1E26), 4626198540796508716348404308345255985)\n            }\n            // for tick = 8192\n            // ratioX96 = (1.0015^8192) * 2^96 = 17040868196391020479062776466509865\n            // 17040868196391020479062776466509865 * 10^26 / 79228162514264337593543950336 =\n            // 21508599537851153911767490449162.3037648642153898377655505172\n            if iszero(lt(factor_, 21508599537851153911767490449162)) {\n                tick := or(tick, 0x2000)\n                factor_ := div(mul(factor_, _1E26), 21508599537851153911767490449162)\n            }\n            // for tick = 4096\n            // ratioX96 = (1.0015^4096) * 2^96 = 36743933851015821532611831851150\n            // 36743933851015821532611831851150 * 10^26 / 79228162514264337593543950336 =\n            // 46377364670549310883002866648.9777607649742626173648716941385\n            if iszero(lt(factor_, 46377364670549310883002866649)) {\n                tick := or(tick, 0x1000)\n                factor_ := div(mul(factor_, _1E26), 46377364670549310883002866649)\n            }\n            // for tick = 2048\n            // ratioX96 = (1.0015^2048) * 2^96 = 1706210527034005899209104452335\n            // 1706210527034005899209104452335 * 10^26 / 79228162514264337593543950336 =\n            // 2153540449365864845468344760.06357108484096046743300420319322\n            if iszero(lt(factor_, 2153540449365864845468344760)) {\n                tick := or(tick, 0x800)\n                factor_ := div(mul(factor_, _1E26), 2153540449365864845468344760)\n            }\n            // for tick = 1024\n            // ratioX96 = (1.0015^1024) * 2^96 = 367668226692760093024536487236\n            // 367668226692760093024536487236 * 10^26 / 79228162514264337593543950336 =\n            // 464062544207767844008185024.950588990554136265212906454481127\n            if iszero(lt(factor_, 464062544207767844008185025)) {\n                tick := or(tick, 0x400)\n                factor_ := div(mul(factor_, _1E26), 464062544207767844008185025)\n            }\n            // for tick = 512\n            // ratioX96 = (1.0015^512) * 2^96 = 170674186729409605620119663668\n            // 170674186729409605620119663668 * 10^26 / 79228162514264337593543950336 =\n            // 215421109505955298802281577.031879604792139232258508172947569\n            if iszero(lt(factor_, 215421109505955298802281577)) {\n                tick := or(tick, 0x200)\n                factor_ := div(mul(factor_, _1E26), 215421109505955298802281577)\n            }\n            // for tick = 256\n            // ratioX96 = (1.0015^256) * 2^96 = 116285004205991934861656513301\n            // 116285004205991934861656513301 * 10^26 / 79228162514264337593543950336 =\n            // 146772309890508740607270614.667650899656438875541505058062410\n            if iszero(lt(factor_, 146772309890508740607270615)) {\n                tick := or(tick, 0x100)\n                factor_ := div(mul(factor_, _1E26), 146772309890508740607270615)\n            }\n            // for tick = 128\n            // ratioX96 = (1.0015^128) * 2^96 = 95984619659632141743747099590\n            // 95984619659632141743747099590 * 10^26 / 79228162514264337593543950336 =\n            // 121149622323187099817270416.157248837742741760456796835775887\n            if iszero(lt(factor_, 121149622323187099817270416)) {\n                tick := or(tick, 0x80)\n                factor_ := div(mul(factor_, _1E26), 121149622323187099817270416)\n            }\n            // for tick = 64\n            // ratioX96 = (1.0015^64) * 2^96 = 87204845308406958006717891124\n            // 87204845308406958006717891124 * 10^26 / 79228162514264337593543950336 =\n            // 110067989135437147685980801.568068573422377364214113968609839\n            if iszero(lt(factor_, 110067989135437147685980801)) {\n                tick := or(tick, 0x40)\n                factor_ := div(mul(factor_, _1E26), 110067989135437147685980801)\n            }\n            // for tick = 32\n            // ratioX96 = (1.0015^32) * 2^96 = 83120873769022354029916374475\n            // 83120873769022354029916374475 * 10^26 / 79228162514264337593543950336 =\n            // 104913292358707887270979599.831816586773651266562785765558183\n            if iszero(lt(factor_, 104913292358707887270979600)) {\n                tick := or(tick, 0x20)\n                factor_ := div(mul(factor_, _1E26), 104913292358707887270979600)\n            }\n            // for tick = 16\n            // ratioX96 = (1.0015^16) * 2^96 = 81151180492336368327184716176\n            // 81151180492336368327184716176 * 10^26 / 79228162514264337593543950336 =\n            // 102427189924701091191840927.762844039579442328381455567932128\n            if iszero(lt(factor_, 102427189924701091191840928)) {\n                tick := or(tick, 0x10)\n                factor_ := div(mul(factor_, _1E26), 102427189924701091191840928)\n            }\n            // for tick = 8\n            // ratioX96 = (1.0015^8) * 2^96 = 80183906840906820640659903620\n            // 80183906840906820640659903620 * 10^26 / 79228162514264337593543950336 =\n            // 101206318935480056907421312.890625\n            if iszero(lt(factor_, 101206318935480056907421313)) {\n                tick := or(tick, 0x8)\n                factor_ := div(mul(factor_, _1E26), 101206318935480056907421313)\n            }\n            // for tick = 4\n            // ratioX96 = (1.0015^4) * 2^96 = 79704602139525152702959747603\n            // 79704602139525152702959747603 * 10^26 / 79228162514264337593543950336 =\n            // 100601351350506250000000000\n            if iszero(lt(factor_, 100601351350506250000000000)) {\n                tick := or(tick, 0x4)\n                factor_ := div(mul(factor_, _1E26), 100601351350506250000000000)\n            }\n            // for tick = 2\n            // ratioX96 = (1.0015^2) * 2^96 = 79466025265172787701084167660\n            // 79466025265172787701084167660 * 10^26 / 79228162514264337593543950336 =\n            // 100300225000000000000000000\n            if iszero(lt(factor_, 100300225000000000000000000)) {\n                tick := or(tick, 0x2)\n                factor_ := div(mul(factor_, _1E26), 100300225000000000000000000)\n            }\n            // for tick = 1\n            // ratioX96 = (1.0015^1) * 2^96 = 79347004758035734099934266261\n            // 79347004758035734099934266261 * 10^26 / 79228162514264337593543950336 =\n            // 100150000000000000000000000\n            if iszero(lt(factor_, 100150000000000000000000000)) {\n                tick := or(tick, 0x1)\n                factor_ := div(mul(factor_, _1E26), 100150000000000000000000000)\n            }\n            if iszero(cond) {\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\n                perfectRatioX96 := div(mul(ratioX96, _1E26), factor_)\n            }\n            if cond {\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\n                tick := not(tick)\n                perfectRatioX96 := div(mul(ratioX96, factor_), 100150000000000000000000000)\n            }\n            // perfect ratio should always be <= ratioX96\n            // not sure if it can ever be bigger but better to have extra checks\n            if gt(perfectRatioX96, ratioX96) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "contracts/liquidity/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    /// @notice struct to set borrow rate data for version 1\n    struct RateDataV1Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\n        uint256 kink;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink;\n        ///\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set borrow rate data for version 2\n    struct RateDataV2Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\n        uint256 kink1;\n        ///\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\n        uint256 kink2;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink1;\n        ///\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\n        uint256 rateAtUtilizationKink2;\n        ///\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set token config\n    struct TokenConfig {\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\n        uint256 fee;\n        ///\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\n        uint256 threshold;\n        ///\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\n        uint256 maxUtilization;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/liquidity/common/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Variables } from \"./variables.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\n\n/// @dev ReentrancyGuard based on OpenZeppelin implementation.\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.8/contracts/security/ReentrancyGuard.sol\nabstract contract ReentrancyGuard is Variables, Error {\n    uint8 internal constant REENTRANCY_NOT_ENTERED = 1;\n    uint8 internal constant REENTRANCY_ENTERED = 2;\n\n    constructor() {\n        // on logic contracts, switch reentrancy to entered so no call is possible (forces delegatecall)\n        _status = REENTRANCY_ENTERED; \n    }\n\n    /// @dev Prevents a contract from calling itself, directly or indirectly.\n    /// See OpenZeppelin implementation for more info\n    modifier reentrancy() {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == REENTRANCY_ENTERED) {\n            revert FluidLiquidityError(ErrorTypes.LiquidityHelpers__Reentrancy);\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = REENTRANCY_ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = REENTRANCY_NOT_ENTERED;\n    }\n}\n\nabstract contract CommonHelpers is ReentrancyGuard {\n    /// @dev Returns the current admin (governance).\n    function _getGovernanceAddr() internal view returns (address governance_) {\n        assembly {\n            governance_ := sload(GOVERNANCE_SLOT)\n        }\n    }\n}\n"
    },
    "contracts/liquidity/common/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract ConstantVariables {\n    /// @dev Storage slot with the admin of the contract. Logic from \"proxy.sol\".\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is validated in the constructor.\n    bytes32 internal constant GOVERNANCE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev address that is mapped to the chain native token\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    /// @dev decimals for native token\n    // !! Double check compatibility with all code if this ever changes for a deployment !!\n    uint8 internal constant NATIVE_TOKEN_DECIMALS = 18;\n\n    /// @dev Minimum token decimals for any token that can be listed at Liquidity (inclusive)\n    uint8 internal constant MIN_TOKEN_DECIMALS = 6;\n    /// @dev Maximum token decimals for any token that can be listed at Liquidity (inclusive)\n    uint8 internal constant MAX_TOKEN_DECIMALS = 18;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /// @dev limit any total amount to be half of type(uint128).max (~3.4e38) at type(int128).max (~1.7e38) as safety\n    /// measure for any potential overflows / unexpected outcomes. This is checked for total borrow / supply.\n    uint256 internal constant MAX_TOKEN_AMOUNT_CAP = uint256(uint128(type(int128).max));\n\n    /// @dev limit for triggering a revert if sent along excess input amount diff is bigger than this percentage (in 1e2)\n    uint256 internal constant MAX_INPUT_AMOUNT_EXCESS = 100; // 1%\n\n    /// @dev if this bytes32 is set in the calldata, then token transfers are skipped as long as Liquidity layer is on the winning side.\n    bytes32 internal constant SKIP_TRANSFERS = keccak256(bytes(\"SKIP_TRANSFERS\"));\n\n    /// @dev time after which a write to storage of exchangePricesAndConfig will happen always.\n    uint256 internal constant FORCE_STORAGE_WRITE_AFTER_TIME = 1 days;\n\n    /// @dev constants used for BigMath conversion from and to storage\n    uint256 internal constant SMALL_COEFFICIENT_SIZE = 10;\n    uint256 internal constant DEFAULT_COEFFICIENT_SIZE = 56;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    /// @dev constants to increase readability for using bit masks\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\n    uint256 internal constant X8 = 0xff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X15 = 0x7fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n}\n\ncontract Variables is ConstantVariables {\n    /// @dev address of contract that gets sent the revenue. Configurable by governance\n    address internal _revenueCollector;\n\n    // 12 bytes empty\n\n    // ----- storage slot 1 ------\n\n    /// @dev paused status: status = 1 -> normal. status = 2 -> paused.\n    /// not tightly packed with revenueCollector address to allow for potential changes later that improve gas more\n    /// (revenueCollector is only rarely used by admin methods, where optimization is not as important).\n    /// to be replaced with transient storage once EIP-1153 Transient storage becomes available with dencun upgrade.\n    uint256 internal _status;\n\n    // ----- storage slot 2 ------\n\n    /// @dev Auths can set most config values. E.g. contracts that automate certain flows like e.g. adding a new fToken.\n    /// Governance can add/remove auths.\n    /// Governance is auth by default\n    mapping(address => uint256) internal _isAuth;\n\n    // ----- storage slot 3 ------\n\n    /// @dev Guardians can pause lower class users\n    /// Governance can add/remove guardians\n    /// Governance is guardian by default\n    mapping(address => uint256) internal _isGuardian;\n\n    // ----- storage slot 4 ------\n\n    /// @dev class defines which protocols can be paused by guardians\n    /// Currently there are 2 classes: 0 can be paused by guardians. 1 cannot be paused by guardians.\n    /// New protocols are added as class 0 and will be upgraded to 1 over time.\n    mapping(address => uint256) internal _userClass;\n\n    // ----- storage slot 5 ------\n\n    /// @dev exchange prices and token config per token: token -> exchange prices & config\n    /// First 16 bits =>   0- 15 => borrow rate (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next  14 bits =>  16- 29 => fee on interest from borrowers to lenders (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n    /// Next  14 bits =>  30- 43 => last stored utilization (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    /// Next  14 bits =>  44- 57 => update on storage threshold (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n    /// Next  33 bits =>  58- 90 => last update timestamp (enough until 16 March 2242 -> max value 8589934591)\n    /// Next  64 bits =>  91-154 => supply exchange price (1e12 -> max value 18_446_744,073709551615)\n    /// Next  64 bits => 155-218 => borrow exchange price (1e12 -> max value 18_446_744,073709551615)\n    /// Next   1 bit  => 219-219 => if 0 then ratio is supplyInterestFree / supplyWithInterest else ratio is supplyWithInterest / supplyInterestFree\n    /// Next  14 bits => 220-233 => supplyRatio: supplyInterestFree / supplyWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    /// Next   1 bit  => 234-234 => if 0 then ratio is borrowInterestFree / borrowWithInterest else ratio is borrowWithInterest / borrowInterestFree\n    /// Next  14 bits => 235-248 => borrowRatio: borrowInterestFree / borrowWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    /// Next   1 bit  => 249-249 => flag for token uses config storage slot 2. (signals SLOAD for additional config slot is needed during execution)\n    /// Last   6 bits => 250-255 => empty for future use\n    ///                             if more free bits are needed in the future, update on storage threshold bits could be reduced to 7 bits\n    ///                             (can plan to add `MAX_TOKEN_CONFIG_UPDATE_THRESHOLD` but need to adjust more bits)\n    ///                             if more bits absolutely needed then we can convert fee, utilization, update on storage threshold,\n    ///                             supplyRatio & borrowRatio from 14 bits to 10bits (1023 max number) where 1000 = 100% & 1 = 0.1%\n    mapping(address => uint256) internal _exchangePricesAndConfig;\n\n    // ----- storage slot 6 ------\n\n    /// @dev Rate related data per token: token -> rate data\n    /// READ (SLOAD): all actions; WRITE (SSTORE): only on set config admin actions\n    /// token => rate related data\n    /// First 4 bits  =>     0-3 => rate version\n    /// rest of the bits are rate dependent:\n\n    /// For rate v1 (one kink) ------------------------------------------------------\n    /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Last 188 bits =>  68-255 => empty for future use\n\n    /// For rate v2 (two kinks) -----------------------------------------------------\n    /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Last 156 bits => 100-255 => empty for future use\n    mapping(address => uint256) internal _rateData;\n\n    // ----- storage slot 7 ------\n\n    /// @dev total supply / borrow amounts for with / without interest per token: token -> amounts\n    /// First  64 bits =>   0- 63 => total supply with interest in raw (totalSupply = totalSupplyRaw * supplyExchangePrice); BigMath: 56 | 8\n    /// Next   64 bits =>  64-127 => total interest free supply in normal token amount (totalSupply = totalSupply); BigMath: 56 | 8\n    /// Next   64 bits => 128-191 => total borrow with interest in raw (totalBorrow = totalBorrowRaw * borrowExchangePrice); BigMath: 56 | 8\n    /// Next   64 bits => 192-255 => total interest free borrow in normal token amount (totalBorrow = totalBorrow); BigMath: 56 | 8\n    mapping(address => uint256) internal _totalAmounts;\n\n    // ----- storage slot 8 ------\n\n    /// @dev user supply data per token: user -> token -> data\n    /// First  1 bit  =>       0 => mode: user supply with or without interest\n    ///                             0 = without, amounts are in normal (i.e. no need to multiply with exchange price)\n    ///                             1 = with interest, amounts are in raw (i.e. must multiply with exchange price to get actual token amounts)\n    /// Next  64 bits =>   1- 64 => user supply amount (normal or raw depends on 1st bit); BigMath: 56 | 8\n    /// Next  64 bits =>  65-128 => previous user withdrawal limit (normal or raw depends on 1st bit); BigMath: 56 | 8\n    /// Next  33 bits => 129-161 => last triggered process timestamp (enough until 16 March 2242 -> max value 8589934591)\n    /// Next  14 bits => 162-175 => expand withdrawal limit percentage (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383).\n    ///                             @dev shrinking is instant\n    /// Next  24 bits => 176-199 => withdrawal limit expand duration in seconds.(Max value 16_777_215; ~4_660 hours, ~194 days)\n    /// Next  18 bits => 200-217 => base withdrawal limit: below this, 100% withdrawals can be done (normal or raw depends on 1st bit); BigMath: 10 | 8\n    /// Next  37 bits => 218-254 => empty for future use\n    /// Last     bit  => 255-255 => is user paused (1 = paused, 0 = not paused)\n    mapping(address => mapping(address => uint256)) internal _userSupplyData;\n\n    // ----- storage slot 9 ------\n\n    /// @dev user borrow data per token: user -> token -> data\n    /// First  1 bit  =>       0 => mode: user borrow with or without interest\n    ///                             0 = without, amounts are in normal (i.e. no need to multiply with exchange price)\n    ///                             1 = with interest, amounts are in raw (i.e. must multiply with exchange price to get actual token amounts)\n    /// Next  64 bits =>   1- 64 => user borrow amount (normal or raw depends on 1st bit); BigMath: 56 | 8\n    /// Next  64 bits =>  65-128 => previous user debt ceiling (normal or raw depends on 1st bit); BigMath: 56 | 8\n    /// Next  33 bits => 129-161 => last triggered process timestamp (enough until 16 March 2242 -> max value 8589934591)\n    /// Next  14 bits => 162-175 => expand debt ceiling percentage (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    ///                             @dev shrinking is instant\n    /// Next  24 bits => 176-199 => debt ceiling expand duration in seconds (Max value 16_777_215; ~4_660 hours, ~194 days)\n    /// Next  18 bits => 200-217 => base debt ceiling: below this, there's no debt ceiling limits (normal or raw depends on 1st bit); BigMath: 10 | 8\n    /// Next  18 bits => 218-235 => max debt ceiling: absolute maximum debt ceiling can expand to (normal or raw depends on 1st bit); BigMath: 10 | 8\n    /// Next  19 bits => 236-254 => empty for future use\n    /// Last     bit  => 255-255 => is user paused (1 = paused, 0 = not paused)\n    mapping(address => mapping(address => uint256)) internal _userBorrowData;\n\n    // ----- storage slot 10 ------\n\n    /// @dev list of allowed tokens at Liquidity. tokens that are once configured can never be completely removed. so this\n    ///      array is append-only.\n    address[] internal _listedTokens;\n\n    // ----- storage slot 11 ------\n\n    /// @dev expanded token configs per token: token -> config data slot 2.\n    ///      Use of this is signaled by `_exchangePricesAndConfig` bit 249.\n    /// First 14 bits =>   0- 13 => max allowed utilization (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n    /// Last 242 bits =>  14-255 => empty for future use\n    mapping(address => uint256) internal _configs2;\n}\n"
    },
    "contracts/liquidity/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Error {\n    error FluidLiquidityError(uint256 errorId_);\n}\n"
    },
    "contracts/liquidity/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |         Admin Module              | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant AdminModule__AddressZero = 10001;\n\n    /// @notice thrown when msg.sender is not governance\n    uint256 internal constant AdminModule__OnlyGovernance = 10002;\n\n    /// @notice thrown when msg.sender is not auth\n    uint256 internal constant AdminModule__OnlyAuths = 10003;\n\n    /// @notice thrown when msg.sender is not guardian\n    uint256 internal constant AdminModule__OnlyGuardians = 10004;\n\n    /// @notice thrown when base withdrawal limit, base debt limit or max withdrawal limit is sent as 0\n    uint256 internal constant AdminModule__LimitZero = 10005;\n\n    /// @notice thrown whenever an invalid input param is given\n    uint256 internal constant AdminModule__InvalidParams = 10006;\n\n    /// @notice thrown if user class 1 is paused (can not be paused)\n    uint256 internal constant AdminModule__UserNotPausable = 10007;\n\n    /// @notice thrown if user is tried to be unpaused but is not paused in the first place\n    uint256 internal constant AdminModule__UserNotPaused = 10008;\n\n    /// @notice thrown if user is not defined yet: Governance didn't yet set any config for this user on a particular token\n    uint256 internal constant AdminModule__UserNotDefined = 10009;\n\n    /// @notice thrown if a token is configured in an invalid order:  1. Set rate config for token 2. Set token config 3. allow any user.\n    uint256 internal constant AdminModule__InvalidConfigOrder = 10010;\n\n    /// @notice thrown if revenue is collected when revenue collector address is not set\n    uint256 internal constant AdminModule__RevenueCollectorNotSet = 10011;\n\n    /// @notice all ValueOverflow errors below are thrown if a certain input param overflows the allowed storage size\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_ZERO = 10012;\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_KINK = 10013;\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_MAX = 10014;\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_KINK1 = 10015;\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_KINK2 = 10016;\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_MAX_V2 = 10017;\n    uint256 internal constant AdminModule__ValueOverflow__FEE = 10018;\n    uint256 internal constant AdminModule__ValueOverflow__THRESHOLD = 10019;\n    uint256 internal constant AdminModule__ValueOverflow__EXPAND_PERCENT = 10020;\n    uint256 internal constant AdminModule__ValueOverflow__EXPAND_DURATION = 10021;\n    uint256 internal constant AdminModule__ValueOverflow__EXPAND_PERCENT_BORROW = 10022;\n    uint256 internal constant AdminModule__ValueOverflow__EXPAND_DURATION_BORROW = 10023;\n    uint256 internal constant AdminModule__ValueOverflow__EXCHANGE_PRICES = 10024;\n    uint256 internal constant AdminModule__ValueOverflow__UTILIZATION = 10025;\n\n    /// @notice thrown when an address is not a contract\n    uint256 internal constant AdminModule__AddressNotAContract = 10026;\n\n    uint256 internal constant AdminModule__ValueOverflow__MAX_UTILIZATION = 10027;\n\n    /// @notice thrown if a token that is being listed has not between 6 and 18 decimals\n    uint256 internal constant AdminModule__TokenInvalidDecimalsRange = 10028;\n\n    /***********************************|\n    |          User Module              | \n    |__________________________________*/\n\n    /// @notice thrown when user operations are paused for an interacted token\n    uint256 internal constant UserModule__UserNotDefined = 11001;\n\n    /// @notice thrown when user operations are paused for an interacted token\n    uint256 internal constant UserModule__UserPaused = 11002;\n\n    /// @notice thrown when user's try to withdraw below withdrawal limit\n    uint256 internal constant UserModule__WithdrawalLimitReached = 11003;\n\n    /// @notice thrown when user's try to borrow above borrow limit\n    uint256 internal constant UserModule__BorrowLimitReached = 11004;\n\n    /// @notice thrown when user sent supply/withdraw and borrow/payback both as 0\n    uint256 internal constant UserModule__OperateAmountsZero = 11005;\n\n    /// @notice thrown when user sent supply/withdraw or borrow/payback both as bigger than 2**128\n    uint256 internal constant UserModule__OperateAmountOutOfBounds = 11006;\n\n    /// @notice thrown when the operate amount for supply / withdraw / borrow / payback is below the minimum amount\n    /// that would cause a storage difference after BigMath & rounding imprecision. Extremely unlikely to ever happen\n    /// for all normal use-cases.\n    uint256 internal constant UserModule__OperateAmountInsufficient = 11007;\n\n    /// @notice thrown when withdraw or borrow is executed but withdrawTo or borrowTo is the zero address\n    uint256 internal constant UserModule__ReceiverNotDefined = 11008;\n\n    /// @notice thrown when user did send excess or insufficient amount (beyond rounding issues)\n    uint256 internal constant UserModule__TransferAmountOutOfBounds = 11009;\n\n    /// @notice thrown when user sent msg.value along for an operation not for the native token\n    uint256 internal constant UserModule__MsgValueForNonNativeToken = 11010;\n\n    /// @notice thrown when a borrow operation is done when utilization is above 100%\n    uint256 internal constant UserModule__MaxUtilizationReached = 11011;\n\n    /// @notice all ValueOverflow errors below are thrown if a certain input param or calc result overflows the allowed storage size\n    uint256 internal constant UserModule__ValueOverflow__EXCHANGE_PRICES = 11012;\n    uint256 internal constant UserModule__ValueOverflow__UTILIZATION = 11013;\n    uint256 internal constant UserModule__ValueOverflow__TOTAL_SUPPLY = 11014;\n    uint256 internal constant UserModule__ValueOverflow__TOTAL_BORROW = 11015;\n\n    /// @notice thrown when SKIP_TRANSFERS is set but the input params are invalid for skipping transfers\n    uint256 internal constant UserModule__SkipTransfersInvalid = 11016;\n\n    /***********************************|\n    |         LiquidityHelpers          | \n    |__________________________________*/\n\n    /// @notice thrown when a reentrancy happens\n    uint256 internal constant LiquidityHelpers__Reentrancy = 12001;\n}\n"
    },
    "contracts/liquidity/interfaces/iLiquidity.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IProxy } from \"../../infiniteProxy/interfaces/iProxy.sol\";\nimport { Structs as AdminModuleStructs } from \"../adminModule/structs.sol\";\n\ninterface IFluidLiquidityAdmin {\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\n    /// @param authsStatus_ array of structs setting allowed status for an address.\n    ///                     status true => add auth, false => remove auth\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\n\n    /// @notice adds/removes guardians. Only callable by Governance.\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\n    ///                         status true => add guardian, false => remove guardian\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\n\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\n    /// @param revenueCollector_  new revenue collector address\n    function updateRevenueCollector(address revenueCollector_) external;\n\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\n    /// @param newStatus_ new status\n    ///        status = 2 -> pause, status = 1 -> resume.\n    function changeStatus(uint256 newStatus_) external;\n\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\n\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\n\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\n    ///         Only callable by Auths.\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\n\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\n    ///         Only callable by Auths.\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\n\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param token_ token address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\n\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\n\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to pause operations for\n    /// @param supplyTokens_  token addresses to pause withdrawals for\n    /// @param borrowTokens_  token addresses to pause borrowings for\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to unpause operations for\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\n    /// @param borrowTokens_  token addresses to unpause borrowings for\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\n    /// @param tokens_  array of tokens to collect revenue for\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\n    function collectRevenue(address[] calldata tokens_) external;\n\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\n    /// @param tokens_ tokens to update exchange prices for\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\n    function updateExchangePrices(\n        address[] calldata tokens_\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\n}\n\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\n    /// @notice Single function which handles supply, withdraw, borrow & payback\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\n    /// @param withdrawTo_ if withdrawal then to which address\n    /// @param borrowTo_ if borrow then to which address\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\n    /// @return memVar3_ updated supplyExchangePrice\n    /// @return memVar4_ updated borrowExchangePrice\n    /// @dev to trigger skipping in / out transfers (gas optimization):\n    /// -  ` callbackData_` MUST be encoded so that \"from\" address is the last 20 bytes in the last 32 bytes slot,\n    ///     also for native token operations where liquidityCallback is not triggered!\n    ///     from address must come at last position if there is more data. I.e. encode like:\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\n    /// -   this \"from\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\n    ///     in the slot before (bytes 32 to 63)\n    /// -   `msg.value` must be 0.\n    /// -   Amounts must be either:\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\n}\n\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\n"
    },
    "contracts/liquidity/userModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Events {\n    /// @notice emitted on any `operate()` execution: deposit / supply / withdraw / borrow.\n    /// includes info related to the executed operation, new total amounts (packed uint256 of BigMath numbers as in storage)\n    /// and exchange prices (packed uint256 as in storage).\n    /// @param user protocol that triggered this operation (e.g. via an fToken or via Vault protocol)\n    /// @param token token address for which this operation was executed\n    /// @param supplyAmount supply amount for the operation. if >0 then a deposit happened, if <0 then a withdrawal happened.\n    ///                     if 0 then nothing.\n    /// @param borrowAmount borrow amount for the operation. if >0 then a borrow happened, if <0 then a payback happened.\n    ///                     if 0 then nothing.\n    /// @param withdrawTo   address that funds where withdrawn to (if supplyAmount <0)\n    /// @param borrowTo     address that funds where borrowed to (if borrowAmount >0)\n    /// @param totalAmounts updated total amounts, stacked uint256 as written to storage:\n    /// First  64 bits =>   0- 63 => total supply with interest in raw (totalSupply = totalSupplyRaw * supplyExchangePrice); BigMath: 56 | 8\n    /// Next   64 bits =>  64-127 => total interest free supply in normal token amount (totalSupply = totalSupply); BigMath: 56 | 8\n    /// Next   64 bits => 128-191 => total borrow with interest in raw (totalBorrow = totalBorrowRaw * borrowExchangePrice); BigMath: 56 | 8\n    /// Next   64 bits => 192-255 => total interest free borrow in normal token amount (totalBorrow = totalBorrow); BigMath: 56 | 8\n    /// @param exchangePricesAndConfig updated exchange prices and configs storage slot. Contains updated supply & borrow exchange price:\n    /// First 16 bits =>   0- 15 => borrow rate (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next  14 bits =>  16- 29 => fee on interest from borrowers to lenders (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n    /// Next  14 bits =>  30- 43 => last stored utilization (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    /// Next  14 bits =>  44- 57 => update on storage threshold (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n    /// Next  33 bits =>  58- 90 => last update timestamp (enough until 16 March 2242 -> max value 8589934591)\n    /// Next  64 bits =>  91-154 => supply exchange price (1e12 -> max value 18_446_744,073709551615)\n    /// Next  64 bits => 155-218 => borrow exchange price (1e12 -> max value 18_446_744,073709551615)\n    /// Next   1 bit  => 219-219 => if 0 then ratio is supplyInterestFree / supplyWithInterest else ratio is supplyWithInterest / supplyInterestFree\n    /// Next  14 bits => 220-233 => supplyRatio: supplyInterestFree / supplyWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    /// Next   1 bit  => 234-234 => if 0 then ratio is borrowInterestFree / borrowWithInterest else ratio is borrowWithInterest / borrowInterestFree\n    /// Next  14 bits => 235-248 => borrowRatio: borrowInterestFree / borrowWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    event LogOperate(\n        address indexed user,\n        address indexed token,\n        int256 supplyAmount,\n        int256 borrowAmount,\n        address withdrawTo,\n        address borrowTo,\n        uint256 totalAmounts,\n        uint256 exchangePricesAndConfig\n    );\n}\n"
    },
    "contracts/liquidity/userModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { LiquidityCalcs } from \"../../libraries/liquidityCalcs.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { SafeTransfer } from \"../../libraries/safeTransfer.sol\";\nimport { CommonHelpers } from \"../common/helpers.sol\";\nimport { Events } from \"./events.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\n\ninterface IProtocol {\n    function liquidityCallback(address token_, uint256 amount_, bytes calldata data_) external;\n}\n\nabstract contract CoreInternals is Error, CommonHelpers, Events {\n    using BigMathMinified for uint256;\n\n    /// @dev supply or withdraw for both with interest & interest free.\n    /// positive `amount_` is deposit, negative `amount_` is withdraw.\n    function _supplyOrWithdraw(\n        address token_,\n        int256 amount_,\n        uint256 supplyExchangePrice_\n    ) internal returns (int256 newSupplyInterestRaw_, int256 newSupplyInterestFree_) {\n        uint256 userSupplyData_ = _userSupplyData[msg.sender][token_];\n\n        if (userSupplyData_ == 0) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__UserNotDefined);\n        }\n        if ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_IS_PAUSED) & 1 == 1) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__UserPaused);\n        }\n\n        // extract user supply amount\n        uint256 userSupply_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n        userSupply_ = (userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK);\n\n        // calculate current, updated (expanded etc.) withdrawal limit\n        uint256 newWithdrawalLimit_ = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\n\n        // calculate updated user supply amount\n        if (userSupplyData_ & 1 == 1) {\n            // mode: with interest\n            if (amount_ > 0) {\n                // convert amount from normal to raw (divide by exchange price) -> round down for deposit\n                newSupplyInterestRaw_ = (amount_ * int256(EXCHANGE_PRICES_PRECISION)) / int256(supplyExchangePrice_);\n                userSupply_ = userSupply_ + uint256(newSupplyInterestRaw_);\n            } else {\n                // convert amount from normal to raw (divide by exchange price) -> round up for withdraw\n                newSupplyInterestRaw_ = -int256(\n                    FixedPointMathLib.mulDivUp(uint256(-amount_), EXCHANGE_PRICES_PRECISION, supplyExchangePrice_)\n                );\n                // if withdrawal is more than user's supply then solidity will throw here\n                userSupply_ = userSupply_ - uint256(-newSupplyInterestRaw_);\n            }\n        } else {\n            // mode: without interest\n            newSupplyInterestFree_ = amount_;\n            if (newSupplyInterestFree_ > 0) {\n                userSupply_ = userSupply_ + uint256(newSupplyInterestFree_);\n            } else {\n                // if withdrawal is more than user's supply then solidity will throw here\n                userSupply_ = userSupply_ - uint256(-newSupplyInterestFree_);\n            }\n        }\n\n        if (amount_ < 0 && userSupply_ < newWithdrawalLimit_) {\n            // if withdraw, then check the user supply after withdrawal is above withdrawal limit\n            revert FluidLiquidityError(ErrorTypes.UserModule__WithdrawalLimitReached);\n        }\n\n        // calculate withdrawal limit to store as previous withdrawal limit in storage\n        newWithdrawalLimit_ = LiquidityCalcs.calcWithdrawalLimitAfterOperate(\n            userSupplyData_,\n            userSupply_,\n            newWithdrawalLimit_\n        );\n\n        // Converting user's supply into BigNumber\n        userSupply_ = userSupply_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_DOWN\n        );\n        if (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64) == userSupply_) {\n            // make sure that operate amount is not so small that it wouldn't affect storage update. if a difference\n            // is present then rounding will be in the right direction to avoid any potential manipulation.\n            revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountInsufficient);\n        }\n\n        // Converting withdrawal limit into BigNumber\n        newWithdrawalLimit_ = newWithdrawalLimit_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_DOWN\n        );\n\n        // Updating on storage\n        _userSupplyData[msg.sender][token_] =\n            // mask to update bits 1-161 (supply amount, withdrawal limit, timestamp)\n            (userSupplyData_ & 0xfffffffffffffffffffffffc0000000000000000000000000000000000000001) |\n            (userSupply_ << LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) | // converted to BigNumber can not overflow\n            (newWithdrawalLimit_ << LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) | // converted to BigNumber can not overflow\n            (block.timestamp << LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP);\n    }\n\n    /// @dev borrow or payback for both with interest & interest free.\n    /// positive `amount_` is borrow, negative `amount_` is payback.\n    function _borrowOrPayback(\n        address token_,\n        int256 amount_,\n        uint256 borrowExchangePrice_\n    ) internal returns (int256 newBorrowInterestRaw_, int256 newBorrowInterestFree_) {\n        uint256 userBorrowData_ = _userBorrowData[msg.sender][token_];\n\n        if (userBorrowData_ == 0) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__UserNotDefined);\n        }\n        if ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_IS_PAUSED) & 1 == 1) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__UserPaused);\n        }\n\n        // extract user borrow amount\n        uint256 userBorrow_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n        userBorrow_ = (userBorrow_ >> DEFAULT_EXPONENT_SIZE) << (userBorrow_ & DEFAULT_EXPONENT_MASK);\n\n        // calculate current, updated (expanded etc.) borrow limit\n        uint256 newBorrowLimit_ = LiquidityCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, userBorrow_);\n\n        // calculate updated user borrow amount\n        if (userBorrowData_ & 1 == 1) {\n            // with interest\n            if (amount_ > 0) {\n                // convert amount normal to raw (divide by exchange price) -> round up for borrow\n                newBorrowInterestRaw_ = int256(\n                    FixedPointMathLib.mulDivUp(uint256(amount_), EXCHANGE_PRICES_PRECISION, borrowExchangePrice_)\n                );\n                userBorrow_ = userBorrow_ + uint256(newBorrowInterestRaw_);\n            } else {\n                // convert amount from normal to raw (divide by exchange price) -> round down for payback\n                newBorrowInterestRaw_ = (amount_ * int256(EXCHANGE_PRICES_PRECISION)) / int256(borrowExchangePrice_);\n                userBorrow_ = userBorrow_ - uint256(-newBorrowInterestRaw_);\n            }\n        } else {\n            // without interest\n            newBorrowInterestFree_ = amount_;\n            if (newBorrowInterestFree_ > 0) {\n                // borrowing\n                userBorrow_ = userBorrow_ + uint256(newBorrowInterestFree_);\n            } else {\n                // payback\n                userBorrow_ = userBorrow_ - uint256(-newBorrowInterestFree_);\n            }\n        }\n\n        if (amount_ > 0 && userBorrow_ > newBorrowLimit_) {\n            // if borrow, then check the user borrow amount after borrowing is below borrow limit\n            revert FluidLiquidityError(ErrorTypes.UserModule__BorrowLimitReached);\n        }\n\n        // calculate borrow limit to store as previous borrow limit in storage\n        newBorrowLimit_ = LiquidityCalcs.calcBorrowLimitAfterOperate(userBorrowData_, userBorrow_, newBorrowLimit_);\n\n        // Converting user's borrowings into bignumber\n        userBorrow_ = userBorrow_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_UP\n        );\n\n        if (((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64) == userBorrow_) {\n            // make sure that operate amount is not so small that it wouldn't affect storage update. if a difference\n            // is present then rounding will be in the right direction to avoid any potential manipulation.\n            revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountInsufficient);\n        }\n\n        // Converting borrow limit into bignumber\n        newBorrowLimit_ = newBorrowLimit_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_DOWN\n        );\n\n        // Updating on storage\n        _userBorrowData[msg.sender][token_] =\n            // mask to update bits 1-161 (borrow amount, borrow limit, timestamp)\n            (userBorrowData_ & 0xfffffffffffffffffffffffc0000000000000000000000000000000000000001) |\n            (userBorrow_ << LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) | // converted to BigNumber can not overflow\n            (newBorrowLimit_ << LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) | // converted to BigNumber can not overflow\n            (block.timestamp << LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP);\n    }\n\n    /// @dev checks if `supplyAmount_` & `borrowAmount_` amounts transfers can be skipped (DEX-protocol use-case).\n    /// -   Requirements:\n    /// -  ` callbackData_` MUST be encoded so that \"from\" address is the last 20 bytes in the last 32 bytes slot,\n    ///     also for native token operations where liquidityCallback is not triggered!\n    ///     from address must come at last position if there is more data. I.e. encode like:\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\n    /// -   this \"from\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\n    ///     in the slot before (bytes 32 to 63)\n    /// -   `msg.value` must be 0.\n    /// -   Amounts must be either:\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\n    function _isInOutBalancedOut(\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes memory callbackData_\n    ) internal view returns (bool) {\n        // callbackData_ being at least > 63 in length is already verified before calling this method.\n\n        // 1. SKIP_TRANSFERS must be set in callbackData_ 32 bytes before last 32 bytes\n        bytes32 skipTransfers_;\n        assembly {\n            skipTransfers_ := mload(\n                add(\n                    // add padding for length as present for dynamic arrays in memory\n                    add(callbackData_, 32),\n                    // Load from memory offset of 2 slots (64 bytes): 1 slot: bytes32 skipTransfers_ + 2 slot: address inFrom_\n                    sub(mload(callbackData_), 64)\n                )\n            )\n        }\n        if (skipTransfers_ != SKIP_TRANSFERS) {\n            return false;\n        }\n        // after here, if invalid, protocol intended to skip transfers, but something is invalid. so we don't just\n        // NOT skip transfers, we actually revert because there must be something wrong on protocol side.\n\n        // 2. amounts must be\n        // a) equal: supply(+) == borrow(+), withdraw(-) == payback(-) OR\n        // b) Liquidity must be on the winning side.\n        // EITHER:\n        // deposit and borrow, both positive. there must be more borrow than deposit.\n        // so supply amount must be less, e.g. 80 deposit and 100 borrow.\n        // OR:\n        // withdraw and payback, both negative. there must be more withdraw than payback.\n        // so supplyAmount must be less (e.g. -100 withdraw and -80 payback )\n        if (\n            msg.value != 0 || // no msg.value should be sent along when trying to skip transfers.\n            supplyAmount_ == 0 ||\n            borrowAmount_ == 0 || // it must be a 2 actions operation, not just e.g. only deposit or only payback.\n            supplyAmount_ > borrowAmount_ // allow case a) and b): supplyAmount must be <=\n        ) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__SkipTransfersInvalid);\n        }\n\n        // 3. inFrom_ must be in last 32 bytes and must match receiver\n        address inFrom_;\n        assembly {\n            inFrom_ := mload(\n                add(\n                    // add padding for length as present for dynamic arrays in memory\n                    add(callbackData_, 32),\n                    // assembly expects address with leading zeros / left padded so need to use 32 as length here\n                    sub(mload(callbackData_), 32)\n                )\n            )\n        }\n\n        if (supplyAmount_ > 0) {\n            // deposit and borrow\n            if (!(inFrom_ == borrowTo_ && inFrom_ == msg.sender)) {\n                revert FluidLiquidityError(ErrorTypes.UserModule__SkipTransfersInvalid);\n            }\n        } else {\n            // withdraw and payback\n            if (!(inFrom_ == withdrawTo_ && inFrom_ == msg.sender)) {\n                revert FluidLiquidityError(ErrorTypes.UserModule__SkipTransfersInvalid);\n            }\n        }\n\n        return true;\n    }\n}\n\ninterface IZtakingPool {\n    ///@notice Stake a specified amount of a particular supported token into the Ztaking Pool\n    ///@param _token The token to deposit/stake in the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@param _amount The amount of token to deposit/stake into the Ztaking Pool\n    function depositFor(address _token, address _for, uint256 _amount) external;\n\n    ///@notice Withdraw a specified amount of a particular supported token previously staked into the Ztaking Pool\n    ///@param _token The token to withdraw from the Ztaking Pool\n    ///@param _amount The amount of token to withdraw from the Ztaking Pool\n    function withdraw(address _token, uint256 _amount) external;\n}\n\n/// @title  Fluid Liquidity UserModule\n/// @notice Fluid Liquidity public facing endpoint logic contract that implements the `operate()` method.\n///         operate can be used to deposit, withdraw, borrow & payback funds, given that they have the necessary\n///         user config allowance. Interacting users must be allowed via the Fluid Liquidity AdminModule first.\n///         Intended users are thus allow-listed protocols, e.g. the Lending protocol (fTokens), Vault protocol etc.\n/// @dev For view methods / accessing data, use the \"LiquidityResolver\" periphery contract.\ncontract FluidLiquidityUserModule is CoreInternals {\n    using BigMathMinified for uint256;\n\n    address private constant WEETH = 0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee;\n    address private constant WEETHS = 0x917ceE801a67f933F2e6b33fC0cD1ED2d5909D88;\n    IZtakingPool private constant ZIRCUIT = IZtakingPool(0xF047ab4c75cebf0eB9ed34Ae2c186f3611aEAfa6);\n\n    /// @dev struct for vars used in operate() that would otherwise cause a Stack too deep error\n    struct OperateMemoryVars {\n        bool skipTransfers;\n        uint256 supplyExchangePrice;\n        uint256 borrowExchangePrice;\n        uint256 supplyRawInterest;\n        uint256 supplyInterestFree;\n        uint256 borrowRawInterest;\n        uint256 borrowInterestFree;\n        uint256 totalAmounts;\n        uint256 exchangePricesAndConfig;\n    }\n\n    /// @notice inheritdoc IFluidLiquidity\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable reentrancy returns (uint256 memVar3_, uint256 memVar4_) {\n        if (supplyAmount_ == 0 && borrowAmount_ == 0) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountsZero);\n        }\n        if (\n            supplyAmount_ < type(int128).min ||\n            supplyAmount_ > type(int128).max ||\n            borrowAmount_ < type(int128).min ||\n            borrowAmount_ > type(int128).max\n        ) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountOutOfBounds);\n        }\n        if ((supplyAmount_ < 0 && withdrawTo_ == address(0)) || (borrowAmount_ > 0 && borrowTo_ == address(0))) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__ReceiverNotDefined);\n        }\n        if (token_ != NATIVE_TOKEN_ADDRESS && msg.value > 0) {\n            // revert: there should not be msg.value if the token is not the native token\n            revert FluidLiquidityError(ErrorTypes.UserModule__MsgValueForNonNativeToken);\n        }\n\n        OperateMemoryVars memory o_;\n\n        // @dev temporary memory variables used as helper in between to avoid assigning new memory variables\n        uint256 memVar_;\n        // memVar2_ => operateAmountIn: deposit + payback\n        uint256 memVar2_ = uint256((supplyAmount_ > 0 ? supplyAmount_ : int256(0))) +\n            uint256((borrowAmount_ < 0 ? -borrowAmount_ : int256(0)));\n\n        // check if token transfers can be skipped. see `_isInOutBalancedOut` for details.\n        if (\n            callbackData_.length > 63 &&\n            _isInOutBalancedOut(supplyAmount_, borrowAmount_, withdrawTo_, borrowTo_, callbackData_)\n        ) {\n            memVar2_ = 0; // set to 0 to skip transfers IN\n            o_.skipTransfers = true; // set flag to true to skip transfers OUT\n        }\n        if (token_ == NATIVE_TOKEN_ADDRESS) {\n            unchecked {\n                // check supply and payback amount is covered by available sent msg.value and\n                // protection that msg.value is not unintentionally way more than actually used in operate()\n                if (\n                    memVar2_ > msg.value ||\n                    msg.value > (memVar2_ * (FOUR_DECIMALS + MAX_INPUT_AMOUNT_EXCESS)) / FOUR_DECIMALS\n                ) {\n                    revert FluidLiquidityError(ErrorTypes.UserModule__TransferAmountOutOfBounds);\n                }\n            }\n            memVar2_ = 0; // set to 0 to skip transfers IN more gas efficient. No need for native token.\n        }\n        // if supply or payback or both -> transfer token amount from sender to here.\n        // for native token this is already covered by msg.value checks in operate(). memVar2_ is set to 0\n        // for same amounts in same operate(): supply(+) == borrow(+), withdraw(-) == payback(-). memVar2_ is set to 0\n        if (memVar2_ > 0) {\n            // memVar_ => initial token balance of this contract\n            memVar_ = IERC20(token_).balanceOf(address(this));\n            // trigger protocol to send token amount and pass callback data\n            IProtocol(msg.sender).liquidityCallback(token_, memVar2_, callbackData_);\n            // memVar_ => current token balance of this contract - initial balance\n            memVar_ = IERC20(token_).balanceOf(address(this)) - memVar_;\n            unchecked {\n                if (\n                    memVar_ < memVar2_ ||\n                    memVar_ > (memVar2_ * (FOUR_DECIMALS + MAX_INPUT_AMOUNT_EXCESS)) / FOUR_DECIMALS\n                ) {\n                    // revert if protocol did not send enough to cover supply / payback\n                    // or if protocol sent more than expected, with 1% tolerance for any potential rounding issues (and for DEX revenue cut)\n                    revert FluidLiquidityError(ErrorTypes.UserModule__TransferAmountOutOfBounds);\n                }\n            }\n\n            // ---------- temporary code start -----------------------\n            // temporary addition for weETH & weETHs: if token is weETH or weETHs -> deposit to Zircuit\n            if (token_ == WEETH) {\n                if (IERC20(WEETH).allowance(address(this), address(ZIRCUIT)) > 0) {\n                    ZIRCUIT.depositFor(WEETH, address(this), memVar_);\n                }\n            } else if (token_ == WEETHS) {\n                if ((IERC20(WEETHS).allowance(address(this), address(ZIRCUIT)) > 0)) {\n                    ZIRCUIT.depositFor(WEETHS, address(this), memVar_);\n                }\n            }\n            // temporary code also includes: WEETH, WEETHS & ZIRCUIT constant, IZtakingPool interface\n            // ---------- temporary code end -----------------------\n        }\n\n        o_.exchangePricesAndConfig = _exchangePricesAndConfig[token_];\n\n        // calculate updated exchange prices\n        (o_.supplyExchangePrice, o_.borrowExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            o_.exchangePricesAndConfig\n        );\n\n        // Extract total supply / borrow amounts for the token\n        o_.totalAmounts = _totalAmounts[token_];\n        memVar_ = o_.totalAmounts & X64;\n        o_.supplyRawInterest = (memVar_ >> DEFAULT_EXPONENT_SIZE) << (memVar_ & DEFAULT_EXPONENT_MASK);\n        memVar_ = (o_.totalAmounts >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\n        o_.supplyInterestFree = (memVar_ >> DEFAULT_EXPONENT_SIZE) << (memVar_ & DEFAULT_EXPONENT_MASK);\n        memVar_ = (o_.totalAmounts >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\n        o_.borrowRawInterest = (memVar_ >> DEFAULT_EXPONENT_SIZE) << (memVar_ & DEFAULT_EXPONENT_MASK);\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n        memVar_ = (o_.totalAmounts >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\n        o_.borrowInterestFree = (memVar_ >> DEFAULT_EXPONENT_SIZE) << (memVar_ & DEFAULT_EXPONENT_MASK);\n\n        if (supplyAmount_ != 0) {\n            // execute supply or withdraw and update total amounts\n            {\n                uint256 totalAmountsBefore_ = o_.totalAmounts;\n                (int256 newSupplyInterestRaw_, int256 newSupplyInterestFree_) = _supplyOrWithdraw(\n                    token_,\n                    supplyAmount_,\n                    o_.supplyExchangePrice\n                );\n                // update total amounts. this is done here so that values are only written to storage once\n                // if a borrow / payback also happens in the same `operate()` call\n                if (newSupplyInterestFree_ == 0) {\n                    // Note newSupplyInterestFree_ can ONLY be 0 if mode is with interest,\n                    // easy to check as that variable is NOT the result of a dvision etc.\n                    // supply or withdraw with interest -> raw amount\n                    if (newSupplyInterestRaw_ > 0) {\n                        o_.supplyRawInterest += uint256(newSupplyInterestRaw_);\n                    } else {\n                        unchecked {\n                            o_.supplyRawInterest = o_.supplyRawInterest > uint256(-newSupplyInterestRaw_)\n                                ? o_.supplyRawInterest - uint256(-newSupplyInterestRaw_)\n                                : 0; // withdraw amount is > total supply -> withdraw total supply down to 0\n                            // Note no risk here as if the user withdraws more than supplied it would revert already\n                            // earlier. Total amounts can end up < sum of user amounts because of rounding\n                        }\n                    }\n\n                    // Note check for revert {UserModule}__ValueOverflow__TOTAL_SUPPLY is further down when we anyway\n                    // calculate the normal amount from raw\n\n                    // Converting the updated total amount into big number for storage\n                    memVar_ = o_.supplyRawInterest.toBigNumber(\n                        DEFAULT_COEFFICIENT_SIZE,\n                        DEFAULT_EXPONENT_SIZE,\n                        BigMathMinified.ROUND_DOWN\n                    );\n                    // update total supply with interest at total amounts in storage (only update changed values)\n                    o_.totalAmounts =\n                        // mask to update bits 0-63\n                        (o_.totalAmounts & 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000) |\n                        memVar_; // converted to BigNumber can not overflow\n                } else {\n                    // supply or withdraw interest free -> normal amount\n                    if (newSupplyInterestFree_ > 0) {\n                        o_.supplyInterestFree += uint256(newSupplyInterestFree_);\n                    } else {\n                        unchecked {\n                            o_.supplyInterestFree = o_.supplyInterestFree > uint256(-newSupplyInterestFree_)\n                                ? o_.supplyInterestFree - uint256(-newSupplyInterestFree_)\n                                : 0; // withdraw amount is > total supply -> withdraw total supply down to 0\n                            // Note no risk here as if the user withdraws more than supplied it would revert already\n                            // earlier. Total amounts can end up < sum of user amounts because of rounding\n                        }\n                    }\n                    if (o_.supplyInterestFree > MAX_TOKEN_AMOUNT_CAP) {\n                        // only withdrawals allowed if total supply interest free reaches MAX_TOKEN_AMOUNT_CAP\n                        revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__TOTAL_SUPPLY);\n                    }\n                    // Converting the updated total amount into big number for storage\n                    memVar_ = o_.supplyInterestFree.toBigNumber(\n                        DEFAULT_COEFFICIENT_SIZE,\n                        DEFAULT_EXPONENT_SIZE,\n                        BigMathMinified.ROUND_DOWN\n                    );\n                    // update total supply interest free at total amounts in storage (only update changed values)\n                    o_.totalAmounts =\n                        // mask to update bits 64-127\n                        (o_.totalAmounts & 0xffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff) |\n                        (memVar_ << LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE); // converted to BigNumber can not overflow\n                }\n                if (totalAmountsBefore_ == o_.totalAmounts) {\n                    // make sure that operate amount is not so small that it wouldn't affect storage update. if a difference\n                    // is present then rounding will be in the right direction to avoid any potential manipulation.\n                    revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountInsufficient);\n                }\n            }\n        }\n        if (borrowAmount_ != 0) {\n            // execute borrow or payback and update total amounts\n            {\n                uint256 totalAmountsBefore_ = o_.totalAmounts;\n                (int256 newBorrowInterestRaw_, int256 newBorrowInterestFree_) = _borrowOrPayback(\n                    token_,\n                    borrowAmount_,\n                    o_.borrowExchangePrice\n                );\n                // update total amounts. this is done here so that values are only written to storage once\n                // if a supply / withdraw also happens in the same `operate()` call\n                if (newBorrowInterestFree_ == 0) {\n                    // Note newBorrowInterestFree_ can ONLY be 0 if mode is with interest,\n                    // easy to check as that variable is NOT the result of a dvision etc.\n                    // borrow or payback with interest -> raw amount\n                    if (newBorrowInterestRaw_ > 0) {\n                        o_.borrowRawInterest += uint256(newBorrowInterestRaw_);\n                    } else {\n                        unchecked {\n                            o_.borrowRawInterest = o_.borrowRawInterest > uint256(-newBorrowInterestRaw_)\n                                ? o_.borrowRawInterest - uint256(-newBorrowInterestRaw_)\n                                : 0; // payback amount is > total borrow -> payback total borrow down to 0\n                        }\n                    }\n\n                    // Note check for revert UserModule__ValueOverflow__TOTAL_BORROW is further down when we anyway\n                    // calculate the normal amount from raw\n\n                    // Converting the updated total amount into big number for storage\n                    memVar_ = o_.borrowRawInterest.toBigNumber(\n                        DEFAULT_COEFFICIENT_SIZE,\n                        DEFAULT_EXPONENT_SIZE,\n                        BigMathMinified.ROUND_UP\n                    );\n                    // update total borrow with interest at total amounts in storage (only update changed values)\n                    o_.totalAmounts =\n                        // mask to update bits 128-191\n                        (o_.totalAmounts & 0xffffffffffffffff0000000000000000ffffffffffffffffffffffffffffffff) |\n                        (memVar_ << LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST); // converted to BigNumber can not overflow\n                } else {\n                    // borrow or payback interest free -> normal amount\n                    if (newBorrowInterestFree_ > 0) {\n                        o_.borrowInterestFree += uint256(newBorrowInterestFree_);\n                    } else {\n                        unchecked {\n                            o_.borrowInterestFree = o_.borrowInterestFree > uint256(-newBorrowInterestFree_)\n                                ? o_.borrowInterestFree - uint256(-newBorrowInterestFree_)\n                                : 0; // payback amount is > total borrow -> payback total borrow down to 0\n                        }\n                    }\n                    if (o_.borrowInterestFree > MAX_TOKEN_AMOUNT_CAP) {\n                        // only payback allowed if total borrow interest free reaches MAX_TOKEN_AMOUNT_CAP\n                        revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__TOTAL_BORROW);\n                    }\n                    // Converting the updated total amount into big number for storage\n                    memVar_ = o_.borrowInterestFree.toBigNumber(\n                        DEFAULT_COEFFICIENT_SIZE,\n                        DEFAULT_EXPONENT_SIZE,\n                        BigMathMinified.ROUND_UP\n                    );\n                    // update total borrow interest free at total amounts in storage (only update changed values)\n                    o_.totalAmounts =\n                        // mask to update bits 192-255\n                        (o_.totalAmounts & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff) |\n                        (memVar_ << LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE); // converted to BigNumber can not overflow\n                }\n                if (totalAmountsBefore_ == o_.totalAmounts) {\n                    // make sure that operate amount is not so small that it wouldn't affect storage update. if a difference\n                    // is present then rounding will be in the right direction to avoid any potential manipulation.\n                    revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountInsufficient);\n                }\n            }\n        }\n        // Updating total amounts on storage\n        _totalAmounts[token_] = o_.totalAmounts;\n        {\n            // update exchange prices / utilization / ratios\n            // exchangePricesAndConfig is only written to storage if either utilization, supplyRatio or borrowRatio\n            // change is above the required storageUpdateThreshold config value or if the last write was > 1 day ago.\n\n            // 1. calculate new supply ratio, borrow ratio & utilization.\n            // 2. check if last storage write was > 1 day ago.\n            // 3. If false -> check if utilization is above update threshold\n            // 4. If false -> check if supply ratio is above update threshold\n            // 5. If false -> check if borrow ratio is above update threshold\n            // 6. If any true, then update on storage\n\n            // ########## calculating supply ratio ##########\n            // supplyWithInterest in normal amount\n            memVar3_ = ((o_.supplyRawInterest * o_.supplyExchangePrice) / EXCHANGE_PRICES_PRECISION);\n            if (memVar3_ > MAX_TOKEN_AMOUNT_CAP && supplyAmount_ > 0) {\n                // only withdrawals allowed if total supply raw reaches MAX_TOKEN_AMOUNT_CAP\n                revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__TOTAL_SUPPLY);\n            }\n            // memVar_ => total supply. set here so supplyWithInterest (memVar3_) is only calculated once. For utilization\n            memVar_ = o_.supplyInterestFree + memVar3_;\n            if (memVar3_ > o_.supplyInterestFree) {\n                // memVar3_ is ratio with 1 bit as 0 as supply interest raw is bigger\n                memVar3_ = ((o_.supplyInterestFree * FOUR_DECIMALS) / memVar3_) << 1;\n                // because of checking to divide by bigger amount, ratio can never be > 100%\n            } else if (memVar3_ < o_.supplyInterestFree) {\n                // memVar3_ is ratio with 1 bit as 1 as supply interest free is bigger\n                memVar3_ = (((memVar3_ * FOUR_DECIMALS) / o_.supplyInterestFree) << 1) | 1;\n                // because of checking to divide by bigger amount, ratio can never be > 100%\n            } else if (memVar_ > 0) {\n                // supplies match exactly (memVar3_  == o_.supplyInterestFree) and total supplies are not 0\n                // -> set ratio to 1 (with first bit set to 0, doesn't matter)\n                memVar3_ = FOUR_DECIMALS << 1;\n            } // else if total supply = 0, memVar3_ (supplyRatio) is already 0.\n\n            // ########## calculating borrow ratio ##########\n            // borrowWithInterest in normal amount\n            memVar4_ = ((o_.borrowRawInterest * o_.borrowExchangePrice) / EXCHANGE_PRICES_PRECISION);\n            if (memVar4_ > MAX_TOKEN_AMOUNT_CAP && borrowAmount_ > 0) {\n                // only payback allowed if total borrow raw reaches MAX_TOKEN_AMOUNT_CAP\n                revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__TOTAL_BORROW);\n            }\n            // memVar2_ => total borrow. set here so borrowWithInterest (memVar4_) is only calculated once. For utilization\n            memVar2_ = o_.borrowInterestFree + memVar4_;\n            if (memVar4_ > o_.borrowInterestFree) {\n                // memVar4_ is ratio with 1 bit as 0 as borrow interest raw is bigger\n                memVar4_ = ((o_.borrowInterestFree * FOUR_DECIMALS) / memVar4_) << 1;\n                // because of checking to divide by bigger amount, ratio can never be > 100%\n            } else if (memVar4_ < o_.borrowInterestFree) {\n                // memVar4_ is ratio with 1 bit as 1 as borrow interest free is bigger\n                memVar4_ = (((memVar4_ * FOUR_DECIMALS) / o_.borrowInterestFree) << 1) | 1;\n                // because of checking to divide by bigger amount, ratio can never be > 100%\n            } else if (memVar2_ > 0) {\n                // borrows match exactly (memVar4_  == o_.borrowInterestFree) and total borrows are not 0\n                // -> set ratio to 1 (with first bit set to 0, doesn't matter)\n                memVar4_ = FOUR_DECIMALS << 1;\n            } // else if total borrow = 0, memVar4_ (borrowRatio) is already 0.\n\n            // calculate utilization. If there is no supply, utilization must be 0 (avoid division by 0)\n            uint256 utilization_;\n            if (memVar_ > 0) {\n                utilization_ = ((memVar2_ * FOUR_DECIMALS) / memVar_);\n\n                // for borrow operations, ensure max utilization is not reached\n                if (borrowAmount_ > 0) {\n                    // memVar_ => max utilization\n                    // if any max utilization other than 100% is set, the flag usesConfigs2 in\n                    // exchangePricesAndConfig is 1. (optimized to avoid SLOAD if not needed).\n                    memVar_ = (o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_USES_CONFIGS2) &\n                        1 ==\n                        1\n                        ? (_configs2[token_] & X14) // read configured max utilization\n                        : FOUR_DECIMALS; // default max utilization = 100%\n\n                    if (utilization_ > memVar_) {\n                        revert FluidLiquidityError(ErrorTypes.UserModule__MaxUtilizationReached);\n                    }\n                }\n            }\n\n            // check if time difference is big enough (> 1 day)\n            unchecked {\n                if (\n                    block.timestamp >\n                    // extract last update timestamp + 1 day\n                    (((o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33) +\n                        FORCE_STORAGE_WRITE_AFTER_TIME)\n                ) {\n                    memVar_ = 1; // set write to storage flag\n                } else {\n                    memVar_ = 0;\n                }\n            }\n\n            if (memVar_ == 0) {\n                // time difference is not big enough to cause storage write -> check utilization\n\n                // memVar_ => extract last utilization\n                memVar_ = (o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14;\n                // memVar2_ => storage update threshold in percent\n                memVar2_ =\n                    (o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD) &\n                    X14;\n                unchecked {\n                    // set memVar_ to 1 if current utilization to previous utilization difference is > update storage threshold\n                    memVar_ = (utilization_ > memVar_ ? utilization_ - memVar_ : memVar_ - utilization_) > memVar2_\n                        ? 1\n                        : 0;\n                    if (memVar_ == 0) {\n                        // utilization & time difference is not big enough -> check supplyRatio difference\n                        // memVar_ => extract last supplyRatio\n                        memVar_ =\n                            (o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) &\n                            X15;\n                        // set memVar_ to 1 if current supplyRatio to previous supplyRatio difference is > update storage threshold\n                        if ((memVar_ & 1) == (memVar3_ & 1)) {\n                            memVar_ = memVar_ >> 1;\n                            memVar_ = (\n                                (memVar3_ >> 1) > memVar_ ? (memVar3_ >> 1) - memVar_ : memVar_ - (memVar3_ >> 1)\n                            ) > memVar2_\n                                ? 1\n                                : 0; // memVar3_ = supplyRatio, memVar_ = previous supplyRatio, memVar2_ = update storage threshold\n                        } else {\n                            // if inverse bit is changing then always update on storage\n                            memVar_ = 1;\n                        }\n                        if (memVar_ == 0) {\n                            // utilization, time, and supplyRatio difference is not big enough -> check borrowRatio difference\n                            // memVar_ => extract last borrowRatio\n                            memVar_ =\n                                (o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\n                                X15;\n                            // set memVar_ to 1 if current borrowRatio to previous borrowRatio difference is > update storage threshold\n                            if ((memVar_ & 1) == (memVar4_ & 1)) {\n                                memVar_ = memVar_ >> 1;\n                                memVar_ = (\n                                    (memVar4_ >> 1) > memVar_ ? (memVar4_ >> 1) - memVar_ : memVar_ - (memVar4_ >> 1)\n                                ) > memVar2_\n                                    ? 1\n                                    : 0; // memVar4_ = borrowRatio, memVar_ = previous borrowRatio, memVar2_ = update storage threshold\n                            } else {\n                                // if inverse bit is changing then always update on storage\n                                memVar_ = 1;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // memVar_ is 1 if either time diff was enough or if\n            // utilization, supplyRatio or borrowRatio difference was > update storage threshold\n            if (memVar_ == 1) {\n                // memVar_ => calculate new borrow rate for utilization. includes value overflow check.\n                memVar_ = LiquidityCalcs.calcBorrowRateFromUtilization(_rateData[token_], utilization_);\n                // ensure values written to storage do not exceed the dedicated bit space in packed uint256 slots\n                if (o_.supplyExchangePrice > X64 || o_.borrowExchangePrice > X64) {\n                    revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__EXCHANGE_PRICES);\n                }\n                if (utilization_ > X14) {\n                    revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__UTILIZATION);\n                }\n                o_.exchangePricesAndConfig =\n                    (o_.exchangePricesAndConfig &\n                        // mask to update bits: 0-15 (borrow rate), 30-43 (utilization), 58-248 (timestamp, exchange prices, ratios)\n                        0xfe000000000000000000000000000000000000000000000003fff0003fff0000) |\n                    memVar_ | // calcBorrowRateFromUtilization already includes an overflow check\n                    (utilization_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) |\n                    (block.timestamp << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) |\n                    (o_.supplyExchangePrice << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) |\n                    (o_.borrowExchangePrice << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) |\n                    // ratios can never be > 100%, no overflow check needed\n                    (memVar3_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) | // supplyRatio (memVar3_ holds that value)\n                    (memVar4_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO); // borrowRatio (memVar4_ holds that value)\n                // Updating on storage\n                _exchangePricesAndConfig[token_] = o_.exchangePricesAndConfig;\n            } else {\n                // do not update in storage but update o_.exchangePricesAndConfig for updated exchange prices at\n                // event emit of LogOperate\n                o_.exchangePricesAndConfig =\n                    (o_.exchangePricesAndConfig &\n                        // mask to update bits: 91-218 (exchange prices)\n                        0xfffffffffc00000000000000000000000000000007ffffffffffffffffffffff) |\n                    (o_.supplyExchangePrice << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) |\n                    (o_.borrowExchangePrice << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE);\n            }\n        }\n        // sending tokens to user at the end after updating everything\n        // only transfer to user in case of withdraw or borrow.\n        // do not transfer for same amounts in same operate(): supply(+) == borrow(+), withdraw(-) == payback(-). (DEX protocol use-case)\n        if ((supplyAmount_ < 0 || borrowAmount_ > 0) && !o_.skipTransfers) {\n            // sending tokens to user at the end after updating everything\n            // set memVar2_ to borrowAmount (if borrow) or reset memVar2_ var to 0 because\n            // it is used with > 0 check below to transfer withdraw / borrow / both\n            memVar2_ = borrowAmount_ > 0 ? uint256(borrowAmount_) : 0;\n            if (supplyAmount_ < 0) {\n                unchecked {\n                    memVar_ = uint256(-supplyAmount_);\n                }\n            } else {\n                memVar_ = 0;\n            }\n            if (memVar_ > 0 && memVar2_ > 0 && withdrawTo_ == borrowTo_) {\n                // if user is doing borrow & withdraw together and address for both is the same\n                // then transfer tokens of borrow & withdraw together to save on gas\n                if (token_ == NATIVE_TOKEN_ADDRESS) {\n                    SafeTransfer.safeTransferNative(withdrawTo_, memVar_ + memVar2_);\n                } else {\n                    SafeTransfer.safeTransfer(token_, withdrawTo_, memVar_ + memVar2_);\n                }\n            } else {\n                if (token_ == NATIVE_TOKEN_ADDRESS) {\n                    // if withdraw\n                    if (memVar_ > 0) {\n                        SafeTransfer.safeTransferNative(withdrawTo_, memVar_);\n                    }\n                    // if borrow\n                    if (memVar2_ > 0) {\n                        SafeTransfer.safeTransferNative(borrowTo_, memVar2_);\n                    }\n                } else {\n                    // if withdraw\n                    if (memVar_ > 0) {\n                        // ---------- temporary code start -----------------------\n                        // temporary addition for weETH & weETHs: if token is weETH or weETHs -> withdraw from Zircuit\n                        if (token_ == WEETH) {\n                            if ((IERC20(WEETH).balanceOf(address(this)) < memVar_)) {\n                                ZIRCUIT.withdraw(WEETH, memVar_);\n                            }\n                        } else if (token_ == WEETHS) {\n                            if ((IERC20(WEETHS).balanceOf(address(this)) < memVar_)) {\n                                ZIRCUIT.withdraw(WEETHS, memVar_);\n                            }\n                        }\n                        // temporary code also includes: WEETH, WEETHS & ZIRCUIT constant, IZtakingPool interface\n                        // ---------- temporary code end -----------------------\n\n                        SafeTransfer.safeTransfer(token_, withdrawTo_, memVar_);\n                    }\n                    // if borrow\n                    if (memVar2_ > 0) {\n                        SafeTransfer.safeTransfer(token_, borrowTo_, memVar2_);\n                    }\n                }\n            }\n        }\n        // emit Operate event\n        emit LogOperate(\n            msg.sender,\n            token_,\n            supplyAmount_,\n            borrowAmount_,\n            withdrawTo_,\n            borrowTo_,\n            o_.totalAmounts,\n            o_.exchangePricesAndConfig\n        );\n        // set return values\n        memVar3_ = o_.supplyExchangePrice;\n        memVar4_ = o_.borrowExchangePrice;\n    }\n}\n"
    },
    "contracts/liquidity/zircuitTransferModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { Variables } from \"../common/variables.sol\";\n\ninterface IZtakingPool {\n    ///@notice Stake a specified amount of a particular supported token into the Ztaking Pool\n    ///@param _token The token to deposit/stake in the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@param _amount The amount of token to deposit/stake into the Ztaking Pool\n    function depositFor(address _token, address _for, uint256 _amount) external;\n\n    ///@notice Withdraw a specified amount of a particular supported token previously staked into the Ztaking Pool\n    ///@param _token The token to withdraw from the Ztaking Pool\n    ///@param _amount The amount of token to withdraw from the Ztaking Pool\n    function withdraw(address _token, uint256 _amount) external;\n\n    function balance(address token_, address staker_) external view returns (uint256);\n}\n\ncontract FluidLiquidityZircuitTransferModule is Variables {\n    address internal constant LIQUIDITY = 0x52Aa899454998Be5b000Ad077a46Bbe360F4e497;\n\n    IERC20 internal constant WEETH = IERC20(0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee);\n    IERC20 internal constant WEETHS = IERC20(0x917ceE801a67f933F2e6b33fC0cD1ED2d5909D88);\n    IZtakingPool internal constant ZIRCUIT = IZtakingPool(0xF047ab4c75cebf0eB9ed34Ae2c186f3611aEAfa6);\n\n    /// @dev Returns the current admin (governance).\n    function _getGovernanceAddr() internal view returns (address governance_) {\n        assembly {\n            governance_ := sload(GOVERNANCE_SLOT)\n        }\n    }\n\n    /// @notice deposit all WEETH funds to Zircuit and sets approved allowance to max uint256.\n    /// @dev Only delegate callable on Liquidity, by Governance\n    function depositZircuitWeETH() external {\n        if (_getGovernanceAddr() != msg.sender || address(this) != LIQUIDITY) {\n            revert();\n        }\n\n        SafeERC20.safeApprove(WEETH, address(ZIRCUIT), type(uint256).max);\n\n        ZIRCUIT.depositFor(address(WEETH), address(this), WEETH.balanceOf(address(this)));\n    }\n\n    /// @notice withdraw all WEETH funds from Zircuit and sets approved allowance to 0.\n    /// @dev Only delegate callable on Liquidity, Governance and Guardians (for emergency)\n    function withdrawZircuitWeETH() external {\n        if ((_isGuardian[msg.sender] & 1 != 1 && _getGovernanceAddr() != msg.sender) || address(this) != LIQUIDITY) {\n            revert();\n        }\n\n        ZIRCUIT.withdraw(address(WEETH), ZIRCUIT.balance(address(WEETH), address(this)));\n\n        // remove approval\n        SafeERC20.safeApprove(WEETH, address(ZIRCUIT), 0);\n    }\n\n    /// @notice deposit all WEETHS funds to Zircuit and sets approved allowance to max uint256.\n    /// @dev Only delegate callable on Liquidity, by Governance\n    function depositZircuitWeETHs() external {\n        if (_getGovernanceAddr() != msg.sender || address(this) != LIQUIDITY) {\n            revert();\n        }\n\n        SafeERC20.safeApprove(WEETHS, address(ZIRCUIT), type(uint256).max);\n\n        ZIRCUIT.depositFor(address(WEETHS), address(this), WEETHS.balanceOf(address(this)));\n    }\n\n    /// @notice withdraw all WEETHS funds from Zircuit and sets approved allowance to 0.\n    /// @dev Only delegate callable on Liquidity, Governance and Guardians (for emergency)\n    function withdrawZircuitWeETHs() external {\n        if ((_isGuardian[msg.sender] & 1 != 1 && _getGovernanceAddr() != msg.sender) || address(this) != LIQUIDITY) {\n            revert();\n        }\n\n        ZIRCUIT.withdraw(address(WEETHS), ZIRCUIT.balance(address(WEETHS), address(this)));\n\n        // remove approval\n        SafeERC20.safeApprove(WEETHS, address(ZIRCUIT), 0);\n    }\n}\n"
    },
    "contracts/mocks/mockProtocol.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { FluidLiquidityUserModule } from \"../liquidity/userModule/main.sol\";\nimport { IFluidLiquidity } from \"../liquidity/interfaces/iLiquidity.sol\";\n\n/// @title    Mock Protocol\n/// @notice   Mock protocol for testing, implements:\n///           function liquidityCallback(address token_, uint256 amount_, bytes calldata data_) external;\n///           This callback method MUST transferFrom data_ decoded from address to the liquidity contract\ncontract MockProtocol {\n    using SafeERC20 for IERC20;\n\n    /// @dev address that is mapped to the chain native token\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address public immutable liquidityContract;\n\n    /// @notice thrown when liquidity callback is called for a native token operation\n    error MockProtocol__UnexpectedLiquidityCallback();\n\n    bool transferInsufficientMode = false;\n    bool transferExcessMode = false;\n    bool reentrancyFromCallback = false;\n    address transferFromAddress;\n\n    /// @notice   Construct a new MockProtocol\n    /// @param    liquidityContract_ The address of the liquidity contract\n    constructor(address liquidityContract_) {\n        liquidityContract = liquidityContract_;\n    }\n\n    receive() external payable {}\n\n    function setTransferInsufficientMode(bool transferInsufficientMode_) public {\n        transferInsufficientMode = transferInsufficientMode_;\n    }\n\n    function setTransferExcessMode(bool transferExcessMode_) public {\n        transferExcessMode = transferExcessMode_;\n    }\n\n    function setReentrancyFromCallback(bool reentrancyFromCallback_) public {\n        reentrancyFromCallback = reentrancyFromCallback_;\n    }\n\n    function setTransferFromAddress(address transferFromAddress_) public {\n        transferFromAddress = transferFromAddress_;\n    }\n\n    /// @notice   Mock liquidity callback\n    /// @param    token_ The token being transferred\n    /// @param    amount_ The amount being transferred\n    function liquidityCallback(address token_, uint256 amount_, bytes memory data_) external {\n        if (reentrancyFromCallback) {\n            // call operate with some random values (should not matter as it reverts anyway)\n            IFluidLiquidity(liquidityContract).operate(\n                token_,\n                10,\n                0,\n                address(0),\n                address(0),\n                abi.encode(address(this))\n            );\n        }\n\n        if (token_ == NATIVE_TOKEN_ADDRESS) {\n            revert MockProtocol__UnexpectedLiquidityCallback();\n        }\n\n        address from_;\n        if (transferFromAddress == address(0)) {\n            // take the last 20 bytes of data_ and decode them to address. Gives more flexibility in type of\n            // data that can be passed in to Liquidity at mock calls while ensuring mock Protocol can do what it\n            // is supposed to do: transfer amount of token to liquidity.\n            assembly {\n                from_ := mload(\n                    add(\n                        // add padding for length as present for dynamic arrays in memory\n                        add(data_, 32),\n                        // assembly expects address with leading zeros / left padded so need to use 32 as length here\n                        sub(mload(data_), 32)\n                    )\n                )\n            }\n        } else {\n            from_ = transferFromAddress;\n        }\n\n        if (amount_ > 0) {\n            if (transferExcessMode) {\n                amount_ += (amount_ * 10101) / 10000; // max excess is 1%\n            } else if (transferInsufficientMode) {\n                amount_ -= 1;\n            }\n        }\n\n        if (from_ == address(this)) {\n            // use approve and transferFrom for more consistent testing of methods called\n            // (always transferFrom instead of transfer)\n            IERC20(token_).safeApprove(address(this), amount_);\n            IERC20(token_).safeTransferFrom(address(this), liquidityContract, amount_);\n        } else {\n            IERC20(token_).safeTransferFrom(from_, liquidityContract, amount_);\n        }\n    }\n\n    /// @notice   Proxy method for executing `operate` on the liquidity contract\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\n        uint256 valueAmount = msg.value;\n\n        if (valueAmount > 0) {\n            if (transferExcessMode) {\n                valueAmount += (valueAmount * 10101) / 10000; // max excess is 1%\n            } else if (transferInsufficientMode) {\n                valueAmount -= 1;\n            }\n        }\n\n        return\n            FluidLiquidityUserModule(liquidityContract).operate{ value: valueAmount }(\n                token_,\n                supplyAmount_,\n                borrowAmount_,\n                withdrawTo_,\n                borrowTo_,\n                callbackData_\n            );\n    }\n}\n"
    },
    "contracts/oracle/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Error {\n    error FluidOracleError(uint256 errorId_);\n}\n"
    },
    "contracts/oracle/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |           FluidOracleL2           | \n    |__________________________________*/\n\n    /// @notice thrown when sequencer on a L2 has an outage and grace period has not yet passed.\n    uint256 internal constant FluidOracleL2__SequencerOutage = 60000;\n\n    /***********************************|\n    |     UniV3CheckCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the delta between main price source and check rate source is exceeding the allowed delta\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidPrice = 60001;\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidParams = 60002;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant UniV3CheckCLRSOracle__ExchangeRateZero = 60003;\n\n    /***********************************|\n    |           FluidOracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid info name is passed into a fluid oracle (e.g. not set or too long)\n    uint256 internal constant FluidOracle__InvalidInfoName = 60010;\n\n    /***********************************|\n    |            sUSDe Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDeOracle__InvalidParams = 60102;\n\n    /***********************************|\n    |           Pendle Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PendleOracle__InvalidParams = 60201;\n\n    /// @notice thrown when the Pendle market Oracle has not been initialized yet\n    uint256 internal constant PendleOracle__MarketNotInitialized = 60202;\n\n    /// @notice thrown when the Pendle market does not have 18 decimals\n    uint256 internal constant PendleOracle__MarketInvalidDecimals = 60203;\n\n    /// @notice thrown when the Pendle market returns an unexpected price\n    uint256 internal constant PendleOracle__InvalidPrice = 60204;\n\n    /***********************************|\n    |    CLRS2UniV3CheckCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant CLRS2UniV3CheckCLRSOracleL2__ExchangeRateZero = 60301;\n\n    /***********************************|\n    |    Ratio2xFallbackCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant Ratio2xFallbackCLRSOracleL2__ExchangeRateZero = 60311;\n\n    /***********************************|\n    |            WeETHsOracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHsOracle__InvalidParams = 60321;\n\n    /***********************************|\n    |        DexSmartColOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexSmartColOracle__InvalidParams = 60331;\n\n    /// @notice thrown when smart col is not enabled\n    uint256 internal constant DexSmartColOracle__SmartColNotEnabled = 60332;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexSmartColOracle__ExchangeRateZero = 60333;\n\n    /***********************************|\n    |        DexSmartDebtOracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexSmartDebtOracle__InvalidParams = 60341;\n\n    /// @notice thrown when smart debt is not enabled\n    uint256 internal constant DexSmartDebtOracle__SmartDebtNotEnabled = 60342;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexSmartDebtOracle__ExchangeRateZero = 60343;\n\n    /***********************************|\n    |            CappedRate           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant CappedRate__InvalidParams = 60351;\n\n    /// @notice thrown when caller is not authorized\n    uint256 internal constant CappedRate__Unauthorized = 60352;\n\n    /// @notice thrown when minimum diff for triggering update on the stared rate is not reached\n    uint256 internal constant CappedRate__MinUpdateDiffNotReached = 60353;\n\n    /// @notice thrown when the external rate source returns 0 for the new rate\n    uint256 internal constant CappedRate__NewRateZero = 60354;\n\n    /// @notice thrown when the new rate source does not fit in 192 bit storage uint, should never happen.\n    uint256 internal constant CappedRate__StorageOverflow = 60355;\n\n    /***********************************|\n    |            sUSDs Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDsOracle__InvalidParams = 60361;\n\n    /***********************************|\n    |            Peg Oracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PegOracle__InvalidParams = 60371;\n\n    /***********************************|\n    |              DexOracle            | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant DexOracle__InvalidParams = 60381;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant DexOracle__ExchangeRateZero = 60382;\n\n    /***********************************|\n    |           GenericOracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant GenericOracle__InvalidParams = 60401;\n\n    /// @notice thrown when reaching an unexepcted config state\n    uint256 internal constant GenericOracle__UnexpectedConfig = 60402;\n\n    /// @notice thrown when the exchange rate is zero\n    uint256 internal constant GenericOracle__RateZero = 60403;\n\n    /***********************************|\n    |          Chainlink Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant ChainlinkOracle__InvalidParams = 61001;\n\n    /***********************************|\n    |          UniswapV3 Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3Oracle__InvalidParams = 62001;\n\n    /// @notice thrown when constructor is called with invalid ordered seconds agos values\n    uint256 internal constant UniV3Oracle__InvalidSecondsAgos = 62002;\n\n    /// @notice thrown when constructor is called with invalid delta values > 100%\n    uint256 internal constant UniV3Oracle__InvalidDeltas = 62003;\n\n    /***********************************|\n    |            WstETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WstETHOracle__InvalidParams = 63001;\n\n    /***********************************|\n    |           Redstone Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant RedstoneOracle__InvalidParams = 64001;\n\n    /***********************************|\n    |          Fallback Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant FallbackOracle__InvalidParams = 65001;\n\n    /***********************************|\n    |       FallbackCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant FallbackCLRSOracle__ExchangeRateZero = 66001;\n\n    /***********************************|\n    |         WstETHCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant WstETHCLRSOracle__ExchangeRateZero = 67001;\n\n    /***********************************|\n    |        CLFallbackUniV3Oracle      | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant CLFallbackUniV3Oracle__ExchangeRateZero = 68001;\n\n    /***********************************|\n    |  WstETHCLRS2UniV3CheckCLRSOracle  | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant WstETHCLRS2UniV3CheckCLRSOracle__ExchangeRateZero = 69001;\n\n    /***********************************|\n    |             WeETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHOracle__InvalidParams = 70001;\n}\n"
    },
    "contracts/oracle/fluidOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"./interfaces/iFluidOracle.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { Error as OracleError } from \"./error.sol\";\n\n/// @title   FluidOracle\n/// @notice  Base contract that any Fluid Oracle must implement\nabstract contract FluidOracle is IFluidOracle, OracleError {\n    /// @dev short helper string to easily identify the oracle. E.g. token symbols\n    //\n    // using a bytes32 because string can not be immutable.\n    bytes32 private immutable _infoName;\n\n    /// @dev target decimals of the oracle when scaling to 1e27. E.g. for ETH / USDC it would be 15\n    /// because diff of ETH decimals to 1e27 is 9, and USDC has 6 decimals, so 6+9 = 15, e.g. 2029,047772120364926\n    /// For USDC / ETH: 21 + 18 = 39, e.g. 0,000492842018675092636829357843847601646\n    uint8 private immutable _targetDecimals;\n\n    constructor(string memory infoName_, uint8 targetDecimals_) {\n        if (bytes(infoName_).length > 32 || bytes(infoName_).length == 0) {\n            revert FluidOracleError(ErrorTypes.FluidOracle__InvalidInfoName);\n        }\n\n        if (targetDecimals_ < 15 || targetDecimals_ > 39) {\n            revert FluidOracleError(ErrorTypes.GenericOracle__InvalidParams);\n        }\n        _targetDecimals = targetDecimals_;\n\n        // convert string to bytes32\n        bytes32 infoNameBytes32_;\n        assembly {\n            infoNameBytes32_ := mload(add(infoName_, 32))\n        }\n        _infoName = infoNameBytes32_;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function targetDecimals() external view returns (uint8) {\n        return _targetDecimals;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function infoName() external view returns (string memory) {\n        // convert bytes32 to string\n        uint256 length_;\n        while (length_ < 32 && _infoName[length_] != 0) {\n            length_++;\n        }\n        bytes memory infoNameBytes_ = new bytes(length_);\n        for (uint256 i; i < length_; i++) {\n            infoNameBytes_[i] = _infoName[i];\n        }\n        return string(infoNameBytes_);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() external view virtual returns (uint256 exchangeRate_);\n}\n"
    },
    "contracts/oracle/interfaces/iFluidOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidOracle {\n    /// @dev Deprecated. Use `getExchangeRateOperate()` and `getExchangeRateLiquidate()` instead. Only implemented for\n    ///      backwards compatibility.\n    function getExchangeRate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for operates\n    function getExchangeRateOperate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for liquidations\n    function getExchangeRateLiquidate() external view returns (uint256 exchangeRate_);\n\n    /// @notice helper string to easily identify the oracle. E.g. token symbols\n    function infoName() external view returns (string memory);\n\n    /// @notice target decimals of the returned oracle rate when scaling to 1e27. E.g. for ETH / USDC it would be 15\n    /// because diff of ETH decimals to 1e27 is 9, and USDC has 6 decimals, so 6+9 = 15, e.g. 2029,047772120364926\n    /// For USDC / ETH: 21 + 18 = 39, e.g. 0,000492842018675092636829357843847601646\n    function targetDecimals() external view returns (uint8);\n}\n"
    },
    "contracts/periphery/resolvers/dexReserves/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { DexSlotsLink } from \"../../../libraries/dexSlotsLink.sol\";\nimport { BytesSliceAndConcat } from \"../../../libraries/bytesSliceAndConcat.sol\";\nimport { Structs as FluidLiquidityResolverStructs } from \"../liquidity/structs.sol\";\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { Variables } from \"./variables.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\ninterface TokenInterface {\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IZtakingPool {\n    function balance(address token_, address staker_) external view returns (uint256);\n}\n\n/// @title DexFactoryViews\n/// @notice Abstract contract providing view functions for DEX factory-related operations\nabstract contract DexFactoryViews is Variables {\n    /// @notice Get the address of a Pool given its ID\n    /// @param poolId_ The ID of the Pool\n    /// @return pool_ The address of the Pool\n    function getPoolAddress(uint256 poolId_) public view returns (address pool_) {\n        return AddressCalcs.addressCalc(address(FACTORY), poolId_);\n    }\n\n    /// @notice Get the total number of Pools\n    /// @return The total number of Pools\n    function getTotalPools() public view returns (uint) {\n        return FACTORY.totalDexes();\n    }\n\n    /// @notice Get an array of all Pool addresses\n    /// @return pools_ An array containing all Pool addresses\n    function getAllPoolAddresses() public view returns (address[] memory pools_) {\n        uint totalPools_ = getTotalPools();\n        pools_ = new address[](totalPools_);\n        for (uint i = 0; i < totalPools_; i++) {\n            pools_[i] = getPoolAddress((i + 1));\n        }\n    }\n}\n\n/// @title DexPublicViews\n/// @notice Abstract contract providing view functions for DEX public data\nabstract contract DexPublicViews {\n    /// @notice Get the prices and exchange prices for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return pex_ A struct containing prices and exchange prices\n    /// @dev expected to be called via callStatic\n    function getDexPricesAndExchangePrices(\n        address dex_\n    ) public returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n        try IFluidDexT1(dex_).getPricesAndExchangePrices() {} catch (bytes memory lowLevelData_) {\n            bytes4 errorSelector_;\n            assembly {\n                // Extract the selector from the error data\n                errorSelector_ := mload(add(lowLevelData_, 0x20))\n            }\n            if (errorSelector_ == IFluidDexT1.FluidDexPricesAndExchangeRates.selector) {\n                pex_ = abi.decode(\n                    BytesSliceAndConcat.bytesSlice(lowLevelData_, 4, lowLevelData_.length - 4),\n                    (IFluidDexT1.PricesAndExchangePrice)\n                );\n            }\n        }\n    }\n\n    /// @notice Get the collateral reserves for a DEX in token decimals amounts\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing collateral reserve information\n    /// @dev expected to be called via callStatic\n    function getDexCollateralReserves(address dex_) public returns (IFluidDexT1.CollateralReserves memory reserves_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        if ((dexVariables2_ & 1) != 1) {\n            // smart col not enabled\n            return IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            reserves_ = _getDexCollateralReserves(dex_, pex_);\n        } catch {\n            reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n    }\n\n    /// @notice Get the collateral reserves for a DEX scaled to 1e12\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing collateral reserve information\n    /// @dev expected to be called via callStatic\n    function getDexCollateralReservesAdjusted(\n        address dex_\n    ) public returns (IFluidDexT1.CollateralReserves memory reserves_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        if ((dexVariables2_ & 1) != 1) {\n            // smart col not enabled\n            return IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            reserves_ = _getDexCollateralReservesAdjusted(dex_, pex_);\n        } catch {\n            reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n    }\n\n    /// @notice Get the debt reserves for a DEX in token decimals amounts\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing debt reserve information\n    /// @dev expected to be called via callStatic\n    function getDexDebtReserves(address dex_) public returns (IFluidDexT1.DebtReserves memory reserves_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        if ((dexVariables2_ & 2) != 2) {\n            // smart debt not enabled\n            return IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            reserves_ = _getDexDebtReserves(dex_, pex_);\n        } catch {\n            reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n    }\n\n    /// @notice Get the debt reserves for a DEX scaled to 1e12\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing debt reserve information\n    /// @dev expected to be called via callStatic\n    function getDexDebtReservesAdjusted(address dex_) public returns (IFluidDexT1.DebtReserves memory reserves_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        if ((dexVariables2_ & 2) != 2) {\n            // smart debt not enabled\n            return IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            reserves_ = _getDexDebtReservesAdjusted(dex_, pex_);\n        } catch {\n            reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n    }\n\n    /// @dev Retrieves and normalizes the collateral reserves for a given DEX.\n    /// @param dex_ The address of the DEX.\n    /// @param pex_ A struct containing price and exchange price information.\n    /// @return reserves_ A struct containing the normalized collateral reserves.\n    function _getDexCollateralReserves(\n        address dex_,\n        IFluidDexT1.PricesAndExchangePrice memory pex_\n    ) internal view returns (IFluidDexT1.CollateralReserves memory reserves_) {\n        reserves_ = _getDexCollateralReservesAdjusted(dex_, pex_);\n\n        IFluidDexT1.ConstantViews2 memory constantsView2_ = IFluidDexT1(dex_).constantsView2();\n\n        // returned reserves are in 1e12 decimals -> normalize to token decimals\n        reserves_.token0RealReserves =\n            (reserves_.token0RealReserves * constantsView2_.token0DenominatorPrecision) /\n            constantsView2_.token0NumeratorPrecision;\n        reserves_.token0ImaginaryReserves =\n            (reserves_.token0ImaginaryReserves * constantsView2_.token0DenominatorPrecision) /\n            constantsView2_.token0NumeratorPrecision;\n        reserves_.token1RealReserves =\n            (reserves_.token1RealReserves * constantsView2_.token1DenominatorPrecision) /\n            constantsView2_.token1NumeratorPrecision;\n        reserves_.token1ImaginaryReserves =\n            (reserves_.token1ImaginaryReserves * constantsView2_.token1DenominatorPrecision) /\n            constantsView2_.token1NumeratorPrecision;\n    }\n\n    /// @dev Retrieves the adjusted collateral reserves for a given DEX.\n    /// @param dex_ The address of the DEX.\n    /// @param pex_ A struct containing price and exchange price information.\n    /// @return reserves_ A struct containing the adjusted collateral reserves.\n    function _getDexCollateralReservesAdjusted(\n        address dex_,\n        IFluidDexT1.PricesAndExchangePrice memory pex_\n    ) internal view returns (IFluidDexT1.CollateralReserves memory reserves_) {\n        try\n            IFluidDexT1(dex_).getCollateralReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.supplyToken0ExchangePrice,\n                pex_.supplyToken1ExchangePrice\n            )\n        returns (IFluidDexT1.CollateralReserves memory colReserves_) {\n            // returned reserves are in 1e12 decimals -> normalize to token decimals\n            reserves_ = colReserves_;\n        } catch {\n            reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n    }\n\n    /// @dev Retrieves and normalizes the debt reserves for a given DEX.\n    /// @param dex_ The address of the DEX.\n    /// @param pex_ A struct containing price and exchange price information.\n    /// @return reserves_ A struct containing the normalized debt reserves.\n    function _getDexDebtReserves(\n        address dex_,\n        IFluidDexT1.PricesAndExchangePrice memory pex_\n    ) internal view returns (IFluidDexT1.DebtReserves memory reserves_) {\n        reserves_ = _getDexDebtReservesAdjusted(dex_, pex_);\n\n        IFluidDexT1.ConstantViews2 memory constantsView2_ = IFluidDexT1(dex_).constantsView2();\n\n        // returned reserves are in 1e12 decimals -> normalize to token decimals\n        reserves_.token0Debt =\n            (reserves_.token0Debt * constantsView2_.token0DenominatorPrecision) /\n            constantsView2_.token0NumeratorPrecision;\n        reserves_.token0RealReserves =\n            (reserves_.token0RealReserves * constantsView2_.token0DenominatorPrecision) /\n            constantsView2_.token0NumeratorPrecision;\n        reserves_.token0ImaginaryReserves =\n            (reserves_.token0ImaginaryReserves * constantsView2_.token0DenominatorPrecision) /\n            constantsView2_.token0NumeratorPrecision;\n        reserves_.token1Debt =\n            (reserves_.token1Debt * constantsView2_.token1DenominatorPrecision) /\n            constantsView2_.token1NumeratorPrecision;\n        reserves_.token1RealReserves =\n            (reserves_.token1RealReserves * constantsView2_.token1DenominatorPrecision) /\n            constantsView2_.token1NumeratorPrecision;\n        reserves_.token1ImaginaryReserves =\n            (reserves_.token1ImaginaryReserves * constantsView2_.token1DenominatorPrecision) /\n            constantsView2_.token1NumeratorPrecision;\n    }\n\n    /// @dev Retrieves the adjusted debt reserves for a given DEX.\n    /// @param dex_ The address of the DEX.\n    /// @param pex_ A struct containing price and exchange price information.\n    /// @return reserves_ A struct containing the adjusted debt reserves.\n    function _getDexDebtReservesAdjusted(\n        address dex_,\n        IFluidDexT1.PricesAndExchangePrice memory pex_\n    ) internal view returns (IFluidDexT1.DebtReserves memory reserves_) {\n        try\n            IFluidDexT1(dex_).getDebtReserves(\n                pex_.geometricMean,\n                pex_.upperRange,\n                pex_.lowerRange,\n                pex_.borrowToken0ExchangePrice,\n                pex_.borrowToken1ExchangePrice\n            )\n        returns (IFluidDexT1.DebtReserves memory debtReserves_) {\n            // returned reserves are in 1e12 decimals -> normalize to token decimals\n            reserves_ = debtReserves_;\n        } catch {\n            reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n    }\n}\n\n/// @title DexConstantsViews\n/// @notice Abstract contract providing view functions for DEX constants\nabstract contract DexConstantsViews {\n    /// @notice returns all Pool constants\n    function getPoolConstantsView(address pool_) public view returns (IFluidDexT1.ConstantViews memory constantsView_) {\n        return IFluidDexT1(pool_).constantsView();\n    }\n\n    /// @notice returns all Pool constants 2\n    function getPoolConstantsView2(\n        address pool_\n    ) public view returns (IFluidDexT1.ConstantViews2 memory constantsView2_) {\n        return IFluidDexT1(pool_).constantsView2();\n    }\n\n    /// @notice Get the addresses of the tokens in a Pool\n    /// @param pool_ The address of the Pool\n    /// @return token0_ The address of token0 in the Pool\n    /// @return token1_ The address of token1 in the Pool\n    function getPoolTokens(address pool_) public view returns (address token0_, address token1_) {\n        IFluidDexT1.ConstantViews memory constantsView_ = IFluidDexT1(pool_).constantsView();\n        return (constantsView_.token0, constantsView_.token1);\n    }\n}\n\nabstract contract DexSwapLimits is Variables, Structs, DexConstantsViews {\n    address private constant WEETH = 0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee;\n    address private constant WEETHS = 0x917ceE801a67f933F2e6b33fC0cD1ED2d5909D88;\n    IZtakingPool private constant ZIRCUIT = IZtakingPool(0xF047ab4c75cebf0eB9ed34Ae2c186f3611aEAfa6);\n\n    /// @notice get the swap limits for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return limits_ A struct containing the swap limits for the DEX\n    function getDexLimits(address dex_) public view returns (DexLimits memory limits_) {\n        // additional liquidity related data such as supply amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserSupplyData memory liquidityUserSupplyDataToken0_;\n        FluidLiquidityResolverStructs.UserSupplyData memory liquidityUserSupplyDataToken1_;\n        // liquidity token related data\n        FluidLiquidityResolverStructs.OverallTokenData memory liquidityTokenData0_;\n        FluidLiquidityResolverStructs.OverallTokenData memory liquidityTokenData1_;\n        // additional liquidity related data such as borrow amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserBorrowData memory liquidityUserBorrowDataToken0_;\n        FluidLiquidityResolverStructs.UserBorrowData memory liquidityUserBorrowDataToken1_;\n\n        {\n            (address token0_, address token1_) = getPoolTokens(dex_);\n            (liquidityUserSupplyDataToken0_, liquidityTokenData0_) = LIQUIDITY_RESOLVER.getUserSupplyData(\n                dex_,\n                token0_\n            );\n            (liquidityUserSupplyDataToken1_, liquidityTokenData1_) = LIQUIDITY_RESOLVER.getUserSupplyData(\n                dex_,\n                token1_\n            );\n            (liquidityUserBorrowDataToken0_, ) = LIQUIDITY_RESOLVER.getUserBorrowData(dex_, token0_);\n            (liquidityUserBorrowDataToken1_, ) = LIQUIDITY_RESOLVER.getUserBorrowData(dex_, token1_);\n\n            // ----------------------- 1. UTILIZATION LIMITS (include liquidity layer balances) -----------------------\n            // for dex, utilization limit check is not just after borrow but also after withdraw (after any swap).\n            // for liquidity, utilization limit check is only after borrow.\n            // so for borrow, use utilization config of either liquidity or dex, whatever is smaller. for withdraw, use dex.\n\n            uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n            /// Next 10 bits => 228-237 => utilization limit of token0. Max value 1000 = 100%, if 100% then no need to check the utilization.\n            /// Next 10 bits => 238-247 => utilization limit of token1. Max value 1000 = 100%, if 100% then no need to check the utilization.\n            {\n                // TOKEN 0\n                uint256 maxUtilizationToken0Dex_ = ((dexVariables2_ >> 228) & X10) * 10; // bring to 1e2 same as liquidity layer\n                // check if max utilization at liquidity layer is smaller for combined config\n                uint256 maxUtilizationToken0Combined_ = maxUtilizationToken0Dex_;\n                if (liquidityTokenData0_.maxUtilization < maxUtilizationToken0Combined_) {\n                    maxUtilizationToken0Combined_ = liquidityTokenData0_.maxUtilization;\n                }\n\n                // calculate utilization limit amount % of total supply (with combined config for borrow)\n                uint256 maxUtilizationToken0_ = (liquidityTokenData0_.totalSupply * maxUtilizationToken0Combined_) /\n                    1e4;\n\n                if (liquidityTokenData0_.totalBorrow < maxUtilizationToken0_) {\n                    // expands to & available: amount until utilization max\n                    // get amount where currently borrowed = utilization limit of total supply. for withdraw only dex config counts.\n                    limits_.withdrawableToken0.available = maxUtilizationToken0Dex_ == 0\n                        ? 0\n                        : (1e4 * liquidityTokenData0_.totalBorrow) / maxUtilizationToken0Dex_;\n                    limits_.withdrawableToken0.available = liquidityTokenData0_.totalSupply >\n                        limits_.withdrawableToken0.available\n                        ? liquidityTokenData0_.totalSupply - limits_.withdrawableToken0.available\n                        : 0;\n                    // no expansion on utilization\n                    limits_.withdrawableToken0.expandsTo = limits_.withdrawableToken0.available;\n\n                    limits_.borrowableToken0.available = maxUtilizationToken0_ - liquidityTokenData0_.totalBorrow;\n                    // no expansion on utilization\n                    limits_.borrowableToken0.expandsTo = limits_.borrowableToken0.available;\n\n                    // balance at liquidity layer is a hard limit that can not be expanded beyond\n                    uint balanceLiquidity_ = token0_ == NATIVE_TOKEN_ADDRESS\n                        ? address(LIQUIDITY).balance\n                        : TokenInterface(token0_).balanceOf(address(LIQUIDITY));\n                    if (token0_ == WEETH) {\n                        balanceLiquidity_ += ZIRCUIT.balance(WEETH, address(LIQUIDITY));\n                    }\n                    if (token0_ == WEETHS) {\n                        balanceLiquidity_ += ZIRCUIT.balance(WEETHS, address(LIQUIDITY));\n                    }\n                    if (limits_.withdrawableToken0.expandsTo > balanceLiquidity_) {\n                        limits_.withdrawableToken0.expandsTo = balanceLiquidity_;\n                    }\n                    if (limits_.borrowableToken0.expandsTo > balanceLiquidity_) {\n                        limits_.borrowableToken0.expandsTo = balanceLiquidity_;\n                    }\n                }\n            }\n\n            {\n                // TOKEN 1\n                uint256 maxUtilizationToken1Dex_ = ((dexVariables2_ >> 238) & X10) * 10;\n                uint256 maxUtilizationToken1Combined_ = maxUtilizationToken1Dex_;\n                if (liquidityTokenData1_.maxUtilization < maxUtilizationToken1Combined_) {\n                    maxUtilizationToken1Combined_ = liquidityTokenData1_.maxUtilization;\n                }\n                uint256 maxUtilizationToken1_ = (liquidityTokenData1_.totalSupply * maxUtilizationToken1Combined_) /\n                    1e4;\n                if (liquidityTokenData1_.totalBorrow < maxUtilizationToken1_) {\n                    // expands to & available: amount until utilization max\n                    // get amount where currently borrowed = utilization limit of total supply. for withdraw only dex config counts.\n                    limits_.withdrawableToken1.available = maxUtilizationToken1Dex_ == 0\n                        ? 0\n                        : (1e4 * liquidityTokenData1_.totalBorrow) / maxUtilizationToken1Dex_;\n                    limits_.withdrawableToken1.available = liquidityTokenData1_.totalSupply >\n                        limits_.withdrawableToken1.available\n                        ? liquidityTokenData1_.totalSupply - limits_.withdrawableToken1.available\n                        : 0;\n                    // no expansion on utilization\n                    limits_.withdrawableToken1.expandsTo = limits_.withdrawableToken1.available;\n\n                    limits_.borrowableToken1.available = maxUtilizationToken1_ - liquidityTokenData1_.totalBorrow;\n                    // no expansion on utilization\n                    limits_.borrowableToken1.expandsTo = limits_.borrowableToken1.available;\n\n                    // balance at liquidity layer is a hard limit that can not be expanded beyond\n                    uint balanceLiquidity_ = token1_ == NATIVE_TOKEN_ADDRESS\n                        ? address(LIQUIDITY).balance\n                        : TokenInterface(token1_).balanceOf(address(LIQUIDITY));\n                    if (token1_ == WEETH) {\n                        balanceLiquidity_ += ZIRCUIT.balance(WEETH, address(LIQUIDITY));\n                    }\n                    if (token1_ == WEETHS) {\n                        balanceLiquidity_ += ZIRCUIT.balance(WEETHS, address(LIQUIDITY));\n                    }\n                    if (limits_.withdrawableToken1.expandsTo > balanceLiquidity_) {\n                        limits_.withdrawableToken1.expandsTo = balanceLiquidity_;\n                    }\n                    if (limits_.borrowableToken1.expandsTo > balanceLiquidity_) {\n                        limits_.borrowableToken1.expandsTo = balanceLiquidity_;\n                    }\n                }\n            }\n        }\n\n        // ----------------------- 2. WITHDRAW AND BORROW LIMITS (include liquidity layer balances) -----------------------\n\n        // expandsTo = max possible amount at full expansion\n        // expandDuration = time of expandDuration config left until maxExpansion is reached\n\n        // TOKEN 0 WITHDRAWABLE\n        {\n            uint256 expandTimeLeft_ = liquidityUserSupplyDataToken0_.lastUpdateTimestamp +\n                liquidityUserSupplyDataToken0_.expandDuration;\n            expandTimeLeft_ = block.timestamp > expandTimeLeft_ ? 0 : expandTimeLeft_ - block.timestamp;\n\n            uint256 maxWithdrawable_ = (liquidityUserSupplyDataToken0_.expandPercent *\n                liquidityUserSupplyDataToken0_.supply) / 1e4;\n            if (liquidityUserSupplyDataToken0_.withdrawable > maxWithdrawable_) {\n                // max expansion already reached or below base limit\n                maxWithdrawable_ = liquidityUserSupplyDataToken0_.withdrawable;\n                expandTimeLeft_ = 0;\n            }\n\n            if (maxWithdrawable_ <= limits_.withdrawableToken0.expandsTo) {\n                // if max withdrawable until limit is less than utilization limit, then set max withdrawable until limit as expansion limit.\n                limits_.withdrawableToken0.expandsTo = maxWithdrawable_;\n\n                expandTimeLeft_ = maxWithdrawable_ == 0\n                    ? 0\n                    : ((limits_.withdrawableToken0.expandsTo - liquidityUserSupplyDataToken0_.withdrawable) *\n                        liquidityUserSupplyDataToken0_.expandDuration) / maxWithdrawable_;\n            } else {\n                // max withdrawable expansion is limited by utilization or liquidity layer balance.\n                // recalculate the duration until that earlier limit is hit.\n                if (liquidityUserSupplyDataToken0_.withdrawable > limits_.withdrawableToken0.expandsTo) {\n                    // withdrawable amount at LiquidityResolver does not have dex utilization limit included\n                    // so this case could actually happen. if so, then adjust withdrawable and expansion is already\n                    // max reached so duration left is 0.\n                    expandTimeLeft_ = 0;\n                    liquidityUserSupplyDataToken0_.withdrawable = limits_.withdrawableToken0.expandsTo;\n                } else {\n                    // expansionPerSecond_ = maxWithdrawable_ / expandDuration;\n                    // withdrawable + expansionPerSecond_ * x = expandsTo;\n                    // so x = (expandsTo - withdrawable) / expansionPerSecond_;\n                    // so x = (expandsTo - withdrawable) / (maxWithdrawable_ / expandDuration);\n                    // so x = (expandsTo - withdrawable) * expandDuration / maxWithdrawable_;\n                    expandTimeLeft_ = maxWithdrawable_ == 0\n                        ? 0\n                        : ((limits_.withdrawableToken0.expandsTo - liquidityUserSupplyDataToken0_.withdrawable) *\n                            liquidityUserSupplyDataToken0_.expandDuration) / maxWithdrawable_;\n                }\n            }\n            limits_.withdrawableToken0.expandDuration = expandTimeLeft_;\n        }\n\n        // TOKEN 1 WITHDRAWABLE\n        {\n            uint256 expandTimeLeft_ = liquidityUserSupplyDataToken1_.lastUpdateTimestamp +\n                liquidityUserSupplyDataToken1_.expandDuration;\n            expandTimeLeft_ = block.timestamp > expandTimeLeft_ ? 0 : expandTimeLeft_ - block.timestamp;\n\n            uint256 maxWithdrawable_ = (liquidityUserSupplyDataToken1_.expandPercent *\n                liquidityUserSupplyDataToken1_.supply) / 1e4;\n            if (liquidityUserSupplyDataToken1_.withdrawable > maxWithdrawable_) {\n                // max expansion already reached or below base limit\n                maxWithdrawable_ = liquidityUserSupplyDataToken1_.withdrawable;\n                expandTimeLeft_ = 0;\n            }\n\n            if (maxWithdrawable_ <= limits_.withdrawableToken1.expandsTo) {\n                // if max withdrawable until limit is less than utilization limit, then set max withdrawable until limit as expansion limit.\n                limits_.withdrawableToken1.expandsTo = maxWithdrawable_;\n\n                expandTimeLeft_ = maxWithdrawable_ == 0\n                    ? 0\n                    : ((limits_.withdrawableToken1.expandsTo - liquidityUserSupplyDataToken1_.withdrawable) *\n                        liquidityUserSupplyDataToken1_.expandDuration) / maxWithdrawable_;\n            } else {\n                // max withdrawable expansion is limited by utilization or liquidity layer balance.\n                // recalculate the duration until that earlier limit is hit.\n                if (liquidityUserSupplyDataToken1_.withdrawable > limits_.withdrawableToken1.expandsTo) {\n                    // withdrawable amount at LiquidityResolver does not have dex utilization limit included\n                    // so this case could actually happen. if so, then adjust withdrawable and expansion is already\n                    // max reached so duration left is 0.\n                    expandTimeLeft_ = 0;\n                    liquidityUserSupplyDataToken1_.withdrawable = limits_.withdrawableToken1.expandsTo;\n                } else {\n                    expandTimeLeft_ = maxWithdrawable_ == 0\n                        ? 0\n                        : ((limits_.withdrawableToken1.expandsTo - liquidityUserSupplyDataToken1_.withdrawable) *\n                            liquidityUserSupplyDataToken1_.expandDuration) / maxWithdrawable_;\n                }\n            }\n            limits_.withdrawableToken1.expandDuration = expandTimeLeft_;\n        }\n\n        // TOKEN 0 BORROWABLE\n        {\n            uint256 expandTimeLeft_ = liquidityUserBorrowDataToken0_.lastUpdateTimestamp +\n                liquidityUserBorrowDataToken0_.expandDuration;\n            expandTimeLeft_ = block.timestamp > expandTimeLeft_ ? 0 : expandTimeLeft_ - block.timestamp;\n\n            uint256 maxBorrowable_ = (liquidityUserBorrowDataToken0_.expandPercent *\n                liquidityUserBorrowDataToken0_.borrow) / 1e4;\n            {\n                // consider max hard borrow limit\n                uint256 maxBorrowableUntilHardLimit_ = liquidityUserBorrowDataToken0_.maxBorrowLimit >\n                    liquidityUserBorrowDataToken0_.borrow\n                    ? liquidityUserBorrowDataToken0_.maxBorrowLimit - liquidityUserBorrowDataToken0_.borrow\n                    : 0;\n                if (limits_.borrowableToken0.expandsTo > maxBorrowableUntilHardLimit_) {\n                    limits_.borrowableToken0.expandsTo = maxBorrowableUntilHardLimit_;\n                }\n            }\n            if (liquidityUserBorrowDataToken0_.borrowable > maxBorrowable_) {\n                // max expansion already reached or below base limit\n                maxBorrowable_ = liquidityUserBorrowDataToken0_.borrowable;\n                expandTimeLeft_ = 0;\n            }\n\n            if (maxBorrowable_ <= limits_.borrowableToken0.expandsTo) {\n                // if max borrowable until limit is less than utilization limit, then set max borrowable until limit as expansion limit.\n                limits_.borrowableToken0.expandsTo = maxBorrowable_;\n\n                // expansionPerSecond_ = maxBorrowable_ / expandDuration;\n                // borrowable + expansionPerSecond_ * x = expandsTo;\n                expandTimeLeft_ = maxBorrowable_ == 0\n                    ? 0\n                    : ((limits_.borrowableToken0.expandsTo - liquidityUserBorrowDataToken0_.borrowable) *\n                        liquidityUserBorrowDataToken0_.expandDuration) / maxBorrowable_;\n            } else {\n                // max borrowable expansion is limited by utilization or liquidity layer balance.\n                // recalculate the duration until that earlier limit is hit.\n                if (liquidityUserBorrowDataToken0_.borrowable > limits_.borrowableToken0.expandsTo) {\n                    // borrowable amount at LiquidityResolver does not have dex utilization limit included\n                    // so this case could actually happen. if so, then adjust borrowable and expansion is already\n                    // max reached so duration left is 0.\n                    expandTimeLeft_ = 0;\n                    liquidityUserBorrowDataToken0_.borrowable = limits_.borrowableToken0.expandsTo;\n                } else {\n                    expandTimeLeft_ = maxBorrowable_ == 0\n                        ? 0\n                        : ((limits_.borrowableToken0.expandsTo - liquidityUserBorrowDataToken0_.borrowable) *\n                            liquidityUserBorrowDataToken0_.expandDuration) / maxBorrowable_;\n                }\n            }\n            limits_.borrowableToken0.expandDuration = expandTimeLeft_;\n        }\n\n        // TOKEN 1 BORROWABLE\n        {\n            uint256 expandTimeLeft_ = liquidityUserBorrowDataToken1_.lastUpdateTimestamp +\n                liquidityUserBorrowDataToken1_.expandDuration;\n            expandTimeLeft_ = block.timestamp > expandTimeLeft_ ? 0 : expandTimeLeft_ - block.timestamp;\n\n            uint256 maxBorrowable_ = (liquidityUserBorrowDataToken1_.expandPercent *\n                liquidityUserBorrowDataToken1_.borrow) / 1e4;\n            {\n                // consider max hard borrow limit\n                uint256 maxBorrowableUntilHardLimit_ = liquidityUserBorrowDataToken1_.maxBorrowLimit >\n                    liquidityUserBorrowDataToken1_.borrow\n                    ? liquidityUserBorrowDataToken1_.maxBorrowLimit - liquidityUserBorrowDataToken1_.borrow\n                    : 0;\n                if (limits_.borrowableToken1.expandsTo > maxBorrowableUntilHardLimit_) {\n                    limits_.borrowableToken1.expandsTo = maxBorrowableUntilHardLimit_;\n                }\n            }\n            if (liquidityUserBorrowDataToken1_.borrowable > maxBorrowable_) {\n                // max expansion already reached or below base limit\n                maxBorrowable_ = liquidityUserBorrowDataToken1_.borrowable;\n                expandTimeLeft_ = 0;\n            }\n\n            if (maxBorrowable_ <= limits_.borrowableToken1.expandsTo) {\n                // if max borrowable until limit is less than utilization limit, then set max borrowable until limit as expansion limit.\n                limits_.borrowableToken1.expandsTo = maxBorrowable_;\n\n                // expansionPerSecond_ = maxBorrowable_ / expandDuration;\n                // borrowable + expansionPerSecond_ * x = expandsTo;\n                expandTimeLeft_ = maxBorrowable_ == 0\n                    ? 0\n                    : ((limits_.borrowableToken1.expandsTo - liquidityUserBorrowDataToken1_.borrowable) *\n                        liquidityUserBorrowDataToken1_.expandDuration) / maxBorrowable_;\n            } else {\n                // max borrowable expansion is limited by utilization or liquidity layer balance.\n                // recalculate the duration until that earlier limit is hit.\n                if (liquidityUserBorrowDataToken1_.borrowable > limits_.borrowableToken1.expandsTo) {\n                    // borrowable amount at LiquidityResolver does not have dex utilization limit included\n                    // so this case could actually happen. if so, then adjust borrowable and expansion is already\n                    // max reached so duration left is 0.\n                    expandTimeLeft_ = 0;\n                    liquidityUserBorrowDataToken1_.borrowable = limits_.borrowableToken1.expandsTo;\n                } else {\n                    expandTimeLeft_ = maxBorrowable_ == 0\n                        ? 0\n                        : ((limits_.borrowableToken1.expandsTo - liquidityUserBorrowDataToken1_.borrowable) *\n                            liquidityUserBorrowDataToken1_.expandDuration) / maxBorrowable_;\n                }\n            }\n            limits_.borrowableToken1.expandDuration = expandTimeLeft_;\n        }\n\n        // for available amounts, set withdrawable / borrowable (incl. liquidity balances) if less than available until utilization\n        if (liquidityUserSupplyDataToken1_.withdrawable < limits_.withdrawableToken0.available) {\n            limits_.withdrawableToken0.available = liquidityUserSupplyDataToken0_.withdrawable;\n        }\n        if (liquidityUserSupplyDataToken1_.withdrawable < limits_.withdrawableToken1.available) {\n            limits_.withdrawableToken1.available = liquidityUserSupplyDataToken1_.withdrawable;\n        }\n        if (liquidityUserBorrowDataToken0_.borrowable < limits_.borrowableToken0.available) {\n            limits_.borrowableToken0.available = liquidityUserBorrowDataToken0_.borrowable;\n        }\n        if (liquidityUserBorrowDataToken1_.borrowable < limits_.borrowableToken1.available) {\n            limits_.borrowableToken1.available = liquidityUserBorrowDataToken1_.borrowable;\n        }\n    }\n}\n\nabstract contract DexActionEstimates is DexPublicViews, DexSwapLimits {\n    address private constant ADDRESS_DEAD = 0x000000000000000000000000000000000000dEaD;\n\n    /// @param t total amount in\n    /// @param x imaginary reserves of token out of collateral\n    /// @param y imaginary reserves of token in of collateral\n    /// @param x2 imaginary reserves of token out of debt\n    /// @param y2 imaginary reserves of token in of debt\n    /// @return a_ how much swap should go through collateral pool. Remaining will go from debt\n    /// note if a < 0 then entire trade route through debt pool and debt pool arbitrage with col pool\n    /// note if a > t then entire trade route through col pool and col pool arbitrage with debt pool\n    /// note if a > 0 & a < t then swap will route through both pools\n    function _swapRoutingIn(uint t, uint x, uint y, uint x2, uint y2) private pure returns (int a_) {\n        // Main equations:\n        // 1. out = x * a / (y + a)\n        // 2. out2 = x2 * (t - a) / (y2 + (t - a))\n        // final price should be same\n        // 3. (y + a) / (x - out) = (y2 + (t - a)) / (x2 - out2)\n        // derivation: https://chatgpt.com/share/dce6f381-ee5f-4d5f-b6ea-5996e84d5b57\n\n        // adding 1e18 precision\n        uint xyRoot_ = FixedPointMathLib.sqrt(x * y * 1e18);\n        uint x2y2Root_ = FixedPointMathLib.sqrt(x2 * y2 * 1e18);\n\n        a_ = (int(y2 * xyRoot_ + t * xyRoot_) - int(y * x2y2Root_)) / int(xyRoot_ + x2y2Root_);\n    }\n\n    /// @param t total amount out\n    /// @param x imaginary reserves of token in of collateral\n    /// @param y imaginary reserves of token out of collateral\n    /// @param x2 imaginary reserves of token in of debt\n    /// @param y2 imaginary reserves of token out of debt\n    /// @return a_ how much swap should go through collateral pool. Remaining will go from debt\n    /// note if a < 0 then entire trade route through debt pool and debt pool arbitrage with col pool\n    /// note if a > t then entire trade route through col pool and col pool arbitrage with debt pool\n    /// note if a > 0 & a < t then swap will route through both pools\n    function _swapRoutingOut(uint t, uint x, uint y, uint x2, uint y2) private pure returns (int a_) {\n        // Main equations:\n        // 1. in = (x * a) / (y - a)\n        // 2. in2 = (x2 * (t - a)) / (y2 - (t - a))\n        // final price should be same\n        // 3. (y - a) / (x + in) = (y2 - (t - a)) / (x2 + in2)\n        // derivation: https://chatgpt.com/share/6585bc28-841f-49ec-aea2-1e5c5b7f4fa9\n\n        // adding 1e18 precision\n        uint xyRoot_ = FixedPointMathLib.sqrt(x * y * 1e18);\n        uint x2y2Root_ = FixedPointMathLib.sqrt(x2 * y2 * 1e18);\n\n        // 1e18 precision gets cancelled out in division\n        a_ = (int(t * xyRoot_ + y * x2y2Root_) - int(y2 * xyRoot_)) / int(xyRoot_ + x2y2Root_);\n    }\n\n    /// @dev Given an input amount of asset and pair reserves, returns the maximum output amount of the other asset\n    /// @param amountIn_ The amount of input asset.\n    /// @param iReserveIn_ Imaginary token reserve with input amount.\n    /// @param iReserveOut_ Imaginary token reserve of output amount.\n    function _getAmountOut(\n        uint256 amountIn_,\n        uint iReserveIn_,\n        uint iReserveOut_\n    ) private pure returns (uint256 amountOut_) {\n        unchecked {\n            // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\n            uint256 numerator_ = amountIn_ * iReserveOut_;\n            uint256 denominator_ = iReserveIn_ + amountIn_;\n\n            // Using the swap formula: (AmountIn * iReserveY) / (iReserveX + AmountIn)\n            amountOut_ = numerator_ / denominator_;\n        }\n    }\n\n    /// @dev Given an output amount of asset and pair reserves, returns the input amount of the other asset\n    /// @param amountOut_ Desired output amount of the asset.\n    /// @param iReserveIn_ Imaginary token reserve of input amount.\n    /// @param iReserveOut_ Imaginary token reserve of output amount.\n    function _getAmountIn(\n        uint256 amountOut_,\n        uint iReserveIn_,\n        uint iReserveOut_\n    ) private pure returns (uint256 amountIn_) {\n        // Both numerator and denominator are scaled to 1e6 to factor in fee scaling.\n        uint256 numerator_ = amountOut_ * iReserveIn_;\n        uint256 denominator_ = iReserveOut_ - amountOut_;\n\n        // Using the swap formula: (AmountOut * iReserveX) / (iReserveY - AmountOut)\n        amountIn_ = numerator_ / denominator_;\n    }\n\n    struct EstimateMemoryVars {\n        uint256 colTokenInImaginaryReserves;\n        uint256 colTokenOutImaginaryReserves;\n        uint256 debtTokenInImaginaryReserves;\n        uint256 debtTokenOutImaginaryReserves;\n        uint256 amountOutCollateralAdjusted;\n        uint256 amountOutDebtAdjusted;\n        uint256 amountInCollateralAdjusted;\n        uint256 amountInDebtAdjusted;\n    }\n\n    /// @notice estimates swap IN tokens execution\n    /// @param dex_ Dex pool\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function estimateSwapIn(\n        address dex_,\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_\n    ) public payable returns (uint256 amountOut_) {\n        try IFluidDexT1(dex_).swapIn{ value: msg.value }(swap0to1_, amountIn_, amountOutMin_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (amountOut_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSwapResult.selector);\n        }\n\n        EstimateMemoryVars memory e_;\n        {\n            IFluidDexT1.CollateralReserves memory colReserves_ = getDexCollateralReservesAdjusted(dex_);\n            IFluidDexT1.DebtReserves memory debtReserves_ = getDexDebtReservesAdjusted(dex_);\n            if (swap0to1_) {\n                e_.colTokenInImaginaryReserves = colReserves_.token0ImaginaryReserves;\n                e_.colTokenOutImaginaryReserves = colReserves_.token1ImaginaryReserves;\n                e_.debtTokenInImaginaryReserves = debtReserves_.token0ImaginaryReserves;\n                e_.debtTokenOutImaginaryReserves = debtReserves_.token1ImaginaryReserves;\n            } else {\n                e_.colTokenInImaginaryReserves = colReserves_.token1ImaginaryReserves;\n                e_.colTokenOutImaginaryReserves = colReserves_.token0ImaginaryReserves;\n                e_.debtTokenInImaginaryReserves = debtReserves_.token1ImaginaryReserves;\n                e_.debtTokenOutImaginaryReserves = debtReserves_.token0ImaginaryReserves;\n            }\n        }\n\n        IFluidDexT1.ConstantViews2 memory constantsView2_ = IFluidDexT1(dex_).constantsView2();\n\n        {\n            int256 swapRoutingAmt_;\n            uint256 poolFee_;\n            uint256 amountInAdjusted_;\n            // bring amount in to 1e12 decimals adjusted\n            if (swap0to1_) {\n                amountInAdjusted_ =\n                    (amountIn_ * constantsView2_.token0NumeratorPrecision) /\n                    constantsView2_.token0DenominatorPrecision;\n            } else {\n                amountInAdjusted_ =\n                    (amountIn_ * constantsView2_.token1NumeratorPrecision) /\n                    constantsView2_.token1DenominatorPrecision;\n            }\n\n            {\n                uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n                poolFee_ = (dexVariables2_ >> 2) & X17;\n                bool colPoolEnabled_ = (dexVariables2_ & 1) == 1;\n                bool debtPoolEnabled_ = (dexVariables2_ & 2) == 2;\n                if (colPoolEnabled_ && debtPoolEnabled_) {\n                    swapRoutingAmt_ = _swapRoutingIn(\n                        amountInAdjusted_,\n                        e_.colTokenOutImaginaryReserves,\n                        e_.colTokenInImaginaryReserves,\n                        e_.debtTokenOutImaginaryReserves,\n                        e_.debtTokenInImaginaryReserves\n                    );\n                } else if (debtPoolEnabled_) {\n                    swapRoutingAmt_ = -1; // Route from debt pool\n                } else if (colPoolEnabled_) {\n                    swapRoutingAmt_ = int256(amountInAdjusted_) + 1; // Route from collateral pool\n                } else {\n                    revert(\"No pools are enabled\");\n                }\n            }\n\n            if (swapRoutingAmt_ <= 0) {\n                // Entire trade routes through debt pool\n                e_.amountInDebtAdjusted = amountInAdjusted_;\n                e_.amountOutDebtAdjusted = _getAmountOut(\n                    ((amountInAdjusted_ * (1e6 - poolFee_)) / 1e6),\n                    e_.debtTokenInImaginaryReserves,\n                    e_.debtTokenOutImaginaryReserves\n                );\n            } else if (swapRoutingAmt_ >= int256(amountInAdjusted_)) {\n                // Entire trade routes through collateral pool\n                e_.amountInCollateralAdjusted = amountInAdjusted_;\n                e_.amountOutCollateralAdjusted = _getAmountOut(\n                    ((amountInAdjusted_ * (1e6 - poolFee_)) / 1e6),\n                    e_.colTokenInImaginaryReserves,\n                    e_.colTokenOutImaginaryReserves\n                );\n            } else {\n                // Trade routes through both pools\n                e_.amountInCollateralAdjusted = uint(swapRoutingAmt_);\n                e_.amountInDebtAdjusted = amountInAdjusted_ - e_.amountInCollateralAdjusted;\n\n                e_.amountOutCollateralAdjusted = _getAmountOut(\n                    ((e_.amountInCollateralAdjusted * (1e6 - poolFee_)) / 1e6),\n                    e_.colTokenInImaginaryReserves,\n                    e_.colTokenOutImaginaryReserves\n                );\n\n                e_.amountOutDebtAdjusted = _getAmountOut(\n                    ((e_.amountInDebtAdjusted * (1e6 - poolFee_)) / 1e6),\n                    e_.debtTokenInImaginaryReserves,\n                    e_.debtTokenOutImaginaryReserves\n                );\n            }\n        }\n\n        {\n            uint256 borrowableAdjusted_;\n            uint256 withdrawableAdjusted_;\n            DexLimits memory limits_ = getDexLimits(dex_);\n\n            // bring amount to 1e12 decimals adjusted\n            if (swap0to1_) {\n                borrowableAdjusted_ =\n                    (limits_.borrowableToken1.available * constantsView2_.token1NumeratorPrecision) /\n                    constantsView2_.token1DenominatorPrecision;\n                withdrawableAdjusted_ =\n                    (limits_.withdrawableToken1.available * constantsView2_.token1NumeratorPrecision) /\n                    constantsView2_.token1DenominatorPrecision;\n            } else {\n                borrowableAdjusted_ =\n                    (limits_.borrowableToken0.available * constantsView2_.token0NumeratorPrecision) /\n                    constantsView2_.token0DenominatorPrecision;\n                withdrawableAdjusted_ =\n                    (limits_.withdrawableToken0.available * constantsView2_.token0NumeratorPrecision) /\n                    constantsView2_.token0DenominatorPrecision;\n            }\n\n            if (e_.amountOutDebtAdjusted > borrowableAdjusted_) {\n                return 0;\n            }\n            if (e_.amountOutCollateralAdjusted > withdrawableAdjusted_) {\n                return 0;\n            }\n        }\n\n        uint256 oldPrice_;\n        uint256 newPrice_;\n        // from whatever pool higher amount of swap is routing we are taking that as final price, does not matter much because both pools final price should be same\n        if (e_.amountInCollateralAdjusted > e_.amountInDebtAdjusted) {\n            // new pool price from col pool\n            oldPrice_ = swap0to1_\n                ? (e_.colTokenOutImaginaryReserves * 1e27) / (e_.colTokenInImaginaryReserves)\n                : (e_.colTokenInImaginaryReserves * 1e27) / (e_.colTokenOutImaginaryReserves);\n            newPrice_ = swap0to1_\n                ? ((e_.colTokenOutImaginaryReserves - e_.amountOutCollateralAdjusted) * 1e27) /\n                    (e_.colTokenInImaginaryReserves + e_.amountInCollateralAdjusted)\n                : ((e_.colTokenInImaginaryReserves + e_.amountInCollateralAdjusted) * 1e27) /\n                    (e_.colTokenOutImaginaryReserves - e_.amountOutCollateralAdjusted);\n        } else {\n            // new pool price from debt pool\n            oldPrice_ = swap0to1_\n                ? (e_.debtTokenOutImaginaryReserves * 1e27) / (e_.debtTokenInImaginaryReserves)\n                : (e_.debtTokenInImaginaryReserves * 1e27) / (e_.debtTokenOutImaginaryReserves);\n            newPrice_ = swap0to1_\n                ? ((e_.debtTokenOutImaginaryReserves - e_.amountOutDebtAdjusted) * 1e27) /\n                    (e_.debtTokenInImaginaryReserves + e_.amountInDebtAdjusted)\n                : ((e_.debtTokenInImaginaryReserves + e_.amountInDebtAdjusted) * 1e27) /\n                    (e_.debtTokenOutImaginaryReserves - e_.amountOutDebtAdjusted);\n        }\n\n        uint256 priceDiff_ = oldPrice_ > newPrice_ ? oldPrice_ - newPrice_ : newPrice_ - oldPrice_;\n        if (priceDiff_ > ((oldPrice_ * ORACLE_LIMIT) / 1e18)) {\n            // if price diff is > 5% then swap would revert.\n            return 0;\n        }\n\n        return amountOut_;\n    }\n\n    /// @notice estimates swap OUT tokens execution\n    /// @param dex_ Dex pool\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function estimateSwapOut(\n        address dex_,\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_\n    ) public payable returns (uint256 amountIn_) {\n        try IFluidDexT1(dex_).swapOut{ value: msg.value }(swap0to1_, amountOut_, amountInMax_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (amountIn_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSwapResult.selector);\n        }\n\n        EstimateMemoryVars memory e_;\n        {\n            IFluidDexT1.CollateralReserves memory colReserves_ = getDexCollateralReservesAdjusted(dex_);\n            IFluidDexT1.DebtReserves memory debtReserves_ = getDexDebtReservesAdjusted(dex_);\n            if (swap0to1_) {\n                e_.colTokenInImaginaryReserves = colReserves_.token0ImaginaryReserves;\n                e_.colTokenOutImaginaryReserves = colReserves_.token1ImaginaryReserves;\n                e_.debtTokenInImaginaryReserves = debtReserves_.token0ImaginaryReserves;\n                e_.debtTokenOutImaginaryReserves = debtReserves_.token1ImaginaryReserves;\n            } else {\n                e_.colTokenInImaginaryReserves = colReserves_.token1ImaginaryReserves;\n                e_.colTokenOutImaginaryReserves = colReserves_.token0ImaginaryReserves;\n                e_.debtTokenInImaginaryReserves = debtReserves_.token1ImaginaryReserves;\n                e_.debtTokenOutImaginaryReserves = debtReserves_.token0ImaginaryReserves;\n            }\n        }\n\n        IFluidDexT1.ConstantViews2 memory constantsView2_ = IFluidDexT1(dex_).constantsView2();\n\n        {\n            int256 swapRoutingAmt_;\n            uint256 poolFee_;\n            uint256 amountOutAdjusted_;\n            // bring amount in to 1e12 decimals adjusted\n            if (swap0to1_) {\n                amountOutAdjusted_ =\n                    (amountOut_ * constantsView2_.token1NumeratorPrecision) /\n                    constantsView2_.token1DenominatorPrecision;\n            } else {\n                amountOutAdjusted_ =\n                    (amountOut_ * constantsView2_.token0NumeratorPrecision) /\n                    constantsView2_.token0DenominatorPrecision;\n            }\n\n            {\n                uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n                poolFee_ = (dexVariables2_ >> 2) & X17;\n                bool colPoolEnabled_ = (dexVariables2_ & 1) == 1;\n                bool debtPoolEnabled_ = (dexVariables2_ & 2) == 2;\n                if (colPoolEnabled_ && debtPoolEnabled_) {\n                    swapRoutingAmt_ = _swapRoutingOut(\n                        amountOutAdjusted_,\n                        e_.colTokenInImaginaryReserves,\n                        e_.colTokenOutImaginaryReserves,\n                        e_.debtTokenInImaginaryReserves,\n                        e_.debtTokenOutImaginaryReserves\n                    );\n                } else if (debtPoolEnabled_) {\n                    swapRoutingAmt_ = -1; // Route from debt pool\n                } else if (colPoolEnabled_) {\n                    swapRoutingAmt_ = int256(amountOutAdjusted_) + 1; // Route from collateral pool\n                } else {\n                    revert(\"No pools are enabled\");\n                }\n            }\n\n            if (swapRoutingAmt_ <= 0) {\n                // Entire trade routes through debt pool\n                e_.amountOutDebtAdjusted = amountOutAdjusted_;\n                e_.amountInDebtAdjusted = _getAmountIn(\n                    e_.amountOutDebtAdjusted,\n                    e_.debtTokenInImaginaryReserves,\n                    e_.debtTokenOutImaginaryReserves\n                );\n                e_.amountInDebtAdjusted = (e_.amountInDebtAdjusted * 1e6) / (1e6 - poolFee_);\n            } else if (swapRoutingAmt_ >= int256(amountOutAdjusted_)) {\n                // Entire trade routes through collateral pool\n                e_.amountOutCollateralAdjusted = amountOutAdjusted_;\n                e_.amountInCollateralAdjusted = _getAmountIn(\n                    e_.amountOutCollateralAdjusted,\n                    e_.colTokenInImaginaryReserves,\n                    e_.colTokenOutImaginaryReserves\n                );\n                e_.amountInCollateralAdjusted = (e_.amountInCollateralAdjusted * 1e6) / (1e6 - poolFee_);\n            } else {\n                // Trade routes through both pools\n                e_.amountOutCollateralAdjusted = uint(swapRoutingAmt_);\n                e_.amountOutDebtAdjusted = amountOutAdjusted_ - e_.amountOutCollateralAdjusted;\n\n                e_.amountInCollateralAdjusted = _getAmountIn(\n                    e_.amountOutCollateralAdjusted,\n                    e_.colTokenInImaginaryReserves,\n                    e_.colTokenOutImaginaryReserves\n                );\n                e_.amountInCollateralAdjusted = (e_.amountInCollateralAdjusted * 1e6) / (1e6 - poolFee_);\n\n                e_.amountInDebtAdjusted = _getAmountIn(\n                    e_.amountOutDebtAdjusted,\n                    e_.debtTokenInImaginaryReserves,\n                    e_.debtTokenOutImaginaryReserves\n                );\n                e_.amountInDebtAdjusted = (e_.amountInDebtAdjusted * 1e6) / (1e6 - poolFee_);\n            }\n        }\n\n        {\n            uint256 borrowableAdjusted_;\n            uint256 withdrawableAdjusted_;\n            DexLimits memory limits_ = getDexLimits(dex_);\n\n            // bring amount to 1e12 decimals adjusted\n            if (swap0to1_) {\n                borrowableAdjusted_ =\n                    (limits_.borrowableToken1.available * constantsView2_.token1NumeratorPrecision) /\n                    constantsView2_.token1DenominatorPrecision;\n                withdrawableAdjusted_ =\n                    (limits_.withdrawableToken1.available * constantsView2_.token1NumeratorPrecision) /\n                    constantsView2_.token1DenominatorPrecision;\n            } else {\n                borrowableAdjusted_ =\n                    (limits_.borrowableToken0.available * constantsView2_.token0NumeratorPrecision) /\n                    constantsView2_.token0DenominatorPrecision;\n                withdrawableAdjusted_ =\n                    (limits_.withdrawableToken0.available * constantsView2_.token0NumeratorPrecision) /\n                    constantsView2_.token0DenominatorPrecision;\n            }\n\n            if (e_.amountOutDebtAdjusted > borrowableAdjusted_) {\n                return type(uint256).max;\n            }\n            if (e_.amountOutCollateralAdjusted > withdrawableAdjusted_) {\n                return type(uint256).max;\n            }\n        }\n\n        uint256 oldPrice_;\n        uint256 newPrice_;\n        // from whatever pool higher amount of swap is routing we are taking that as final price, does not matter much because both pools final price should be same\n        if (e_.amountOutCollateralAdjusted > e_.amountOutDebtAdjusted) {\n            // new pool price from col pool\n            oldPrice_ = swap0to1_\n                ? (e_.colTokenOutImaginaryReserves * 1e27) / (e_.colTokenInImaginaryReserves)\n                : (e_.colTokenInImaginaryReserves * 1e27) / (e_.colTokenOutImaginaryReserves);\n            newPrice_ = swap0to1_\n                ? ((e_.colTokenOutImaginaryReserves - e_.amountOutCollateralAdjusted) * 1e27) /\n                    (e_.colTokenInImaginaryReserves + e_.amountInCollateralAdjusted)\n                : ((e_.colTokenInImaginaryReserves + e_.amountInCollateralAdjusted) * 1e27) /\n                    (e_.colTokenOutImaginaryReserves - e_.amountOutCollateralAdjusted);\n        } else {\n            // new pool price from debt pool\n            oldPrice_ = swap0to1_\n                ? (e_.debtTokenOutImaginaryReserves * 1e27) / (e_.debtTokenInImaginaryReserves)\n                : (e_.debtTokenInImaginaryReserves * 1e27) / (e_.debtTokenOutImaginaryReserves);\n            newPrice_ = swap0to1_\n                ? ((e_.debtTokenOutImaginaryReserves - e_.amountOutDebtAdjusted) * 1e27) /\n                    (e_.debtTokenInImaginaryReserves + e_.amountInDebtAdjusted)\n                : ((e_.debtTokenInImaginaryReserves + e_.amountInDebtAdjusted) * 1e27) /\n                    (e_.debtTokenOutImaginaryReserves - e_.amountOutDebtAdjusted);\n        }\n\n        uint256 priceDiff_ = oldPrice_ > newPrice_ ? oldPrice_ - newPrice_ : newPrice_ - oldPrice_;\n        if (priceDiff_ > ((oldPrice_ * ORACLE_LIMIT) / 1e18)) {\n            // if price diff is > 5% then swap would revert.\n            return type(uint256).max;\n        }\n\n        return amountIn_;\n    }\n\n    function _decodeLowLevelUint1x(\n        bytes memory lowLevelData_,\n        bytes4 targetErrorSelector_\n    ) internal pure returns (uint value1_) {\n        if (lowLevelData_.length < 36) {\n            return 0;\n        }\n\n        bytes4 errorSelector_;\n        assembly {\n            // Extract the selector from the error data\n            errorSelector_ := mload(add(lowLevelData_, 0x20))\n        }\n        if (errorSelector_ == targetErrorSelector_) {\n            assembly {\n                value1_ := mload(add(lowLevelData_, 36))\n            }\n        }\n        // else => values remain 0\n    }\n}\n\n/// @notice Fluid Dex Reserves resolver\n/// Implements various view-only methods to give easy access to Dex protocol reserves data.\ncontract FluidDexReservesResolver is DexFactoryViews, DexActionEstimates {\n    constructor(\n        address factory_,\n        address liquidity_,\n        address liquidityResolver_\n    ) Variables(factory_, liquidity_, liquidityResolver_) {}\n\n    /// @notice Get a Pool's address and its token addresses\n    /// @param poolId_ The ID of the Pool\n    /// @return pool_ The Pool data\n    function getPool(uint256 poolId_) public view returns (Pool memory pool_) {\n        address poolAddress_ = getPoolAddress(poolId_);\n        (address token0_, address token1_) = getPoolTokens(poolAddress_);\n        return Pool(poolAddress_, token0_, token1_, getPoolFee(poolAddress_));\n    }\n\n    /// @notice Get a Pool's fee\n    /// @param pool_ The Pool address\n    /// @return fee_ The Pool fee as 1% = 10000\n    function getPoolFee(address pool_) public view returns (uint256 fee_) {\n        uint256 dexVariables2_ = IFluidDexT1(pool_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        return (dexVariables2_ >> 2) & X17;\n    }\n\n    /// @notice Get an array of all Pool addresses and their token addresses\n    /// @return pools_ An array containing all Pool data\n    function getAllPools() public view returns (Pool[] memory pools_) {\n        uint256 totalPools_ = getTotalPools();\n        pools_ = new Pool[](totalPools_);\n        for (uint256 i; i < totalPools_; i++) {\n            pools_[i] = getPool(i + 1);\n        }\n    }\n\n    /// @notice Get the token addresses, collateral reserves, and debt reserves for a given Pool address\n    /// @param pool_ The Pool address\n    /// @return poolReserves_ The Pool data with reserves.\n    /// @dev expected to be called via callStatic\n    function getPoolReserves(address pool_) public returns (PoolWithReserves memory poolReserves_) {\n        (poolReserves_.token0, poolReserves_.token1) = getPoolTokens(pool_);\n\n        try this.getDexPricesAndExchangePrices(pool_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            poolReserves_.centerPrice = pex_.centerPrice;\n            poolReserves_.collateralReserves = _getDexCollateralReserves(pool_, pex_);\n            poolReserves_.debtReserves = _getDexDebtReserves(pool_, pex_);\n        } catch {\n            poolReserves_.collateralReserves = getDexCollateralReserves(pool_);\n            poolReserves_.debtReserves = getDexDebtReserves(pool_);\n        }\n\n        poolReserves_.pool = pool_;\n        poolReserves_.fee = getPoolFee(pool_);\n\n        poolReserves_.limits = getDexLimits(pool_);\n    }\n\n    /// @notice Get an array of Pool addresses, their token addresses, collateral reserves, and debt reserves for a given array of Pool addresses\n    /// @param pools_ The array of Pool addresses\n    /// @return poolsReserves_ An array containing all Pool data with reserves\n    /// @dev expected to be called via callStatic\n    function getPoolsReserves(address[] memory pools_) public returns (PoolWithReserves[] memory poolsReserves_) {\n        poolsReserves_ = new PoolWithReserves[](pools_.length);\n        for (uint256 i; i < pools_.length; i++) {\n            poolsReserves_[i] = getPoolReserves(pools_[i]);\n        }\n    }\n\n    /// @notice Get an array of all Pool addresses, their token addresses, collateral reserves, and debt reserves\n    /// @return poolsReserves_ An array containing all Pool data with reserves\n    /// @dev expected to be called via callStatic\n    function getAllPoolsReserves() public returns (PoolWithReserves[] memory poolsReserves_) {\n        return getPoolsReserves(getAllPoolAddresses());\n    }\n\n    /// @notice Get the token addresses, adjusted collateral reserves, and adjusted debt reserves for a given Pool address\n    /// @param pool_ The Pool address\n    /// @return poolReserves_ The Pool data with adjusted reserves scaled to 1e12. balanceTokens are in token decimals.\n    /// @dev expected to be called via callStatic\n    function getPoolReservesAdjusted(address pool_) public returns (PoolWithReserves memory poolReserves_) {\n        (poolReserves_.token0, poolReserves_.token1) = getPoolTokens(pool_);\n\n        try this.getDexPricesAndExchangePrices(pool_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            poolReserves_.centerPrice = pex_.centerPrice;\n            poolReserves_.collateralReserves = _getDexCollateralReservesAdjusted(pool_, pex_);\n            poolReserves_.debtReserves = _getDexDebtReservesAdjusted(pool_, pex_);\n        } catch {\n            poolReserves_.collateralReserves = getDexCollateralReservesAdjusted(pool_);\n            poolReserves_.debtReserves = getDexDebtReservesAdjusted(pool_);\n        }\n\n        poolReserves_.pool = pool_;\n        poolReserves_.fee = getPoolFee(pool_);\n\n        poolReserves_.limits = getDexLimits(pool_);\n    }\n\n    /// @notice Get an array of Pool addresses, their token addresses, adjusted collateral reserves, and adjusted debt reserves for a given array of Pool addresses\n    /// @param pools_ The array of Pool addresses\n    /// @return poolsReserves_ An array containing all Pool data with adjusted reserves scaled to 1e12\n    /// @dev expected to be called via callStatic\n    function getPoolsReservesAdjusted(\n        address[] memory pools_\n    ) public returns (PoolWithReserves[] memory poolsReserves_) {\n        poolsReserves_ = new PoolWithReserves[](pools_.length);\n        for (uint256 i; i < pools_.length; i++) {\n            poolsReserves_[i] = getPoolReservesAdjusted(pools_[i]);\n        }\n    }\n\n    /// @notice Get an array of all Pool addresses, their token addresses, adjusted collateral reserves, and adjusted debt reserves\n    /// @return poolsReserves_ An array containing all Pool data with adjusted reserves scaled to 1e12\n    /// @dev expected to be called via callStatic\n    function getAllPoolsReservesAdjusted() public returns (PoolWithReserves[] memory poolsReserves_) {\n        return getPoolsReservesAdjusted(getAllPoolAddresses());\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexReserves/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\n\nabstract contract Structs {\n    struct Pool {\n        address pool;\n        address token0;\n        address token1;\n        uint256 fee;\n    }\n\n    struct PoolWithReserves {\n        address pool;\n        address token0;\n        address token1;\n        uint256 fee;\n        uint256 centerPrice;\n        IFluidDexT1.CollateralReserves collateralReserves;\n        IFluidDexT1.DebtReserves debtReserves;\n        DexLimits limits;\n    }\n\n    struct TokenLimit {\n        // both `available` and `expandsTo` limits consider:\n        // - max utilization (at Liquidity layer and at Dex, for withdrawable only dex)\n        // - withdraw limits / borrow limits\n        // - balances at liquidity layer\n        uint256 available; // maximum available swap amount\n        uint256 expandsTo; // maximum amount the available swap amount expands to\n        uint256 expandDuration; // duration for `available` to grow to `expandsTo`\n    }\n\n    struct DexLimits {\n        TokenLimit withdrawableToken0;\n        TokenLimit withdrawableToken1;\n        TokenLimit borrowableToken0;\n        TokenLimit borrowableToken1;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexReserves/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidDexFactory } from \"../../../protocols/dex/interfaces/iDexFactory.sol\";\nimport { IFluidLiquidityResolver } from \"../liquidity/iLiquidityResolver.sol\";\n\ninterface IFluidLiquidity {\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n\nabstract contract Variables {\n    uint256 internal constant X10 = 0x3ff;\n    uint256 internal constant X17 = 0x1ffff;\n\n    uint256 internal constant ORACLE_LIMIT = 5 * 1e16; // 5%\n\n    /// @dev address that is mapped to the chain native token\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    IFluidDexFactory public immutable FACTORY;\n    IFluidLiquidity public immutable LIQUIDITY;\n    IFluidLiquidityResolver public immutable LIQUIDITY_RESOLVER;\n\n    constructor(address factory_, address liquidity_, address liquidityResolver_) {\n        FACTORY = IFluidDexFactory(factory_);\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        LIQUIDITY_RESOLVER = IFluidLiquidityResolver(liquidityResolver_);\n    }\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/iLiquidityResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Structs as LiquidityStructs } from \"../../../periphery/resolvers/liquidity/structs.sol\";\n\ninterface IFluidLiquidityResolver {\n    /// @notice gets the `revenueAmount_` for a `token_`.\n    function getRevenue(address token_) external view returns (uint256 revenueAmount_);\n\n    /// @notice address of contract that gets sent the revenue. Configurable by governance\n    function getRevenueCollector() external view returns (address);\n\n    /// @notice Liquidity contract paused status: status = 1 -> normal. status = 2 -> paused.\n    function getStatus() external view returns (uint256);\n\n    /// @notice checks if `auth_` is an allowed auth on Liquidity.\n    /// Auths can set most config values. E.g. contracts that automate certain flows like e.g. adding a new fToken.\n    /// Governance can add/remove auths. Governance is auth by default.\n    function isAuth(address auth_) external view returns (uint256);\n\n    /// @notice checks if `guardian_` is an allowed Guardian on Liquidity.\n    /// Guardians can pause lower class users.\n    /// Governance can add/remove guardians. Governance is guardian by default.\n    function isGuardian(address guardian_) external view returns (uint256);\n\n    /// @notice gets user class for `user_`. Class defines which protocols can be paused by guardians.\n    /// Currently there are 2 classes: 0 can be paused by guardians. 1 cannot be paused by guardians.\n    /// New protocols are added as class 0 and will be upgraded to 1 over time.\n    function getUserClass(address user_) external view returns (uint256);\n\n    /// @notice gets exchangePricesAndConfig packed uint256 storage slot for `token_`.\n    function getExchangePricesAndConfig(address token_) external view returns (uint256);\n\n    /// @notice gets rateConfig packed uint256 storage slot for `token_`.\n    function getRateConfig(address token_) external view returns (uint256);\n\n    /// @notice gets totalAmounts packed uint256 storage slot for `token_`.\n    function getTotalAmounts(address token_) external view returns (uint256);\n\n    /// @notice gets configs2 packed uint256 storage slot for `token_`.\n    function getConfigs2(address token_) external view returns (uint256);\n\n    /// @notice gets userSupply data packed uint256 storage slot for `user_` and `token_`.\n    function getUserSupply(address user_, address token_) external view returns (uint256);\n\n    /// @notice gets userBorrow data packed uint256 storage slot for `user_` and `token_`.\n    function getUserBorrow(address user_, address token_) external view returns (uint256);\n\n    /// @notice returns all `listedTokens_` at the Liquidity contract. Once configured, a token can never be removed.\n    function listedTokens() external view returns (address[] memory listedTokens_);\n\n    /// @notice get the Rate config data `rateData_` for a `token_` compiled from the packed uint256 rateConfig storage slot\n    function getTokenRateData(address token_) external view returns (LiquidityStructs.RateData memory rateData_);\n\n    /// @notice get the Rate config datas `rateDatas_` for multiple `tokens_` compiled from the packed uint256 rateConfig storage slot\n    function getTokensRateData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.RateData[] memory rateDatas_);\n\n    /// @notice returns general data for `token_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokenData(\n        address token_\n    ) external view returns (LiquidityStructs.OverallTokenData memory overallTokenData_);\n\n    /// @notice returns general data for multiple `tokens_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokensData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns general data for all `listedTokens()` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getAllOverallTokensData()\n        external\n        view\n        returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserSupplyData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData memory userSupplyData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleSupplyData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserBorrowData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData memory userBorrowData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleBorrowData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `supplyTokens_`\n    ///     and returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `borrowTokens_`\n    function getUserMultipleBorrowSupplyData(\n        address user_,\n        address[] calldata supplyTokens_,\n        address[] calldata borrowTokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallSupplyTokensData_,\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallBorrowTokensData_\n        );\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { LiquidityCalcs } from \"../../../libraries/liquidityCalcs.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\nimport { LiquiditySlotsLink } from \"../../../libraries/liquiditySlotsLink.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\nimport { IFluidLiquidityResolver } from \"./iLiquidityResolver.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { Variables } from \"./variables.sol\";\n\ninterface TokenInterface {\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IZtakingPool {\n    function balance(address token_, address staker_) external view returns (uint256);\n}\n\n/// @notice Fluid Liquidity resolver\n/// Implements various view-only methods to give easy access to Liquidity data.\ncontract FluidLiquidityResolver is IFluidLiquidityResolver, Variables, Structs {\n    /// @dev address that is mapped to the chain native token\n    address internal constant _NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice thrown if an input param address is zero\n    error FluidLiquidityResolver__AddressZero();\n\n    constructor(IFluidLiquidity liquidity_) Variables(liquidity_) {\n        if (address(liquidity_) == address(0)) {\n            revert FluidLiquidityResolver__AddressZero();\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getRevenueCollector() public view returns (address) {\n        return address(uint160(LIQUIDITY.readFromStorage(bytes32(0))));\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getRevenue(address token_) public view returns (uint256 revenueAmount_) {\n        uint256 liquidityTokenBalance_ = token_ == _NATIVE_TOKEN_ADDRESS\n            ? address(LIQUIDITY).balance\n            : IERC20(token_).balanceOf(address(LIQUIDITY));\n\n        uint256 exchangePricesAndConfig_ = getExchangePricesAndConfig(token_);\n        if (exchangePricesAndConfig_ == 0) {\n            return 0;\n        }\n\n        return LiquidityCalcs.calcRevenue(getTotalAmounts(token_), exchangePricesAndConfig_, liquidityTokenBalance_);\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getStatus() public view returns (uint256) {\n        return LIQUIDITY.readFromStorage(bytes32(LiquiditySlotsLink.LIQUIDITY_STATUS_SLOT));\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function isAuth(address auth_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(LiquiditySlotsLink.LIQUIDITY_AUTHS_MAPPING_SLOT, auth_)\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function isGuardian(address guardian_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_GUARDIANS_MAPPING_SLOT,\n                    guardian_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserClass(address user_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_USER_CLASS_MAPPING_SLOT,\n                    user_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getExchangePricesAndConfig(address token_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n                    token_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getRateConfig(address token_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_RATE_DATA_MAPPING_SLOT,\n                    token_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getTotalAmounts(address token_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT,\n                    token_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getConfigs2(address token_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_CONFIGS2_MAPPING_SLOT,\n                    token_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserSupply(address user_, address token_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n                    user_,\n                    token_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserBorrow(address user_, address token_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n                    user_,\n                    token_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function listedTokens() public view returns (address[] memory listedTokens_) {\n        uint256 length_ = LIQUIDITY.readFromStorage(bytes32(LiquiditySlotsLink.LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT));\n\n        listedTokens_ = new address[](length_);\n\n        uint256 startingSlotForArrayElements_ = uint256(\n            keccak256(abi.encode(LiquiditySlotsLink.LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT))\n        );\n\n        for (uint256 i; i < length_; i++) {\n            listedTokens_[i] = address(uint160(LIQUIDITY.readFromStorage(bytes32(startingSlotForArrayElements_ + i))));\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getTokenRateData(address token_) public view returns (RateData memory rateData_) {\n        uint256 rateConfig_ = getRateConfig(token_);\n\n        rateData_.version = rateConfig_ & 0xF;\n\n        if (rateData_.version == 1) {\n            rateData_.rateDataV1.token = token_;\n            rateData_.rateDataV1.rateAtUtilizationZero =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) &\n                X16;\n            rateData_.rateDataV1.kink = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n            rateData_.rateDataV1.rateAtUtilizationKink =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) &\n                X16;\n            rateData_.rateDataV1.rateAtUtilizationMax =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) &\n                X16;\n        } else if (rateData_.version == 2) {\n            rateData_.rateDataV2.token = token_;\n            rateData_.rateDataV2.rateAtUtilizationZero =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) &\n                X16;\n            rateData_.rateDataV2.kink1 =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) &\n                X16;\n            rateData_.rateDataV2.rateAtUtilizationKink1 =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) &\n                X16;\n            rateData_.rateDataV2.kink2 =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) &\n                X16;\n            rateData_.rateDataV2.rateAtUtilizationKink2 =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) &\n                X16;\n            rateData_.rateDataV2.rateAtUtilizationMax =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) &\n                X16;\n        } else if (rateData_.version > 0) {\n            // when version is 0 -> token not configured yet. do not revert, just return 0 for all values\n            revert(\"not-valid-rate-version\");\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getTokensRateData(address[] calldata tokens_) public view returns (RateData[] memory rateDatas_) {\n        uint256 length_ = tokens_.length;\n        rateDatas_ = new RateData[](length_);\n\n        for (uint256 i; i < length_; i++) {\n            rateDatas_[i] = getTokenRateData(tokens_[i]);\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getOverallTokenData(\n        address token_\n    ) public view returns (Structs.OverallTokenData memory overallTokenData_) {\n        overallTokenData_.rateData = getTokenRateData(token_);\n\n        uint256 exchangePriceAndConfig_ = getExchangePricesAndConfig(token_);\n        if (exchangePriceAndConfig_ > 0) {\n            uint256 totalAmounts_ = getTotalAmounts(token_);\n\n            (overallTokenData_.supplyExchangePrice, overallTokenData_.borrowExchangePrice) = LiquidityCalcs\n                .calcExchangePrices(exchangePriceAndConfig_);\n\n            overallTokenData_.borrowRate = exchangePriceAndConfig_ & X16;\n            overallTokenData_.fee = (exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14;\n            overallTokenData_.lastStoredUtilization =\n                (exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) &\n                X14;\n            overallTokenData_.storageUpdateThreshold =\n                (exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD) &\n                X14;\n            overallTokenData_.lastUpdateTimestamp =\n                (exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) &\n                X33;\n            overallTokenData_.maxUtilization = FOUR_DECIMALS;\n            if ((exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_USES_CONFIGS2) & 1 == 1) {\n                overallTokenData_.maxUtilization = getConfigs2(token_) & X14;\n            }\n\n            // Extract supply & borrow amounts\n            uint256 temp_ = totalAmounts_ & X64;\n            overallTokenData_.supplyRawInterest = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n            temp_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\n            overallTokenData_.supplyInterestFree = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n            temp_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\n            overallTokenData_.borrowRawInterest = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n            // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n            temp_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\n            overallTokenData_.borrowInterestFree = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            uint256 supplyWithInterest_;\n            uint256 borrowWithInterest_;\n            if (overallTokenData_.supplyRawInterest > 0) {\n                // use old exchange prices for supply rate to be at same level as borrow rate from storage.\n                // Note the rate here can be a tiny bit with higher precision because we use borrowWithInterest_ / supplyWithInterest_\n                // which has higher precision than the utilization used from storage in LiquidityCalcs\n                supplyWithInterest_ =\n                    (overallTokenData_.supplyRawInterest *\n                        ((exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\n                            X64)) /\n                    EXCHANGE_PRICES_PRECISION; // normalized from raw\n                borrowWithInterest_ =\n                    (overallTokenData_.borrowRawInterest *\n                        ((exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\n                            X64)) /\n                    EXCHANGE_PRICES_PRECISION; // normalized from raw\n\n                overallTokenData_.supplyRate = supplyWithInterest_ == 0\n                    ? 0\n                    : (overallTokenData_.borrowRate * (FOUR_DECIMALS - overallTokenData_.fee) * borrowWithInterest_) /\n                        (supplyWithInterest_ * FOUR_DECIMALS);\n            }\n\n            supplyWithInterest_ =\n                (overallTokenData_.supplyRawInterest * overallTokenData_.supplyExchangePrice) /\n                EXCHANGE_PRICES_PRECISION; // normalized from raw\n            overallTokenData_.totalSupply = supplyWithInterest_ + overallTokenData_.supplyInterestFree;\n            borrowWithInterest_ =\n                (overallTokenData_.borrowRawInterest * overallTokenData_.borrowExchangePrice) /\n                EXCHANGE_PRICES_PRECISION; // normalized from raw\n            overallTokenData_.totalBorrow = borrowWithInterest_ + overallTokenData_.borrowInterestFree;\n\n            overallTokenData_.revenue = getRevenue(token_);\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getOverallTokensData(\n        address[] memory tokens_\n    ) public view returns (Structs.OverallTokenData[] memory overallTokensData_) {\n        uint256 length_ = tokens_.length;\n        overallTokensData_ = new Structs.OverallTokenData[](length_);\n        for (uint256 i; i < length_; i++) {\n            overallTokensData_[i] = getOverallTokenData(tokens_[i]);\n        }\n    }\n\n    address private constant WEETH = 0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee;\n    address private constant WEETHS = 0x917ceE801a67f933F2e6b33fC0cD1ED2d5909D88;\n    IZtakingPool private constant ZIRCUIT = IZtakingPool(0xF047ab4c75cebf0eB9ed34Ae2c186f3611aEAfa6);\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getAllOverallTokensData() public view returns (Structs.OverallTokenData[] memory overallTokensData_) {\n        return getOverallTokensData(listedTokens());\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserSupplyData(\n        address user_,\n        address token_\n    )\n        public\n        view\n        returns (Structs.UserSupplyData memory userSupplyData_, Structs.OverallTokenData memory overallTokenData_)\n    {\n        overallTokenData_ = getOverallTokenData(token_);\n        uint256 userSupply_ = getUserSupply(user_, token_);\n\n        if (userSupply_ > 0) {\n            // if userSupply_ == 0 -> user not configured yet for token at Liquidity\n            userSupplyData_.modeWithInterest = userSupply_ & 1 == 1;\n            userSupplyData_.supply = BigMathMinified.fromBigNumber(\n                (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n            // get updated expanded withdrawal limit\n            userSupplyData_.withdrawalLimit = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(\n                userSupply_,\n                userSupplyData_.supply\n            );\n\n            userSupplyData_.lastUpdateTimestamp =\n                (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) &\n                X33;\n            userSupplyData_.expandPercent = (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n            userSupplyData_.expandDuration = (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24;\n            userSupplyData_.baseWithdrawalLimit = BigMathMinified.fromBigNumber(\n                (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n            if (userSupplyData_.modeWithInterest) {\n                // convert raw amounts to normal for withInterest mode\n                userSupplyData_.supply =\n                    (userSupplyData_.supply * overallTokenData_.supplyExchangePrice) /\n                    EXCHANGE_PRICES_PRECISION;\n                userSupplyData_.withdrawalLimit =\n                    (userSupplyData_.withdrawalLimit * overallTokenData_.supplyExchangePrice) /\n                    EXCHANGE_PRICES_PRECISION;\n                userSupplyData_.baseWithdrawalLimit =\n                    (userSupplyData_.baseWithdrawalLimit * overallTokenData_.supplyExchangePrice) /\n                    EXCHANGE_PRICES_PRECISION;\n            }\n\n            userSupplyData_.withdrawableUntilLimit = userSupplyData_.supply > userSupplyData_.withdrawalLimit\n                ? userSupplyData_.supply - userSupplyData_.withdrawalLimit\n                : 0;\n            uint balanceOf_ = token_ == _NATIVE_TOKEN_ADDRESS\n                ? address(LIQUIDITY).balance\n                : TokenInterface(token_).balanceOf(address(LIQUIDITY));\n            if (token_ == WEETH) {\n                balanceOf_ += ZIRCUIT.balance(WEETH, address(LIQUIDITY));\n            }\n            if (token_ == WEETHS) {\n                balanceOf_ += ZIRCUIT.balance(WEETHS, address(LIQUIDITY));\n            }\n\n            userSupplyData_.withdrawable = balanceOf_ > userSupplyData_.withdrawableUntilLimit\n                ? userSupplyData_.withdrawableUntilLimit\n                : balanceOf_;\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserMultipleSupplyData(\n        address user_,\n        address[] calldata tokens_\n    )\n        public\n        view\n        returns (\n            Structs.UserSupplyData[] memory userSuppliesData_,\n            Structs.OverallTokenData[] memory overallTokensData_\n        )\n    {\n        uint256 length_ = tokens_.length;\n        userSuppliesData_ = new Structs.UserSupplyData[](length_);\n        overallTokensData_ = new Structs.OverallTokenData[](length_);\n\n        for (uint256 i; i < length_; i++) {\n            (userSuppliesData_[i], overallTokensData_[i]) = getUserSupplyData(user_, tokens_[i]);\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserBorrowData(\n        address user_,\n        address token_\n    )\n        public\n        view\n        returns (Structs.UserBorrowData memory userBorrowData_, Structs.OverallTokenData memory overallTokenData_)\n    {\n        overallTokenData_ = getOverallTokenData(token_);\n        uint256 userBorrow_ = getUserBorrow(user_, token_);\n\n        if (userBorrow_ > 0) {\n            // if userBorrow_ == 0 -> user not configured yet for token at Liquidity\n\n            userBorrowData_.modeWithInterest = userBorrow_ & 1 == 1;\n\n            userBorrowData_.borrow = BigMathMinified.fromBigNumber(\n                (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n            // get updated expanded borrow limit\n            userBorrowData_.borrowLimit = LiquidityCalcs.calcBorrowLimitBeforeOperate(\n                userBorrow_,\n                userBorrowData_.borrow\n            );\n\n            userBorrowData_.lastUpdateTimestamp =\n                (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) &\n                X33;\n            userBorrowData_.expandPercent = (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n            userBorrowData_.expandDuration = (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24;\n            userBorrowData_.baseBorrowLimit = BigMathMinified.fromBigNumber(\n                (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n            userBorrowData_.maxBorrowLimit = BigMathMinified.fromBigNumber(\n                (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n            if (userBorrowData_.modeWithInterest) {\n                // convert raw amounts to normal for withInterest mode\n                userBorrowData_.borrow =\n                    (userBorrowData_.borrow * overallTokenData_.borrowExchangePrice) /\n                    EXCHANGE_PRICES_PRECISION;\n                userBorrowData_.borrowLimit =\n                    (userBorrowData_.borrowLimit * overallTokenData_.borrowExchangePrice) /\n                    EXCHANGE_PRICES_PRECISION;\n                userBorrowData_.baseBorrowLimit =\n                    (userBorrowData_.baseBorrowLimit * overallTokenData_.borrowExchangePrice) /\n                    EXCHANGE_PRICES_PRECISION;\n                userBorrowData_.maxBorrowLimit =\n                    (userBorrowData_.maxBorrowLimit * overallTokenData_.borrowExchangePrice) /\n                    EXCHANGE_PRICES_PRECISION;\n            }\n\n            userBorrowData_.borrowLimitUtilization =\n                (overallTokenData_.maxUtilization * overallTokenData_.totalSupply) /\n                1e4;\n\n            // uncollected revenue is counting towards available balanceOf.\n            // because of this \"borrowable\" would be showing an amount that can go above 100% utilization, causing a revert.\n            // need to take into consideration the borrowable amount until the max utilization limit, which depends on the total\n            // borrow amount (not user specific)\n            uint borrowableUntilUtilizationLimit_ = userBorrowData_.borrowLimitUtilization >\n                overallTokenData_.totalBorrow\n                ? userBorrowData_.borrowLimitUtilization - overallTokenData_.totalBorrow\n                : 0;\n\n            uint borrowableUntilBorrowLimit_ = userBorrowData_.borrowLimit > userBorrowData_.borrow\n                ? userBorrowData_.borrowLimit - userBorrowData_.borrow\n                : 0;\n\n            userBorrowData_.borrowableUntilLimit = borrowableUntilBorrowLimit_ > borrowableUntilUtilizationLimit_\n                ? borrowableUntilUtilizationLimit_\n                : borrowableUntilBorrowLimit_;\n\n            // if available balance at Liquidity is less than the borrowableUntilLimit amount, then the balance is\n            // the limiting borrowable amount.\n            uint balanceOf_ = token_ == _NATIVE_TOKEN_ADDRESS\n                ? address(LIQUIDITY).balance\n                : TokenInterface(token_).balanceOf(address(LIQUIDITY));\n\n            userBorrowData_.borrowable = balanceOf_ > userBorrowData_.borrowableUntilLimit\n                ? userBorrowData_.borrowableUntilLimit\n                : balanceOf_;\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserMultipleBorrowData(\n        address user_,\n        address[] calldata tokens_\n    )\n        public\n        view\n        returns (\n            Structs.UserBorrowData[] memory userBorrowingsData_,\n            Structs.OverallTokenData[] memory overallTokensData_\n        )\n    {\n        uint256 length_ = tokens_.length;\n        userBorrowingsData_ = new UserBorrowData[](length_);\n        overallTokensData_ = new Structs.OverallTokenData[](length_);\n\n        for (uint256 i; i < length_; i++) {\n            (userBorrowingsData_[i], overallTokensData_[i]) = getUserBorrowData(user_, tokens_[i]);\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserMultipleBorrowSupplyData(\n        address user_,\n        address[] calldata supplyTokens_,\n        address[] calldata borrowTokens_\n    )\n        public\n        view\n        returns (\n            Structs.UserSupplyData[] memory userSuppliesData_,\n            Structs.OverallTokenData[] memory overallSupplyTokensData_,\n            Structs.UserBorrowData[] memory userBorrowingsData_,\n            Structs.OverallTokenData[] memory overallBorrowTokensData_\n        )\n    {\n        uint256 length_ = supplyTokens_.length;\n        userSuppliesData_ = new Structs.UserSupplyData[](length_);\n        overallSupplyTokensData_ = new Structs.OverallTokenData[](length_);\n        for (uint256 i; i < length_; i++) {\n            (userSuppliesData_[i], overallSupplyTokensData_[i]) = getUserSupplyData(user_, supplyTokens_[i]);\n        }\n\n        length_ = borrowTokens_.length;\n        userBorrowingsData_ = new UserBorrowData[](length_);\n        overallBorrowTokensData_ = new Structs.OverallTokenData[](length_);\n        for (uint256 i; i < length_; i++) {\n            (userBorrowingsData_[i], overallBorrowTokensData_[i]) = getUserBorrowData(user_, borrowTokens_[i]);\n        }\n    }\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Structs as AdminModuleStructs } from \"../../../liquidity/adminModule/structs.sol\";\n\nabstract contract Structs {\n    struct RateData {\n        uint256 version;\n        AdminModuleStructs.RateDataV1Params rateDataV1;\n        AdminModuleStructs.RateDataV2Params rateDataV2;\n    }\n\n    struct OverallTokenData {\n        uint256 borrowRate;\n        uint256 supplyRate;\n        uint256 fee; // revenue fee\n        uint256 lastStoredUtilization;\n        uint256 storageUpdateThreshold;\n        uint256 lastUpdateTimestamp;\n        uint256 supplyExchangePrice;\n        uint256 borrowExchangePrice;\n        uint256 supplyRawInterest;\n        uint256 supplyInterestFree;\n        uint256 borrowRawInterest;\n        uint256 borrowInterestFree;\n        uint256 totalSupply;\n        uint256 totalBorrow;\n        uint256 revenue;\n        uint256 maxUtilization; // maximum allowed utilization\n        RateData rateData;\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserSupplyData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 supply; // user supply amount\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\n        uint256 withdrawalLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\n        uint256 baseWithdrawalLimit;\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\n        uint256 withdrawableUntilLimit;\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserBorrowData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 borrow; // user borrow amount\n        uint256 borrowLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseBorrowLimit;\n        uint256 maxBorrowLimit;\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\n    }\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\n\ncontract Variables {\n    /// @dev Storage slot with the admin of the contract. Logic from \"proxy.sol\".\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n    /// validated in the constructor.\n    bytes32 internal constant GOVERNANCE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant SMALL_COEFFICIENT_SIZE = 10;\n    uint256 internal constant DEFAULT_COEFFICIENT_SIZE = 56;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 10000;\n    uint256 internal constant X8 = 0xff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    /// @notice address of the liquidity contract\n    IFluidLiquidity public immutable LIQUIDITY;\n\n    constructor(IFluidLiquidity liquidity_) {\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vault/iVaultResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Structs } from \"./structs.sol\";\n\ninterface IFluidVaultResolver {\n    function vaultByNftId(uint nftId_) external view returns (address vault_);\n\n    function positionByNftId(\n        uint nftId_\n    ) external view returns (Structs.UserPosition memory userPosition_, Structs.VaultEntireData memory vaultData_);\n\n    function getVaultVariablesRaw(address vault_) external view returns (uint);\n\n    function getVaultVariables2Raw(address vault_) external view returns (uint);\n\n    function getTickHasDebtRaw(address vault_, int key_) external view returns (uint);\n\n    function getTickDataRaw(address vault_, int tick_) external view returns (uint);\n\n    function getBranchDataRaw(address vault_, uint branch_) external view returns (uint);\n\n    function getPositionDataRaw(address vault_, uint positionId_) external view returns (uint);\n\n    function getAllVaultsAddresses() external view returns (address[] memory vaults_);\n\n    function getVaultLiquidation(\n        address vault_,\n        uint tokenInAmt_\n    ) external returns (Structs.LiquidationStruct memory liquidationData_);\n\n    function getVaultEntireData(address vault_) external view returns (Structs.VaultEntireData memory vaultData_);\n}\n"
    },
    "contracts/periphery/resolvers/vault/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidVault } from \"../../../protocols/vault/interfaces/iVault.sol\";\nimport { Structs as FluidLiquidityResolverStructs } from \"../liquidity/structs.sol\";\n\n// @dev Amounts are always in token amount for normal col / normal debt or in\n// shares for Dex smart col / smart debt.\ncontract Structs {\n    struct Configs {\n        // can be supplyRate instead if Vault Type is smart col. in that case if 1st bit == 1 then positive else negative\n        uint16 supplyRateMagnifier;\n        // can be borrowRate instead if Vault Type is smart debt. in that case if 1st bit == 1 then positive else negative\n        uint16 borrowRateMagnifier;\n        uint16 collateralFactor;\n        uint16 liquidationThreshold;\n        uint16 liquidationMaxLimit;\n        uint16 withdrawalGap;\n        uint16 liquidationPenalty;\n        uint16 borrowFee;\n        address oracle;\n        // Oracle price is always debt per col, i.e. amount of debt for 1 col.\n        // In case of Dex this price can be used to resolve shares values w.r.t. token0 or token1:\n        // - T2: debt token per 1 col share\n        // - T3: debt shares per 1 col token\n        // - T4: debt shares per 1 col share\n        uint oraclePriceOperate;\n        uint oraclePriceLiquidate;\n        address rebalancer;\n        uint lastUpdateTimestamp;\n    }\n\n    struct ExchangePricesAndRates {\n        uint lastStoredLiquiditySupplyExchangePrice; // 0 in case of smart col\n        uint lastStoredLiquidityBorrowExchangePrice; // 0 in case of smart debt\n        uint lastStoredVaultSupplyExchangePrice;\n        uint lastStoredVaultBorrowExchangePrice;\n        uint liquiditySupplyExchangePrice; // set to 1e12 in case of smart col\n        uint liquidityBorrowExchangePrice; // set to 1e12 in case of smart debt\n        uint vaultSupplyExchangePrice;\n        uint vaultBorrowExchangePrice;\n        uint supplyRateLiquidity; // set to 0 in case of smart col. Must get per token through DexEntireData\n        uint borrowRateLiquidity; // set to 0 in case of smart debt. Must get per token through DexEntireData\n        // supplyRateVault or borrowRateVault:\n        // - when normal col / debt: rate at liquidity + diff rewards or fee through magnifier (rewardsOrFeeRate below)\n        // - when smart col / debt: rewards or fee rate at the vault itself. always == rewardsOrFeeRate below.\n        // to get the full rates for vault when smart col / debt, combine with data from DexResolver:\n        // - rateAtLiquidity for token0 or token1 (DexResolver)\n        // - the rewards or fee rate at the vault (VaultResolver)\n        // - the Dex APR (currently off-chain compiled through tracking swap events at the DEX)\n        int supplyRateVault; // can be negative in case of smart col (meaning pay to supply)\n        int borrowRateVault; // can be negative in case of smart debt (meaning get paid to borrow)\n        // rewardsOrFeeRateSupply: rewards or fee rate in percent 1e2 precision (1% = 100, 100% = 10000).\n        // positive rewards, negative fee.\n        // for smart col vaults: supplyRateVault == supplyRateLiquidity.\n        // for normal col vaults: relative percent to supplyRateLiquidity, e.g.:\n        // when rewards: supplyRateLiquidity = 4%, rewardsOrFeeRateSupply = 20%, supplyRateVault = 4.8%.\n        // when fee: supplyRateLiquidity = 4%, rewardsOrFeeRateSupply = -30%, supplyRateVault = 2.8%.\n        int rewardsOrFeeRateSupply;\n        // rewardsOrFeeRateBorrow: rewards or fee rate in percent 1e2 precision (1% = 100, 100% = 10000).\n        // negative rewards, positive fee.\n        // for smart debt vaults: borrowRateVault == borrowRateLiquidity.\n        // for normal debt vaults: relative percent to borrowRateLiquidity, e.g.:\n        // when rewards: borrowRateLiquidity = 4%, rewardsOrFeeRateBorrow = -20%, borrowRateVault = 3.2%.\n        // when fee: borrowRateLiquidity = 4%, rewardsOrFeeRateBorrow = 30%, borrowRateVault = 5.2%.\n        int rewardsOrFeeRateBorrow;\n    }\n\n    struct TotalSupplyAndBorrow {\n        uint totalSupplyVault;\n        uint totalBorrowVault;\n        uint totalSupplyLiquidityOrDex;\n        uint totalBorrowLiquidityOrDex;\n        uint absorbedSupply;\n        uint absorbedBorrow;\n    }\n\n    struct LimitsAndAvailability {\n        // in case of DEX: withdrawable / borrowable amount of vault at DEX, BUT there could be that DEX can not withdraw\n        // that much at Liquidity! So for DEX this must be combined with returned data in DexResolver.\n        uint withdrawLimit;\n        uint withdrawableUntilLimit;\n        uint withdrawable;\n        uint borrowLimit;\n        uint borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        uint borrowLimitUtilization; // borrow limit for `maxUtilization` config at Liquidity\n        uint minimumBorrowing;\n    }\n\n    struct CurrentBranchState {\n        uint status; // if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\n        int minimaTick;\n        uint debtFactor;\n        uint partials;\n        uint debtLiquidity;\n        uint baseBranchId;\n        int baseBranchMinima;\n    }\n\n    struct VaultState {\n        uint totalPositions;\n        int topTick;\n        uint currentBranch;\n        uint totalBranch;\n        uint totalBorrow;\n        uint totalSupply;\n        CurrentBranchState currentBranchState;\n    }\n\n    struct VaultEntireData {\n        address vault;\n        bool isSmartCol; // true if col token is a Fluid Dex\n        bool isSmartDebt; // true if debt token is a Fluid Dex\n        IFluidVault.ConstantViews constantVariables;\n        Configs configs;\n        ExchangePricesAndRates exchangePricesAndRates;\n        TotalSupplyAndBorrow totalSupplyAndBorrow;\n        LimitsAndAvailability limitsAndAvailability;\n        VaultState vaultState;\n        // liquidity related data such as supply amount, limits, expansion etc.\n        // Also set for Dex, limits are in shares and same things apply as noted for LimitsAndAvailability above!\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyData;\n        // liquidity related data such as borrow amount, limits, expansion etc.\n        // Also set for Dex, limits are in shares and same things apply as noted for LimitsAndAvailability above!\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowData;\n    }\n\n    struct UserPosition {\n        uint nftId;\n        address owner;\n        bool isLiquidated;\n        bool isSupplyPosition; // if true that means borrowing is 0\n        int tick;\n        uint tickId;\n        uint beforeSupply;\n        uint beforeBorrow;\n        uint beforeDustBorrow;\n        uint supply;\n        uint borrow;\n        uint dustBorrow;\n    }\n\n    /// @dev liquidation related data\n    /// @param vault address of vault\n    /// @param token0In address of token in\n    /// @param token0Out address of token out\n    /// @param token1In address of token in (if smart debt)\n    /// @param token1Out address of token out (if smart col)\n    /// @param inAmt (without absorb liquidity) minimum of available liquidation\n    /// @param outAmt (without absorb liquidity) expected token out, collateral to withdraw\n    /// @param inAmtWithAbsorb (absorb liquidity included) minimum of available liquidation. In most cases it'll be same as inAmt but sometimes can be bigger.\n    /// @param outAmtWithAbsorb (absorb liquidity included) expected token out, collateral to withdraw. In most cases it'll be same as outAmt but sometimes can be bigger.\n    /// @param absorbAvailable true if absorb is available\n    /// @dev Liquidity in with absirb will always be >= without asborb. Sometimes without asborb can provide better swaps,\n    ///      sometimes with absirb can provide better swaps. But available in with absirb will always be >= One\n    struct LiquidationStruct {\n        address vault;\n        address token0In;\n        address token0Out;\n        address token1In;\n        address token1Out;\n        // amounts in case of smart debt are in shares, otherwise token amounts.\n        // smart col can not be liquidated so to exchange inAmt always use DexResolver DexState.tokenPerDebtShare\n        // and tokenPerColShare for outAmt when Vault is smart col.\n        uint inAmt;\n        uint outAmt;\n        uint inAmtWithAbsorb;\n        uint outAmtWithAbsorb;\n        bool absorbAvailable;\n    }\n\n    struct AbsorbStruct {\n        address vault;\n        bool absorbAvailable;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultLiquidation/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\nimport { Variables } from \"./variables.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { FluidProtocolTypes } from \"../../../libraries/fluidProtocolTypes.sol\";\nimport { Structs as VaultResolverStructs } from \"../vault/structs.sol\";\nimport { IFluidVaultResolver } from \"../vault/iVaultResolver.sol\";\nimport { IFluidVaultT1 } from \"../../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { LiquiditySlotsLink } from \"../../../libraries/liquiditySlotsLink.sol\";\nimport { LiquidityCalcs } from \"../../../libraries/liquidityCalcs.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\n\ninterface IZtakingPool {\n    function balance(address token_, address staker_) external view returns (uint256);\n}\n\ninterface ISUSDSHolder {\n    function previewUSDCBalance() external view returns (uint256);\n}\ninterface TokenInterface {\n    function balanceOf(address) external view returns (uint);\n}\n\n/// @notice Resolver contract that helps in finding available token (liquidation) swaps available in Fluid VaultT1s.\n/// @dev    Note that on the same protocol, if \"withAbsorb = true\" is executed, this also consumes the swap\n///         that would be on the same protocol with \"withAbsorb = false\". So the total available swap amount\n///         at a protocol if both a swap with and without absorb is available is not `with inAmt + without inAmt`\n///         but rather `with inAmt`.\n///         Sometimes with absorb can provide better swaps, sometimes without absorb can provide better swaps.\n///         But available liquidity for \"withAbsorb\" amounts will always be >= without absorb amounts.\n/// @dev    The \"Raw\" methods return both the with and without absorb swaps for the same Fluid Vault, the non-\"Raw\"\n///         methods automatically filter by the better ratio swap. For same cases a better optimization of ratios\n///         is possible with custom logic based on the \"Raw\" methods, see details in comments.\n/// @dev    for native token, send 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE.\n/// @dev    returned swaps Struct can be fed into `getSwapTx` to prepare the tx that executes the swaps.\n/// @dev    non-view methods in this contract are expected to be called with callStatic,\n///         although they would anyway not do any actual state changes.\ncontract FluidVaultLiquidationResolver is Variables, Structs {\n    /// @notice thrown if an input param address is zero\n    error FluidVaultLiquidationsResolver__AddressZero();\n    /// @notice thrown if an invalid param is given to a method\n    error FluidVaultLiquidationsResolver__InvalidParams();\n\n    /// @notice constructor sets the immutable vault resolver address\n    constructor(IFluidVaultResolver vaultResolver_, IFluidLiquidity liquidity_) Variables(vaultResolver_, liquidity_) {\n        if (address(vaultResolver_) == address(0) || address(liquidity_) == address(0)) {\n            revert FluidVaultLiquidationsResolver__AddressZero();\n        }\n    }\n\n    /// @notice returns all available token swap paths\n    function getAllSwapPaths() public view returns (SwapPath[] memory paths_) {\n        address[] memory vaultAddresses_ = _getVaultT1s();\n        paths_ = new SwapPath[](vaultAddresses_.length);\n\n        address borrowToken_;\n        address supplyToken_;\n        for (uint256 i; i < vaultAddresses_.length; ++i) {\n            (borrowToken_, supplyToken_) = _getVaultTokens(vaultAddresses_[i]);\n            paths_[i] = SwapPath({ protocol: vaultAddresses_[i], tokenIn: borrowToken_, tokenOut: supplyToken_ });\n        }\n    }\n\n    /// @notice returns all swap paths for a certain `tokenIn_` swapped to a `tokenOut_`.\n    ///         returns empty array if no swap path is available for a given pair.\n    function getSwapPaths(address tokenIn_, address tokenOut_) public view returns (SwapPath[] memory paths_) {\n        address[] memory vaultAddresses_ = _getVaultT1s();\n\n        uint256 foundVaultsCount_;\n        address[] memory foundVaults_ = new address[](vaultAddresses_.length);\n\n        address borrowToken_;\n        address supplyToken_;\n        for (uint256 i; i < vaultAddresses_.length; ++i) {\n            (borrowToken_, supplyToken_) = _getVaultTokens(vaultAddresses_[i]);\n\n            if (borrowToken_ == tokenIn_ && supplyToken_ == tokenOut_) {\n                foundVaults_[foundVaultsCount_] = vaultAddresses_[i];\n                ++foundVaultsCount_;\n            }\n        }\n\n        paths_ = new SwapPath[](foundVaultsCount_);\n        for (uint256 i; i < foundVaultsCount_; ++i) {\n            paths_[i] = SwapPath({ protocol: foundVaults_[i], tokenIn: tokenIn_, tokenOut: tokenOut_ });\n        }\n    }\n\n    /// @notice returns all available swap paths for any `tokensIn_` to any `tokensOut_`.\n    function getAnySwapPaths(\n        address[] calldata tokensIn_,\n        address[] calldata tokensOut_\n    ) public view returns (SwapPath[] memory paths_) {\n        SwapPath[] memory maxPaths_ = new SwapPath[](tokensIn_.length * tokensOut_.length);\n\n        address[] memory vaultAddresses_ = _getVaultT1s();\n\n        uint256 matches_;\n\n        address borrowToken_;\n        address supplyToken_;\n        unchecked {\n            for (uint256 vi; vi < vaultAddresses_.length; ++vi) {\n                (borrowToken_, supplyToken_) = _getVaultTokens(vaultAddresses_[vi]);\n\n                // for each vault, iterate over all possible input params token combinations\n                for (uint256 i; i < tokensIn_.length; ++i) {\n                    for (uint256 j; j < tokensOut_.length; ++j) {\n                        if (borrowToken_ == tokensIn_[i] && supplyToken_ == tokensOut_[j]) {\n                            maxPaths_[matches_] = SwapPath({\n                                protocol: vaultAddresses_[vi],\n                                tokenIn: borrowToken_,\n                                tokenOut: supplyToken_\n                            });\n                            ++matches_;\n                        }\n                    }\n                }\n            }\n\n            paths_ = new SwapPath[](matches_);\n            for (uint256 i; i < matches_; ++i) {\n                paths_[i] = maxPaths_[i];\n            }\n        }\n    }\n\n    /// @notice returns the swap data for with and without absorb for a Fluid `vault_`.\n    function getVaultSwapData(\n        address vault_\n    ) public returns (SwapData memory withoutAbsorb_, SwapData memory withAbsorb_) {\n        VaultResolverStructs.LiquidationStruct memory liquidationData_ = VAULT_RESOLVER.getVaultLiquidation(vault_, 0);\n\n        withoutAbsorb_ = SwapData({\n            inAmt: liquidationData_.inAmt,\n            outAmt: liquidationData_.outAmt,\n            withAbsorb: false,\n            ratio: _calcRatio(liquidationData_.inAmt, liquidationData_.outAmt)\n        });\n\n        withAbsorb_ = SwapData({\n            inAmt: liquidationData_.inAmtWithAbsorb,\n            outAmt: liquidationData_.outAmtWithAbsorb,\n            withAbsorb: true,\n            ratio: _calcRatio(liquidationData_.inAmtWithAbsorb, liquidationData_.outAmtWithAbsorb)\n        });\n    }\n\n    /// @notice returns the swap data for with and without absorb for multiple Fluid `vaults_`.\n    function getVaultsSwapData(\n        address[] memory vaults_\n    ) public returns (SwapData[] memory withoutAbsorb_, SwapData[] memory withAbsorb_) {\n        withoutAbsorb_ = new SwapData[](vaults_.length);\n        withAbsorb_ = new SwapData[](vaults_.length);\n        for (uint256 i; i < vaults_.length; ++i) {\n            (withoutAbsorb_[i], withAbsorb_[i]) = getVaultSwapData(vaults_[i]);\n        }\n    }\n\n    /// @notice returns the swap data for with and without absorb for all Fluid vaults.\n    function getAllVaultsSwapData() public returns (SwapData[] memory withoutAbsorb_, SwapData[] memory withAbsorb_) {\n        return getVaultsSwapData(_getVaultT1s());\n    }\n\n    /// @notice returns the available swap amounts at a certain `protocol_`. Only returns non-zero swaps.\n    ///         For vault protocol considering both a swap that uses liquidation with absorb and without absorb.\n    function getSwapForProtocol(address protocol_) public returns (Swap memory swap_) {\n        if (protocol_ == address(0)) {\n            return swap_;\n        }\n\n        (address borrowToken_, address supplyToken_) = _getVaultTokens(protocol_);\n        (SwapData memory withoutAbsorb_, SwapData memory withAbsorb_) = getVaultSwapData(protocol_);\n\n        swap_ = _getSwapAccountingForWithdrawable(\n            Swap({\n                path: SwapPath({ protocol: protocol_, tokenIn: borrowToken_, tokenOut: supplyToken_ }),\n                data: _getBetterRatioSwapData(withoutAbsorb_, withAbsorb_)\n            }),\n            withAbsorb_.outAmt == 0 ? 0 : _getVaultT1Withdrawable(protocol_, supplyToken_)\n        );\n    }\n\n    /// @notice returns all available `swaps_` for multiple Fluid `vaults_` raw. Only returns non-zero swaps.\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\n    function getVaultsSwapRaw(address[] memory vaults_) public returns (Swap[] memory swaps_) {\n        unchecked {\n            uint256 nonZeroSwaps_;\n            Swap[] memory allSwaps_ = new Swap[](vaults_.length * 2);\n\n            SwapData memory withoutAbsorb_;\n            SwapData memory withAbsorb_;\n            address borrowToken_;\n            address supplyToken_;\n            uint256 withdrawable_;\n            for (uint256 i; i < vaults_.length; ++i) {\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(vaults_[i]);\n                if (withAbsorb_.inAmt == 0) {\n                    // if with absorb is 0, then without absorb can only be 0 too\n                    continue;\n                }\n                (borrowToken_, supplyToken_) = _getVaultTokens(vaults_[i]);\n                withdrawable_ = _getVaultT1Withdrawable(vaults_[i], supplyToken_);\n                if (withdrawable_ == 0) {\n                    continue;\n                }\n                ++nonZeroSwaps_;\n                if (withAbsorb_.inAmt == withoutAbsorb_.inAmt) {\n                    // with absorb has the same liquidity as without absorb.\n                    // running liquidate() with absorb in that case only costs extra gas. return only without absorb swap\n                    withAbsorb_.inAmt = 0;\n                } else if (withoutAbsorb_.inAmt > 0) {\n                    // both with and without absorb swaps\n                    ++nonZeroSwaps_;\n                }\n\n                allSwaps_[i * 2] = _getSwapAccountingForWithdrawable(\n                    Swap({\n                        path: SwapPath({ protocol: vaults_[i], tokenIn: borrowToken_, tokenOut: supplyToken_ }),\n                        data: withoutAbsorb_\n                    }),\n                    withdrawable_\n                );\n                allSwaps_[i * 2 + 1] = _getSwapAccountingForWithdrawable(\n                    Swap({\n                        path: SwapPath({ protocol: vaults_[i], tokenIn: borrowToken_, tokenOut: supplyToken_ }),\n                        data: withAbsorb_\n                    }),\n                    withdrawable_\n                );\n            }\n\n            return _getNonZeroSwaps(allSwaps_, nonZeroSwaps_);\n        }\n    }\n\n    /// @notice returns all available `swaps_` for all Fluid vaults raw. Only returns non-zero swaps.\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\n    function getAllVaultsSwapRaw() public returns (Swap[] memory swaps_) {\n        return getVaultsSwapRaw(_getVaultT1s());\n    }\n\n    /// @notice returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\n    function getSwapsForPathsRaw(SwapPath[] memory paths_) public returns (Swap[] memory swaps_) {\n        unchecked {\n            Swap[] memory allSwaps_ = new Swap[](paths_.length * 2);\n\n            uint256 nonZeroSwaps_;\n            SwapData memory withoutAbsorb_;\n            SwapData memory withAbsorb_;\n            uint256 withdrawable_;\n            for (uint256 i; i < paths_.length; ++i) {\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(paths_[i].protocol);\n\n                if (withAbsorb_.inAmt == 0) {\n                    // if with absorb is 0, then without absorb can only be 0 too\n                    continue;\n                }\n                withdrawable_ = _getVaultT1Withdrawable(paths_[i].protocol, paths_[i].tokenOut);\n                if (withdrawable_ == 0) {\n                    continue;\n                }\n                ++nonZeroSwaps_;\n                if (withAbsorb_.inAmt == withoutAbsorb_.inAmt) {\n                    // with absorb has the same liquidity as without absorb.\n                    // running liquidate() with absorb in that case only costs extra gas. return only without absorb swap\n                    withAbsorb_.inAmt = 0;\n                } else if (withoutAbsorb_.inAmt > 0) {\n                    // both with and without absorb swaps\n                    ++nonZeroSwaps_;\n                }\n\n                allSwaps_[i * 2] = _getSwapAccountingForWithdrawable(\n                    Swap({ path: paths_[i], data: withoutAbsorb_ }),\n                    withdrawable_\n                );\n\n                allSwaps_[i * 2 + 1] = _getSwapAccountingForWithdrawable(\n                    Swap({ path: paths_[i], data: withAbsorb_ }),\n                    withdrawable_\n                );\n            }\n\n            swaps_ = new Swap[](nonZeroSwaps_);\n            uint256 index_;\n            for (uint256 i; i < allSwaps_.length; ++i) {\n                if (allSwaps_[i].data.inAmt > 0) {\n                    swaps_[index_] = allSwaps_[i];\n                    ++index_;\n                }\n            }\n        }\n    }\n\n    /// @notice finds all available `swaps_` for `tokenIn_` to `tokenOut_`.\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\n    function getSwapsRaw(address tokenIn_, address tokenOut_) public returns (Swap[] memory swaps_) {\n        return getSwapsForPathsRaw(getSwapPaths(tokenIn_, tokenOut_));\n    }\n\n    /// @notice finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.\n    ///         Token pairs that are not available or where available swap amounts are zero\n    ///         will not be present in the returned `swaps_` array.\n    ///         includes all swaps unfiltered, e.g. with absorb and without absorb swaps are present for the same vault.\n    function getAnySwapsRaw(\n        address[] calldata tokensIn_,\n        address[] calldata tokensOut_\n    ) public returns (Swap[] memory swaps_) {\n        return getSwapsForPathsRaw(getAnySwapPaths(tokensIn_, tokensOut_));\n    }\n\n    /// @notice returns all available `swaps_` for multiple Fluid `vaults_`. Only returns non-zero swaps.\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\n    ///         better ratio.\n    function getVaultsSwap(address[] memory vaults_) public returns (Swap[] memory swaps_) {\n        unchecked {\n            uint256 nonZeroSwaps_;\n            Swap[] memory allSwaps_ = new Swap[](vaults_.length);\n\n            SwapData memory withoutAbsorb_;\n            SwapData memory withAbsorb_;\n            Swap memory swap_;\n            uint256 withdrawable_;\n            for (uint256 i; i < vaults_.length; ++i) {\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(vaults_[i]);\n                swap_ = Swap({\n                    path: SwapPath({ protocol: vaults_[i], tokenIn: address(0), tokenOut: address(0) }),\n                    data: _getBetterRatioSwapData(withoutAbsorb_, withAbsorb_)\n                });\n\n                if (swap_.data.inAmt == 0) {\n                    // no swap available on this vault\n                    continue;\n                }\n                (swap_.path.tokenIn, swap_.path.tokenOut) = _getVaultTokens(vaults_[i]);\n                withdrawable_ = _getVaultT1Withdrawable(swap_.path.protocol, swap_.path.tokenOut);\n                if (withdrawable_ == 0) {\n                    continue;\n                }\n\n                ++nonZeroSwaps_;\n\n                allSwaps_[i] = _getSwapAccountingForWithdrawable(swap_, withdrawable_);\n            }\n\n            return _getNonZeroSwaps(allSwaps_, nonZeroSwaps_);\n        }\n    }\n\n    /// @notice returns all available `swaps_` for all Fluid vaults. Only returns non-zero swaps.\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\n    ///         better ratio.\n    function getAllVaultsSwap() public returns (Swap[] memory swaps_) {\n        return getVaultsSwap(_getVaultT1s());\n    }\n\n    /// @notice returns all the available `swaps_` for certain swap `paths_`. Only returns non-zero swaps.\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\n    ///         better ratio.\n    function getSwapsForPaths(SwapPath[] memory paths_) public returns (Swap[] memory swaps_) {\n        unchecked {\n            Swap[] memory allSwaps_ = new Swap[](paths_.length);\n\n            uint256 nonZeroSwaps_;\n            Swap memory swap_;\n            SwapData memory withoutAbsorb_;\n            SwapData memory withAbsorb_;\n            uint256 withdrawable_;\n            for (uint256 i; i < paths_.length; ++i) {\n                (withoutAbsorb_, withAbsorb_) = getVaultSwapData(paths_[i].protocol);\n                swap_ = Swap({ path: paths_[i], data: _getBetterRatioSwapData(withoutAbsorb_, withAbsorb_) });\n\n                if (swap_.data.inAmt == 0) {\n                    // no swap available on this vault\n                    continue;\n                }\n                withdrawable_ = _getVaultT1Withdrawable(swap_.path.protocol, swap_.path.tokenOut);\n                if (withdrawable_ == 0) {\n                    continue;\n                }\n\n                ++nonZeroSwaps_;\n\n                allSwaps_[i] = _getSwapAccountingForWithdrawable(swap_, withdrawable_);\n            }\n\n            return _getNonZeroSwaps(allSwaps_, nonZeroSwaps_);\n        }\n    }\n\n    /// @notice finds all available `swaps_` for `tokenIn_` to `tokenOut_`.\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\n    ///         better ratio.\n    function getSwaps(address tokenIn_, address tokenOut_) public returns (Swap[] memory swaps_) {\n        return getSwapsForPaths(getSwapPaths(tokenIn_, tokenOut_));\n    }\n\n    /// @notice finds all available `swaps_` for any `tokensIn_` to any `tokesnOut_`.\n    ///         Token pairs that are not available or where available swap amounts are zero\n    ///         will not be present in the returned `swaps_` array.\n    ///         returns only either the with absorb swap or without absorb swap for each vault, whichever has the\n    ///         better ratio.\n    function getAnySwaps(\n        address[] calldata tokensIn_,\n        address[] calldata tokensOut_\n    ) public returns (Swap[] memory swaps_) {\n        return getSwapsForPaths(getAnySwapPaths(tokensIn_, tokensOut_));\n    }\n\n    /// @notice returns the calldata to execute a swap as returned by the other methods in this contract.\n    ///         `swap_.data.inAmt` must come from msg.sender, `swap_.data.outAmt` goes to `receiver_`. If the input token\n    ///         is the native token, msg.value must be sent along when triggering the actual call with the returned calldata\n    ///         which should be `swap_.data.inAmt`.\n    /// @param swap_ Swap struct as returned by other methods\n    /// @param receiver_ receiver address that the output token is sent to\n    /// @param slippage_ maximum allowed slippage for the expected output token amount. Reverts iIf received token out\n    ///                  amount is lower than this. in 1e4 percentage, e.g. 1% = 10000, 0.3% = 3000, 0.01% = 100, 0.0001% = 1.\n    /// @return target_ target address where `calldata_` must be executed\n    /// @return calldata_ the calldata that can be used to trigger the liquidation call, resulting in the desired swap.\n    function getSwapTx(\n        Swap calldata swap_,\n        address receiver_,\n        uint256 slippage_\n    ) public pure returns (address target_, bytes memory calldata_) {\n        if (swap_.path.protocol == address(0) || receiver_ == address(0)) {\n            revert FluidVaultLiquidationsResolver__AddressZero();\n        }\n        if (slippage_ >= 1e6 || swap_.data.inAmt == 0 || swap_.data.outAmt == 0) {\n            revert FluidVaultLiquidationsResolver__InvalidParams();\n        }\n\n        uint256 colPerUnitDebt_ = (swap_.data.outAmt * 1e18) / swap_.data.inAmt;\n        colPerUnitDebt_ = (colPerUnitDebt_ * (1e6 - slippage_)) / 1e6; // e.g. 50 * 99% / 100% = 49.5\n\n        calldata_ = abi.encodeWithSelector(\n            IFluidVaultT1(swap_.path.protocol).liquidate.selector,\n            swap_.data.inAmt,\n            colPerUnitDebt_,\n            receiver_,\n            swap_.data.withAbsorb\n        );\n        target_ = swap_.path.protocol;\n    }\n\n    /// @notice returns the same data as `getSwapTx` for an array of input `swaps_` at once.\n    function getSwapTxs(\n        Swap[] calldata swaps_,\n        address receiver_,\n        uint256 slippage_\n    ) public pure returns (address[] memory targets_, bytes[] memory calldatas_) {\n        targets_ = new address[](swaps_.length);\n        calldatas_ = new bytes[](swaps_.length);\n        for (uint256 i; i < swaps_.length; ++i) {\n            (targets_[i], calldatas_[i]) = getSwapTx(swaps_[i], receiver_, slippage_);\n        }\n    }\n\n    /// @notice finds all swaps from `tokenIn_` to `tokenOut_` for an exact input amount `inAmt_`.\n    ///         filters the available swaps and sorts them by ratio, so the returned swaps are the best available\n    ///         swaps to reach the target `inAmt_`.\n    ///         If the full available amount is less than the target `inAmt_`, the available amount is returned as `actualInAmt_`.\n    /// @dev The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better\n    /// but the target swap amount is more than the available without absorb liquidity. For this, currently the available\n    /// withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity.\n    /// The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false\n    /// to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing\n    /// amount up to the target amount with the worse ratio with absorb liquidity.\n    /// @param tokenIn_ input token\n    /// @param tokenOut_ output token\n    /// @param inAmt_ exact input token amount that should be swapped to output token\n    /// @return swaps_ swaps to reach the target amount, sorted by ratio in descending order\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\n    /// @return actualInAmt_ actual input token amount. Can be less than inAmt_ if all available swaps can not cover\n    ///                      the target amount.\n    /// @return outAmt_ output token amount received for `actualInAmt_`\n    function exactInput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 inAmt_\n    ) public returns (Swap[] memory swaps_, uint256 actualInAmt_, uint256 outAmt_) {\n        return filterToTargetInAmt(getSwapsRaw(tokenIn_, tokenOut_), inAmt_);\n    }\n\n    /// @notice finds all swaps from `tokenIn_` to `tokenOut_` for an APPROXIMATE output amount `outAmt_`.\n    ///         filters the available swaps and sorts them by ratio, so the returned swaps are the best available\n    ///         swaps to reach the target `outAmt_`.\n    ///         If the full available amount is less than the target `outAmt_`, the available amount is returned as `actualOutAmt_`.\n    ///         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to\n    ///         approximately estimate the required input amounts to reach a certain output amount. This\n    ///         will change until execution and should be controlled with a maximum slippage.\n    ///         Recommended to use exact input methods instead.\n    /// @dev The only cases that are currently not best possible optimized for are when the ratio for withoutAbsorb is better\n    /// but the target swap amount is more than the available without absorb liquidity. For this currently the available\n    /// withAbsorb liquidity is consumed first before tapping into the better ratio withoutAbsorb liquidity.\n    /// The optimized version would be to split the tx into two swaps, first executing liquidate() with absorb = false\n    /// to fully swap all the withoutAbsorb liquidity, and then in the second tx run with absorb = true to fill the missing\n    /// amount up to the target amount with the worse ratio with absorb liquidity.\n    /// @param tokenIn_ input token\n    /// @param tokenOut_ output token\n    /// @param outAmt_ exact output token amount that should be swapped to from input token\n    /// @return swaps_ swaps to reach the target amount, sorted by ratio in descending order\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\n    /// @return inAmt_ input token amount needed to receive `actualOutAmt_`\n    /// @return approxOutAmt_ approximate output token amount. Can be less than `outAmt_` if all available swaps can not cover\n    ///                       the target amount.\n    function approxOutput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 outAmt_\n    ) public returns (Swap[] memory swaps_, uint256 inAmt_, uint256 approxOutAmt_) {\n        return filterToApproxOutAmt(getSwapsRaw(tokenIn_, tokenOut_), outAmt_);\n    }\n\n    /// @notice filters the `swaps_` to the point where `targetInAmt_` is reached.\n    ///         This is best used in combination with the \"Raw\" methods, as the `targetInAmt_` allows for more optimized\n    ///         filtering than otherwise done with the non-\"Raw\" methods.\n    /// @return filteredSwaps_ swaps to reach the target amount, sorted by ratio in descending order\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\n    /// @return actualInAmt_ actual input amount. Can be less than targetInAmt_ if all available swaps can not cover\n    ///                      the target amount.\n    /// @return approxOutAmt_ actual estimated output amount.\n    function filterToTargetInAmt(\n        Swap[] memory swaps_,\n        uint256 targetInAmt_\n    ) public returns (Swap[] memory filteredSwaps_, uint256 actualInAmt_, uint256 approxOutAmt_) {\n        return _filterToTarget(swaps_, targetInAmt_, type(uint256).max);\n    }\n\n    /// @notice filters the `swaps_` to the point where APPROXIMATELY `targetOutAmt_` is reached.\n    ///         IMPORTANT: guaranteed exact output swaps are not possible with Fluid, this method only aims to\n    ///         approximately estimate the required input amounts to reach a certain output amount. This\n    ///         will change until execution and should be controlled with a maximum slippage.\n    ///         Recommended to use exact input methods instead.\n    ///         This is best used in combination with the \"Raw\" methods, as the `targetInAmt_` allows for more optimized\n    ///         filtering than otherwise done with the non-\"Raw\" methods.\n    /// @return filteredSwaps_ swaps to reach the target amount, sorted by ratio in descending order\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\n    /// @return actualInAmt_ actual input amount.\n    /// @return approxOutAmt_ APPROXIMATE actual output amount. Can be less than targetOutAmt_ if all available swaps\n    ///                      can not cover the target amount.\n    function filterToApproxOutAmt(\n        Swap[] memory swaps_,\n        uint256 targetApproxOutAmt_\n    ) public returns (Swap[] memory filteredSwaps_, uint256 actualInAmt_, uint256 approxOutAmt_) {\n        return _filterToTarget(swaps_, type(uint256).max, targetApproxOutAmt_);\n    }\n\n    function _getUserSupplyData(address user_, address token_) internal view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n                    user_,\n                    token_\n                )\n            );\n    }\n\n    function _getExchangePricesAndConfig(address token_) internal view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n                    token_\n                )\n            );\n    }\n\n    address private constant WEETH = 0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee;\n    address private constant WEETHS = 0x917ceE801a67f933F2e6b33fC0cD1ED2d5909D88;\n    address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    // @dev do change this address after deployment of holder\n    ISUSDSHolder private constant SUSDS_HOLDER = ISUSDSHolder(0x470e8de2eBaef52014A47Cb5E6aF86884947F08c);\n    IZtakingPool private constant ZIRCUIT = IZtakingPool(0xF047ab4c75cebf0eB9ed34Ae2c186f3611aEAfa6);\n\n    /// @dev get withdrawable amount at a certain T1 vault, which limits liquidations. Incl. balance check at Liquidity\n    function _getVaultT1Withdrawable(address vault_, address token_) internal view returns (uint256 withdrawable_) {\n        uint256 userSupplyData_ = _getUserSupplyData(vault_, token_);\n\n        if (userSupplyData_ == 0) {\n            return 0;\n        }\n\n        uint256 userSupply_ = BigMathMinified.fromBigNumber(\n            (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & LiquidityCalcs.X64,\n            LiquidityCalcs.DEFAULT_EXPONENT_SIZE,\n            LiquidityCalcs.DEFAULT_EXPONENT_MASK\n        );\n\n        // get updated expanded withdrawal limit\n        uint256 withdrawalLimit_ = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\n\n        if (userSupplyData_ & 1 == 1) {\n            uint256 exchangePricesAndConfig_ = _getExchangePricesAndConfig(token_);\n            if (exchangePricesAndConfig_ == 0) {\n                return 0;\n            }\n            (uint256 supplyExchangePrice_, ) = LiquidityCalcs.calcExchangePrices(exchangePricesAndConfig_);\n            // convert raw amounts to normal for withInterest mode\n            userSupply_ = (userSupply_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION;\n            withdrawalLimit_ = (withdrawalLimit_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION;\n        }\n\n        withdrawable_ = userSupply_ > withdrawalLimit_ ? userSupply_ - withdrawalLimit_ : 0;\n        uint256 balanceOf_ = token_ == NATIVE_TOKEN_ADDRESS\n            ? address(LIQUIDITY).balance\n            : TokenInterface(token_).balanceOf(address(LIQUIDITY));\n        if (token_ == WEETH) {\n            balanceOf_ += ZIRCUIT.balance(WEETH, address(LIQUIDITY));\n        }\n        if (token_ == WEETHS) {\n            balanceOf_ += ZIRCUIT.balance(WEETHS, address(LIQUIDITY));\n        }\n        if (token_ == USDC) {\n            balanceOf_ += SUSDS_HOLDER.previewUSDCBalance();\n        }\n\n        withdrawable_ = balanceOf_ > withdrawable_ ? withdrawable_ : balanceOf_;\n    }\n\n    /// @dev limits a Swap liquidatable amount according to actually col side withdrawable amount\n    function _getSwapAccountingForWithdrawable(\n        Swap memory swap_,\n        uint256 withdrawable_\n    ) internal pure returns (Swap memory) {\n        if (swap_.data.outAmt == 0) {\n            return swap_;\n        }\n\n        if (withdrawable_ < swap_.data.outAmt) {\n            // reduce swap in and out amount to max withdrawable\n            swap_.data.inAmt = (swap_.data.inAmt * withdrawable_) / swap_.data.outAmt;\n            swap_.data.outAmt = withdrawable_;\n        }\n\n        return swap_;\n    }\n\n    /// @dev filters the `swaps_` to the point where either `targetInAmt_` or `targetOutAmt_` is reached.\n    ///         To filter only by in or only by out amount, send `type(uint256).max` for the other param.\n    /// @return filteredSwaps_ swaps to reach the target amount, sorted by ratio in descending order\n    ///         (higher ratio = better rate). Best ratio swap will be at pos 0, second best at pos 1 and so on.\n    /// @return actualInAmt_ actual input amount. Can be less than targetInAmt_ if all available swaps can not cover\n    ///                      the target amount.\n    /// @return actualOutAmt_ actual output amount. Can be less than targetOutAmt_ if all available swaps can not cover\n    ///                      the target amount.\n    function _filterToTarget(\n        Swap[] memory swaps_,\n        uint256 targetInAmt_,\n        uint256 targetOutAmt_\n    ) internal returns (Swap[] memory filteredSwaps_, uint256 actualInAmt_, uint256 actualOutAmt_) {\n        swaps_ = _sortByRatio(swaps_);\n        (filteredSwaps_, actualInAmt_, actualOutAmt_) = _filterSwapsUntilTarget(swaps_, targetInAmt_, targetOutAmt_);\n\n        if (actualInAmt_ > targetInAmt_ || actualOutAmt_ > targetOutAmt_) {\n            // reduce last swap in amt to match target in amt\n            uint256 lastSwapIndex_ = filteredSwaps_.length - 1;\n\n            uint256 missingInAmt_;\n            if (actualInAmt_ > targetInAmt_) {\n                // swaps_[i].data.inAmt is causing that we over reach targetInAmt_\n                // so to get missing account from here until targetInAmt_, we only want\n                // swaps_[i].data.inAmt minus whatever is too much (actualInAmt_ - targetInAmt_)\n                missingInAmt_ = filteredSwaps_[lastSwapIndex_].data.inAmt + 1 - (actualInAmt_ - targetInAmt_);\n            } else {\n                // get missing in amt to use for liquidation call input param based on missing out amt and ratio\n                uint256 missingOutAmt_ = filteredSwaps_[lastSwapIndex_].data.outAmt - (actualOutAmt_ - targetOutAmt_);\n\n                // get total available liquidation and the ratios for with absorb vs without absorb\n                VaultResolverStructs.LiquidationStruct memory liquidationDataAvailable_ = VAULT_RESOLVER\n                    .getVaultLiquidation(filteredSwaps_[lastSwapIndex_].path.protocol, 0);\n\n                uint256 withoutAbsorbRatio_ = _calcRatio(\n                    liquidationDataAvailable_.inAmt,\n                    liquidationDataAvailable_.outAmt\n                );\n                // calculate the ratio of the absorb only liquidity part\n                uint256 absorbOnlyRatio_ = _calcRatio(\n                    liquidationDataAvailable_.inAmtWithAbsorb - liquidationDataAvailable_.inAmt,\n                    liquidationDataAvailable_.outAmtWithAbsorb - liquidationDataAvailable_.outAmt\n                );\n                if (absorbOnlyRatio_ > withoutAbsorbRatio_ || liquidationDataAvailable_.outAmt < missingOutAmt_) {\n                    // with absorb has the better ratio than without absorb or without absorb can not fully cover\n                    // the missing out amount. So with absorb has to be run.\n                    // Note for the case liquidationDataAvailable_.outAmt < missingOutAmt_:\n                    // missing in amt would ideally be a combination of the whole without absorb liquidity +\n                    // some left over which has the different (worse) with absorb ratio.\n                    // when running withAbsorb = true, always the whole with absorb liquidity is taken first.\n                    // so to profit of the better without absorb liquidity, this would have to be turned into 2 swaps.\n                    // but this might not always be better because of gas usage etc., so for simplicity we just\n                    // take the whole absorb liquidity first.\n\n                    // check if absorb only liquidity covers the missing out amount, if so then the swap ratio is already known\n                    // as absorbOnlyRatio_ which can be used to derive the required inAmt\n                    uint256 asborbOnlyLiquidity_ = liquidationDataAvailable_.outAmtWithAbsorb -\n                        liquidationDataAvailable_.outAmt;\n                    if (asborbOnlyLiquidity_ >= missingOutAmt_) {\n                        missingInAmt_ = (missingOutAmt_ * 1e27) / absorbOnlyRatio_ + 1;\n                    } else {\n                        // missing in amt is a combination of the whole absorb liquidity + some left over\n                        // which has the different without absorb ratio\n                        missingInAmt_ = (asborbOnlyLiquidity_ * 1e27) / absorbOnlyRatio_ + 1;\n                        missingInAmt_ += ((missingOutAmt_ - asborbOnlyLiquidity_) * 1e27) / withoutAbsorbRatio_ + 1;\n                    }\n                } else {\n                    // without absorb has the better ratio AND missing out amount can be covered by without absorb liquidity\n                    missingInAmt_ = (missingOutAmt_ * 1e27) / withoutAbsorbRatio_ + 1;\n                }\n            }\n\n            VaultResolverStructs.LiquidationStruct memory liquidationData_ = VAULT_RESOLVER.getVaultLiquidation(\n                filteredSwaps_[lastSwapIndex_].path.protocol,\n                missingInAmt_\n            );\n\n            actualInAmt_ -= filteredSwaps_[lastSwapIndex_].data.inAmt;\n            actualOutAmt_ -= filteredSwaps_[lastSwapIndex_].data.outAmt;\n\n            if (filteredSwaps_[lastSwapIndex_].data.withAbsorb) {\n                filteredSwaps_[lastSwapIndex_].data.inAmt = liquidationData_.inAmtWithAbsorb;\n                filteredSwaps_[lastSwapIndex_].data.outAmt = liquidationData_.outAmtWithAbsorb;\n                filteredSwaps_[lastSwapIndex_].data.ratio = _calcRatio(\n                    liquidationData_.inAmtWithAbsorb,\n                    liquidationData_.outAmtWithAbsorb\n                );\n            } else {\n                filteredSwaps_[lastSwapIndex_].data.inAmt = liquidationData_.inAmt;\n                filteredSwaps_[lastSwapIndex_].data.outAmt = liquidationData_.outAmt;\n                filteredSwaps_[lastSwapIndex_].data.ratio = _calcRatio(liquidationData_.inAmt, liquidationData_.outAmt);\n            }\n\n            actualInAmt_ += filteredSwaps_[lastSwapIndex_].data.inAmt;\n            actualOutAmt_ += filteredSwaps_[lastSwapIndex_].data.outAmt;\n        }\n    }\n\n    /// @dev sorts `swaps_` by ratio descending. Higher ratio is better (getting more output for input).\n    ///      Best ratio swap will be at pos 0, second best at pos 1 and so on\n    function _sortByRatio(Swap[] memory swaps_) internal pure returns (Swap[] memory) {\n        bool swapped_;\n        Swap memory helper_;\n        for (uint256 i = 1; i < swaps_.length; i++) {\n            swapped_ = false;\n            for (uint256 j = 0; j < swaps_.length - i; j++) {\n                if (swaps_[j + 1].data.ratio > swaps_[j].data.ratio) {\n                    helper_ = swaps_[j];\n                    swaps_[j] = swaps_[j + 1];\n                    swaps_[j + 1] = helper_;\n                    swapped_ = true;\n                }\n            }\n            if (!swapped_) {\n                return swaps_;\n            }\n        }\n\n        return swaps_;\n    }\n\n    /// @dev filters `swaps_` to exactly reach `targetInAmt_`. Takes into consideration to filter out any swaps\n    ///      where both the withAbsorb and withoutAbsorb swap would be present for the same protocol, only\n    ///      leaving the withAbsorb swap (as that includes withoutAbsorb).\n    ///      Also returns the total in `sumInAmt_` and out `sumOutAmt_` amounts, which will be less than `targetInAmt_`\n    ///      in the case that the target amount can not be reached even with all swaps.\n    function _filterSwapsUntilTarget(\n        Swap[] memory swaps_,\n        uint256 targetInAmt_,\n        uint256 targetOutAmt_\n    ) internal returns (Swap[] memory filteredSwaps_, uint256 sumInAmt_, uint256 sumOutAmt_) {\n        if (swaps_.length == 0) {\n            return (swaps_, 0, 0);\n        }\n        uint256 filteredCount_;\n        // find swaps needed until target in amt\n        while (sumInAmt_ < targetInAmt_ && sumOutAmt_ < targetOutAmt_ && filteredCount_ < swaps_.length) {\n            sumInAmt_ += swaps_[filteredCount_].data.inAmt;\n            sumOutAmt_ += swaps_[filteredCount_].data.outAmt;\n            ++filteredCount_;\n        }\n\n        // must not double count without absorb when with absorb is already present\n        // until filteredCount, for any protocol where with absorb is present,\n        // filter out the without absorb if that swap is present too.\n        // if any is found then the while to find swaps until targetAmt must be run again\n        // as it will be less with the filtered out element deducted.\n        uint256 duplicatesCount_;\n        for (uint256 i; i < filteredCount_ - 1; ++i) {\n            for (uint256 j = i + 1; j < filteredCount_; ++j) {\n                if (swaps_[i].path.protocol == swaps_[j].path.protocol) {\n                    // same protocol present twice (with and without absorb).\n                    // mark without absorb to be removed by setting the inAmt to 0\n                    if (swaps_[i].data.withAbsorb) {\n                        swaps_[j].data.inAmt = 0;\n                    } else {\n                        swaps_[i].data.inAmt = 0;\n                    }\n                    duplicatesCount_++;\n                }\n            }\n        }\n\n        if (duplicatesCount_ > 0) {\n            uint256 index_;\n            // filter swaps that are set to 0\n            filteredSwaps_ = new Swap[](swaps_.length - duplicatesCount_);\n            for (uint256 i; i < swaps_.length; ++i) {\n                if (swaps_[i].data.inAmt > 0) {\n                    filteredSwaps_[index_] = swaps_[i];\n                    ++index_;\n                }\n            }\n\n            // recursive call again to reach target amount as planned.\n            return _filterSwapsUntilTarget(filteredSwaps_, targetInAmt_, targetOutAmt_);\n        }\n\n        // when clean of duplicates -> finished, return filtered swaps and total sumInAmt\n        filteredSwaps_ = new Swap[](filteredCount_);\n        for (uint256 i; i < filteredCount_; ++i) {\n            filteredSwaps_[i] = swaps_[i];\n        }\n        return (filteredSwaps_, sumInAmt_, sumOutAmt_);\n    }\n\n    /// @dev gets the better swap based on ratio of with vs without absorb swap data.\n    function _getBetterRatioSwapData(\n        SwapData memory withoutAbsorb_,\n        SwapData memory withAbsorb_\n    ) internal pure returns (SwapData memory swap_) {\n        if (withAbsorb_.inAmt == 0) {\n            // if ratio == 0, meaning inAmt is 0, then the with absorb swap is returned.\n            return withAbsorb_;\n        }\n\n        if (withAbsorb_.ratio > withoutAbsorb_.ratio) {\n            // If (ratio of withAbsorb > ratio of withoutAbsorb) then always absorb should be true.\n            return withAbsorb_;\n        }\n\n        if (withAbsorb_.ratio == withoutAbsorb_.ratio) {\n            if (withAbsorb_.inAmt == withoutAbsorb_.inAmt) {\n                // with absorb has the same liquidity as without absorb.\n                // running liquidate() with absorb in that case only costs extra gas. return only without absorb swap\n                return withoutAbsorb_;\n            }\n\n            // with absorb has more liquidity, but same ratio -> return with absorb\n            return withAbsorb_;\n        }\n\n        // ratio of without absorb is better.\n        // Note: case where with absorb has worse ratio. but it could have significant more liquidity -> will not be\n        // returned here as long as there is without absorb liquidity...\n        return withoutAbsorb_;\n    }\n\n    /// @dev filters `allSwaps_` to the non zero amount `swaps_`, knowing the `nonZeroSwapsCount_`\n    function _getNonZeroSwaps(\n        Swap[] memory allSwaps_,\n        uint256 nonZeroSwapsCount_\n    ) internal pure returns (Swap[] memory swaps_) {\n        unchecked {\n            swaps_ = new Swap[](nonZeroSwapsCount_);\n            uint256 index_;\n            for (uint256 i; i < allSwaps_.length; ++i) {\n                if (allSwaps_[i].data.inAmt > 0) {\n                    swaps_[index_] = allSwaps_[i];\n                    ++index_;\n                }\n            }\n        }\n    }\n\n    /// @dev gets the `vault_` token in (borrow token) and token out (supply token)\n    function _getVaultTokens(address vault_) internal view returns (address tokenIn_, address tokenOut_) {\n        IFluidVaultT1.ConstantViews memory constants_ = IFluidVaultT1(vault_).constantsView();\n        return (constants_.borrowToken, constants_.supplyToken);\n    }\n\n    /// @dev returns ratio for how much outAmt_ am I getting for inAmt_. scaled by 1e27\n    function _calcRatio(uint256 inAmt_, uint256 outAmt_) internal pure returns (uint256) {\n        if (outAmt_ == 0) {\n            return 0;\n        }\n        return (outAmt_ * 1e27) / inAmt_;\n    }\n\n    /// @dev returns all VaultT1 type protocols at the Fluid VaultFactory\n    function _getVaultT1s() internal view returns (address[] memory) {\n        return FluidProtocolTypes.filterBy(VAULT_RESOLVER.getAllVaultsAddresses(), FluidProtocolTypes.VAULT_T1_TYPE);\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultLiquidation/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Structs {\n    struct SwapPath {\n        ///\n        /// @param protocol vault address at which the token pair is available\n        address protocol;\n        ///\n        /// @param tokenIn input token, borrow token at the vault\n        address tokenIn;\n        ///\n        /// @param tokenOut output token, collateral token at the vault\n        address tokenOut;\n    }\n\n    struct SwapData {\n        ///\n        /// @param inAmt total input token amount\n        uint256 inAmt;\n        ///\n        /// @param outAmt total output token amount received\n        uint256 outAmt;\n        ///\n        /// @param withAbsorb flag for using mode \"withAbsorb\" when calling liquidate() on the Vault.\n        ///                   Is set to true if a) liquidity without absorb would not\n        ///                   cover the desired `inAmt_` or if b) the rate of with absorb is better than without absorb.\n        bool withAbsorb;\n        ///\n        /// @param ratio ratio of outAmt / inAmt scaled by 1e27\n        uint256 ratio;\n    }\n\n    struct Swap {\n        ///\n        /// @param path swap path struct info such as protocol where the swap is available\n        SwapPath path;\n        ///\n        /// @param data swap data struct info such as amounts\n        SwapData data;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultLiquidation/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidVaultResolver } from \"../vault/iVaultResolver.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\n\ncontract Variables {\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    IFluidVaultResolver public immutable VAULT_RESOLVER;\n\n    /// @notice address of the liquidity contract\n    IFluidLiquidity public immutable LIQUIDITY;\n\n    constructor(IFluidVaultResolver vaultResolver_, IFluidLiquidity liquidity_) {\n        VAULT_RESOLVER = vaultResolver_;\n        LIQUIDITY = liquidity_;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultT1/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Variables } from \"./variables.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { TickMath } from \"../../../libraries/tickMath.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\n\ncontract Helpers is Variables, Structs {\n    function normalSlot(uint256 slot_) public pure returns (bytes32) {\n        return bytes32(slot_);\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping\n    function calculateStorageSlotUintMapping(uint256 slot_, uint key_) public pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping\n    function calculateStorageSlotIntMapping(uint256 slot_, int key_) public pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping\n    function calculateDoubleIntUintMapping(uint256 slot_, int key1_, uint key2_) public pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n\n    function tickHelper(uint tickRaw_) public pure returns (int tick) {\n        require(tickRaw_ < X20, \"invalid-number\");\n        if (tickRaw_ > 0) {\n            tick = tickRaw_ & 1 == 1 ? int((tickRaw_ >> 1) & X19) : -int((tickRaw_ >> 1) & X19);\n        } else {\n            tick = type(int).min;\n        }\n    }\n\n    constructor(\n        address factory_,\n        address liquidity_,\n        address liquidityResolver_\n    ) Variables(factory_, liquidity_, liquidityResolver_) {}\n}\n"
    },
    "contracts/periphery/resolvers/vaultT1/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Helpers } from \"./helpers.sol\";\nimport { TickMath } from \"../../../libraries/tickMath.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\nimport { IFluidOracle } from \"../../../oracle/fluidOracle.sol\";\nimport { IFluidVaultT1 } from \"../../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { Structs as FluidLiquidityResolverStructs } from \"../liquidity/structs.sol\";\nimport { LiquiditySlotsLink } from \"../../../libraries/liquiditySlotsLink.sol\";\nimport { LiquidityCalcs } from \"../../../libraries/liquidityCalcs.sol\";\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { FluidProtocolTypes, IFluidProtocol } from \"../../../libraries/fluidProtocolTypes.sol\";\nimport { IFluidLiquidity } from \"./variables.sol\";\n\ninterface TokenInterface {\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IZtakingPool {\n    function balance(address token_, address staker_) external view returns (uint256);\n}\n\n/// @notice Fluid VaultT1 protocol resolver\n/// ATTENTION: Use VaultResolver instead! This is just a temporary legacy-compatible resolver.\n/// Implements various view-only methods to give easy access to Vault protocol data.\ncontract FluidVaultT1Resolver is Helpers {\n    constructor(\n        address factory_,\n        address liquidity_,\n        address liquidityResolver_\n    ) Helpers(factory_, liquidity_, liquidityResolver_) {}\n\n    /// @notice Get the address of a vault.\n    /// @param vaultId_ The ID of the vault.\n    /// @return vault_ The address of the vault.\n    function getVaultAddress(uint vaultId_) public view returns (address vault_) {\n        return AddressCalcs.addressCalc(address(FACTORY), vaultId_);\n    }\n\n    /// @notice Get the type of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return vaultType_ The type of the vault. 0 if not a Fluid vault.\n    function getVaultType(address vault_) public view returns (uint vaultType_) {\n        if (vault_.code.length == 0) {\n            return 0;\n        }\n        try IFluidProtocol(vault_).TYPE() returns (uint type_) {\n            return type_;\n        } catch {\n            if (getVaultAddress(getVaultId(vault_)) != vault_) {\n                return 0;\n            }\n            // if TYPE() is not available but address is valid vault id, it must be vault T1\n            return FluidProtocolTypes.VAULT_T1_TYPE;\n        }\n    }\n\n    /// @notice Get the ID of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return id_ The ID of the vault.\n    function getVaultId(address vault_) public view returns (uint id_) {\n        id_ = IFluidVaultT1(vault_).VAULT_ID();\n    }\n\n    /// @notice Get the token configuration.\n    /// @param nftId_ The ID of the NFT.\n    /// @return The token configuration.\n    function getTokenConfig(uint nftId_) public view returns (uint) {\n        return FACTORY.readFromStorage(calculateStorageSlotUintMapping(3, nftId_));\n    }\n\n    /// @notice Get the raw variables of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The raw variables of the vault.\n    function getVaultVariablesRaw(address vault_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(normalSlot(0));\n    }\n\n    /// @notice Get the raw variables of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The raw variables of the vault.\n    function getVaultVariables2Raw(address vault_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(normalSlot(1));\n    }\n\n    /// @notice Get the absorbed liquidity of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The absorbed liquidity of the vault.\n    function getAbsorbedLiquidityRaw(address vault_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(normalSlot(2));\n    }\n\n    /// @notice Get the position data of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param positionId_ The ID of the position.\n    /// @return The position data of the vault.\n    function getPositionDataRaw(address vault_, uint positionId_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(calculateStorageSlotUintMapping(3, positionId_));\n    }\n\n    /// @notice Get the raw tick data of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param tick_ The tick value.\n    /// @return The raw tick data of the vault.\n    // if tick > 0 then key_ = tick / 256\n    // if tick < 0 then key_ = (tick / 256) - 1\n    function getTickDataRaw(address vault_, int tick_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(calculateStorageSlotIntMapping(5, tick_));\n    }\n\n    /// @notice Get the raw tick data of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param key_ The tick key.\n    /// @return The raw tick data of the vault.\n    function getTickHasDebtRaw(address vault_, int key_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(calculateStorageSlotIntMapping(4, key_));\n    }\n\n    /// @notice Get the raw tick data of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param tick_ The tick value.\n    /// @param id_ The ID of the tick.\n    /// @return The raw tick data of the vault.\n    // id_ = (realId_ / 3) + 1\n    function getTickIdDataRaw(address vault_, int tick_, uint id_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(calculateDoubleIntUintMapping(6, tick_, id_));\n    }\n\n    /// @notice Get the raw branch data of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param branch_ The branch value.\n    /// @return The raw branch data of the vault.\n    function getBranchDataRaw(address vault_, uint branch_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(calculateStorageSlotUintMapping(7, branch_));\n    }\n\n    /// @notice Get the raw rate of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The raw rate of the vault.\n    function getRateRaw(address vault_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(normalSlot(8));\n    }\n\n    /// @notice Get the rebalancer of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The rebalancer of the vault.\n    function getRebalancer(address vault_) public view returns (address) {\n        return address(uint160(IFluidVaultT1(vault_).readFromStorage(normalSlot(9))));\n    }\n\n    /// @notice Get the absorbed dust debt of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return The absorbed dust debt of the vault.\n    function getAbsorbedDustDebt(address vault_) public view returns (uint) {\n        return IFluidVaultT1(vault_).readFromStorage(normalSlot(10));\n    }\n\n    /// @notice Get the total number of vaults (incl. new vault types).\n    /// @return The total number of vaults.\n    function getTotalVaults() public view returns (uint) {\n        return FACTORY.totalVaults();\n    }\n\n    /// @notice Get the addresses of all the vaults.\n    /// @return vaults_ The addresses of all the vaults.\n    function getAllVaultsAddresses() public view returns (address[] memory vaults_) {\n        uint totalVaults_ = getTotalVaults();\n        vaults_ = new address[](totalVaults_);\n        for (uint i = 0; i < totalVaults_; i++) {\n            vaults_[i] = getVaultAddress((i + 1));\n        }\n        return FluidProtocolTypes.filterBy(vaults_, FluidProtocolTypes.VAULT_T1_TYPE);\n    }\n\n    /// @dev Get the constants of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return constants_ The constants of the vault.\n    function _getVaultConstants(address vault_) internal view returns (IFluidVaultT1.ConstantViews memory constants_) {\n        constants_ = IFluidVaultT1(vault_).constantsView();\n    }\n\n    /// @dev Get the configuration of a vault.\n    /// @param vault_ The address of the vault.\n    /// @return configs_ The configuration of the vault.\n    function _getVaultConfig(address vault_) internal view returns (Configs memory configs_) {\n        uint vaultVariables2_ = getVaultVariables2Raw(vault_);\n        configs_.supplyRateMagnifier = uint16(vaultVariables2_ & X16);\n        configs_.borrowRateMagnifier = uint16((vaultVariables2_ >> 16) & X16);\n        configs_.collateralFactor = (uint16((vaultVariables2_ >> 32) & X10)) * 10;\n        configs_.liquidationThreshold = (uint16((vaultVariables2_ >> 42) & X10)) * 10;\n        configs_.liquidationMaxLimit = (uint16((vaultVariables2_ >> 52) & X10) * 10);\n        configs_.withdrawalGap = uint16((vaultVariables2_ >> 62) & X10) * 10;\n        configs_.liquidationPenalty = uint16((vaultVariables2_ >> 72) & X10);\n        configs_.borrowFee = uint16((vaultVariables2_ >> 82) & X10);\n        configs_.oracle = address(uint160(vaultVariables2_ >> 96));\n\n        if (configs_.oracle != address(0)) {\n            try IFluidOracle(configs_.oracle).getExchangeRateOperate() returns (uint exchangeRate_) {\n                configs_.oraclePriceOperate = exchangeRate_;\n                configs_.oraclePriceLiquidate = IFluidOracle(configs_.oracle).getExchangeRateLiquidate();\n            } catch {\n                // deprecated backward compatible for older vaults oracles\n                configs_.oraclePriceOperate = IFluidOracle(configs_.oracle).getExchangeRate();\n                configs_.oraclePriceLiquidate = configs_.oraclePriceOperate;\n            }\n        }\n\n        configs_.rebalancer = getRebalancer(vault_);\n    }\n\n    /// @dev Get the exchange prices and rates of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param configs_ The configuration of the vault.\n    /// @param liquiditySupplyRate_ The liquidity supply rate\n    /// @param liquidityBorrowRate_ The liquidity borrow rate\n    /// @return exchangePricesAndRates_ The exchange prices and rates of the vault.\n    function _getExchangePricesAndRates(\n        address vault_,\n        Configs memory configs_,\n        uint liquiditySupplyRate_,\n        uint liquidityBorrowRate_\n    ) internal view returns (ExchangePricesAndRates memory exchangePricesAndRates_) {\n        uint exchangePrices_ = getRateRaw(vault_);\n        exchangePricesAndRates_.lastStoredLiquiditySupplyExchangePrice = exchangePrices_ & X64;\n        exchangePricesAndRates_.lastStoredLiquidityBorrowExchangePrice = (exchangePrices_ >> 64) & X64;\n        exchangePricesAndRates_.lastStoredVaultSupplyExchangePrice = (exchangePrices_ >> 128) & X64;\n        exchangePricesAndRates_.lastStoredVaultBorrowExchangePrice = (exchangePrices_ >> 192) & X64;\n\n        (\n            exchangePricesAndRates_.liquiditySupplyExchangePrice,\n            exchangePricesAndRates_.liquidityBorrowExchangePrice,\n            exchangePricesAndRates_.vaultSupplyExchangePrice,\n            exchangePricesAndRates_.vaultBorrowExchangePrice\n        ) = IFluidVaultT1(vault_).updateExchangePrices(getVaultVariables2Raw(vault_));\n\n        exchangePricesAndRates_.supplyRateLiquidity = liquiditySupplyRate_;\n        exchangePricesAndRates_.borrowRateLiquidity = liquidityBorrowRate_;\n\n        exchangePricesAndRates_.supplyRateVault = (liquiditySupplyRate_ * configs_.supplyRateMagnifier) / 10000;\n        exchangePricesAndRates_.borrowRateVault = (liquidityBorrowRate_ * configs_.borrowRateMagnifier) / 10000;\n        exchangePricesAndRates_.rewardsRate = configs_.supplyRateMagnifier > 10000\n            ? configs_.supplyRateMagnifier - 10000\n            : 0;\n    }\n\n    /// @dev Get the total supply and borrow of a vault.\n    /// @param vault_ The address of the vault.\n    /// @param exchangePricesAndRates_ The exchange prices and rates of the vault.\n    /// @param constantsVariables_ The constants and variables of the vault.\n    /// @return totalSupplyAndBorrow_ The total supply and borrow of the vault.\n    function _getTotalSupplyAndBorrow(\n        address vault_,\n        ExchangePricesAndRates memory exchangePricesAndRates_,\n        IFluidVaultT1.ConstantViews memory constantsVariables_\n    ) internal view returns (TotalSupplyAndBorrow memory totalSupplyAndBorrow_) {\n        uint vaultVariables_ = getVaultVariablesRaw(vault_);\n        uint absorbedLiquidity_ = getAbsorbedLiquidityRaw(vault_);\n        uint totalSupplyLiquidity_ = IFluidLiquidity(constantsVariables_.liquidity).readFromStorage(\n            constantsVariables_.liquidityUserSupplySlot\n        );\n        // extracting user's supply\n        totalSupplyLiquidity_ = (totalSupplyLiquidity_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n        // converting big number into normal number\n        totalSupplyLiquidity_ = (totalSupplyLiquidity_ >> 8) << (totalSupplyLiquidity_ & X8);\n\n        uint totalBorrowLiquidity_ = IFluidLiquidity(constantsVariables_.liquidity).readFromStorage(\n            constantsVariables_.liquidityUserBorrowSlot\n        );\n        // extracting user's borrow\n        totalBorrowLiquidity_ = (totalBorrowLiquidity_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n        // converting big number into normal number\n        totalBorrowLiquidity_ = (totalBorrowLiquidity_ >> 8) << (totalBorrowLiquidity_ & X8);\n\n        totalSupplyAndBorrow_.totalSupplyVault = (vaultVariables_ >> 82) & X64;\n        // Converting bignumber into normal number\n        totalSupplyAndBorrow_.totalSupplyVault =\n            (totalSupplyAndBorrow_.totalSupplyVault >> 8) <<\n            (totalSupplyAndBorrow_.totalSupplyVault & X8);\n        totalSupplyAndBorrow_.totalBorrowVault = (vaultVariables_ >> 146) & X64;\n        // Converting bignumber into normal number\n        totalSupplyAndBorrow_.totalBorrowVault =\n            (totalSupplyAndBorrow_.totalBorrowVault >> 8) <<\n            (totalSupplyAndBorrow_.totalBorrowVault & X8);\n\n        totalSupplyAndBorrow_.totalSupplyLiquidity = totalSupplyLiquidity_;\n        totalSupplyAndBorrow_.totalBorrowLiquidity = totalBorrowLiquidity_;\n\n        totalSupplyAndBorrow_.absorbedBorrow = absorbedLiquidity_ & X128;\n        totalSupplyAndBorrow_.absorbedSupply = absorbedLiquidity_ >> 128;\n\n        // converting raw total supply & total borrow into normal amounts\n        totalSupplyAndBorrow_.totalSupplyVault =\n            (totalSupplyAndBorrow_.totalSupplyVault * exchangePricesAndRates_.vaultSupplyExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n        totalSupplyAndBorrow_.totalBorrowVault =\n            (totalSupplyAndBorrow_.totalBorrowVault * exchangePricesAndRates_.vaultBorrowExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n\n        // below logic multiply with liquidity exchange price also works for case of smart debt / smart col because\n        // liquiditySupplyExchangePrice and liquidityBorrowExchangePrice will be EXCHANGE_PRICES_PRECISION\n        totalSupplyAndBorrow_.totalSupplyLiquidity =\n            (totalSupplyAndBorrow_.totalSupplyLiquidity * exchangePricesAndRates_.liquiditySupplyExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n        totalSupplyAndBorrow_.totalBorrowLiquidity =\n            (totalSupplyAndBorrow_.totalBorrowLiquidity * exchangePricesAndRates_.liquidityBorrowExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n\n        totalSupplyAndBorrow_.absorbedSupply =\n            (totalSupplyAndBorrow_.absorbedSupply * exchangePricesAndRates_.vaultSupplyExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n        totalSupplyAndBorrow_.absorbedBorrow =\n            (totalSupplyAndBorrow_.absorbedBorrow * exchangePricesAndRates_.vaultBorrowExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n    }\n\n    address private constant WEETH = 0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee;\n    address private constant WEETHS = 0x917ceE801a67f933F2e6b33fC0cD1ED2d5909D88;\n    IZtakingPool private constant ZIRCUIT = IZtakingPool(0xF047ab4c75cebf0eB9ed34Ae2c186f3611aEAfa6);\n\n    /// @dev Calculates limits and availability for a user's vault operations.\n    /// @param exchangePricesAndRates_ Exchange prices and rates for the vault.\n    /// @param constantsVariables_ Constants and variables for the vault.\n    /// @param withdrawalGapConfig_ Configuration for the withdrawal gap.\n    /// @param borrowLimit_ The borrow limit for the user. Only set if not smart debt.\n    /// @param borrowLimitUtilization_ The utilization of the borrow limit. Only set if not smart debt.\n    /// @param borrowableUntilLimit_ The limit until which borrowing is allowed. Only set if not smart debt.\n    /// @return limitsAndAvailability_ The calculated limits and availability for the user's vault operations.\n    function _getLimitsAndAvailability(\n        ExchangePricesAndRates memory exchangePricesAndRates_,\n        IFluidVaultT1.ConstantViews memory constantsVariables_,\n        uint withdrawalGapConfig_,\n        uint borrowLimit_,\n        uint borrowLimitUtilization_,\n        uint borrowableUntilLimit_\n    ) internal view returns (LimitsAndAvailability memory limitsAndAvailability_) {\n        // fetching user's supply slot data\n        uint userSupplyLiquidityData_ = IFluidLiquidity(constantsVariables_.liquidity).readFromStorage(\n            constantsVariables_.liquidityUserSupplySlot\n        );\n        if (userSupplyLiquidityData_ > 0) {\n            uint userSupply_;\n            uint supplyLimitRaw_;\n            userSupply_ = (userSupplyLiquidityData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n            userSupply_ = (userSupply_ >> 8) << (userSupply_ & X8);\n\n            supplyLimitRaw_ = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(userSupplyLiquidityData_, userSupply_);\n\n            userSupply_ =\n                (userSupply_ * exchangePricesAndRates_.liquiditySupplyExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n\n            // liquiditySupplyExchangePrice is EXCHANGE_PRICES_PRECISION in case of smart col\n            limitsAndAvailability_.withdrawLimit =\n                (supplyLimitRaw_ * exchangePricesAndRates_.liquiditySupplyExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n\n            // totalSupplyLiquidity = user supply\n            limitsAndAvailability_.withdrawableUntilLimit = userSupply_ > limitsAndAvailability_.withdrawLimit\n                ? userSupply_ - limitsAndAvailability_.withdrawLimit\n                : 0;\n\n            uint withdrawalGap_ = limitsAndAvailability_.withdrawLimit == 0\n                ? 0 // apply withdrawal gap only if withdraw limit is actually active (not below base limit)\n                : (userSupply_ * withdrawalGapConfig_) / 1e4;\n\n            limitsAndAvailability_.withdrawableUntilLimit = (limitsAndAvailability_.withdrawableUntilLimit >\n                withdrawalGap_)\n                ? (((limitsAndAvailability_.withdrawableUntilLimit - withdrawalGap_) * 999999) / 1000000)\n                : 0;\n\n            limitsAndAvailability_.withdrawable = limitsAndAvailability_.withdrawableUntilLimit;\n            uint balanceOf_;\n            if (constantsVariables_.supplyToken == NATIVE_TOKEN_ADDRESS) {\n                balanceOf_ = address(constantsVariables_.liquidity).balance;\n            } else {\n                balanceOf_ = TokenInterface(constantsVariables_.supplyToken).balanceOf(\n                    address(constantsVariables_.liquidity)\n                );\n                if (constantsVariables_.supplyToken == WEETH) {\n                    balanceOf_ += ZIRCUIT.balance(WEETH, address(LIQUIDITY));\n                }\n                if (constantsVariables_.supplyToken == WEETHS) {\n                    balanceOf_ += ZIRCUIT.balance(WEETHS, address(LIQUIDITY));\n                }\n            }\n            if (balanceOf_ < limitsAndAvailability_.withdrawableUntilLimit) {\n                limitsAndAvailability_.withdrawable = balanceOf_;\n            }\n        }\n\n        uint userBorrowLiquidityData_ = IFluidLiquidity(constantsVariables_.liquidity).readFromStorage(\n            constantsVariables_.liquidityUserBorrowSlot\n        );\n        if (userBorrowLiquidityData_ > 0) {\n            limitsAndAvailability_.borrowLimit = borrowLimit_;\n            limitsAndAvailability_.borrowLimitUtilization = borrowLimitUtilization_;\n\n            limitsAndAvailability_.borrowableUntilLimit = (borrowableUntilLimit_ * 999999) / 1000000;\n\n            uint balanceOf_;\n            if (constantsVariables_.borrowToken == NATIVE_TOKEN_ADDRESS) {\n                balanceOf_ = address(constantsVariables_.liquidity).balance;\n            } else {\n                balanceOf_ = TokenInterface(constantsVariables_.borrowToken).balanceOf(\n                    address(constantsVariables_.liquidity)\n                );\n            }\n            limitsAndAvailability_.borrowable = balanceOf_ > limitsAndAvailability_.borrowableUntilLimit\n                ? limitsAndAvailability_.borrowableUntilLimit\n                : balanceOf_;\n        }\n\n        limitsAndAvailability_.minimumBorrowing =\n            (10001 * exchangePricesAndRates_.vaultBorrowExchangePrice) /\n            EXCHANGE_PRICES_PRECISION;\n    }\n\n    /// @notice Retrieves the state of a given vault.\n    /// @param vault_ The address of the vault to retrieve the state for.\n    /// @return vaultState_ The state of the vault, including top tick, current and total branches,\n    ///                     total supply and borrow, total positions, and current branch state.\n    function getVaultState(address vault_) public view returns (VaultState memory vaultState_) {\n        uint vaultVariables_ = getVaultVariablesRaw(vault_);\n\n        vaultState_.topTick = tickHelper(((vaultVariables_ >> 2) & X20));\n        vaultState_.currentBranch = (vaultVariables_ >> 22) & X30;\n        vaultState_.totalBranch = (vaultVariables_ >> 52) & X30;\n        vaultState_.totalSupply = BigMathMinified.fromBigNumber((vaultVariables_ >> 82) & X64, 8, X8);\n        vaultState_.totalBorrow = BigMathMinified.fromBigNumber((vaultVariables_ >> 146) & X64, 8, X8);\n        vaultState_.totalPositions = (vaultVariables_ >> 210) & X32;\n\n        uint currentBranchData_ = getBranchDataRaw(vault_, vaultState_.currentBranch);\n        vaultState_.currentBranchState.status = currentBranchData_ & 3;\n        vaultState_.currentBranchState.minimaTick = tickHelper(((currentBranchData_ >> 2) & X20));\n        vaultState_.currentBranchState.debtFactor = (currentBranchData_ >> 116) & X50;\n        vaultState_.currentBranchState.partials = (currentBranchData_ >> 22) & X30;\n        vaultState_.currentBranchState.debtLiquidity = BigMathMinified.fromBigNumber(\n            (currentBranchData_ >> 52) & X64,\n            8,\n            X8\n        );\n        vaultState_.currentBranchState.baseBranchId = (currentBranchData_ >> 166) & X30;\n        vaultState_.currentBranchState.baseBranchMinima = tickHelper(((currentBranchData_ >> 196) & X20));\n    }\n\n    /// @notice Retrieves the entire data for a given vault.\n    /// @param vault_ The address of the vault to retrieve the data for.\n    /// @return vaultData_ The entire data of the vault.\n    function getVaultEntireData(address vault_) public view returns (VaultEntireData memory vaultData_) {\n        vaultData_.vault = vault_;\n        uint vaultType_ = getVaultType(vault_);\n        if (vaultType_ == FluidProtocolTypes.VAULT_T1_TYPE) {\n            vaultData_.constantVariables = _getVaultConstants(vault_);\n\n            // in case of NOT smart debt, the borrow limits are fetched from liquidity resolver\n            uint borrowLimit_;\n            uint borrowLimitUtilization_;\n            uint borrowableUntilLimit_;\n\n            {\n                uint liquiditySupplyRate_;\n                uint liquidityBorrowRate_;\n                (\n                    FluidLiquidityResolverStructs.UserSupplyData memory liquidityUserSupplyData_,\n                    FluidLiquidityResolverStructs.OverallTokenData memory liquiditySupplyTokenData_\n                ) = LIQUIDITY_RESOLVER.getUserSupplyData(vault_, vaultData_.constantVariables.supplyToken);\n\n                vaultData_.liquidityUserSupplyData = liquidityUserSupplyData_;\n\n                liquiditySupplyRate_ = liquiditySupplyTokenData_.supplyRate;\n\n                (\n                    FluidLiquidityResolverStructs.UserBorrowData memory liquidityUserBorrowData_,\n                    FluidLiquidityResolverStructs.OverallTokenData memory liquidityBorrowTokenData_\n                ) = LIQUIDITY_RESOLVER.getUserBorrowData(vault_, vaultData_.constantVariables.borrowToken);\n\n                vaultData_.liquidityUserBorrowData = liquidityUserBorrowData_;\n\n                liquidityBorrowRate_ = liquidityBorrowTokenData_.borrowRate;\n\n                borrowLimit_ = liquidityUserBorrowData_.borrowLimit;\n                borrowLimitUtilization_ = liquidityUserBorrowData_.borrowLimitUtilization;\n                borrowableUntilLimit_ = liquidityUserBorrowData_.borrowableUntilLimit;\n\n                vaultData_.configs = _getVaultConfig(vault_);\n                vaultData_.exchangePricesAndRates = _getExchangePricesAndRates(\n                    vault_,\n                    vaultData_.configs,\n                    liquiditySupplyRate_,\n                    liquidityBorrowRate_\n                );\n            }\n            vaultData_.totalSupplyAndBorrow = _getTotalSupplyAndBorrow(\n                vault_,\n                vaultData_.exchangePricesAndRates,\n                vaultData_.constantVariables\n            );\n            vaultData_.limitsAndAvailability = _getLimitsAndAvailability(\n                vaultData_.exchangePricesAndRates,\n                vaultData_.constantVariables,\n                vaultData_.configs.withdrawalGap,\n                borrowLimit_,\n                borrowLimitUtilization_,\n                borrowableUntilLimit_\n            );\n            vaultData_.vaultState = getVaultState(vault_);\n        }\n    }\n\n    /// @notice Retrieves the entire data for a list of vaults.\n    /// @param vaults_ The list of vault addresses.\n    /// @return vaultsData_ An array of VaultEntireData structures containing the data for each vault.\n    function getVaultsEntireData(\n        address[] memory vaults_\n    ) external view returns (VaultEntireData[] memory vaultsData_) {\n        uint length_ = vaults_.length;\n        vaultsData_ = new VaultEntireData[](length_);\n        for (uint i = 0; i < length_; i++) {\n            vaultsData_[i] = getVaultEntireData(vaults_[i]);\n        }\n    }\n\n    /// @notice Retrieves the entire data for all vaults.\n    /// @return vaultsData_ An array of VaultEntireData structures containing the data for each vault.\n    function getVaultsEntireData() external view returns (VaultEntireData[] memory vaultsData_) {\n        address[] memory vaults_ = getAllVaultsAddresses();\n        uint length_ = vaults_.length;\n        vaultsData_ = new VaultEntireData[](length_);\n        for (uint i = 0; i < length_; i++) {\n            vaultsData_[i] = getVaultEntireData(vaults_[i]);\n        }\n    }\n\n    /// @notice Retrieves the position data for a given NFT ID and the corresponding vault data.\n    /// @param nftId_ The NFT ID for which to retrieve the position data.\n    /// @return userPosition_ The UserPosition structure containing the position data.\n    /// @return vaultData_ The VaultEntireData structure containing the vault data.\n    function positionByNftId(\n        uint nftId_\n    ) public view returns (UserPosition memory userPosition_, VaultEntireData memory vaultData_) {\n        userPosition_.nftId = nftId_;\n        address vault_ = vaultByNftId(nftId_);\n        if (vault_ != address(0)) {\n            uint positionData_ = getPositionDataRaw(vault_, nftId_);\n            vaultData_ = getVaultEntireData(vault_);\n\n            userPosition_.owner = FACTORY.ownerOf(nftId_);\n            userPosition_.isSupplyPosition = (positionData_ & 1) == 1;\n            userPosition_.supply = (positionData_ >> 45) & X64;\n            // Converting big number into normal number\n            userPosition_.supply = (userPosition_.supply >> 8) << (userPosition_.supply & X8);\n            userPosition_.beforeSupply = userPosition_.supply;\n            userPosition_.dustBorrow = (positionData_ >> 109) & X64;\n            // Converting big number into normal number\n            userPosition_.dustBorrow = (userPosition_.dustBorrow >> 8) << (userPosition_.dustBorrow & X8);\n            userPosition_.beforeDustBorrow = userPosition_.dustBorrow;\n            if (!userPosition_.isSupplyPosition) {\n                userPosition_.tick = (positionData_ & 2) == 2\n                    ? int((positionData_ >> 2) & X19)\n                    : -int((positionData_ >> 2) & X19);\n                userPosition_.tickId = (positionData_ >> 21) & X24;\n                userPosition_.borrow =\n                    (TickMath.getRatioAtTick(int24(userPosition_.tick)) * userPosition_.supply) >>\n                    96;\n                userPosition_.beforeBorrow = userPosition_.borrow - userPosition_.beforeDustBorrow;\n\n                uint tickData_ = getTickDataRaw(vault_, userPosition_.tick);\n\n                if (((tickData_ & 1) == 1) || (((tickData_ >> 1) & X24) > userPosition_.tickId)) {\n                    // user got liquidated\n                    userPosition_.isLiquidated = true;\n                    (userPosition_.tick, userPosition_.borrow, userPosition_.supply, , ) = IFluidVaultT1(vault_)\n                        .fetchLatestPosition(userPosition_.tick, userPosition_.tickId, userPosition_.borrow, tickData_);\n                }\n\n                if (userPosition_.borrow > userPosition_.dustBorrow) {\n                    userPosition_.borrow = userPosition_.borrow - userPosition_.dustBorrow;\n                } else {\n                    userPosition_.borrow = 0;\n                    userPosition_.dustBorrow = 0;\n                }\n            }\n\n            // converting raw amounts into normal\n            userPosition_.beforeSupply =\n                (userPosition_.beforeSupply * vaultData_.exchangePricesAndRates.vaultSupplyExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n            userPosition_.beforeBorrow =\n                (userPosition_.beforeBorrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n            userPosition_.beforeDustBorrow =\n                (userPosition_.beforeDustBorrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n            userPosition_.supply =\n                (userPosition_.supply * vaultData_.exchangePricesAndRates.vaultSupplyExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n            userPosition_.borrow =\n                (userPosition_.borrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n            userPosition_.dustBorrow =\n                (userPosition_.dustBorrow * vaultData_.exchangePricesAndRates.vaultBorrowExchangePrice) /\n                EXCHANGE_PRICES_PRECISION;\n        }\n    }\n\n    /// @notice Returns an array of NFT IDs for all positions of a given user.\n    /// @param user_ The address of the user for whom to fetch positions.\n    /// @return nftIds_ An array of NFT IDs representing the user's positions.\n    function positionsNftIdOfUser(address user_) public view returns (uint[] memory nftIds_) {\n        uint totalPositions_ = FACTORY.balanceOf(user_);\n        nftIds_ = new uint[](totalPositions_);\n        for (uint i; i < totalPositions_; i++) {\n            nftIds_[i] = FACTORY.tokenOfOwnerByIndex(user_, i);\n        }\n    }\n\n    /// @notice Returns the vault address associated with a given NFT ID.\n    /// @param nftId_ The NFT ID for which to fetch the vault address.\n    /// @return vault_ The address of the vault associated with the NFT ID.\n    function vaultByNftId(uint nftId_) public view returns (address vault_) {\n        uint tokenConfig_ = getTokenConfig(nftId_);\n        vault_ = FACTORY.getVaultAddress((tokenConfig_ >> 192) & X32);\n    }\n\n    /// @notice Fetches all positions and their corresponding vault data for a given user.\n    /// @param user_ The address of the user for whom to fetch positions and vault data.\n    /// @return userPositions_ An array of UserPosition structs representing the user's positions.\n    /// @return vaultsData_ An array of VaultEntireData structs representing the vault data for each position.\n    function positionsByUser(\n        address user_\n    ) external view returns (UserPosition[] memory userPositions_, VaultEntireData[] memory vaultsData_) {\n        uint[] memory nftIds_ = positionsNftIdOfUser(user_);\n        uint length_ = nftIds_.length;\n        userPositions_ = new UserPosition[](length_);\n        vaultsData_ = new VaultEntireData[](length_);\n        for (uint i = 0; i < length_; i++) {\n            (userPositions_[i], vaultsData_[i]) = positionByNftId(nftIds_[i]);\n        }\n    }\n\n    /// @notice Returns the total number of positions across all users.\n    /// @return The total number of positions.\n    function totalPositions() external view returns (uint) {\n        return FACTORY.totalSupply();\n    }\n\n    /// @notice fetches available liquidations\n    /// @param vault_ address of vault for which to fetch\n    /// @param tokenInAmt_ token in aka debt to payback, leave 0 to get max\n    /// @return liquidationData_ liquidation related data. Check out structs.sol\n    function getVaultLiquidation(\n        address vault_,\n        uint tokenInAmt_\n    ) public returns (LiquidationStruct memory liquidationData_) {\n        tokenInAmt_ = tokenInAmt_ == 0 ? X128 : tokenInAmt_;\n\n        liquidationData_.vault = vault_;\n\n        uint vaultType_ = getVaultType(vault_);\n        if (vaultType_ == FluidProtocolTypes.VAULT_T1_TYPE) {\n            IFluidVaultT1.ConstantViews memory constants_ = _getVaultConstants(vault_);\n\n            liquidationData_.tokenIn = constants_.borrowToken;\n            liquidationData_.tokenOut = constants_.supplyToken;\n\n            // running without absorb\n            try IFluidVaultT1(vault_).liquidate(tokenInAmt_, 0, 0x000000000000000000000000000000000000dEaD, false) {\n                // Handle successful execution\n            } catch Error(string memory) {\n                // Handle generic errors with a reason\n            } catch (bytes memory lowLevelData_) {\n                (liquidationData_.tokenInAmtOne, liquidationData_.tokenOutAmtOne) = _decodeLiquidationResult(\n                    lowLevelData_\n                );\n            }\n\n            // running with absorb\n            try IFluidVaultT1(vault_).liquidate(tokenInAmt_, 0, 0x000000000000000000000000000000000000dEaD, true) {\n                // Handle successful execution\n            } catch Error(string memory) {\n                // Handle generic errors with a reason\n            } catch (bytes memory lowLevelData_) {\n                (liquidationData_.tokenInAmtTwo, liquidationData_.tokenOutAmtTwo) = _decodeLiquidationResult(\n                    lowLevelData_\n                );\n            }\n        }\n    }\n\n    /// @dev helper method to decode liquidation result revert data\n    function _decodeLiquidationResult(bytes memory lowLevelData_) internal pure returns (uint amtIn_, uint amtOut_) {\n        // Check if the error data is long enough to contain a selector\n        if (lowLevelData_.length >= 68) {\n            bytes4 errorSelector_;\n            assembly {\n                // Extract the selector from the error data\n                errorSelector_ := mload(add(lowLevelData_, 0x20))\n            }\n            if (errorSelector_ == IFluidVaultT1.FluidLiquidateResult.selector) {\n                assembly {\n                    amtOut_ := mload(add(lowLevelData_, 36))\n                    amtIn_ := mload(add(lowLevelData_, 68))\n                }\n            } // else -> tokenInAmtTwo & tokenOutAmtTwo remains 0\n        }\n    }\n\n    /// @notice Retrieves liquidation data for multiple vaults.\n    /// @param vaults_ The array of vault addresses.\n    /// @param tokensInAmt_ The array of token amounts to liquidate.\n    /// @return liquidationsData_ An array of LiquidationStruct containing the liquidation data for each vault.\n    function getMultipleVaultsLiquidation(\n        address[] memory vaults_,\n        uint[] memory tokensInAmt_\n    ) external returns (LiquidationStruct[] memory liquidationsData_) {\n        uint length_ = vaults_.length;\n        liquidationsData_ = new LiquidationStruct[](length_);\n        for (uint i = 0; i < length_; i++) {\n            liquidationsData_[i] = getVaultLiquidation(vaults_[i], tokensInAmt_[i]);\n        }\n    }\n\n    /// @notice Retrieves liquidation data for all vaults.\n    /// @return liquidationsData_ An array of LiquidationStruct containing the liquidation data for all vaults.\n    function getAllVaultsLiquidation() external returns (LiquidationStruct[] memory liquidationsData_) {\n        address[] memory vaults_ = getAllVaultsAddresses();\n        uint length_ = vaults_.length;\n\n        liquidationsData_ = new LiquidationStruct[](length_);\n        for (uint i = 0; i < length_; i++) {\n            liquidationsData_[i] = getVaultLiquidation(vaults_[i], 0);\n        }\n    }\n\n    /// @notice DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for a single vault.\n    /// @param vault_ The address of the vault.\n    /// @return absorbData_ The AbsorbStruct containing the absorb data for the vault.\n    function getVaultAbsorb(address vault_) public returns (AbsorbStruct memory absorbData_) {\n        absorbData_.vault = vault_;\n        uint absorbedLiquidity_ = getAbsorbedLiquidityRaw(vault_);\n        try IFluidVaultT1(vault_).absorb() {\n            // Handle successful execution\n            uint newAbsorbedLiquidity_ = getAbsorbedLiquidityRaw(vault_);\n            if (newAbsorbedLiquidity_ != absorbedLiquidity_) {\n                absorbData_.absorbAvailable = true;\n            }\n        } catch Error(string memory) {} catch (bytes memory) {}\n    }\n\n    /// @notice DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for multiple vaults.\n    /// @param vaults_ The array of vault addresses.\n    /// @return absorbData_ An array of AbsorbStruct containing the absorb data for each vault.\n    function getVaultsAbsorb(address[] memory vaults_) public returns (AbsorbStruct[] memory absorbData_) {\n        uint length_ = vaults_.length;\n        absorbData_ = new AbsorbStruct[](length_);\n        for (uint i = 0; i < length_; i++) {\n            absorbData_[i] = getVaultAbsorb(vaults_[i]);\n        }\n    }\n\n    /// @notice DEPRECATED, only works for vaults v1.0.0: Retrieves absorb data for all vaults.\n    /// @return absorbData_ An array of AbsorbStruct containing the absorb data for all vaults.\n    function getVaultsAbsorb() public returns (AbsorbStruct[] memory absorbData_) {\n        return getVaultsAbsorb(getAllVaultsAddresses());\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultT1/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidVaultT1 } from \"../../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { Structs as FluidLiquidityResolverStructs } from \"../liquidity/structs.sol\";\n\ncontract Structs {\n    struct Configs {\n        uint16 supplyRateMagnifier;\n        uint16 borrowRateMagnifier;\n        uint16 collateralFactor;\n        uint16 liquidationThreshold;\n        uint16 liquidationMaxLimit;\n        uint16 withdrawalGap;\n        uint16 liquidationPenalty;\n        uint16 borrowFee;\n        address oracle;\n        uint oraclePriceOperate;\n        uint oraclePriceLiquidate;\n        address rebalancer;\n    }\n\n    struct ExchangePricesAndRates {\n        uint lastStoredLiquiditySupplyExchangePrice;\n        uint lastStoredLiquidityBorrowExchangePrice;\n        uint lastStoredVaultSupplyExchangePrice;\n        uint lastStoredVaultBorrowExchangePrice;\n        uint liquiditySupplyExchangePrice;\n        uint liquidityBorrowExchangePrice;\n        uint vaultSupplyExchangePrice;\n        uint vaultBorrowExchangePrice;\n        uint supplyRateVault;\n        uint borrowRateVault;\n        uint supplyRateLiquidity;\n        uint borrowRateLiquidity;\n        uint rewardsRate; // rewards rate in percent 1e2 precision (1% = 100, 100% = 10000)\n    }\n\n    struct TotalSupplyAndBorrow {\n        uint totalSupplyVault;\n        uint totalBorrowVault;\n        uint totalSupplyLiquidity;\n        uint totalBorrowLiquidity;\n        uint absorbedSupply;\n        uint absorbedBorrow;\n    }\n\n    struct LimitsAndAvailability {\n        uint withdrawLimit;\n        uint withdrawableUntilLimit;\n        uint withdrawable;\n        uint borrowLimit;\n        uint borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        uint borrowLimitUtilization; // borrow limit for `maxUtilization` config at Liquidity\n        uint minimumBorrowing;\n    }\n    struct CurrentBranchState {\n        uint status; // if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\n        int minimaTick;\n        uint debtFactor;\n        uint partials;\n        uint debtLiquidity;\n        uint baseBranchId;\n        int baseBranchMinima;\n    }\n    struct VaultState {\n        uint totalPositions;\n        int topTick;\n        uint currentBranch;\n        uint totalBranch;\n        uint totalBorrow;\n        uint totalSupply;\n        CurrentBranchState currentBranchState;\n    }\n\n    struct VaultEntireData {\n        address vault;\n        IFluidVaultT1.ConstantViews constantVariables;\n        Configs configs;\n        ExchangePricesAndRates exchangePricesAndRates;\n        TotalSupplyAndBorrow totalSupplyAndBorrow;\n        LimitsAndAvailability limitsAndAvailability;\n        VaultState vaultState;\n        // liquidity related data such as supply amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserSupplyData liquidityUserSupplyData;\n        // liquidity related data such as borrow amount, limits, expansion etc.\n        FluidLiquidityResolverStructs.UserBorrowData liquidityUserBorrowData;\n    }\n\n    struct UserPosition {\n        uint nftId;\n        address owner;\n        bool isLiquidated;\n        bool isSupplyPosition; // if true that means borrowing is 0\n        int tick;\n        uint tickId;\n        uint beforeSupply;\n        uint beforeBorrow;\n        uint beforeDustBorrow;\n        uint supply;\n        uint borrow;\n        uint dustBorrow;\n    }\n\n    /// @dev liquidation related data\n    /// @param vault address of vault\n    /// @param tokenIn_ address of token in\n    /// @param tokenOut_ address of token out\n    /// @param tokenInAmtOne_ (without absorb liquidity) minimum of available liquidation & tokenInAmt_\n    /// @param tokenOutAmtOne_ (without absorb liquidity) expected token out, collateral to withdraw\n    /// @param tokenInAmtTwo_ (absorb liquidity included) minimum of available liquidation & tokenInAmt_. In most cases it'll be same as tokenInAmtOne_ but sometimes can be bigger.\n    /// @param tokenOutAmtTwo_ (absorb liquidity included) expected token out, collateral to withdraw. In most cases it'll be same as tokenOutAmtOne_ but sometimes can be bigger.\n    /// @dev Liquidity in Two will always be >= One. Sometimes One can provide better swaps, sometimes Two can provide better swaps. But available in Two will always be >= One\n    struct LiquidationStruct {\n        address vault;\n        address tokenIn;\n        address tokenOut;\n        uint tokenInAmtOne;\n        uint tokenOutAmtOne;\n        uint tokenInAmtTwo;\n        uint tokenOutAmtTwo;\n    }\n\n    struct AbsorbStruct {\n        address vault;\n        bool absorbAvailable;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/vaultT1/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidityResolver } from \"../liquidity/iLiquidityResolver.sol\";\nimport { IFluidVaultFactory } from \"../../../protocols/vault/interfaces/iVaultFactory.sol\";\n\ninterface IFluidLiquidity {\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n\ncontract Variables {\n    IFluidVaultFactory public immutable FACTORY;\n    IFluidLiquidity public immutable LIQUIDITY;\n    IFluidLiquidityResolver public immutable LIQUIDITY_RESOLVER;\n\n    // 30 bits (used for partials mainly)\n    uint internal constant X8 = 0xff;\n    uint internal constant X10 = 0x3ff;\n    uint internal constant X14 = 0x3fff;\n    uint internal constant X15 = 0x7fff;\n    uint internal constant X16 = 0xffff;\n    uint internal constant X19 = 0x7ffff;\n    uint internal constant X20 = 0xfffff;\n    uint internal constant X24 = 0xffffff;\n    uint internal constant X25 = 0x1ffffff;\n    uint internal constant X30 = 0x3fffffff;\n    uint internal constant X32 = 0xffffffff;\n    uint internal constant X33 = 0x1ffffffff;\n    uint internal constant X35 = 0x7ffffffff;\n    uint internal constant X40 = 0xffffffffff;\n    uint internal constant X50 = 0x3ffffffffffff;\n    uint internal constant X64 = 0xffffffffffffffff;\n    uint internal constant X96 = 0xffffffffffffffffffffffff;\n    uint internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n    /// @dev address that is mapped to the chain native token\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    constructor(address factory_, address liquidity_, address liquidityResolver_) {\n        FACTORY = IFluidVaultFactory(factory_);\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        LIQUIDITY_RESOLVER = IFluidLiquidityResolver(liquidityResolver_);\n    }\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexFactory {\n    /// @notice Global auth is auth for all dexes\n    function isGlobalAuth(address auth_) external view returns (bool);\n\n    /// @notice Dex auth is auth for a specific dex\n    function isDexAuth(address vault_, address auth_) external view returns (bool);\n\n    /// @notice Total dexes deployed.\n    function totalDexes() external view returns (uint256);\n\n    /// @notice Compute dexAddress\n    function getDexAddress(uint256 dexId_) external view returns (address);\n\n    /// @notice read uint256 `result_` for a storage `slot_` key\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexT1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexT1 {\n    error FluidDexError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares);\n\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\n\n    /// @notice returns the dex id\n    function DEX_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndOracle;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) external view returns (CollateralReserves memory c_);\n\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) external view returns (DebtReserves memory d_);\n\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\n    function getPricesAndExchangePrices() external;\n\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount in and callback functionality\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of tokens to swap in\n    /// @param amountOutMin_ The minimum amount of tokens to receive after swap\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapInWithCallback(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Swap tokens with perfect amount out and callback functionality\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOutWithCallback(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(uint token0Amt_, uint token1Amt_, uint maxSharesAmt_, address to_) external returns (uint shares_);\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) external returns (uint withdrawAmt_);\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) external payable returns (uint paybackAmt_);\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(uint[] memory secondsAgos_) external view returns (Oracle[] memory twaps_, uint currentPrice_);\n}\n"
    },
    "contracts/protocols/flashloan/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Error {\n    error FluidFlashLenderError(uint256 errorId_);\n}\n"
    },
    "contracts/protocols/flashloan/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |           FlashLender             | \n    |__________________________________*/\n\n    /// @notice Thrown when a function encounters or is provided with an address set to the zero address.\n    uint256 internal constant FlashLender__ZeroAddress = 80001;\n\n    /// @notice Thrown when the requested flash loan amount exceeds the allowed maximum.\n    uint256 internal constant FlashLender__MaxFlashLoanAmountExceeded = 80002;\n\n    /// @notice Thrown when a function returns an unexpected value.\n    uint256 internal constant FlashLender__InvalidReturnValue = 80003;\n\n    /// @notice Thrown when an unauthorized action is attempted.\n    uint256 internal constant FlashLender__Unauthorized = 80004;\n\n    /// @notice Thrown when an operation involves a token that isn't supported.\n    uint256 internal constant FlashLender__TokenNotSupported = 80005;\n\n    /// @notice Thrown when a token is already being borrowed by flashloan protocol.\n    uint256 internal constant FlashLender__DuplicateBorrow = 80006;\n}\n"
    },
    "contracts/protocols/flashloan/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\n\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { Error } from \"./error.sol\";\nimport { Variables } from \"./variables.sol\";\n\n/// @dev Flashloan protocol helper methods\nabstract contract Helpers is Variables, Error {\n    constructor(IFluidLiquidity liquidity_) Variables(liquidity_) {}\n\n    /// @notice Reads user borrow data of currency to be lent.\n    /// @param token_ The loan currency.\n    /// @return user borrow data for `token`.\n    function _readUserBorrowData(address token_) internal view returns (uint256) {\n        bytes32 slot_ = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n            address(this),\n            token_\n        );\n        return LIQUIDITY.readFromStorage(slot_);\n    }\n\n    /// @notice Checks if the given address is valid (not equal to address(0)).\n    /// @param value_ The address to check..\n    function _checkValidAddress(address value_) internal pure {\n        if (value_ == address(0)) {\n            revert FluidFlashLenderError(ErrorTypes.FlashLender__ZeroAddress);\n        }\n    }\n\n    /// @notice Ensures that the provided address is valid (not equal to address(0)).\n    /// @param value_ The address to check.\n    modifier validAddress(address value_) {\n        _checkValidAddress(value_);\n        _;\n    }\n}\n"
    },
    "contracts/protocols/flashloan/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IERC3156FlashBorrower {\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "contracts/protocols/flashloan/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\ninterface IERC3156FlashLender {\n    /// @dev The amount of currency available to be lent.\n    /// @param token The loan currency.\n    /// @return The amount of `token` that can be borrowed.\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /// @dev The fee to be charged for a given loan.\n    /// @param token The loan currency.\n    /// @param amount The amount of tokens lent.\n    /// @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /// @dev Initiate a flash loan.\n    /// @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n    /// @param token The loan currency.\n    /// @param amount The amount of tokens lent.\n    /// @param data Arbitrary data structure, intended to contain user-defined parameters.\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "contracts/protocols/flashloan/interfaces/iFlashBorrower.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport \"./IERC3156FlashBorrower.sol\";\nimport { Structs } from \"../structs.sol\";\n\ninterface IFlashBorrower is IERC3156FlashBorrower {\n    function onFlashLoanMultiple(\n        address initiator,\n        Structs.AddressUint256[] calldata tokensWithValues,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "contracts/protocols/flashloan/interfaces/iFlashLender.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFlashBorrower } from \"./iFlashBorrower.sol\";\nimport { IERC3156FlashLender } from \"./IERC3156FlashLender.sol\";\nimport { IERC3156FlashBorrower } from \"./IERC3156FlashBorrower.sol\";\nimport { Structs } from \"../structs.sol\";\n\ninterface IFluidFlashLender is IERC3156FlashLender {\n    /// @notice Initiate a flash loan with multiple tokens.\n    /// @param receiver_ The receiver of the tokens in the loan, and the receiver of the callback.\n    /// @param tokensWithAmounts_ An array of token addresses and loan amounts.\n    /// @param data_ Arbitrary data structure, intended to contain user-defined parameters.\n    /// @return 'true' if the flash loan are successful\n    function flashLoanMultiple(\n        IFlashBorrower receiver_,\n        Structs.AddressUint256[] calldata tokensWithAmounts_,\n        bytes calldata data_\n    ) external returns (bool);\n}\n"
    },
    "contracts/protocols/flashloan/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { Helpers } from \"./helpers.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { IFluidFlashLender } from \"./interfaces/iFlashLender.sol\";\nimport { IERC3156FlashBorrower } from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport { IFlashBorrower } from \"./interfaces/iFlashBorrower.sol\";\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { IProtocol } from \"../../liquidity/userModule/main.sol\";\n\nimport { LiquidityCalcs } from \"../../libraries/liquidityCalcs.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\n\n/// @notice contract that provides Flashloans via Fluid. ERC-3156 compatible.\n/// In addition also implements a `flashLoanMultiple()` method which can be used to flash loan multiple tokens at once.\n/// @dev Fee is a constant 0. This contract is not upgradeable.\n//\n// @dev Fee is not really implemented, just the parts that are needed to ensure compatibility with ERC-3156.\n// @dev user borrow amount for this contract at Liquidity will slowly grow but that is not an issue as the amount\n// being repaid is still the exact original amount always.\ncontract FluidFlashLender is Structs, IFluidFlashLender, IProtocol, Helpers {\n    using SafeERC20 for IERC20;\n\n    /// @notice emitted whenever funds for a certain `token` are rescued to Liquidity\n    event LogRescueFunds(address indexed token);\n\n    /// @notice emitted when a flashloan has been taken and repaid\n    event LogFlashLoan(address indexed token, uint256 indexed amount, address indexed receiver);\n\n    constructor(IFluidLiquidity liquidity_) Helpers(liquidity_) {}\n\n    /// @notice The amount of currency available to be lent.\n    /// @param token_ The loan currency.\n    /// @return The amount of `token` that can be borrowed.\n    function maxFlashLoan(address token_) public view returns (uint256) {\n        // maximum flashloan is either:\n        // a) the borrow limit of Flashloan protocol at Liquidity or\n        // b) the total available amount of token at Liquidity (if lower than borrow limit)\n\n        // get current exchange rates\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n                    token_\n                )\n            )\n        );\n\n        // a) get the borrow limit\n        uint256 userBorrowData_ = _readUserBorrowData(token_);\n        uint256 userBorrow_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & LiquidityCalcs.X64;\n        // get borrow limit\n        uint256 borrowLimit_ = LiquidityCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, userBorrow_);\n        // revert if Flashloan protocol has already borrowed more than 0.0001% of borrow limit for the `token_`. This\n        // catches any duplicate token borrows. We can not just check for user borrow == 0 because of rounding.\n        if (userBorrow_ > (borrowLimit_ / 100_000)) {\n            revert FluidFlashLenderError(ErrorTypes.FlashLender__DuplicateBorrow);\n        }\n        // subtract any already borrowed amount\n        borrowLimit_ -= userBorrow_;\n\n        if (userBorrowData_ & 1 == 1) {\n            // convert raw borrow limit amount to normal for withInterest mode\n            borrowLimit_ = (borrowLimit_ * borrowExchangePrice_) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n        }\n\n        // b) get the total available amount at Liquidity (total supply - total borrow)\n        uint256 totalAmounts_ = LIQUIDITY.readFromStorage(\n            LiquiditySlotsLink.calculateMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT,\n                token_\n            )\n        );\n        // totalSupply = supplyRawInterest normalized from raw + supplyInterestFree\n        uint256 totalSupply_ = LiquidityCalcs.getTotalSupply(totalAmounts_, supplyExchangePrice_);\n        // get total borrow for token interest free + with interest converted from raw\n        uint256 totalBorrow_ = LiquidityCalcs.getTotalBorrow(totalAmounts_, borrowExchangePrice_);\n\n        uint256 availableAmount_;\n        unchecked {\n            // todo: this amount would also have to include max utilization limit.\n            // potential other updates might be needed in flashloan protocol before release as Liquidity layer\n            // had some changes etc.\n            availableAmount_ = totalBorrow_ > totalSupply_ ? 0 : totalSupply_ - totalBorrow_;\n        }\n\n        return borrowLimit_ < availableAmount_ ? borrowLimit_ : availableAmount_;\n    }\n\n    /// @notice The fee to be charged for a given loan.\n    /// @param token_ loan currency.\n    /// @param amount_ The amount of tokens lent.\n    /// @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    function flashFee(address token_, uint256 amount_) external view returns (uint256) {\n        if (_readUserBorrowData(token_) == 0) {\n            revert FluidFlashLenderError(ErrorTypes.FlashLender__TokenNotSupported);\n        }\n        return _FLASH_FEE;\n    }\n\n    /// @notice Initiate a flash loan.\n    /// @dev receiver_ must approve `amount_` of `token_` for payback. For native token, it must be send as msg.value.\n    /// @param receiver_ The receiver of the tokens in the loan, and the receiver of the callback.\n    /// @param token_ The loan currency.\n    /// @param amount_ The amount of tokens lent.\n    /// @param data_ Arbitrary data structure, intended to contain user-defined parameters.\n    function flashLoan(\n        IERC3156FlashBorrower receiver_,\n        address token_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external validAddress(address(receiver_)) validAddress(token_) returns (bool) {\n        if (amount_ > maxFlashLoan(token_)) {\n            revert FluidFlashLenderError(ErrorTypes.FlashLender__MaxFlashLoanAmountExceeded);\n        }\n\n        LIQUIDITY.operate(token_, 0, SafeCast.toInt256(amount_), address(0), address(receiver_), new bytes(0));\n\n        if (\n            receiver_.onFlashLoan(msg.sender, token_, amount_, _FLASH_FEE, data_) != _RETURN_VALUE_FOR_FLASHLOAN_SINGLE\n        ) {\n            revert FluidFlashLenderError(ErrorTypes.FlashLender__InvalidReturnValue);\n        }\n\n        LIQUIDITY.operate{ value: token_ == _NATIVE_TOKEN_ADDRESS ? amount_ : 0 }(\n            token_,\n            0,\n            -int256(amount_),\n            address(0),\n            address(0),\n            abi.encode(address(receiver_))\n        );\n\n        emit LogFlashLoan(token_, amount_, address(receiver_));\n\n        return true;\n    }\n\n    /// @notice Initiate a flash loan with multiple tokens.\n    /// @dev receiver_ must approve `amount_` of  each token for payback. For native token, it must be send as msg.value.\n    /// @param receiver_ The receiver of the tokens in the loan, and the receiver of the callback.\n    /// @param tokensWithAmounts_ An array of token addresses and loan amounts.\n    /// @param data_ Arbitrary data structure, intended to contain user-defined parameters.\n    /// @return 'true' if the flash loans are successful\n    function flashLoanMultiple(\n        IFlashBorrower receiver_,\n        AddressUint256[] calldata tokensWithAmounts_,\n        bytes calldata data_\n    ) external validAddress(address(receiver_)) returns (bool) {\n        uint256 length_ = tokensWithAmounts_.length;\n\n        // execute all borrows at Liquidity\n        for (uint256 i; i < length_; ) {\n            _checkValidAddress(tokensWithAmounts_[i].addr);\n            if (tokensWithAmounts_[i].value > maxFlashLoan(tokensWithAmounts_[i].addr)) {\n                revert FluidFlashLenderError(ErrorTypes.FlashLender__MaxFlashLoanAmountExceeded);\n            }\n\n            LIQUIDITY.operate(\n                tokensWithAmounts_[i].addr,\n                0,\n                SafeCast.toInt256(tokensWithAmounts_[i].value),\n                address(0),\n                address(receiver_),\n                new bytes(0)\n            );\n\n            unchecked {\n                i++;\n            }\n        }\n\n        if (\n            //onFlashLoanMultiple or onFlashLoan callback and then we could put tokens with amounts if data callback\n            receiver_.onFlashLoanMultiple(msg.sender, tokensWithAmounts_, _FLASH_FEE, data_) !=\n            _RETURN_VALUE_FOR_FLASHLOAN_MULTIPLE\n        ) {\n            revert FluidFlashLenderError(ErrorTypes.FlashLender__InvalidReturnValue);\n        }\n\n        // execute all paybacks at Liquidity\n        for (uint256 i; i < length_; ) {\n            {\n                address receiverAddress_ = address(receiver_); // required to avoid stack too deep error\n\n                LIQUIDITY.operate{\n                    value: tokensWithAmounts_[i].addr == _NATIVE_TOKEN_ADDRESS ? tokensWithAmounts_[i].value : 0\n                }(\n                    tokensWithAmounts_[i].addr,\n                    0,\n                    -int256(tokensWithAmounts_[i].value),\n                    address(0),\n                    address(0),\n                    abi.encode(receiverAddress_)\n                );\n\n                emit LogFlashLoan(tokensWithAmounts_[i].addr, tokensWithAmounts_[i].value, receiverAddress_);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice   flashLender liquidity callback\n    /// @param    token_ The token being transferred\n    /// @param    amount_ The amount being transferred\n    function liquidityCallback(address token_, uint256 amount_, bytes calldata data_) external {\n        if (msg.sender != address(LIQUIDITY)) {\n            revert FluidFlashLenderError(ErrorTypes.FlashLender__Unauthorized);\n        }\n\n        address receiver_ = abi.decode(data_, (address));\n        IERC20(token_).safeTransferFrom(receiver_, address(LIQUIDITY), amount_);\n    }\n\n    /// @dev @Fallback function to receive Ether\n    receive() external payable {}\n\n    /// @notice sends any potentially stuck funds to Liquidity contract. Only callable by Liquidity auths.\n    //\n    // @dev this contract never holds any funds:\n    // -> borrowed funds are directly sent from Liquidity to the receiver.\n    // -> at payback, only approval is given by receiver to this contract but funds are directly transferred from\n    // receiver to Liquidity. For native token, msg.value is sent forward to Liquidity operate() call.\n    // Thus we can simply create a method to rescue any potentially stuck funds by sending them to Liquidity,\n    // where that excess amount is recognized as revenue and could be withdrawn by Governance.\n    function rescueFunds(address token_) external {\n        // todo make this method protected?\n        if (\n            // msg.sender must be an auth or Governance at Liquidity\n            (LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_AUTHS_MAPPING_SLOT,\n                    msg.sender\n                )\n            ) &\n                1 !=\n                1) && address(uint160(LIQUIDITY.readFromStorage(_GOVERNANCE_SLOT))) != msg.sender\n        ) {\n            revert FluidFlashLenderError(ErrorTypes.FlashLender__Unauthorized);\n        }\n\n        if (token_ == _NATIVE_TOKEN_ADDRESS) {\n            Address.sendValue(payable(address(LIQUIDITY)), address(this).balance);\n        } else {\n            IERC20(token_).safeTransfer(address(LIQUIDITY), IERC20(token_).balanceOf(address(this)));\n        }\n\n        emit LogRescueFunds(token_);\n    }\n\n    /// @notice repays `repayAmount_` for `token_` at Liquidity.\n    /// Can be used to balance out any leftover rounding differences at Liquidity if ever needed.\n    function repayAtLiquidity(address token_, uint256 repayAmount_) external payable {\n        // todo use safeCast here. casting to int256 here otherwise can lead to positive amounts\n        // see https://docs.google.com/document/d/15A-fobewpCnS8DVMHlOIBADB4ikvOIKO3H0TTnRoWR0\n        // also make this a protected method?\n        // -int256(repayAmount_) converts uint256 positive values to its corresponding negative int256:\n        // 123 -> -123\n        // However, because the negative is produced by making twos complement, it is possible to craft the value with most significant bit flipped to produce positive numbers:\n        // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff85 ->  123\n        // This doesnt lead to issues as passing positive values would lead to revert as the borrower specified as address(0).\n        // However, to prevent issues that might arise from further development and implementation changes,\n        // we recommend using SafeCast at expense of slightly higher gas costs for this particular call.\n        LIQUIDITY.operate{ value: msg.value }(\n            token_,\n            0,\n            -int256(repayAmount_),\n            address(0),\n            address(0),\n            abi.encode(msg.sender)\n        );\n    }\n}\n"
    },
    "contracts/protocols/flashloan/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n}\n"
    },
    "contracts/protocols/flashloan/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\n\nabstract contract Variables {\n    /// @dev address that is mapped to the chain native token\n    address internal constant _NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    bytes32 internal constant _RETURN_VALUE_FOR_FLASHLOAN_SINGLE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    bytes32 internal constant _RETURN_VALUE_FOR_FLASHLOAN_MULTIPLE = keccak256(\"FlashBorrower.onFlashLoanMultiple\");\n\n    /// @dev Storage slot with the admin of the contract at Liquidity. Logic from \"proxy.sol\".\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n    bytes32 internal constant _GOVERNANCE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /// @dev fee for flashloan set globally for all tokens\n    //\n    // @dev can't just change this to a value != 0 as that case is not fully implemented. Ensure necessary changes are\n    // made if _FLASH_FEE must be set to value != 0.\n    uint256 internal constant _FLASH_FEE = 0;\n\n    /// @notice address of the Fluid Liquidity contract\n    IFluidLiquidity public immutable LIQUIDITY;\n\n    constructor(IFluidLiquidity liquidity_) {\n        LIQUIDITY = liquidity_;\n    }\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVault.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\ninterface IFluidVault {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice returns the vault id\n    function TYPE() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Tokens {\n        address token0;\n        address token1;\n    }\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address operateImplementation;\n        address adminImplementation;\n        address secondaryImplementation;\n        address deployer; // address which deploys oracle\n        address supply; // either liquidity layer or DEX protocol\n        address borrow; // either liquidity layer or DEX protocol\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\n        uint256 vaultId;\n        uint256 vaultType;\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n\n    function rebalance(\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_\n    ) external payable returns (int supplyAmt_, int borrowAmt_);\n\n    /// @notice reverts with FluidLiquidateResult\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\ninterface IFluidVaultFactory is IERC721Enumerable {\n    /// @notice Minting an NFT Vault for the user\n    function mint(uint256 vaultId_, address user_) external returns (uint256 tokenId_);\n\n    /// @notice returns owner of Vault which is also an NFT\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /// @notice Global auth is auth for all vaults\n    function isGlobalAuth(address auth_) external view returns (bool);\n\n    /// @notice Vault auth is auth for a specific vault\n    function isVaultAuth(address vault_, address auth_) external view returns (bool);\n\n    /// @notice Total vaults deployed.\n    function totalVaults() external view returns (uint256);\n\n    /// @notice Compute vaultAddress\n    function getVaultAddress(uint256 vaultId) external view returns (address);\n\n    /// @notice read uint256 `result_` for a storage `slot_` key\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT1.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidVaultT1 {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice returns the vault factory address\n    function VAULT_FACTORY() external view returns (address);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address adminImplementation;\n        address secondaryImplementation;\n        address supplyToken;\n        address borrowToken;\n        uint8 supplyDecimals;\n        uint8 borrowDecimals;\n        uint vaultId;\n        bytes32 liquiditySupplyExchangePriceSlot;\n        bytes32 liquidityBorrowExchangePriceSlot;\n        bytes32 liquidityUserSupplySlot;\n        bytes32 liquidityUserBorrowSlot;\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    function operate(\n        uint256 nftId_, // if 0 then new position\n        int256 newCol_, // if negative then withdraw\n        int256 newDebt_, // if negative then payback\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint actualDebtAmt_, uint actualColAmt_);\n\n    function absorb() payable external;\n\n    function rebalance() external payable returns (int supplyAmt_, int borrowAmt_);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n}\n"
    },
    "solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}