{
  "language": "Solidity",
  "sources": {
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/bytesSliceAndConcat.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary BytesSliceAndConcat {\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesConcat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    ) internal pure returns (bytes memory tempBytes) {\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesSlice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory tempBytes) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/libraries/dexSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\nlibrary DexSlotsLink {\n    /// @dev storage slot for variables at Dex\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\n    /// @dev storage slot for variables2 at Dex\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\n    /// @dev storage slot for total supply shares at Dex\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\n    /// @dev storage slot for user supply mapping at Dex\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\n    /// @dev storage slot for total borrow shares at Dex\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\n    /// @dev storage slot for user borrow mapping at Dex\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\n    /// @dev storage slot for oracle mapping at Dex\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\n    /// @dev storage slot for range and threshold shifts at Dex\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\n    /// @dev storage slot for center price shift at Dex\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexReserves/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { DexSlotsLink } from \"../../../libraries/dexSlotsLink.sol\";\nimport { BytesSliceAndConcat } from \"../../../libraries/bytesSliceAndConcat.sol\";\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\nimport { Variables } from \"./variables.sol\";\nimport { Structs } from \"./structs.sol\";\n\n/// @title DexFactoryViews\n/// @notice Abstract contract providing view functions for DEX factory-related operations\nabstract contract DexFactoryViews is Variables {\n    /// @notice Get the address of a Pool given its ID\n    /// @param poolId_ The ID of the Pool\n    /// @return pool_ The address of the Pool\n    function getPoolAddress(uint256 poolId_) public view returns (address pool_) {\n        return AddressCalcs.addressCalc(address(FACTORY), poolId_);\n    }\n\n    /// @notice Get the total number of Pools\n    /// @return The total number of Pools\n    function getTotalPools() public view returns (uint) {\n        return FACTORY.totalDexes();\n    }\n\n    /// @notice Get an array of all Pool addresses\n    /// @return pools_ An array containing all Pool addresses\n    function getAllPoolAddresses() public view returns (address[] memory pools_) {\n        uint totalPools_ = getTotalPools();\n        pools_ = new address[](totalPools_);\n        for (uint i = 0; i < totalPools_; i++) {\n            pools_[i] = getPoolAddress((i + 1));\n        }\n    }\n}\n\n/// @title DexPublicViews\n/// @notice Abstract contract providing view functions for DEX public data\nabstract contract DexPublicViews {\n    /// @notice Get the prices and exchange prices for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return pex_ A struct containing prices and exchange prices\n    /// @dev expected to be called via callStatic\n    function getDexPricesAndExchangePrices(\n        address dex_\n    ) public returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n        try IFluidDexT1(dex_).getPricesAndExchangePrices() {} catch (bytes memory lowLevelData_) {\n            bytes4 errorSelector_;\n            assembly {\n                // Extract the selector from the error data\n                errorSelector_ := mload(add(lowLevelData_, 0x20))\n            }\n            if (errorSelector_ == IFluidDexT1.FluidDexPricesAndExchangeRates.selector) {\n                pex_ = abi.decode(\n                    BytesSliceAndConcat.bytesSlice(lowLevelData_, 4, lowLevelData_.length - 4),\n                    (IFluidDexT1.PricesAndExchangePrice)\n                );\n            }\n        }\n    }\n\n    /// @notice Get the collateral reserves for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing collateral reserve information\n    /// @dev expected to be called via callStatic\n    function getDexCollateralReserves(address dex_) public returns (IFluidDexT1.CollateralReserves memory reserves_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        if ((dexVariables2_ & 1) != 1) {\n            // smart col not enabled\n            return IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            try\n                IFluidDexT1(dex_).getCollateralReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.supplyToken0ExchangePrice,\n                    pex_.supplyToken1ExchangePrice\n                )\n            returns (IFluidDexT1.CollateralReserves memory colReserves_) {\n                reserves_ = colReserves_;\n            } catch {\n                reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n            }\n        } catch {\n            reserves_ = IFluidDexT1.CollateralReserves(0, 0, 0, 0);\n        }\n    }\n\n    /// @notice Get the debt reserves for a DEX\n    /// @param dex_ The address of the DEX\n    /// @return reserves_ A struct containing debt reserve information\n    /// @dev expected to be called via callStatic\n    function getDexDebtReserves(address dex_) public returns (IFluidDexT1.DebtReserves memory reserves_) {\n        uint256 dexVariables2_ = IFluidDexT1(dex_).readFromStorage(bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT));\n        if ((dexVariables2_ & 2) != 2) {\n            // smart debt not enabled\n            return IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n\n        try this.getDexPricesAndExchangePrices(dex_) returns (IFluidDexT1.PricesAndExchangePrice memory pex_) {\n            try\n                IFluidDexT1(dex_).getDebtReserves(\n                    pex_.geometricMean,\n                    pex_.upperRange,\n                    pex_.lowerRange,\n                    pex_.borrowToken0ExchangePrice,\n                    pex_.borrowToken1ExchangePrice\n                )\n            returns (IFluidDexT1.DebtReserves memory debtReserves_) {\n                reserves_ = debtReserves_;\n            } catch {\n                reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n            }\n        } catch {\n            reserves_ = IFluidDexT1.DebtReserves(0, 0, 0, 0, 0, 0);\n        }\n    }\n}\n\n/// @title DexConstantsViews\n/// @notice Abstract contract providing view functions for DEX constants\nabstract contract DexConstantsViews {\n    /// @notice returns all Pool constants\n    function getPoolConstantsView(address pool_) public view returns (IFluidDexT1.ConstantViews memory constantsView_) {\n        return IFluidDexT1(pool_).constantsView();\n    }\n\n    /// @notice returns all Pool constants 2\n    function getPoolConstantsView2(\n        address pool_\n    ) public view returns (IFluidDexT1.ConstantViews2 memory constantsView2_) {\n        return IFluidDexT1(pool_).constantsView2();\n    }\n\n    /// @notice Get the addresses of the tokens in a Pool\n    /// @param pool_ The address of the Pool\n    /// @return token0_ The address of token0 in the Pool\n    /// @return token1_ The address of token1 in the Pool\n    function getPoolTokens(address pool_) public view returns (address token0_, address token1_) {\n        IFluidDexT1.ConstantViews memory constantsView_ = IFluidDexT1(pool_).constantsView();\n        return (constantsView_.token0, constantsView_.token1);\n    }\n}\n\nabstract contract DexActionEstimates {\n    address private constant ADDRESS_DEAD = 0x000000000000000000000000000000000000dEaD;\n\n    /// @notice estimates swap IN tokens execution\n    /// @param dex_ Dex pool\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function estimateSwapIn(\n        address dex_,\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_\n    ) public payable returns (uint256 amountOut_) {\n        try IFluidDexT1(dex_).swapIn{ value: msg.value }(swap0to1_, amountIn_, amountOutMin_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (amountOut_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSwapResult.selector);\n        }\n    }\n\n    /// @notice estimates swap OUT tokens execution\n    /// @param dex_ Dex pool\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function estimateSwapOut(\n        address dex_,\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_\n    ) public payable returns (uint256 amountIn_) {\n        try IFluidDexT1(dex_).swapOut{ value: msg.value }(swap0to1_, amountOut_, amountInMax_, ADDRESS_DEAD) {} catch (\n            bytes memory lowLevelData_\n        ) {\n            (amountIn_) = _decodeLowLevelUint1x(lowLevelData_, IFluidDexT1.FluidDexSwapResult.selector);\n        }\n    }\n\n    function _decodeLowLevelUint1x(\n        bytes memory lowLevelData_,\n        bytes4 targetErrorSelector_\n    ) internal pure returns (uint value1_) {\n        if (lowLevelData_.length < 36) {\n            return 0;\n        }\n\n        bytes4 errorSelector_;\n        assembly {\n            // Extract the selector from the error data\n            errorSelector_ := mload(add(lowLevelData_, 0x20))\n        }\n        if (errorSelector_ == targetErrorSelector_) {\n            assembly {\n                value1_ := mload(add(lowLevelData_, 36))\n            }\n        }\n        // else => values remain 0\n    }\n}\n\n/// @notice Fluid Dex Reserves resolver\n/// Implements various view-only methods to give easy access to Dex protocol reserves data.\ncontract FluidDexReservesResolver is\n    Variables,\n    Structs,\n    DexFactoryViews,\n    DexConstantsViews,\n    DexPublicViews,\n    DexActionEstimates\n{\n    constructor(address factory_) Variables(factory_) {}\n\n    /// @notice Get a Pool's address and its token addresses\n    /// @param poolId_ The ID of the Pool\n    /// @return pool_ The Pool data\n    function getPool(uint256 poolId_) public view returns (Pool memory pool_) {\n        address poolAddress_ = getPoolAddress(poolId_);\n        (address token0_, address token1_) = getPoolTokens(poolAddress_);\n        return Pool(poolAddress_, token0_, token1_);\n    }\n\n    /// @notice Get an array of all Pool addresses and their token addresses\n    /// @return pools_ An array containing all Pool data\n    function getAllPools() public view returns (Pool[] memory pools_) {\n        uint256 totalPools_ = getTotalPools();\n        pools_ = new Pool[](totalPools_);\n        for (uint256 i; i < totalPools_; i++) {\n            pools_[i] = getPool(i + 1);\n        }\n    }\n\n    /// @notice Get the token addresses, collateral reserves, and debt reserves for a given Pool address\n    /// @param pool_ The Pool address\n    /// @return poolReserves_ The Pool data with reserves\n    /// @dev expected to be called via callStatic\n    function getPoolReserves(address pool_) public returns (PoolWithReserves memory poolReserves_) {\n        (address token0_, address token1_) = getPoolTokens(pool_);\n        IFluidDexT1.CollateralReserves memory collateralReserves_ = getDexCollateralReserves(pool_);\n        IFluidDexT1.DebtReserves memory debtReserves_ = getDexDebtReserves(pool_);\n        return PoolWithReserves(pool_, token0_, token1_, collateralReserves_, debtReserves_);\n    }\n\n    /// @notice Get an array of Pool addresses, their token addresses, collateral reserves, and debt reserves for a given array of Pool addresses\n    /// @param pools_ The array of Pool addresses\n    /// @return poolsReserves_ An array containing all Pool data with reserves\n    /// @dev expected to be called via callStatic\n    function getPoolsReserves(address[] memory pools_) public returns (PoolWithReserves[] memory poolsReserves_) {\n        poolsReserves_ = new PoolWithReserves[](pools_.length);\n        for (uint256 i; i < pools_.length; i++) {\n            poolsReserves_[i] = getPoolReserves(pools_[i]);\n        }\n    }\n\n    /// @notice Get an array of all Pool addresses, their token addresses, collateral reserves, and debt reserves\n    /// @return poolsReserves_ An array containing all Pool data with reserves\n    /// @dev expected to be called via callStatic\n    function getAllPoolsReserves() public returns (PoolWithReserves[] memory poolsReserves_) {\n        return getPoolsReserves(getAllPoolAddresses());\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexReserves/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidDexT1 } from \"../../../protocols/dex/interfaces/iDexT1.sol\";\n\nabstract contract Structs {\n    struct Pool {\n        address pool;\n        address token0_;\n        address token1_;\n    }\n\n    struct PoolWithReserves {\n        address pool;\n        address token0_;\n        address token1_;\n        IFluidDexT1.CollateralReserves collateralReserves;\n        IFluidDexT1.DebtReserves debtReserves;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexReserves/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidDexFactory } from \"../../../protocols/dex/interfaces/iDexFactory.sol\";\n\nabstract contract Variables {\n    IFluidDexFactory public immutable FACTORY;\n\n    constructor(address factory_) {\n        FACTORY = IFluidDexFactory(factory_);\n    }\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexFactory {\n    /// @notice Global auth is auth for all dexes\n    function isGlobalAuth(address auth_) external view returns (bool);\n\n    /// @notice Dex auth is auth for a specific dex\n    function isDexAuth(address vault_, address auth_) external view returns (bool);\n\n    /// @notice Total dexes deployed.\n    function totalDexes() external view returns (uint256);\n\n    /// @notice Compute dexAddress\n    function getDexAddress(uint256 vaultId) external view returns (address);\n\n    /// @notice read uint256 `result_` for a storage `slot_` key\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexT1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexT1 {\n    error FluidDexError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares);\n\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\n\n    /// @notice returns the dex id\n    function DEX_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndOracle;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n        struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) external view returns (CollateralReserves memory c_);\n\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) external view returns (DebtReserves memory d_);\n\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\n    function getPricesAndExchangePrices() external;\n\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param estimate_ If true, the function will revert with the estimated withdrawal amounts without actually performing the withdrawal\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        bool estimate_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param estimate_ If true, function will revert with estimated borrow amounts without executing the borrow\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        bool estimate_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param estimate_ If true, the function will revert with the estimated shares to burn without actually performing the withdrawal\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        bool estimate_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param estimate_ If true, only estimates the shares without actually borrowing\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        bool estimate_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param estimate_ If true, the function will revert with the estimated withdrawal amount without executing the withdrawal\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        bool estimate_\n    ) external returns (uint withdrawAmt_);\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) external payable returns (uint paybackAmt_);\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(uint[] memory secondsAgos_) external view returns (Oracle[] memory twaps_, uint currentPrice_);\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}