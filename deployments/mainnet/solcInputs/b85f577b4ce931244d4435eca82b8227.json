{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/config/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Error {\n    error FluidConfigError(uint256 errorId_);\n}\n"
    },
    "contracts/config/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |    ExpandPercentConfigHandler     | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant ExpandPercentConfigHandler__AddressZero = 100001;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant ExpandPercentConfigHandler__Unauthorized = 100002;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant ExpandPercentConfigHandler__InvalidParams = 100003;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant ExpandPercentConfigHandler__NoUpdate = 100004;\n\n    /// @notice thrown when slot is not used, e.g. when borrow token is 0 there is no borrow data\n    uint256 internal constant ExpandPercentConfigHandler__SlotDoesNotExist = 100005;\n\n    /***********************************|\n    |      EthenaRateConfigHandler      | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant EthenaRateConfigHandler__AddressZero = 100011;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant EthenaRateConfigHandler__Unauthorized = 100012;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant EthenaRateConfigHandler__InvalidParams = 100013;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant EthenaRateConfigHandler__NoUpdate = 100014;\n\n    /***********************************|\n    |       MaxBorrowConfigHandler      | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant MaxBorrowConfigHandler__AddressZero = 100021;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant MaxBorrowConfigHandler__Unauthorized = 100022;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant MaxBorrowConfigHandler__InvalidParams = 100023;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant MaxBorrowConfigHandler__NoUpdate = 100024;\n\n    /***********************************|\n    |       BufferRateConfigHandler     | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant BufferRateConfigHandler__AddressZero = 100031;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant BufferRateConfigHandler__Unauthorized = 100032;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant BufferRateConfigHandler__InvalidParams = 100033;\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant BufferRateConfigHandler__NoUpdate = 100034;\n\n    /// @notice thrown when rate data version is not supported\n    uint256 internal constant BufferRateConfigHandler__RateVersionUnsupported = 100035;\n\n    /***********************************|\n    |          FluidRatesAuth           | \n    |__________________________________*/\n\n    /// @notice thrown when no update is currently needed\n    uint256 internal constant RatesAuth__NoUpdate = 100041;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant RatesAuth__Unauthorized = 100042;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant RatesAuth__InvalidParams = 100043;\n\n    /// @notice thrown when cooldown is not yet expired\n    uint256 internal constant RatesAuth__CooldownLeft = 100044;\n\n    /// @notice thrown when version is invalid\n    uint256 internal constant RatesAuth__InvalidVersion = 100045;\n\n    /***********************************|\n    |          ListTokenAuth            | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant ListTokenAuth__Unauthorized = 100051;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant ListTokenAuth_AlreadyInitialized = 100052;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant ListTokenAuth__InvalidParams = 100053;\n\n    /***********************************|\n    |       CollectRevenueAuth          | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant CollectRevenueAuth__Unauthorized = 100061;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant CollectRevenueAuth__InvalidParams = 100062;\n\n    /***********************************|\n    |       FluidWithdrawLimitAuth      | \n    |__________________________________*/\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant WithdrawLimitAuth__NoUserSupply = 100071;\n\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\n    uint256 internal constant WithdrawLimitAuth__Unauthorized = 100072;\n\n    /// @notice thrown when invalid params are passed into a method\n    uint256 internal constant WithdrawLimitAuth__InvalidParams = 100073;\n\n    /// @notice thrown when no more withdrawal limit can be set for the day\n    uint256 internal constant WithdrawLimitAuth__DailyLimitReached = 100074;\n\n    /// @notice thrown when no more withdrawal limit can be set for the hour\n    uint256 internal constant WithdrawLimitAuth__HourlyLimitReached = 100075;\n\n    /// @notice thrown when the withdrawal limit and userSupply difference exceeds 5%\n    uint256 internal constant WithdrawLimitAuth__ExcessPercentageDifference = 100076;\n\n}\n"
    },
    "contracts/config/ethenaRateHandler/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Events {\n    /// @notice emitted when borrow magnifier is updated at vault\n    event LogUpdateBorrowRateMagnifier(uint256 oldMagnifier, uint256 newMagnifier);\n}\n"
    },
    "contracts/config/ethenaRateHandler/interfaces/iStakedUSDe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\ninterface IStakedUSDe is IERC4626 {\n    /// @notice The amount of the last asset distribution from the controller contract into this\n    /// contract + any unvested remainder at that time\n    function vestingAmount() external view returns (uint256);\n\n    /// @notice The timestamp of the last asset distribution from the controller contract into this contract\n    function lastDistributionTimestamp() external view returns (uint256);\n\n    /// @notice Returns the amount of USDe tokens that are vested in the contract.\n    function totalAssets() external view returns (uint256);\n}\n"
    },
    "contracts/config/ethenaRateHandler/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { IFluidVaultT1 } from \"../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { FluidVaultT1Admin } from \"../../protocols/vault/vaultT1/adminModule/main.sol\";\nimport { IStakedUSDe } from \"./interfaces/iStakedUSDe.sol\";\nimport { Variables } from \"./variables.sol\";\nimport { Events } from \"./events.sol\";\nimport { Error } from \"../error.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\n/// @notice Sets borrow rate for sUSDe/debtToken vaults based on sUSDe yield rate, by adjusting the borrowRateMagnifier\ncontract FluidEthenaRateConfigHandler is Variables, Error, Events {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidConfigError(ErrorTypes.EthenaRateConfigHandler__AddressZero);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract)\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidConfigError(ErrorTypes.EthenaRateConfigHandler__Unauthorized);\n        }\n        _;\n    }\n\n    constructor(\n        IFluidReserveContract reserveContract_,\n        IFluidLiquidity liquidity_,\n        IFluidVaultT1 vault_,\n        IStakedUSDe stakedUSDe_,\n        address borrowToken_,\n        uint256 ratePercentMargin_,\n        uint256 maxRewardsDelay_,\n        uint256 utilizationPenaltyStart_,\n        uint256 utilization100PenaltyPercent_\n    )\n        validAddress(address(reserveContract_))\n        validAddress(address(liquidity_))\n        validAddress(address(vault_))\n        validAddress(address(stakedUSDe_))\n        validAddress(borrowToken_)\n    {\n        if (\n            ratePercentMargin_ == 0 ||\n            ratePercentMargin_ >= 1e4 ||\n            maxRewardsDelay_ == 0 ||\n            utilizationPenaltyStart_ >= 1e4 ||\n            utilization100PenaltyPercent_ == 0\n        ) {\n            revert FluidConfigError(ErrorTypes.EthenaRateConfigHandler__InvalidParams);\n        }\n\n        RESERVE_CONTRACT = reserveContract_;\n        LIQUIDITY = liquidity_;\n        SUSDE = stakedUSDe_;\n        VAULT = vault_;\n        BORROW_TOKEN = borrowToken_;\n\n        _LIQUDITY_BORROW_TOKEN_EXCHANGE_PRICES_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            borrowToken_\n        );\n\n        RATE_PERCENT_MARGIN = ratePercentMargin_;\n        MAX_REWARDS_DELAY = maxRewardsDelay_;\n\n        UTILIZATION_PENALTY_START = utilizationPenaltyStart_;\n        UTILIZATION100_PENALTY_PERCENT = utilization100PenaltyPercent_;\n    }\n\n    /// @notice Rebalances the borrow rate magnifier for `VAULT` based on borrow rate at Liquidity in relation to\n    /// sUSDe yield rate (`getSUSDEYieldRate()`).\n    /// Emits `LogUpdateBorrowRateMagnifier` in case of update. Reverts if no update is needed.\n    /// Can only be called by an authorized rebalancer.\n    function rebalance() external onlyRebalancer {\n        uint256 targetMagnifier_ = calculateMagnifier();\n        uint256 currentMagnifier_ = currentMagnifier();\n\n        // execute update on vault if necessary\n        if (targetMagnifier_ == currentMagnifier_) {\n            revert FluidConfigError(ErrorTypes.EthenaRateConfigHandler__NoUpdate);\n        }\n\n        FluidVaultT1Admin(address(VAULT)).updateBorrowRateMagnifier(targetMagnifier_);\n\n        emit LogUpdateBorrowRateMagnifier(currentMagnifier_, targetMagnifier_);\n    }\n\n    /// @notice Calculates the new borrow rate magnifier based on sUSDe yield rate and utilization\n    /// @return magnifier_ the calculated magnifier value.\n    function calculateMagnifier() public view returns (uint256 magnifier_) {\n        uint256 sUSDeYieldRate_ = getSUSDeYieldRate();\n        uint256 exchangePriceAndConfig_ = LIQUIDITY.readFromStorage(_LIQUDITY_BORROW_TOKEN_EXCHANGE_PRICES_SLOT);\n\n        uint256 utilization_ = (exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14;\n\n        // calculate target borrow rate. scaled by 1e18.\n        // borrow rate is based on sUSDeYieldRate_ and a margin that goes to lenders\n        // e.g. when RATE_PERCENT_MARGIN = 1000 (10%), then borrow rate will be 90% of the sUSDe yield rate\n        // e.g. when sUSDe yield is 60%, borrow rate would be 54%\n        uint256 targetBorrowRate_ = (sUSDeYieldRate_ * (1e4 - RATE_PERCENT_MARGIN)) / 1e4;\n\n        if (utilization_ > UTILIZATION_PENALTY_START) {\n            // above UTILIZATION_PENALTY_START (e.g. 90%), penalty should rise linearly according to UTILIZATION100_PENALTY_PERCENT\n            // e.g. from 10% margin at 90% utilization to -3% penalty at 100% utilization\n            // so from +RATE_PERCENT_MARGIN at UTILIZATION_PENALTY_START to -UTILIZATION100_PENALTY_PERCENT at 100%\n            if (utilization_ < 1e4) {\n                uint256 utilizationAbovePenaltyStart_ = utilization_ - UTILIZATION_PENALTY_START;\n                uint256 penaltyUtilizationDiff_ = 1e4 - UTILIZATION_PENALTY_START;\n                uint256 penaltyRateDiff_ = RATE_PERCENT_MARGIN + UTILIZATION100_PENALTY_PERCENT;\n\n                // e.g. when current utilization = 96%, start penalty utilization = 90%, penalty at 100 = 3%, rate margin = 90%:\n                // utilizationAbovePenaltyStart_ = 600 (6%)\n                // penaltyUtilizationDiff_ = 1000 (10%)\n                // penaltyRateDiff_ = 1000 + 300 = 1300 (13%)\n                // marginAfterPenalty_ = 1300 * 600 / 1000 = 780 (7.8%)\n                uint256 marginAfterPenalty_ = (penaltyRateDiff_ * utilizationAbovePenaltyStart_) /\n                    penaltyUtilizationDiff_;\n\n                // e.g. when sUSDe yield is 60%, borrow rate would become 58.68% (from 60% * (90% + 7.8%) / 100% )\n                targetBorrowRate_ = (sUSDeYieldRate_ * ((1e4 - RATE_PERCENT_MARGIN) + marginAfterPenalty_)) / 1e4;\n            } else {\n                // above 100% utilization, cap at -UTILIZATION100_PENALTY_PERCENT penalty\n                targetBorrowRate_ = (sUSDeYieldRate_ * (1e4 + UTILIZATION100_PENALTY_PERCENT)) / 1e4;\n            }\n        }\n\n        // get current neutral borrow rate at Liquidity (without any magnifier).\n        // exchangePriceAndConfig slot at Liquidity, first 16 bits\n        uint256 liquidityBorrowRate_ = exchangePriceAndConfig_ & X16;\n\n        if (liquidityBorrowRate_ == 0) {\n            return 1e4;\n        }\n\n        // calculate magnifier needed to reach target borrow rate.\n        // liquidityBorrowRate_ * x = targetBorrowRate_. so x = targetBorrowRate_ / liquidityBorrowRate_.\n        // must scale liquidityBorrowRate_ from 1e2 to 1e18 as targetBorrowRate_ is in 1e18. magnifier itself is scaled\n        // by 1e4 (1x = 10000)\n        magnifier_ = (1e4 * targetBorrowRate_) / (liquidityBorrowRate_ * 1e16);\n\n        // make sure magnifier is within allowed limits\n        if (magnifier_ < _MIN_MAGNIFIER) {\n            return _MIN_MAGNIFIER;\n        }\n        if (magnifier_ > _MAX_MAGNIFIER) {\n            return _MAX_MAGNIFIER;\n        }\n    }\n\n    /// @notice returns the currently configured borrow magnifier at the `VAULT`.\n    function currentMagnifier() public view returns (uint256) {\n        // read borrow rate magnifier from Vault `vaultVariables2` located in storage slot 1, 16 bits from 16-31\n        return (VAULT.readFromStorage(bytes32(uint256(1))) >> 16) & X16;\n    }\n\n    /// @notice calculates updated vesting yield rate based on `vestingAmount` and `totalAssets` of StakedUSDe contract\n    /// @return rate_ sUSDe yearly yield rate scaled by 1e18 (1e18 = 1%, 1e20 = 100%)\n    function getSUSDeYieldRate() public view returns (uint256 rate_) {\n        if (block.timestamp > SUSDE.lastDistributionTimestamp() + _SUSDE_VESTING_PERIOD + MAX_REWARDS_DELAY) {\n            // if rewards update on StakedUSDe contract is delayed by more than `MAX_REWARDS_DELAY`, we use rate as 0\n            // as we can't know if e.g. funding would have gone negative and there are indeed no rewards.\n            return 0;\n        }\n\n        // vestingAmount is yield per 8 hours (`SUSDE_VESTING_PERIOD`)\n        rate_ = (SUSDE.vestingAmount() * 1e20) / SUSDE.totalAssets(); // 8 hours rate\n        // turn into yearly yield\n        rate_ = (rate_ * 365 * 24 hours) / _SUSDE_VESTING_PERIOD; // 365 days * 24 hours / 8 hours -> rate_ * 1095\n    }\n}\n"
    },
    "contracts/config/ethenaRateHandler/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\nimport { IFluidReserveContract } from \"../../reserve/interfaces/iReserveContract.sol\";\nimport { IFluidVaultT1 } from \"../../protocols/vault/interfaces/iVaultT1.sol\";\nimport { IStakedUSDe } from \"./interfaces/iStakedUSDe.sol\";\n\nabstract contract Constants {\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n    IFluidLiquidity public immutable LIQUIDITY;\n    IFluidVaultT1 public immutable VAULT;\n    IStakedUSDe public immutable SUSDE;\n    address public immutable BORROW_TOKEN;\n\n    /// @notice sUSDe vesting yield reward rate percent margin that goes to lenders\n    /// e.g. RATE_PERCENT_MARGIN = 10% then borrow rate for debt token ends up as 90% of the sUSDe yield.\n    /// (in 1e2: 100% = 10_000; 1% = 100)\n    uint256 public immutable RATE_PERCENT_MARGIN;\n\n    /// @notice max delay in seconds for rewards update after vesting period ended, after which we assume rate is 0.\n    /// e.g. 15 min\n    uint256 public immutable MAX_REWARDS_DELAY;\n\n    /// @notice utilization penalty start point (in 1e2: 100% = 10_000; 1% = 100). above this, a penalty percent\n    ///         is applied, to incentivize deleveraging.\n    uint256 public immutable UTILIZATION_PENALTY_START;\n    /// @notice penalty percent target at 100%, on top of sUSDe yield rate if utilization is above UTILIZATION_PENALTY_START\n    ///         (in 1e2: 100% = 10_000; 1% = 100)\n    uint256 public immutable UTILIZATION100_PENALTY_PERCENT;\n\n    bytes32 internal immutable _LIQUDITY_BORROW_TOKEN_EXCHANGE_PRICES_SLOT;\n\n    /// @dev vesting period defined as private constant on StakedUSDe contract\n    uint256 internal constant _SUSDE_VESTING_PERIOD = 8 hours;\n\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant _MIN_MAGNIFIER = 1e4; // min magnifier is always at least 1x (10000)\n    uint256 internal constant _MAX_MAGNIFIER = 65535; // max magnifier to fit in storage slot is 65535 (16 bits)\n}\n\nabstract contract Variables is Constants {}\n"
    },
    "contracts/deployer/interface.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidContractFactory {\n    function totalContracts() external view returns (uint256);\n\n    function getContractAddress(uint256 nonce_) external view returns (address contractAddress_);\n\n    function deployContract(\n        bytes calldata contractCode_\n    ) external returns (address contractAddress_);\n\n    function updateDeployer(address deployer_, uint16 count_) external;\n\n    function deployer(address deployer_) external view returns (uint256);\n\n}\n"
    },
    "contracts/infiniteProxy/interfaces/iProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IProxy {\n    function setAdmin(address newAdmin_) external;\n\n    function setDummyImplementation(address newDummyImplementation_) external;\n\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\n\n    function removeImplementation(address implementation_) external;\n\n    function getAdmin() external view returns (address);\n\n    function getDummyImplementation() external view returns (address);\n\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\n\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/bigMathMinified.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\nlibrary BigMathMinified {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/bigMathVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\n\n/// @title Extended version of BigMathMinified. Implements functions for normal operators (*, /, etc) modified to interact with big numbers.\n/// @notice this is an optimized version mainly created by taking Fluid vault's codebase into consideration so it's use is limited for other cases.\n// \n// @dev IMPORTANT: for any change here, make sure to uncomment and run the fuzz tests in bigMathVault.t.sol\nlibrary BigMathVault {\n    uint private constant COEFFICIENT_SIZE_DEBT_FACTOR = 35;\n    uint private constant EXPONENT_SIZE_DEBT_FACTOR = 15;\n    uint private constant COEFFICIENT_MAX_DEBT_FACTOR = (1 << COEFFICIENT_SIZE_DEBT_FACTOR) - 1;\n    uint private constant EXPONENT_MAX_DEBT_FACTOR = (1 << EXPONENT_SIZE_DEBT_FACTOR) - 1;\n    uint private constant DECIMALS_DEBT_FACTOR = 16384;\n    uint internal constant MAX_MASK_DEBT_FACTOR = (1 << (COEFFICIENT_SIZE_DEBT_FACTOR + EXPONENT_SIZE_DEBT_FACTOR)) - 1;\n\n    // Having precision as 2**64 on vault\n    uint internal constant PRECISION = 64;\n    uint internal constant TWO_POWER_64 = 1 << PRECISION;\n    // Max bit for 35 bits * 35 bits number will be 70\n    // why do we use 69 then here instead of 70\n    uint internal constant TWO_POWER_69_MINUS_1 = (1 << 69) - 1;\n\n    uint private constant COEFFICIENT_PLUS_PRECISION = COEFFICIENT_SIZE_DEBT_FACTOR + PRECISION; // 99\n    uint private constant COEFFICIENT_PLUS_PRECISION_MINUS_1 = COEFFICIENT_PLUS_PRECISION - 1; // 98\n    uint private constant TWO_POWER_COEFFICIENT_PLUS_PRECISION_MINUS_1 = (1 << COEFFICIENT_PLUS_PRECISION_MINUS_1) - 1; // (1 << 98) - 1;\n    uint private constant TWO_POWER_COEFFICIENT_PLUS_PRECISION_MINUS_1_MINUS_1 =\n        (1 << (COEFFICIENT_PLUS_PRECISION_MINUS_1 - 1)) - 1; // (1 << 97) - 1;\n\n    /// @dev multiplies a `normal` number with a `bigNumber1` and then divides by `bigNumber2`.\n    /// @dev For vault's use case MUST always:\n    ///      - bigNumbers have exponent size 15 bits\n    ///      - bigNumbers have coefficient size 35 bits and have 35th bit always 1 (when exponent > 0 BigMath numbers have max precision)\n    ///        so coefficients must always be in range 17179869184 <= coefficient <= 34359738367.\n    ///      - bigNumber1 (debt factor) always have exponent >= 1 & <= 16384\n    ///      - bigNumber2 (connection factor) always have exponent >= 1 & <= 32767 (15 bits)\n    ///      - bigNumber2 always >= bigNumber1 (connection factor can never be < base branch debt factor)\n    ///      - as a result of previous points, numbers must never be 0\n    ///      - normal is positionRawDebt and is always within 10000 and type(int128).max\n    /// @return normal * bigNumber1 / bigNumber2\n    function mulDivNormal(uint256 normal, uint256 bigNumber1, uint256 bigNumber2) internal pure returns (uint256) {\n        unchecked {\n            // exponent2_ - exponent1_\n            uint netExponent_ = (bigNumber2 & EXPONENT_MAX_DEBT_FACTOR) - (bigNumber1 & EXPONENT_MAX_DEBT_FACTOR);\n            if (netExponent_ < 129) {\n                // (normal * coefficient1_) / (coefficient2_ << netExponent_);\n                return ((normal * (bigNumber1 >> EXPONENT_SIZE_DEBT_FACTOR)) /\n                    ((bigNumber2 >> EXPONENT_SIZE_DEBT_FACTOR) << netExponent_));\n            }\n            // else:\n            // biggest possible nominator: type(int128).max * 35bits max      =  5846006549323611672814739330865132078589370433536\n            // smallest possible denominator: 17179869184 << 129 (= 1 << 163) = 11692013098647223345629478661730264157247460343808\n            // -> can only ever be 0\n            return 0;\n        }\n    }\n\n    /// @dev multiplies a `bigNumber` with normal `number1` and then divides by `TWO_POWER_64`.\n    /// @dev For vault's use case (calculating new branch debt factor after liquidation):\n    ///      - number1 is debtFactor, intialized as TWO_POWER_64 and reduced from there, hence it's always <= TWO_POWER_64 and always > 0.\n    ///      - bigNumber is branch debt factor, which starts as ((X35 << 15) | (1 << 14)) and reduces from there.\n    ///      - bigNumber must have have exponent size 15 bits and be >= 1 & <= 16384\n    ///      - bigNumber must have coefficient size 35 bits and have 35th bit always 1 (when exponent > 0 BigMath numbers have max precision)\n    ///        so coefficients must always be in range 17179869184 <= coefficient <= 34359738367.\n    /// @param bigNumber Coefficient | Exponent.\n    /// @param number1 normal number.\n    /// @return result bigNumber * number1 / TWO_POWER_64.\n    function mulDivBigNumber(uint256 bigNumber, uint256 number1) internal pure returns (uint256 result) {\n        // using unchecked as we are only at 1 place in Vault and it won't overflow there.\n        unchecked {\n            uint256 _resultNumerator = (bigNumber >> EXPONENT_SIZE_DEBT_FACTOR) * number1; // bigNumber coefficient * normal number\n            // 99% chances are that most sig bit should be 64 + 35 - 1 or 64 + 35 - 2\n            // diff = mostSigBit. Can only ever be >= 35 and <= 98\n            uint256 diff = (_resultNumerator > TWO_POWER_COEFFICIENT_PLUS_PRECISION_MINUS_1)\n                ? COEFFICIENT_PLUS_PRECISION\n                : (_resultNumerator > TWO_POWER_COEFFICIENT_PLUS_PRECISION_MINUS_1_MINUS_1)\n                    ? COEFFICIENT_PLUS_PRECISION_MINUS_1\n                    : BigMathMinified.mostSignificantBit(_resultNumerator);\n\n            // diff = difference in bits to make the _resultNumerator 35 bits again\n            diff = diff - COEFFICIENT_SIZE_DEBT_FACTOR;\n            _resultNumerator = _resultNumerator >> diff;\n            // starting exponent is 16384, so exponent should never get 0 here\n            result = (bigNumber & EXPONENT_MAX_DEBT_FACTOR) + diff;\n            if (result > PRECISION) {\n                result = (_resultNumerator << EXPONENT_SIZE_DEBT_FACTOR) + result - PRECISION; // divides by TWO_POWER_64 by reducing exponent by 64\n            } else {\n                // if number1 is small, e.g. 1e4 and bigNumber is also small e.g. coefficient = 17179869184 & exponent is at 50\n                // then: resultNumerator = 171798691840000, diff most significant bit = 48, ending up with diff = 13\n                // for exponent in result we end up doing: 50 + 13 - 64 -> underflowing exponent.\n                // this should never happen anyway, but if it does better to revert than to continue with unknown effects.\n                revert(); // debt factor should never become a BigNumber with exponent <= 0\n            }\n        }\n    }\n\n    /// @dev multiplies a `bigNumber1` with another `bigNumber2`.\n    /// @dev For vault's use case (calculating connection factor of merged branches userTickDebtFactor * connectionDebtFactor *... connectionDebtFactor):\n    ///      - bigNumbers must have have exponent size 15 bits and be >= 1 & <= 32767\n    ///      - bigNumber must have coefficient size 35 bits and have 35th bit always 1 (when exponent > 0 BigMath numbers have max precision)\n    ///        so coefficients must always be in range 17179869184 <= coefficient <= 34359738367.\n    /// @dev sum of exponents from `bigNumber1` `bigNumber2` should be > 16384.\n    /// e.g. res = bigNumber1 * bigNumber2 = [(coe1, exp1) * (coe2, exp2)] >> decimal\n    ///          = (coe1*coe2>>overflow, exp1+exp2+overflow-decimal)\n    /// @param bigNumber1          BigNumber format with coefficient and exponent.\n    /// @param bigNumber2          BigNumber format with coefficient and exponent.\n    /// @return                    BigNumber format with coefficient and exponent\n    function mulBigNumber(uint256 bigNumber1, uint256 bigNumber2) internal pure returns (uint256) {\n        unchecked {\n            // coefficient1_ * coefficient2_\n            uint resCoefficient_ = (bigNumber1 >> EXPONENT_SIZE_DEBT_FACTOR) *\n                (bigNumber2 >> EXPONENT_SIZE_DEBT_FACTOR);\n            // res coefficient at min can be 17179869184 * 17179869184 =  295147905179352825856 (= 1 << 68; 69th bit as 1)\n            // res coefficient at max can be 34359738367 * 34359738367 = 1180591620648691826689 (X35 * X35 fits in 70 bits)\n            uint overflowLen_ = resCoefficient_ > TWO_POWER_69_MINUS_1\n                ? COEFFICIENT_SIZE_DEBT_FACTOR\n                : COEFFICIENT_SIZE_DEBT_FACTOR - 1;\n            // overflowLen_ is either 34 or 35\n            resCoefficient_ = resCoefficient_ >> overflowLen_;\n\n            // bigNumber2 is connection factor\n            // exponent1_ + exponent2_ + overflowLen_ - decimals\n            uint resExponent_ = ((bigNumber1 & EXPONENT_MAX_DEBT_FACTOR) +\n                (bigNumber2 & EXPONENT_MAX_DEBT_FACTOR) +\n                overflowLen_);\n            if (resExponent_ < DECIMALS_DEBT_FACTOR) {\n                // for this ever to happen, the debt factors used to calculate connection factors would have to be at extremely\n                // unrealistic values. Like e.g.\n                // branch3 (debt factor X35 << 15 | 16383) got merged into branch2 (debt factor X35 << 15 | 8190)\n                // -> connection factor (divBigNumber): ((coe1<<precision_)/coe2>>overflowLen, exp1+decimal+overflowLen-exp2-precision_) so:\n                // coefficient: (X35<<64)/X35 >> 30 = 17179869184\n                // exponent: 8190+16384+30-16383-64 = 8157.\n                // result: 17179869184 << 15 | 8157\n                // and then branch2 into branch1 (debt factor X35 << 15 | 22). -> connection factor:\n                // coefficient: (X35<<64)/X35 >> 30 = 17179869184\n                // exponent: 22+16384+30-8190-64 = 8182.\n                // result: 17179869184 << 15 | 8182\n                // connection factors sum up (mulBigNumber): (coe1*coe2>>overflow, exp1+exp2+overflow-decimal)\n                // exponent: 8182+8157+35-16384=16374-16384=-10. underflow.\n                // this should never happen anyway, but if it does better to revert than to continue with unknown effects.\n                revert();\n            }\n            resExponent_ = resExponent_ - DECIMALS_DEBT_FACTOR;\n\n            if (resExponent_ > EXPONENT_MAX_DEBT_FACTOR) {\n                // if resExponent_ is not within limits that means user's got ~100% (something like 99.999999999999...)\n                // this situation will probably never happen and this basically means user's position is ~100% liquidated\n                return MAX_MASK_DEBT_FACTOR;\n            }\n\n            return ((resCoefficient_ << EXPONENT_SIZE_DEBT_FACTOR) | resExponent_);\n        }\n    }\n\n    /// @dev divides a `bigNumber1` by `bigNumber2`.\n    /// @dev For vault's use case (calculating connectionFactor_ = baseBranchDebtFactor / currentBranchDebtFactor) bigNumbers MUST always:\n    ///      - have exponent size 15 bits and be >= 1 & <= 16384\n    ///      - have coefficient size 35 bits and have 35th bit always 1 (when exponent > 0 BigMath numbers have max precision)\n    ///        so coefficients must always be in range 17179869184 <= coefficient <= 34359738367.\n    ///      - as a result of previous points, numbers must never be 0\n    /// e.g. res = bigNumber1 / bigNumber2 = [(coe1, exp1) / (coe2, exp2)] << decimal\n    ///          = ((coe1<<precision_)/coe2, exp1+decimal-exp2-precision_)\n    /// @param bigNumber1          BigNumber format with coefficient and exponent\n    /// @param bigNumber2          BigNumber format with coefficient and exponent\n    /// @return                    BigNumber format with coefficient and exponent\n    /// Returned connection factor can only ever be >= baseBranchDebtFactor (c = x*100/y with both x,y > 0 & x,y <= 100: c can only ever be >= x)\n    function divBigNumber(uint256 bigNumber1, uint256 bigNumber2) internal pure returns (uint256) {\n        unchecked {\n            // (coefficient1_ << PRECISION) / coefficient2_\n            uint256 resCoefficient_ = ((bigNumber1 >> EXPONENT_SIZE_DEBT_FACTOR) << PRECISION) /\n                (bigNumber2 >> EXPONENT_SIZE_DEBT_FACTOR);\n            // nominator at min 17179869184 << 64 = 316912650057057350374175801344. at max 34359738367 << 64 = 633825300095667956674642051072.\n            // so min value resCoefficient_ 9223372037123211264 (64 bits) vs max 36893488146345361408 (fits in 65 bits)\n\n            // mostSigBit will be PRECISION + 1 or PRECISION\n            uint256 overflowLen_ = ((resCoefficient_ >> PRECISION) == 1) ? (PRECISION + 1) : PRECISION;\n            // Overflow will be PRECISION - COEFFICIENT_SIZE_DEBT_FACTOR or (PRECISION + 1) - COEFFICIENT_SIZE_DEBT_FACTOR\n            // Meaning 64 - 35 = 29 or 65 - 35 = 30\n            overflowLen_ = overflowLen_ - COEFFICIENT_SIZE_DEBT_FACTOR;\n            resCoefficient_ = resCoefficient_ >> overflowLen_;\n\n            // exponent1_ will always be less than or equal to 16384\n            // exponent2_ will always be less than or equal to 16384\n            // Even if exponent2_ is 0 (not possible) & resExponent_ = DECIMALS_DEBT_FACTOR then also resExponent_ will be less than max limit, so no overflow\n            // result exponent = (exponent1_ + DECIMALS_DEBT_FACTOR + overflowLen_) - (exponent2_ + PRECISION);\n            uint256 resExponent_ = ((bigNumber1 & EXPONENT_MAX_DEBT_FACTOR) + // exponent1_\n                DECIMALS_DEBT_FACTOR + // DECIMALS_DEBT_FACTOR is 100% as it is percentage value\n                overflowLen_); // addition part resExponent_ here min 16414, max 32798\n            // reuse overFlowLen_ variable for subtraction sum of exponent\n            overflowLen_ = (bigNumber2 & EXPONENT_MAX_DEBT_FACTOR) + PRECISION; // subtraction part overflowLen_ here: min 65, max 16448\n            if (resExponent_ > overflowLen_) {\n                resExponent_ = resExponent_ - overflowLen_;\n\n                return ((resCoefficient_ << EXPONENT_SIZE_DEBT_FACTOR) | resExponent_);\n            }\n\n            // Can happen if bigNumber1 exponent is < 35 (35+16384+29 = 16448) and bigNumber2 exponent is e.g. max 16384.\n            // this would mean a branch with a normal big debt factor (bigNumber2) is merged into a base branch with an extremely small\n            // debt factor (bigNumber1).\n            // this should never happen anyway, but if it does better to revert than to continue with unknown effects.\n            revert(); // connection factor should never become a BigNumber with exponent <= 0\n        }\n    }\n}\n"
    },
    "contracts/libraries/bytesSliceAndConcat.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary BytesSliceAndConcat {\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesConcat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    ) internal pure returns (bytes memory tempBytes) {\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesSlice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory tempBytes) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/libraries/dexSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\nlibrary DexSlotsLink {\n    /// @dev storage slot for variables at Dex\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\n    /// @dev storage slot for variables2 at Dex\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\n    /// @dev storage slot for total supply shares at Dex\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\n    /// @dev storage slot for user supply mapping at Dex\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\n    /// @dev storage slot for total borrow shares at Dex\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\n    /// @dev storage slot for user borrow mapping at Dex\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\n    /// @dev storage slot for oracle mapping at Dex\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\n    /// @dev storage slot for range and threshold shifts at Dex\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\n    /// @dev storage slot for center price shift at Dex\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n}\n"
    },
    "contracts/libraries/fluidProtocolTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ninterface IFluidProtocol {\n    function TYPE() external view returns (uint256);\n}\n\n/// @notice implements helper methods to filter Fluid protocols by a certain type\nlibrary FluidProtocolTypes {\n    uint256 internal constant VAULT_T1_TYPE = 10000; // VaultT1 borrow protocol type vaults\n    uint256 internal constant VAULT_T2_SMART_COL_TYPE = 20000; // DEX protocol type vault\n    uint256 internal constant VAULT_T3_SMART_DEBT_TYPE = 30000; // DEX protocol type vault\n    uint256 internal constant VAULT_T4_SMART_COL_SMART_DEBT_TYPE = 40000; // DEX protocol type vault\n\n    /// @dev filters input `addresses_` by protocol `type_`. Input addresses must be actual Fluid protocols, otherwise\n    ///      they would be wrongly assumed to be VaultT1 even if they are not Fluid VaultT1 smart contracts.\n    ///      `type_` must be a listed constant type of this library.\n    ///      Example usage is to filter all vault addresses at the Vault factory by a certain type, e.g. to not include\n    ///      DEX protocol type vaults.\n    function filterBy(address[] memory addresses_, uint256 type_) internal view returns (address[] memory filtered_) {\n        uint256 curType_;\n        uint256 filteredProtocols_ = addresses_.length;\n        for (uint256 i; i < addresses_.length; ) {\n            try IFluidProtocol(addresses_[i]).TYPE() returns (uint256 protocolType_) {\n                curType_ = protocolType_;\n            } catch {\n                curType_ = VAULT_T1_TYPE;\n            }\n\n            if (curType_ != type_) {\n                addresses_[i] = address(0);\n                --filteredProtocols_;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        filtered_ = new address[](filteredProtocols_);\n        uint256 index_;\n        unchecked {\n            for (uint256 i; i < addresses_.length; ) {\n                if (addresses_[i] != address(0)) {\n                    filtered_[index_] = addresses_[i];\n                    ++index_;\n                }\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/liquidityCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\nimport { LiquiditySlotsLink } from \"./liquiditySlotsLink.sol\";\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\n\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\n/// borrow rate, withdrawal / borrow limits, revenue amount.\nlibrary LiquidityCalcs {\n    error FluidLiquidityCalcsError(uint256 errorId_);\n\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\n    event BorrowRateMaxCap();\n\n    /// @dev constants as from Liquidity variables.sol\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X15 = 0x7fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                  CALC EXCHANGE PRICES                  /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\n    function calcExchangePrices(\n        uint256 exchangePricesAndConfig_\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\n        // Extracting exchange prices\n        supplyExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\n            X64;\n        borrowExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\n            X64;\n\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\n        }\n\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\n\n        unchecked {\n            // last timestamp can not be > current timestamp\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\n\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\n                X15;\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // calculate new borrow exchange price.\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\n            borrowExchangePrice_ +=\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\n\n            // FOR SUPPLY EXCHANGE PRICE:\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\n            //\n            // Example:\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\n            // yield is 10 (so half a year must have passed).\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 20%) = 62,5%\n            // supplyRate = (40% * (100% - 10%)) * = 36% * 62,5% = 22.5%\n            // increase in supplyExchangePrice, assuming 100 as previous price.\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\n\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\n\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\n\n            if (temp_ == 1) {\n                // if no raw supply: no exchange price update needed\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\n            if (temp_ & 1 == 1) {\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n                temp_ = temp_ >> 1;\n\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\n                // in the if statement a little above.\n\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\n                // so ratioSupplyYield must come out as 2.5 (250%).\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\n                temp_ =\n                    // utilization * (100% + 100% / supplyRatio)\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\n                    (FOUR_DECIMALS);\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\n            } else {\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n                temp_ = temp_ >> 1;\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\n\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\n                temp_ =\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\n                    (1e27 *\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\n                        (FOUR_DECIMALS + temp_)) /\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\n            }\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\n\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\n            if (borrowRatio_ & 1 == 1) {\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\n\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\n            } else {\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\n            }\n\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\n\n            // 2. calculate supply rate\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\n            // but more suppliers not earning interest.\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\n                temp_ * // ratioSupplyYield\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\n\n            // 3. calculate increase in supply exchange price\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                     CALC REVENUE                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\n    /// and the current balance of the Fluid liquidity contract for the token.\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\n    /// @return revenueAmount_ collectable revenue amount\n    function calcRevenue(\n        uint256 totalAmounts_,\n        uint256 exchangePricesAndConfig_,\n        uint256 liquidityTokenBalance_\n    ) internal view returns (uint256 revenueAmount_) {\n        // @dev no need to super-optimize this method as it is only used by admin\n\n        // calculate the new exchange prices based on earned interest\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\n\n        // total supply = interest free + with interest converted from raw\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\n\n        if (totalSupply_ > 0) {\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\n            // ensure there is no possible case because of rounding etc. where this would revert,\n            // explicitly check if >\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\n            // can only be revenue.\n        } else {\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\n            revenueAmount_ = liquidityTokenBalance_;\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ =\n                block.timestamp -\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ =\n                block.timestamp -\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC RATES                        /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev Calculates new borrow rate from utilization for a token\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\n        // extract rate version: 4 bits (0xF) starting from bit 0\n        uint256 rateVersion_ = (rateData_ & 0xF);\n\n        if (rateVersion_ == 1) {\n            rate_ = calcRateV1(rateData_, utilization_);\n        } else if (rateVersion_ == 2) {\n            rate_ = calcRateV2(rateData_, utilization_);\n        } else {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\n        }\n\n        if (rate_ > X16) {\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\n            // this is unlikely to ever happen if configs stay within expected levels.\n            rate_ = X16;\n            // emit event to more easily become aware\n            emit BorrowRateMaxCap();\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e2 precision\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v1 (one kink) ------------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // else utilization is greater than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\n            x1_ = kink1_;\n            x2_ = FOUR_DECIMALS; // 100%\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e4 precision\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v2 (two kinks) -----------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 156 bits => 100-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink1\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\n            if (utilization_ < kink2_) {\n                // if utilization is less than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                x1_ = kink1_;\n                x2_ = kink2_;\n            } else {\n                // else utilization is greater than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\n                x1_ = kink2_;\n                x2_ = FOUR_DECIMALS;\n            }\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\n    function getTotalSupply(\n        uint256 totalAmounts_,\n        uint256 supplyExchangePrice_\n    ) internal pure returns (uint256 totalSupply_) {\n        // totalSupply_ => supplyInterestFree\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\n    function getTotalBorrow(\n        uint256 totalAmounts_,\n        uint256 borrowExchangePrice_\n    ) internal pure returns (uint256 totalBorrow_) {\n        // totalBorrow_ => borrowInterestFree\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n}\n"
    },
    "contracts/libraries/liquiditySlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\nlibrary LiquiditySlotsLink {\n    /// @dev storage slot for status at Liquidity\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\n    /// @dev storage slot for auths mapping at Liquidity\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\n    /// @dev storage slot for guardians mapping at Liquidity\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\n    /// @dev storage slot for user class mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\n    /// @dev storage slot for rateData mapping at Liquidity\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\n    /// @dev storage slot for totalAmounts mapping at Liquidity\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\n    /// @dev storage slot for user supply double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\n    /// @dev storage slot for user borrow double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // ExchangePricesAndConfig\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\n\n    // RateData:\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\n    // RateData: V1\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\n    // RateData: V2\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\n\n    // TotalAmounts\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\n\n    // Configs2\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/safeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\n\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\nlibrary SafeTransfer {\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 20000; // pass max. 20k gas for native transfers\n\n    error FluidSafeTransferError(uint256 errorId_);\n\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from_\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of `token_` to `to_`.\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of ` native token to `to_`.\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\n    function safeTransferNative(address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n}\n"
    },
    "contracts/libraries/storageRead.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice implements a method to read uint256 data from storage at a bytes32 storage slot key.\ncontract StorageRead {\n    function readFromStorage(bytes32 slot_) public view returns (uint256 result_) {\n        assembly {\n            result_ := sload(slot_) // read value from the storage slot\n        }\n    }\n}\n"
    },
    "contracts/libraries/tickMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that calculates number \"tick\" and \"ratioX96\" from this: ratioX96 = (1.0015^tick) * 2^96\n/// @notice this library is used in Fluid Vault protocol for optimiziation.\n/// @dev \"tick\" supports between -32767 and 32767. \"ratioX96\" supports between 37075072 and 169307877264527972847801929085841449095838922544595\nlibrary TickMath {\n    /// The minimum tick that can be passed in getRatioAtTick. 1.0015**-32767\n    int24 internal constant MIN_TICK = -32767;\n    /// The maximum tick that can be passed in getRatioAtTick. 1.0015**32767\n    int24 internal constant MAX_TICK = 32767;\n\n    uint256 internal constant FACTOR00 = 0x100000000000000000000000000000000;\n    uint256 internal constant FACTOR01 = 0xff9dd7de423466c20352b1246ce4856f; // 2^128/1.0015**1 = 339772707859149738855091969477551883631\n    uint256 internal constant FACTOR02 = 0xff3bd55f4488ad277531fa1c725a66d0; // 2^128/1.0015**2 = 339263812140938331358054887146831636176\n    uint256 internal constant FACTOR03 = 0xfe78410fd6498b73cb96a6917f853259; // 2^128/1.0015**4 = 338248306163758188337119769319392490073\n    uint256 internal constant FACTOR04 = 0xfcf2d9987c9be178ad5bfeffaa123273; // 2^128/1.0015**8 = 336226404141693512316971918999264834163\n    uint256 internal constant FACTOR05 = 0xf9ef02c4529258b057769680fc6601b3; // 2^128/1.0015**16 = 332218786018727629051611634067491389875\n    uint256 internal constant FACTOR06 = 0xf402d288133a85a17784a411f7aba082; // 2^128/1.0015**32 = 324346285652234375371948336458280706178\n    uint256 internal constant FACTOR07 = 0xe895615b5beb6386553757b0352bda90; // 2^128/1.0015**64 = 309156521885964218294057947947195947664\n    uint256 internal constant FACTOR08 = 0xd34f17a00ffa00a8309940a15930391a; // 2^128/1.0015**128 = 280877777739312896540849703637713172762 \n    uint256 internal constant FACTOR09 = 0xae6b7961714e20548d88ea5123f9a0ff; // 2^128/1.0015**256 = 231843708922198649176471782639349113087\n    uint256 internal constant FACTOR10 = 0x76d6461f27082d74e0feed3b388c0ca1; // 2^128/1.0015**512 = 157961477267171621126394973980180876449\n    uint256 internal constant FACTOR11 = 0x372a3bfe0745d8b6b19d985d9a8b85bb; // 2^128/1.0015**1024 = 73326833024599564193373530205717235131\n    uint256 internal constant FACTOR12 = 0x0be32cbee48979763cf7247dd7bb539d; // 2^128/1.0015**2048 = 15801066890623697521348224657638773661\n    uint256 internal constant FACTOR13 = 0x8d4f70c9ff4924dac37612d1e2921e;   // 2^128/1.0015**4096 = 733725103481409245883800626999235102\n    uint256 internal constant FACTOR14 = 0x4e009ae5519380809a02ca7aec77;     // 2^128/1.0015**8192 = 1582075887005588088019997442108535\n    uint256 internal constant FACTOR15 = 0x17c45e641b6e95dee056ff10;         // 2^128/1.0015**16384 = 7355550435635883087458926352\n\n    /// The minimum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MIN_TICK). ~ Equivalent to `(1 << 96) * (1.0015**-32767)`\n    uint256 internal constant MIN_RATIOX96 = 37075072;\n    /// The maximum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MAX_TICK).\n    /// ~ Equivalent to `(1 << 96) * (1.0015**32767)`, rounding etc. leading to minor difference\n    uint256 internal constant MAX_RATIOX96 = 169307877264527972847801929085841449095838922544595;\n\n    uint256 internal constant ZERO_TICK_SCALED_RATIO = 0x1000000000000000000000000; // 1 << 96 // 79228162514264337593543950336\n    uint256 internal constant _1E26 = 1e26;\n\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return ratioX96 ratio = (debt amount/collateral amount)\n    function getRatioAtTick(int tick) internal pure returns (uint256 ratioX96) {\n        assembly {\n            let absTick_ := sub(xor(tick, sar(255, tick)), sar(255, tick))\n\n            if gt(absTick_, MAX_TICK) {\n                revert(0, 0)\n            }\n            let factor_ := FACTOR00\n            if and(absTick_, 0x1) {\n                factor_ := FACTOR01\n            }\n            if and(absTick_, 0x2) {\n                factor_ := shr(128, mul(factor_, FACTOR02))\n            }\n            if and(absTick_, 0x4) {\n                factor_ := shr(128, mul(factor_, FACTOR03))\n            }\n            if and(absTick_, 0x8) {\n                factor_ := shr(128, mul(factor_, FACTOR04))\n            }\n            if and(absTick_, 0x10) {\n                factor_ := shr(128, mul(factor_, FACTOR05))\n            }\n            if and(absTick_, 0x20) {\n                factor_ := shr(128, mul(factor_, FACTOR06))\n            }\n            if and(absTick_, 0x40) {\n                factor_ := shr(128, mul(factor_, FACTOR07))\n            }\n            if and(absTick_, 0x80) {\n                factor_ := shr(128, mul(factor_, FACTOR08))\n            }\n            if and(absTick_, 0x100) {\n                factor_ := shr(128, mul(factor_, FACTOR09))\n            }\n            if and(absTick_, 0x200) {\n                factor_ := shr(128, mul(factor_, FACTOR10))\n            }\n            if and(absTick_, 0x400) {\n                factor_ := shr(128, mul(factor_, FACTOR11))\n            }\n            if and(absTick_, 0x800) {\n                factor_ := shr(128, mul(factor_, FACTOR12))\n            }\n            if and(absTick_, 0x1000) {\n                factor_ := shr(128, mul(factor_, FACTOR13))\n            }\n            if and(absTick_, 0x2000) {\n                factor_ := shr(128, mul(factor_, FACTOR14))\n            }\n            if and(absTick_, 0x4000) {\n                factor_ := shr(128, mul(factor_, FACTOR15))\n            }\n\n            let precision_ := 0\n            if iszero(and(tick, 0x8000000000000000000000000000000000000000000000000000000000000000)) {\n                factor_ := div(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, factor_)\n                // we round up in the division so getTickAtRatio of the output price is always consistent\n                if mod(factor_, 0x100000000) {\n                    precision_ := 1\n                }\n            }\n            ratioX96 := add(shr(32, factor_), precision_)\n        }\n    }\n\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\n    /// @dev Throws if ratioX96 > max ratio || ratioX96 < min ratio\n    /// @param ratioX96 The input ratio; ratio = (debt amount/collateral amount)\n    /// @return tick The output tick for the above formula. Returns in round down form. if tick is 123.23 then 123, if tick is -123.23 then returns -124\n    /// @return perfectRatioX96 perfect ratio for the above tick\n    function getTickAtRatio(uint256 ratioX96) internal pure returns (int tick, uint perfectRatioX96) {\n        assembly {\n            if or(gt(ratioX96, MAX_RATIOX96), lt(ratioX96, MIN_RATIOX96)) {\n                revert(0, 0)\n            }\n\n            let cond := lt(ratioX96, ZERO_TICK_SCALED_RATIO)\n            let factor_\n\n            if iszero(cond) {\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\n                factor_ := div(mul(ratioX96, _1E26), ZERO_TICK_SCALED_RATIO)\n            }\n            if cond {\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\n                factor_ := div(mul(ZERO_TICK_SCALED_RATIO, _1E26), ratioX96)\n            }\n\n            // put in https://www.wolframalpha.com/ whole equation: (1.0015^tick) * 2^96 * 10^26 / 79228162514264337593543950336\n\n            // for tick = 16384\n            // ratioX96 = (1.0015^16384) * 2^96 = 3665252098134783297721995888537077351735\n            // 3665252098134783297721995888537077351735 * 10^26 / 79228162514264337593543950336 =\n            // 4626198540796508716348404308345255985.06131964639489434655721\n            if iszero(lt(factor_, 4626198540796508716348404308345255985)) {\n                tick := or(tick, 0x4000)\n                factor_ := div(mul(factor_, _1E26), 4626198540796508716348404308345255985)\n            }\n            // for tick = 8192\n            // ratioX96 = (1.0015^8192) * 2^96 = 17040868196391020479062776466509865\n            // 17040868196391020479062776466509865 * 10^26 / 79228162514264337593543950336 =\n            // 21508599537851153911767490449162.3037648642153898377655505172\n            if iszero(lt(factor_, 21508599537851153911767490449162)) {\n                tick := or(tick, 0x2000)\n                factor_ := div(mul(factor_, _1E26), 21508599537851153911767490449162)\n            }\n            // for tick = 4096\n            // ratioX96 = (1.0015^4096) * 2^96 = 36743933851015821532611831851150\n            // 36743933851015821532611831851150 * 10^26 / 79228162514264337593543950336 =\n            // 46377364670549310883002866648.9777607649742626173648716941385\n            if iszero(lt(factor_, 46377364670549310883002866649)) {\n                tick := or(tick, 0x1000)\n                factor_ := div(mul(factor_, _1E26), 46377364670549310883002866649)\n            }\n            // for tick = 2048\n            // ratioX96 = (1.0015^2048) * 2^96 = 1706210527034005899209104452335\n            // 1706210527034005899209104452335 * 10^26 / 79228162514264337593543950336 =\n            // 2153540449365864845468344760.06357108484096046743300420319322\n            if iszero(lt(factor_, 2153540449365864845468344760)) {\n                tick := or(tick, 0x800)\n                factor_ := div(mul(factor_, _1E26), 2153540449365864845468344760)\n            }\n            // for tick = 1024\n            // ratioX96 = (1.0015^1024) * 2^96 = 367668226692760093024536487236\n            // 367668226692760093024536487236 * 10^26 / 79228162514264337593543950336 =\n            // 464062544207767844008185024.950588990554136265212906454481127\n            if iszero(lt(factor_, 464062544207767844008185025)) {\n                tick := or(tick, 0x400)\n                factor_ := div(mul(factor_, _1E26), 464062544207767844008185025)\n            }\n            // for tick = 512\n            // ratioX96 = (1.0015^512) * 2^96 = 170674186729409605620119663668\n            // 170674186729409605620119663668 * 10^26 / 79228162514264337593543950336 =\n            // 215421109505955298802281577.031879604792139232258508172947569\n            if iszero(lt(factor_, 215421109505955298802281577)) {\n                tick := or(tick, 0x200)\n                factor_ := div(mul(factor_, _1E26), 215421109505955298802281577)\n            }\n            // for tick = 256\n            // ratioX96 = (1.0015^256) * 2^96 = 116285004205991934861656513301\n            // 116285004205991934861656513301 * 10^26 / 79228162514264337593543950336 =\n            // 146772309890508740607270614.667650899656438875541505058062410\n            if iszero(lt(factor_, 146772309890508740607270615)) {\n                tick := or(tick, 0x100)\n                factor_ := div(mul(factor_, _1E26), 146772309890508740607270615)\n            }\n            // for tick = 128\n            // ratioX96 = (1.0015^128) * 2^96 = 95984619659632141743747099590\n            // 95984619659632141743747099590 * 10^26 / 79228162514264337593543950336 =\n            // 121149622323187099817270416.157248837742741760456796835775887\n            if iszero(lt(factor_, 121149622323187099817270416)) {\n                tick := or(tick, 0x80)\n                factor_ := div(mul(factor_, _1E26), 121149622323187099817270416)\n            }\n            // for tick = 64\n            // ratioX96 = (1.0015^64) * 2^96 = 87204845308406958006717891124\n            // 87204845308406958006717891124 * 10^26 / 79228162514264337593543950336 =\n            // 110067989135437147685980801.568068573422377364214113968609839\n            if iszero(lt(factor_, 110067989135437147685980801)) {\n                tick := or(tick, 0x40)\n                factor_ := div(mul(factor_, _1E26), 110067989135437147685980801)\n            }\n            // for tick = 32\n            // ratioX96 = (1.0015^32) * 2^96 = 83120873769022354029916374475\n            // 83120873769022354029916374475 * 10^26 / 79228162514264337593543950336 =\n            // 104913292358707887270979599.831816586773651266562785765558183\n            if iszero(lt(factor_, 104913292358707887270979600)) {\n                tick := or(tick, 0x20)\n                factor_ := div(mul(factor_, _1E26), 104913292358707887270979600)\n            }\n            // for tick = 16\n            // ratioX96 = (1.0015^16) * 2^96 = 81151180492336368327184716176\n            // 81151180492336368327184716176 * 10^26 / 79228162514264337593543950336 =\n            // 102427189924701091191840927.762844039579442328381455567932128\n            if iszero(lt(factor_, 102427189924701091191840928)) {\n                tick := or(tick, 0x10)\n                factor_ := div(mul(factor_, _1E26), 102427189924701091191840928)\n            }\n            // for tick = 8\n            // ratioX96 = (1.0015^8) * 2^96 = 80183906840906820640659903620\n            // 80183906840906820640659903620 * 10^26 / 79228162514264337593543950336 =\n            // 101206318935480056907421312.890625\n            if iszero(lt(factor_, 101206318935480056907421313)) {\n                tick := or(tick, 0x8)\n                factor_ := div(mul(factor_, _1E26), 101206318935480056907421313)\n            }\n            // for tick = 4\n            // ratioX96 = (1.0015^4) * 2^96 = 79704602139525152702959747603\n            // 79704602139525152702959747603 * 10^26 / 79228162514264337593543950336 =\n            // 100601351350506250000000000\n            if iszero(lt(factor_, 100601351350506250000000000)) {\n                tick := or(tick, 0x4)\n                factor_ := div(mul(factor_, _1E26), 100601351350506250000000000)\n            }\n            // for tick = 2\n            // ratioX96 = (1.0015^2) * 2^96 = 79466025265172787701084167660\n            // 79466025265172787701084167660 * 10^26 / 79228162514264337593543950336 =\n            // 100300225000000000000000000\n            if iszero(lt(factor_, 100300225000000000000000000)) {\n                tick := or(tick, 0x2)\n                factor_ := div(mul(factor_, _1E26), 100300225000000000000000000)\n            }\n            // for tick = 1\n            // ratioX96 = (1.0015^1) * 2^96 = 79347004758035734099934266261\n            // 79347004758035734099934266261 * 10^26 / 79228162514264337593543950336 =\n            // 100150000000000000000000000\n            if iszero(lt(factor_, 100150000000000000000000000)) {\n                tick := or(tick, 0x1)\n                factor_ := div(mul(factor_, _1E26), 100150000000000000000000000)\n            }\n            if iszero(cond) {\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\n                perfectRatioX96 := div(mul(ratioX96, _1E26), factor_)\n            }\n            if cond {\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\n                tick := not(tick)\n                perfectRatioX96 := div(mul(ratioX96, factor_), 100150000000000000000000000)\n            }\n            // perfect ratio should always be <= ratioX96\n            // not sure if it can ever be bigger but better to have extra checks\n            if gt(perfectRatioX96, ratioX96) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "contracts/liquidity/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    /// @notice struct to set borrow rate data for version 1\n    struct RateDataV1Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\n        uint256 kink;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink;\n        ///\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set borrow rate data for version 2\n    struct RateDataV2Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\n        uint256 kink1;\n        ///\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\n        uint256 kink2;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink1;\n        ///\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\n        uint256 rateAtUtilizationKink2;\n        ///\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set token config\n    struct TokenConfig {\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\n        uint256 fee;\n        ///\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\n        uint256 threshold;\n        ///\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\n        uint256 maxUtilization;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/liquidity/interfaces/iLiquidity.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IProxy } from \"../../infiniteProxy/interfaces/iProxy.sol\";\nimport { Structs as AdminModuleStructs } from \"../adminModule/structs.sol\";\n\ninterface IFluidLiquidityAdmin {\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\n    /// @param authsStatus_ array of structs setting allowed status for an address.\n    ///                     status true => add auth, false => remove auth\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\n\n    /// @notice adds/removes guardians. Only callable by Governance.\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\n    ///                         status true => add guardian, false => remove guardian\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\n\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\n    /// @param revenueCollector_  new revenue collector address\n    function updateRevenueCollector(address revenueCollector_) external;\n\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\n    /// @param newStatus_ new status\n    ///        status = 2 -> pause, status = 1 -> resume.\n    function changeStatus(uint256 newStatus_) external;\n\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\n\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\n\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\n    ///         Only callable by Auths.\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\n\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\n    ///         Only callable by Auths.\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\n\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param token_ token address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\n\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\n\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to pause operations for\n    /// @param supplyTokens_  token addresses to pause withdrawals for\n    /// @param borrowTokens_  token addresses to pause borrowings for\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to unpause operations for\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\n    /// @param borrowTokens_  token addresses to unpause borrowings for\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\n    /// @param tokens_  array of tokens to collect revenue for\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\n    function collectRevenue(address[] calldata tokens_) external;\n\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\n    /// @param tokens_ tokens to update exchange prices for\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\n    function updateExchangePrices(\n        address[] calldata tokens_\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\n}\n\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\n    /// @notice Single function which handles supply, withdraw, borrow & payback\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\n    /// @param withdrawTo_ if withdrawal then to which address\n    /// @param borrowTo_ if borrow then to which address\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\n    /// @return memVar3_ updated supplyExchangePrice\n    /// @return memVar4_ updated borrowExchangePrice\n    /// @dev to trigger skipping in / out transfers (gas optimization):\n    /// -  ` callbackData_` MUST be encoded so that \"from\" address is the last 20 bytes in the last 32 bytes slot,\n    ///     also for native token operations where liquidityCallback is not triggered!\n    ///     from address must come at last position if there is more data. I.e. encode like:\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\n    /// -   this \"from\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\n    ///     in the slot before (bytes 32 to 63)\n    /// -   `msg.value` must be 0.\n    /// -   Amounts must be either:\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\n}\n\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\n"
    },
    "contracts/oracle/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Error {\n    error FluidOracleError(uint256 errorId_);\n}\n"
    },
    "contracts/oracle/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |           FluidOracleL2           | \n    |__________________________________*/\n\n    /// @notice thrown when sequencer on a L2 has an outage and grace period has not yet passed.\n    uint256 internal constant FluidOracleL2__SequencerOutage = 60000;\n\n    /***********************************|\n    |     UniV3CheckCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the delta between main price source and check rate source is exceeding the allowed delta\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidPrice = 60001;\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidParams = 60002;\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant UniV3CheckCLRSOracle__ExchangeRateZero = 60003;\n\n    /***********************************|\n    |           FluidOracle             | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid info name is passed into a fluid oracle (e.g. not set or too long)\n    uint256 internal constant FluidOracle__InvalidInfoName = 60010;\n\n    /***********************************|\n    |            sUSDe Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant SUSDeOracle__InvalidParams = 60102;\n\n    /***********************************|\n    |           Pendle Oracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant PendleOracle__InvalidParams = 60201;\n\n    /// @notice thrown when the Pendle market Oracle has not been initialized yet\n    uint256 internal constant PendleOracle__MarketNotInitialized = 60202;\n\n    /// @notice thrown when the Pendle market does not have 18 decimals\n    uint256 internal constant PendleOracle__MarketInvalidDecimals = 60203;\n\n    /// @notice thrown when the Pendle market returns an unexpected price\n    uint256 internal constant PendleOracle__InvalidPrice = 60204;\n\n    /***********************************|\n    |    CLRS2UniV3CheckCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant CLRS2UniV3CheckCLRSOracleL2__ExchangeRateZero = 60301;\n\n    /***********************************|\n    |    Ratio2xFallbackCLRSOracleL2    | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\n    uint256 internal constant Ratio2xFallbackCLRSOracleL2__ExchangeRateZero = 60311;\n\n    /***********************************|\n    |            WeETHsOracle           | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHsOracle__InvalidParams = 60321;\n\n    /***********************************|\n    |          Chainlink Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant ChainlinkOracle__InvalidParams = 61001;\n\n    /***********************************|\n    |          UniswapV3 Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant UniV3Oracle__InvalidParams = 62001;\n\n    /// @notice thrown when constructor is called with invalid ordered seconds agos values\n    uint256 internal constant UniV3Oracle__InvalidSecondsAgos = 62002;\n\n    /// @notice thrown when constructor is called with invalid delta values > 100%\n    uint256 internal constant UniV3Oracle__InvalidDeltas = 62003;\n\n    /***********************************|\n    |            WstETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WstETHOracle__InvalidParams = 63001;\n\n    /***********************************|\n    |           Redstone Oracle         | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant RedstoneOracle__InvalidParams = 64001;\n\n    /***********************************|\n    |          Fallback Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant FallbackOracle__InvalidParams = 65001;\n\n    /***********************************|\n    |       FallbackCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant FallbackCLRSOracle__ExchangeRateZero = 66001;\n\n    /***********************************|\n    |         WstETHCLRSOracle          | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\n    uint256 internal constant WstETHCLRSOracle__ExchangeRateZero = 67001;\n\n    /***********************************|\n    |        CLFallbackUniV3Oracle      | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant CLFallbackUniV3Oracle__ExchangeRateZero = 68001;\n\n    /***********************************|\n    |  WstETHCLRS2UniV3CheckCLRSOracle  | \n    |__________________________________*/\n\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\n    uint256 internal constant WstETHCLRS2UniV3CheckCLRSOracle__ExchangeRateZero = 69001;\n\n    /***********************************|\n    |             WeETh Oracle          | \n    |__________________________________*/\n\n    /// @notice thrown when an invalid parameter is passed to a method\n    uint256 internal constant WeETHOracle__InvalidParams = 70001;\n}\n"
    },
    "contracts/oracle/fluidOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"./interfaces/iFluidOracle.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { Error as OracleError } from \"./error.sol\";\n\n/// @title   FluidOracle\n/// @notice  Base contract that any Fluid Oracle must implement\nabstract contract FluidOracle is IFluidOracle, OracleError {\n    /// @dev short helper string to easily identify the oracle. E.g. token symbols\n    //\n    // using a bytes32 because string can not be immutable.\n    bytes32 private immutable _infoName;\n\n    constructor(string memory infoName_) {\n        if (bytes(infoName_).length > 32 || bytes(infoName_).length == 0) {\n            revert FluidOracleError(ErrorTypes.FluidOracle__InvalidInfoName);\n        }\n\n        // convert string to bytes32\n        bytes32 infoNameBytes32_;\n        assembly {\n            infoNameBytes32_ := mload(add(infoName_, 32))\n        }\n        _infoName = infoNameBytes32_;\n    }\n\n    /// @inheritdoc IFluidOracle\n    function infoName() external view returns (string memory) {\n        // convert bytes32 to string\n        uint256 length_;\n        while (length_ < 32 && _infoName[length_] != 0) {\n            length_++;\n        }\n        bytes memory infoNameBytes_ = new bytes(length_);\n        for (uint256 i; i < length_; i++) {\n            infoNameBytes_[i] = _infoName[i];\n        }\n        return string(infoNameBytes_);\n    }\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateOperate() external view virtual returns (uint256 exchangeRate_);\n\n    /// @inheritdoc IFluidOracle\n    function getExchangeRateLiquidate() external view virtual returns (uint256 exchangeRate_);\n}\n"
    },
    "contracts/oracle/interfaces/iFluidOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidOracle {\n    /// @dev Deprecated. Use `getExchangeRateOperate()` and `getExchangeRateLiquidate()` instead. Only implemented for\n    ///      backwards compatibility.\n    function getExchangeRate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for operates\n    function getExchangeRateOperate() external view returns (uint256 exchangeRate_);\n\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for liquidations\n    function getExchangeRateLiquidate() external view returns (uint256 exchangeRate_);\n\n    /// @notice helper string to easily identify the oracle. E.g. token symbols\n    function infoName() external view returns (string memory);\n}\n"
    },
    "contracts/protocols/dex/interfaces/iDexT1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidDexT1 {\n    error FluidDexError(uint256 errorId);\n\n    /// @notice used to simulate swap to find the output amount\n    error FluidDexSwapResult(uint256 amountOut);\n\n    error FluidDexPerfectLiquidityOutput(uint256 token0Amt, uint token1Amt);\n\n    error FluidDexSingleTokenOutput(uint256 tokenAmt);\n\n    error FluidDexLiquidityOutput(uint256 shares);\n\n    error FluidDexPricesAndExchangeRates(PricesAndExchangePrice pex_);\n\n    /// @notice returns the dex id\n    function DEX_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndOracle;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n    struct ConstantViews2 {\n        uint token0NumeratorPrecision;\n        uint token0DenominatorPrecision;\n        uint token1NumeratorPrecision;\n        uint token1DenominatorPrecision;\n    }\n\n    struct PricesAndExchangePrice {\n        uint lastStoredPrice; // last stored price in 1e27 decimals\n        uint centerPrice; // last stored price in 1e27 decimals\n        uint upperRange; // price at upper range in 1e27 decimals\n        uint lowerRange; // price at lower range in 1e27 decimals\n        uint geometricMean; // geometric mean of upper range & lower range in 1e27 decimals\n        uint supplyToken0ExchangePrice;\n        uint borrowToken0ExchangePrice;\n        uint supplyToken1ExchangePrice;\n        uint borrowToken1ExchangePrice;\n    }\n\n    struct CollateralReserves {\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    struct DebtReserves {\n        uint token0Debt;\n        uint token1Debt;\n        uint token0RealReserves;\n        uint token1RealReserves;\n        uint token0ImaginaryReserves;\n        uint token1ImaginaryReserves;\n    }\n\n    function getCollateralReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0SupplyExchangePrice_,\n        uint token1SupplyExchangePrice_\n    ) external view returns (CollateralReserves memory c_);\n\n    function getDebtReserves(\n        uint geometricMean_,\n        uint upperRange_,\n        uint lowerRange_,\n        uint token0BorrowExchangePrice_,\n        uint token1BorrowExchangePrice_\n    ) external view returns (DebtReserves memory d_);\n\n    // reverts with FluidDexPricesAndExchangeRates(pex_);\n    function getPricesAndExchangePrices() external;\n\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    function constantsView2() external view returns (ConstantViews2 memory constantsView2_);\n\n    struct Oracle {\n        uint twap1by0; // TWAP price\n        uint lowestPrice1by0; // lowest price point\n        uint highestPrice1by0; // highest price point\n        uint twap0by1; // TWAP price\n        uint lowestPrice0by1; // lowest price point\n        uint highestPrice0by1; // highest price point\n    }\n\n    /// @dev This function allows users to swap a specific amount of input tokens for output tokens\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountIn_ The exact amount of input tokens to swap\n    /// @param amountOutMin_ The minimum amount of output tokens the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountOut_\n    /// @return amountOut_ The amount of output tokens received from the swap\n    function swapIn(\n        bool swap0to1_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address to_\n    ) external payable returns (uint256 amountOut_);\n\n    /// @dev Swap tokens with perfect amount out\n    /// @param swap0to1_ Direction of swap. If true, swaps token0 for token1; if false, swaps token1 for token0\n    /// @param amountOut_ The exact amount of tokens to receive after swap\n    /// @param amountInMax_ Maximum amount of tokens to swap in\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with amountIn_\n    /// @return amountIn_ The amount of input tokens used for the swap\n    function swapOut(\n        bool swap0to1_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address to_\n    ) external payable returns (uint256 amountIn_);\n\n    /// @dev Deposit tokens in equal proportion to the current pool ratio\n    /// @param shares_ The number of shares to mint\n    /// @param maxToken0Deposit_ Maximum amount of token0 to deposit\n    /// @param maxToken1Deposit_ Maximum amount of token1 to deposit\n    /// @param estimate_ If true, function will revert with estimated deposit amounts without executing the deposit\n    /// @return token0Amt_ Amount of token0 deposited\n    /// @return token1Amt_ Amount of token1 deposited\n    function depositPerfect(\n        uint shares_,\n        uint maxToken0Deposit_,\n        uint maxToken1Deposit_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to withdraw a perfect amount of collateral liquidity\n    /// @param shares_ The number of shares to withdraw\n    /// @param minToken0Withdraw_ The minimum amount of token0 the user is willing to accept\n    /// @param minToken1Withdraw_ The minimum amount of token1 the user is willing to accept\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ The amount of token0 withdrawn\n    /// @return token1Amt_ The amount of token1 withdrawn\n    function withdrawPerfect(\n        uint shares_,\n        uint minToken0Withdraw_,\n        uint minToken1Withdraw_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to borrow tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to borrow\n    /// @param minToken0Borrow_ Minimum amount of token0 to borrow\n    /// @param minToken1Borrow_ Minimum amount of token1 to borrow\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with token0Amt_ & token1Amt_\n    /// @return token0Amt_ Amount of token0 borrowed\n    /// @return token1Amt_ Amount of token1 borrowed\n    function borrowPerfect(\n        uint shares_,\n        uint minToken0Borrow_,\n        uint minToken1Borrow_,\n        address to_\n    ) external returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to pay back borrowed tokens in equal proportion to the current debt pool ratio\n    /// @param shares_ The number of shares to pay back\n    /// @param maxToken0Payback_ Maximum amount of token0 to pay back\n    /// @param maxToken1Payback_ Maximum amount of token1 to pay back\n    /// @param estimate_ If true, function will revert with estimated payback amounts without executing the payback\n    /// @return token0Amt_ Amount of token0 paid back\n    /// @return token1Amt_ Amount of token1 paid back\n    function paybackPerfect(\n        uint shares_,\n        uint maxToken0Payback_,\n        uint maxToken1Payback_,\n        bool estimate_\n    ) external payable returns (uint token0Amt_, uint token1Amt_);\n\n    /// @dev This function allows users to deposit tokens in any proportion into the col pool\n    /// @param token0Amt_ The amount of token0 to deposit\n    /// @param token1Amt_ The amount of token1 to deposit\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to receive\n    /// @param estimate_ If true, function will revert with estimated shares without executing the deposit\n    /// @return shares_ The amount of shares minted for the deposit\n    function deposit(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw tokens in any proportion from the col pool\n    /// @param token0Amt_ The amount of token0 to withdraw\n    /// @param token1Amt_ The amount of token1 to withdraw\n    /// @param maxSharesAmt_ The maximum number of shares the user is willing to burn\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The number of shares burned for the withdrawal\n    function withdraw(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to borrow tokens in any proportion from the debt pool\n    /// @param token0Amt_ The amount of token0 to borrow\n    /// @param token1Amt_ The amount of token1 to borrow\n    /// @param maxSharesAmt_ The maximum amount of shares the user is willing to receive\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with shares_\n    /// @return shares_ The amount of borrow shares minted to represent the borrowed amount\n    function borrow(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint maxSharesAmt_,\n        address to_\n    ) external returns (uint shares_);\n\n    /// @dev This function allows users to payback tokens in any proportion to the debt pool\n    /// @param token0Amt_ The amount of token0 to payback\n    /// @param token1Amt_ The amount of token1 to payback\n    /// @param minSharesAmt_ The minimum amount of shares the user expects to burn\n    /// @param estimate_ If true, function will revert with estimated shares without executing the payback\n    /// @return shares_ The amount of borrow shares burned for the payback\n    function payback(\n        uint token0Amt_,\n        uint token1Amt_,\n        uint minSharesAmt_,\n        bool estimate_\n    ) external payable returns (uint shares_);\n\n    /// @dev This function allows users to withdraw their collateral with perfect shares in one token\n    /// @param shares_ The number of shares to burn for withdrawal\n    /// @param minToken0_ The minimum amount of token0 the user expects to receive (set to 0 if withdrawing in token1)\n    /// @param minToken1_ The minimum amount of token1 the user expects to receive (set to 0 if withdrawing in token0)\n    /// @param to_ Recipient of swapped tokens. If to_ == address(0) then out tokens will be sent to msg.sender. If to_ == ADDRESS_DEAD then function will revert with withdrawAmt_\n    /// @return withdrawAmt_ The amount of tokens withdrawn in the chosen token\n    function withdrawPerfectInOneToken(\n        uint shares_,\n        uint minToken0_,\n        uint minToken1_,\n        address to_\n    ) external returns (\n        uint withdrawAmt_\n    );\n\n    /// @dev This function allows users to payback their debt with perfect shares in one token\n    /// @param shares_ The number of shares to burn for payback\n    /// @param maxToken0_ The maximum amount of token0 the user is willing to pay (set to 0 if paying back in token1)\n    /// @param maxToken1_ The maximum amount of token1 the user is willing to pay (set to 0 if paying back in token0)\n    /// @param estimate_ If true, the function will revert with the estimated payback amount without executing the payback\n    /// @return paybackAmt_ The amount of tokens paid back in the chosen token\n    function paybackPerfectInOneToken(\n        uint shares_,\n        uint maxToken0_,\n        uint maxToken1_,\n        bool estimate_\n    ) external payable returns (\n        uint paybackAmt_\n    );\n\n    /// @dev the oracle assumes last set price of pool till the next swap happens.\n    /// There's a possibility that during that time some interest is generated hence the last stored price is not the 100% correct price for the whole duration\n    /// but the difference due to interest will be super low so this difference is ignored\n    /// For example 2 swaps happened 10min (600 seconds) apart and 1 token has 10% higher interest than other.\n    /// then that token will accrue about 10% * 600 / secondsInAYear = ~0.0002%\n    /// @param secondsAgos_ array of seconds ago for which TWAP is needed. If user sends [10, 30, 60] then twaps_ will return [10-0, 30-10, 60-30]\n    /// @return twaps_ twap price, lowest price (aka minima) & highest price (aka maxima) between secondsAgo checkpoints\n    /// @return currentPrice_ price of pool after the most recent swap\n    function oraclePrice(\n        uint[] memory secondsAgos_\n    ) external view returns (\n        Oracle[] memory twaps_,\n        uint currentPrice_\n    );\n}\n"
    },
    "contracts/protocols/vault/borrowRewards/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Events {\n    /// @notice Emitted when magnifier is updated\n    event LogUpdateMagnifier(address indexed vault, uint256 newMagnifier);\n\n    /// @notice Emitted when rewards are started\n    event LogRewardsStarted(uint256 startTime, uint256 endTime);\n\n    /// @notice Emitted when next rewards are set\n    event LogNextRewardsQueued(uint256 rewardsAmount, uint256 duration);\n}\n"
    },
    "contracts/protocols/vault/borrowRewards/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidVaultT1Admin } from \"../vaultT1/adminModule/main.sol\";\nimport { IFluidVaultT1 } from \"../interfaces/iVaultT1.sol\";\nimport { IFluidReserveContract } from \"../../../reserve/interfaces/iReserveContract.sol\";\nimport { LiquiditySlotsLink } from \"../../../libraries/liquiditySlotsLink.sol\";\nimport { Events } from \"./events.sol\";\nimport { Variables } from \"./variables.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\n\n/// @title VaultRewards\n/// @notice This contract is designed to adjust the borrow rate magnifier for a vault based on the current debt borrow & borrow rate.\n/// The adjustment aims to dynamically scale the rewards given to lenders as the TVL in the vault changes\n///\n/// The magnifier is adjusted based on a regular most used reward type where rewardRate = totalRewardsAnnually / totalborrow.\n/// Reward rate is applied by adjusting the borrow magnifier on vault.\n/// Adjustments are made via the rebalance function, which is restricted to be called by designated rebalancers only.\ncontract FluidVaultBorrowRewards is Variables, Events, Error {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidVaultError(ErrorTypes.VaultBorrowRewards__AddressZero);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract)\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidVaultError(ErrorTypes.VaultBorrowRewards__Unauthorized);\n        }\n        _;\n    }\n\n    /// @notice Constructs the FluidVaultBorrowRewards contract.\n    /// @param reserveContract_ The address of the reserve contract where rebalancers are defined.\n    /// @param vault_ The vault to which this contract will apply new magnifier parameter.\n    /// @param liquidity_ Fluid liquidity address\n    /// @param rewardsAmt_ Amounts of rewards to distribute\n    /// @param duration_ rewards duration\n    /// @param initiator_ address that can start rewards with `start()`\n    /// @param debtToken_ vault debt token address\n    /// @param governance_ governance address\n    constructor(\n        IFluidReserveContract reserveContract_,\n        IFluidVaultT1 vault_,\n        IFluidLiquidity liquidity_,\n        uint256 rewardsAmt_,\n        uint256 duration_,\n        address initiator_,\n        address debtToken_,\n        address governance_\n    )\n        validAddress(address(reserveContract_))\n        validAddress(address(liquidity_))\n        validAddress(address(vault_))\n        validAddress(initiator_)\n        validAddress(address(debtToken_))\n        validAddress(governance_)\n    {\n        if (rewardsAmt_ == 0 || duration_ == 0) {\n            revert FluidVaultError(ErrorTypes.VaultBorrowRewards__InvalidParams);\n        }\n        RESERVE_CONTRACT = reserveContract_;\n        VAULT = vault_;\n        rewardsAmount = uint128(rewardsAmt_);\n        rewardsAmountPerYear = (rewardsAmt_ * SECONDS_PER_YEAR) / duration_;\n        duration = uint40(duration_);\n        INITIATOR = initiator_;\n        LIQUIDITY = liquidity_;\n        VAULT_DEBT_TOKEN = debtToken_;\n        GOVERNANCE = governance_;\n\n        LIQUIDITY_TOTAL_AMOUNTS_DEBT_TOKEN_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT,\n            debtToken_\n        );\n        LIQUIDITY_EXCHANGE_PRICE_DEBT_TOKEN_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            debtToken_\n        );\n    }\n\n    /// @notice Rebalances the borrow rate magnifier based on the current debt borrow.\n    /// Can only be called by an authorized rebalancer.\n    function rebalance() external onlyRebalancer {\n        (uint256 newMagnifier_, bool ended_) = calculateBorrowMagnifier();\n        if (ended_ && newMagnifier_ == FOUR_DECIMALS) {\n            if (nextDuration == 0 || nextRewardsAmount == 0) {\n                ended = true;\n            } else {\n                rewardsAmount = nextRewardsAmount;\n                rewardsAmountPerYear = (nextRewardsAmount * SECONDS_PER_YEAR) / nextDuration;\n                duration = nextDuration;\n                nextRewardsAmount = 0;\n                nextDuration = 0;\n                startTime = uint40(block.timestamp);\n                endTime = uint40(block.timestamp + duration);\n                (newMagnifier_, ended_) = calculateBorrowMagnifier();\n            }\n        }\n        if (newMagnifier_ == currentBorrowMagnifier()) {\n            if (ended_) {\n                return;\n            }\n            revert FluidVaultError(ErrorTypes.VaultBorrowRewards__NewMagnifierSameAsOldMagnifier);\n        }\n\n        FluidVaultT1Admin(address(VAULT)).updateBorrowRateMagnifier(newMagnifier_);\n        emit LogUpdateMagnifier(address(VAULT), newMagnifier_);\n    }\n\n    /// @notice Calculates the new borrow rate magnifier based on the current debt borrow (`vaultTVL()`).\n    /// @return magnifier_ The calculated magnifier value.\n    function calculateBorrowMagnifier() public view returns (uint256 magnifier_, bool ended_) {\n        uint256 currentTVL_ = vaultBorrowTVL();\n        uint256 startTime_ = uint256(startTime);\n        uint256 endTime_ = uint256(endTime);\n\n        if (startTime_ == 0 || endTime_ == 0 || ended) {\n            revert FluidVaultError(ErrorTypes.VaultBorrowRewards__RewardsNotStartedOrEnded);\n        }\n\n        if (block.timestamp > endTime_) {\n            return (FOUR_DECIMALS, true);\n        }\n\n        uint borrowRate_ = getBorrowRate();\n        uint rewardsRate_ = (rewardsAmountPerYear * FOUR_DECIMALS) / currentTVL_;\n\n        if (borrowRate_ > 0) {\n            uint256 rewardsDelta_ = (rewardsRate_ * FOUR_DECIMALS) / borrowRate_;\n            magnifier_ = (rewardsDelta_ < FOUR_DECIMALS) ? FOUR_DECIMALS - rewardsDelta_ : 0;\n        } else {\n            magnifier_ = FOUR_DECIMALS;\n        }\n    }\n\n    /// @notice returns the currently configured borrow magnifier at the `VAULT`.\n    function currentBorrowMagnifier() public view returns (uint256) {\n        // read borrow rate magnifier from Vault `vaultVariables2` located in storage slot 1, first 16 bits\n        return (VAULT.readFromStorage(bytes32(uint256(1))) >> 16) & X16;\n    }\n\n    /// @notice returns the current total value locked as debt (TVL) in the `VAULT`.\n    function vaultBorrowTVL() public view returns (uint256 tvl_) {\n        // read total borrow raw in vault from storage slot 0 `vaultVariables`, 64 bits 146-209\n        tvl_ = (VAULT.readFromStorage(bytes32(0)) >> 146) & 0xFFFFFFFFFFFFFFFF;\n\n        // Converting bignumber into normal number\n        tvl_ = (tvl_ >> 8) << (tvl_ & 0xFF);\n\n        // get updated borrow exchange price, which takes slot 1 `vaultVariables2` as input param\n        (, , , uint256 vaultBorrowExPrice_) = VAULT.updateExchangePrices(VAULT.readFromStorage(bytes32(uint256(1))));\n\n        // converting raw total borrow into normal amount\n        tvl_ = (tvl_ * vaultBorrowExPrice_) / 1e12;\n    }\n\n    /// @notice Returns the current borrow rate from the liquidity contract.\n    /// @return The borrow rate as a uint256.\n    function getBorrowRate() public view returns (uint256) {\n        uint256 exchangePriceAndConfig_ = LIQUIDITY.readFromStorage(LIQUIDITY_EXCHANGE_PRICE_DEBT_TOKEN_SLOT);\n        return exchangePriceAndConfig_ & X16;\n    }\n\n    /// @notice Starts the rewards at the current block timestamp.\n    function start() external {\n        startAt(block.timestamp);\n    }\n\n    /// @notice Starts the rewards at a specified timestamp.\n    /// @param startTime_ The timestamp at which to start the rewards.\n    function startAt(uint256 startTime_) public {\n        if (msg.sender != INITIATOR) {\n            revert FluidVaultError(ErrorTypes.VaultBorrowRewards__NotTheInitiator);\n        }\n        if (startTime > 0 || endTime > 0) {\n            revert FluidVaultError(ErrorTypes.VaultBorrowRewards__AlreadyStarted);\n        }\n        if (startTime_ < block.timestamp || startTime_ > block.timestamp + 2 weeks) {\n            revert FluidVaultError(ErrorTypes.VaultBorrowRewards__InvalidStartTime);\n        }\n        startTime = uint40(startTime_);\n        endTime = uint40(startTime_ + duration);\n        emit LogRewardsStarted(startTime, endTime);\n    }\n\n    /// @notice Queues the next rewards with specified amount and duration.\n    /// @param rewardsAmount_ The amount of rewards to be distributed.\n    /// @param duration_ The duration of the rewards program.\n    /// @dev This function can only be called by the governance address.\n    /// @dev Reverts if the current rewards period has already ended.\n    function queueNextRewards(uint256 rewardsAmount_, uint256 duration_) external {\n        if (msg.sender != GOVERNANCE) {\n            revert FluidVaultError(ErrorTypes.VaultBorrowRewards__NotTheGovernance);\n        }\n        if (rewardsAmount_ == 0 || duration_ == 0) {\n            revert FluidVaultError(ErrorTypes.VaultBorrowRewards__InvalidParams);\n        }\n        if (block.timestamp > endTime || ended) {\n            revert FluidVaultError(ErrorTypes.VaultBorrowRewards__AlreadyEnded);\n        }\n        nextRewardsAmount = uint128(rewardsAmount_);\n        nextDuration = uint40(duration_);\n        emit LogNextRewardsQueued(rewardsAmount_, duration_);\n    }\n}\n"
    },
    "contracts/protocols/vault/borrowRewards/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidReserveContract } from \"../../../reserve/interfaces/iReserveContract.sol\";\nimport { IFluidVaultT1 } from \"../interfaces/iVaultT1.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\n\nabstract contract Constants {\n    IFluidLiquidity public immutable LIQUIDITY;\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n    IFluidVaultT1 public immutable VAULT;\n    address public immutable INITIATOR;\n    address public immutable VAULT_DEBT_TOKEN;\n    address public immutable GOVERNANCE;\n\n    bytes32 internal immutable LIQUIDITY_TOTAL_AMOUNTS_DEBT_TOKEN_SLOT;\n    bytes32 internal immutable LIQUIDITY_EXCHANGE_PRICE_DEBT_TOKEN_SLOT;\n    uint256 internal constant FOUR_DECIMALS = 10000;\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xff;\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n}\n\nabstract contract Variables is Constants {\n    // slot 1\n    bool public ended; // when rewards are ended\n    uint40 public startTime;\n    uint40 public duration;\n    uint40 public endTime;\n    uint40 public nextDuration;\n\n    // slot 2\n    uint128 public rewardsAmount;\n    uint128 public nextRewardsAmount;\n\n    // slot 3\n    uint256 public rewardsAmountPerYear;\n}\n"
    },
    "contracts/protocols/vault/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Error {\n    error FluidVaultError(uint256 errorId_);\n\n    /// @notice used to simulate liquidation to find the maximum liquidatable amounts\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n}\n"
    },
    "contracts/protocols/vault/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |           Vault Factory           | \n    |__________________________________*/\n\n    uint256 internal constant VaultFactory__InvalidOperation = 30001;\n    uint256 internal constant VaultFactory__Unauthorized = 30002;\n    uint256 internal constant VaultFactory__SameTokenNotAllowed = 30003;\n    uint256 internal constant VaultFactory__InvalidParams = 30004;\n    uint256 internal constant VaultFactory__InvalidVault = 30005;\n    uint256 internal constant VaultFactory__InvalidVaultAddress = 30006;\n    uint256 internal constant VaultFactory__OnlyDelegateCallAllowed = 30007;\n\n    /***********************************|\n    |            Vault                  | \n    |__________________________________*/\n\n    /// @notice thrown at reentrancy\n    uint256 internal constant Vault__AlreadyEntered = 31001;\n\n    /// @notice thrown when user sends deposit & borrow amount as 0\n    uint256 internal constant Vault__InvalidOperateAmount = 31002;\n\n    /// @notice thrown when msg.value is not in sync with native token deposit or payback\n    uint256 internal constant Vault__InvalidMsgValueOperate = 31003;\n\n    /// @notice thrown when msg.sender is not the owner of the vault\n    uint256 internal constant Vault__NotAnOwner = 31004;\n\n    /// @notice thrown when user's position does not exist. Sending the wrong index from the frontend\n    uint256 internal constant Vault__TickIsEmpty = 31005;\n\n    /// @notice thrown when the user's position is above CF and the user tries to make it more risky by trying to withdraw or borrow\n    uint256 internal constant Vault__PositionAboveCF = 31006;\n\n    /// @notice thrown when the top tick is not initialized. Happens if the vault is totally new or all the user's left\n    uint256 internal constant Vault__TopTickDoesNotExist = 31007;\n\n    /// @notice thrown when msg.value in liquidate is not in sync payback\n    uint256 internal constant Vault__InvalidMsgValueLiquidate = 31008;\n\n    /// @notice thrown when slippage is more on liquidation than what the liquidator sent\n    uint256 internal constant Vault__ExcessSlippageLiquidation = 31009;\n\n    /// @notice thrown when msg.sender is not the rebalancer/reserve contract\n    uint256 internal constant Vault__NotRebalancer = 31010;\n\n    /// @notice thrown when NFT of one vault interacts with the NFT of other vault\n    uint256 internal constant Vault__NftNotOfThisVault = 31011;\n\n    /// @notice thrown when the token is not initialized on the liquidity contract\n    uint256 internal constant Vault__TokenNotInitialized = 31012;\n\n    /// @notice thrown when admin updates fallback if a non-auth calls vault\n    uint256 internal constant Vault__NotAnAuth = 31013;\n\n    /// @notice thrown in operate when user tries to witdhraw more collateral than deposited\n    uint256 internal constant Vault__ExcessCollateralWithdrawal = 31014;\n\n    /// @notice thrown in operate when user tries to payback more debt than borrowed\n    uint256 internal constant Vault__ExcessDebtPayback = 31015;\n\n    /// @notice thrown when user try to withdrawal more than operate's withdrawal limit\n    uint256 internal constant Vault__WithdrawMoreThanOperateLimit = 31016;\n\n    /// @notice thrown when caller of liquidityCallback is not Liquidity\n    uint256 internal constant Vault__InvalidLiquidityCallbackAddress = 31017;\n\n    /// @notice thrown when reentrancy is not already on\n    uint256 internal constant Vault__NotEntered = 31018;\n\n    /// @notice thrown when someone directly calls operate or secondary implementation contract\n    uint256 internal constant Vault__OnlyDelegateCallAllowed = 31019;\n\n    /// @notice thrown when the safeTransferFrom for a token amount failed\n    uint256 internal constant Vault__TransferFromFailed = 31020;\n\n    /// @notice thrown when exchange price overflows while updating on storage\n    uint256 internal constant Vault__ExchangePriceOverFlow = 31021;\n\n    /// @notice thrown when debt to liquidate amt is sent wrong\n    uint256 internal constant Vault__InvalidLiquidationAmt = 31022;\n\n    /// @notice thrown when user debt or collateral goes above 2**128 or below -2**128\n    uint256 internal constant Vault__UserCollateralDebtExceed = 31023;\n\n    /// @notice thrown if on liquidation branch debt becomes lower than 100\n    uint256 internal constant Vault__BranchDebtTooLow = 31024;\n\n    /// @notice thrown when tick's debt is less than 10000\n    uint256 internal constant Vault__TickDebtTooLow = 31025;\n\n    /// @notice thrown when the received new liquidity exchange price is of unexpected value (< than the old one)\n    uint256 internal constant Vault__LiquidityExchangePriceUnexpected = 31026;\n\n    /// @notice thrown when user's debt is less than 10000\n    uint256 internal constant Vault__UserDebtTooLow = 31027;\n\n    /// @notice thrown when on only payback and only deposit the ratio of position increases\n    uint256 internal constant Vault__InvalidPaybackOrDeposit = 31028;\n\n    /// @notice thrown when liquidation just happens of a single partial or when there's nothing to liquidate\n    uint256 internal constant Vault__InvalidLiquidation = 31029;\n\n    /// @notice thrown when msg.value is sent wrong in rebalance\n    uint256 internal constant Vault__InvalidMsgValueInRebalance = 31030;\n\n    /// @notice thrown when nothing rebalanced\n    uint256 internal constant Vault__NothingToRebalance = 31031;\n\n    /// @notice thrown on unforseen liquidation scenarios. Might never come in use.\n    uint256 internal constant Vault__LiquidationReverts = 31032;\n\n    /// @notice thrown when oracle price is > 1e54\n    uint256 internal constant Vault__InvalidOraclePrice = 31033;\n\n    /// @notice thrown when constants are not set properly via contructor\n    uint256 internal constant Vault__ImproperConstantsSetup = 31034;\n\n    /// @notice thrown when externally calling fetchLatestPosition function\n    uint256 internal constant Vault__FetchLatestPositionFailed = 31035;\n\n    /// @notice thrown when dex callback is not from dex\n    uint256 internal constant Vault__InvalidDexCallbackAddress = 31036;\n\n    /// @notice thrown when dex callback is already set\n    uint256 internal constant Vault__DexFromAddressAlreadySet = 31037;\n\n    /// @notice thrown when an invalid min / max amounts config is passed to rebalance()\n    uint256 internal constant Vault__InvalidMinMaxInRebalance = 31038;\n\n    /***********************************|\n    |              ERC721               | \n    |__________________________________*/\n\n    uint256 internal constant ERC721__InvalidParams = 32001;\n    uint256 internal constant ERC721__Unauthorized = 32002;\n    uint256 internal constant ERC721__InvalidOperation = 32003;\n    uint256 internal constant ERC721__UnsafeRecipient = 32004;\n    uint256 internal constant ERC721__OutOfBoundsIndex = 32005;\n\n    /***********************************|\n    |            Vault Admin            | \n    |__________________________________*/\n\n    /// @notice thrown when admin tries to setup invalid value which are crossing limits\n    uint256 internal constant VaultAdmin__ValueAboveLimit = 33001;\n\n    /// @notice when someone directly calls admin implementation contract\n    uint256 internal constant VaultAdmin__OnlyDelegateCallAllowed = 33002;\n\n    /// @notice thrown when auth sends NFT ID as 0 while collecting dust debt\n    uint256 internal constant VaultAdmin__NftIdShouldBeNonZero = 33003;\n\n    /// @notice thrown when trying to collect dust debt of NFT which is not of this vault\n    uint256 internal constant VaultAdmin__NftNotOfThisVault = 33004;\n\n    /// @notice thrown when dust debt of NFT is 0, meaning nothing to collect\n    uint256 internal constant VaultAdmin__DustDebtIsZero = 33005;\n\n    /// @notice thrown when final debt after liquidation is not 0, meaning position 100% liquidated\n    uint256 internal constant VaultAdmin__FinalDebtShouldBeZero = 33006;\n\n    /// @notice thrown when NFT is not liquidated state\n    uint256 internal constant VaultAdmin__NftNotLiquidated = 33007;\n\n    /// @notice thrown when total absorbed dust debt is 0\n    uint256 internal constant VaultAdmin__AbsorbedDustDebtIsZero = 33008;\n\n    /// @notice thrown when address is set as 0\n    uint256 internal constant VaultAdmin__AddressZeroNotAllowed = 33009;\n\n    /***********************************|\n    |            Vault Rewards          | \n    |__________________________________*/\n\n    uint256 internal constant VaultRewards__Unauthorized = 34001;\n    uint256 internal constant VaultRewards__AddressZero = 34002;\n    uint256 internal constant VaultRewards__InvalidParams = 34003;\n    uint256 internal constant VaultRewards__NewMagnifierSameAsOldMagnifier = 34004;\n    uint256 internal constant VaultRewards__NotTheInitiator = 34005;\n    uint256 internal constant VaultRewards__NotTheGovernance = 34006;\n    uint256 internal constant VaultRewards__AlreadyStarted = 34007;\n    uint256 internal constant VaultRewards__RewardsNotStartedOrEnded = 34008;\n    uint256 internal constant VaultRewards__InvalidStartTime = 34009;\n    uint256 internal constant VaultRewards__AlreadyEnded = 34010;\n\n    /***********************************|\n    |          Vault DEX Types          | \n    |__________________________________*/\n\n    uint256 internal constant VaultDex__InvalidOperateAmount = 35001;\n    uint256 internal constant VaultDex__DebtSharesPaidMoreThanAvailableLiquidation = 35002;\n\n    /***********************************|\n    |        Vault Borrow Rewards       | \n    |__________________________________*/\n\n    uint256 internal constant VaultBorrowRewards__Unauthorized = 36001;\n    uint256 internal constant VaultBorrowRewards__AddressZero = 36002;\n    uint256 internal constant VaultBorrowRewards__InvalidParams = 36003;\n    uint256 internal constant VaultBorrowRewards__NewMagnifierSameAsOldMagnifier = 36004;\n    uint256 internal constant VaultBorrowRewards__NotTheInitiator = 36005;\n    uint256 internal constant VaultBorrowRewards__NotTheGovernance = 36006;\n    uint256 internal constant VaultBorrowRewards__AlreadyStarted = 36007;\n    uint256 internal constant VaultBorrowRewards__RewardsNotStartedOrEnded = 36008;\n    uint256 internal constant VaultBorrowRewards__InvalidStartTime = 36009;\n    uint256 internal constant VaultBorrowRewards__AlreadyEnded = 36010;\n}\n"
    },
    "contracts/protocols/vault/factory/deploymentHelpers/miniDeployer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Owned } from \"solmate/src/auth/Owned.sol\";\n\n/// @title MiniDeployer\n/// @notice A contract that allows deployers to deploy any contract by passing the contract data in bytes\n/// @dev The main objective of this contract is to avoid storing contract addresses in our protocols which requires 160 bits of storage\n///      Instead, we can just store the nonce & deployment of this address to calculate the address realtime using \"AddressCalcs\" library\ncontract MiniDeployer is Owned {\n    /// @notice Thrown when an invalid operation is attempted\n    error MiniDeployer__InvalidOperation();\n\n    /// @notice Emitted when a new contract is deployed\n    event LogContractDeployed(address indexed contractAddress);\n\n    /// @notice Constructor to initialize the contract\n    /// @param owner_ The address of the contract owner\n    constructor(address owner_) Owned(owner_) {}\n\n    /// @notice Internal function to deploy a contract\n    /// @param bytecode_ The bytecode of the contract to deploy\n    /// @return address_ The address of the deployed contract\n    /// @dev Uses inline assembly for efficient deployment\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\n        if (bytecode_.length == 0) {\n            revert MiniDeployer__InvalidOperation();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\n        }\n        if (address_ == address(0)) {\n            revert MiniDeployer__InvalidOperation();\n        }\n    }\n\n    /// @notice Deploys a new contract\n    /// @param contractCode_ The bytecode of the contract to deploy\n    /// @return contractAddress_ The address of the deployed contract\n    /// @dev Decrements the deployer's allowed deployments count if not the owner\n    function deployContract(bytes calldata contractCode_) external onlyOwner returns (address contractAddress_) {\n        contractAddress_ = _deploy(contractCode_);\n\n        emit LogContractDeployed(contractAddress_);\n    }\n}\n"
    },
    "contracts/protocols/vault/factory/deploymentHelpers/SSTORE2Deployer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SSTORE2 } from \"solmate/src/utils/SSTORE2.sol\";\nimport { BytesSliceAndConcat } from \"../../../../libraries/bytesSliceAndConcat.sol\";\n\n/// @notice This contract is open and can be called by any address.\n/// It provides functionality to deploy and read code using SSTORE2.\ncontract SStore2Deployer {\n    /// @dev deploys code and emits an event with the pointer and code hash\n    /// @param code_ code to deploy\n    /// @return pointer_ pointer to the deployed code\n    function deployCode(bytes memory code_) external returns (address pointer_) {\n        pointer_ = SSTORE2.write(code_);\n        emit LogCodeDeployed(pointer_, keccak256(code_));\n    }\n\n    /// @dev deploys code and emits an event with the pointer and code hash\n    /// @param code_ code to deploy\n    /// @return pointer1_ pointer to the first part of the deployed code\n    /// @return pointer2_ pointer to the second part of the deployed code\n    function deployCodeSplit(bytes memory code_) external returns (address pointer1_, address pointer2_) {\n        // split storing creation code into two SSTORE2 pointers, because:\n        // due to contract code limits 24576 bytes is the maximum amount of data that can be written in a single pointer / key.\n        // Attempting to write more will result in failure.\n        // So by splitting in two parts we can make sure that the contract bytecode size can use up the full limit of 24576 bytes.\n        bytes memory code1_ = BytesSliceAndConcat.bytesSlice(code_, 0, code_.length / 2);\n        // slice lengths:\n        // when even length, e.g. 250:\n        //      part 1 = 0 -> 250 / 2, so 0 until 125 length, so 0 -> 125\n        //      part 2 = 250 / 2 -> 250 - 250 / 2, so 125 until 125 length, so 125 -> 250\n        // when odd length: e.g. 251:\n        //      part 1 = 0 -> 251 / 2, so 0 until 125 length, so 0 -> 125\n        //      part 2 = 251 / 2 -> 251 - 251 / 2, so 125 until 126 length, so 125 -> 251\n        bytes memory code2_ = BytesSliceAndConcat.bytesSlice(code_, code_.length / 2, code_.length - code_.length / 2);\n        pointer1_ = SSTORE2.write(code1_);\n        pointer2_ = SSTORE2.write(code2_);\n        emit LogCodeDeployedSplit(pointer1_, pointer2_, keccak256(code_));\n    }\n\n    /// @dev reads code from a pointer\n    /// @param pointer_ pointer to the code\n    /// @return code_ code\n    function readCode(address pointer_) external view returns (bytes memory code_) {\n        code_ = SSTORE2.read(pointer_);\n    }\n\n    function readCodeSplit(address pointer1_, address pointer2_) external view returns (bytes memory code_) {\n        code_ = BytesSliceAndConcat.bytesConcat(SSTORE2.read(pointer1_), SSTORE2.read(pointer2_));\n    }\n\n    event LogCodeDeployed(address pointer_, bytes32 codeHash_);\n    event LogCodeDeployedSplit(address pointer1_, address pointer2_, bytes32 codeHash_);\n}\n"
    },
    "contracts/protocols/vault/factory/deploymentLogics/vaultT1Logic_not_for_prod.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SSTORE2 } from \"solmate/src/utils/SSTORE2.sol\";\nimport { MiniDeployer } from \"../deploymentHelpers/miniDeployer.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { IFluidVaultFactory } from \"../../interfaces/iVaultFactory.sol\";\n\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\n\nimport { IFluidVaultT1_Not_For_Prod } from \"../../interfaces/iVaultT1_not_for_prod.sol\";\n\nimport { IFluidContractFactory } from \"../../../../deployer/interface.sol\";\n\nimport { FluidProtocolTypes } from \"../../../../libraries/fluidProtocolTypes.sol\";\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ncontract FluidVaultT1DeploymentLogic_Not_For_Prod is Error {\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice address of liquidity contract\n    address public immutable LIQUIDITY;\n\n    address public immutable DEX_FACTORY;\n\n    address public immutable DEPLOYER;\n\n    /// @notice address of MiniDeployer Contract\n    MiniDeployer public immutable MINI_DEPLOYER;\n\n    /// @notice address of Admin implementation\n    address public immutable ADMIN_IMPLEMENTATION;\n\n    /// @notice address of Secondary implementation\n    address public immutable SECONDARY_IMPLEMENTATION;\n\n    address public immutable VAULT_T1_CREATIONCODE_MAIN_OPERATE;\n\n    address public immutable VAULT_T1_CREATIONCODE_MAIN;\n\n    /// @notice address of this contract\n    address public immutable ADDRESS_THIS;\n\n    /// @notice Emitted when a new vaultT1 is deployed.\n    /// @param vault The address of the newly deployed vault.\n    /// @param vaultId The id of the newly deployed vault.\n    /// @param supplyToken The address of the supply token.\n    /// @param borrowToken The address of the borrow token.\n    event VaultT1Deployed(\n        address indexed vault,\n        uint256 vaultId,\n        address indexed supplyToken,\n        address indexed borrowToken\n    );\n\n    /// @dev each vault type has different vaultAdminImplementation but same vaultSecondaryImplementatio\n    constructor(\n        address liquidity_,\n        address vaultFactory_,\n        address dexFactory_,\n        address deployer_,\n        address vaultAdminImplementation_,\n        address vaultSecondaryImplementation_,\n        address vaultOperateImplementation_,\n        address vaultMainImplementation_\n    ) {\n        LIQUIDITY = liquidity_;\n        DEX_FACTORY = dexFactory_;\n        DEPLOYER = deployer_;\n        ADMIN_IMPLEMENTATION = vaultAdminImplementation_;\n        SECONDARY_IMPLEMENTATION = vaultSecondaryImplementation_;\n\n        // Deploy mini deployer\n        MINI_DEPLOYER = new MiniDeployer(vaultFactory_);\n\n        VAULT_T1_CREATIONCODE_MAIN_OPERATE = vaultOperateImplementation_;\n\n        VAULT_T1_CREATIONCODE_MAIN = vaultMainImplementation_;\n\n        ADDRESS_THIS = address(this);\n    }\n\n    /// @notice                         Computes vaultT1 bytecode for the given supply token (`supplyToken_`) and borrow token (`borrowToken_`).\n    ///                                 This will be called by the VaultFactory via .delegateCall\n    /// @param supplyToken_             The address of the supply token.\n    /// @param borrowToken_             The address of the borrow token.\n    /// @return vaultCreationBytecode_  Returns the bytecode of the new vault to deploy.\n    function vaultT1(\n        address supplyToken_,\n        address borrowToken_\n    ) external returns (bytes memory vaultCreationBytecode_) {\n        if (address(this) == ADDRESS_THIS) revert FluidVaultError(ErrorTypes.VaultFactory__OnlyDelegateCallAllowed);\n\n        if (supplyToken_ == borrowToken_) revert FluidVaultError(ErrorTypes.VaultFactory__SameTokenNotAllowed);\n\n        IFluidVaultT1_Not_For_Prod.ConstantViews memory constants_;\n        constants_.liquidity = LIQUIDITY;\n        constants_.factory = address(this);\n        constants_.deployer = DEPLOYER;\n        constants_.adminImplementation = ADMIN_IMPLEMENTATION;\n        constants_.secondaryImplementation = SECONDARY_IMPLEMENTATION;\n        constants_.supply = LIQUIDITY;\n        constants_.supplyToken.token0 = supplyToken_;\n        constants_.borrow = LIQUIDITY;\n        constants_.borrowToken.token0 = borrowToken_;\n        constants_.vaultId = IFluidVaultFactory(address(this)).totalVaults();\n        constants_.vaultType = FluidProtocolTypes.VAULT_T1_TYPE;\n\n        address vault_ = IFluidVaultFactory(address(this)).getVaultAddress(constants_.vaultId);\n\n        constants_ = _calculateLiquidityVaultSlots(constants_, vault_);\n        vaultCreationBytecode_ = abi.encodePacked(\n            SSTORE2.read(VAULT_T1_CREATIONCODE_MAIN_OPERATE),\n            abi.encode(constants_)\n        );\n\n        address operateImplementation_ = MINI_DEPLOYER.deployContract(vaultCreationBytecode_);\n\n        constants_.operateImplementation = operateImplementation_;\n\n        vaultCreationBytecode_ = abi.encodePacked(SSTORE2.read(VAULT_T1_CREATIONCODE_MAIN), abi.encode(constants_));\n\n        emit VaultT1Deployed(vault_, constants_.vaultId, supplyToken_, borrowToken_);\n\n        return vaultCreationBytecode_;\n    }\n\n    /// @dev                            Calculates the liquidity vault slots for the given supply token, borrow token, and vault (`vault_`).\n    /// @param constants_               Constants struct as used in Vault T1\n    /// @param vault_                   The address of the vault.\n    /// @return liquidityVaultSlots_    Returns the calculated liquidity vault slots set in the `IFluidVaultT1.ConstantViews` struct.\n    function _calculateLiquidityVaultSlots(\n        IFluidVaultT1_Not_For_Prod.ConstantViews memory constants_,\n        address vault_\n    ) private pure returns (IFluidVaultT1_Not_For_Prod.ConstantViews memory) {\n        constants_.supplyExchangePriceSlot = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            constants_.supplyToken.token0\n        );\n        constants_.borrowExchangePriceSlot = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            constants_.borrowToken.token0\n        );\n        constants_.userSupplySlot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n            vault_,\n            constants_.supplyToken.token0\n        );\n        constants_.userBorrowSlot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n            vault_,\n            constants_.borrowToken.token0\n        );\n        return constants_;\n    }\n}\n"
    },
    "contracts/protocols/vault/factory/deploymentLogics/vaultT1Logic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SSTORE2 } from \"solmate/src/utils/SSTORE2.sol\";\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { IFluidVaultFactory } from \"../../interfaces/iVaultFactory.sol\";\n\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\n\nimport { IFluidVaultT1 } from \"../../interfaces/iVaultT1.sol\";\nimport { FluidVaultT1 } from \"../../vaultT1/coreModule/main.sol\";\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ncontract FluidVaultT1DeploymentLogic is Error {\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev SSTORE2 pointer for the VaultT1 creation code. Stored externally to reduce factory bytecode (in 2 parts)\n    address internal immutable VAULT_T1_CREATIONCODE_ADDRESS_1;\n    address internal immutable VAULT_T1_CREATIONCODE_ADDRESS_2;\n\n    /// @notice address of liquidity contract\n    address public immutable LIQUIDITY;\n\n    /// @notice address of Admin implementation\n    address public immutable ADMIN_IMPLEMENTATION;\n\n    /// @notice address of Secondary implementation\n    address public immutable SECONDARY_IMPLEMENTATION;\n\n    /// @notice address of this contract\n    address public immutable ADDRESS_THIS;\n\n    /// @notice Emitted when a new vaultT1 is deployed.\n    /// @param vault The address of the newly deployed vault.\n    /// @param vaultId The id of the newly deployed vault.\n    /// @param supplyToken The address of the supply token.\n    /// @param borrowToken The address of the borrow token.\n    event VaultT1Deployed(\n        address indexed vault,\n        uint256 vaultId,\n        address indexed supplyToken,\n        address indexed borrowToken\n    );\n\n    constructor(address liquidity_, address vaultAdminImplementation_, address vaultSecondaryImplementation_) {\n        LIQUIDITY = liquidity_;\n        ADMIN_IMPLEMENTATION = vaultAdminImplementation_;\n        SECONDARY_IMPLEMENTATION = vaultSecondaryImplementation_;\n\n        // split storing creation code into two SSTORE2 pointers, because:\n        // due to contract code limits 24576 bytes is the maximum amount of data that can be written in a single pointer / key.\n        // Attempting to write more will result in failure.\n        // So by splitting in two parts we can make sure that the contract bytecode size can use up the full limit of 24576 bytes.\n        uint256 creationCodeLength_ = type(FluidVaultT1).creationCode.length;\n        VAULT_T1_CREATIONCODE_ADDRESS_1 = SSTORE2.write(\n            _bytesSlice(type(FluidVaultT1).creationCode, 0, creationCodeLength_ / 2)\n        );\n        // slice lengths:\n        // when even length, e.g. 250:\n        //      part 1 = 0 -> 250 / 2, so 0 until 125 length, so 0 -> 125\n        //      part 2 = 250 / 2 -> 250 - 250 / 2, so 125 until 125 length, so 125 -> 250\n        // when odd length: e.g. 251:\n        //      part 1 = 0 -> 251 / 2, so 0 until 125 length, so 0 -> 125\n        //      part 2 = 251 / 2 -> 251 - 251 / 2, so 125 until 126 length, so 125 -> 251\n        VAULT_T1_CREATIONCODE_ADDRESS_2 = SSTORE2.write(\n            _bytesSlice(\n                type(FluidVaultT1).creationCode,\n                creationCodeLength_ / 2,\n                creationCodeLength_ - creationCodeLength_ / 2\n            )\n        );\n\n        ADDRESS_THIS = address(this);\n    }\n\n    /// @notice                         Computes vaultT1 bytecode for the given supply token (`supplyToken_`) and borrow token (`borrowToken_`).\n    ///                                 This will be called by the VaultFactory via .delegateCall\n    /// @param supplyToken_             The address of the supply token.\n    /// @param borrowToken_             The address of the borrow token.\n    /// @return vaultCreationBytecode_  Returns the bytecode of the new vault to deploy.\n    function vaultT1(\n        address supplyToken_,\n        address borrowToken_\n    ) external returns (bytes memory vaultCreationBytecode_) {\n        if (address(this) == ADDRESS_THIS) revert FluidVaultError(ErrorTypes.VaultFactory__OnlyDelegateCallAllowed);\n\n        if (supplyToken_ == borrowToken_) revert FluidVaultError(ErrorTypes.VaultFactory__SameTokenNotAllowed);\n\n        IFluidVaultT1.ConstantViews memory constants_;\n        constants_.liquidity = LIQUIDITY;\n        constants_.factory = address(this);\n        constants_.adminImplementation = ADMIN_IMPLEMENTATION;\n        constants_.secondaryImplementation = SECONDARY_IMPLEMENTATION;\n        constants_.supplyToken = supplyToken_;\n        constants_.supplyDecimals = supplyToken_ != NATIVE_TOKEN ? IERC20(supplyToken_).decimals() : 18;\n        constants_.borrowToken = borrowToken_;\n        constants_.borrowDecimals = borrowToken_ != NATIVE_TOKEN ? IERC20(borrowToken_).decimals() : 18;\n        constants_.vaultId = IFluidVaultFactory(address(this)).totalVaults();\n\n        address vault_ = IFluidVaultFactory(address(this)).getVaultAddress(constants_.vaultId);\n\n        constants_ = _calculateLiquidityVaultSlots(constants_, vault_);\n\n        vaultCreationBytecode_ = abi.encodePacked(vaultT1CreationBytecode(), abi.encode(constants_));\n\n        emit VaultT1Deployed(vault_, constants_.vaultId, supplyToken_, borrowToken_);\n\n        return vaultCreationBytecode_;\n    }\n\n    /// @notice returns the stored VaultT1 creation bytecode\n    function vaultT1CreationBytecode() public view returns (bytes memory) {\n        return\n            _bytesConcat(SSTORE2.read(VAULT_T1_CREATIONCODE_ADDRESS_1), SSTORE2.read(VAULT_T1_CREATIONCODE_ADDRESS_2));\n    }\n\n    /// @dev                            Calculates the liquidity vault slots for the given supply token, borrow token, and vault (`vault_`).\n    /// @param constants_               Constants struct as used in Vault T1\n    /// @param vault_                   The address of the vault.\n    /// @return liquidityVaultSlots_    Returns the calculated liquidity vault slots set in the `IFluidVaultT1.ConstantViews` struct.\n    function _calculateLiquidityVaultSlots(\n        IFluidVaultT1.ConstantViews memory constants_,\n        address vault_\n    ) private pure returns (IFluidVaultT1.ConstantViews memory) {\n        constants_.liquiditySupplyExchangePriceSlot = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            constants_.supplyToken\n        );\n        constants_.liquidityBorrowExchangePriceSlot = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            constants_.borrowToken\n        );\n        constants_.liquidityUserSupplySlot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n            vault_,\n            constants_.supplyToken\n        );\n        constants_.liquidityUserBorrowSlot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n            vault_,\n            constants_.borrowToken\n        );\n        return constants_;\n    }\n\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function _bytesConcat(bytes memory _preBytes, bytes memory _postBytes) private pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function _bytesSlice(bytes memory _bytes, uint256 _start, uint256 _length) private pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/protocols/vault/factory/deploymentLogics/vaultT2Logic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SSTORE2 } from \"solmate/src/utils/SSTORE2.sol\";\nimport { MiniDeployer } from \"../deploymentHelpers/miniDeployer.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { IFluidVaultFactory } from \"../../interfaces/iVaultFactory.sol\";\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\nimport { DexSlotsLink } from \"../../../../libraries/dexSlotsLink.sol\";\nimport { FluidProtocolTypes } from \"../../../../libraries/fluidProtocolTypes.sol\";\nimport { IFluidVaultT2 } from \"../../interfaces/iVaultT2.sol\";\nimport { IFluidDexT1 } from \"../../../dex/interfaces/iDexT1.sol\";\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ncontract FluidVaultT2DeploymentLogic is Error {\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice address of liquidity contract\n    address public immutable LIQUIDITY;\n\n    address public immutable DEX_FACTORY;\n\n    address public immutable DEPLOYER;\n\n    /// @notice address of MiniDeployer Contract\n    MiniDeployer public immutable MINI_DEPLOYER;\n\n    /// @notice address of Admin implementation\n    address public immutable ADMIN_IMPLEMENTATION;\n\n    /// @notice address of Secondary implementation\n    address public immutable SECONDARY_IMPLEMENTATION;\n\n    address public immutable VAULT_T2_CREATIONCODE_MAIN_OPERATE;\n\n    address public immutable VAULT_T2_CREATIONCODE_MAIN;\n\n    /// @notice address of this contract\n    address public immutable ADDRESS_THIS;\n\n    /// @notice Emitted when a new vaultT2 is deployed.\n    /// @param vault The address of the newly deployed vault.\n    /// @param vaultId The id of the newly deployed vault.\n    /// @param smartCol The address of the dex for which the smart collateral is used.\n    /// @param borrowToken The address of the borrow token.\n    event VaultT2Deployed(\n        address indexed vault,\n        uint256 vaultId,\n        address indexed smartCol,\n        address indexed borrowToken\n    );\n\n    /// @dev each vault type has different vaultAdminImplementation but same vaultSecondaryImplementatio\n    constructor(\n        address liquidity_,\n        address vaultFactory_,\n        address dexFactory_,\n        address deployer_,\n        address vaultAdminImplementation_,\n        address vaultSecondaryImplementation_,\n        address vaultOperateImplementation_,\n        address vaultMainImplementation_\n    ) {\n        LIQUIDITY = liquidity_;\n        DEX_FACTORY = dexFactory_;\n        DEPLOYER = deployer_;\n        ADMIN_IMPLEMENTATION = vaultAdminImplementation_;\n        SECONDARY_IMPLEMENTATION = vaultSecondaryImplementation_;\n\n        // Deploy mini deployer\n        MINI_DEPLOYER = new MiniDeployer(vaultFactory_);\n\n        VAULT_T2_CREATIONCODE_MAIN_OPERATE = vaultOperateImplementation_;\n\n        VAULT_T2_CREATIONCODE_MAIN = vaultMainImplementation_;\n\n        ADDRESS_THIS = address(this);\n    }\n\n    function vaultT2(address smartCol_, address borrowToken_) external returns (bytes memory vaultCreationBytecode_) {\n        if (address(this) == ADDRESS_THIS) revert FluidVaultError(ErrorTypes.VaultFactory__OnlyDelegateCallAllowed);\n\n        // also verifies that dex address is valid\n        IFluidDexT1.ConstantViews memory smartColConstants_ = IFluidDexT1(smartCol_).constantsView();\n\n        // verifying that borrow token is valid\n        if (borrowToken_ != NATIVE_TOKEN) IERC20(borrowToken_).decimals();\n\n        IFluidVaultT2.ConstantViews memory constants_;\n        constants_.liquidity = LIQUIDITY;\n        constants_.factory = address(this);\n        constants_.deployer = DEPLOYER;\n        constants_.adminImplementation = ADMIN_IMPLEMENTATION;\n        constants_.secondaryImplementation = SECONDARY_IMPLEMENTATION;\n        constants_.supply = smartCol_;\n        constants_.supplyToken.token0 = smartColConstants_.token0;\n        constants_.supplyToken.token1 = smartColConstants_.token1;\n        constants_.borrow = LIQUIDITY;\n        constants_.borrowToken.token0 = borrowToken_;\n        // borrowToken.token1 will remain 0\n        constants_.vaultId = IFluidVaultFactory(address(this)).totalVaults();\n        constants_.vaultType = FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE;\n\n        address vault_ = IFluidVaultFactory(address(this)).getVaultAddress(constants_.vaultId);\n\n        constants_ = _calculateVaultSlots(constants_, vault_);\n\n        vaultCreationBytecode_ = abi.encodePacked(\n            SSTORE2.read(VAULT_T2_CREATIONCODE_MAIN_OPERATE),\n            abi.encode(constants_)\n        );\n\n        address operateImplementation_ = MINI_DEPLOYER.deployContract(vaultCreationBytecode_);\n\n        constants_.operateImplementation = operateImplementation_;\n\n        vaultCreationBytecode_ = abi.encodePacked(SSTORE2.read(VAULT_T2_CREATIONCODE_MAIN), abi.encode(constants_));\n\n        emit VaultT2Deployed(vault_, constants_.vaultId, smartCol_, borrowToken_);\n\n        return vaultCreationBytecode_;\n    }\n\n    /// @dev Retrieves the creation code for the Operate contract\n    function operateCreationCode() public view returns (bytes memory) {\n        return SSTORE2.read(VAULT_T2_CREATIONCODE_MAIN_OPERATE);\n    }\n\n    /// @dev Retrieves the creation code for the main contract\n    function mainCreationCode() public view returns (bytes memory) {\n        return SSTORE2.read(VAULT_T2_CREATIONCODE_MAIN);\n    }\n\n    function _calculateVaultSlots(\n        IFluidVaultT2.ConstantViews memory constants_,\n        address vault_\n    ) private pure returns (IFluidVaultT2.ConstantViews memory) {\n        constants_.supplyExchangePriceSlot = bytes32(0);\n        constants_.borrowExchangePriceSlot = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            constants_.borrowToken.token0\n        );\n        constants_.userSupplySlot = DexSlotsLink.calculateMappingStorageSlot(\n            DexSlotsLink.DEX_USER_SUPPLY_MAPPING_SLOT,\n            vault_\n        );\n        constants_.userBorrowSlot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n            vault_,\n            constants_.borrowToken.token0\n        );\n        return constants_;\n    }\n}\n"
    },
    "contracts/protocols/vault/factory/deploymentLogics/vaultT3Logic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SSTORE2 } from \"solmate/src/utils/SSTORE2.sol\";\nimport { MiniDeployer } from \"../deploymentHelpers/miniDeployer.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { IFluidVaultFactory } from \"../../interfaces/iVaultFactory.sol\";\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\nimport { DexSlotsLink } from \"../../../../libraries/dexSlotsLink.sol\";\nimport { FluidProtocolTypes } from \"../../../../libraries/fluidProtocolTypes.sol\";\nimport { IFluidVaultT3 } from \"../../interfaces/iVaultT3.sol\";\nimport { IFluidDexT1 } from \"../../../dex/interfaces/iDexT1.sol\";\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ncontract FluidVaultT3DeploymentLogic is Error {\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice address of liquidity contract\n    address public immutable LIQUIDITY;\n\n    address public immutable DEX_FACTORY;\n\n    address public immutable DEPLOYER;\n\n    /// @notice address of MiniDeployer Contract\n    MiniDeployer public immutable MINI_DEPLOYER;\n\n    /// @notice address of Admin implementation\n    address public immutable ADMIN_IMPLEMENTATION;\n\n    /// @notice address of Secondary implementation\n    address public immutable SECONDARY_IMPLEMENTATION;\n\n    address public immutable VAULT_T3_CREATIONCODE_MAIN_OPERATE;\n\n    address public immutable VAULT_T3_CREATIONCODE_MAIN;\n\n    /// @notice address of this contract\n    address public immutable ADDRESS_THIS;\n\n    /// @notice Emitted when a new vaultT3 is deployed.\n    /// @param vault The address of the newly deployed vault.\n    /// @param vaultId The id of the newly deployed vault.\n    /// @param supplyToken The address of the supply token.\n    /// @param smartDebt The address of the dex for which the smart debt is used.\n    event VaultT3Deployed(\n        address indexed vault,\n        uint256 vaultId,\n        address indexed supplyToken,\n        address indexed smartDebt\n    );\n\n    /// @dev each vault type has different vaultAdminImplementation but same vaultSecondaryImplementatio\n    constructor(\n        address liquidity_,\n        address vaultFactory_,\n        address dexFactory_,\n        address deployer_,\n        address vaultAdminImplementation_,\n        address vaultSecondaryImplementation_,\n        address vaultOperateImplementation_,\n        address vaultMainImplementation_\n    ) {\n        LIQUIDITY = liquidity_;\n        DEX_FACTORY = dexFactory_;\n        DEPLOYER = deployer_;\n        ADMIN_IMPLEMENTATION = vaultAdminImplementation_;\n        SECONDARY_IMPLEMENTATION = vaultSecondaryImplementation_;\n\n        // Deploy mini deployer\n        MINI_DEPLOYER = new MiniDeployer(vaultFactory_);\n\n        VAULT_T3_CREATIONCODE_MAIN_OPERATE = vaultOperateImplementation_;\n\n        VAULT_T3_CREATIONCODE_MAIN = vaultMainImplementation_;\n\n        ADDRESS_THIS = address(this);\n    }\n\n    function vaultT3(address supplyToken_, address smartDebt_) external returns (bytes memory vaultCreationBytecode_) {\n        if (address(this) == ADDRESS_THIS) revert FluidVaultError(ErrorTypes.VaultFactory__OnlyDelegateCallAllowed);\n\n        // verifying that supply token is valid\n        if (supplyToken_ != NATIVE_TOKEN) IERC20(supplyToken_).decimals();\n\n        // also verifies that dex address is valid\n        IFluidDexT1.ConstantViews memory smartDebtConstants_ = IFluidDexT1(smartDebt_).constantsView();\n\n        IFluidVaultT3.ConstantViews memory constants_;\n        constants_.liquidity = LIQUIDITY;\n        constants_.factory = address(this);\n        constants_.deployer = DEPLOYER;\n        constants_.adminImplementation = ADMIN_IMPLEMENTATION;\n        constants_.secondaryImplementation = SECONDARY_IMPLEMENTATION;\n        constants_.supply = LIQUIDITY;\n        constants_.supplyToken.token0 = supplyToken_;\n        // supplyToken.token1 will remain 0\n        constants_.borrow = smartDebt_;\n        constants_.borrowToken.token0 = smartDebtConstants_.token0;\n        constants_.borrowToken.token1 = smartDebtConstants_.token1;\n        constants_.vaultId = IFluidVaultFactory(address(this)).totalVaults();\n        constants_.vaultType = FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE;\n\n        address vault_ = IFluidVaultFactory(address(this)).getVaultAddress(constants_.vaultId);\n\n        constants_ = _calculateVaultSlots(constants_, vault_);\n\n        vaultCreationBytecode_ = abi.encodePacked(\n            SSTORE2.read(VAULT_T3_CREATIONCODE_MAIN_OPERATE),\n            abi.encode(constants_)\n        );\n\n        address operateImplementation_ = MINI_DEPLOYER.deployContract(vaultCreationBytecode_);\n\n        constants_.operateImplementation = operateImplementation_;\n\n        vaultCreationBytecode_ = abi.encodePacked(SSTORE2.read(VAULT_T3_CREATIONCODE_MAIN), abi.encode(constants_));\n\n        emit VaultT3Deployed(vault_, constants_.vaultId, supplyToken_, smartDebt_);\n\n        return vaultCreationBytecode_;\n    }\n\n    /// @dev Retrieves the creation code for the Operate contract\n    function operateCreationCode() public view returns (bytes memory) {\n        return SSTORE2.read(VAULT_T3_CREATIONCODE_MAIN_OPERATE);\n    }\n\n    /// @dev Retrieves the creation code for the main contract\n    function mainCreationCode() public view returns (bytes memory) {\n        return SSTORE2.read(VAULT_T3_CREATIONCODE_MAIN);\n    }\n\n    function _calculateVaultSlots(\n        IFluidVaultT3.ConstantViews memory constants_,\n        address vault_\n    ) private pure returns (IFluidVaultT3.ConstantViews memory) {\n        constants_.supplyExchangePriceSlot = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            constants_.supplyToken.token0\n        );\n        constants_.borrowExchangePriceSlot = bytes32(0);\n        constants_.userSupplySlot = LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n            vault_,\n            constants_.supplyToken.token0\n        );\n        constants_.userBorrowSlot = DexSlotsLink.calculateMappingStorageSlot(\n            DexSlotsLink.DEX_USER_BORROW_MAPPING_SLOT,\n            vault_\n        );\n        return constants_;\n    }\n}\n"
    },
    "contracts/protocols/vault/factory/deploymentLogics/vaultT4Logic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SSTORE2 } from \"solmate/src/utils/SSTORE2.sol\";\nimport { MiniDeployer } from \"../deploymentHelpers/miniDeployer.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { IFluidVaultFactory } from \"../../interfaces/iVaultFactory.sol\";\nimport { DexSlotsLink } from \"../../../../libraries/dexSlotsLink.sol\";\nimport { FluidProtocolTypes } from \"../../../../libraries/fluidProtocolTypes.sol\";\nimport { IFluidVaultT4 } from \"../../interfaces/iVaultT4.sol\";\nimport { IFluidDexT1 } from \"../../../dex/interfaces/iDexT1.sol\";\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ncontract FluidVaultT4DeploymentLogic is Error {\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice address of liquidity contract\n    address public immutable LIQUIDITY;\n\n    address public immutable DEX_FACTORY;\n\n    address public immutable DEPLOYER;\n\n    /// @notice address of MiniDeployer Contract\n    MiniDeployer public immutable MINI_DEPLOYER;\n\n    /// @notice address of Admin implementation\n    address public immutable ADMIN_IMPLEMENTATION;\n\n    /// @notice address of Secondary implementation\n    address public immutable SECONDARY_IMPLEMENTATION;\n\n    address public immutable VAULT_T4_CREATIONCODE_MAIN_OPERATE;\n\n    address public immutable VAULT_T4_CREATIONCODE_MAIN;\n\n    /// @notice address of this contract\n    address public immutable ADDRESS_THIS;\n\n    /// @notice Emitted when a new vaultT4 is deployed.\n    /// @param vault The address of the newly deployed vault.\n    /// @param vaultId The id of the newly deployed vault.\n    /// @param smartCol The address of the dex for which the smart collateral is used.\n    /// @param smartDebt The address of the dex for which the smart debt is used.\n    event VaultT4Deployed(address indexed vault, uint256 vaultId, address indexed smartCol, address indexed smartDebt);\n\n    /// @dev each vault type has different vaultAdminImplementation but same vaultSecondaryImplementatio\n    constructor(\n        address liquidity_,\n        address vaultFactory_,\n        address dexFactory_,\n        address deployer_,\n        address vaultAdminImplementation_,\n        address vaultSecondaryImplementation_,\n        address vaultOperateImplementation_,\n        address vaultMainImplementation_\n    ) {\n        LIQUIDITY = liquidity_;\n        DEX_FACTORY = dexFactory_;\n        DEPLOYER = deployer_;\n        ADMIN_IMPLEMENTATION = vaultAdminImplementation_;\n        SECONDARY_IMPLEMENTATION = vaultSecondaryImplementation_;\n\n        // Deploy mini deployer\n        MINI_DEPLOYER = new MiniDeployer(vaultFactory_);\n\n        VAULT_T4_CREATIONCODE_MAIN_OPERATE = vaultOperateImplementation_;\n\n        VAULT_T4_CREATIONCODE_MAIN = vaultMainImplementation_;\n\n        ADDRESS_THIS = address(this);\n    }\n\n    function vaultT4(address smartCol_, address smartDebt_) external returns (bytes memory vaultCreationBytecode_) {\n        if (address(this) == ADDRESS_THIS) revert FluidVaultError(ErrorTypes.VaultFactory__OnlyDelegateCallAllowed);\n\n        // verifying that dex address are valid\n        IFluidDexT1.ConstantViews memory smartColConstants_ = IFluidDexT1(smartCol_).constantsView();\n        IFluidDexT1.ConstantViews memory smartDebtConstants_ = IFluidDexT1(smartDebt_).constantsView();\n\n        IFluidVaultT4.ConstantViews memory constants_;\n        constants_.liquidity = LIQUIDITY;\n        constants_.factory = address(this);\n        constants_.deployer = DEPLOYER;\n        constants_.adminImplementation = ADMIN_IMPLEMENTATION;\n        constants_.secondaryImplementation = SECONDARY_IMPLEMENTATION;\n        constants_.supply = smartCol_;\n        constants_.supplyToken.token0 = smartColConstants_.token0;\n        constants_.supplyToken.token1 = smartColConstants_.token1;\n        constants_.borrow = smartDebt_;\n        constants_.borrowToken.token0 = smartDebtConstants_.token0;\n        constants_.borrowToken.token1 = smartDebtConstants_.token1;\n        constants_.vaultId = IFluidVaultFactory(address(this)).totalVaults();\n        constants_.vaultType = FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE;\n\n        address vault_ = IFluidVaultFactory(address(this)).getVaultAddress(constants_.vaultId);\n\n        constants_ = _calculateVaultSlots(constants_, vault_);\n\n        vaultCreationBytecode_ = abi.encodePacked(\n            SSTORE2.read(VAULT_T4_CREATIONCODE_MAIN_OPERATE),\n            abi.encode(constants_)\n        );\n\n        address operateImplementation_ = MINI_DEPLOYER.deployContract(vaultCreationBytecode_);\n\n        constants_.operateImplementation = operateImplementation_;\n\n        vaultCreationBytecode_ = abi.encodePacked(SSTORE2.read(VAULT_T4_CREATIONCODE_MAIN), abi.encode(constants_));\n\n        emit VaultT4Deployed(vault_, constants_.vaultId, smartCol_, smartDebt_);\n\n        return vaultCreationBytecode_;\n    }\n\n    /// @dev Retrieves the creation code for the Operate contract\n    function operateCreationCode() public view returns (bytes memory) {\n        return SSTORE2.read(VAULT_T4_CREATIONCODE_MAIN_OPERATE);\n    }\n\n    /// @dev Retrieves the creation code for the main contract\n    function mainCreationCode() public view returns (bytes memory) {\n        return SSTORE2.read(VAULT_T4_CREATIONCODE_MAIN);\n    }\n\n    function _calculateVaultSlots(\n        IFluidVaultT4.ConstantViews memory constants_,\n        address vault_\n    ) private pure returns (IFluidVaultT4.ConstantViews memory) {\n        constants_.supplyExchangePriceSlot = bytes32(0);\n        constants_.borrowExchangePriceSlot = bytes32(0);\n        constants_.userSupplySlot = DexSlotsLink.calculateMappingStorageSlot(\n            DexSlotsLink.DEX_USER_SUPPLY_MAPPING_SLOT,\n            vault_\n        );\n        constants_.userBorrowSlot = DexSlotsLink.calculateMappingStorageSlot(\n            DexSlotsLink.DEX_USER_BORROW_MAPPING_SLOT,\n            vault_\n        );\n        return constants_;\n    }\n}\n"
    },
    "contracts/protocols/vault/factory/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\n\n/// @notice Fluid Vault Factory ERC721 base contract. Implements the ERC721 standard, based on Solmate.\n/// In addition, implements ERC721 Enumerable.\n/// Modern, minimalist, and gas efficient ERC-721 with Enumerable implementation.\n///\n/// @author Instadapp\n/// @author Modified Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 is Error {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    // token id => token config\n    // uint160 0 - 159: address:: owner\n    // uint32 160 - 191: uint32:: index\n    // uint32 192 - 223: uint32:: vaultId\n    // uint32 224 - 255: uint32:: null\n    mapping(uint256 => uint256) internal _tokenConfig;\n\n    // owner => slot => index\n    /*\n    // slot 0: \n    // uint32 0 - 31: uint32:: balanceOf\n    // uint224 32 - 255: 7 tokenIds each of uint32 packed\n    // slot N (N >= 1)\n    // uint32 * 8 each tokenId\n    */\n    mapping(address => mapping(uint256 => uint256)) internal _ownerConfig;\n\n    /// @notice returns `owner_` of NFT with `id_`\n    function ownerOf(uint256 id_) public view virtual returns (address owner_) {\n        if ((owner_ = address(uint160(_tokenConfig[id_]))) == address(0))\n            revert FluidVaultError(ErrorTypes.ERC721__InvalidParams);\n    }\n\n    /// @notice returns total count of NFTs owned by `owner_`\n    function balanceOf(address owner_) public view virtual returns (uint256) {\n        if (owner_ == address(0)) revert FluidVaultError(ErrorTypes.ERC721__InvalidParams);\n\n        return _ownerConfig[owner_][0] & type(uint32).max;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    ERC721Enumerable STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice total amount of tokens stored by the contract.\n    uint256 public totalSupply;\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice trackes if a NFT id is approved for a certain address.\n    mapping(uint256 => address) public getApproved;\n\n    /// @notice trackes if all the NFTs of an owner are approved for a certain other address.\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice approves an NFT with `id_` to be spent (transferred) by `spender_`\n    function approve(address spender_, uint256 id_) public virtual {\n        address owner_ = address(uint160(_tokenConfig[id_]));\n        if (!(msg.sender == owner_ || isApprovedForAll[owner_][msg.sender]))\n            revert FluidVaultError(ErrorTypes.ERC721__Unauthorized);\n\n        getApproved[id_] = spender_;\n\n        emit Approval(owner_, spender_, id_);\n    }\n\n    /// @notice approves all NFTs owned by msg.sender to be spent (transferred) by `operator_`\n    function setApprovalForAll(address operator_, bool approved_) public virtual {\n        isApprovedForAll[msg.sender][operator_] = approved_;\n\n        emit ApprovalForAll(msg.sender, operator_, approved_);\n    }\n\n    /// @notice transfers an NFT with `id_` `from_` address `to_` address without safe check\n    function transferFrom(address from_, address to_, uint256 id_) public virtual {\n        uint256 tokenConfig_ = _tokenConfig[id_];\n        if (from_ != address(uint160(tokenConfig_))) revert FluidVaultError(ErrorTypes.ERC721__InvalidParams);\n\n        if (!(msg.sender == from_ || isApprovedForAll[from_][msg.sender] || msg.sender == getApproved[id_]))\n            revert FluidVaultError(ErrorTypes.ERC721__Unauthorized);\n\n        // call _transfer with vaultId extracted from tokenConfig_\n        _transfer(from_, to_, id_, (tokenConfig_ >> 192) & type(uint32).max);\n\n        delete getApproved[id_];\n\n        emit Transfer(from_, to_, id_);\n    }\n\n    /// @notice transfers an NFT with `id_` `from_` address `to_` address\n    function safeTransferFrom(address from_, address to_, uint256 id_) public virtual {\n        transferFrom(from_, to_, id_);\n\n        if (\n            !(to_.code.length == 0 ||\n                ERC721TokenReceiver(to_).onERC721Received(msg.sender, from_, id_, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector)\n        ) revert FluidVaultError(ErrorTypes.ERC721__UnsafeRecipient);\n    }\n\n    /// @notice transfers an NFT with `id_` `from_` address `to_` address, passing `data_` to `onERC721Received` callback\n    function safeTransferFrom(address from_, address to_, uint256 id_, bytes calldata data_) public virtual {\n        transferFrom(from_, to_, id_);\n\n        if (\n            !((to_.code.length == 0) ||\n                ERC721TokenReceiver(to_).onERC721Received(msg.sender, from_, id_, data_) ==\n                ERC721TokenReceiver.onERC721Received.selector)\n        ) revert FluidVaultError(ErrorTypes.ERC721__UnsafeRecipient);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721Enumerable LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns a token ID at a given `index_` of all the tokens stored by the contract.\n    /// Use along with {totalSupply} to enumerate all tokens.\n    function tokenByIndex(uint256 index_) external view returns (uint256) {\n        if (index_ >= totalSupply) {\n            revert FluidVaultError(ErrorTypes.ERC721__OutOfBoundsIndex);\n        }\n        return index_ + 1;\n    }\n\n    /// @notice Returns a token ID owned by `owner_` at a given `index_` of its token list.\n    /// Use along with {balanceOf} to enumerate all of `owner_`'s tokens.\n    function tokenOfOwnerByIndex(address owner_, uint256 index_) external view returns (uint256) {\n        if (index_ >= balanceOf(owner_)) {\n            revert FluidVaultError(ErrorTypes.ERC721__OutOfBoundsIndex);\n        }\n\n        index_ = index_ + 1;\n        return (_ownerConfig[owner_][index_ / 8] >> ((index_ % 8) * 32)) & type(uint32).max;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId_) public view virtual returns (bool) {\n        return\n            interfaceId_ == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId_ == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId_ == 0x5b5e139f || // ERC165 Interface ID for ERC721Metadata\n            interfaceId_ == 0x780e9d63; // ERC165 Interface ID for ERC721Enumberable\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL TRANSFER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _transfer(address from_, address to_, uint256 id_, uint256 vaultId_) internal {\n        if (to_ == address(0)) {\n            revert FluidVaultError(ErrorTypes.ERC721__InvalidOperation);\n        } else if (from_ == address(0)) {\n            _add(to_, id_, vaultId_);\n        } else if (to_ != from_) {\n            _remove(from_, id_);\n            _add(to_, id_, vaultId_);\n        }\n    }\n\n    function _add(address user_, uint256 id_, uint256 vaultId_) private {\n        uint256 ownerConfig_ = _ownerConfig[user_][0];\n        unchecked {\n            // index starts from `1`\n            uint256 balanceOf_ = (ownerConfig_ & type(uint32).max) + 1;\n\n            _tokenConfig[id_] = (uint160(user_) | (balanceOf_ << 160) | (vaultId_ << 192));\n\n            _ownerConfig[user_][0] = (ownerConfig_ & ~uint256(type(uint32).max)) | (balanceOf_);\n\n            uint256 wordIndex_ = (balanceOf_ / 8);\n            _ownerConfig[user_][wordIndex_] = _ownerConfig[user_][wordIndex_] | (id_ << ((balanceOf_ % 8) * 32));\n        }\n    }\n\n    function _remove(address user_, uint256 id_) private {\n        uint256 temp_ = _tokenConfig[id_];\n\n        // fetching `id_` details and deleting it.\n        uint256 tokenIndex_ = (temp_ >> 160) & type(uint32).max;\n        _tokenConfig[id_] = 0;\n\n        // fetching & updating balance\n        temp_ = _ownerConfig[user_][0];\n        uint256 lastTokenIndex_ = (temp_ & type(uint32).max); // (lastTokenIndex_ = balanceOf)\n        _ownerConfig[user_][0] = (temp_ & ~uint256(type(uint32).max)) | (lastTokenIndex_ - 1);\n\n        {\n            unchecked {\n                uint256 lastTokenWordIndex_ = (lastTokenIndex_ / 8);\n                uint256 lastTokenBitShift_ = (lastTokenIndex_ % 8) * 32;\n                temp_ = _ownerConfig[user_][lastTokenWordIndex_];\n\n                // replace `id_` tokenId with `last` tokenId.\n                if (lastTokenIndex_ != tokenIndex_) {\n                    uint256 wordIndex_ = (tokenIndex_ / 8);\n                    uint256 bitShift_ = (tokenIndex_ % 8) * 32;\n\n                    // temp_ here is _ownerConfig[user_][lastTokenWordIndex_];\n                    uint256 lastTokenId_ = uint256((temp_ >> lastTokenBitShift_) & type(uint32).max);\n                    if (wordIndex_ == lastTokenWordIndex_) {\n                        // this case, when lastToken and currentToken are in same slot.\n                        // updating temp_ as we will remove the lastToken from this slot itself\n                        temp_ = (temp_ & ~(uint256(type(uint32).max) << bitShift_)) | (lastTokenId_ << bitShift_);\n                    } else {\n                        _ownerConfig[user_][wordIndex_] =\n                            (_ownerConfig[user_][wordIndex_] & ~(uint256(type(uint32).max) << bitShift_)) |\n                            (lastTokenId_ << bitShift_);\n                    }\n                    _tokenConfig[lastTokenId_] =\n                        (_tokenConfig[lastTokenId_] & ~(uint256(type(uint32).max) << 160)) |\n                        (tokenIndex_ << 160);\n                }\n\n                // temp_ here is _ownerConfig[user_][lastTokenWordIndex_];\n                _ownerConfig[user_][lastTokenWordIndex_] = temp_ & ~(uint256(type(uint32).max) << lastTokenBitShift_);\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to_, uint256 vaultId_) internal virtual returns (uint256 id_) {\n\n        unchecked {\n            ++totalSupply;\n        }\n\n        id_ = totalSupply;\n        if (id_ >= type(uint32).max || _tokenConfig[id_] != 0) revert FluidVaultError(ErrorTypes.ERC721__InvalidParams);\n\n        _transfer(address(0), to_, id_, vaultId_);\n\n        emit Transfer(address(0), to_, id_);\n    }\n}\n\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(address, address, uint256, bytes calldata) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/protocols/vault/factory/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Owned } from \"solmate/src/auth/Owned.sol\";\nimport { ERC721 } from \"./ERC721/ERC721.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\n\nimport { StorageRead } from \"../../../libraries/storageRead.sol\";\n\nabstract contract VaultFactoryVariables is Owned, ERC721, StorageRead {\n    /// @dev ERC721 tokens name\n    string internal constant ERC721_NAME = \"Fluid Vault\";\n    /// @dev ERC721 tokens symbol\n    string internal constant ERC721_SYMBOL = \"fVLT\";\n\n    /*//////////////////////////////////////////////////////////////\n                          STORAGE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    // ------------ storage variables from inherited contracts (Owned and ERC721) come before vars here --------\n\n    // ----------------------- slot 0 ---------------------------\n    // address public owner; // from Owned\n\n    // 12 bytes empty\n\n    // ----------------------- slot 1 ---------------------------\n    // string public name;\n\n    // ----------------------- slot 2 ---------------------------\n    // string public symbol;\n\n    // ----------------------- slot 3 ---------------------------\n    // mapping(uint256 => uint256) internal _tokenConfig;\n\n    // ----------------------- slot 4 ---------------------------\n    // mapping(address => mapping(uint256 => uint256)) internal _ownerConfig;\n\n    // ----------------------- slot 5 ---------------------------\n    // uint256 public totalSupply;\n\n    // ----------------------- slot 6 ---------------------------\n    // mapping(uint256 => address) public getApproved;\n\n    // ----------------------- slot 7  ---------------------------\n    // mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    // ----------------------- slot 8  ---------------------------\n    /// @dev deployer can deploy new Vault contract\n    /// owner can add/remove deployer.\n    /// Owner is deployer by default.\n    mapping(address => bool) internal _deployers;\n\n    // ----------------------- slot 9  ---------------------------\n    /// @dev global auths can update any vault config.\n    /// owner can add/remove global auths.\n    /// Owner is global auth by default.\n    mapping(address => bool) internal _globalAuths;\n\n    // ----------------------- slot 10  ---------------------------\n    /// @dev vault auths can update specific vault config.\n    /// owner can add/remove vault auths.\n    /// Owner is vault auth by default.\n    /// vault => auth => add/remove\n    mapping(address => mapping(address => bool)) internal _vaultAuths;\n\n    // ----------------------- slot 11 ---------------------------\n    /// @dev total no of vaults deployed by the factory\n    /// only addresses that have deployer role or owner can deploy new vault.\n    uint256 internal _totalVaults;\n\n    // ----------------------- slot 12 ---------------------------\n    /// @dev vault deployment logics for deploying vault\n    /// These logic contracts hold the deployment logics of specific vaults and are called via .delegatecall inside deployVault().\n    /// only addresses that have owner can add/remove new vault deployment logic.\n    mapping(address => bool) internal _vaultDeploymentLogics;\n\n    /*//////////////////////////////////////////////////////////////\n                          CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    constructor(address owner_) Owned(owner_) ERC721(ERC721_NAME, ERC721_SYMBOL) {}\n}\n\nabstract contract VaultFactoryEvents {\n    /// @dev Emitted when a new vault is deployed.\n    /// @param vault The address of the newly deployed vault.\n    /// @param vaultId The id of the newly deployed vault.\n    event VaultDeployed(address indexed vault, uint256 indexed vaultId);\n\n    /// @dev Emitted when a new token/position is minted by a vault.\n    /// @param vault The address of the vault that minted the token.\n    /// @param user The address of the user who received the minted token.\n    /// @param tokenId The ID of the newly minted token.\n    event NewPositionMinted(address indexed vault, address indexed user, uint256 indexed tokenId);\n\n    /// @dev Emitted when the deployer is modified by owner.\n    /// @param deployer Address whose deployer status is updated.\n    /// @param allowed Indicates whether the address is authorized as a deployer or not.\n    event LogSetDeployer(address indexed deployer, bool indexed allowed);\n\n    /// @dev Emitted when the globalAuth is modified by owner.\n    /// @param globalAuth Address whose globalAuth status is updated.\n    /// @param allowed Indicates whether the address is authorized as a deployer or not.\n    event LogSetGlobalAuth(address indexed globalAuth, bool indexed allowed);\n\n    /// @dev Emitted when the vaultAuth is modified by owner.\n    /// @param vaultAuth Address whose vaultAuth status is updated.\n    /// @param allowed Indicates whether the address is authorized as a deployer or not.\n    /// @param vault Address of the specific vault related to the authorization change.\n    event LogSetVaultAuth(address indexed vaultAuth, bool indexed allowed, address indexed vault);\n\n    /// @dev Emitted when the vault deployment logic is modified by owner.\n    /// @param vaultDeploymentLogic The address of the vault deployment logic contract.\n    /// @param allowed  Indicates whether the address is authorized as a deployer or not.\n    event LogSetVaultDeploymentLogic(address indexed vaultDeploymentLogic, bool indexed allowed);\n}\n\nabstract contract VaultFactoryCore is VaultFactoryVariables, VaultFactoryEvents {\n    constructor(address owner_) validAddress(owner_) VaultFactoryVariables(owner_) {}\n\n    /// @dev validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidVaultError(ErrorTypes.VaultFactory__InvalidParams);\n        }\n        _;\n    }\n}\n\n/// @dev Implements Vault Factory auth-only callable methods. Owner / auths can set various config values and\n/// can define the allow-listed deployers.\nabstract contract VaultFactoryAuth is VaultFactoryCore {\n    /// @notice                         Sets an address (`deployer_`) as allowed deployer or not.\n    ///                                 This function can only be called by the owner.\n    /// @param deployer_                The address to be set as deployer.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to deploy vaults.\n    function setDeployer(address deployer_, bool allowed_) external onlyOwner validAddress(deployer_) {\n        _deployers[deployer_] = allowed_;\n\n        emit LogSetDeployer(deployer_, allowed_);\n    }\n\n    /// @notice                         Sets an address (`globalAuth_`) as a global authorization or not.\n    ///                                 This function can only be called by the owner.\n    /// @param globalAuth_              The address to be set as global authorization.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to update any vault config.\n    function setGlobalAuth(address globalAuth_, bool allowed_) external onlyOwner validAddress(globalAuth_) {\n        _globalAuths[globalAuth_] = allowed_;\n\n        emit LogSetGlobalAuth(globalAuth_, allowed_);\n    }\n\n    /// @notice                         Sets an address (`vaultAuth_`) as allowed vault authorization or not for a specific vault (`vault_`).\n    ///                                 This function can only be called by the owner.\n    /// @param vault_                   The address of the vault for which the authorization is being set.\n    /// @param vaultAuth_               The address to be set as vault authorization.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to update the specific vault config.\n    function setVaultAuth(\n        address vault_,\n        address vaultAuth_,\n        bool allowed_\n    ) external onlyOwner validAddress(vaultAuth_) {\n        _vaultAuths[vault_][vaultAuth_] = allowed_;\n\n        emit LogSetVaultAuth(vaultAuth_, allowed_, vault_);\n    }\n\n    /// @notice                         Sets an address as allowed vault deployment logic (`deploymentLogic_`) contract or not.\n    ///                                 This function can only be called by the owner.\n    /// @param deploymentLogic_         The address of the vault deployment logic contract to be set.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to deploy new type of vault.\n    function setVaultDeploymentLogic(\n        address deploymentLogic_,\n        bool allowed_\n    ) public onlyOwner validAddress(deploymentLogic_) {\n        _vaultDeploymentLogics[deploymentLogic_] = allowed_;\n\n        emit LogSetVaultDeploymentLogic(deploymentLogic_, allowed_);\n    }\n\n    /// @notice                         Spell allows owner aka governance to do any arbitrary call on factory\n    /// @param target_                  Address to which the call needs to be delegated\n    /// @param data_                    Data to execute at the delegated address\n    function spell(address target_, bytes memory data_) external onlyOwner returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n\n    /// @notice                         Checks if the provided address (`deployer_`) is authorized as a deployer.\n    /// @param deployer_                The address to be checked for deployer authorization.\n    /// @return                         Returns `true` if the address is a deployer, otherwise `false`.\n    function isDeployer(address deployer_) public view returns (bool) {\n        return _deployers[deployer_] || owner == deployer_;\n    }\n\n    /// @notice                         Checks if the provided address (`globalAuth_`) has global vault authorization privileges.\n    /// @param globalAuth_              The address to be checked for global authorization privileges.\n    /// @return                         Returns `true` if the given address has global authorization privileges, otherwise `false`.\n    function isGlobalAuth(address globalAuth_) public view returns (bool) {\n        return _globalAuths[globalAuth_] || owner == globalAuth_;\n    }\n\n    /// @notice                         Checks if the provided address (`vaultAuth_`) has vault authorization privileges for the specified vault (`vault_`).\n    /// @param vault_                   The address of the vault to check.\n    /// @param vaultAuth_               The address to be checked for vault authorization privileges.\n    /// @return                         Returns `true` if the given address has vault authorization privileges for the specified vault, otherwise `false`.\n    function isVaultAuth(address vault_, address vaultAuth_) public view returns (bool) {\n        return _vaultAuths[vault_][vaultAuth_] || owner == vaultAuth_;\n    }\n\n    /// @notice                         Checks if the provided (`vaultDeploymentLogic_`) address has authorization for vault deployment.\n    /// @param vaultDeploymentLogic_    The address of the vault deploy logic to check for authorization privileges.\n    /// @return                         Returns `true` if the given address has authorization privileges for vault deployment, otherwise `false`.\n    function isVaultDeploymentLogic(address vaultDeploymentLogic_) public view returns (bool) {\n        return _vaultDeploymentLogics[vaultDeploymentLogic_];\n    }\n}\n\n/// @dev implements VaultFactory deploy vault related methods.\nabstract contract VaultFactoryDeployment is VaultFactoryCore, VaultFactoryAuth {\n    /// @dev                            Deploys a contract using the CREATE opcode with the provided bytecode (`bytecode_`).\n    ///                                 This is an internal function, meant to be used within the contract to facilitate the deployment of other contracts.\n    /// @param bytecode_                The bytecode of the contract to be deployed.\n    /// @return address_                Returns the address of the deployed contract.\n    function _deploy(bytes memory bytecode_) internal returns (address address_) {\n        if (bytecode_.length == 0) {\n            revert FluidVaultError(ErrorTypes.VaultFactory__InvalidOperation);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            address_ := create(0, add(bytecode_, 0x20), mload(bytecode_))\n        }\n        if (address_ == address(0)) {\n            revert FluidVaultError(ErrorTypes.VaultFactory__InvalidOperation);\n        }\n    }\n\n    /// @notice                         Deploys a new vault using the specified deployment logic `vaultDeploymentLogic_` and data `vaultDeploymentData_`.\n    ///                                 Only accounts with deployer access or the owner can deploy a new vault.\n    /// @param vaultDeploymentLogic_    The address of the vault deployment logic contract.\n    /// @param vaultDeploymentData_     The data to be used for vault deployment.\n    /// @return vault_                  Returns the address of the newly deployed vault.\n    function deployVault(\n        address vaultDeploymentLogic_,\n        bytes calldata vaultDeploymentData_\n    ) external returns (address vault_) {\n        // Revert if msg.sender doesn't have deployer access or is an owner.\n        if (!isDeployer(msg.sender)) revert FluidVaultError(ErrorTypes.VaultFactory__Unauthorized);\n        // Revert if vaultDeploymentLogic_ is not whitelisted.\n        if (!isVaultDeploymentLogic(vaultDeploymentLogic_))\n            revert FluidVaultError(ErrorTypes.VaultFactory__Unauthorized);\n\n        // Vault ID for the new vault and also acts as `nonce` for CREATE\n        uint256 vaultId_ = ++_totalVaults;\n\n        // compute vault address for vault id.\n        vault_ = getVaultAddress(vaultId_);\n\n        // deploy the vault using vault deployment logic by making .delegatecall\n        (bool success_, bytes memory data_) = vaultDeploymentLogic_.delegatecall(vaultDeploymentData_);\n\n        if (!(success_ && vault_ == _deploy(abi.decode(data_, (bytes))) && isVault(vault_))) {\n            revert FluidVaultError(ErrorTypes.VaultFactory__InvalidVaultAddress);\n        }\n\n        emit VaultDeployed(vault_, vaultId_);\n    }\n\n    /// @notice                         Computes the address of a vault based on its given ID (`vaultId_`).\n    /// @param vaultId_                 The ID of the vault.\n    /// @return vault_                  Returns the computed address of the vault.\n    function getVaultAddress(uint256 vaultId_) public view returns (address vault_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (vaultId_ == 0x00) {\n            return address(0);\n        } else if (vaultId_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), address(this), uint8(vaultId_));\n        } else if (vaultId_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), address(this), bytes1(0x81), uint8(vaultId_));\n        } else if (vaultId_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), address(this), bytes1(0x82), uint16(vaultId_));\n        } else if (vaultId_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), address(this), bytes1(0x83), uint24(vaultId_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), address(this), bytes1(0x84), uint32(vaultId_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n    /// @notice                         Checks if a given address (`vault_`) corresponds to a valid vault.\n    /// @param vault_                   The vault address to check.\n    /// @return                         Returns `true` if the given address corresponds to a valid vault, otherwise `false`.\n    function isVault(address vault_) public view returns (bool) {\n        if (vault_.code.length == 0) {\n            return false;\n        } else {\n            // VAULT_ID() function signature is 0x540acabc\n            (bool success_, bytes memory data_) = vault_.staticcall(hex\"540acabc\");\n            return success_ && vault_ == getVaultAddress(abi.decode(data_, (uint256)));\n        }\n    }\n\n    /// @notice                   Returns the total number of vaults deployed by the factory.\n    /// @return                   Returns the total number of vaults.\n    function totalVaults() external view returns (uint256) {\n        return _totalVaults;\n    }\n}\n\nabstract contract VaultFactoryERC721 is VaultFactoryCore, VaultFactoryDeployment {\n    /// @notice                   Mints a new ERC721 token for a specific vault (`vaultId_`) to a specified user (`user_`).\n    ///                           Only the corresponding vault is authorized to mint a token.\n    /// @param vaultId_           The ID of the vault that's minting the token.\n    /// @param user_              The address receiving the minted token.\n    /// @return tokenId_          The ID of the newly minted token.\n    function mint(uint256 vaultId_, address user_) external returns (uint256 tokenId_) {\n        if (msg.sender != getVaultAddress(vaultId_)) revert FluidVaultError(ErrorTypes.VaultFactory__InvalidVault);\n\n        // Using _mint() instead of _safeMint() to allow any msg.sender to receive ERC721 without onERC721Received holder.\n        tokenId_ = _mint(user_, vaultId_);\n\n        emit NewPositionMinted(msg.sender, user_, tokenId_);\n    }\n\n    /// @notice                   Returns the URI of the specified token ID (`id_`).\n    ///                           In this implementation, an empty string is returned as no specific URI is defined.\n    /// @param id_                The ID of the token to query.\n    /// @return                   An empty string since no specific URI is defined in this implementation.\n    function tokenURI(uint256 id_) public view virtual override returns (string memory) {\n        return \"\";\n    }\n}\n\n/// @title Fluid VaultFactory\n/// @notice creates Fluid vault protocol vaults, which are interacting with Fluid Liquidity to deposit / borrow funds.\n/// Vaults are created at a deterministic address, given an incrementing `vaultId` (see `getVaultAddress()`).\n/// Vaults can only be deployed by allow-listed deployer addresses.\n/// This factory also implements ERC721-Enumerable, the NFTs are used to represent created user positions. Only vaults\n/// can mint new NFTs.\n/// @dev Note the deployed vaults start out with no config at Liquidity contract.\n/// This must be done by Liquidity auths in a separate step, otherwise no deposits will be possible.\n/// This contract is not upgradeable. It supports adding new vault deployment logic contracts for new, future vaults.\ncontract FluidVaultFactory is VaultFactoryCore, VaultFactoryAuth, VaultFactoryDeployment, VaultFactoryERC721 {\n    constructor(address owner_) VaultFactoryCore(owner_) {}\n}\n"
    },
    "contracts/protocols/vault/interfaces/iLiquidityDexCommon.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFluidLiquidityLogic } from \"../../../liquidity/interfaces/iLiquidity.sol\";\nimport { IFluidDexT1 } from \"../../dex/interfaces/iDexT1.sol\";\n\ninterface ILiquidityDexCommon is IFluidLiquidityLogic, IFluidDexT1 {\n    /// @notice only importing IFluidLiquidityLogic as readFromStorage is also defined in iDexT1 as well so to avoid clashing\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVault.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\ninterface IFluidVault {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice returns the vault id\n    function TYPE() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct Tokens {\n        address token0;\n        address token1;\n    }\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address operateImplementation;\n        address adminImplementation;\n        address secondaryImplementation;\n        address deployer; // address which deploys oracle\n        address supply; // either liquidity layer or DEX protocol\n        address borrow; // either liquidity layer or DEX protocol\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\n        uint256 vaultId;\n        uint256 vaultType;\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n\n    function rebalance(\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_\n    ) external returns (int supplyAmt_, int borrowAmt_);\n\n    /// @notice reverts with FluidLiquidateResult\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\ninterface IFluidVaultFactory is IERC721Enumerable {\n    /// @notice Minting an NFT Vault for the user\n    function mint(uint256 vaultId_, address user_) external returns (uint256 tokenId_);\n\n    /// @notice returns owner of Vault which is also an NFT\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /// @notice Global auth is auth for all vaults\n    function isGlobalAuth(address auth_) external view returns (bool);\n\n    /// @notice Vault auth is auth for a specific vault\n    function isVaultAuth(address vault_, address auth_) external view returns (bool);\n\n    /// @notice Total vaults deployed.\n    function totalVaults() external view returns (uint256);\n\n    /// @notice Compute vaultAddress\n    function getVaultAddress(uint256 vaultId) external view returns (address);\n\n    /// @notice read uint256 `result_` for a storage `slot_` key\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT1_not_for_prod.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFluidVault } from \"./iVault.sol\";\n\ninterface IFluidVaultT1_Not_For_Prod is IFluidVault {\n    function operate(\n        uint256 nftId_, // if 0 then new position\n        int256 newCol_, // if negative then withdraw\n        int256 newDebt_, // if negative then payback\n        address to_, // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\n        uint256 vaultVariables_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256, // final borrow amount. if - then payback\n            uint256\n        );\n\n    function liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint actualDebtAmt_, uint actualColAmt_);\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT1.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IFluidVaultT1 {\n    /// @notice returns the vault id\n    function VAULT_ID() external view returns (uint256);\n\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address adminImplementation;\n        address secondaryImplementation;\n        address supplyToken;\n        address borrowToken;\n        uint8 supplyDecimals;\n        uint8 borrowDecimals;\n        uint vaultId;\n        bytes32 liquiditySupplyExchangePriceSlot;\n        bytes32 liquidityBorrowExchangePriceSlot;\n        bytes32 liquidityUserSupplySlot;\n        bytes32 liquidityUserBorrowSlot;\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    /// @notice fetches the latest user position after a liquidation\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        external\n        view\n        returns (\n            int256, // tick\n            uint256, // raw debt\n            uint256, // raw collateral\n            uint256, // branchID_\n            uint256 // branchData_\n        );\n\n    /// @notice calculates the updated vault exchange prices\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        external\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice calculates the updated vault exchange prices and writes them to storage\n    function updateExchangePricesOnStorage()\n        external\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        );\n\n    /// @notice returns the liquidity contract address\n    function LIQUIDITY() external view returns (address);\n\n    function operate(\n        uint256 nftId_, // if 0 then new position\n        int256 newCol_, // if negative then withdraw\n        int256 newDebt_, // if negative then payback\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint actualDebtAmt_, uint actualColAmt_);\n\n    function absorb() external;\n\n    function rebalance() external payable returns (int supplyAmt_, int borrowAmt_);\n\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT2.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFluidVault } from \"./iVault.sol\";\n\ninterface IFluidVaultT2 is IFluidVault {\n    function operate(\n        uint nftId_,\n        int newColToken0_,\n        int newColToken1_,\n        int colSharesMinMax_,\n        int newDebt_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function operatePerfect(\n        uint nftId_,\n        int perfectColShares_,\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int newDebt_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256[] memory r_\n        );\n\n    function liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint256 actualDebt_, uint256 actualColShares_, uint256 token0Col_, uint256 token1Col_);\n\n    function liquidatePerfect(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint256 actualDebt_, uint256 actualColShares_, uint256 token0Col_, uint256 token1Col_);\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT3.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFluidVault } from \"./iVault.sol\";\n\ninterface IFluidVaultT3 is IFluidVault {\n    function operate(\n        uint nftId_,\n        int newCol_,\n        int newDebtToken0_,\n        int newDebtToken1_,\n        int debtSharesMinMax_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function operatePerfect(\n        uint nftId_,\n        int newCol_,\n        int perfectDebtShares_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256[] memory r_\n        );\n\n    function liquidate(\n        uint256 token0DebtAmt_,\n        uint256 token1DebtAmt_,\n        uint256 debtSharesMin_,\n        uint256 colPerUnitDebt_,\n        address to_,\n        bool absorb_\n    ) external payable returns (uint256 actualDebtShares_, uint256 actualCol_);\n\n    function liquidatePerfect(\n        uint256 debtShares_,\n        uint256 token0DebtAmtPerUnitShares_,\n        uint256 token1DebtAmtPerUnitShares_,\n        uint256 colPerUnitDebt_,\n        address to_,\n        bool absorb_\n    )\n        external\n        payable\n        returns (uint256 actualDebtShares_, uint256 token0Debt_, uint256 token1Debt_, uint256 actualCol_);\n}\n"
    },
    "contracts/protocols/vault/interfaces/iVaultT4.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IFluidVault } from \"./iVault.sol\";\n\ninterface IFluidVaultT4 is IFluidVault {\n    function operate(\n        uint nftId_,\n        int newColToken0_,\n        int newColToken1_,\n        int colSharesMinMax_,\n        int newDebtToken0_,\n        int newDebtToken1_,\n        int debtSharesMinMax_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        );\n\n    function operatePerfect(\n        uint nftId_,\n        int perfectColShares_,\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int perfectDebtShares_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256[] memory r_\n        );\n\n    function liquidate(\n        uint256 token0DebtAmt_,\n        uint256 token1DebtAmt_,\n        uint256 debtSharesMin_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    )\n        external\n        payable\n        returns (uint256 actualDebtShares_, uint256 actualColShares_, uint256 token0Col_, uint256 token1Col_);\n\n    function liquidatePerfect(\n        uint256 debtShares_,\n        uint256 token0DebtAmtPerUnitShares_,\n        uint256 token1DebtAmtPerUnitShares_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    )\n        external\n        payable\n        returns (\n            uint256 actualDebtShares_,\n            uint256 token0Debt_,\n            uint256 token1Debt_,\n            uint256 actualColShares_,\n            uint256 token0Col_,\n            uint256 token1Col_\n        );\n}\n"
    },
    "contracts/protocols/vault/rewards/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Events {\n    /// @notice Emitted when magnifier is updated\n    event LogUpdateMagnifier(address indexed vault, uint256 newMagnifier);\n\n    /// @notice Emitted when rewards are started\n    event LogRewardsStarted(uint256 startTime, uint256 endTime);\n\n    /// @notice Emitted when next rewards are set\n    event LogNextRewardsQueued(uint256 rewardsAmount, uint256 duration);\n}\n"
    },
    "contracts/protocols/vault/rewards/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidVaultT1Admin } from \"../vaultT1/adminModule/main.sol\";\nimport { IFluidVaultT1 } from \"../interfaces/iVaultT1.sol\";\nimport { IFluidReserveContract } from \"../../../reserve/interfaces/iReserveContract.sol\";\nimport { LiquiditySlotsLink } from \"../../../libraries/liquiditySlotsLink.sol\";\nimport { Events } from \"./events.sol\";\nimport { Variables } from \"./variables.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\n\n/// @title VaultRewards\n/// @notice This contract is designed to adjust the supply rate magnifier for a vault based on the current collateral supply & supply rate.\n/// The adjustment aims to dynamically scale the rewards given to lenders as the TVL in the vault changes.\n///\n/// The magnifier is adjusted based on a regular most used reward type where rewardRate = totalRewardsAnnually / totalSupply.\n/// Reward rate is applied by adjusting the supply magnifier on vault.\n/// Adjustments are made via the rebalance function, which is restricted to be called by designated rebalancers only.\ncontract FluidVaultRewards is Variables, Events, Error {\n    /// @dev Validates that an address is not the zero address\n    modifier validAddress(address value_) {\n        if (value_ == address(0)) {\n            revert FluidVaultError(ErrorTypes.VaultRewards__AddressZero);\n        }\n        _;\n    }\n\n    /// @dev Validates that an address is a rebalancer (taken from reserve contract)\n    modifier onlyRebalancer() {\n        if (!RESERVE_CONTRACT.isRebalancer(msg.sender)) {\n            revert FluidVaultError(ErrorTypes.VaultRewards__Unauthorized);\n        }\n        _;\n    }\n\n    /// @notice Constructs the FluidVaultRewards contract.\n    /// @param reserveContract_ The address of the reserve contract where rebalancers are defined.\n    /// @param vault_ The vault to which this contract will apply new magnifier parameter.\n    /// @param liquidity_ Fluid liquidity address\n    /// @param rewardsAmt_ Amounts of rewards to distribute\n    /// @param duration_ rewards duration\n    /// @param initiator_ address that can start rewards with `start()`\n    /// @param collateralToken_ vault collateral token address\n    /// @param governance_ governance address\n    constructor(\n        IFluidReserveContract reserveContract_,\n        IFluidVaultT1 vault_,\n        IFluidLiquidity liquidity_,\n        uint256 rewardsAmt_,\n        uint256 duration_,\n        address initiator_,\n        address collateralToken_,\n        address governance_\n    )\n        validAddress(address(reserveContract_))\n        validAddress(address(liquidity_))\n        validAddress(address(vault_))\n        validAddress(initiator_)\n        validAddress(address(collateralToken_))\n        validAddress(governance_)\n    {\n        if (rewardsAmt_ == 0 || duration_ == 0) {\n            revert FluidVaultError(ErrorTypes.VaultRewards__InvalidParams);\n        }\n        RESERVE_CONTRACT = reserveContract_;\n        VAULT = vault_;\n        rewardsAmount = uint128(rewardsAmt_);\n        rewardsAmountPerYear = (rewardsAmt_ * SECONDS_PER_YEAR) / duration_;\n        duration = uint40(duration_);\n        INITIATOR = initiator_;\n        LIQUIDITY = liquidity_;\n        VAULT_COLLATERAL_TOKEN = collateralToken_;\n        GOVERNANCE = governance_;\n\n        LIQUIDITY_TOTAL_AMOUNTS_COLLATERAL_TOKEN_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT,\n            collateralToken_\n        );\n        LIQUIDITY_EXCHANGE_PRICE_COLLATERAL_TOKEN_SLOT = LiquiditySlotsLink.calculateMappingStorageSlot(\n            LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n            collateralToken_\n        );\n    }\n\n    /// @notice Rebalances the supply rate magnifier based on the current collateral supply.\n    /// Can only be called by an authorized rebalancer.\n    function rebalance() external onlyRebalancer {\n        (uint256 newMagnifier_, bool ended_) = calculateMagnifier();\n        if (ended_ && newMagnifier_ == FOUR_DECIMALS) {\n            if (nextDuration == 0 || nextRewardsAmount == 0) {\n                ended = true;\n            } else {\n                rewardsAmount = nextRewardsAmount;\n                rewardsAmountPerYear = (nextRewardsAmount * SECONDS_PER_YEAR) / nextDuration;\n                duration = nextDuration;\n                nextRewardsAmount = 0;\n                nextDuration = 0;\n                startTime = uint40(block.timestamp);\n                endTime = uint40(block.timestamp + duration);\n                (newMagnifier_, ended_) = calculateMagnifier();\n            }\n        }\n        if (newMagnifier_ == currentMagnifier()) {\n            if (ended_) {\n                return;\n            }\n            revert FluidVaultError(ErrorTypes.VaultRewards__NewMagnifierSameAsOldMagnifier);\n        }\n\n        FluidVaultT1Admin(address(VAULT)).updateSupplyRateMagnifier(newMagnifier_);\n        emit LogUpdateMagnifier(address(VAULT), newMagnifier_);\n    }\n\n    /// @notice Calculates the new supply rate magnifier based on the current collateral supply (`vaultTVL()`).\n    /// @return magnifier_ The calculated magnifier value.\n    function calculateMagnifier() public view returns (uint256 magnifier_, bool ended_) {\n        uint256 currentTVL_ = vaultTVL();\n        uint256 startTime_ = uint256(startTime);\n        uint256 endTime_ = uint256(endTime);\n\n        if (startTime_ == 0 || endTime_ == 0 || ended) {\n            revert FluidVaultError(ErrorTypes.VaultRewards__RewardsNotStartedOrEnded);\n        }\n\n        if (block.timestamp > endTime_) {\n            return (FOUR_DECIMALS, true);\n        }\n\n        uint supplyRate_ = getSupplyRate();\n        uint rewardsRate_ = (rewardsAmountPerYear * FOUR_DECIMALS) / currentTVL_;\n\n        magnifier_ = FOUR_DECIMALS + (supplyRate_ == 0 ? rewardsRate_ : ((rewardsRate_ * FOUR_DECIMALS) / supplyRate_));\n        if (magnifier_ > X16) {\n            magnifier_ = X16;\n        }\n    }\n\n    /// @notice returns the currently configured supply magnifier at the `VAULT`.\n    function currentMagnifier() public view returns (uint256) {\n        // read supply rate magnifier from Vault `vaultVariables2` located in storage slot 1, first 16 bits\n        return VAULT.readFromStorage(bytes32(uint256(1))) & X16;\n    }\n\n    /// @notice returns the current total value locked as collateral (TVL) in the `VAULT`.\n    function vaultTVL() public view returns (uint256 tvl_) {\n        // read total supply raw in vault from storage slot 0 `vaultVariables`, 64 bits 82-145\n        tvl_ = (VAULT.readFromStorage(bytes32(0)) >> 82) & 0xFFFFFFFFFFFFFFFF;\n\n        // Converting bignumber into normal number\n        tvl_ = (tvl_ >> 8) << (tvl_ & 0xFF);\n\n        // get updated supply exchange price, which takes slot 1 `vaultVariables2` as input param\n        (, , uint256 vaultSupplyExPrice_, ) = VAULT.updateExchangePrices(VAULT.readFromStorage(bytes32(uint256(1))));\n\n        // converting raw total supply into normal amount\n        tvl_ = (tvl_ * vaultSupplyExPrice_) / 1e12;\n    }\n\n    function getSupplyRate() public view returns (uint supplyRate_) {\n        uint256 exchangePriceAndConfig_ = LIQUIDITY.readFromStorage(LIQUIDITY_EXCHANGE_PRICE_COLLATERAL_TOKEN_SLOT);\n        uint256 totalAmounts_ = LIQUIDITY.readFromStorage(LIQUIDITY_TOTAL_AMOUNTS_COLLATERAL_TOKEN_SLOT);\n\n        uint borrowRate_ = exchangePriceAndConfig_ & X16;\n        uint fee_ = (exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14;\n        uint supplyExchangePrice_ = ((exchangePriceAndConfig_ >>\n            LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) & X64);\n        uint borrowExchangePrice_ = ((exchangePriceAndConfig_ >>\n            LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) & X64);\n\n        // Extract supply raw interest\n        uint256 supplyWithInterest_ = totalAmounts_ & X64;\n        supplyWithInterest_ =\n            (supplyWithInterest_ >> DEFAULT_EXPONENT_SIZE) <<\n            (supplyWithInterest_ & DEFAULT_EXPONENT_MASK);\n\n        // Extract borrow raw interest\n        uint256 borrowWithInterest_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) &\n            X64;\n        borrowWithInterest_ =\n            (borrowWithInterest_ >> DEFAULT_EXPONENT_SIZE) <<\n            (borrowWithInterest_ & DEFAULT_EXPONENT_MASK);\n\n        if (supplyWithInterest_ > 0) {\n            // use old exchange prices for supply rate to be at same level as borrow rate from storage.\n            // Note the rate here can be a tiny bit with higher precision because we use borrowWithInterest_ / supplyWithInterest_\n            // which has higher precision than the utilization used from storage in LiquidityCalcs\n            supplyWithInterest_ = (supplyWithInterest_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION; // normalized from raw\n            borrowWithInterest_ = (borrowWithInterest_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION; // normalized from raw\n\n            supplyRate_ =\n                (borrowRate_ * (FOUR_DECIMALS - fee_) * borrowWithInterest_) /\n                (supplyWithInterest_ * FOUR_DECIMALS);\n        }\n    }\n\n    function start() external {\n        startAt(block.timestamp);\n    }\n\n    function startAt(uint256 startTime_) public {\n        if (msg.sender != INITIATOR) {\n            revert FluidVaultError(ErrorTypes.VaultRewards__NotTheInitiator);\n        }\n        if (startTime > 0 || endTime > 0) {\n            revert FluidVaultError(ErrorTypes.VaultRewards__AlreadyStarted);\n        }\n        if (startTime_ < block.timestamp || startTime_ > block.timestamp + 2 weeks) {\n            revert FluidVaultError(ErrorTypes.VaultRewards__InvalidStartTime);\n        }\n        startTime = uint40(startTime_);\n        endTime = uint40(startTime_ + duration);\n        emit LogRewardsStarted(startTime, endTime);\n    }\n\n    function queueNextRewards(uint256 rewardsAmount_, uint256 duration_) external {\n        if (msg.sender != GOVERNANCE) {\n            revert FluidVaultError(ErrorTypes.VaultRewards__NotTheGovernance);\n        }\n        if (rewardsAmount_ == 0 || duration_ == 0) {\n            revert FluidVaultError(ErrorTypes.VaultRewards__InvalidParams);\n        }\n        if (block.timestamp > endTime || ended) {\n            revert FluidVaultError(ErrorTypes.VaultRewards__AlreadyEnded);\n        }\n        nextRewardsAmount = uint128(rewardsAmount_);\n        nextDuration = uint40(duration_);\n        emit LogNextRewardsQueued(rewardsAmount_, duration_);\n    }\n}\n"
    },
    "contracts/protocols/vault/rewards/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidReserveContract } from \"../../../reserve/interfaces/iReserveContract.sol\";\nimport { IFluidVaultT1 } from \"../interfaces/iVaultT1.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\n\nabstract contract Constants {\n    IFluidLiquidity public immutable LIQUIDITY;\n    IFluidReserveContract public immutable RESERVE_CONTRACT;\n    IFluidVaultT1 public immutable VAULT;\n    address public immutable INITIATOR;\n    address public immutable VAULT_COLLATERAL_TOKEN;\n    address public immutable GOVERNANCE;\n\n    bytes32 internal immutable LIQUIDITY_TOTAL_AMOUNTS_COLLATERAL_TOKEN_SLOT;\n    bytes32 internal immutable LIQUIDITY_EXCHANGE_PRICE_COLLATERAL_TOKEN_SLOT;\n    uint256 internal constant FOUR_DECIMALS = 10000;\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xff;\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n}\n\nabstract contract Variables is Constants {\n    // slot 1\n    bool public ended; // when rewards are ended\n    uint40 public startTime;\n    uint40 public duration;\n    uint40 public endTime;\n    uint40 public nextDuration;\n\n    // slot 2\n    uint128 public rewardsAmount;\n    uint128 public nextRewardsAmount;\n\n    // slot 3\n    uint256 public rewardsAmountPerYear;\n}\n"
    },
    "contracts/protocols/vault/vaultT1_not_for_prod/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract VaultT1Events {\n    /// @notice emitted when the supply rate magnifier config is updated\n    event LogUpdateSupplyRateMagnifier(uint supplyRateMagnifier_);\n\n    /// @notice emitted when the borrow rate magnifier config is updated\n    event LogUpdateBorrowRateMagnifier(uint borrowRateMagnifier_);\n\n    /// @notice emitted when the core setting configs are updated\n    event LogUpdateCoreSettings(\n        uint supplyRateMagnifier_,\n        uint borrowRateMagnifier_,\n        uint collateralFactor_,\n        uint liquidationThreshold_,\n        uint liquidationMaxLimit_,\n        uint withdrawGap_,\n        uint liquidationPenalty_,\n        uint borrowFee_\n    );\n}\n"
    },
    "contracts/protocols/vault/vaultT1_not_for_prod/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidVaultAdmin } from \"../../vaultTypesCommon/adminModule/main.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { VaultT1Events } from \"./events.sol\";\n\n/// @notice Fluid Vault protocol Admin Module contract.\n///         Implements admin related methods to set configs such as liquidation params, rates\n///         oracle address etc.\n///         Methods are limited to be called via delegateCall only. Vault CoreModule (\"VaultT1\" contract)\n///         is expected to call the methods implemented here after checking the msg.sender is authorized.\n///         All methods update the exchange prices in storage before changing configs.\ncontract FluidVaultT1Admin_Not_For_Prod is FluidVaultAdmin, VaultT1Events {\n    /// @notice updates the supply rate magnifier to `supplyRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateSupplyRateMagnifier(uint supplyRateMagnifier_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateSupplyRateMagnifier(supplyRateMagnifier_);\n\n        if (supplyRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000) |\n            supplyRateMagnifier_;\n    }\n\n    /// @notice updates the borrow rate magnifier to `borrowRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateBorrowRateMagnifier(uint borrowRateMagnifier_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowRateMagnifier(borrowRateMagnifier_);\n\n        if (borrowRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff) |\n            (borrowRateMagnifier_ << 16);\n    }\n\n    /// @notice updates the all Vault core settings according to input params.\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\n    function updateCoreSettings(\n        uint256 supplyRateMagnifier_,\n        uint256 borrowRateMagnifier_,\n        uint256 collateralFactor_,\n        uint256 liquidationThreshold_,\n        uint256 liquidationMaxLimit_,\n        uint256 withdrawGap_,\n        uint256 liquidationPenalty_,\n        uint256 borrowFee_\n    ) public _updateExchangePrice _verifyCaller {\n        // emitting the event at the start as then we are updating numbers to store in a more optimized way\n        emit LogUpdateCoreSettings(\n            supplyRateMagnifier_,\n            borrowRateMagnifier_,\n            collateralFactor_,\n            liquidationThreshold_,\n            liquidationMaxLimit_,\n            withdrawGap_,\n            liquidationPenalty_,\n            borrowFee_\n        );\n\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        collateralFactor_ = collateralFactor_ / 10;\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n        withdrawGap_ = withdrawGap_ / 10;\n\n        if (\n            (supplyRateMagnifier_ > X16) ||\n            (borrowRateMagnifier_ > X16) ||\n            (collateralFactor_ >= liquidationThreshold_) ||\n            (liquidationThreshold_ >= liquidationMaxLimit_) ||\n            (withdrawGap_ > X10) ||\n            (liquidationPenalty_ > X10) ||\n            (borrowFee_ > X10)\n        ) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff00000000000000000000000) |\n            supplyRateMagnifier_ |\n            (borrowRateMagnifier_ << 16) |\n            (collateralFactor_ << 32) |\n            (liquidationThreshold_ << 42) |\n            (liquidationMaxLimit_ << 52) |\n            (withdrawGap_ << 62) |\n            (liquidationPenalty_ << 72) |\n            (borrowFee_ << 82);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT1_not_for_prod/coreModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { FluidVault } from \"../../vaultTypesCommon/coreModule/main.sol\";\n\n/// @notice Fluid \"VaultT1\" (Vault Type 1). Fluid vault protocol main contract. T1 -> Normal collateral | Normal debt\n///         Fluid Vault protocol is a borrow / lending protocol, allowing users to create collateral / borrow positions.\n///         All funds are deposited into / borrowed from Fluid Liquidity layer.\n///         Positions are represented through NFTs minted by the VaultFactory.\n///         Deployed by \"VaultFactory\" and linked together with Vault AdminModule `ADMIN_IMPLEMENTATION` and\n///         FluidVaultSecondary (main2.sol) `SECONDARY_IMPLEMENTATION`.\n///         AdminModule & FluidVaultSecondary methods are delegateCalled, if the msg.sender has the required authorization.\n///         This contract links to an Oracle, which is used to assess collateral / debt value. Oracles implement the\n///         \"FluidOracle\" base contract and return the price in 1e27 precision.\n/// @dev    For view methods / accessing data, use the \"VaultResolver\" periphery contract.\n//\n// vaults can only be deployed for tokens that are listed at Liquidity (constructor reverts otherwise\n// if either the exchange price for the supply token or the borrow token is still not set at Liquidity).\nabstract contract Internals is FluidVault {\n    // This will remain empty as this codebase has no smart collateral & smart debt\n\n    constructor(ConstantViews memory constants_) FluidVault(constants_) {}\n}\n\ncontract FluidVaultT1_Not_For_Prod is Internals {\n    /// @notice Performs operations on a vault position\n    /// @dev This function allows users to modify their vault position by adjusting collateral and debt\n    /// @param nftId_ The ID of the NFT representing the vault position\n    /// @param newCol_ The change in collateral amount (positive for deposit, negative for withdrawal)\n    /// @param newDebt_ The change in debt amount (positive for borrowing, negative for repayment)\n    /// @param to_ The address to receive withdrawn collateral or borrowed tokens (if address(0), defaults to msg.sender)\n    /// @return nftId_ The ID of the NFT representing the updated vault position\n    /// @return Final supply amount (negative if withdrawal occurred)\n    /// @return Final borrow amount (negative if repayment occurred)\n    /// @custom:security Re-entrancy protection is implemented\n    /// @custom:security ETH balance is validated before and after operation\n    function operate(\n        uint nftId_,\n        int newCol_,\n        int newDebt_,\n        address to_\n    )\n        external\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        )\n    {\n        return abi.decode(_spell(OPERATE_IMPLEMENTATION, msg.data), (uint, int, int));\n    }\n\n    /// @notice Liquidates a vault position\n    /// @dev This function allows the liquidation of a vault position by paying back the debt with the collateral\n    /// @param debtAmt_ The amount of debt to be liquidated\n    /// @param colPerUnitDebt_ The collateral per unit of debt\n    /// @param to_ The address to receive the liquidated collateral\n    /// @param absorb_ If true, the liquidation absorbs the debt and the collateral is sent to the to_ address\n    /// @return actualDebt_ The actual amount of debt that was liquidated\n    /// @return actualCol_ The actual amount of collateral that was sent to the to_ address\n    function liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt amt\n        address to_,\n        bool absorb_\n    ) external payable returns (uint256 actualDebt_, uint256 actualCol_) {\n        uint vaultVariables_ = vaultVariables;\n        // ############# turning re-entrancy bit on #############\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        uint initialEth_ = address(this).balance - msg.value;\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        (actualDebt_, actualCol_, vaultVariables_) = abi.decode(\n            _liquidate(debtAmt_, colPerUnitDebt_, to_, absorb_, vaultVariables_),\n            (uint, uint, uint)\n        );\n\n        // disabling re-entrancy and updating on storage\n        vaultVariables = vaultVariables_;\n\n        _validateEth(initialEth_);\n    }\n\n    constructor(ConstantViews memory constants_) Internals(constants_) {\n        // Note that vaults are deployed by VaultFactory so we somewhat trust the values being passed in\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT1_not_for_prod/coreModule/mainOperate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { FluidVaultOperate } from \"../../vaultTypesCommon/coreModule/mainOperate.sol\";\n\n/// @notice Fluid \"VaultT1\" (Vault Type 1). Fluid vault protocol main operate contract. T1 -> Normal collateral | Normal debt\nabstract contract Internals is FluidVaultOperate {\n    // This will remain empty as this codebase has no smart collateral & smart debt\n\n    constructor(ConstantViews memory constants_) FluidVaultOperate(constants_) {}\n}\n\ncontract FluidVaultT1Operate_Not_For_Prod is Internals {\n    /// @notice Performs operations on a vault position\n    /// @dev This function allows users to modify their vault position by adjusting collateral and debt\n    /// @param nftId_ The ID of the NFT representing the vault position\n    /// @param newCol_ The change in collateral amount (positive for deposit, negative for withdrawal)\n    /// @param newDebt_ The change in debt amount (positive for borrowing, negative for repayment)\n    /// @param to_ The address to receive withdrawn collateral or borrowed tokens (if address(0), defaults to msg.sender)\n    /// @return nftId_ The ID of the NFT representing the updated vault position\n    /// @return Final supply amount (negative if withdrawal occurred)\n    /// @return Final borrow amount (negative if repayment occurred)\n    /// @custom:security Re-entrancy protection is implemented\n    /// @custom:security ETH balance is validated before and after operation\n    function operate(\n        uint nftId_,\n        int newCol_,\n        int newDebt_,\n        address to_\n    )\n        external\n        payable\n        _delegateCallCheck\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        )\n    {\n        uint vaultVariables_ = vaultVariables;\n        // re-entrancy check\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        uint initialEth_ = address(this).balance - msg.value;\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        // operate will throw is user tried to withdraw excess shares\n        (nftId_, newCol_, newDebt_, vaultVariables_) = _operate(nftId_, newCol_, newDebt_, to_, vaultVariables_);\n\n        // disabling re-entrancy and updating vault variables\n        vaultVariables = vaultVariables_;\n\n        _validateEth(initialEth_);\n\n        return (nftId_, newCol_, newDebt_);\n    }\n\n    constructor(ConstantViews memory constants_) Internals(constants_) {}\n}\n"
    },
    "contracts/protocols/vault/vaultT1/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Events {\n    /// @notice emitted when the supply rate magnifier config is updated\n    event LogUpdateSupplyRateMagnifier(uint supplyRateMagnifier_);\n\n    /// @notice emitted when the borrow rate magnifier config is updated\n    event LogUpdateBorrowRateMagnifier(uint borrowRateMagnifier_);\n\n    /// @notice emitted when the collateral factor config is updated\n    event LogUpdateCollateralFactor(uint collateralFactor_);\n\n    /// @notice emitted when the liquidation threshold config is updated\n    event LogUpdateLiquidationThreshold(uint liquidationThreshold_);\n\n    /// @notice emitted when the liquidation max limit config is updated\n    event LogUpdateLiquidationMaxLimit(uint liquidationMaxLimit_);\n\n    /// @notice emitted when the withdrawal gap config is updated\n    event LogUpdateWithdrawGap(uint withdrawGap_);\n\n    /// @notice emitted when the liquidation penalty config is updated\n    event LogUpdateLiquidationPenalty(uint liquidationPenalty_);\n\n    /// @notice emitted when the borrow fee config is updated\n    event LogUpdateBorrowFee(uint borrowFee_);\n\n    /// @notice emitted when the core setting configs are updated\n    event LogUpdateCoreSettings(\n        uint supplyRateMagnifier_,\n        uint borrowRateMagnifier_,\n        uint collateralFactor_,\n        uint liquidationThreshold_,\n        uint liquidationMaxLimit_,\n        uint withdrawGap_,\n        uint liquidationPenalty_,\n        uint borrowFee_\n    );\n\n    /// @notice emitted when the oracle is updated\n    event LogUpdateOracle(address indexed newOracle_);\n\n    /// @notice emitted when the allowed rebalancer is updated\n    event LogUpdateRebalancer(address indexed newRebalancer_);\n\n    /// @notice emitted when funds are rescued\n    event LogRescueFunds(address indexed token_);\n\n    /// @notice emitted when dust debt is absorbed for `nftIds_`\n    event LogAbsorbDustDebt(uint256[] nftIds_, uint256 absorbedDustDebt_);\n}\n"
    },
    "contracts/protocols/vault/vaultT1/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { Variables } from \"../common/variables.sol\";\nimport { Events } from \"./events.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { IFluidVaultT1 } from \"../../interfaces/iVaultT1.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { TickMath } from \"../../../../libraries/tickMath.sol\";\nimport { SafeTransfer } from \"../../../../libraries/safeTransfer.sol\";\n\n/// @notice Fluid Vault protocol Admin Module contract.\n///         Implements admin related methods to set configs such as liquidation params, rates\n///         oracle address etc.\n///         Methods are limited to be called via delegateCall only. Vault CoreModule (\"VaultT1\" contract)\n///         is expected to call the methods implemented here after checking the msg.sender is authorized.\n///         All methods update the exchange prices in storage before changing configs.\ncontract FluidVaultT1Admin is Variables, Events, Error {\n    uint private constant X8 = 0xff;\n    uint private constant X10 = 0x3ff;\n    uint private constant X16 = 0xffff;\n    uint private constant X19 = 0x7ffff;\n    uint private constant X24 = 0xffffff;\n    uint internal constant X64 = 0xffffffffffffffff;\n    uint private constant X96 = 0xffffffffffffffffffffffff;\n    address private constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address private immutable addressThis;\n\n    constructor() {\n        addressThis = address(this);\n    }\n\n    modifier _verifyCaller() {\n        if (address(this) == addressThis) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev updates exchange price on storage, called on all admin methods in combination with _verifyCaller modifier so\n    /// only called by authorized delegatecall\n    modifier _updateExchangePrice() {\n        IFluidVaultT1(address(this)).updateExchangePricesOnStorage();\n        _;\n    }\n\n    function _checkLiquidationMaxLimitAndPenalty(uint liquidationMaxLimit_, uint liquidationPenalty_) private pure {\n        // liquidation max limit with penalty should not go above 99.7%\n        // As liquidation with penalty can happen from liquidation Threshold to max limit\n        // If it goes above 100% than that means liquidator is getting more collateral than user's available\n        if ((liquidationMaxLimit_ + liquidationPenalty_) > 9970) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n    }\n\n    /// @notice updates the supply rate magnifier to `supplyRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateSupplyRateMagnifier(uint supplyRateMagnifier_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateSupplyRateMagnifier(supplyRateMagnifier_);\n\n        if (supplyRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000) |\n            supplyRateMagnifier_;\n    }\n\n    /// @notice updates the borrow rate magnifier to `borrowRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateBorrowRateMagnifier(uint borrowRateMagnifier_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowRateMagnifier(borrowRateMagnifier_);\n\n        if (borrowRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff) |\n            (borrowRateMagnifier_ << 16);\n    }\n\n    /// @notice updates the collateral factor to `collateralFactor_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateCollateralFactor(uint collateralFactor_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateCollateralFactor(collateralFactor_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\n\n        collateralFactor_ = collateralFactor_ / 10;\n\n        if (collateralFactor_ >= liquidationThreshold_) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffc00ffffffff) |\n            (collateralFactor_ << 32);\n    }\n\n    /// @notice updates the liquidation threshold to `liquidationThreshold_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationThreshold(uint liquidationThreshold_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationThreshold(liquidationThreshold_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint collateralFactor_ = ((vaultVariables2_ >> 32) & X10);\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\n\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n\n        if ((collateralFactor_ >= liquidationThreshold_) || (liquidationThreshold_ >= liquidationMaxLimit_))\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffff003ffffffffff) |\n            (liquidationThreshold_ << 42);\n    }\n\n    /// @notice updates the liquidation max limit to `liquidationMaxLimit_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationMaxLimit(uint liquidationMaxLimit_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationMaxLimit(liquidationMaxLimit_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\n        uint liquidationPenalty_ = ((vaultVariables2_ >> 72) & X10);\n\n        // both are in 1e2 decimals (1e2 = 1%)\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n\n        if (liquidationThreshold_ >= liquidationMaxLimit_)\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffc00fffffffffffff) |\n            (liquidationMaxLimit_ << 52);\n    }\n\n    /// @notice updates the withdrawal gap to `withdrawGap_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateWithdrawGap(uint withdrawGap_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateWithdrawGap(withdrawGap_);\n\n        withdrawGap_ = withdrawGap_ / 10;\n\n        // withdrawGap must not be > 100%\n        if (withdrawGap_ > 1000) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffff003fffffffffffffff) |\n            (withdrawGap_ << 62);\n    }\n\n    /// @notice updates the liquidation penalty to `liquidationPenalty_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationPenalty(uint liquidationPenalty_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationPenalty(liquidationPenalty_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\n\n        // Converting liquidationMaxLimit_ in 1e2 decimals (1e2 = 1%)\n        _checkLiquidationMaxLimitAndPenalty((liquidationMaxLimit_ * 10), liquidationPenalty_);\n\n        if (liquidationPenalty_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffc00ffffffffffffffffff) |\n            (liquidationPenalty_ << 72);\n    }\n\n    /// @notice updates the borrow fee to `borrowFee_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateBorrowFee(uint borrowFee_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowFee(borrowFee_);\n\n        if (borrowFee_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff003ffffffffffffffffffff) |\n            (borrowFee_ << 82);\n    }\n\n    /// @notice updates the all Vault core settings according to input params.\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\n    function updateCoreSettings(\n        uint256 supplyRateMagnifier_,\n        uint256 borrowRateMagnifier_,\n        uint256 collateralFactor_,\n        uint256 liquidationThreshold_,\n        uint256 liquidationMaxLimit_,\n        uint256 withdrawGap_,\n        uint256 liquidationPenalty_,\n        uint256 borrowFee_\n    ) public _updateExchangePrice _verifyCaller {\n        // emitting the event at the start as then we are updating numbers to store in a more optimized way\n        emit LogUpdateCoreSettings(\n            supplyRateMagnifier_,\n            borrowRateMagnifier_,\n            collateralFactor_,\n            liquidationThreshold_,\n            liquidationMaxLimit_,\n            withdrawGap_,\n            liquidationPenalty_,\n            borrowFee_\n        );\n\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        collateralFactor_ = collateralFactor_ / 10;\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n        withdrawGap_ = withdrawGap_ / 10;\n\n        if (\n            (supplyRateMagnifier_ > X16) ||\n            (borrowRateMagnifier_ > X16) ||\n            (collateralFactor_ >= liquidationThreshold_) ||\n            (liquidationThreshold_ >= liquidationMaxLimit_) ||\n            (withdrawGap_ > X10) ||\n            (liquidationPenalty_ > X10) ||\n            (borrowFee_ > X10)\n        ) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff00000000000000000000000) |\n            supplyRateMagnifier_ |\n            (borrowRateMagnifier_ << 16) |\n            (collateralFactor_ << 32) |\n            (liquidationThreshold_ << 42) |\n            (liquidationMaxLimit_ << 52) |\n            (withdrawGap_ << 62) |\n            (liquidationPenalty_ << 72) |\n            (borrowFee_ << 82);\n    }\n\n    /// @notice updates the Vault oracle to `newOracle_`. Must implement the FluidOracle interface.\n    function updateOracle(address newOracle_) public _updateExchangePrice _verifyCaller {\n        if (newOracle_ == address(0)) revert FluidVaultError(ErrorTypes.VaultAdmin__AddressZeroNotAllowed);\n\n        // Removing current oracle by masking only first 96 bits then inserting new oracle as bits\n        vaultVariables2 = (vaultVariables2 & X96) | (uint256(uint160(newOracle_)) << 96);\n\n        emit LogUpdateOracle(newOracle_);\n    }\n\n    /// @notice updates the allowed rebalancer to `newRebalancer_`.\n    function updateRebalancer(address newRebalancer_) public _updateExchangePrice _verifyCaller {\n        if (newRebalancer_ == address(0)) revert FluidVaultError(ErrorTypes.VaultAdmin__AddressZeroNotAllowed);\n\n        rebalancer = newRebalancer_;\n\n        emit LogUpdateRebalancer(newRebalancer_);\n    }\n\n    /// @notice sends any potentially stuck funds to Liquidity contract.\n    /// @dev this contract never holds any funds as all operations send / receive funds from user <-> Liquidity.\n    function rescueFunds(address token_) external _verifyCaller {\n        if (token_ == NATIVE_TOKEN) {\n            SafeTransfer.safeTransferNative(IFluidVaultT1(address(this)).LIQUIDITY(), address(this).balance);\n        } else {\n            SafeTransfer.safeTransfer(\n                token_,\n                IFluidVaultT1(address(this)).LIQUIDITY(),\n                IERC20(token_).balanceOf(address(this))\n            );\n        }\n\n        emit LogRescueFunds(token_);\n    }\n\n    /// @notice absorbs accumulated dust debt\n    /// @dev in decades if a lot of positions are 100% liquidated (aka absorbed) then dust debt can mount up\n    /// which is basically sort of an extra revenue for the protocol.\n    //\n    // this function might never come in use that's why adding it in admin module\n    function absorbDustDebt(uint[] memory nftIds_) public _verifyCaller {\n        uint256 vaultVariables_ = vaultVariables;\n        // re-entrancy check\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        uint nftId_;\n        uint posData_;\n        int posTick_;\n        uint tickId_;\n        uint posCol_;\n        uint posDebt_;\n        uint posDustDebt_;\n        uint tickData_;\n\n        uint absorbedDustDebt_ = absorbedDustDebt;\n\n        for (uint i = 0; i < nftIds_.length; ) {\n            nftId_ = nftIds_[i];\n            if (nftId_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftIdShouldBeNonZero);\n            }\n\n            // user's position data\n            posData_ = positionData[nftId_];\n\n            if (posData_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotOfThisVault);\n            }\n\n            posCol_ = (posData_ >> 45) & X64;\n            // Converting big number into normal number\n            posCol_ = (posCol_ >> 8) << (posCol_ & X8);\n\n            posDustDebt_ = (posData_ >> 109) & X64;\n            // Converting big number into normal number\n            posDustDebt_ = (posDustDebt_ >> 8) << (posDustDebt_ & X8);\n\n            if (posDustDebt_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__DustDebtIsZero);\n            }\n\n            // borrow position (has collateral & debt)\n            posTick_ = posData_ & 2 == 2 ? int((posData_ >> 2) & X19) : -int((posData_ >> 2) & X19);\n            tickId_ = (posData_ >> 21) & X24;\n\n            posDebt_ = (TickMath.getRatioAtTick(int24(posTick_)) * posCol_) >> 96;\n\n            // Tick data from user's tick\n            tickData_ = tickData[posTick_];\n\n            // Checking if tick is liquidated OR if the total IDs of tick is greater than user's tick ID\n            if (((tickData_ & 1) == 1) || (((tickData_ >> 1) & X24) > tickId_)) {\n                // User got liquidated\n                (, posDebt_, , , ) = IFluidVaultT1(address(this)).fetchLatestPosition(\n                    posTick_,\n                    tickId_,\n                    posDebt_,\n                    tickData_\n                );\n                if (posDebt_ > 0) {\n                    revert FluidVaultError(ErrorTypes.VaultAdmin__FinalDebtShouldBeZero);\n                }\n                // absorbing user's debt as it's 100% or almost 100% liquidated\n                absorbedDustDebt_ = absorbedDustDebt_ + posDustDebt_;\n                // making position as supply only\n                positionData[nftId_] = 1;\n            } else {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotLiquidated);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n\n        if (absorbedDustDebt_ == 0) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__AbsorbedDustDebtIsZero);\n        }\n\n        uint totalBorrow_ = (vaultVariables_ >> 146) & X64;\n        // Converting big number into normal number\n        totalBorrow_ = (totalBorrow_ >> 8) << (totalBorrow_ & X8);\n        // note: by default dust debt is not added into total borrow but on 100% liquidation (aka absorb) dust debt equivalent\n        // is removed from total borrow so adding it back again here\n        totalBorrow_ = totalBorrow_ + absorbedDustDebt_;\n        totalBorrow_ = BigMathMinified.toBigNumber(totalBorrow_, 56, 8, BigMathMinified.ROUND_UP);\n\n        // adding absorbed dust debt to total borrow so it will get included in the next rebalancing.\n        // there is some fuzziness here as when the position got fully liquidated (aka absorbed) the exchange price was different\n        // than what it'll be now. The fuzziness which will be extremely small so we can ignore it\n        // updating on storage\n        vaultVariables =\n            (vaultVariables_ & 0xfffffffffffc0000000000000003ffffffffffffffffffffffffffffffffffff) |\n            (totalBorrow_ << 146);\n\n        // updating on storage\n        absorbedDustDebt = 0;\n\n        emit LogAbsorbDustDebt(nftIds_, absorbedDustDebt_);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT1/common/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Variables {\n    /***********************************|\n    |         Storage Variables         |\n    |__________________________________*/\n\n    /// note: in all variables. For tick >= 0 are represented with bit as 1, tick < 0 are represented with bit as 0\n    /// note: read all the variables through storageRead.sol\n\n    /// note: vaultVariables contains vault variables which need regular updates through transactions\n    /// First 1 bit => 0 => re-entrancy. If 0 then allow transaction to go, else throw.\n    /// Next 1 bit => 1 => Is the current active branch liquidated? If true then check the branch's minima tick before creating a new position\n    /// If the new tick is greater than minima tick then initialize a new branch, make that as current branch & do proper linking\n    /// Next 1 bit => 2 => sign of topmost tick (0 -> negative; 1 -> positive)\n    /// Next 19 bits => 3-21 => absolute value of topmost tick\n    /// Next 30 bits => 22-51 => current branch ID\n    /// Next 30 bits => 52-81 => total branch ID\n    /// Next 64 bits => 82-145 => Total supply\n    /// Next 64 bits => 146-209 => Total borrow\n    /// Next 32 bits => 210-241 => Total positions\n    uint256 internal vaultVariables;\n\n    /// note: vaultVariables2 contains variables which do not update on every transaction. So mainly admin/auth set amount\n    /// First 16 bits => 0-15 => supply rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\n    /// Next 16 bits => 16-31 => borrow rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\n    /// Next 10 bits => 32-41 => collateral factor. 800 = 0.8 = 80% (max precision of 0.1%)\n    /// Next 10 bits => 42-51 => liquidation Threshold. 900 = 0.9 = 90% (max precision of 0.1%)\n    /// Next 10 bits => 52-61 => liquidation Max Limit. 950 = 0.95 = 95% (max precision of 0.1%) (above this 100% liquidation can happen)\n    /// Next 10 bits => 62-71 => withdraw gap. 100 = 0.1 = 10%. (max precision of 0.1%) (max 7 bits can also suffice for the requirement here of 0.1% to 10%). Needed to save some limits on withdrawals so liquidate can work seamlessly.\n    /// Next 10 bits => 72-81 => liquidation penalty. 100 = 0.01 = 1%. (max precision of 0.01%) (max liquidation penantly can be 10.23%). Applies when tick is in between liquidation Threshold & liquidation Max Limit.\n    /// Next 10 bits => 82-91 => borrow fee. 100 = 0.01 = 1%. (max precision of 0.01%) (max borrow fee can be 10.23%). Fees on borrow.\n    /// Next 4  bits => 92-95 => empty\n    /// Next 160 bits => 96-255 => Oracle address\n    uint256 internal vaultVariables2;\n\n    /// note: stores absorbed liquidity\n    /// First 128 bits raw debt amount\n    /// last 128 bits raw col amount\n    uint256 internal absorbedLiquidity;\n\n    /// position index => position data uint\n    /// if the entire variable is 0 (meaning not initialized) at the start that means no position at all\n    /// First 1 bit => 0 => position type (0 => borrow position; 1 => supply position)\n    /// Next 1 bit => 1 => sign of user's tick (0 => negative; 1 => positive)\n    /// Next 19 bits => 2-20 => absolute value of user's tick\n    /// Next 24 bits => 21-44 => user's tick's id\n    /// Below we are storing user's collateral & not debt, because the position can also be only collateral with no tick but it can never be only debt\n    /// Next 64 bits => 45-108 => user's supply amount. Debt will be calculated through supply & ratio.\n    /// Next 64 bits => 109-172 => user's dust debt amount. User's net debt = total debt - dust amount. Total debt is calculated through supply & ratio\n    /// User won't pay any extra interest on dust debt & hence we will not show it as a debt on UI. For user's there's no dust.\n    mapping(uint256 => uint256) internal positionData;\n\n    /// Tick has debt only keeps data of non liquidated positions. liquidated tick's data stays in branch itself\n    /// tick parent => uint (represents bool for 256 children)\n    /// parent of (i)th tick:-\n    /// if (i>=0) (i / 256);\n    /// else ((i + 1) / 256) - 1\n    /// first bit of the variable is the smallest tick & last bit is the biggest tick of that slot\n    mapping(int256 => uint256) internal tickHasDebt;\n\n    /// mapping tickId => tickData\n    /// Tick related data. Total debt & other things\n    /// First bit => 0 => If 1 then liquidated else not liquidated\n    /// Next 24 bits => 1-24 => Total IDs. ID should start from 1.\n    /// If not liquidated:\n    /// Next 64 bits => 25-88 => raw debt\n    /// If liquidated\n    /// The below 3 things are of last ID. This is to be updated when user creates a new position\n    /// Next 1 bit => 25 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated (100% liquidated)\n    /// Next 30 bits => 26-55 => branch ID where this tick got liquidated\n    /// Next 50 bits => 56-105 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    mapping(int256 => uint256) internal tickData;\n\n    /// tick id => previous tick id liquidation data. ID starts from 1\n    /// One tick ID contains 3 IDs of 80 bits in it, holding liquidation data of previously active but liquidated ticks\n    /// 81 bits data below\n    /// #### First 85 bits ####\n    /// 1st bit => 0 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 1-30 => branch ID where this tick got liquidated\n    /// Next 50 bits => 31-80 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    /// #### Second 85 bits ####\n    /// 85th bit => 85 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 86-115 => branch ID where this tick got liquidated\n    /// Next 50 bits => 116-165 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    /// #### Third 85 bits ####\n    /// 170th bit => 170 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 171-200 => branch ID where this tick got liquidated\n    /// Next 50 bits => 201-250 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    mapping(int256 => mapping(uint256 => uint256)) internal tickId;\n\n    /// mapping branchId => branchData\n    /// First 2 bits => 0-1 => if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\n    /// merged means the branch is merged into it's base branch\n    /// closed means all the users are 100% liquidated\n    /// Next 1 bit => 2 => minima tick sign of this branch. Will only be there if any liquidation happened.\n    /// Next 19 bits => 3-21 => minima tick of this branch. Will only be there if any liquidation happened.\n    /// Next 30 bits => 22-51 => Partials of minima tick of branch this is connected to. 0 if master branch.\n    /// Next 64 bits => 52-115 Debt liquidity at this branch. Similar to last's top tick data. Remaining debt will move here from tickData after first liquidation\n    /// If not merged\n    /// Next 50 bits => 116-165 => Debt factor or of this branch. (35 bits coefficient | 15 bits expansion)\n    /// If merged\n    /// Next 50 bits => 116-165 => Connection/adjustment debt factor of this branch with the next branch.\n    /// If closed\n    /// Next 50 bits => 116-165 => Debt factor as 0. As all the user's positions are now fully gone\n    /// following values are present always again (merged / not merged / closed)\n    /// Next 30 bits => 166-195 => Branch's ID with which this branch is connected. If 0 then that means this is the master branch\n    /// Next 1 bit => 196 => sign of minima tick of branch this is connected to. 0 if master branch.\n    /// Next 19 bits => 197-215 => minima tick of branch this is connected to. 0 if master branch.\n    mapping(uint256 => uint256) internal branchData;\n\n    /// Exchange prices are in 1e12\n    /// First 64 bits => 0-63 => Liquidity's collateral token supply exchange price\n    /// First 64 bits => 64-127 => Liquidity's debt token borrow exchange price\n    /// First 64 bits => 128-191 => Vault's collateral token supply exchange price\n    /// First 64 bits => 192-255 => Vault's debt token borrow exchange price\n    uint256 internal rates;\n\n    /// address of rebalancer\n    address internal rebalancer;\n\n    uint256 internal absorbedDustDebt;\n}\n"
    },
    "contracts/protocols/vault/vaultT1/coreModule/constantVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidVaultFactory } from \"../../interfaces/iVaultFactory.sol\";\nimport { IFluidLiquidity } from \"../../../../liquidity/interfaces/iLiquidity.sol\";\nimport { StorageRead } from \"../../../../libraries/storageRead.sol\";\n\nimport { Structs } from \"./structs.sol\";\n\ninterface TokenInterface {\n    function decimals() external view returns (uint8);\n}\n\ncontract ConstantVariables is StorageRead, Structs {\n    /***********************************|\n    |        Constant Variables         |\n    |__________________________________*/\n\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    /// @dev collateral token address\n    address internal immutable SUPPLY_TOKEN;\n    /// @dev borrow token address\n    address internal immutable BORROW_TOKEN;\n\n    /// @dev Token decimals. For example wETH is 18 decimals\n    uint8 internal immutable SUPPLY_DECIMALS;\n    /// @dev Token decimals. For example USDC is 6 decimals\n    uint8 internal immutable BORROW_DECIMALS;\n\n    /// @dev VaultT1 AdminModule implemenation address\n    address internal immutable ADMIN_IMPLEMENTATION;\n\n    /// @dev VaultT1 Secondary implemenation (main2.sol) address\n    address internal immutable SECONDARY_IMPLEMENTATION;\n\n    /// @dev liquidity proxy contract address\n    IFluidLiquidity public immutable LIQUIDITY;\n\n    /// @dev vault factory contract address\n    IFluidVaultFactory public immutable VAULT_FACTORY;\n\n    uint public immutable VAULT_ID;\n\n    uint internal constant X8 = 0xff;\n    uint internal constant X10 = 0x3ff;\n    uint internal constant X16 = 0xffff;\n    uint internal constant X19 = 0x7ffff;\n    uint internal constant X20 = 0xfffff;\n    uint internal constant X24 = 0xffffff;\n    uint internal constant X25 = 0x1ffffff;\n    uint internal constant X30 = 0x3fffffff;\n    uint internal constant X35 = 0x7ffffffff;\n    uint internal constant X50 = 0x3ffffffffffff;\n    uint internal constant X64 = 0xffffffffffffffff;\n    uint internal constant X96 = 0xffffffffffffffffffffffff;\n    uint internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev slot ids in Liquidity contract. Helps in low gas fetch from liquidity contract by skipping delegate call\n    bytes32 internal immutable LIQUIDITY_SUPPLY_EXCHANGE_PRICE_SLOT;\n    bytes32 internal immutable LIQUIDITY_BORROW_EXCHANGE_PRICE_SLOT;\n    bytes32 internal immutable LIQUIDITY_USER_SUPPLY_SLOT;\n    bytes32 internal immutable LIQUIDITY_USER_BORROW_SLOT;\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_) {\n        constantsView_.liquidity = address(LIQUIDITY);\n        constantsView_.factory = address(VAULT_FACTORY);\n        constantsView_.adminImplementation = ADMIN_IMPLEMENTATION;\n        constantsView_.secondaryImplementation = SECONDARY_IMPLEMENTATION;\n        constantsView_.supplyToken = SUPPLY_TOKEN;\n        constantsView_.borrowToken = BORROW_TOKEN;\n        constantsView_.supplyDecimals = SUPPLY_DECIMALS;\n        constantsView_.borrowDecimals = BORROW_DECIMALS;\n        constantsView_.vaultId = VAULT_ID;\n        constantsView_.liquiditySupplyExchangePriceSlot = LIQUIDITY_SUPPLY_EXCHANGE_PRICE_SLOT;\n        constantsView_.liquidityBorrowExchangePriceSlot = LIQUIDITY_BORROW_EXCHANGE_PRICE_SLOT;\n        constantsView_.liquidityUserSupplySlot = LIQUIDITY_USER_SUPPLY_SLOT;\n        constantsView_.liquidityUserBorrowSlot = LIQUIDITY_USER_BORROW_SLOT;\n    }\n\n    constructor(ConstantViews memory constants_) {\n        LIQUIDITY = IFluidLiquidity(constants_.liquidity);\n        VAULT_FACTORY = IFluidVaultFactory(constants_.factory);\n        VAULT_ID = constants_.vaultId;\n\n        SUPPLY_TOKEN = constants_.supplyToken;\n        BORROW_TOKEN = constants_.borrowToken;\n        SUPPLY_DECIMALS = constants_.supplyDecimals;\n        BORROW_DECIMALS = constants_.borrowDecimals;\n\n        // @dev those slots are calculated in the deploymentLogics / VaultFactory\n        LIQUIDITY_SUPPLY_EXCHANGE_PRICE_SLOT = constants_.liquiditySupplyExchangePriceSlot;\n        LIQUIDITY_BORROW_EXCHANGE_PRICE_SLOT = constants_.liquidityBorrowExchangePriceSlot;\n        LIQUIDITY_USER_SUPPLY_SLOT = constants_.liquidityUserSupplySlot;\n        LIQUIDITY_USER_BORROW_SLOT = constants_.liquidityUserBorrowSlot;\n\n        ADMIN_IMPLEMENTATION = constants_.adminImplementation;\n        SECONDARY_IMPLEMENTATION = constants_.secondaryImplementation;\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT1/coreModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Events {\n    /// @notice emitted when an operate() method is executed that changes collateral (`colAmt_`) / debt (debtAmt_`)\n    /// amount for a `user_` position with `nftId_`. Receiver of any funds is the address `to_`.\n    event LogOperate(address user_, uint256 nftId_, int256 colAmt_, int256 debtAmt_, address to_);\n\n    /// @notice emitted when the exchange prices are updated in storage.\n    event LogUpdateExchangePrice(uint256 supplyExPrice_, uint256 borrowExPrice_);\n\n    /// @notice emitted when a liquidation has been executed.\n    event LogLiquidate(address liquidator_, uint256 colAmt_, uint256 debtAmt_, address to_);\n\n    /// @notice emitted when `absorb()` was executed to absorb bad debt.\n    event LogAbsorb(uint colAbsorbedRaw_, uint debtAbsorbedRaw_);\n\n    /// @notice emitted when a `rebalance()` has been executed, balancing out total supply / borrow between Vault\n    /// and Fluid Liquidity pools.\n    /// if `colAmt_` is positive then loss, meaning transfer from rebalancer address to vault and deposit.\n    /// if `colAmt_` is negative then profit, meaning withdrawn from vault and sent to rebalancer address.\n    /// if `debtAmt_` is positive then profit, meaning borrow from vault and sent to rebalancer address.\n    /// if `debtAmt_` is negative then loss, meaning transfer from rebalancer address to vault and payback.\n    event LogRebalance(int colAmt_, int debtAmt_);\n}\n"
    },
    "contracts/protocols/vault/vaultT1/coreModule/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Variables } from \"../common/variables.sol\";\nimport { ConstantVariables } from \"./constantVariables.sol\";\nimport { Events } from \"./events.sol\";\nimport { TickMath } from \"../../../../libraries/tickMath.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { BigMathVault } from \"../../../../libraries/bigMathVault.sol\";\nimport { LiquidityCalcs } from \"../../../../libraries/liquidityCalcs.sol\";\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\n\n/// @dev Fluid vault protocol helper methods. Mostly used for `operate()` and `liquidate()` methods of CoreModule.\nabstract contract Helpers is Variables, ConstantVariables, Events, Error {\n    using BigMathMinified for uint256;\n    using BigMathVault for uint256;\n\n    /// @notice Calculates new vault exchange prices. Does not update values in storage.\n    /// @param vaultVariables2_ exactly same as vaultVariables2 from storage\n    /// @return liqSupplyExPrice_ latest liquidity's supply token supply exchange price\n    /// @return liqBorrowExPrice_ latest liquidity's borrow token borrow exchange price\n    /// @return vaultSupplyExPrice_ latest vault's supply token exchange price\n    /// @return vaultBorrowExPrice_ latest vault's borrow token exchange price\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        public\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        )\n    {\n        // Fetching last stored rates\n        uint rates_ = rates;\n\n        (liqSupplyExPrice_, ) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(LIQUIDITY_SUPPLY_EXCHANGE_PRICE_SLOT)\n        );\n        (, liqBorrowExPrice_) = LiquidityCalcs.calcExchangePrices(\n            LIQUIDITY.readFromStorage(LIQUIDITY_BORROW_EXCHANGE_PRICE_SLOT)\n        );\n\n        uint256 oldLiqSupplyExPrice_ = (rates_ & X64);\n        uint256 oldLiqBorrowExPrice_ = ((rates_ >> 64) & X64);\n        if (liqSupplyExPrice_ < oldLiqSupplyExPrice_ || liqBorrowExPrice_ < oldLiqBorrowExPrice_) {\n            // new liquidity exchange price is < than the old one. liquidity exchange price should only ever increase.\n            // If not, something went wrong and avoid proceeding with unknown outcome.\n            revert FluidVaultError(ErrorTypes.Vault__LiquidityExchangePriceUnexpected);\n        }\n\n        // liquidity Exchange Prices always increases in next block. Hence substraction with old will never be negative\n        // uint64 * 1e18 is the max the number that could be\n        unchecked {\n            // Calculating increase in supply exchange price w.r.t last stored liquidity's exchange price\n            // vaultSupplyExPrice_ => supplyIncreaseInPercent_\n            vaultSupplyExPrice_ = ((((liqSupplyExPrice_ * 1e18) / oldLiqSupplyExPrice_) - 1e18) *\n                (vaultVariables2_ & X16)) / 10000; // supply rate magnifier\n\n            // Calculating increase in borrow exchange price w.r.t last stored liquidity's exchange price\n            // vaultBorrowExPrice_ => borrowIncreaseInPercent_\n            vaultBorrowExPrice_ = ((((liqBorrowExPrice_ * 1e18) / oldLiqBorrowExPrice_) - 1e18) *\n                ((vaultVariables2_ >> 16) & X16)) / 10000; // borrow rate magnifier\n\n            // It's extremely hard the exchange prices to overflow even in 100 years but if it does it's not an\n            // issue here as we are not updating on storage\n            // (rates_ >> 128) & X64) -> last stored vault's supply token exchange price\n            vaultSupplyExPrice_ = (((rates_ >> 128) & X64) * (1e18 + vaultSupplyExPrice_)) / 1e18;\n            // (rates_ >> 192) -> last stored vault's borrow token exchange price (no need to mask with & X64 as it is anyway max 64 bits)\n            vaultBorrowExPrice_ = ((rates_ >> 192) * (1e18 + vaultBorrowExPrice_)) / 1e18;\n        }\n    }\n\n    /// note admin module is also calling this function self call\n    /// @dev updating exchange price on storage. Only need to update on storage when changing supply or borrow magnifier\n    function updateExchangePricesOnStorage()\n        public\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        )\n    {\n        (liqSupplyExPrice_, liqBorrowExPrice_, vaultSupplyExPrice_, vaultBorrowExPrice_) = updateExchangePrices(\n            vaultVariables2\n        );\n\n        if (\n            liqSupplyExPrice_ > X64 || liqBorrowExPrice_ > X64 || vaultSupplyExPrice_ > X64 || vaultBorrowExPrice_ > X64\n        ) {\n            revert FluidVaultError(ErrorTypes.Vault__ExchangePriceOverFlow);\n        }\n\n        // Updating in storage\n        rates =\n            liqSupplyExPrice_ |\n            (liqBorrowExPrice_ << 64) |\n            (vaultSupplyExPrice_ << 128) |\n            (vaultBorrowExPrice_ << 192);\n\n        emit LogUpdateExchangePrice(vaultSupplyExPrice_, vaultBorrowExPrice_);\n    }\n\n    /// @dev fetches new user's position after liquidation. The new liquidated position's debt is decreased by 0.01%\n    /// to make sure that branch's liquidity never becomes 0 as if it would have gotten 0 then there will be multiple cases that we would need to tackle.\n    /// @param positionTick_ position's tick when it was last updated through operate\n    /// @param positionTickId_ position's tick Id. This stores the debt factor and branch to make the first connection\n    /// @param positionRawDebt_ position's raw debt when it was last updated through operate\n    /// @param tickData_ position's tick's tickData just for minor comparison to know if data is moved to tick Id or is still in tick data\n    /// @return final tick position after all the liquidation\n    /// @return final debt of position after all the liquidation\n    /// @return positionRawCol_ final collateral of position after all the liquidation\n    /// @return branchId_ final branch's ID where the position is at currently\n    /// @return branchData_ final branch's data where the position is at currently\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        public\n        view\n        returns (\n            int256, // positionTick_\n            uint256, // positionRawDebt_\n            uint256 positionRawCol_,\n            uint256 branchId_,\n            uint256 branchData_\n        )\n    {\n        uint256 initialPositionRawDebt_ = positionRawDebt_;\n        uint256 connectionFactor_;\n        bool isFullyLiquidated_;\n\n        // Checking if tick's total ID = user's tick ID\n        if (((tickData_ >> 1) & X24) == positionTickId_) {\n            // fetching from tick data itself\n            isFullyLiquidated_ = ((tickData_ >> 25) & 1) == 1;\n            branchId_ = (tickData_ >> 26) & X30;\n            connectionFactor_ = (tickData_ >> 56) & X50;\n        } else {\n            {\n                uint256 tickLiquidationData_;\n                unchecked {\n                    // Fetching tick's liquidation data. One variable contains data of 3 IDs. Tick Id mapping is starting from 1.\n                    tickLiquidationData_ =\n                        tickId[positionTick_][(positionTickId_ + 2) / 3] >>\n                        (((positionTickId_ + 2) % 3) * 85);\n                }\n\n                isFullyLiquidated_ = (tickLiquidationData_ & 1) == 1;\n                branchId_ = (tickLiquidationData_ >> 1) & X30;\n                connectionFactor_ = (tickLiquidationData_ >> 31) & X50;\n            }\n        }\n\n        // data of branch\n        branchData_ = branchData[branchId_];\n\n        if (isFullyLiquidated_) {\n            positionTick_ = type(int).min;\n            positionRawDebt_ = 0;\n        } else {\n            // Below information about connection debt factor\n            // If branch is merged, Connection debt factor is used to multiply in order to get perfect liquidation of user\n            // For example: Considering user was at the top.\n            // In first branch, the user liquidated to debt factor 0.5 and then branch got merged (branching starting from 1)\n            // In second branch, it got liquidated to 0.4 but when the above branch merged the debt factor on this branch was 0.6\n            // Meaning on 1st branch, user got liquidated by 50% & on 2nd by 33.33%. So a total of 66.6%.\n            // What we will set a connection factor will be 0.6/0.5 = 1.2\n            // So now to get user's position, this is what we'll do:\n            // finalDebt = (0.4 / (1 * 1.2)) * debtBeforeLiquidation\n            // 0.4 is current active branch's minima debt factor\n            // 1 is debt factor from where user started\n            // 1.2 is connection factor which we found out through 0.6 / 0.5\n            while ((branchData_ & 3) == 2) {\n                // If true then the branch is merged\n\n                // userTickDebtFactor * connectionDebtFactor *... connectionDebtFactor aka adjustmentDebtFactor\n                connectionFactor_ = connectionFactor_.mulBigNumber(((branchData_ >> 116) & X50));\n                if (connectionFactor_ == BigMathVault.MAX_MASK_DEBT_FACTOR) break; // user ~100% liquidated\n                // Note we don't need updated branch data in case of 100% liquidated so saving gas for fetching it\n\n                // Fetching new branch data\n                branchId_ = (branchData_ >> 166) & X30; // Link to base branch of current branch\n                branchData_ = branchData[branchId_];\n            }\n            // When the while loop breaks meaning the branch now has minima Debt Factor or is a closed branch;\n\n            if (((branchData_ & 3) == 3) || (connectionFactor_ == BigMathVault.MAX_MASK_DEBT_FACTOR)) {\n                // Branch got closed (or user liquidated ~100%). Hence make the user's position 0\n                // Rare cases to get into this situation\n                // Branch can get close often but once closed it's tricky that some user might come iterating through there\n                // If a user comes then that user will be very mini user like some cents probably\n                positionTick_ = type(int).min;\n                positionRawDebt_ = 0;\n            } else {\n                // If branch is not merged, the main branch it's connected to then it'll have minima debt factor\n\n                // position debt = debt * base branch minimaDebtFactor / connectionFactor\n                positionRawDebt_ = positionRawDebt_.mulDivNormal(\n                    (branchData_ >> 116) & X50, // minimaDebtFactor\n                    connectionFactor_\n                );\n\n                unchecked {\n                    // Reducing user's liquidity by 0.01% if user got liquidated.\n                    // As this will make sure that the branch always have some debt even if all liquidated user left\n                    // This saves a lot more logics & consideration on Operate function\n                    // if we don't do this then we have to add logics related to closing the branch and factor connections accordingly.\n                    if (positionRawDebt_ > (initialPositionRawDebt_ / 100)) {\n                        positionRawDebt_ = (positionRawDebt_ * 9999) / 10000;\n                    } else {\n                        // if user debt reduced by more than 99% in liquidation then making user as fully liquidated\n                        positionRawDebt_ = 0;\n                    }\n                }\n\n                {\n                    if (positionRawDebt_ > 0) {\n                        // positionTick_ -> read minima tick of branch\n                        unchecked {\n                            positionTick_ = branchData_ & 4 == 4\n                                ? int((branchData_ >> 3) & X19)\n                                : -int((branchData_ >> 3) & X19);\n                        }\n                        // Calculating user's collateral\n                        uint256 ratioAtTick_ = TickMath.getRatioAtTick(int24(positionTick_));\n                        uint256 ratioOneLess_;\n                        unchecked {\n                            ratioOneLess_ = (ratioAtTick_ * 10000) / 10015;\n                        }\n                        // formula below for better readability:\n                        // length = ratioAtTick_ - ratioOneLess_\n                        // ratio = ratioOneLess_ + (length * positionPartials_) / X30\n                        // positionRawCol_ = (positionRawDebt_ * (1 << 96)) / ratio_\n                        positionRawCol_ =\n                            (positionRawDebt_ * TickMath.ZERO_TICK_SCALED_RATIO) /\n                            (ratioOneLess_ + ((ratioAtTick_ - ratioOneLess_) * ((branchData_ >> 22) & X30)) / X30);\n                    } else {\n                        positionTick_ = type(int).min;\n                    }\n                }\n            }\n        }\n        return (positionTick_, positionRawDebt_, positionRawCol_, branchId_, branchData_);\n    }\n\n    /// @dev sets `tick_` as having debt or no debt in storage `tickHasDebt` depending on `addOrRemove_`\n    /// @param tick_ tick to add or remove from tickHasDebt\n    /// @param addOrRemove_ if true then add else remove\n    function _updateTickHasDebt(int tick_, bool addOrRemove_) internal {\n        // Positive mapID_ starts from 0 & above and negative starts below 0.\n        // tick 0 to 255 will have mapId_ as 0 while tick -256 to -1 will have mapId_ as -1.\n        unchecked {\n            int mapId_ = tick_ < 0 ? ((tick_ + 1) / 256) - 1 : tick_ / 256;\n\n            // in case of removing:\n            // (tick == 255) tickHasDebt[mapId_] - 1 << 255\n            // (tick == 0) tickHasDebt[mapId_] - 1 << 0\n            // (tick == -1) tickHasDebt[mapId_] - 1 << 255\n            // (tick == -256) tickHasDebt[mapId_] - 1 << 0\n            // in case of adding:\n            // (tick == 255) tickHasDebt[mapId_] - 1 << 255\n            // (tick == 0) tickHasDebt[mapId_] - 1 << 0\n            // (tick == -1) tickHasDebt[mapId_] - 1 << 255\n            // (tick == -256) tickHasDebt[mapId_] - 1 << 0\n            uint position_ = uint(tick_ - (mapId_ * 256));\n\n            tickHasDebt[mapId_] = addOrRemove_\n                ? tickHasDebt[mapId_] | (1 << position_)\n                : tickHasDebt[mapId_] & ~(1 << position_);\n        }\n    }\n\n    /// @dev gets next perfect top tick (tick which is not liquidated)\n    /// @param topTick_ current top tick which will no longer be top tick\n    /// @return nextTick_ next top tick which will become the new top tick\n    function _fetchNextTopTick(int topTick_) internal view returns (int nextTick_) {\n        int mapId_;\n        uint tickHasDebt_;\n\n        unchecked {\n            mapId_ = topTick_ < 0 ? ((topTick_ + 1) / 256) - 1 : topTick_ / 256;\n            uint bitsToRemove_ = uint(-topTick_ + (mapId_ * 256 + 256));\n            // Removing current top tick from tickHasDebt\n            tickHasDebt_ = (tickHasDebt[mapId_] << bitsToRemove_) >> bitsToRemove_;\n\n            // For last user remaining in vault there could be a lot of iterations in the while loop.\n            // Chances of this to happen is extremely low (like ~0%)\n            while (true) {\n                if (tickHasDebt_ > 0) {\n                    nextTick_ = mapId_ * 256 + int(tickHasDebt_.mostSignificantBit()) - 1;\n                    break;\n                }\n\n                // Reducing mapId_ by 1 in every loop; if it reaches to -129 then no filled tick exist, meaning it's the last tick\n                if (--mapId_ == -129) {\n                    nextTick_ = type(int).min;\n                    break;\n                }\n\n                tickHasDebt_ = tickHasDebt[mapId_];\n            }\n        }\n    }\n\n    /// @dev adding debt to a particular tick\n    /// @param totalColRaw_ total raw collateral of position\n    /// @param netDebtRaw_ net raw debt (total debt - dust debt)\n    /// @return tick_ tick where the debt is being added\n    /// @return tickId_ tick current id\n    /// @return userRawDebt_ user's total raw debt\n    /// @return rawDust_ dust debt used for adjustment\n    function _addDebtToTickWrite(\n        uint256 totalColRaw_,\n        uint256 netDebtRaw_ // debtRaw - dust\n    ) internal returns (int256 tick_, uint256 tickId_, uint256 userRawDebt_, uint256 rawDust_) {\n        if (netDebtRaw_ < 10000) {\n            // thrown if user's debt is too low\n            revert FluidVaultError(ErrorTypes.Vault__UserDebtTooLow);\n        }\n        // tick_ & ratio_ returned from library is round down. Hence increasing it by 1 and increasing ratio by 1 tick.\n        uint ratio_ = (netDebtRaw_ * TickMath.ZERO_TICK_SCALED_RATIO) / totalColRaw_;\n        (tick_, ratio_) = TickMath.getTickAtRatio(ratio_);\n        unchecked {\n            ++tick_;\n            ratio_ = (ratio_ * 10015) / 10000;\n        }\n        userRawDebt_ = (ratio_ * totalColRaw_) >> 96;\n        rawDust_ = userRawDebt_ - netDebtRaw_;\n\n        // Current state of tick\n        uint256 tickData_ = tickData[tick_];\n        tickId_ = (tickData_ >> 1) & X24;\n\n        uint tickNewDebt_;\n        if (tickId_ > 0 && tickData_ & 1 == 0) {\n            // Current debt in the tick\n            uint256 tickExistingRawDebt_ = (tickData_ >> 25) & X64;\n            tickExistingRawDebt_ = (tickExistingRawDebt_ >> 8) << (tickExistingRawDebt_ & X8);\n\n            // Tick's already initialized and not liquidated. Hence simply add the debt\n            tickNewDebt_ = tickExistingRawDebt_ + userRawDebt_;\n            if (tickExistingRawDebt_ == 0) {\n                // Adding tick into tickHasDebt\n                _updateTickHasDebt(tick_, true);\n            }\n        } else {\n            // Liquidation happened or tick getting initialized for the very first time.\n            if (tickId_ > 0) {\n                // Meaning a liquidation happened. Hence move the data to tickID\n                unchecked {\n                    uint tickMap_ = (tickId_ + 2) / 3;\n                    // Adding 2 in ID so we can get right mapping ID. For example for ID 1, 2 & 3 mapping should be 1 and so on..\n                    // For example shift for id 1 should be 0, for id 2 should be 85, for id 3 it should be 170 and so on..\n                    tickId[tick_][tickMap_] =\n                        tickId[tick_][tickMap_] |\n                        ((tickData_ >> 25) << (((tickId_ + 2) % 3) * 85));\n                }\n            }\n            // Increasing total ID by one\n            unchecked {\n                ++tickId_;\n            }\n            tickNewDebt_ = userRawDebt_;\n\n            // Adding tick into tickHasDebt\n            _updateTickHasDebt(tick_, true);\n        }\n        if (tickNewDebt_ < 10000) {\n            // thrown if tick's debt/liquidity is too low\n            revert FluidVaultError(ErrorTypes.Vault__TickDebtTooLow);\n        }\n        tickData[tick_] = (tickId_ << 1) | (tickNewDebt_.toBigNumber(56, 8, BigMathMinified.ROUND_DOWN) << 25);\n    }\n\n    /// @dev sets new top tick. If it comes to this function then that means current top tick is perfect tick.\n    /// if next top tick is liquidated then unitializes the current non liquidated branch and make the liquidated branch as current branch\n    /// @param topTick_ current top tick\n    /// @param vaultVariables_ vaultVariables of storage but with newer updates\n    /// @return newVaultVariables_ newVaultVariables_ updated vault variable internally to this function\n    /// @return newTopTick_ new top tick\n    function _setNewTopTick(\n        int topTick_,\n        uint vaultVariables_\n    ) internal returns (uint newVaultVariables_, int newTopTick_) {\n        // This function considers that the current top tick was not liquidated\n        // Overall flow of function:\n        // if new top tick liquidated (aka base branch's minima tick) -> Close the current branch and make base branch as current branch\n        // if new top tick not liquidated -> update things in current branch.\n        // if new top tick is not liquidated and same tick exist in base branch then tick is considered as not liquidated.\n\n        uint branchId_ = (vaultVariables_ >> 22) & X30; // branch id of current branch\n\n        uint256 branchData_ = branchData[branchId_];\n        int256 baseBranchMinimaTick_;\n        if ((branchData_ >> 196) & 1 == 1) {\n            baseBranchMinimaTick_ = int((branchData_ >> 197) & X19);\n        } else {\n            unchecked {\n                baseBranchMinimaTick_ = -int((branchData_ >> 197) & X19);\n            }\n            if (baseBranchMinimaTick_ == 0) {\n                // meaning the current branch is the master branch\n                baseBranchMinimaTick_ = type(int).min;\n            }\n        }\n\n        // Returns type(int).min if no top tick exist\n        int nextTopTickNotLiquidated_ = _fetchNextTopTick(topTick_);\n\n        newTopTick_ = baseBranchMinimaTick_ > nextTopTickNotLiquidated_\n            ? baseBranchMinimaTick_\n            : nextTopTickNotLiquidated_;\n\n        if (newTopTick_ == type(int).min) {\n            // if this happens that means this was the last user of the vault :(\n            vaultVariables_ = vaultVariables_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00001;\n        } else if (newTopTick_ == nextTopTickNotLiquidated_) {\n            // New top tick exist in current non liquidated branch\n            if (newTopTick_ < 0) {\n                unchecked {\n                    vaultVariables_ =\n                        (vaultVariables_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00001) |\n                        (uint(-newTopTick_) << 3);\n                }\n            } else {\n                vaultVariables_ =\n                    (vaultVariables_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00001) |\n                    4 | // setting top tick as positive\n                    (uint(newTopTick_) << 3);\n            }\n        } else {\n            // if this happens that means base branch exists & is the next top tick\n            // Remove current non liquidated branch as active.\n            // Not deleting here as it's going to get initialize again whenever a new top tick comes\n            branchData[branchId_] = 0;\n            // Inserting liquidated branch's minima tick\n            unchecked {\n                vaultVariables_ =\n                    (vaultVariables_ & 0xfffffffffffffffffffffffffffffffffffffffffffc00000000000000000001) |\n                    2 | // Setting top tick as liquidated\n                    (((branchData_ >> 196) & X20) << 2) | // new current top tick = base branch minima tick\n                    (((branchData_ >> 166) & X30) << 22) | // new current branch id = base branch id\n                    ((branchId_ - 1) << 52); // reduce total branch id by 1\n            }\n        }\n\n        newVaultVariables_ = vaultVariables_;\n    }\n\n    constructor(ConstantViews memory constants_) ConstantVariables(constants_) {}\n}\n"
    },
    "contracts/protocols/vault/vaultT1/coreModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n\nimport { IFluidOracle } from \"../../../../oracle/fluidOracle.sol\";\n\nimport { TickMath } from \"../../../../libraries/tickMath.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { BigMathVault } from \"../../../../libraries/bigMathVault.sol\";\nimport { LiquidityCalcs } from \"../../../../libraries/liquidityCalcs.sol\";\nimport { SafeTransfer } from \"../../../../libraries/safeTransfer.sol\";\n\nimport { Helpers } from \"./helpers.sol\";\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\n\n/// @notice Fluid \"VaultT1\" (Vault Type 1). Fluid vault protocol main contract.\n///         Fluid Vault protocol is a borrow / lending protocol, allowing users to create collateral / borrow positions.\n///         All funds are deposited into / borrowed from Fluid Liquidity layer.\n///         Positions are represented through NFTs minted by the VaultFactory.\n///         Deployed by \"VaultFactory\" and linked together with VaultT1 AdminModule `ADMIN_IMPLEMENTATION` and\n///         FluidVaultT1Secondary (main2.sol) `SECONDARY_IMPLEMENTATION`.\n///         AdminModule & FluidVaultT1Secondary methods are delegateCalled, if the msg.sender has the required authorization.\n///         This contract links to an Oracle, which is used to assess collateral / debt value. Oracles implement the\n///         \"FluidOracle\" base contract and return the price in 1e27 precision.\n/// @dev    For view methods / accessing data, use the \"VaultResolver\" periphery contract.\n//\n// vaults can only be deployed for tokens that are listed at Liquidity (constructor reverts otherwise\n// if either the exchange price for the supply token or the borrow token is still not set at Liquidity).\ncontract FluidVaultT1 is Helpers {\n    using BigMathMinified for uint256;\n    using BigMathVault for uint256;\n\n    /// @dev Single function which handles supply, withdraw, borrow & payback\n    /// @param nftId_ NFT ID for interaction. If 0 then create new NFT/position.\n    /// @param newCol_ new collateral. If positive then deposit, if negative then withdraw, if 0 then do nohing\n    /// @param newDebt_ new debt. If positive then borrow, if negative then payback, if 0 then do nohing\n    /// @param to_ address where withdraw or borrow should go. If address(0) then msg.sender\n    /// @return nftId_ if 0 then this returns the newly created NFT Id else returns the same NFT ID\n    /// @return newCol_ final supply amount. Mainly if max withdraw using type(int).min then this is useful to get perfect amount else remain same as newCol_\n    /// @return newDebt_ final borrow amount. Mainly if max payback using type(int).min then this is useful to get perfect amount else remain same as newDebt_\n    function operate(\n        uint256 nftId_, // if 0 then new position\n        int256 newCol_, // if negative then withdraw\n        int256 newDebt_, // if negative then payback\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\n    )\n        public\n        payable\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        )\n    {\n        uint256 vaultVariables_ = vaultVariables;\n        // re-entrancy check\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        if (\n            (newCol_ == 0 && newDebt_ == 0) ||\n            // withdrawal or deposit cannot be too small\n            ((newCol_ != 0) && (newCol_ > -10000 && newCol_ < 10000)) ||\n            // borrow or payback cannot be too small\n            ((newDebt_ != 0) && (newDebt_ > -10000 && newDebt_ < 10000))\n        ) {\n            revert FluidVaultError(ErrorTypes.Vault__InvalidOperateAmount);\n        }\n\n        // Check msg.value aligns with input amounts if supply or borrow token is native token.\n        // Note that it's not possible for a vault to have both supply token and borrow token as native token.\n        if (SUPPLY_TOKEN == NATIVE_TOKEN && newCol_ > 0) {\n            if (uint(newCol_) != msg.value) {\n                revert FluidVaultError(ErrorTypes.Vault__InvalidMsgValueOperate);\n            }\n        } else if (msg.value > 0) {\n            if (!(BORROW_TOKEN == NATIVE_TOKEN && newDebt_ < 0)) {\n                // msg.value sent along for withdraw, borrow, or non-native token operations\n                revert FluidVaultError(ErrorTypes.Vault__InvalidMsgValueOperate);\n            }\n        }\n\n        OperateMemoryVars memory o_;\n        // Temporary variables used as helpers at many places\n        uint256 temp_;\n        uint256 temp2_;\n        int256 temp3_;\n\n        o_.vaultVariables2 = vaultVariables2;\n\n        temp_ = (vaultVariables_ >> 2) & X20;\n        unchecked {\n            o_.topTick = (temp_ == 0) ? type(int).min : ((temp_ & 1) == 1)\n                ? int((temp_ >> 1) & X19)\n                : -int((temp_ >> 1) & X19);\n        }\n\n        {\n            // Fetching user's position\n            if (nftId_ == 0) {\n                // creating new position.\n                o_.tick = type(int).min;\n                // minting new NFT vault for user.\n                nftId_ = VAULT_FACTORY.mint(VAULT_ID, msg.sender);\n                // Adding 1 in total positions. Total positions cannot exceed 32bits as NFT minting checks for that\n                unchecked {\n                    vaultVariables_ = vaultVariables_ + (1 << 210);\n                }\n            } else {\n                // Updating existing position\n\n                // checking owner only in case of withdraw or borrow\n                if ((newCol_ < 0 || newDebt_ > 0) && (VAULT_FACTORY.ownerOf(nftId_) != msg.sender)) {\n                    revert FluidVaultError(ErrorTypes.Vault__NotAnOwner);\n                }\n\n                // temp_ => user's position data\n                temp_ = positionData[nftId_];\n\n                if (temp_ == 0) {\n                    revert FluidVaultError(ErrorTypes.Vault__NftNotOfThisVault);\n                }\n                // temp2_ => user's supply amount\n                temp2_ = (temp_ >> 45) & X64;\n                // Converting big number into normal number\n                o_.colRaw = (temp2_ >> 8) << (temp2_ & X8);\n                // temp2_ => user's  dust debt amount\n                temp2_ = (temp_ >> 109) & X64;\n                // Converting big number into normal number\n                o_.dustDebtRaw = (temp2_ >> 8) << (temp2_ & X8);\n\n                // 1 is supply & 0 is borrow\n                if (temp_ & 1 == 1) {\n                    // only supply position (has no debt)\n                    o_.tick = type(int).min;\n                } else {\n                    // borrow position (has collateral & debt)\n                    unchecked {\n                        o_.tick = temp_ & 2 == 2 ? int((temp_ >> 2) & X19) : -int((temp_ >> 2) & X19);\n                    }\n                    o_.tickId = (temp_ >> 21) & X24;\n                }\n            }\n        }\n\n        // Get latest updated Position's debt & supply (if position is with debt -> not new / supply position)\n        if (o_.tick > type(int).min) {\n            // if entering this if statement then temp_ here will always be user's position data\n            // extracting collateral exponent\n            temp_ = (temp_ >> 45) & X8;\n            // if exponent is > 0 then rounding up the collateral just for calculating debt\n            unchecked {\n                temp_ = temp_ == 0 ? (o_.colRaw + 1) : o_.colRaw + (1 << temp_);\n            }\n            // fetch current debt\n            o_.debtRaw = ((TickMath.getRatioAtTick(int24(o_.tick)) * temp_) >> 96) + 1;\n\n            // Tick data from user's tick\n            temp_ = tickData[o_.tick];\n\n            // Checking if tick is liquidated (first bit 1) OR if the total IDs of tick is greater than user's tick ID\n            if (((temp_ & 1) == 1) || (((temp_ >> 1) & X24) > o_.tickId)) {\n                // User got liquidated\n                (\n                    // returns the position of the user if the user got liquidated.\n                    o_.tick,\n                    o_.debtRaw,\n                    o_.colRaw,\n                    temp2_, // final branchId from liquidation where position exist right now\n                    o_.branchData\n                ) = fetchLatestPosition(o_.tick, o_.tickId, o_.debtRaw, temp_);\n\n                if (o_.debtRaw > o_.dustDebtRaw) {\n                    // temp_ => branch's Debt\n                    temp_ = (o_.branchData >> 52) & X64;\n                    temp_ = (temp_ >> 8) << (temp_ & X8);\n\n                    // o_.debtRaw should always be < branch's Debt (temp_).\n                    // Taking margin (0.01%) in fetchLatestPosition to make sure it's always less\n                    temp_ -= o_.debtRaw;\n                    if (temp_ < 100) {\n                        // explicitly making sure that branch debt/liquidity doesn't get super low.\n                        temp_ = 100;\n                    }\n                    // Inserting updated branch's debt\n                    branchData[temp2_] =\n                        (o_.branchData & 0xfffffffffffffffffffffffffffffffffff0000000000000000fffffffffffff) |\n                        (temp_.toBigNumber(56, 8, BigMathMinified.ROUND_UP) << 52);\n\n                    unchecked {\n                        // Converted positionRawDebt_ in net position debt\n                        o_.debtRaw -= o_.dustDebtRaw;\n                    }\n                } else {\n                    // Liquidated 100% or almost 100%\n                    // absorbing dust debt\n                    absorbedDustDebt = absorbedDustDebt + o_.dustDebtRaw - o_.debtRaw;\n                    o_.debtRaw = 0;\n                    o_.colRaw = 0;\n                }\n            } else {\n                // User didn't got liquidated\n                // Removing user's debt from tick data\n                // temp2_ => debt in tick\n                temp2_ = (temp_ >> 25) & X64;\n                // below require can fail when a user liquidity is extremely low (talking about way less than even $1)\n                // adding require meaning this vault user won't be able to interact unless someone makes the liquidity in tick as non 0.\n                // reason of adding is the tick has already removed from everywhere. Can removing it again break something? Better to simply remove that case entirely\n                if (temp2_ == 0) {\n                    revert FluidVaultError(ErrorTypes.Vault__TickIsEmpty);\n                }\n                // Converting big number into normal number\n                temp2_ = (temp2_ >> 8) << (temp2_ & X8);\n                // debtInTick (temp2_) < debtToRemove (o_.debtRaw) that means minor precision error. Hence make the debtInTick as 0.\n                // The precision error can be caused with Bigmath library limiting the precision to 2**56.\n                unchecked {\n                    temp2_ = o_.debtRaw < temp2_ ? temp2_ - o_.debtRaw : 0;\n                }\n\n                if (temp2_ < 10000) {\n                    temp2_ = 0;\n                    // if debt becomes 0 then remove from tick has debt\n\n                    if (o_.tick == o_.topTick) {\n                        // if tick is top tick then current top tick is perfect tick -> fetch & set new top tick\n\n                        // Updating new top tick in vaultVariables_ and topTick_\n                        (vaultVariables_, o_.topTick) = _setNewTopTick(o_.topTick, vaultVariables_);\n                    }\n\n                    // Removing from tickHasDebt\n                    _updateTickHasDebt(o_.tick, false);\n                }\n\n                tickData[o_.tick] = (temp_ & X25) | (temp2_.toBigNumber(56, 8, BigMathMinified.ROUND_DOWN) << 25);\n\n                // Converted positionRawDebt_ in net position debt\n                o_.debtRaw -= o_.dustDebtRaw;\n            }\n            o_.dustDebtRaw = 0;\n        }\n\n        // Setting the current tick into old tick as the position tick is going to change now.\n        o_.oldTick = o_.tick;\n        o_.oldColRaw = o_.colRaw;\n        o_.oldNetDebtRaw = o_.debtRaw;\n\n        {\n            (o_.liquidityExPrice, , o_.supplyExPrice, o_.borrowExPrice) = updateExchangePrices(o_.vaultVariables2);\n\n            {\n                // supply or withdraw\n                if (newCol_ > 0) {\n                    // supply new col, rounding down\n                    o_.colRaw += (uint256(newCol_) * EXCHANGE_PRICES_PRECISION) / o_.supplyExPrice;\n                    // final user's collateral should not be above 2**128 bits\n                    if (o_.colRaw > X128) {\n                        revert FluidVaultError(ErrorTypes.Vault__UserCollateralDebtExceed);\n                    }\n                } else if (newCol_ < 0) {\n                    // if withdraw equals type(int).min then max withdraw\n                    if (newCol_ > type(int128).min) {\n                        // partial withdraw, rounding up removing extra wei from collateral\n                        temp3_ = ((newCol_ * int(EXCHANGE_PRICES_PRECISION)) / int256(o_.supplyExPrice)) - 1;\n                        unchecked {\n                            if (uint256(-temp3_) > o_.colRaw) {\n                                revert FluidVaultError(ErrorTypes.Vault__ExcessCollateralWithdrawal);\n                            }\n                            o_.colRaw -= uint256(-temp3_);\n                        }\n                    } else if (newCol_ == type(int).min) {\n                        // max withdraw, rounding up:\n                        // adding +1 to negative withdrawAmount newCol_ for safe rounding (reducing withdraw)\n                        newCol_ = -(int256((o_.colRaw * o_.supplyExPrice) / EXCHANGE_PRICES_PRECISION)) + 1;\n                        o_.colRaw = 0;\n                    } else {\n                        revert FluidVaultError(ErrorTypes.Vault__UserCollateralDebtExceed);\n                    }\n                }\n            }\n            {\n                // borrow or payback\n                if (newDebt_ > 0) {\n                    // borrow new debt, rounding up adding extra wei in debt\n                    temp_ = ((uint(newDebt_) * EXCHANGE_PRICES_PRECISION) / o_.borrowExPrice) + 1;\n                    // if borrow fee is 0 then it'll become temp_ + 0.\n                    // Only adding fee in o_.debtRaw and not in newDebt_ as newDebt_ is debt that needs to be borrowed from Liquidity\n                    // as we have added fee in debtRaw hence it will get added in user's position & vault's total borrow.\n                    // It can be collected with rebalance function.\n                    o_.debtRaw += temp_ + (temp_ * ((o_.vaultVariables2 >> 82) & X10)) / 10000;\n                    // final user's debt should not be above 2**128 bits\n                    if (o_.debtRaw > X128) {\n                        revert FluidVaultError(ErrorTypes.Vault__UserCollateralDebtExceed);\n                    }\n                } else if (newDebt_ < 0) {\n                    // if payback equals type(int).min then max payback\n                    if (newDebt_ > type(int128).min) {\n                        // partial payback.\n                        // temp3_ => newDebt_ in raw terms, safe rounding up negative amount to rounding reduce payback\n                        temp3_ = (newDebt_ * int256(EXCHANGE_PRICES_PRECISION)) / int256(o_.borrowExPrice) + 1;\n                        unchecked {\n                            temp3_ = -temp3_;\n                            if (uint256(temp3_) > o_.debtRaw) {\n                                revert FluidVaultError(ErrorTypes.Vault__ExcessDebtPayback);\n                            }\n                            o_.debtRaw -= uint256(temp3_);\n                        }\n                    } else if (newDebt_ == type(int).min) {\n                        // max payback, rounding up amount that will be transferred in to pay back full debt:\n                        // subtracting -1 of negative debtAmount newDebt_ for safe rounding (increasing payback)\n                        newDebt_ = -(int256((o_.debtRaw * o_.borrowExPrice) / EXCHANGE_PRICES_PRECISION)) - 1;\n                        o_.debtRaw = 0;\n                    } else {\n                        revert FluidVaultError(ErrorTypes.Vault__UserCollateralDebtExceed);\n                    }\n                }\n            }\n        }\n\n        // if position has no collateral or debt and user sends type(int).min for withdraw and payback then this results in 0\n        // there's is no issue if it stays 0 but better to throw here to avoid checking for potential issues if there could be\n        if (newCol_ == 0 && newDebt_ == 0) {\n            revert FluidVaultError(ErrorTypes.Vault__InvalidOperateAmount);\n        }\n\n        // Assign new tick\n        if (o_.debtRaw > 0) {\n            // updating tickHasDebt in the below function if required\n            // o_.debtRaw here is updated to new debt raw incl. dust debt (not net debt)\n            unchecked {\n                (o_.tick, o_.tickId, o_.debtRaw, o_.dustDebtRaw) = _addDebtToTickWrite(\n                    o_.colRaw,\n                    ((o_.debtRaw * 1000000001) / 1000000000) + 1\n                );\n            }\n\n            if (newDebt_ < 0) {\n                // anyone can payback debt of any position\n                // hence, explicitly checking the debt should decrease\n                if ((o_.debtRaw - o_.dustDebtRaw) > o_.oldNetDebtRaw) {\n                    revert FluidVaultError(ErrorTypes.Vault__InvalidPaybackOrDeposit);\n                }\n            }\n            if ((newCol_ > 0) && (newDebt_ == 0)) {\n                // anyone can deposit collateral in any position\n                // Hence, explicitly checking that new ratio should be less than old ratio\n                if (\n                    (((o_.debtRaw - o_.dustDebtRaw) * TickMath.ZERO_TICK_SCALED_RATIO) / o_.colRaw) >\n                    ((o_.oldNetDebtRaw * TickMath.ZERO_TICK_SCALED_RATIO) / o_.oldColRaw)\n                ) {\n                    revert FluidVaultError(ErrorTypes.Vault__InvalidPaybackOrDeposit);\n                }\n            }\n\n            if (o_.tick >= o_.topTick) {\n                // Updating topTick in storage\n                // temp_ => tick to insert in vault variables\n                unchecked {\n                    temp_ = o_.tick < 0 ? uint(-o_.tick) << 1 : (uint(o_.tick) << 1) | 1;\n                }\n                if (vaultVariables_ & 2 == 0) {\n                    // Current branch not liquidated. Hence, just update top tick\n                    vaultVariables_ =\n                        (vaultVariables_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00000) |\n                        (temp_ << 2);\n                } else {\n                    // Current branch liquidated\n                    // Initialize a new branch\n                    // temp2_ => totalBranchId_\n                    unchecked {\n                        temp2_ = ((vaultVariables_ >> 52) & X30) + 1; // would take 34 years to overflow if a new branch is created every second\n                    }\n                    // Connecting new active branch with current active branch which is now base branch\n                    // Current top tick is now base branch's minima tick\n                    branchData[temp2_] =\n                        (((vaultVariables_ >> 22) & X30) << 166) | // current branch id set as base branch id\n                        (((vaultVariables_ >> 2) & X20) << 196); // current top tick set as base branch minima tick\n                    // Updating new vault variables in memory with new branch\n                    vaultVariables_ =\n                        (vaultVariables_ & 0xfffffffffffffffffffffffffffffffffffffffffffc00000000000000000000) |\n                        (temp_ << 2) | // new top tick\n                        (temp2_ << 22) | // new branch id\n                        (temp2_ << 52); // total branch ids\n                }\n            }\n        } else {\n            // debtRaw_ remains 0 in this situation\n            // This kind of position will not have any tick. Meaning it'll be a supply position.\n            o_.tick = type(int).min;\n        }\n\n        {\n            if (newCol_ < 0 || newDebt_ > 0) {\n                // withdraw or borrow\n                if (to_ == address(0)) {\n                    to_ = msg.sender;\n                }\n\n                unchecked {\n                    // if debt is greater than 0 & transaction includes borrow or withdraw (incl. combinations such as deposit + borrow etc.)\n                    // -> check collateral factor\n                    // calc for net debt can be unchecked as o_.dustDebtRaw can not be > o_.debtRaw:\n                    // o_.dustDebtRaw is the result of o_.debtRaw - x where x > 0 see _addDebtToTickWrite()\n\n                    // Only fetch oracle if position is getting riskier or if borrowing is involved\n                    // if user is withdrawing and paying back in the same transaction such that the final ratio\n                    // is lower than initial then as well no need to check oracle aka user is doing payback & withdraw or deleverage\n                    if (o_.debtRaw > 0 && (\n                            o_.oldTick <= o_.tick ||\n                            (o_.debtRaw - o_.dustDebtRaw) > (((o_.oldNetDebtRaw * 1000000001) / 1000000000) + 1)\n                        )\n                    ) {\n                        // Oracle returns price at 100% ratio.\n                        // converting oracle 160 bits into oracle address\n                        // temp_ => debt price w.r.t to col in 1e27\n                        temp_ = IFluidOracle(address(uint160(o_.vaultVariables2 >> 96))).getExchangeRateOperate();\n                        // Note if price would come back as 0 `getTickAtRatio` will fail\n\n                        // reverting if oracle price is too high or lower than 1e9 to avoid precision issues\n                        if (temp_ > 1e54 || temp_ < 1e9) {\n                            revert FluidVaultError(ErrorTypes.Vault__InvalidOraclePrice);\n                        }\n\n                        // Converting price in terms of raw amounts\n                        temp_ = (temp_ * o_.supplyExPrice) / o_.borrowExPrice;\n\n                        // capping oracle pricing to 1e45 (#487RGF783GF: id reference for other similar cases in codebase)\n                        // This means we are restricting collateral price to never go above 1e45\n                        // Above 1e45 precisions gets too low for calculations\n                        // This can will never happen for all good token pairs (for example, WBTC/DAI pair when WBTC price is $1M, oracle price will come as 1e43)\n                        // Restricting oracle price doesn't pose any risk to protocol as we are capping collateral price, meaning if price is above 1e45\n                        // user is simply not able to borrow more\n                        if (temp_ > 1e45) {\n                            temp_ = 1e45;\n                        }\n\n                        // temp2_ => ratio at CF. CF is in 3 decimals. 900 = 90%\n                        temp2_ = ((temp_ * ((o_.vaultVariables2 >> 32) & X10)) / 1000);\n\n                        // Price from oracle is in 1e27 decimals. Converting it into (1 << 96) decimals\n                        temp2_ = ((temp2_ * TickMath.ZERO_TICK_SCALED_RATIO) / 1e27);\n\n                        // temp3_ => tickAtCF_\n                        (temp3_, ) = TickMath.getTickAtRatio(temp2_);\n                        if (o_.tick > temp3_) {\n                            // Above CF, user should only be allowed to reduce ratio either by paying debt or by depositing more collateral\n                            // Not comparing collateral as user can potentially use safe/deleverage to reduce tick & debt.\n                            // On use of safe/deleverage, collateral will decrease but debt will decrease as well making the overall position safer.\n                            revert FluidVaultError(ErrorTypes.Vault__PositionAboveCF);\n                        }\n                    }\n                }\n\n            }\n        }\n\n        {\n            // Updating user's new position on storage\n            // temp_ => tick to insert as user position tick\n            if (o_.tick > type(int).min) {\n                unchecked {\n                    temp_ = o_.tick < 0 ? (uint(-o_.tick) << 1) : ((uint(o_.tick) << 1) | 1);\n                }\n            } else {\n                // if positionTick_ = type(int).min OR positionRawDebt_ == 0 then that means it's only supply position\n                // (for case of positionRawDebt_ == 0, tick is set to type(int).min further up)\n                temp_ = 0;\n            }\n\n            positionData[nftId_] =\n                ((temp_ == 0) ? 1 : 0) | // setting if supply only position (1) or not (first bit)\n                (temp_ << 1) |\n                (o_.tickId << 21) |\n                (o_.colRaw.toBigNumber(56, 8, BigMathMinified.ROUND_DOWN) << 45) |\n                // dust debt is rounded down because user debt = debt - dustDebt. rounding up would mean we reduce user debt\n                (o_.dustDebtRaw.toBigNumber(56, 8, BigMathMinified.ROUND_DOWN) << 109);\n        }\n\n        // Withdrawal gap to make sure there's always liquidity for liquidation\n        // For example if withdrawal allowance is 15% on liquidity then we can limit operate's withdrawal allowance to 10%\n        // this will allow liquidate function to get extra 5% buffer for potential liquidations.\n        if (newCol_ < 0) {\n            // extracting withdrawal gap which is in 0.1% precision.\n            temp_ = (o_.vaultVariables2 >> 62) & X10;\n            if (temp_ > 0) {\n                // fetching user's supply slot data\n                o_.userSupplyLiquidityData = LIQUIDITY.readFromStorage(LIQUIDITY_USER_SUPPLY_SLOT);\n\n                // converting current user's supply from big number to normal\n                temp2_ = (o_.userSupplyLiquidityData >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n                temp2_ = (temp2_ >> 8) << (temp2_ & X8);\n\n                // fetching liquidity's withdrawal limit\n                temp3_ = int(LiquidityCalcs.calcWithdrawalLimitBeforeOperate(o_.userSupplyLiquidityData, temp2_));\n\n                // max the number could go is vault's supply * 1000. Overflowing is almost impossible.\n                unchecked {\n                    // (liquidityUserSupply - withdrawalGap - liquidityWithdrawaLimit) should be less than user's withdrawal\n                    if (\n                        (temp3_ > 0) &&\n                        (((int(temp2_ * (1000 - temp_)) / 1000)) - temp3_) <\n                        (((-newCol_) * int(EXCHANGE_PRICES_PRECISION)) / int(o_.liquidityExPrice))\n                    ) {\n                        revert FluidVaultError(ErrorTypes.Vault__WithdrawMoreThanOperateLimit);\n                    }\n                }\n            }\n        }\n\n        {\n            // execute actions at Liquidity: deposit & payback is first and then withdraw & borrow\n            if (newCol_ > 0) {\n                // deposit\n                LIQUIDITY.operate{ value: SUPPLY_TOKEN == NATIVE_TOKEN ? msg.value : 0 }(\n                    SUPPLY_TOKEN,\n                    newCol_,\n                    0,\n                    address(0),\n                    address(0),\n                    abi.encode(msg.sender)\n                );\n            }\n            if (newDebt_ < 0) {\n                if (BORROW_TOKEN == NATIVE_TOKEN) {\n                    unchecked {\n                        temp_ = uint(-newDebt_);\n                        if (msg.value > temp_) {\n                            SafeTransfer.safeTransferNative(msg.sender, msg.value - temp_);\n                        } else if (msg.value < temp_) {\n                            revert FluidVaultError(ErrorTypes.Vault__InvalidMsgValueOperate);\n                        }\n                    }\n                } else {\n                    temp_ = 0;\n                }\n                // payback\n                LIQUIDITY.operate{ value: temp_ }(\n                    BORROW_TOKEN,\n                    0,\n                    newDebt_,\n                    address(0),\n                    address(0),\n                    abi.encode(msg.sender)\n                );\n            }\n            if (newCol_ < 0) {\n                // withdraw\n                LIQUIDITY.operate(SUPPLY_TOKEN, newCol_, 0, to_, address(0), new bytes(0));\n            }\n            if (newDebt_ > 0) {\n                // borrow\n                LIQUIDITY.operate(BORROW_TOKEN, 0, newDebt_, address(0), to_, new bytes(0));\n            }\n        }\n\n        {\n            // Updating vault variables on storage\n\n            // Calculating new total collateral & total debt.\n            temp_ = (vaultVariables_ >> 82) & X64;\n            temp_ = ((temp_ >> 8) << (temp_ & X8)) + o_.colRaw - o_.oldColRaw;\n            temp2_ = (vaultVariables_ >> 146) & X64;\n            temp2_ = ((temp2_ >> 8) << (temp2_ & X8)) + (o_.debtRaw - o_.dustDebtRaw) - o_.oldNetDebtRaw;\n            // Updating vault variables on storage. This will also reentrancy 0 back again\n            // Converting total supply & total borrow in 64 bits (56 | 8) bignumber\n            vaultVariables =\n                (vaultVariables_ & 0xfffffffffffc00000000000000000000000000000003ffffffffffffffffffff) |\n                (temp_.toBigNumber(56, 8, BigMathMinified.ROUND_DOWN) << 82) | // total supply\n                (temp2_.toBigNumber(56, 8, BigMathMinified.ROUND_UP) << 146); // total borrow\n        }\n\n        emit LogOperate(msg.sender, nftId_, newCol_, newDebt_, to_);\n\n        return (nftId_, newCol_, newDebt_);\n    }\n\n    /// @dev allows to liquidate all bad debt of all users at once. Liquidator can also liquidate partially any amount they want.\n    /// @param debtAmt_ total debt to liquidate (aka debt token to swap into collateral token)\n    /// @param colPerUnitDebt_ minimum collateral token per unit of debt in 1e18 decimals\n    /// @param to_ address at which collateral token should go to.\n    ///            If dead address (0x000000000000000000000000000000000000dEaD) then reverts with custom error \"FluidLiquidateResult\"\n    ///            returning the actual collateral and actual debt liquidated. Useful to find max liquidatable amounts via try / catch.\n    /// @param absorb_ if true then liquidate from absorbed first\n    /// @return actualDebtAmt_ if liquidator sends debtAmt_ more than debt remaining to liquidate then actualDebtAmt_ changes from debtAmt_ else remains same\n    /// @return actualColAmt_ total liquidated collateral which liquidator will get\n    function liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\n        address to_,\n        bool absorb_\n    ) public payable returns (uint actualDebtAmt_, uint actualColAmt_) {\n        LiquidateMemoryVars memory memoryVars_;\n\n        uint vaultVariables_ = vaultVariables;\n\n        // ############# turning re-entrancy bit on #############\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        if (BORROW_TOKEN == NATIVE_TOKEN) {\n            if ((msg.value != debtAmt_) && (to_ != 0x000000000000000000000000000000000000dEaD)) {\n                revert FluidVaultError(ErrorTypes.Vault__InvalidMsgValueLiquidate);\n            }\n        } else if (msg.value > 0) {\n            revert FluidVaultError(ErrorTypes.Vault__InvalidMsgValueLiquidate);\n        }\n\n        memoryVars_.vaultVariables2 = vaultVariables2;\n\n        if (((vaultVariables_ >> 2) & X20) == 0) {\n            revert FluidVaultError(ErrorTypes.Vault__TopTickDoesNotExist);\n        }\n\n        // Below are exchange prices of vaults\n        (, , memoryVars_.supplyExPrice, memoryVars_.borrowExPrice) = updateExchangePrices(memoryVars_.vaultVariables2);\n\n        CurrentLiquidity memory currentData_;\n        BranchData memory branch_;\n        // Temporary holder variables, used many times for different small things\n        uint temp_;\n        uint temp2_;\n\n        {\n            // ############# Oracle related stuff #############\n            // Col price w.r.t debt. For example: 1 ETH = 1000 DAI\n            // temp_ -> debtPerCol\n            temp_ = IFluidOracle(address(uint160(memoryVars_.vaultVariables2 >> 96))).getExchangeRateLiquidate(); // Price in 27 decimals\n\n            // not reverting if oracle price is lower than 1e9 as it can pause potential liquidation in this edge case situations\n            if (temp_ > 1e54 || temp_ == 0) {\n                revert FluidVaultError(ErrorTypes.Vault__InvalidOraclePrice);\n            }\n\n            unchecked {\n                // temp_ -> debtPerCol Converting in terms of raw amount\n                temp_ = (temp_ * memoryVars_.supplyExPrice) / memoryVars_.borrowExPrice;\n\n                // capping oracle pricing to 1e45\n                // Reason mentioned at (search: #487RGF783GF)\n                if (temp_ > 1e45) {\n                    temp_ = 1e45;\n                }\n                // temp2_ -> Raw colPerDebt_ in 27 decimals\n                temp2_ = 1e54 / temp_;\n\n                // temp2_ can never be > 1e54\n                // Oracle price should never be > 1e54\n                // Liquidation penalty in 4 decimals (1e2 = 1%) (max: 10.23%) -> (vaultVariables2_ >> 72) & X10\n                currentData_.colPerDebt = (temp2_ * (10000 + ((memoryVars_.vaultVariables2 >> 72) & X10))) / 10000;\n\n                // get liquidiation tick (tick at liquidation threshold ratio)\n                // Liquidation threshold in 3 decimals (900 = 90%) -> (vaultVariables2_ >> 42) & X10\n                // Dividing by 1e27 to convert temp_ into normal number\n                temp_ = ((temp_ * TickMath.ZERO_TICK_SCALED_RATIO) / 1e27);\n                // temp2_ -> liquidationRatio_\n                temp2_ = (temp_ * ((memoryVars_.vaultVariables2 >> 42) & X10)) / 1000;\n            }\n            (memoryVars_.liquidationTick, ) = TickMath.getTickAtRatio(temp2_);\n\n            // get liquidiation max limit tick (tick at liquidation max limit ratio)\n            // Max limit in 3 decimals (900 = 90%) -> (vaultVariables2_ >> 52) & X10\n            // temp2_ -> maxRatio_\n            unchecked {\n                temp2_ = (temp_ * ((memoryVars_.vaultVariables2 >> 52) & X10)) / 1000;\n            }\n            (memoryVars_.maxTick, ) = TickMath.getTickAtRatio(temp2_);\n        }\n\n        // extracting top tick as top tick will be the current tick\n        unchecked {\n            currentData_.tick = (vaultVariables_ & 4) == 4\n                ? int256((vaultVariables_ >> 3) & X19)\n                : -int256((vaultVariables_ >> 3) & X19);\n        }\n\n        if (currentData_.tick > memoryVars_.maxTick) {\n            // absorbing all the debt above maxTick if available\n            vaultVariables_ = (abi.decode(_spell(SECONDARY_IMPLEMENTATION, abi.encodeWithSignature(\"absorb(uint256,int256)\", vaultVariables_, memoryVars_.maxTick)), (uint256)));\n\n            // updating current tick to new topTick after absorb\n            unchecked {\n                currentData_.tick = (vaultVariables_ & 4) == 4\n                    ? int256((vaultVariables_ >> 3) & X19)\n                    : -int256((vaultVariables_ >> 3) & X19);\n            }\n            if (debtAmt_ == 0) {\n                // updating vault variables on storage as the transaction was for only absorb\n                vaultVariables = vaultVariables_;\n                return (0, 0);\n            }\n        }\n\n        if (debtAmt_ < 10000 || debtAmt_ > X128) {\n            revert FluidVaultError(ErrorTypes.Vault__InvalidLiquidationAmt);\n        }\n\n        // setting up status if top tick is liquidated or not\n        currentData_.tickStatus = vaultVariables_ & 2 == 0 ? 1 : 2;\n        // Tick info is mainly used as a place holder to store temporary tick related data\n        // (it can be current or ref using same memory variable)\n        TickData memory tickInfo_;\n        tickInfo_.tick = currentData_.tick;\n\n        {\n            // ############# Setting current branch in memory #############\n\n            // Updating branch related data\n            branch_.id = (vaultVariables_ >> 22) & X30;\n            branch_.data = branchData[branch_.id];\n            branch_.debtFactor = (branch_.data >> 116) & X50;\n            if (branch_.debtFactor == 0) {\n                // Initializing branch debt factor. 35 | 15 bit number. Where full 35 bits and 15th bit is occupied.\n                // Making the total number as (2**35 - 1) << 2**14.\n                // note: initial debt factor can be any number.\n                branch_.debtFactor = ((X35 << 15) | (1 << 14));\n            }\n            // fetching base branch's minima tick. if 0 that means it's a master branch\n            temp_ = (branch_.data >> 196) & X20;\n            if (temp_ > 0) {\n                unchecked {\n                    branch_.minimaTick = (temp_ & 1) == 1 ? int256((temp_ >> 1) & X19) : -int256((temp_ >> 1) & X19);\n                }\n            } else {\n                branch_.minimaTick = type(int).min;\n            }\n        }\n\n        // debtAmt_ should be less than 2**128 & EXCHANGE_PRICES_PRECISION is 1e12\n        unchecked {\n            currentData_.debtRemaining = (debtAmt_ * EXCHANGE_PRICES_PRECISION) / memoryVars_.borrowExPrice;\n        }\n\n        // extracting total debt\n        temp2_ = (vaultVariables_ >> 146) & X64;\n        temp2_ = ((temp2_ >> 8) << (temp2_ & X8));\n\n        if ((temp2_ / 1e9) > currentData_.debtRemaining) {\n            // if liquidation amount is less than 1e9 of total debt then revert\n            // so if total debt is $1B then minimum liquidation limit = $1\n            // so if total debt is $1T then minimum liquidation limit = $1000\n            // partials precision is slightlty above 1e9 so this will make sure that on every liquidation atleast 1 partial gets liquidated\n            // not sure if it can result in any issue but restricting amount further more to remove very low amount scenarios totally\n            revert FluidVaultError(ErrorTypes.Vault__InvalidLiquidationAmt);\n        }\n\n        if (absorb_) {\n            temp_ = absorbedLiquidity;\n            // temp2_ -> absorbed col\n            temp2_ = (temp_ >> 128) & X128;\n            // temp_ -> absorbed debt\n            temp_ = temp_ & X128;\n\n            if (temp_ > currentData_.debtRemaining) {\n                // Removing collateral in equal proportion as debt\n                currentData_.totalColLiq = ((temp2_ * currentData_.debtRemaining) / temp_);\n                temp2_ -= currentData_.totalColLiq;\n                // Removing debt\n                currentData_.totalDebtLiq = currentData_.debtRemaining;\n                unchecked {\n                    temp_ -= currentData_.debtRemaining;\n                }\n                currentData_.debtRemaining = 0;\n\n                // updating on storage\n                absorbedLiquidity = temp_ | (temp2_ << 128);\n            } else {\n                // updating on storage\n                absorbedLiquidity = 0;\n                unchecked {\n                    currentData_.debtRemaining -= temp_;\n                }\n                currentData_.totalDebtLiq = temp_;\n                currentData_.totalColLiq = temp2_;\n            }\n        }\n\n        // current tick should be greater than liquidationTick and it cannot be greater than maxTick as absorb will run\n        if (currentData_.tick > memoryVars_.liquidationTick) {\n            if (currentData_.debtRemaining > 0) {\n                // Stores liquidated debt & collateral in each loop\n                uint debtLiquidated_;\n                uint colLiquidated_;\n                uint debtFactor_ = BigMathVault.TWO_POWER_64;\n\n                TickHasDebt memory tickHasDebt_;\n                unchecked {\n                    tickHasDebt_.mapId = (currentData_.tick < 0)\n                        ? (((currentData_.tick + 1) / 256) - 1)\n                        : (currentData_.tick / 256);\n                }\n\n                tickInfo_.ratio = TickMath.getRatioAtTick(tickInfo_.tick);\n\n                if (currentData_.tickStatus == 1) {\n                    // top tick is not liquidated. Hence it's a perfect tick.\n                    currentData_.ratio = tickInfo_.ratio;\n                    // if current tick in liquidation is a perfect tick then it is also the next tick that has debt.\n                    tickHasDebt_.nextTick = currentData_.tick;\n                } else {\n                    // top tick is liquidated. Hence it has partials.\n                    // next tick that has debt liquidity will have to be fetched from tickHasDebt\n                    unchecked {\n                        tickInfo_.ratioOneLess = (tickInfo_.ratio * 10000) / 10015;\n                        tickInfo_.length = tickInfo_.ratio - tickInfo_.ratioOneLess;\n                        tickInfo_.partials = (branch_.data >> 22) & X30;\n                        currentData_.ratio = tickInfo_.ratioOneLess + ((tickInfo_.length * tickInfo_.partials) / X30);\n                        \n                        if ((memoryVars_.liquidationTick + 1) == tickInfo_.tick && (tickInfo_.partials == 1)) {\n                            if (to_ == 0x000000000000000000000000000000000000dEaD) {\n                                // revert with liquidated amounts if to_ address is the dead address.\n                                // this can be used in a resolver to find the max liquidatable amounts.\n                                revert FluidLiquidateResult(0, 0);\n                            }\n                            revert FluidVaultError(ErrorTypes.Vault__InvalidLiquidation);\n                        }\n                    }\n                }\n\n                while (true) {\n                    if (currentData_.tickStatus == 1) {\n                        // not liquidated -> Getting the debt from tick data itself\n                        temp2_ = tickData[currentData_.tick];\n                        // temp_ => tick debt\n                        temp_ = (temp2_ >> 25) & X64;\n                        // Converting big number into normal number\n                        temp_ = (temp_ >> 8) << (temp_ & X8);\n                        // Updating tickData on storage with removing debt & adding connection to branch\n                        tickData[currentData_.tick] =\n                            1 | // set tick as liquidated\n                            (temp2_ & 0x1fffffe) | // set same total tick ids\n                            (branch_.id << 26) | // branch id where this tick got liquidated\n                            (branch_.debtFactor << 56);\n                    } else {\n                        // already liquidated -> Get the debt from branch data in big number\n                        // temp_ => tick debt\n                        temp_ = (branch_.data >> 52) & X64;\n                        // Converting big number into normal number\n                        temp_ = (temp_ >> 8) << (temp_ & X8);\n                        // Branch is getting updated over the end\n                    }\n\n                    // Adding new debt into active debt for liquidation\n                    currentData_.debt += temp_;\n\n                    // Adding new col into active col for liquidation\n                    // Ratio is in 2**96 decimals hence multiplying debt with 2**96 to get proper collateral\n                    currentData_.col += (temp_ * TickMath.ZERO_TICK_SCALED_RATIO) / currentData_.ratio;\n\n                    if (\n                        (tickHasDebt_.nextTick == currentData_.tick && currentData_.tickStatus == 1) ||\n                        tickHasDebt_.tickHasDebt == 0\n                    ) {\n                        // Fetching next perfect tick with liquidity\n                        // tickHasDebt_.tickHasDebt == 0 will only happen in the first while loop\n                        // in the very first perfect tick liquidation it'll be 0\n                        if (tickHasDebt_.tickHasDebt == 0) {\n                            tickHasDebt_.tickHasDebt = tickHasDebt[tickHasDebt_.mapId];\n                        }\n\n                        // in 1st loop tickStatus can be 2. Meaning not a perfect current tick\n                        if (currentData_.tickStatus == 1) {\n                            unchecked {\n                                tickHasDebt_.bitsToRemove = uint(-currentData_.tick + (tickHasDebt_.mapId * 256 + 256));\n                            }\n                            // Removing current top tick from tickHasDebt\n                            tickHasDebt_.tickHasDebt =\n                                (tickHasDebt_.tickHasDebt << tickHasDebt_.bitsToRemove) >>\n                                tickHasDebt_.bitsToRemove;\n                            // Updating in storage if tickHasDebt becomes 0.\n                            if (tickHasDebt_.tickHasDebt == 0) {\n                                tickHasDebt[tickHasDebt_.mapId] = 0;\n                            }\n                        }\n\n                        // For last user remaining in vault there could be a lot of while loop.\n                        // Chances of this to happen is extremely low (like ~0%)\n                        while (true) {\n                            if (tickHasDebt_.tickHasDebt > 0) {\n                                unchecked {\n                                    tickHasDebt_.nextTick =\n                                        tickHasDebt_.mapId *\n                                        256 +\n                                        int(tickHasDebt_.tickHasDebt.mostSignificantBit()) -\n                                        1;\n                                }\n                                break;\n                            }\n\n                            // tickHasDebt_.tickHasDebt == 0. Checking if minimum tick of this mapID is less than liquidationTick_\n                            // if true that means now the next tick is not needed as liquidation gets over minimum at liquidationTick_\n                            unchecked {\n                                if ((tickHasDebt_.mapId * 256) < memoryVars_.liquidationTick) {\n                                    tickHasDebt_.nextTick = type(int).min;\n                                    break;\n                                }\n\n                                // Fetching next tick has debt by decreasing tickHasDebt_.mapId first\n                                tickHasDebt_.tickHasDebt = tickHasDebt[--tickHasDebt_.mapId];\n                            }\n                        }\n                    }\n\n                    // Fetching refTick. refTick is the biggest tick of these 3:\n                    // 1. Next tick with liquidity (from tickHasDebt)\n                    // 2. Minima tick of current branch\n                    // 3. Liquidation threshold tick\n                    {\n                        // Setting currentData_.refTick & currentData_.refTickStatus\n                        if (\n                            branch_.minimaTick > tickHasDebt_.nextTick &&\n                            branch_.minimaTick > memoryVars_.liquidationTick\n                        ) {\n                            // next tick will be of base branch (merge)\n                            currentData_.refTick = branch_.minimaTick;\n                            currentData_.refTickStatus = 2;\n                        } else if (tickHasDebt_.nextTick > memoryVars_.liquidationTick) {\n                            // next tick will be next tick from perfect tick\n                            currentData_.refTick = tickHasDebt_.nextTick;\n                            currentData_.refTickStatus = 1;\n                        } else {\n                            // next tick is threshold tick\n                            currentData_.refTick = memoryVars_.liquidationTick;\n                            currentData_.refTickStatus = 3; // leads to end of liquidation loop\n                        }\n                    }\n\n                    // using tickInfo variable again for ref tick as we don't have the need for it any more\n                    tickInfo_.ratio = TickMath.getRatioAtTick(int24(currentData_.refTick));\n                    if (currentData_.refTickStatus == 2) {\n                        // merge current branch with base branch\n                        unchecked {\n                            tickInfo_.ratioOneLess = (tickInfo_.ratio * 10000) / 10015;\n                            tickInfo_.length = tickInfo_.ratio - tickInfo_.ratioOneLess;\n                            // Fetching base branch data to get the base branch's partial\n                            branch_.baseBranchData = branchData[((branch_.data >> 166) & X30)];\n                            tickInfo_.partials = (branch_.baseBranchData >> 22) & X30;\n                            tickInfo_.currentRatio =\n                                tickInfo_.ratioOneLess +\n                                ((tickInfo_.length * tickInfo_.partials) / X30);\n                            currentData_.refRatio = tickInfo_.currentRatio;\n                        }\n                    } else {\n                        // refTickStatus can only be 1 (next tick from perfect tick) or 3 (liquidation threshold tick)\n                        tickInfo_.currentRatio = tickInfo_.ratio;\n                        currentData_.refRatio = tickInfo_.ratio;\n                        tickInfo_.partials = X30;\n                    }\n\n                    // Formula: (debt_ - x) / (col_ - (x * colPerDebt_)) = ratioEnd_\n                    // x = ((ratioEnd_ * col) - debt_) / ((colPerDebt_ * ratioEnd_) - 1)\n                    // x is debtToLiquidate_\n                    // col_ = debt_ / ratioStart_ -> (currentData_.debt / currentData_.ratio)\n                    // ratioEnd_ is currentData_.refRatio\n                    //\n                    // Calculation results of numerator & denominator is always negative\n                    // which will cancel out to give positive output in the end so we can safely cast to uint.\n                    // for nominator:\n                    // ratioStart can only be >= ratioEnd so first part can only be reducing currentData_.debt leading to\n                    // currentData_.debt reduced - currentData_.debt original * 1e27 -> can only be a negative number\n                    // for denominator:\n                    // currentData_.colPerDebt and currentData_.refRatio are inversely proportional to each other.\n                    // the maximum value they can ever be is ~9.97e26 which is the 0.3% away from 100% because liquidation\n                    // threshold + liquidation penalty can never be > 99.7%. This can also be verified by going back from\n                    // min / max ratio values further up where we fetch oracle price etc.\n                    // as optimization we can inverse nominator and denominator subtraction to directly get a positive number.\n\n                    debtLiquidated_ =\n                        // nominator\n                        ((currentData_.debt - (currentData_.refRatio * currentData_.debt) / currentData_.ratio) *\n                            1e27) /\n                        // denominator\n                        (1e27 - ((currentData_.colPerDebt * currentData_.refRatio) / TickMath.ZERO_TICK_SCALED_RATIO));\n\n                    colLiquidated_ = (debtLiquidated_ * currentData_.colPerDebt) / 1e27;\n\n                    if (currentData_.debt == debtLiquidated_) {\n                        debtLiquidated_ -= 1;\n                    }\n\n                    if (debtLiquidated_ >= currentData_.debtRemaining || currentData_.refTickStatus == 3) {\n                        // End of liquidation as full amount to liquidate or liquidation threshold tick has been reached;\n\n                        // Updating tickHasDebt on storage.\n                        tickHasDebt[tickHasDebt_.mapId] = tickHasDebt_.tickHasDebt;\n\n                        if (debtLiquidated_ >= currentData_.debtRemaining) {\n                            // Liquidation ended between currentTick & refTick.\n                            // Not all of liquidatable debt is actually liquidated -> recalculate\n                            debtLiquidated_ = currentData_.debtRemaining;\n                            colLiquidated_ = (debtLiquidated_ * currentData_.colPerDebt) / 1e27;\n                            // Liquidating to debt. temp_ => final ratio after liquidation\n                            // liquidatable debt - debtLiquidated / liquidatable col - colLiquidated\n                            temp_ =\n                                ((currentData_.debt - debtLiquidated_) * TickMath.ZERO_TICK_SCALED_RATIO) /\n                                (currentData_.col - colLiquidated_);\n                            // Fetching tick of where liquidation ended\n                            (tickInfo_.tick, tickInfo_.ratioOneLess) = TickMath.getTickAtRatio(temp_);\n                            if ((tickInfo_.tick < currentData_.refTick) && (tickInfo_.partials == X30)) {\n                                // this situation might never happen\n                                // if this happens then there might be some very edge case precision of few weis which is returning 1 tick less\n                                // if the above were to ever happen then tickInfo_.tick only be currentData_.refTick - 1\n                                // in this case the partial will be very very near to full (X30)\n                                // increasing tick by 2 and making partial as 1 which is basically very very near to currentData_.refTick\n                                unchecked {\n                                    tickInfo_.tick += 2;\n                                }\n                                tickInfo_.partials = 1;\n                            } else {\n                                unchecked {\n                                    // Increasing tick by 1 as final ratio will probably be a partial\n                                    ++tickInfo_.tick;\n\n                                    // if ref tick is old liquidated tick then storing partials in temp2_\n                                    // tickInfo_.partials contains partial of branch which is the current ref tick\n                                    temp2_ = (currentData_.refTickStatus == 2 && tickInfo_.tick == currentData_.refTick) ? tickInfo_.partials : 0;\n\n                                    tickInfo_.ratio = (tickInfo_.ratioOneLess * 10015) / 10000;\n                                    tickInfo_.length = tickInfo_.ratio - tickInfo_.ratioOneLess;\n                                    tickInfo_.partials = ((temp_ - tickInfo_.ratioOneLess) * X30) / tickInfo_.length;\n\n                                    // Taking edge cases where partial comes as 0 or X30 meaning perfect tick.\n                                    // Hence, increasing or reducing it by 1 as liquidation tick cannot be perfect tick.\n                                    tickInfo_.partials = tickInfo_.partials == 0 ? 1 : tickInfo_.partials >= X30\n                                        ? X30 - 1\n                                        : tickInfo_.partials;\n                                }\n                                if (temp2_ > 0 && temp2_ >= tickInfo_.partials) {\n                                    // if refTick is liquidated tick and hence contains partials then checking that\n                                    // current liquidation tick's partial should not be less than last liquidation refTick\n\n                                    // not sure if this is even possible to happen but adding checks to avoid it fully\n                                    // if it reverts here then next liquidation on next block should go through fine\n                                    revert FluidVaultError(ErrorTypes.Vault__LiquidationReverts);\n                                }\n                            }\n                        } else {\n                            // End in liquidation threshold.\n                            // finalRatio_ = currentData_.refRatio;\n                            // Increasing liquidation threshold tick by 1 partial. With 1 partial it'll reach to the next tick.\n                            // Ratio change will be negligible. Doing this as liquidation threshold tick can also be a perfect non-liquidated tick.\n                            unchecked {\n                                tickInfo_.tick = currentData_.refTick + 1;\n                            }\n                            // Making partial as 1 so it doesn't stay perfect tick\n                            tickInfo_.partials = 1;\n                            // length is not needed as only partials are written to storage\n                        }\n\n                        // debtFactor = debtFactor * (liquidatableDebt - debtLiquidated) / liquidatableDebt\n                        // -> debtFactor * leftOverDebt / liquidatableDebt\n                        debtFactor_ = (debtFactor_ * (currentData_.debt - debtLiquidated_)) / currentData_.debt;\n                        currentData_.totalDebtLiq += debtLiquidated_;\n                        currentData_.debt -= debtLiquidated_; // currentData_.debt => leftOverDebt after debtLiquidated_\n                        currentData_.totalColLiq += colLiquidated_;\n                        currentData_.col -= colLiquidated_; // currentData_.col => leftOverCol after colLiquidated_\n\n                        // Updating branch's debt factor & write to storage as liquidation is over\n                        branch_.debtFactor = branch_.debtFactor.mulDivBigNumber(debtFactor_);\n\n                        if (currentData_.debt < 100) {\n                            // this can happen when someone tries to create a dust tick\n                            revert FluidVaultError(ErrorTypes.Vault__BranchDebtTooLow);\n                        }\n\n                        unchecked {\n                            // Tick to insert\n                            temp2_ = tickInfo_.tick < 0\n                                ? (uint(-tickInfo_.tick) << 1)\n                                : ((uint(tickInfo_.tick) << 1) | 1);\n                        }\n\n                        // Updating Branch data with debt factor, debt, partials, minima tick & assigning is liquidated\n                        branchData[branch_.id] =\n                            ((branch_.data >> 166) << 166) |\n                            1 | // set as liquidated\n                            (temp2_ << 2) | // minima tick of branch\n                            (tickInfo_.partials << 22) |\n                            (currentData_.debt.toBigNumber(56, 8, BigMathMinified.ROUND_UP) << 52) | // branch debt\n                            (branch_.debtFactor << 116);\n\n                        // Updating vault variables with current branch & tick\n                        vaultVariables_ =\n                            ((vaultVariables_ >> 52) << 52) |\n                            2 | // set as liquidated\n                            (temp2_ << 2) | // top tick\n                            (branch_.id << 22);\n                        break;\n                    }\n\n                    unchecked {\n                        // debtLiquidated_ >= currentData_.debtRemaining leads to loop break in if statement above\n                        // so this can be unchecked\n                        currentData_.debtRemaining -= debtLiquidated_;\n                    }\n\n                    // debtFactor = debtFactor * (liquidatableDebt - debtLiquidated) / liquidatableDebt\n                    // -> debtFactor * leftOverDebt / liquidatableDebt\n                    debtFactor_ = (debtFactor_ * (currentData_.debt - debtLiquidated_)) / currentData_.debt;\n                    currentData_.totalDebtLiq += debtLiquidated_;\n                    currentData_.debt -= debtLiquidated_;\n                    currentData_.totalColLiq += colLiquidated_;\n                    currentData_.col -= colLiquidated_;\n\n                    // updating branch's debt factor\n                    branch_.debtFactor = branch_.debtFactor.mulDivBigNumber(debtFactor_);\n                    // Setting debt factor as 1 << 64 again\n                    debtFactor_ = BigMathVault.TWO_POWER_64;\n\n                    if (currentData_.refTickStatus == 2) {\n                        // ref tick is base branch's minima hence merging current branch to base branch\n                        // and making base branch as current branch.\n\n                        // read base branch related data\n                        temp_ = (branch_.data >> 166) & X30; // temp_ -> base branch id\n                        temp2_ = branch_.baseBranchData;\n                        {\n                            uint newBranchDebtFactor_ = (temp2_ >> 116) & X50;\n\n                            // connectionFactor_ = baseBranchDebtFactor / currentBranchDebtFactor\n                            uint connectionFactor_ = newBranchDebtFactor_.divBigNumber(branch_.debtFactor);\n                            // Updating current branch in storage\n                            branchData[branch_.id] =\n                                ((branch_.data >> 166) << 166) | // deleting debt / partials / minima tick\n                                2 | // setting as merged\n                                (connectionFactor_ << 116); // set new connectionFactor\n\n                            // Storing base branch in memory\n                            // Updating branch ID to base branch ID\n                            branch_.id = temp_;\n                            // Updating branch data with base branch data\n                            branch_.data = temp2_;\n                            // Remove next branch connection from base branch\n                            branch_.debtFactor = newBranchDebtFactor_;\n                            // temp_ => minima tick of base branch\n                            temp_ = (temp2_ >> 196) & X20;\n                            if (temp_ > 0) {\n                                unchecked {\n                                    branch_.minimaTick = (temp_ & 1) == 1\n                                        ? int256((temp_ >> 1) & X19)\n                                        : -int256((temp_ >> 1) & X19);\n                                }\n                            } else {\n                                branch_.minimaTick = type(int).min;\n                            }\n                        }\n                    }\n\n                    // Making refTick as currentTick\n                    currentData_.tick = currentData_.refTick;\n                    currentData_.tickStatus = currentData_.refTickStatus;\n                    currentData_.ratio = currentData_.refRatio;\n                }\n            }\n        }\n\n        // calculating net token amounts using exchange price\n        actualDebtAmt_ = (currentData_.totalDebtLiq * memoryVars_.borrowExPrice) / EXCHANGE_PRICES_PRECISION;\n        actualColAmt_ = (currentData_.totalColLiq * memoryVars_.supplyExPrice) / EXCHANGE_PRICES_PRECISION;\n\n        // Chances of this to happen are in few wei\n        if (actualDebtAmt_ > debtAmt_) {\n            // calc new actualColAmt_ via ratio.\n            actualColAmt_ = actualColAmt_ * (debtAmt_ / actualDebtAmt_);\n            actualDebtAmt_ = debtAmt_;\n        }\n\n        if (actualDebtAmt_ == 0) {\n            revert FluidVaultError(ErrorTypes.Vault__InvalidLiquidation);\n        }\n\n        if (((actualColAmt_ * 1e18) / actualDebtAmt_) < colPerUnitDebt_) {\n            revert FluidVaultError(ErrorTypes.Vault__ExcessSlippageLiquidation);\n        }\n\n        if (to_ == 0x000000000000000000000000000000000000dEaD) {\n            // revert with liquidated amounts if to_ address is the dead address.\n            // this can be used in a resolver to find the max liquidatable amounts.\n            revert FluidLiquidateResult(actualColAmt_, actualDebtAmt_);\n        }\n\n        // payback at Liquidity\n        if (BORROW_TOKEN == NATIVE_TOKEN) {\n            temp_ = actualDebtAmt_;\n            if (actualDebtAmt_ < msg.value) {\n                unchecked {\n                    // subtraction can be unchecked because of if check above\n                    SafeTransfer.safeTransferNative(msg.sender, msg.value - actualDebtAmt_);\n                }\n            }\n            // else if actualDebtAmt_ > msg.value not possible as actualDebtAmt_ can maximally be debtAmt_ and\n            // msg.value == debtAmt_ is checked in the beginning of function.\n        } else {\n            temp_ = 0;\n        }\n        unchecked {\n            // payback at liquidity\n            LIQUIDITY.operate{ value: temp_ }(\n                BORROW_TOKEN,\n                0,\n                -int(actualDebtAmt_),\n                address(0),\n                address(0),\n                abi.encode(msg.sender)\n            );\n            // withdraw at liquidity\n            LIQUIDITY.operate(SUPPLY_TOKEN, -int(actualColAmt_), 0, to_, address(0), new bytes(0));\n        }\n\n        // Calculating new total collateral & total debt.\n        // temp_ -> total supply\n        temp_ = (vaultVariables_ >> 82) & X64;\n        temp_ = ((temp_ >> 8) << (temp_ & X8)) - currentData_.totalColLiq;\n        // temp2_ -> total borrow\n        temp2_ = (vaultVariables_ >> 146) & X64;\n        temp2_ = ((temp2_ >> 8) << (temp2_ & X8)) - currentData_.totalDebtLiq;\n        // Updating vault variables on storage\n        // Converting total supply & total borrow in 64 bits (56 | 8) bignumber\n        vaultVariables =\n            (vaultVariables_ & 0xfffffffffffc00000000000000000000000000000003ffffffffffffffffffff) |\n            (temp_.toBigNumber(56, 8, BigMathMinified.ROUND_DOWN) << 82) | // total supply\n            (temp2_.toBigNumber(56, 8, BigMathMinified.ROUND_UP) << 146); // total borrow\n\n        emit LogLiquidate(msg.sender, actualColAmt_, actualDebtAmt_, to_);\n    }\n\n    /// @dev Checks total supply of vault's in Liquidity Layer & Vault contract and rebalance it accordingly\n    /// if vault supply is more than Liquidity Layer then deposit difference through reserve/rebalance contract\n    /// if vault supply is less than Liquidity Layer then withdraw difference to reserve/rebalance contract\n    /// if vault borrow is more than Liquidity Layer then borrow difference to reserve/rebalance contract\n    /// if vault borrow is less than Liquidity Layer then payback difference through reserve/rebalance contract\n    function rebalance() external payable returns (int supplyAmt_, int borrowAmt_) {\n        (supplyAmt_, borrowAmt_) = abi.decode(_spell(SECONDARY_IMPLEMENTATION, msg.data), (int, int));\n    }\n\n    /// @dev liquidity callback for cheaper token transfers in case of deposit or payback.\n    /// only callable by Liquidity during an operation.\n    function liquidityCallback(address token_, uint amount_, bytes calldata data_) external {\n        if (msg.sender != address(LIQUIDITY))\n            revert FluidVaultError(ErrorTypes.Vault__InvalidLiquidityCallbackAddress);\n        if (vaultVariables & 1 == 0) revert FluidVaultError(ErrorTypes.Vault__NotEntered);\n\n        SafeTransfer.safeTransferFrom(token_, abi.decode(data_, (address)), address(LIQUIDITY), amount_);\n    }\n\n    constructor(ConstantViews memory constants_) Helpers(constants_) {\n        // Note that vaults are deployed by VaultFactory so we somewhat trust the values being passed in\n\n        // Setting branch in vault.\n        vaultVariables = (vaultVariables) | (1 << 22) | (1 << 52);\n\n        uint liqSupplyExchangePrice_ = (LIQUIDITY.readFromStorage(LIQUIDITY_SUPPLY_EXCHANGE_PRICE_SLOT) >>\n            LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) & X64;\n        uint liqBorrowExchangePrice_ = (LIQUIDITY.readFromStorage(LIQUIDITY_BORROW_EXCHANGE_PRICE_SLOT) >>\n            LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) & X64;\n\n        if (\n            liqSupplyExchangePrice_ < EXCHANGE_PRICES_PRECISION || liqBorrowExchangePrice_ < EXCHANGE_PRICES_PRECISION\n        ) {\n            revert FluidVaultError(ErrorTypes.Vault__TokenNotInitialized);\n        }\n        // Updating initial rates in storage\n        rates =\n            liqSupplyExchangePrice_ |\n            (liqBorrowExchangePrice_ << 64) |\n            (EXCHANGE_PRICES_PRECISION << 128) |\n            (EXCHANGE_PRICES_PRECISION << 192);\n    }\n\n    fallback() external {\n        if (!(VAULT_FACTORY.isGlobalAuth(msg.sender) || VAULT_FACTORY.isVaultAuth(address(this), msg.sender))) {\n            revert FluidVaultError(ErrorTypes.Vault__NotAnAuth);\n        }\n\n        // Delegate the current call to `implementation`.\n        // This does not return to its internall call site, it will return directly to the external caller.\n        // solhint-disable-next-line no-inline-assembly\n        _spell(ADMIN_IMPLEMENTATION, msg.data);\n    }\n\n    function _spell(address target_, bytes memory data_) private returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT1/coreModule/main2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Variables } from \"../common/variables.sol\";\nimport { IFluidOracle } from \"../../../../oracle/fluidOracle.sol\";\nimport { TickMath } from \"../../../../libraries/tickMath.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { Error } from \"../../error.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { IFluidVaultT1 } from \"../../interfaces/iVaultT1.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { Events } from \"./events.sol\";\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\nimport { LiquidityCalcs } from \"../../../../libraries/liquidityCalcs.sol\";\nimport { IFluidLiquidity } from \"../../../../liquidity/interfaces/iLiquidity.sol\";\nimport { SafeTransfer } from \"../../../../libraries/safeTransfer.sol\";\n\n/// @notice Fluid Vault protocol secondary methods contract.\n///         Implements `absorb()` and `rebalance()` methods, extracted from main contract due to contract size limits.\n///         Methods are limited to be called via delegateCall only (as done by Vault CoreModule \"VaultT1\" contract).\ncontract FluidVaultT1Secondary is Variables, Error, Structs, Events {\n    using BigMathMinified for uint;\n\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // 30 bits (used for partials mainly)\n    uint internal constant X8 = 0xff;\n    uint internal constant X10 = 0x3ff;\n    uint internal constant X16 = 0xffff;\n    uint internal constant X19 = 0x7ffff;\n    uint internal constant X20 = 0xfffff;\n    uint internal constant X24 = 0xffffff;\n    uint internal constant X25 = 0x1ffffff;\n    uint internal constant X30 = 0x3fffffff;\n    uint internal constant X35 = 0x7ffffffff;\n    uint internal constant X50 = 0x3ffffffffffff;\n    uint internal constant X64 = 0xffffffffffffffff;\n    uint internal constant X96 = 0xffffffffffffffffffffffff;\n    uint internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n\n    address private immutable addressThis;\n\n    constructor() {\n        addressThis = address(this);\n    }\n\n    modifier _verifyCaller() {\n        if (address(this) == addressThis) {\n            revert FluidVaultError(ErrorTypes.Vault__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev absorb function absorbs the bad debt if the bad debt is above max limit. The main use of it is\n    /// if the bad debt didn't got liquidated in time maybe due to sudden price drop or bad debt was extremely small to liquidate\n    /// and the bad debt goes above 100% ratio then there's no incentive for anyone to liquidate now\n    /// hence absorb functions absorbs that bad debt to allow newer bad debt to liquidate seamlessly.\n    /// if absorbing were to happen after this it's on governance on how to deal with it\n    /// although it can still be removed through liquidate via liquidator if the price goes back up and liquidation becomes beneficial\n    /// upon absorbed user position gets 100% liquidated.\n    function absorb(uint vaultVariables_, int maxTick_) public _verifyCaller returns (uint) {\n        AbsorbMemoryVariables memory a_;\n\n        // Temporary holder variables, used many times for different small few liner things\n        uint temp_;\n        uint temp2_;\n\n        TickHasDebt memory tickHasDebt_;\n\n        {\n            // liquidating ticks above max ratio\n\n            // temp_ -> top tick\n            temp_ = ((vaultVariables_ >> 2) & X20);\n            // increasing startingTick_ by 1 so the current tick comes into looping equation\n            a_.startingTick = (temp_ & 1) == 1 ? (int(temp_ >> 1) + 1) : (-int(temp_ >> 1) + 1);\n\n            tickHasDebt_.mapId = a_.startingTick < 0 ? ((a_.startingTick + 1) / 256) - 1 : a_.startingTick / 256;\n\n            tickHasDebt_.tickHasDebt = tickHasDebt[tickHasDebt_.mapId];\n\n            {\n                // For last user remaining in vault there could be a lot of while loop.\n                // Chances of this to happen is extremely low (like ~0%)\n                tickHasDebt_.nextTick = TickMath.MAX_TICK;\n                while (true) {\n                    if (tickHasDebt_.tickHasDebt > 0) {\n                        a_.mostSigBit = tickHasDebt_.tickHasDebt.mostSignificantBit();\n                        tickHasDebt_.nextTick = tickHasDebt_.mapId * 256 + int(a_.mostSigBit) - 1;\n\n                        while (tickHasDebt_.nextTick > maxTick_) {\n                            // storing tickData into temp_\n                            temp_ = tickData[tickHasDebt_.nextTick];\n                            // temp2_ -> tick's debt\n                            temp2_ = (temp_ >> 25) & X64;\n                            // converting big number into normal number\n                            temp2_ = (temp2_ >> 8) << (temp2_ & X8);\n                            // Absorbing tick's debt & collateral\n                            a_.debtAbsorbed += temp2_;\n                            // calculating collateral from debt & ratio and adding to a_.colAbsorbed\n                            a_.colAbsorbed += ((temp2_ * TickMath.ZERO_TICK_SCALED_RATIO) /\n                                TickMath.getRatioAtTick(int24(tickHasDebt_.nextTick)));\n                            // Update tick data on storage. Making tick as 100% liquidated\n                            tickData[tickHasDebt_.nextTick] = 1 | (temp_ & 0x1fffffe) | (1 << 25); // set as 100% liquidated\n\n                            // temp_ = bits to remove\n                            temp_ = 257 - a_.mostSigBit;\n                            tickHasDebt_.tickHasDebt = (tickHasDebt_.tickHasDebt << temp_) >> temp_;\n                            if (tickHasDebt_.tickHasDebt == 0) break;\n\n                            a_.mostSigBit = tickHasDebt_.tickHasDebt.mostSignificantBit();\n                            tickHasDebt_.nextTick = tickHasDebt_.mapId * 256 + int(a_.mostSigBit) - 1;\n                        }\n                        // updating tickHasDebt on storage\n                        tickHasDebt[tickHasDebt_.mapId] = tickHasDebt_.tickHasDebt;\n                    }\n\n                    // tickHasDebt_.tickHasDebt == 0 from here.\n\n                    if (tickHasDebt_.nextTick <= maxTick_) {\n                        break;\n                    }\n\n                    if (tickHasDebt_.mapId < -129) {\n                        tickHasDebt_.nextTick = type(int).min;\n                        break;\n                    }\n\n                    // Fetching next tickHasDebt by decreasing tickHasDebt_.mapId first\n                    tickHasDebt_.tickHasDebt = tickHasDebt[--tickHasDebt_.mapId];\n                }\n            }\n        }\n\n        // After the above loop we will get nextTick stored in tickHasDebt_ which we will use to compare & set things in the end\n\n        {\n            TickData memory tickInfo_;\n            BranchData memory branch_;\n            // if this remains 0 that means create a new branch over the end\n            uint newBranchId_;\n\n            {\n                // Liquidate branches in a loop and store the end branch\n                branch_.id = (vaultVariables_ >> 22) & X30;\n                branch_.data = branchData[branch_.id];\n                // Checking if current branch is liquidated\n                if ((vaultVariables_ & 2) == 0) {\n                    // current branch is not liquidated hence it can be used as a new branch if needed\n                    newBranchId_ = branch_.id;\n\n                    // Checking the base branch minima tick. temp_ = base branch minima tick\n                    temp_ = (branch_.data >> 196) & X20;\n                    if (temp_ > 0) {\n                        // Setting the base branch as current liquidatable branch\n                        branch_.id = (branch_.data >> 166) & X30;\n                        branch_.data = branchData[branch_.id];\n                        branch_.minimaTick = (temp_ & 1) == 1 ? int(temp_ >> 1) : -int(temp_ >> 1);\n                    } else {\n                        // the current branch is base branch, hence need to setup a new base branch\n                        branch_.id = 0;\n                        branch_.data = 0;\n                        branch_.minimaTick = type(int).min;\n                    }\n                } else {\n                    // current branch is liquidated\n                    temp_ = (branch_.data >> 2) & X20;\n                    branch_.minimaTick = (temp_ & 1) == 1 ? int(temp_ >> 1) : -int(temp_ >> 1);\n                }\n                while (branch_.minimaTick > maxTick_) {\n                    // Check base branch, if exists then check if minima tick is above max tick then liquidate it.\n                    tickInfo_.ratio = TickMath.getRatioAtTick(int24(branch_.minimaTick));\n                    tickInfo_.ratioOneLess = (tickInfo_.ratio * 10000) / 10015;\n                    tickInfo_.length = tickInfo_.ratio - tickInfo_.ratioOneLess;\n\n                    // partials\n                    tickInfo_.partials = (branch_.data >> 22) & X30;\n\n                    tickInfo_.currentRatio = tickInfo_.ratioOneLess + ((tickInfo_.length * tickInfo_.partials) / X30);\n\n                    // debt in branch\n                    temp2_ = (branch_.data >> 52) & X64;\n                    // converting big number into normal number\n                    temp2_ = (temp2_ >> 8) << (temp2_ & X8);\n                    // Absorbing branch's debt & collateral\n                    a_.debtAbsorbed += temp2_;\n                    // calculating branch's collateral using debt & ratio and adding it to a_.colAbsorbed\n                    a_.colAbsorbed += (temp2_ * TickMath.ZERO_TICK_SCALED_RATIO) / tickInfo_.currentRatio;\n\n                    // Closing branch\n                    branchData[branch_.id] = branch_.data | 3;\n\n                    // Setting new branch\n                    temp_ = (branch_.data >> 196) & X20; // temp_ -> minima tick of connected branch\n                    if (temp_ > 0) {\n                        // Setting the base branch as current liquidatable branch\n                        branch_.id = (branch_.data >> 166) & X30;\n                        branch_.data = branchData[branch_.id];\n                        branch_.minimaTick = (temp_ & 1) == 1 ? int(temp_ >> 1) : -int(temp_ >> 1);\n                    } else {\n                        // the current branch is base branch, hence need to setup a new base branch\n                        branch_.id = 0;\n                        branch_.data = 0;\n                        branch_.minimaTick = type(int).min;\n                    }\n                }\n            }\n\n            if (tickHasDebt_.nextTick >= branch_.minimaTick) {\n                // new top tick is not liquidated\n                // temp2_ = tick to insert\n                if (tickHasDebt_.nextTick > type(int).min) {\n                    temp2_ = tickHasDebt_.nextTick < 0\n                        ? (uint(-tickHasDebt_.nextTick) << 1)\n                        : ((uint(tickHasDebt_.nextTick) << 1) | 1);\n                } else {\n                    temp2_ = 0;\n                }\n                if (newBranchId_ == 0) {\n                    // initializing a new branch\n                    // newBranchId_ = total current branches + 1\n                    unchecked {\n                        newBranchId_ = ((vaultVariables_ >> 52) & X30) + 1;\n                    }\n                    vaultVariables_ =\n                        ((vaultVariables_ >> 82) << 82) |\n                        (temp2_ << 2) |\n                        (newBranchId_ << 22) |\n                        (newBranchId_ << 52);\n                } else {\n                    // using already initialized non liquidated branch\n                    vaultVariables_ = ((vaultVariables_ >> 22) << 22) | (temp2_ << 2);\n                }\n\n                if (branch_.minimaTick > type(int).min) {\n                    temp2_ = branch_.minimaTick < 0\n                        ? (uint(-branch_.minimaTick) << 1)\n                        : ((uint(branch_.minimaTick) << 1) | 1);\n                    // set base branch id and minima tick\n                    branchData[newBranchId_] = (branch_.id << 166) | (temp2_ << 196);\n                } else {\n                    // new base branch does not have any connected branch\n                    branchData[newBranchId_] = 0;\n                }\n            } else {\n                // new top tick is liquidated\n                temp2_ = branch_.minimaTick < 0\n                    ? (uint(-branch_.minimaTick) << 1)\n                    : ((uint(branch_.minimaTick) << 1) | 1);\n                if (newBranchId_ == 0) {\n                    vaultVariables_ = ((vaultVariables_ >> 52) << 52) | 2 | (temp2_ << 2) | (branch_.id << 22);\n                } else {\n                    // uninitializing the non liquidated branch\n                    vaultVariables_ =\n                        ((vaultVariables_ >> 82) << 82) |\n                        2 |\n                        (temp2_ << 2) |\n                        (branch_.id << 22) |\n                        ((newBranchId_ - 1) << 52); // decreasing total branch by 1\n                    branchData[newBranchId_] = 0;\n                }\n            }\n        }\n\n        // updating absorbed liquidity on storage\n        absorbedLiquidity = absorbedLiquidity + a_.debtAbsorbed + (a_.colAbsorbed << 128);\n\n        emit LogAbsorb(a_.colAbsorbed, a_.debtAbsorbed);\n\n        // returning updated vault variables\n        return vaultVariables_;\n    }\n\n    /// @dev Checks total supply of vault's in Liquidity Layer & Vault contract and rebalance it accordingly\n    /// if vault supply is more than Liquidity Layer then deposit difference through reserve/rebalance contract\n    /// if vault supply is less than Liquidity Layer then withdraw difference to reserve/rebalance contract\n    /// if vault borrow is more than Liquidity Layer then borrow difference to reserve/rebalance contract\n    /// if vault borrow is less than Liquidity Layer then payback difference through reserve/rebalance contract\n    function rebalance() external payable _verifyCaller returns (int supplyAmt_, int borrowAmt_) {\n        if (msg.sender != rebalancer) {\n            revert FluidVaultError(ErrorTypes.Vault__NotRebalancer);\n        }\n\n        uint vaultVariables_ = vaultVariables;\n        // ############# turning re-entrancy bit on #############\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        IFluidVaultT1.ConstantViews memory constants_ = IFluidVaultT1(address(this)).constantsView();\n\n        if (msg.value > 0 && !(constants_.supplyToken == NATIVE_TOKEN || constants_.borrowToken == NATIVE_TOKEN)) {\n            revert FluidVaultError(ErrorTypes.Vault__InvalidMsgValueInRebalance);\n        }\n\n        IFluidLiquidity liquidity_ = IFluidLiquidity(constants_.liquidity);\n        RebalanceMemoryVariables memory r_;\n\n        (r_.liqSupplyExPrice, r_.liqBorrowExPrice, r_.vaultSupplyExPrice, r_.vaultBorrowExPrice) = IFluidVaultT1(\n            address(this)\n        ).updateExchangePrices(vaultVariables2);\n\n        // extract vault supply at Liquidity -> 64 bits starting from bit 1 (first bit is interest mode)\n        uint totalSupplyLiquidity_ = (liquidity_.readFromStorage(constants_.liquidityUserSupplySlot) >>\n            LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n        totalSupplyLiquidity_ = (totalSupplyLiquidity_ >> 8) << (totalSupplyLiquidity_ & X8);\n        totalSupplyLiquidity_ =\n            (totalSupplyLiquidity_ * r_.liqSupplyExPrice) /\n            LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n\n        // extract vault borrowings at Liquidity -> 64 bits starting from bit 1 (first bit is interest mode)\n        uint totalBorrowLiquidity_ = (liquidity_.readFromStorage(constants_.liquidityUserBorrowSlot) >>\n            LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n        totalBorrowLiquidity_ = (totalBorrowLiquidity_ >> 8) << (totalBorrowLiquidity_ & X8);\n        totalBorrowLiquidity_ =\n            (totalBorrowLiquidity_ * r_.liqBorrowExPrice) /\n            LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n\n        uint totalSupplyVault_ = (vaultVariables_ >> 82) & X64;\n        totalSupplyVault_ = (totalSupplyVault_ >> 8) << (totalSupplyVault_ & X8);\n        totalSupplyVault_ = (totalSupplyVault_ * r_.vaultSupplyExPrice) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n\n        uint totalBorrowVault_ = (vaultVariables_ >> 146) & X64;\n        totalBorrowVault_ = (totalBorrowVault_ >> 8) << (totalBorrowVault_ & X8);\n        totalBorrowVault_ = (totalBorrowVault_ * r_.vaultBorrowExPrice) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n\n        uint value_;\n\n        if (totalSupplyVault_ > totalSupplyLiquidity_) {\n            // Fetch tokens from revenue/rebalance contract and supply in liquidity contract\n            // This is the scenario when the supply rewards are going in vault, hence\n            // the vault total supply is increasing at a higher pace than Liquidity contract.\n            // We are not transferring rewards right when we set the rewards to keep things clean.\n            // Also, this can also happen in case when supply rate magnifier is greater than 1.\n\n            supplyAmt_ = int(totalSupplyVault_) - int(totalSupplyLiquidity_);\n\n            if (constants_.supplyToken == NATIVE_TOKEN) {\n                if (msg.value > uint(supplyAmt_)) {\n                    value_ = uint(supplyAmt_);\n                    SafeTransfer.safeTransferNative(msg.sender, msg.value - value_); // sending back excess ETH\n                } else {\n                    value_ = msg.value; // setting amount as msg.value\n                }\n                supplyAmt_ = int(value_);\n            } else {\n                value_ = 0;\n            }\n\n            try liquidity_.operate{ value: value_ }(\n                constants_.supplyToken,\n                supplyAmt_,\n                0,\n                address(0),\n                address(0),\n                abi.encode(rebalancer)\n            ) {\n                // if success then do nothing\n            } catch  {\n                supplyAmt_ = 0;\n            }\n\n            \n        } else if (totalSupplyLiquidity_ > totalSupplyVault_) {\n            if (constants_.supplyToken == NATIVE_TOKEN && msg.value > 0) {\n                revert FluidVaultError(ErrorTypes.Vault__InvalidMsgValueInRebalance);\n            }\n            // Withdraw from Liquidity contract and send it to revenue contract.\n            // This is the scenario when the vault user's are getting less ETH APR than what's going on Liquidity contract.\n            // When supply rate magnifier is less than 1.\n            supplyAmt_ = int(totalSupplyVault_) - int(totalSupplyLiquidity_);\n            try liquidity_.operate(constants_.supplyToken, supplyAmt_, 0, rebalancer, address(0), new bytes(0)) {\n                // if success then do nothing\n            } catch  {\n                supplyAmt_ = 0;\n            }\n        }\n\n        if (totalBorrowVault_ > totalBorrowLiquidity_) {\n            if (constants_.borrowToken == NATIVE_TOKEN && msg.value > 0) {\n                revert FluidVaultError(ErrorTypes.Vault__InvalidMsgValueInRebalance);\n            }\n            // Borrow from Liquidity contract and send to revenue/rebalance contract\n            // This is the scenario when the vault is charging more borrow to user than the Liquidity contract.\n            // When borrow rate magnifier is greater than 1.\n            borrowAmt_ = int(totalBorrowVault_) - int(totalBorrowLiquidity_);\n            try liquidity_.operate(constants_.borrowToken, 0, borrowAmt_, address(0), rebalancer, new bytes(0)) {\n                // if success then do nothing\n            } catch  {\n                borrowAmt_ = 0;\n            }\n        } else if (totalBorrowLiquidity_ > totalBorrowVault_) {\n            // Transfer from revenue/rebalance contract and payback on Liquidity contract\n            // This is the scenario when vault protocol is earning rewards so effective borrow rate for users is low.\n            // Or the case where borrow rate magnifier is less than 1\n\n            borrowAmt_ = int(totalBorrowLiquidity_) - int(totalBorrowVault_);\n\n            if (constants_.borrowToken == NATIVE_TOKEN) {\n                if (msg.value > uint(borrowAmt_)) {\n                    value_ = uint(borrowAmt_);\n                    SafeTransfer.safeTransferNative(msg.sender, msg.value - value_);\n                } else {\n                    value_ = msg.value; // setting amount as msg.value\n                }\n                borrowAmt_ = int(value_);\n            } else {\n                value_ = 0;\n            }\n\n            borrowAmt_ = -borrowAmt_;\n\n            try liquidity_.operate{ value: value_ }(\n                constants_.borrowToken,\n                0,\n                borrowAmt_,\n                address(0),\n                address(0),\n                abi.encode(rebalancer)\n            ) {\n                // if success then do nothing\n            } catch  {\n                borrowAmt_ = 0;\n            }\n        }\n\n        if (supplyAmt_ == 0 && borrowAmt_ == 0) {\n            revert FluidVaultError(ErrorTypes.Vault__NothingToRebalance);\n        }\n\n        // Updating vault variable on storage to turn off the reentrancy bit\n        vaultVariables = vaultVariables_;\n\n        emit LogRebalance(supplyAmt_, borrowAmt_);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT1/coreModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\ncontract Structs {\n    // structs are used to mitigate Stack too deep errors\n\n    struct OperateMemoryVars {\n        // ## User's position before update ##\n        uint oldColRaw;\n        uint oldNetDebtRaw; // total debt - dust debt\n        int oldTick;\n        // ## User's position after update ##\n        uint colRaw;\n        uint debtRaw;\n        uint dustDebtRaw;\n        int tick;\n        uint tickId;\n        // others\n        uint256 vaultVariables2;\n        uint256 branchId;\n        int256 topTick;\n        uint liquidityExPrice;\n        uint supplyExPrice;\n        uint borrowExPrice;\n        uint branchData;\n        // user's supply slot data in liquidity\n        uint userSupplyLiquidityData;\n    }\n\n    struct BranchData {\n        uint id;\n        uint data;\n        uint ratio;\n        uint debtFactor;\n        int minimaTick;\n        uint baseBranchData;\n    }\n\n    struct TickData {\n        int tick;\n        uint data;\n        uint ratio;\n        uint ratioOneLess;\n        uint length;\n        uint currentRatio; // current tick is ratio with partials.\n        uint partials;\n    }\n\n    // note: All the below token amounts are in raw form.\n    struct CurrentLiquidity {\n        uint256 debtRemaining; // Debt remaining to liquidate\n        uint256 debt; // Current liquidatable debt before reaching next check point\n        uint256 col; // Calculate using debt & ratioCurrent\n        uint256 colPerDebt; // How much collateral to liquidate per unit of Debt\n        uint256 totalDebtLiq; // Total debt liquidated till now\n        uint256 totalColLiq; // Total collateral liquidated till now\n        int tick; // Current tick to liquidate\n        uint ratio; // Current ratio to liquidate\n        uint tickStatus; // if 1 then it's a perfect tick, if 2 that means it's a liquidated tick\n        int refTick; // ref tick to liquidate\n        uint refRatio; // ratio at ref tick\n        uint refTickStatus; // if 1 then it's a perfect tick, if 2 that means it's a liquidated tick, if 3 that means it's a liquidation threshold\n    }\n\n    struct TickHasDebt {\n        int tick; // current tick\n        int nextTick; // next tick with liquidity\n        int mapId; // mapping ID of tickHasDebt\n        uint bitsToRemove; // liquidity to remove till tick_ so we can search for next tick\n        uint tickHasDebt; // getting tickHasDebt_ from tickHasDebt[mapId_]\n        uint mostSigBit; // most significant bit in tickHasDebt_ to get the next tick\n    }\n\n    struct LiquidateMemoryVars {\n        uint256 vaultVariables2;\n        int liquidationTick;\n        int maxTick;\n        uint256 supplyExPrice;\n        uint256 borrowExPrice;\n    }\n\n    struct AbsorbMemoryVariables {\n        uint256 debtAbsorbed;\n        uint256 colAbsorbed;\n        int256 startingTick;\n        uint256 mostSigBit;\n    }\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address adminImplementation;\n        address secondaryImplementation;\n        address supplyToken;\n        address borrowToken;\n        uint8 supplyDecimals;\n        uint8 borrowDecimals;\n        uint vaultId;\n        bytes32 liquiditySupplyExchangePriceSlot;\n        bytes32 liquidityBorrowExchangePriceSlot;\n        bytes32 liquidityUserSupplySlot;\n        bytes32 liquidityUserBorrowSlot;\n    }\n\n    struct RebalanceMemoryVariables {\n        uint256 liqSupplyExPrice;\n        uint256 liqBorrowExPrice;\n        uint256 vaultSupplyExPrice;\n        uint256 vaultBorrowExPrice;\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT2/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract VaultT2Events {\n    /// @notice emitted when the supply rate config is updated\n    event LogUpdateSupplyRate(int supplyRate_);\n\n    /// @notice emitted when the borrow rate magnifier config is updated\n    event LogUpdateBorrowRateMagnifier(uint borrowRateMagnifier_);\n\n    /// @notice emitted when the core setting configs are updated\n    event LogUpdateCoreSettings(\n        int supplyRate_,\n        uint borrowRateMagnifier_,\n        uint collateralFactor_,\n        uint liquidationThreshold_,\n        uint liquidationMaxLimit_,\n        uint withdrawGap_,\n        uint liquidationPenalty_,\n        uint borrowFee_\n    );\n}\n"
    },
    "contracts/protocols/vault/vaultT2/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidVaultAdmin } from \"../../vaultTypesCommon/adminModule/main.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { VaultT2Events } from \"./events.sol\";\n\n/// @notice Fluid Vault protocol Admin Module contract.\n///         Implements admin related methods to set configs such as liquidation params, rates\n///         oracle address etc.\n///         Methods are limited to be called via delegateCall only. Vault CoreModule is expected\n///         to call the methods implemented here after checking the msg.sender is authorized.\n///         All methods update the exchange prices in storage before changing configs.\ncontract FluidVaultT2Admin is FluidVaultAdmin, VaultT2Events {\n    /// @notice updates the supply rate. Input in 1e2 (1% = 100, 100% = 10_000). If positive then incentives else charging\n    function updateSupplyRate(int supplyRate_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateSupplyRate(supplyRate_);\n\n        if ((supplyRate_ > int(X15)) || (-supplyRate_ > int(X15))) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        uint supplyRateToInsert_ = supplyRate_ < 0 ? (uint(-supplyRate_) << 1) : (uint(1) | (uint(supplyRate_) << 1));\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000) |\n            supplyRateToInsert_;\n    }\n\n    /// @notice updates the borrow rate magnifier to `borrowRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateBorrowRateMagnifier(uint borrowRateMagnifier_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowRateMagnifier(borrowRateMagnifier_);\n\n        if (borrowRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff) |\n            (borrowRateMagnifier_ << 16);\n    }\n\n    /// @notice updates the all Vault core settings according to input params.\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\n    function updateCoreSettings(\n        int256 supplyRate_,\n        uint256 borrowRateMagnifier_,\n        uint256 collateralFactor_,\n        uint256 liquidationThreshold_,\n        uint256 liquidationMaxLimit_,\n        uint256 withdrawGap_,\n        uint256 liquidationPenalty_,\n        uint256 borrowFee_\n    ) public _updateExchangePrice _verifyCaller {\n        // emitting the event at the start as then we are updating numbers to store in a more optimized way\n        emit LogUpdateCoreSettings(\n            supplyRate_,\n            borrowRateMagnifier_,\n            collateralFactor_,\n            liquidationThreshold_,\n            liquidationMaxLimit_,\n            withdrawGap_,\n            liquidationPenalty_,\n            borrowFee_\n        );\n\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        collateralFactor_ = collateralFactor_ / 10;\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n        withdrawGap_ = withdrawGap_ / 10;\n\n        if (\n            (supplyRate_ > int(X15)) ||\n            (-supplyRate_ > int(X15)) ||\n            (borrowRateMagnifier_ > X16) ||\n            (collateralFactor_ >= liquidationThreshold_) ||\n            (liquidationThreshold_ >= liquidationMaxLimit_) ||\n            (withdrawGap_ > X10) ||\n            (liquidationPenalty_ > X10) ||\n            (borrowFee_ > X10)\n        ) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        uint supplyRateToInsert_ = supplyRate_ < 0 ? (uint(-supplyRate_) << 1) : (uint(1) | (uint(supplyRate_) << 1));\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff00000000000000000000000) |\n            supplyRateToInsert_ |\n            (borrowRateMagnifier_ << 16) |\n            (collateralFactor_ << 32) |\n            (liquidationThreshold_ << 42) |\n            (liquidationMaxLimit_ << 52) |\n            (withdrawGap_ << 62) |\n            (liquidationPenalty_ << 72) |\n            (borrowFee_ << 82);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT2/coreModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { FluidVault } from \"../../vaultTypesCommon/coreModule/main.sol\";\n\n/// @notice Fluid \"VaultT2\" (Vault Type 2). Fluid vault protocol main contract. T2 -> Smart collateral | Normal debt\n///         Fluid Vault protocol is a borrow / lending protocol, allowing users to create collateral / borrow positions.\n///         All funds are deposited into / borrowed from Fluid Liquidity layer.\n///         Positions are represented through NFTs minted by the VaultFactory.\n///         Deployed by \"VaultFactory\" and linked together with Vault AdminModule `ADMIN_IMPLEMENTATION` and\n///         FluidVaultSecondary (main2.sol) `SECONDARY_IMPLEMENTATION`.\n///         AdminModule & FluidVaultSecondary methods are delegateCalled, if the msg.sender has the required authorization.\n///         This contract links to an Oracle, which is used to assess collateral / debt value. Oracles implement the\n///         \"FluidOracle\" base contract and return the price in 1e27 precision.\n/// @dev    For view methods / accessing data, use the \"VaultResolver\" periphery contract.\n//\n// vaults can only be deployed for tokens that are listed at Liquidity (constructor reverts otherwise\n// if either the exchange price for the supply token or the borrow token is still not set at Liquidity).\nabstract contract Internals is FluidVault {\n    function _colLiquidatePerfectAfter(\n        uint perfectColShares_,\n        uint token0ColAmtPerUnitShares_,\n        uint token1ColAmtPerUnitShares_,\n        address to_\n    ) internal returns (uint newColToken0_, uint newColToken1_) {\n        uint colToken0Min_ = (token0ColAmtPerUnitShares_ * perfectColShares_) / 1e18;\n        uint colToken1Min_ = (token1ColAmtPerUnitShares_ * perfectColShares_) / 1e18;\n\n        if (colToken0Min_ > 0 && colToken1Min_ > 0) {\n            (newColToken0_, newColToken1_) = SUPPLY.withdrawPerfect(\n                perfectColShares_,\n                colToken0Min_,\n                colToken1Min_,\n                to_\n            );\n        } else if (colToken0Min_ > 0 && colToken1Min_ == 0) {\n            // withdraw only in token0, newColToken1_ remains 0\n            (newColToken0_) = SUPPLY.withdrawPerfectInOneToken(perfectColShares_, colToken0Min_, colToken1Min_, to_);\n        } else if (colToken0Min_ == 0 && colToken1Min_ > 0) {\n            // withdraw only in token1, newColToken0_ remains 0\n            (newColToken1_) = SUPPLY.withdrawPerfectInOneToken(perfectColShares_, colToken0Min_, colToken1Min_, to_);\n        } else {\n            // both sent as 0\n            revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n        }\n    }\n\n    constructor(ConstantViews memory constants_) FluidVault(constants_) {}\n}\n\ncontract FluidVaultT2 is Internals {\n    /// @notice Performs operations on a vault position\n    /// @dev This function allows users to modify their vault position by adjusting collateral and debt\n    /// @param nftId_ The ID of the NFT representing the vault position\n    /// @param newColToken0_ The change in collateral amount of token0 (positive for deposit, negative for withdrawal)\n    /// @param newColToken1_ The change in collateral amount of token1 (positive for deposit, negative for withdrawal)\n    /// @param colSharesMinMax_ min or max collateral shares to mint or burn (positive for deposit, negative for withdrawal)\n    /// @param newDebt_ The change in debt amount (positive for borrowing, negative for repayment)\n    /// @param to_ The address to receive withdrawn collateral or borrowed tokens (if address(0), defaults to msg.sender)\n    /// @return nftId_ The ID of the NFT representing the updated vault position\n    /// @return supplyAmt_ Final supply amount (negative if withdrawal occurred)\n    /// @return borrowAmt_ Final borrow amount (negative if repayment occurred)\n    function operate(\n        uint nftId_,\n        int newColToken0_,\n        int newColToken1_,\n        int colSharesMinMax_,\n        int newDebt_,\n        address to_\n    )\n        external\n        payable\n        _dexFromAddress\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        )\n    {\n        return abi.decode(_spell(OPERATE_IMPLEMENTATION, msg.data), (uint, int, int));\n    }\n\n    /// @notice Performs operations on a vault position with perfect collateral shares\n    /// @dev This function allows users to modify their vault position by adjusting collateral and debt\n    /// @param nftId_ The ID of the NFT representing the vault position\n    /// @param perfectColShares_ The change in collateral shares (positive for deposit, negative for withdrawal)\n    /// @param colToken0MinMax_ min or max collateral amount of token0 to withdraw or deposit (positive for deposit, negative for withdrawal)\n    /// @param colToken1MinMax_ min or max collateral amount of token1 to withdraw or deposit (positive for deposit, negative for withdrawal)\n    /// @param newDebt_ The change in debt amount (positive for borrowing, negative for repayment)\n    /// @param to_ The address to receive withdrawn collateral or borrowed tokens (if address(0), defaults to msg.sender)\n    /// @return nftId_ The ID of the NFT representing the updated vault position\n    /// @return r_ int256 array of return values:\n    ///              0 - final col shares amount (can only change on max withdrawal)\n    ///              1 - token0 deposit or withdraw amount\n    ///              2 - token1 deposit or withdraw amount\n    ///              3 - newDebt_ will only change if user sent type(int).min\n    function operatePerfect(\n        uint nftId_,\n        int perfectColShares_,\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int newDebt_,\n        address to_\n    )\n        external\n        payable\n        _dexFromAddress\n        returns (\n            uint256, // nftId_\n            int256[] memory r_\n        )\n    {\n        return abi.decode(_spell(OPERATE_IMPLEMENTATION, msg.data), (uint, int256[]));\n    }\n\n    /// @notice Liquidates a vault position\n    /// @dev This function allows users to liquidate a vault position by adjusting collateral and debt\n    /// @param debtAmt_ The amount of debt to liquidate\n    /// @param colPerUnitDebt_ The collateral shares per unit of debt\n    /// @param token0ColAmtPerUnitShares_ The collateral amount of token0 per unit of shares to withdraw\n    /// @param token1ColAmtPerUnitShares_ The collateral amount of token1 per unit of shares to withdraw\n    /// @param to_ The address to receive withdrawn collateral (if address(0), defaults to msg.sender)\n    /// @param absorb_ Whether to liquidate absorbed liquidity as well\n    /// @return actualDebt_ The actual amount of debt liquidated\n    /// @return actualColShares_ The actual amount of collateral shares liquidated\n    /// @return token0Col_ The amount of token0 collateral withdrawn\n    /// @return token1Col_ The amount of token1 collateral withdrawn\n    function liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    )\n        public\n        payable\n        _dexFromAddress\n        returns (uint256 actualDebt_, uint256 actualColShares_, uint256 token0Col_, uint256 token1Col_)\n    {\n        uint vaultVariables_ = vaultVariables;\n        // ############# turning re-entrancy bit on #############\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        uint initialEth_ = address(this).balance - msg.value;\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        (actualDebt_, actualColShares_, vaultVariables_) = abi.decode(\n            _liquidate(debtAmt_, colPerUnitDebt_, to_, absorb_, vaultVariables_),\n            (uint, uint, uint)\n        );\n\n        (token0Col_, token1Col_) = _colLiquidatePerfectAfter(\n            actualColShares_,\n            token0ColAmtPerUnitShares_,\n            token1ColAmtPerUnitShares_,\n            to_\n        );\n\n        // disabling re-entrancy and updating on storage\n        vaultVariables = vaultVariables_;\n\n        _validateEth(initialEth_);\n    }\n\n    /// @notice Liquidates a vault position with perfect collateral shares\n    /// @dev This function allows users to liquidate a vault position by adjusting collateral and debt\n    /// @param debtAmt_ The amount of debt to liquidate\n    /// @param colPerUnitDebt_ The collateral shares per unit of debt\n    /// @param token0ColAmtPerUnitShares_ The collateral amount of token0 per unit of shares to withdraw\n    /// @param token1ColAmtPerUnitShares_ The collateral amount of token1 per unit of shares to withdraw\n    /// @param to_ The address to receive withdrawn collateral (if address(0), defaults to msg.sender)\n    /// @param absorb_ Whether to liquidate absorbed liquidity as well\n    /// @return actualDebt_ The actual amount of debt liquidated\n    /// @return actualColShares_ The actual amount of collateral shares liquidated\n    /// @return token0Col_ The amount of token0 collateral withdrawn\n    /// @return token1Col_ The amount of token1 collateral withdrawn\n    function liquidatePerfect(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    ) external payable returns (uint256 actualDebt_, uint256 actualColShares_, uint256 token0Col_, uint256 token1Col_) {\n        return\n            liquidate(debtAmt_, colPerUnitDebt_, token0ColAmtPerUnitShares_, token1ColAmtPerUnitShares_, to_, absorb_);\n    }\n\n    constructor(ConstantViews memory constants_) Internals(constants_) {\n        // Note that vaults are deployed by VaultFactory so we somewhat trust the values being passed in\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT2/coreModule/mainOperate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { FluidVaultOperate } from \"../../vaultTypesCommon/coreModule/mainOperate.sol\";\n\n/// @notice Fluid \"VaultT2\" (Vault Type 2). Fluid vault protocol main operate contract. T2 -> Smart collateral | Normal debt\nabstract contract Internals is FluidVaultOperate {\n    function _colOperateBefore(\n        int newColToken0_,\n        int newColToken1_,\n        int colSharesMinMax_,\n        address to_\n    ) internal returns (int shares_) {\n        if (colSharesMinMax_ > 0) {\n            // deposit & minting shares\n            if (newColToken0_ < 0 || newColToken1_ < 0 || (newColToken0_ == 0 && newColToken1_ == 0)) {\n                // when minting shares, collateral amount should always be > 0 (aka deposit)\n                revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n            }\n            shares_ = int(\n                SUPPLY.deposit{\n                    value: (SUPPLY_TOKEN0 == NATIVE_TOKEN)\n                        ? uint(newColToken0_)\n                        : (SUPPLY_TOKEN1 == NATIVE_TOKEN)\n                            ? uint(newColToken1_)\n                            : 0\n                }(uint(newColToken0_), uint(newColToken1_), uint(colSharesMinMax_), false)\n            );\n        } else if (colSharesMinMax_ < 0) {\n            // withdrawing and burning shares\n            if (newColToken0_ > 0 || newColToken1_ > 0 || (newColToken0_ == 0 && newColToken1_ == 0)) {\n                // when burning shares, collateral amount should always be < 0 (aka withdraw)\n                revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n            }\n            // withdraw both tokens from DEX protocol and update shares_\n            shares_ = -int(SUPPLY.withdraw(uint(-newColToken0_), uint(-newColToken1_), uint(-colSharesMinMax_), to_));\n        } else {\n            // if 0 then user does not want to deposit or withdraw, hence shares remain 0\n            if (newColToken0_ != 0 || newColToken1_ != 0) {\n                revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n            }\n        }\n    }\n\n    function _colOperatePerfectBefore(\n        int perfectColShares_,\n        int colToken0MinMax_,\n        int colToken1MinMax_\n    ) internal returns (int newColToken0_, int newColToken1_) {\n        if ((colToken0MinMax_ <= 0) || (colToken0MinMax_ <= 0)) {\n            // max limit of token should be positive in case of deposit\n            revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n        }\n\n        (uint token0Amt_, uint token1Amt_) = SUPPLY.depositPerfect{\n            value: (SUPPLY_TOKEN0 == NATIVE_TOKEN)\n                ? uint(colToken0MinMax_)\n                : (SUPPLY_TOKEN1 == NATIVE_TOKEN)\n                    ? uint(colToken1MinMax_)\n                    : 0\n        }(uint(perfectColShares_), uint(colToken0MinMax_), uint(colToken1MinMax_), false);\n        newColToken0_ = int(token0Amt_);\n        newColToken1_ = int(token1Amt_);\n    }\n\n    function _colOperatePerfectAfter(\n        int perfectColShares_,\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        address to_\n    ) internal returns (int newColToken0_, int newColToken1_) {\n        uint token0Amt_;\n        uint token1Amt_;\n        if (colToken0MinMax_ < 0 && colToken1MinMax_ < 0) {\n            (token0Amt_, token1Amt_) = SUPPLY.withdrawPerfect(\n                uint(-perfectColShares_),\n                uint(-colToken0MinMax_),\n                uint(-colToken1MinMax_),\n                to_\n            );\n        } else if (colToken0MinMax_ < 0 && colToken1MinMax_ == 0) {\n            // withdraw only in token0, newColToken1_ remains 0\n            (token0Amt_) = SUPPLY.withdrawPerfectInOneToken(\n                uint(-perfectColShares_),\n                uint(-colToken0MinMax_),\n                uint(-colToken1MinMax_),\n                to_\n            );\n        } else if (colToken0MinMax_ == 0 && colToken1MinMax_ < 0) {\n            // withdraw only in token1, newColToken0_ remains 0\n            (token1Amt_) = SUPPLY.withdrawPerfectInOneToken(\n                uint(-perfectColShares_),\n                uint(-colToken0MinMax_),\n                uint(-colToken1MinMax_),\n                to_\n            );\n        } else {\n            // meaning user sent both amount as >= 0 in case of withdraw\n            revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n        }\n\n        newColToken0_ = -int(token0Amt_);\n        newColToken1_ = -int(token1Amt_);\n    }\n\n    constructor(ConstantViews memory constants_) FluidVaultOperate(constants_) {}\n}\n\ncontract FluidVaultT2Operate is Internals {\n    struct SmartOperate {\n        uint initialEth;\n        int colShares;\n        int debtShares;\n        uint256 vaultVariables;\n    }\n\n    /// @notice Performs operations on a vault position\n    /// @dev This function allows users to modify their vault position by adjusting collateral and debt\n    /// @param nftId_ The ID of the NFT representing the vault position\n    /// @param newColToken0_ The change in collateral amount of token0 (positive for deposit, negative for withdrawal)\n    /// @param newColToken1_ The change in collateral amount of token1 (positive for deposit, negative for withdrawal)\n    /// @param colSharesMinMax_ min or max collateral shares to mint or burn (positive for deposit, negative for withdrawal)\n    /// @param newDebt_ The change in debt amount (positive for borrowing, negative for repayment)\n    /// @param to_ The address to receive withdrawn collateral or borrowed tokens (if address(0), defaults to msg.sender)\n    /// @return nftId_ The ID of the NFT representing the updated vault position\n    /// @return supplyAmt_ Final supply amount (negative if withdrawal occurred)\n    /// @return borrowAmt_ Final borrow amount (negative if repayment occurred)\n    function operate(\n        uint nftId_,\n        int newColToken0_,\n        int newColToken1_,\n        int colSharesMinMax_,\n        int newDebt_,\n        address to_\n    )\n        external\n        payable\n        _delegateCallCheck\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        )\n    {\n        SmartOperate memory so_;\n\n        so_.vaultVariables = vaultVariables;\n        // re-entrancy check\n        if (so_.vaultVariables & 1 == 0) {\n            // Updating on storage\n            vaultVariables = so_.vaultVariables | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        so_.initialEth = address(this).balance - msg.value;\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        so_.colShares = _colOperateBefore(newColToken0_, newColToken1_, colSharesMinMax_, to_);\n\n        // operate will throw is user tried to withdraw excess shares\n        // so_.colShares returned after should remain same as before\n        // so_.debtShares returned after should remain same as before\n        (nftId_, so_.colShares, newDebt_, so_.vaultVariables) = _operate(\n            nftId_,\n            so_.colShares,\n            newDebt_,\n            to_,\n            so_.vaultVariables\n        );\n\n        // disabling re-entrancy and updating vault variables\n        vaultVariables = so_.vaultVariables;\n\n        _validateEth(so_.initialEth);\n\n        return (nftId_, so_.colShares, newDebt_);\n    }\n\n    struct SmartOperatePerfect {\n        uint initialEth;\n        int newColToken0;\n        int newColToken1;\n        int newDebtToken0;\n        int newDebtToken1;\n        uint vaultVariables;\n    }\n\n    /// @notice Performs operations on a vault position with perfect collateral shares\n    /// @dev This function allows users to modify their vault position by adjusting collateral and debt\n    /// @param nftId_ The ID of the NFT representing the vault position\n    /// @param perfectColShares_ The change in collateral shares (positive for deposit, negative for withdrawal)\n    /// @param colToken0MinMax_ min or max collateral amount of token0 to withdraw or deposit (positive for deposit, negative for withdrawal)\n    /// @param colToken1MinMax_ min or max collateral amount of token1 to withdraw or deposit (positive for deposit, negative for withdrawal)\n    /// @param newDebt_ The change in debt amount (positive for borrowing, negative for repayment)\n    /// @param to_ The address to receive withdrawn collateral or borrowed tokens (if address(0), defaults to msg.sender)\n    /// @return nftId_ The ID of the NFT representing the updated vault position\n    /// @return r_ int256 array of return values:\n    ///              0 - final col shares amount (can only change on max withdrawal)\n    ///              1 - token0 deposit or withdraw amount\n    ///              2 - token1 deposit or withdraw amount\n    ///              3 - newDebt_ will only change if user sent type(int).min\n    function operatePerfect(\n        uint nftId_,\n        int perfectColShares_,\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int newDebt_,\n        address to_\n    )\n        external\n        payable\n        _delegateCallCheck\n        returns (\n            uint256, // nftId_\n            int256[] memory r_\n        )\n    {\n        SmartOperatePerfect memory sop_;\n        r_ = new int256[](4);\n\n        sop_.vaultVariables = vaultVariables;\n        // re-entrancy check\n        if (sop_.vaultVariables & 1 == 0) {\n            // Updating on storage\n            vaultVariables = sop_.vaultVariables | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        sop_.initialEth = address(this).balance - msg.value;\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        if (perfectColShares_ > 0) {\n            (sop_.newColToken0, sop_.newColToken1) = _colOperatePerfectBefore(\n                perfectColShares_,\n                colToken0MinMax_,\n                colToken1MinMax_\n            );\n        }\n\n        // operate will throw if user tried to withdraw excess shares\n        // if max withdrawal then perfectColShares_ will change from type(int).min to total user's col shares\n        (nftId_, perfectColShares_, newDebt_, sop_.vaultVariables) = _operate(\n            nftId_,\n            perfectColShares_,\n            newDebt_,\n            to_,\n            sop_.vaultVariables\n        );\n\n        if (perfectColShares_ < 0) {\n            (sop_.newColToken0, sop_.newColToken1) = _colOperatePerfectAfter(\n                perfectColShares_,\n                colToken0MinMax_,\n                colToken1MinMax_,\n                to_\n            );\n        }\n\n        r_[0] = perfectColShares_;\n        r_[1] = sop_.newColToken0;\n        r_[2] = sop_.newColToken1;\n        r_[3] = newDebt_;\n\n        // disabling re-entrancy and updating vault variables\n        vaultVariables = sop_.vaultVariables;\n\n        _validateEth(sop_.initialEth);\n\n        return (nftId_, r_);\n    }\n\n    constructor(ConstantViews memory constants_) Internals(constants_) {}\n}\n"
    },
    "contracts/protocols/vault/vaultT3/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract VaultT3Events {\n    /// @notice emitted when the supply rate magnifier config is updated\n    event LogUpdateSupplyRateMagnifier(uint supplyRateMagnifier_);\n\n    /// @notice emitted when the borrow rate config is updated\n    event LogUpdateBorrowRate(int borrowRate_);\n\n    /// @notice emitted when the core setting configs are updated\n    event LogUpdateCoreSettings(\n        uint supplyRateMagnifier_,\n        int borrowRate_,\n        uint collateralFactor_,\n        uint liquidationThreshold_,\n        uint liquidationMaxLimit_,\n        uint withdrawGap_,\n        uint liquidationPenalty_,\n        uint borrowFee_\n    );\n}\n"
    },
    "contracts/protocols/vault/vaultT3/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidVaultAdmin } from \"../../vaultTypesCommon/adminModule/main.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { VaultT3Events } from \"./events.sol\";\n\n/// @notice Fluid Vault protocol Admin Module contract.\n///         Implements admin related methods to set configs such as liquidation params, rates\n///         oracle address etc.\n///         Methods are limited to be called via delegateCall only. Vault CoreModule is expected\n///         to call the methods implemented here after checking the msg.sender is authorized.\n///         All methods update the exchange prices in storage before changing configs.\ncontract FluidVaultT3Admin is FluidVaultAdmin, VaultT3Events {\n    /// @notice updates the supply rate magnifier to `supplyRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateSupplyRateMagnifier(uint supplyRateMagnifier_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateSupplyRateMagnifier(supplyRateMagnifier_);\n\n        if (supplyRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000) |\n            supplyRateMagnifier_;\n    }\n\n    /// @notice updates the borrow rate. Input in 1e2 (1% = 100, 100% = 10_000). If positive then charging else incentives\n    function updateBorrowRate(int borrowRate_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowRate(borrowRate_);\n\n        if ((borrowRate_ > int(X15)) || (-borrowRate_ > int(X15))) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        uint borrowRateToInsert_ = borrowRate_ < 0 ? ((uint(-borrowRate_) << 1)) : (uint(1) | (uint(borrowRate_) << 1));\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff) |\n            (borrowRateToInsert_ << 16);\n    }\n\n    /// @notice updates the all Vault core settings according to input params.\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\n    function updateCoreSettings(\n        uint256 supplyRateMagnifier_,\n        int256 borrowRate_,\n        uint256 collateralFactor_,\n        uint256 liquidationThreshold_,\n        uint256 liquidationMaxLimit_,\n        uint256 withdrawGap_,\n        uint256 liquidationPenalty_,\n        uint256 borrowFee_\n    ) public _updateExchangePrice _verifyCaller {\n        // emitting the event at the start as then we are updating numbers to store in a more optimized way\n        emit LogUpdateCoreSettings(\n            supplyRateMagnifier_,\n            borrowRate_,\n            collateralFactor_,\n            liquidationThreshold_,\n            liquidationMaxLimit_,\n            withdrawGap_,\n            liquidationPenalty_,\n            borrowFee_\n        );\n\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        collateralFactor_ = collateralFactor_ / 10;\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n        withdrawGap_ = withdrawGap_ / 10;\n\n        if (\n            (supplyRateMagnifier_ > X16) ||\n            (borrowRate_ > int(X15)) ||\n            (-borrowRate_ > int(X15)) ||\n            (collateralFactor_ >= liquidationThreshold_) ||\n            (liquidationThreshold_ >= liquidationMaxLimit_) ||\n            (withdrawGap_ > X10) ||\n            (liquidationPenalty_ > X10) ||\n            (borrowFee_ > X10)\n        ) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        uint borrowRateToInsert_ = borrowRate_ < 0 ? ((uint(-borrowRate_) << 1)) : (uint(1) | (uint(borrowRate_) << 1));\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff00000000000000000000000) |\n            supplyRateMagnifier_ |\n            (borrowRateToInsert_ << 16) |\n            (collateralFactor_ << 32) |\n            (liquidationThreshold_ << 42) |\n            (liquidationMaxLimit_ << 52) |\n            (withdrawGap_ << 62) |\n            (liquidationPenalty_ << 72) |\n            (borrowFee_ << 82);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT3/coreModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { FluidVault } from \"../../vaultTypesCommon/coreModule/main.sol\";\n\n/// @notice Fluid \"VaultT3\" (Vault Type 3). Fluid vault protocol main contract. T3 -> Normal collateral | Smart debt\n///         Fluid Vault protocol is a borrow / lending protocol, allowing users to create collateral / borrow positions.\n///         All funds are deposited into / borrowed from Fluid Liquidity layer.\n///         Positions are represented through NFTs minted by the VaultFactory.\n///         Deployed by \"VaultFactory\" and linked together with Vault AdminModule `ADMIN_IMPLEMENTATION` and\n///         FluidVaultSecondary (main2.sol) `SECONDARY_IMPLEMENTATION`.\n///         AdminModule & FluidVaultSecondary methods are delegateCalled, if the msg.sender has the required authorization.\n///         This contract links to an Oracle, which is used to assess collateral / debt value. Oracles implement the\n///         \"FluidOracle\" base contract and return the price in 1e27 precision.\n/// @dev    For view methods / accessing data, use the \"VaultResolver\" periphery contract.\n//\n// vaults can only be deployed for tokens that are listed at Liquidity (constructor reverts otherwise\n// if either the exchange price for the supply token or the borrow token is still not set at Liquidity).\nabstract contract Internals is FluidVault {\n    function _debtLiquidateBefore(\n        uint token0DebtAmt_,\n        uint token1DebtAmt_,\n        uint debtSharesMin_\n    ) internal returns (uint shares_) {\n        // paying back and burning shares\n        if (token0DebtAmt_ == 0 && token1DebtAmt_ == 0) {\n            // when burning shares, debt amount should always be > 0 (aka payback)\n            revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n        }\n\n        shares_ = BORROW.payback{\n            value: (BORROW_TOKEN0 == NATIVE_TOKEN)\n                ? token0DebtAmt_\n                : (BORROW_TOKEN1 == NATIVE_TOKEN)\n                    ? token1DebtAmt_\n                    : 0\n        }(token0DebtAmt_, token1DebtAmt_, debtSharesMin_, false);\n    }\n\n    function _debtLiquidatePerfectPayback(\n        uint perfectDebtShares_,\n        uint token0DebtAmtPerUnitShares_,\n        uint token1DebtAmtPerUnitShares_\n    ) internal returns (uint token0DebtPaid_, uint token1DebtPaid_) {\n        uint debtToken0Min_ = (token0DebtAmtPerUnitShares_ * perfectDebtShares_) / 1e18;\n        uint debtToken1Min_ = (token1DebtAmtPerUnitShares_ * perfectDebtShares_) / 1e18;\n\n        if (debtToken0Min_ > 0 && debtToken1Min_ > 0) {\n            (token0DebtPaid_, token1DebtPaid_) = BORROW.paybackPerfect{\n                value: (BORROW_TOKEN0 == NATIVE_TOKEN)\n                    ? debtToken0Min_\n                    : (BORROW_TOKEN1 == NATIVE_TOKEN)\n                        ? debtToken1Min_\n                        : 0\n            }(perfectDebtShares_, debtToken0Min_, debtToken1Min_, false);\n        } else if (debtToken0Min_ > 0 && debtToken1Min_ == 0) {\n            // payback only in token0, token1DebtPaid_ remains 0\n            (token0DebtPaid_) = BORROW.paybackPerfectInOneToken{\n                value: (BORROW_TOKEN0 == NATIVE_TOKEN) ? debtToken0Min_ : 0\n            }(perfectDebtShares_, debtToken0Min_, debtToken1Min_, false);\n        } else if (debtToken0Min_ == 0 && debtToken1Min_ > 0) {\n            // payback only in token1, token0DebtPaid_ remains 0\n            (token1DebtPaid_) = BORROW.paybackPerfectInOneToken{\n                value: (BORROW_TOKEN1 == NATIVE_TOKEN) ? debtToken1Min_ : 0\n            }(perfectDebtShares_, debtToken0Min_, debtToken1Min_, false);\n        } else {\n            // both sent as 0\n            revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n        }\n    }\n\n    constructor(ConstantViews memory constants_) FluidVault(constants_) {}\n}\n\ncontract FluidVaultT3 is Internals {\n    /// @notice Performs operations on a vault position\n    /// @dev This function allows users to modify their vault position by adjusting collateral and debt\n    /// @param nftId_ The ID of the NFT representing the vault position\n    /// @param newCol_ The change in collateral amount (positive for deposit, negative for withdrawal)\n    /// @param newDebtToken0_ The change in debt amount for token0 (positive for borrowing, negative for repayment)\n    /// @param newDebtToken1_ The change in debt amount for token1 (positive for borrowing, negative for repayment)\n    /// @param debtSharesMinMax_ Min or max debt shares to burn or mint (positive for borrowing, negative for repayment)\n    /// @param to_ The address to receive withdrawn collateral or borrowed tokens (if address(0), defaults to msg.sender)\n    /// @return nftId_ The ID of the NFT representing the updated vault position\n    /// @return supplyAmt_ Final supply amount (negative if withdrawal occurred)\n    /// @return borrowAmt_ Final borrow amount (negative if repayment occurred)\n    /// @custom:security Re-entrancy protection is implemented\n    /// @custom:security ETH balance is validated before and after operation\n    function operate(\n        uint nftId_,\n        int newCol_,\n        int newDebtToken0_,\n        int newDebtToken1_,\n        int debtSharesMinMax_,\n        address to_\n    )\n        external\n        payable\n        _dexFromAddress\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        )\n    {\n        return abi.decode(_spell(OPERATE_IMPLEMENTATION, msg.data), (uint, int, int));\n    }\n\n    /// @notice Performs operations on a vault position with perfect collateral shares\n    /// @dev This function allows users to modify their vault position by adjusting collateral and debt\n    /// @param nftId_ The ID of the NFT representing the vault position\n    /// @param newCol_ The change in collateral amount (positive for deposit, negative for withdrawal)\n    /// @param perfectDebtShares_ The change in debt shares (positive for borrowing, negative for repayment)\n    /// @param debtToken0MinMax_ Min or max debt amount for token0 to payback or borrow (positive for borrowing, negative for repayment)\n    /// @param debtToken1MinMax_ Min or max debt amount for token1 to payback or borrow (positive for borrowing, negative for repayment)\n    /// @param to_ The address to receive withdrawn collateral or borrowed tokens (if address(0), defaults to msg.sender)\n    /// @return nftId_ The ID of the NFT representing the updated vault position\n    /// @return r_ int256 array of return values:\n    ///              0 - col amount, will only change if user sends type(int).min\n    ///              1 - final debt shares amount (can only change on max payback)\n    ///              2 - token0 borrow or payback amount\n    ///              3 - token1 borrow or payback amount\n    function operatePerfect(\n        uint nftId_,\n        int newCol_,\n        int perfectDebtShares_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_,\n        address to_\n    )\n        external\n        payable\n        _dexFromAddress\n        returns (\n            uint256, // nftId_\n            int256[] memory r_\n        )\n    {\n        return abi.decode(_spell(OPERATE_IMPLEMENTATION, msg.data), (uint, int256[]));\n    }\n\n    /// @notice Liquidates a vault position\n    /// @dev This function allows users to liquidate a vault position by adjusting collateral and debt\n    /// @param token0DebtAmt_ The amount of debt in token0 to payback\n    /// @param token1DebtAmt_ The amount of debt in token1 to payback\n    /// @param debtSharesMin_ The minimum number of debt shares to liquidate\n    /// @param colPerUnitDebt_ The collateral amount per unit of debt shares\n    /// @param to_ The address to receive withdrawn collateral (if address(0), defaults to msg.sender)\n    /// @param absorb_ Whether to liquidate absorbed liquidity as well\n    /// @return actualDebtShares_ The actual number of debt shares liquidated\n    /// @return actualCol_ The actual amount of collateral withdrawn\n    function liquidate(\n        uint256 token0DebtAmt_,\n        uint256 token1DebtAmt_,\n        uint256 debtSharesMin_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        address to_,\n        bool absorb_\n    ) external payable _dexFromAddress returns (uint256 actualDebtShares_, uint256 actualCol_) {\n        uint vaultVariables_ = vaultVariables;\n        // ############# turning re-entrancy bit on #############\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        uint initialEth_ = address(this).balance - msg.value;\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        uint sharesPaid_ = _debtLiquidateBefore(token0DebtAmt_, token1DebtAmt_, debtSharesMin_);\n        (actualDebtShares_, actualCol_, vaultVariables_) = abi.decode(\n            _liquidate(sharesPaid_, colPerUnitDebt_, to_, absorb_, vaultVariables_),\n            (uint, uint, uint)\n        );\n\n        if (actualDebtShares_ < sharesPaid_) {\n            // shares paid should never be more than actual liquidation available\n            revert FluidVaultError(ErrorTypes.VaultDex__DebtSharesPaidMoreThanAvailableLiquidation);\n        }\n\n        // disabling re-entrancy and updating on storage\n        vaultVariables = vaultVariables_;\n\n        _validateEth(initialEth_);\n    }\n\n    struct LiquidatePerfect {\n        uint256 vaultVariables;\n        uint256 initialEth;\n    }\n\n    /// @notice Liquidates a vault position with perfect collateral shares\n    /// @dev This function allows users to liquidate a vault position by adjusting collateral and debt\n    /// @param debtShares_ The amount of debt shares to liquidate\n    /// @param token0DebtAmtPerUnitShares_ The amount of debt in token0 per unit of debt shares (if sent 0 then entire payback is in token1)\n    /// @param token1DebtAmtPerUnitShares_ The amount of debt in token1 per unit of debt shares (if sent 0 then entire payback is in token0)\n    /// @param colPerUnitDebt_ The collateral amount per unit of debt shares\n    /// @param to_ The address to receive withdrawn collateral (if address(0), defaults to msg.sender)\n    /// @param absorb_ Whether to liquidate absorbed liquidity as well\n    /// @return actualDebtShares_ The actual number of debt shares liquidated\n    /// @return token0Debt_ The amount of debt in token0 that was paid back\n    /// @return token1Debt_ The amount of debt in token1 that was paid back\n    /// @return actualCol_ The actual amount of collateral withdrawn\n    function liquidatePerfect(\n        uint256 debtShares_,\n        uint256 token0DebtAmtPerUnitShares_,\n        uint256 token1DebtAmtPerUnitShares_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        address to_,\n        bool absorb_\n    )\n        external\n        payable\n        _dexFromAddress\n        returns (uint256 actualDebtShares_, uint256 token0Debt_, uint256 token1Debt_, uint256 actualCol_)\n    {\n        LiquidatePerfect memory lp_;\n        lp_.vaultVariables = vaultVariables;\n        // ############# turning re-entrancy bit on #############\n        if (lp_.vaultVariables & 1 == 0) {\n            // Updating on storage\n            vaultVariables = lp_.vaultVariables | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        lp_.initialEth = address(this).balance - msg.value;\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        (actualDebtShares_, actualCol_, lp_.vaultVariables) = abi.decode(\n            _liquidate(debtShares_, colPerUnitDebt_, to_, absorb_, lp_.vaultVariables),\n            (uint, uint, uint)\n        );\n\n        (token0Debt_, token1Debt_) = _debtLiquidatePerfectPayback(\n            actualDebtShares_,\n            token0DebtAmtPerUnitShares_,\n            token1DebtAmtPerUnitShares_\n        );\n\n        // disabling re-entrancy and updating on storage\n        vaultVariables = lp_.vaultVariables;\n\n        _validateEth(lp_.initialEth);\n    }\n\n    constructor(ConstantViews memory constants_) Internals(constants_) {\n        // Note that vaults are deployed by VaultFactory so we somewhat trust the values being passed in\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT3/coreModule/mainOperate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { FluidVaultOperate } from \"../../vaultTypesCommon/coreModule/mainOperate.sol\";\n\n/// @notice Fluid \"VaultT3\" (Vault Type 3). Fluid vault protocol main operate contract. T3 -> Normal collateral | Smart debt\nabstract contract Internals is FluidVaultOperate {\n    function _debtOperateBefore(\n        int newDebtToken0_,\n        int newDebtToken1_,\n        int debtSharesMinMax_,\n        address to_\n    ) internal returns (int shares_) {\n        if (debtSharesMinMax_ > 0) {\n            // borrowing & minting shares\n            if (newDebtToken0_ < 0 || newDebtToken1_ < 0 || (newDebtToken0_ == 0 && newDebtToken1_ == 0)) {\n                // when minting shares, debt amount should always be > 0 (aka borrow)\n                revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n            }\n            // borrowing both tokens from DEX protocol and update shares_\n            shares_ = int(BORROW.borrow(uint(newDebtToken0_), uint(newDebtToken1_), uint(debtSharesMinMax_), to_));\n        } else if (debtSharesMinMax_ < 0) {\n            // paying back and burning shares\n            if (newDebtToken0_ > 0 || newDebtToken1_ > 0 || (newDebtToken0_ == 0 && newDebtToken1_ == 0)) {\n                // when burning shares, debt amount should always be < 0 (aka payback)\n                revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n            }\n            shares_ = -int(\n                BORROW.payback{\n                    value: (BORROW_TOKEN0 == NATIVE_TOKEN)\n                        ? uint(-newDebtToken0_)\n                        : (BORROW_TOKEN1 == NATIVE_TOKEN)\n                            ? uint(-newDebtToken1_)\n                            : 0\n                }(uint(-newDebtToken0_), uint(-newDebtToken1_), uint(-debtSharesMinMax_), false)\n            );\n        } else {\n            // if 0 then user does not want to borrow or payback, hence shares remain 0\n            if (newDebtToken0_ != 0 || newDebtToken1_ != 0) {\n                revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n            }\n        }\n    }\n\n    function _debtOperatePerfectPayback(\n        int perfectDebtShares_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_\n    ) internal returns (int newDebtToken0_, int newDebtToken1_) {\n        uint token0Amt_;\n        uint token1Amt_;\n\n        if (debtToken0MinMax_ < 0 && debtToken1MinMax_ < 0) {\n            (token0Amt_, token1Amt_) = BORROW.paybackPerfect{\n                value: (BORROW_TOKEN0 == NATIVE_TOKEN)\n                    ? uint(-debtToken0MinMax_)\n                    : (BORROW_TOKEN1 == NATIVE_TOKEN)\n                        ? uint(-debtToken1MinMax_)\n                        : 0\n            }(uint(-perfectDebtShares_), uint(-debtToken0MinMax_), uint(-debtToken1MinMax_), false);\n        } else if (debtToken0MinMax_ < 0 && debtToken1MinMax_ == 0) {\n            // payback only in token0, token1Amt_ remains 0\n            (token0Amt_) = BORROW.paybackPerfectInOneToken{\n                value: (BORROW_TOKEN0 == NATIVE_TOKEN) ? uint(-debtToken0MinMax_) : 0\n            }(uint(-perfectDebtShares_), uint(-debtToken0MinMax_), uint(-debtToken1MinMax_), false);\n        } else if (debtToken0MinMax_ == 0 && debtToken1MinMax_ < 0) {\n            // payback only in token1, token0Amt_ remains 0\n            (token1Amt_) = BORROW.paybackPerfectInOneToken{\n                value: (BORROW_TOKEN1 == NATIVE_TOKEN) ? uint(-debtToken1MinMax_) : 0\n            }(uint(-perfectDebtShares_), uint(-debtToken0MinMax_), uint(-debtToken1MinMax_), false);\n        } else {\n            // meaning user sent both amount as >= 0 in case of payback\n            revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n        }\n\n        newDebtToken0_ = -int(token0Amt_);\n        newDebtToken1_ = -int(token1Amt_);\n    }\n\n    function _debtOperatePerfectBorrow(\n        int perfectDebtShares_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_,\n        address to_\n    ) internal returns (int newDebtToken0_, int newDebtToken1_) {\n        if ((debtToken0MinMax_ <= 0) || (debtToken1MinMax_ <= 0)) {\n            // min limit of token should be positive in case of borrow\n            revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n        }\n\n        (uint token0Amt_, uint token1Amt_) = BORROW.borrowPerfect(\n            uint(perfectDebtShares_),\n            uint(debtToken0MinMax_),\n            uint(debtToken1MinMax_),\n            to_\n        );\n        newDebtToken0_ = int(token0Amt_);\n        newDebtToken1_ = int(token1Amt_);\n    }\n\n    constructor(ConstantViews memory constants_) FluidVaultOperate(constants_) {}\n}\n\ncontract FluidVaultT3Operate is Internals {\n    struct SmartOperate {\n        uint initialEth;\n        int debtShares;\n        uint256 vaultVariables;\n    }\n\n    /// @notice Performs operations on a vault position\n    /// @dev This function allows users to modify their vault position by adjusting collateral and debt\n    /// @param nftId_ The ID of the NFT representing the vault position\n    /// @param newCol_ The change in collateral amount (positive for deposit, negative for withdrawal)\n    /// @param newDebtToken0_ The change in debt amount for token0 (positive for borrowing, negative for repayment)\n    /// @param newDebtToken1_ The change in debt amount for token1 (positive for borrowing, negative for repayment)\n    /// @param debtSharesMinMax_ Min or max debt shares to mint or burn (positive for borrowing, negative for repayment)\n    /// @param to_ The address to receive withdrawn collateral or borrowed tokens (if address(0), defaults to msg.sender)\n    /// @return nftId_ The ID of the NFT representing the updated vault position\n    /// @return supplyAmt_ Final supply amount (negative if withdrawal occurred)\n    /// @return borrowAmt_ Final borrow amount (negative if repayment occurred)\n    /// @custom:security Re-entrancy protection is implemented\n    /// @custom:security ETH balance is validated before and after operation\n    function operate(\n        uint nftId_,\n        int newCol_,\n        int newDebtToken0_,\n        int newDebtToken1_,\n        int debtSharesMinMax_,\n        address to_\n    )\n        external\n        payable\n        _delegateCallCheck\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        )\n    {\n        SmartOperate memory so_;\n\n        so_.vaultVariables = vaultVariables;\n        // re-entrancy check\n        if (so_.vaultVariables & 1 == 0) {\n            // Updating on storage\n            vaultVariables = so_.vaultVariables | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        so_.initialEth = address(this).balance - msg.value;\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        so_.debtShares = _debtOperateBefore(newDebtToken0_, newDebtToken1_, debtSharesMinMax_, to_);\n\n        // operate will throw is user tried to withdraw excess shares\n        // so_.colShares returned after should remain same as before\n        // so_.debtShares returned after should remain same as before\n        (nftId_, newCol_, so_.debtShares, so_.vaultVariables) = _operate(\n            nftId_,\n            newCol_,\n            so_.debtShares,\n            to_,\n            so_.vaultVariables\n        );\n\n        // disabling re-entrancy and updating vault variables\n        vaultVariables = so_.vaultVariables;\n\n        _validateEth(so_.initialEth);\n\n        return (nftId_, newCol_, so_.debtShares);\n    }\n\n    struct SmartOperatePerfect {\n        uint initialEth;\n        int newDebtToken0;\n        int newDebtToken1;\n        uint vaultVariables;\n    }\n\n    /// @notice Performs operations on a vault position with perfect collateral shares\n    /// @dev This function allows users to modify their vault position by adjusting collateral and debt\n    /// @param nftId_ The ID of the NFT representing the vault position\n    /// @param newCol_ The change in collateral amount (positive for deposit, negative for withdrawal)\n    /// @param perfectDebtShares_ The change in debt shares (positive for borrowing, negative for repayment)\n    /// @param debtToken0MinMax_ Min or max debt amount for token0 to payback or borrow (positive for borrowing, negative for repayment)\n    /// @param debtToken1MinMax_ Min or max debt amount for token1 to payback or borrow (positive for borrowing, negative for repayment)\n    /// @param to_ The address to receive withdrawn collateral or borrowed tokens (if address(0), defaults to msg.sender)\n    /// @return nftId_ The ID of the NFT representing the updated vault position\n    /// @return r_ int256 array of return values:\n    ///              0 - col amount, will only change if user sends type(int).min\n    ///              1 - final debt shares amount (can only change on max payback)\n    ///              2 - token0 borrow or payback amount\n    ///              3 - token1 borrow or payback amount\n    function operatePerfect(\n        uint nftId_,\n        int newCol_,\n        int perfectDebtShares_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_,\n        address to_\n    )\n        external\n        payable\n        _delegateCallCheck\n        returns (\n            uint256, // nftId_\n            int256[] memory r_\n        )\n    {\n        SmartOperatePerfect memory sop_;\n        r_ = new int256[](4);\n\n        sop_.vaultVariables = vaultVariables;\n        // re-entrancy check\n        if (sop_.vaultVariables & 1 == 0) {\n            // Updating on storage\n            vaultVariables = sop_.vaultVariables | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        sop_.initialEth = address(this).balance - msg.value;\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        // operate will throw if user tried to withdraw excess shares\n        // if max payback then perfectDebtShares_ will change from type(int).min to total user's debt shares\n        (nftId_, newCol_, perfectDebtShares_, sop_.vaultVariables) = _operate(\n            nftId_,\n            newCol_,\n            perfectDebtShares_,\n            to_,\n            sop_.vaultVariables\n        );\n\n        // payback back after operate because user might want to payback max and in that case below function won't work\n        if (perfectDebtShares_ < 0) {\n            (sop_.newDebtToken0, sop_.newDebtToken1) = _debtOperatePerfectPayback(\n                perfectDebtShares_,\n                debtToken0MinMax_,\n                debtToken1MinMax_\n            );\n        } else if (perfectDebtShares_ > 0) {\n            (sop_.newDebtToken0, sop_.newDebtToken1) = _debtOperatePerfectBorrow(\n                perfectDebtShares_,\n                debtToken0MinMax_,\n                debtToken1MinMax_,\n                to_\n            );\n        }\n\n        r_[0] = newCol_;\n        r_[1] = perfectDebtShares_;\n        r_[2] = sop_.newDebtToken0;\n        r_[3] = sop_.newDebtToken1;\n\n        // disabling re-entrancy and updating vault variables\n        vaultVariables = sop_.vaultVariables;\n\n        _validateEth(sop_.initialEth);\n\n        return (nftId_, r_);\n    }\n\n    constructor(ConstantViews memory constants_) Internals(constants_) {}\n}\n"
    },
    "contracts/protocols/vault/vaultT4/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract VaultT4Events {\n    /// @notice emitted when the supply rate config is updated\n    event LogUpdateSupplyRate(int supplyRate_);\n\n    /// @notice emitted when the borrow rate config is updated\n    event LogUpdateBorrowRate(int borrowRate_);\n\n    /// @notice emitted when the core setting configs are updated\n    event LogUpdateCoreSettings(\n        int supplyRate_,\n        int borrowRate_,\n        uint collateralFactor_,\n        uint liquidationThreshold_,\n        uint liquidationMaxLimit_,\n        uint withdrawGap_,\n        uint liquidationPenalty_,\n        uint borrowFee_\n    );\n}\n"
    },
    "contracts/protocols/vault/vaultT4/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { FluidVaultAdmin } from \"../../vaultTypesCommon/adminModule/main.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { VaultT4Events } from \"./events.sol\";\n\n/// @notice Fluid Vault protocol Admin Module contract.\n///         Implements admin related methods to set configs such as liquidation params, rates\n///         oracle address etc.\n///         Methods are limited to be called via delegateCall only. Vault CoreModule is expected\n///         to call the methods implemented here after checking the msg.sender is authorized.\n///         All methods update the exchange prices in storage before changing configs.\ncontract FluidVaultT4Admin is FluidVaultAdmin, VaultT4Events {\n    /// @notice updates the supply rate. Input in 1e2 (1% = 100, 100% = 10_000). If positive then incentives else charging\n    function updateSupplyRate(int supplyRate_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateSupplyRate(supplyRate_);\n\n        if ((supplyRate_ > int(X15)) || (-supplyRate_ > int(X15))) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        uint supplyRateToInsert_ = supplyRate_ < 0 ? (uint(-supplyRate_) << 1) : (uint(1) | (uint(supplyRate_) << 1));\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000) |\n            supplyRateToInsert_;\n    }\n\n    /// @notice updates the borrow rate. Input in 1e2 (1% = 100, 100% = 10_000). If positive then charging else incentives\n    function updateBorrowRate(int borrowRate_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowRate(borrowRate_);\n\n        if ((borrowRate_ > int(X15)) || (-borrowRate_ > int(X15))) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        uint borrowRateToInsert_ = borrowRate_ < 0 ? ((uint(-borrowRate_) << 1)) : (uint(1) | (uint(borrowRate_) << 1));\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff) |\n            (borrowRateToInsert_ << 16);\n    }\n\n    /// @notice updates the all Vault core settings according to input params.\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\n    function updateCoreSettings(\n        int256 supplyRate_,\n        int256 borrowRate_,\n        uint256 collateralFactor_,\n        uint256 liquidationThreshold_,\n        uint256 liquidationMaxLimit_,\n        uint256 withdrawGap_,\n        uint256 liquidationPenalty_,\n        uint256 borrowFee_\n    ) public _updateExchangePrice _verifyCaller {\n        // emitting the event at the start as then we are updating numbers to store in a more optimized way\n        emit LogUpdateCoreSettings(\n            supplyRate_,\n            borrowRate_,\n            collateralFactor_,\n            liquidationThreshold_,\n            liquidationMaxLimit_,\n            withdrawGap_,\n            liquidationPenalty_,\n            borrowFee_\n        );\n\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        collateralFactor_ = collateralFactor_ / 10;\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n        withdrawGap_ = withdrawGap_ / 10;\n\n        if (\n            (supplyRate_ > int(X15)) ||\n            (-supplyRate_ > int(X15)) ||\n            (borrowRate_ > int(X15)) ||\n            (-borrowRate_ > int(X15)) ||\n            (collateralFactor_ >= liquidationThreshold_) ||\n            (liquidationThreshold_ >= liquidationMaxLimit_) ||\n            (withdrawGap_ > X10) ||\n            (liquidationPenalty_ > X10) ||\n            (borrowFee_ > X10)\n        ) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n\n        uint supplyRateToInsert_ = supplyRate_ < 0 ? (uint(-supplyRate_) << 1) : (uint(1) | (uint(supplyRate_) << 1));\n\n        uint borrowRateToInsert_ = borrowRate_ < 0 ? ((uint(-borrowRate_) << 1)) : (uint(1) | (uint(borrowRate_) << 1));\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff00000000000000000000000) |\n            supplyRateToInsert_ |\n            (borrowRateToInsert_ << 16) |\n            (collateralFactor_ << 32) |\n            (liquidationThreshold_ << 42) |\n            (liquidationMaxLimit_ << 52) |\n            (withdrawGap_ << 62) |\n            (liquidationPenalty_ << 72) |\n            (borrowFee_ << 82);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT4/coreModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { FluidVault } from \"../../vaultTypesCommon/coreModule/main.sol\";\n\n/// @notice Fluid \"VaultT4\" (Vault Type 4). Fluid vault protocol main contract. T4 -> Smart collateral | Smart debt\n///         Fluid Vault protocol is a borrow / lending protocol, allowing users to create collateral / borrow positions.\n///         All funds are deposited into / borrowed from Fluid Liquidity layer.\n///         Positions are represented through NFTs minted by the VaultFactory.\n///         Deployed by \"VaultFactory\" and linked together with Vault AdminModule `ADMIN_IMPLEMENTATION` and\n///         FluidVaultSecondary (main2.sol) `SECONDARY_IMPLEMENTATION`.\n///         AdminModule & FluidVaultSecondary methods are delegateCalled, if the msg.sender has the required authorization.\n///         This contract links to an Oracle, which is used to assess collateral / debt value. Oracles implement the\n///         \"FluidOracle\" base contract and return the price in 1e27 precision.\n/// @dev    For view methods / accessing data, use the \"VaultResolver\" periphery contract.\n//\n// vaults can only be deployed for tokens that are listed at Liquidity (constructor reverts otherwise\n// if either the exchange price for the supply token or the borrow token is still not set at Liquidity).\nabstract contract Internals is FluidVault {\n    function _debtLiquidateBefore(\n        uint token0DebtAmt_,\n        uint token1DebtAmt_,\n        uint debtSharesMin_\n    ) internal returns (uint shares_) {\n        // paying back and burning shares\n        if (token0DebtAmt_ == 0 && token1DebtAmt_ == 0) {\n            // when burning shares, debt amount should always be > 0 (aka payback)\n            revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n        }\n\n        shares_ = BORROW.payback{\n            value: (BORROW_TOKEN0 == NATIVE_TOKEN)\n                ? token0DebtAmt_\n                : (BORROW_TOKEN1 == NATIVE_TOKEN)\n                    ? token1DebtAmt_\n                    : 0\n        }(token0DebtAmt_, token1DebtAmt_, debtSharesMin_, false);\n    }\n\n    function _colLiquidatePerfectAfter(\n        uint perfectColShares_,\n        uint token0ColAmtPerUnitShares_,\n        uint token1ColAmtPerUnitShares_,\n        address to_\n    ) internal returns (uint newColToken0_, uint newColToken1_) {\n        uint colToken0Min_ = (token0ColAmtPerUnitShares_ * perfectColShares_) / 1e18;\n        uint colToken1Min_ = (token1ColAmtPerUnitShares_ * perfectColShares_) / 1e18;\n\n        if (colToken0Min_ > 0 && colToken1Min_ > 0) {\n            (newColToken0_, newColToken1_) = SUPPLY.withdrawPerfect(\n                perfectColShares_,\n                colToken0Min_,\n                colToken1Min_,\n                to_\n            );\n        } else if (colToken0Min_ > 0 && colToken1Min_ == 0) {\n            // withdraw only in token0, newColToken1_ remains 0\n            (newColToken0_) = SUPPLY.withdrawPerfectInOneToken(perfectColShares_, colToken0Min_, colToken1Min_, to_);\n        } else if (colToken0Min_ == 0 && colToken1Min_ > 0) {\n            // withdraw only in token1, newColToken0_ remains 0\n            (newColToken1_) = SUPPLY.withdrawPerfectInOneToken(perfectColShares_, colToken0Min_, colToken1Min_, to_);\n        } else {\n            // both sent as 0\n            revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n        }\n    }\n\n    function _debtLiquidatePerfectPayback(\n        uint perfectDebtShares_,\n        uint token0DebtAmtPerUnitShares_,\n        uint token1DebtAmtPerUnitShares_\n    ) internal returns (uint token0DebtPaid_, uint token1DebtPaid_) {\n        uint debtToken0Min_ = (token0DebtAmtPerUnitShares_ * perfectDebtShares_) / 1e18;\n        uint debtToken1Min_ = (token1DebtAmtPerUnitShares_ * perfectDebtShares_) / 1e18;\n\n        if (debtToken0Min_ > 0 && debtToken1Min_ > 0) {\n            (token0DebtPaid_, token1DebtPaid_) = BORROW.paybackPerfect{\n                value: (BORROW_TOKEN0 == NATIVE_TOKEN)\n                    ? debtToken0Min_\n                    : (BORROW_TOKEN1 == NATIVE_TOKEN)\n                        ? debtToken1Min_\n                        : 0\n            }(perfectDebtShares_, debtToken0Min_, debtToken1Min_, false);\n        } else if (debtToken0Min_ > 0 && debtToken1Min_ == 0) {\n            // payback only in token0, token1DebtPaid_ remains 0\n            (token0DebtPaid_) = BORROW.paybackPerfectInOneToken{\n                value: (BORROW_TOKEN0 == NATIVE_TOKEN) ? debtToken0Min_ : 0\n            }(perfectDebtShares_, debtToken0Min_, debtToken1Min_, false);\n        } else if (debtToken0Min_ == 0 && debtToken1Min_ > 0) {\n            // payback only in token1, token0DebtPaid_ remains 0\n            (token1DebtPaid_) = BORROW.paybackPerfectInOneToken{\n                value: (BORROW_TOKEN1 == NATIVE_TOKEN) ? debtToken1Min_ : 0\n            }(perfectDebtShares_, debtToken0Min_, debtToken1Min_, false);\n        } else {\n            // both sent as 0\n            revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n        }\n    }\n\n    constructor(ConstantViews memory constants_) FluidVault(constants_) {}\n}\n\ncontract FluidVaultT4 is Internals {\n    /// @notice Performs operations on a vault position\n    /// @dev This function allows users to modify their vault position by adjusting collateral and debt\n    /// @param nftId_ The ID of the NFT representing the vault position\n    /// @param newColToken0_ The change in collateral amount for token0 (positive for deposit, negative for withdrawal)\n    /// @param newColToken1_ The change in collateral amount for token1 (positive for deposit, negative for withdrawal)\n    /// @param colSharesMinMax_ Min or max collateral shares to mint or burn (positive for deposit, negative for withdrawal)\n    /// @param newDebtToken0_ The change in debt amount for token0 (positive for borrowing, negative for repayment)\n    /// @param newDebtToken1_ The change in debt amount for token1 (positive for borrowing, negative for repayment)\n    /// @param debtSharesMinMax_ Min or max debt shares to burn or mint (positive for borrowing, negative for repayment)\n    /// @param to_ The address to receive funds (if address(0), defaults to msg.sender)\n    /// @return supplyAmt_ Final supply amount (negative if withdrawal occurred)\n    /// @return borrowAmt_ Final borrow amount (negative if repayment occurred)\n    function operate(\n        uint nftId_,\n        int newColToken0_,\n        int newColToken1_,\n        int colSharesMinMax_,\n        int newDebtToken0_,\n        int newDebtToken1_,\n        int debtSharesMinMax_,\n        address to_\n    )\n        external\n        payable\n        _dexFromAddress\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        )\n    {\n        return abi.decode(_spell(OPERATE_IMPLEMENTATION, msg.data), (uint, int, int));\n    }\n\n    /// @notice Performs operations on a vault position with perfect collateral shares\n    /// @dev This function allows users to modify their vault position by adjusting collateral and debt\n    /// @param nftId_ The ID of the NFT representing the vault position\n    /// @param perfectColShares_ The change in collateral shares (positive for deposit, negative for withdrawal)\n    /// @param colToken0MinMax_ Min or max collateral amount of token0 to withdraw or deposit (positive for deposit, negative for withdrawal)\n    /// @param colToken1MinMax_ Min or max collateral amount of token1 to withdraw or deposit (positive for deposit, negative for withdrawal)\n    /// @param perfectDebtShares_ The change in debt shares (positive for borrowing, negative for repayment)\n    /// @param debtToken0MinMax_ Min or max debt amount for token0 to borrow or payback (positive for borrowing, negative for repayment)\n    /// @param debtToken1MinMax_ Min or max debt amount for token1 to borrow or payback (positive for borrowing, negative for repayment)\n    /// @param to_ The address to receive funds (if address(0), defaults to msg.sender)\n    /// @return nftId_ The ID of the NFT representing the updated vault position\n    /// @return r_ int256 array of return values:\n    ///              0 - final col shares amount (can only change on max withdrawal)\n    ///              1 - token0 deposit or withdraw amount\n    ///              2 - token1 deposit or withdraw amount\n    ///              3 - final debt shares amount (can only change on max payback)\n    ///              4 - token0 borrow or payback amount\n    ///              5 - token1 borrow or payback amount\n    function operatePerfect(\n        uint nftId_,\n        int perfectColShares_,\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int perfectDebtShares_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_,\n        address to_\n    )\n        external\n        payable\n        _dexFromAddress\n        returns (\n            uint256, // nftId_\n            int256[] memory r_\n        )\n    {\n        return abi.decode(_spell(OPERATE_IMPLEMENTATION, msg.data), (uint, int256[]));\n    }\n\n    /// @notice Liquidates a vault position\n    /// @dev This function allows users to liquidate a vault position by adjusting collateral and debt\n    /// @param token0DebtAmt_ The amount of debt in token0 to payback\n    /// @param token1DebtAmt_ The amount of debt in token1 to payback\n    /// @param debtSharesMin_ The minimum number of debt shares to liquidate\n    /// @param colPerUnitDebt_ The collateral amount per unit of debt shares\n    /// @param token0ColAmtPerUnitShares_ The collateral amount per unit of debt shares for token0 (in 1e18)\n    /// @param token1ColAmtPerUnitShares_ The collateral amount per unit of debt shares for token1 (in 1e18)\n    /// @param to_ The address to receive withdrawn collateral (if address(0), defaults to msg.sender)\n    /// @param absorb_ Whether to liquidate absorbed liquidity as well\n    /// @return actualDebtShares_ The actual number of debt shares liquidated\n    /// @return actualColShares_ The actual number of collateral shares liquidated\n    /// @return token0Col_ The amount of token0 collateral withdrawn\n    /// @return token1Col_ The amount of token1 collateral withdrawn\n    function liquidate(\n        uint256 token0DebtAmt_,\n        uint256 token1DebtAmt_,\n        uint256 debtSharesMin_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    )\n        external\n        payable\n        _dexFromAddress\n        returns (uint256 actualDebtShares_, uint256 actualColShares_, uint256 token0Col_, uint256 token1Col_)\n    {\n        uint vaultVariables_ = vaultVariables;\n        // ############# turning re-entrancy bit on #############\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        uint initialEth_ = address(this).balance - msg.value;\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        uint sharesPaid_ = _debtLiquidateBefore(token0DebtAmt_, token1DebtAmt_, debtSharesMin_);\n        (actualDebtShares_, actualColShares_, vaultVariables_) = abi.decode(\n            _liquidate(sharesPaid_, colPerUnitDebt_, to_, absorb_, vaultVariables_),\n            (uint, uint, uint)\n        );\n\n        if (actualDebtShares_ < sharesPaid_) {\n            // shares paid should never be more than actual liquidation available\n            revert FluidVaultError(ErrorTypes.VaultDex__DebtSharesPaidMoreThanAvailableLiquidation);\n        }\n\n        (token0Col_, token1Col_) = _colLiquidatePerfectAfter(\n            actualColShares_,\n            token0ColAmtPerUnitShares_,\n            token1ColAmtPerUnitShares_,\n            to_\n        );\n\n        // disabling re-entrancy and updating on storage\n        vaultVariables = vaultVariables_;\n\n        _validateEth(initialEth_);\n    }\n\n    struct LiquidatePerfect {\n        uint256 vaultVariables;\n        uint256 initialEth;\n    }\n\n    /// @notice Liquidates a vault position with perfect collateral shares\n    /// @dev This function allows users to liquidate a vault position by adjusting collateral and debt\n    /// @param debtShares_ The number of debt shares to liquidate\n    /// @param token0DebtAmtPerUnitShares_ The debt amount per unit of debt shares for token0 (in 1e18)\n    /// @param token1DebtAmtPerUnitShares_ The debt amount per unit of debt shares for token1 (in 1e18)\n    /// @param colPerUnitDebt_ The collateral amount per unit of debt shares (in 1e18)\n    /// @param token0ColAmtPerUnitShares_ The collateral amount per unit of debt shares for token0 (in 1e18)\n    /// @param token1ColAmtPerUnitShares_ The collateral amount per unit of debt shares for token1 (in 1e18)\n    /// @param to_ The address to receive withdrawn collateral or borrowed tokens (if address(0), defaults to msg.sender)\n    /// @param absorb_ Whether to liquidate absorbed liquidity as well\n    /// @return actualDebtShares_ The actual number of debt shares liquidated\n    /// @return token0Debt_ The amount of debt in token0 that was paid back\n    /// @return token1Debt_ The amount of debt in token1 that was paid back\n    /// @return actualColShares_ The actual number of collateral shares liquidated\n    /// @return token0Col_ The amount of collateral in token0 that was withdrawn\n    /// @return token1Col_ The amount of collateral in token1 that was withdrawn\n    function liquidatePerfect(\n        uint256 debtShares_,\n        uint256 token0DebtAmtPerUnitShares_,\n        uint256 token1DebtAmtPerUnitShares_,\n        uint256 colPerUnitDebt_, // col per unit is w.r.t debt shares and not token0/1 debt amount\n        uint256 token0ColAmtPerUnitShares_, // in 1e18\n        uint256 token1ColAmtPerUnitShares_, // in 1e18\n        address to_,\n        bool absorb_\n    )\n        external\n        payable\n        _dexFromAddress\n        returns (\n            uint256 actualDebtShares_,\n            uint256 token0Debt_,\n            uint256 token1Debt_,\n            uint256 actualColShares_,\n            uint256 token0Col_,\n            uint256 token1Col_\n        )\n    {\n        LiquidatePerfect memory lp_;\n        lp_.vaultVariables = vaultVariables;\n        // ############# turning re-entrancy bit on #############\n        if (lp_.vaultVariables & 1 == 0) {\n            // Updating on storage\n            vaultVariables = lp_.vaultVariables | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        lp_.initialEth = address(this).balance - msg.value;\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        (actualDebtShares_, actualColShares_, lp_.vaultVariables) = abi.decode(\n            _liquidate(debtShares_, colPerUnitDebt_, to_, absorb_, lp_.vaultVariables),\n            (uint, uint, uint)\n        );\n\n        (token0Debt_, token1Debt_) = _debtLiquidatePerfectPayback(\n            actualDebtShares_,\n            token0DebtAmtPerUnitShares_,\n            token1DebtAmtPerUnitShares_\n        );\n\n        (token0Col_, token1Col_) = _colLiquidatePerfectAfter(\n            actualColShares_,\n            token0ColAmtPerUnitShares_,\n            token1ColAmtPerUnitShares_,\n            to_\n        );\n\n        // disabling re-entrancy and updating on storage\n        vaultVariables = lp_.vaultVariables;\n\n        _validateEth(lp_.initialEth);\n    }\n\n    constructor(ConstantViews memory constants_) Internals(constants_) {\n        // Note that vaults are deployed by VaultFactory so we somewhat trust the values being passed in\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultT4/coreModule/mainOperate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { FluidVaultOperate } from \"../../vaultTypesCommon/coreModule/mainOperate.sol\";\n\n/// @notice Fluid \"VaultT4\" (Vault Type 4). Fluid vault protocol main operate contract. T4 -> Smart collateral | Smart debt\nabstract contract Internals is FluidVaultOperate {\n    function _colOperateBefore(\n        int newColToken0_,\n        int newColToken1_,\n        int colSharesMinMax_,\n        address to_\n    ) internal returns (int shares_) {\n        if (colSharesMinMax_ > 0) {\n            // deposit & minting shares\n            if (newColToken0_ < 0 || newColToken1_ < 0 || (newColToken0_ == 0 && newColToken1_ == 0)) {\n                // when minting shares, collateral amount should always be > 0 (aka deposit)\n                revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n            }\n            shares_ = int(\n                SUPPLY.deposit{\n                    value: (SUPPLY_TOKEN0 == NATIVE_TOKEN)\n                        ? uint(newColToken0_)\n                        : (SUPPLY_TOKEN1 == NATIVE_TOKEN)\n                            ? uint(newColToken1_)\n                            : 0\n                }(uint(newColToken0_), uint(newColToken1_), uint(colSharesMinMax_), false)\n            );\n        } else if (colSharesMinMax_ < 0) {\n            // withdrawing and burning shares\n            if (newColToken0_ > 0 || newColToken1_ > 0 || (newColToken0_ == 0 && newColToken1_ == 0)) {\n                // when burning shares, collateral amount should always be < 0 (aka withdraw)\n                revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n            }\n            // withdraw both tokens from DEX protocol and update shares_\n            shares_ = -int(SUPPLY.withdraw(uint(-newColToken0_), uint(-newColToken1_), uint(-colSharesMinMax_), to_));\n        } else {\n            // if 0 then user does not want to deposit or withdraw, hence shares remain 0\n            if (newColToken0_ != 0 || newColToken1_ != 0) {\n                revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n            }\n        }\n    }\n\n    function _debtOperateBefore(\n        int newDebtToken0_,\n        int newDebtToken1_,\n        int debtSharesMinMax_,\n        address to_\n    ) internal returns (int shares_) {\n        if (debtSharesMinMax_ > 0) {\n            // borrowing & minting shares\n            if (newDebtToken0_ < 0 || newDebtToken1_ < 0 || (newDebtToken0_ == 0 && newDebtToken1_ == 0)) {\n                // when minting shares, debt amount should always be > 0 (aka borrow)\n                revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n            }\n            // borrowing both tokens from DEX protocol and update shares_\n            shares_ = int(BORROW.borrow(uint(newDebtToken0_), uint(newDebtToken1_), uint(debtSharesMinMax_), to_));\n        } else if (debtSharesMinMax_ < 0) {\n            // paying back and burning shares\n            if (newDebtToken0_ > 0 || newDebtToken1_ > 0 || (newDebtToken0_ == 0 && newDebtToken1_ == 0)) {\n                // when burning shares, debt amount should always be < 0 (aka payback)\n                revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n            }\n            shares_ = -int(\n                BORROW.payback{\n                    value: (BORROW_TOKEN0 == NATIVE_TOKEN)\n                        ? uint(-newDebtToken0_)\n                        : (BORROW_TOKEN1 == NATIVE_TOKEN)\n                            ? uint(-newDebtToken1_)\n                            : 0\n                }(uint(-newDebtToken0_), uint(-newDebtToken1_), uint(-debtSharesMinMax_), false)\n            );\n        } else {\n            // if 0 then user does not want to borrow or payback, hence shares remain 0\n            if (newDebtToken0_ != 0 || newDebtToken1_ != 0) {\n                revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n            }\n        }\n    }\n\n    function _colOperatePerfectBefore(\n        int perfectColShares_,\n        int colToken0MinMax_,\n        int colToken1MinMax_\n    ) internal returns (int newColToken0_, int newColToken1_) {\n        if ((colToken0MinMax_ <= 0) || (colToken0MinMax_ <= 0)) {\n            // max limit of token should be positive in case of deposit\n            revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n        }\n\n        (uint token0Amt_, uint token1Amt_) = SUPPLY.depositPerfect{\n            value: (SUPPLY_TOKEN0 == NATIVE_TOKEN)\n                ? uint(colToken0MinMax_)\n                : (SUPPLY_TOKEN1 == NATIVE_TOKEN)\n                    ? uint(colToken1MinMax_)\n                    : 0\n        }(uint(perfectColShares_), uint(colToken0MinMax_), uint(colToken1MinMax_), false);\n        newColToken0_ = int(token0Amt_);\n        newColToken1_ = int(token1Amt_);\n    }\n\n    function _debtOperatePerfectPayback(\n        int perfectDebtShares_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_\n    ) internal returns (int newDebtToken0_, int newDebtToken1_) {\n        uint token0Amt_;\n        uint token1Amt_;\n\n        if (debtToken0MinMax_ < 0 && debtToken1MinMax_ < 0) {\n            (token0Amt_, token1Amt_) = BORROW.paybackPerfect{\n                value: (BORROW_TOKEN0 == NATIVE_TOKEN)\n                    ? uint(-debtToken0MinMax_)\n                    : (BORROW_TOKEN1 == NATIVE_TOKEN)\n                        ? uint(-debtToken1MinMax_)\n                        : 0\n            }(uint(-perfectDebtShares_), uint(-debtToken0MinMax_), uint(-debtToken1MinMax_), false);\n        } else if (debtToken0MinMax_ < 0 && debtToken1MinMax_ == 0) {\n            // payback only in token0, token1Amt_ remains 0\n            (token0Amt_) = BORROW.paybackPerfectInOneToken{\n                value: (BORROW_TOKEN0 == NATIVE_TOKEN) ? uint(-debtToken0MinMax_) : 0\n            }(uint(-perfectDebtShares_), uint(-debtToken0MinMax_), uint(-debtToken1MinMax_), false);\n        } else if (debtToken0MinMax_ == 0 && debtToken1MinMax_ < 0) {\n            // payback only in token1, token0Amt_ remains 0\n            (token1Amt_) = BORROW.paybackPerfectInOneToken{\n                value: (BORROW_TOKEN1 == NATIVE_TOKEN) ? uint(-debtToken1MinMax_) : 0\n            }(uint(-perfectDebtShares_), uint(-debtToken0MinMax_), uint(-debtToken1MinMax_), false);\n        } else {\n            // meaning user sent both amount as >= 0 in case of payback\n            revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n        }\n\n        newDebtToken0_ = -int(token0Amt_);\n        newDebtToken1_ = -int(token1Amt_);\n    }\n\n    function _colOperatePerfectAfter(\n        int perfectColShares_,\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        address to_\n    ) internal returns (int newColToken0_, int newColToken1_) {\n        uint token0Amt_;\n        uint token1Amt_;\n        if (colToken0MinMax_ < 0 && colToken1MinMax_ < 0) {\n            (token0Amt_, token1Amt_) = SUPPLY.withdrawPerfect(\n                uint(-perfectColShares_),\n                uint(-colToken0MinMax_),\n                uint(-colToken1MinMax_),\n                to_\n            );\n        } else if (colToken0MinMax_ < 0 && colToken1MinMax_ == 0) {\n            // withdraw only in token0, newColToken1_ remains 0\n            (token0Amt_) = SUPPLY.withdrawPerfectInOneToken(\n                uint(-perfectColShares_),\n                uint(-colToken0MinMax_),\n                uint(-colToken1MinMax_),\n                to_\n            );\n        } else if (colToken0MinMax_ == 0 && colToken1MinMax_ < 0) {\n            // withdraw only in token1, newColToken0_ remains 0\n            (token1Amt_) = SUPPLY.withdrawPerfectInOneToken(\n                uint(-perfectColShares_),\n                uint(-colToken0MinMax_),\n                uint(-colToken1MinMax_),\n                to_\n            );\n        } else {\n            // meaning user sent both amount as >= 0 in case of withdraw\n            revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n        }\n\n        newColToken0_ = -int(token0Amt_);\n        newColToken1_ = -int(token1Amt_);\n    }\n\n    function _debtOperatePerfectBorrow(\n        int perfectDebtShares_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_,\n        address to_\n    ) internal returns (int newDebtToken0_, int newDebtToken1_) {\n        if ((debtToken0MinMax_ <= 0) || (debtToken1MinMax_ <= 0)) {\n            // min limit of token should be positive in case of borrow\n            revert FluidVaultError(ErrorTypes.VaultDex__InvalidOperateAmount);\n        }\n\n        (uint token0Amt_, uint token1Amt_) = BORROW.borrowPerfect(\n            uint(perfectDebtShares_),\n            uint(debtToken0MinMax_),\n            uint(debtToken1MinMax_),\n            to_\n        );\n        newDebtToken0_ = int(token0Amt_);\n        newDebtToken1_ = int(token1Amt_);\n    }\n\n    constructor(ConstantViews memory constants_) FluidVaultOperate(constants_) {}\n}\n\ncontract FluidVaultT4Operate is Internals {\n    struct SmartOperate {\n        uint initialEth;\n        int colShares;\n        int debtShares;\n        uint256 vaultVariables;\n    }\n\n    /// @notice Performs operations on a vault position\n    /// @dev This function allows users to modify their vault position by adjusting collateral and debt\n    /// @param nftId_ The ID of the NFT representing the vault position\n    /// @param newColToken0_ The change in collateral amount for token0 (positive for deposit, negative for withdrawal)\n    /// @param newColToken1_ The change in collateral amount for token1 (positive for deposit, negative for withdrawal)\n    /// @param colSharesMinMax_ Min or max collateral shares to mint or burn (positive for deposit, negative for withdrawal)\n    /// @param newDebtToken0_ The change in debt amount for token0 (positive for borrowing, negative for repayment)\n    /// @param newDebtToken1_ The change in debt amount for token1 (positive for borrowing, negative for repayment)\n    /// @param debtSharesMinMax_ Min or max debt shares to burn or mint (positive for borrowing, negative for repayment)\n    /// @param to_ The address to receive withdrawn collateral or borrowed tokens (if address(0), defaults to msg.sender)\n    /// @return nftId_ The ID of the NFT representing the updated vault position\n    /// @return supplyAmt_ Final supply amount (negative if withdrawal occurred)\n    /// @return borrowAmt_ Final borrow amount (negative if repayment occurred)\n    function operate(\n        uint nftId_,\n        int newColToken0_,\n        int newColToken1_,\n        int colSharesMinMax_,\n        int newDebtToken0_,\n        int newDebtToken1_,\n        int debtSharesMinMax_,\n        address to_\n    )\n        external\n        payable\n        _delegateCallCheck\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256 // final borrow amount. if - then payback\n        )\n    {\n        SmartOperate memory so_;\n\n        so_.vaultVariables = vaultVariables;\n        // re-entrancy check\n        if (so_.vaultVariables & 1 == 0) {\n            // Updating on storage\n            vaultVariables = so_.vaultVariables | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        so_.initialEth = address(this).balance - msg.value;\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        so_.colShares = _colOperateBefore(newColToken0_, newColToken1_, colSharesMinMax_, to_);\n        so_.debtShares = _debtOperateBefore(newDebtToken0_, newDebtToken1_, debtSharesMinMax_, to_);\n\n        // operate will throw is user tried to withdraw excess shares\n        // so_.colShares returned after should remain same as before\n        // so_.debtShares returned after should remain same as before\n        (nftId_, so_.colShares, so_.debtShares, so_.vaultVariables) = _operate(\n            nftId_,\n            so_.colShares,\n            so_.debtShares,\n            to_,\n            so_.vaultVariables\n        );\n\n        // disabling re-entrancy and updating vault variables\n        vaultVariables = so_.vaultVariables;\n\n        _validateEth(so_.initialEth);\n\n        return (nftId_, so_.colShares, so_.debtShares);\n    }\n\n    struct SmartOperatePerfect {\n        uint initialEth;\n        int newColToken0;\n        int newColToken1;\n        int newDebtToken0;\n        int newDebtToken1;\n        uint vaultVariables;\n    }\n\n    /// @notice Performs operations on a vault position with perfect collateral shares\n    /// @dev This function allows users to modify their vault position by adjusting collateral and debt\n    /// @param nftId_ The ID of the NFT representing the vault position\n    /// @param perfectColShares_ The change in collateral shares (positive for deposit, negative for withdrawal)\n    /// @param colToken0MinMax_ Min or max collateral amount of token0 to withdraw or deposit (positive for deposit, negative for withdrawal)\n    /// @param colToken1MinMax_ Min or max collateral amount of token1 to withdraw or deposit (positive for deposit, negative for withdrawal)\n    /// @param perfectDebtShares_ The change in debt shares (positive for borrowing, negative for repayment)\n    /// @param debtToken0MinMax_ Min or max debt amount for token0 to borrow or payback (positive for borrowing, negative for repayment)\n    /// @param debtToken1MinMax_ Min or max debt amount for token1 to borrow or payback (positive for borrowing, negative for repayment)\n    /// @return nftId_ The ID of the NFT representing the updated vault position\n    /// @return r_ int256 array of return values:\n    ///              0 - final col shares amount (can only change on max withdrawal)\n    ///              1 - token0 deposit or withdraw amount\n    ///              2 - token1 deposit or withdraw amount\n    ///              3 - final debt shares amount (can only change on max payback)\n    ///              4 - token0 borrow or payback amount\n    ///              5 - token1 borrow or payback amount\n    function operatePerfect(\n        uint nftId_,\n        int perfectColShares_,\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int perfectDebtShares_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_,\n        address to_\n    )\n        external\n        payable\n        _delegateCallCheck\n        returns (\n            uint256, // nftId_\n            int256[] memory r_\n        )\n    {\n        SmartOperatePerfect memory sop_;\n        r_ = new int256[](6);\n\n        sop_.vaultVariables = vaultVariables;\n        // re-entrancy check\n        if (sop_.vaultVariables & 1 == 0) {\n            // Updating on storage\n            vaultVariables = sop_.vaultVariables | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        sop_.initialEth = address(this).balance - msg.value;\n\n        to_ = to_ == address(0) ? msg.sender : to_;\n\n        if (perfectColShares_ > 0) {\n            (sop_.newColToken0, sop_.newColToken1) = _colOperatePerfectBefore(\n                perfectColShares_,\n                colToken0MinMax_,\n                colToken1MinMax_\n            );\n        }\n\n        // operate will throw if user tried to withdraw excess shares\n        // if max withdrawal then perfectColShares_ will change from type(int).min to total user's col shares\n        // if max payback then perfectDebtShares_ will change from type(int).min to total user's debt shares\n        (nftId_, perfectColShares_, perfectDebtShares_, sop_.vaultVariables) = _operate(\n            nftId_,\n            perfectColShares_,\n            perfectDebtShares_,\n            to_,\n            sop_.vaultVariables\n        );\n\n        if (perfectColShares_ < 0) {\n            (sop_.newColToken0, sop_.newColToken1) = _colOperatePerfectAfter(\n                perfectColShares_,\n                colToken0MinMax_,\n                colToken1MinMax_,\n                to_\n            );\n        }\n\n        // payback back after operate because user might want to payback max and in that case below function won't work\n        if (perfectDebtShares_ < 0) {\n            (sop_.newDebtToken0, sop_.newDebtToken1) = _debtOperatePerfectPayback(\n                perfectDebtShares_,\n                debtToken0MinMax_,\n                debtToken1MinMax_\n            );\n        } else if (perfectDebtShares_ > 0) {\n            (sop_.newDebtToken0, sop_.newDebtToken1) = _debtOperatePerfectBorrow(\n                perfectDebtShares_,\n                debtToken0MinMax_,\n                debtToken1MinMax_,\n                to_\n            );\n        }\n\n        r_[0] = perfectColShares_;\n        r_[1] = sop_.newColToken0;\n        r_[2] = sop_.newColToken1;\n        r_[3] = perfectDebtShares_;\n        r_[4] = sop_.newDebtToken0;\n        r_[5] = sop_.newDebtToken1;\n\n        // disabling re-entrancy and updating vault variables\n        vaultVariables = sop_.vaultVariables;\n\n        _validateEth(sop_.initialEth);\n\n        return (nftId_, r_);\n    }\n\n    constructor(ConstantViews memory constants_) Internals(constants_) {}\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Events {\n    /// @notice emitted when the collateral factor config is updated\n    event LogUpdateCollateralFactor(uint collateralFactor_);\n\n    /// @notice emitted when the liquidation threshold config is updated\n    event LogUpdateLiquidationThreshold(uint liquidationThreshold_);\n\n    /// @notice emitted when the liquidation max limit config is updated\n    event LogUpdateLiquidationMaxLimit(uint liquidationMaxLimit_);\n\n    /// @notice emitted when the withdrawal gap config is updated\n    event LogUpdateWithdrawGap(uint withdrawGap_);\n\n    /// @notice emitted when the liquidation penalty config is updated\n    event LogUpdateLiquidationPenalty(uint liquidationPenalty_);\n\n    /// @notice emitted when the borrow fee config is updated\n    event LogUpdateBorrowFee(uint borrowFee_);\n\n    /// @notice emitted when the oracle is updated\n    event LogUpdateOracle(uint indexed deploymentNonce_, address indexed newOracle_);\n\n    /// @notice emitted when the allowed rebalancer is updated\n    event LogUpdateRebalancer(address indexed newRebalancer_);\n\n    /// @notice emitted when funds are rescued\n    event LogRescueFunds(address indexed token_);\n\n    /// @notice emitted when dust debt is absorbed for `nftIds_`\n    event LogAbsorbDustDebt(uint256[] nftIds_, uint256 absorbedDustDebt_);\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IFluidOracle } from \"../../../../oracle/fluidOracle.sol\";\n\nimport { Variables } from \"../common/variables.sol\";\nimport { Events } from \"./events.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\nimport { IFluidVault } from \"../../interfaces/iVault.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { TickMath } from \"../../../../libraries/tickMath.sol\";\nimport { AddressCalcs } from \"../../../../libraries/addressCalcs.sol\";\nimport { SafeTransfer } from \"../../../../libraries/safeTransfer.sol\";\n\n/// @notice Fluid Vault protocol Admin Module contract.\n///         Implements admin related methods to set configs such as liquidation params, rates\n///         oracle address etc.\n///         Methods are limited to be called via delegateCall only. Vault CoreModule (\"VaultT1\" contract)\n///         is expected to call the methods implemented here after checking the msg.sender is authorized.\n///         All methods update the exchange prices in storage before changing configs.\nabstract contract FluidVaultAdmin is Variables, Events, Error {\n    uint internal constant X8 = 0xff;\n    uint internal constant X10 = 0x3ff;\n    uint internal constant X15 = 0x7fff;\n    uint internal constant X16 = 0xffff;\n    uint internal constant X19 = 0x7ffff;\n    uint internal constant X24 = 0xffffff;\n    uint internal constant X30 = 0x3fffffff;\n    uint internal constant X64 = 0xffffffffffffffff;\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address internal immutable addressThis;\n\n    constructor() {\n        addressThis = address(this);\n    }\n\n    modifier _verifyCaller() {\n        if (address(this) == addressThis) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev updates exchange price on storage, called on all admin methods in combination with _verifyCaller modifier so\n    /// only called by authorized delegatecall\n    modifier _updateExchangePrice() {\n        IFluidVault(address(this)).updateExchangePricesOnStorage();\n        _;\n    }\n\n    function _checkLiquidationMaxLimitAndPenalty(uint liquidationMaxLimit_, uint liquidationPenalty_) internal pure {\n        // liquidation max limit with penalty should not go above 99.7%\n        // As liquidation with penalty can happen from liquidation Threshold to max limit\n        // If it goes above 100% than that means liquidator is getting more collateral than user's available\n        if ((liquidationMaxLimit_ + liquidationPenalty_) > 9970) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n        }\n    }\n\n    /// @notice updates the collateral factor to `collateralFactor_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateCollateralFactor(uint collateralFactor_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateCollateralFactor(collateralFactor_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\n\n        collateralFactor_ = collateralFactor_ / 10;\n\n        if (collateralFactor_ >= liquidationThreshold_) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffc00ffffffff) |\n            (collateralFactor_ << 32);\n    }\n\n    /// @notice updates the liquidation threshold to `liquidationThreshold_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationThreshold(uint liquidationThreshold_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationThreshold(liquidationThreshold_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint collateralFactor_ = ((vaultVariables2_ >> 32) & X10);\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\n\n        liquidationThreshold_ = liquidationThreshold_ / 10;\n\n        if ((collateralFactor_ >= liquidationThreshold_) || (liquidationThreshold_ >= liquidationMaxLimit_))\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffff003ffffffffff) |\n            (liquidationThreshold_ << 42);\n    }\n\n    /// @notice updates the liquidation max limit to `liquidationMaxLimit_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationMaxLimit(uint liquidationMaxLimit_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationMaxLimit(liquidationMaxLimit_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\n        uint liquidationPenalty_ = ((vaultVariables2_ >> 72) & X10);\n\n        // both are in 1e2 decimals (1e2 = 1%)\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\n\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\n\n        if (liquidationThreshold_ >= liquidationMaxLimit_)\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffc00fffffffffffff) |\n            (liquidationMaxLimit_ << 52);\n    }\n\n    /// @notice updates the withdrawal gap to `withdrawGap_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateWithdrawGap(uint withdrawGap_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateWithdrawGap(withdrawGap_);\n\n        withdrawGap_ = withdrawGap_ / 10;\n\n        // withdrawGap must not be > 100%\n        if (withdrawGap_ > 1000) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffff003fffffffffffffff) |\n            (withdrawGap_ << 62);\n    }\n\n    /// @notice updates the liquidation penalty to `liquidationPenalty_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationPenalty(uint liquidationPenalty_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateLiquidationPenalty(liquidationPenalty_);\n\n        uint vaultVariables2_ = vaultVariables2;\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\n\n        // Converting liquidationMaxLimit_ in 1e2 decimals (1e2 = 1%)\n        _checkLiquidationMaxLimitAndPenalty((liquidationMaxLimit_ * 10), liquidationPenalty_);\n\n        if (liquidationPenalty_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffc00ffffffffffffffffff) |\n            (liquidationPenalty_ << 72);\n    }\n\n    /// @notice updates the borrow fee to `borrowFee_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateBorrowFee(uint borrowFee_) public _updateExchangePrice _verifyCaller {\n        emit LogUpdateBorrowFee(borrowFee_);\n\n        if (borrowFee_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff003ffffffffffffffffffff) |\n            (borrowFee_ << 82);\n    }\n\n    /// @notice updates the Vault oracle to `newOracleNonce_`. Must implement the FluidOracle interface.\n    function updateOracle(uint newOracleNonce_) public _updateExchangePrice _verifyCaller {\n        if (newOracleNonce_ > X30) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\n\n        // masking to remove old oracle and keep all the other values intact\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffc0000000fffffffffffffffffffffff) |\n            (newOracleNonce_ << 92);\n\n        IFluidVault.ConstantViews memory c_ = IFluidVault(address(this)).constantsView();\n\n        address oracle_ = AddressCalcs.addressCalc(c_.deployer, newOracleNonce_);\n\n        // checking if oracle address follows the standard\n        IFluidOracle(oracle_).getExchangeRateOperate();\n        IFluidOracle(oracle_).getExchangeRateLiquidate();\n\n        emit LogUpdateOracle(newOracleNonce_, oracle_);\n    }\n\n    /// @notice updates the allowed rebalancer to `newRebalancer_`.\n    function updateRebalancer(address newRebalancer_) public _updateExchangePrice _verifyCaller {\n        if (newRebalancer_ == address(0)) revert FluidVaultError(ErrorTypes.VaultAdmin__AddressZeroNotAllowed);\n\n        rebalancer = newRebalancer_;\n\n        emit LogUpdateRebalancer(newRebalancer_);\n    }\n\n    /// @notice sends any potentially stuck funds to Liquidity contract.\n    /// @dev this contract never holds any funds as all operations send / receive funds from user <-> Liquidity.\n    function rescueFunds(address token_) external _verifyCaller {\n        if (token_ == NATIVE_TOKEN) {\n            SafeTransfer.safeTransferNative(IFluidVault(address(this)).LIQUIDITY(), address(this).balance);\n        } else {\n            SafeTransfer.safeTransfer(\n                token_,\n                IFluidVault(address(this)).LIQUIDITY(),\n                IERC20(token_).balanceOf(address(this))\n            );\n        }\n\n        emit LogRescueFunds(token_);\n    }\n\n    /// @notice absorbs accumulated dust debt\n    /// @dev in decades if a lot of positions are 100% liquidated (aka absorbed) then dust debt can mount up\n    /// which is basically sort of an extra revenue for the protocol.\n    //\n    // this function might never come in use that's why adding it in admin module\n    function absorbDustDebt(uint[] memory nftIds_) public _verifyCaller {\n        uint256 vaultVariables_ = vaultVariables;\n        // re-entrancy check\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        uint nftId_;\n        uint posData_;\n        int posTick_;\n        uint tickId_;\n        uint posCol_;\n        uint posDebt_;\n        uint posDustDebt_;\n        uint tickData_;\n\n        uint absorbedDustDebt_ = absorbedDustDebt;\n\n        for (uint i = 0; i < nftIds_.length; ) {\n            nftId_ = nftIds_[i];\n            if (nftId_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftIdShouldBeNonZero);\n            }\n\n            // user's position data\n            posData_ = positionData[nftId_];\n\n            if (posData_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotOfThisVault);\n            }\n\n            posCol_ = (posData_ >> 45) & X64;\n            // Converting big number into normal number\n            posCol_ = (posCol_ >> 8) << (posCol_ & X8);\n\n            posDustDebt_ = (posData_ >> 109) & X64;\n            // Converting big number into normal number\n            posDustDebt_ = (posDustDebt_ >> 8) << (posDustDebt_ & X8);\n\n            if (posDustDebt_ == 0) {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__DustDebtIsZero);\n            }\n\n            // borrow position (has collateral & debt)\n            posTick_ = posData_ & 2 == 2 ? int((posData_ >> 2) & X19) : -int((posData_ >> 2) & X19);\n            tickId_ = (posData_ >> 21) & X24;\n\n            posDebt_ = (TickMath.getRatioAtTick(int24(posTick_)) * posCol_) >> 96;\n\n            // Tick data from user's tick\n            tickData_ = tickData[posTick_];\n\n            // Checking if tick is liquidated OR if the total IDs of tick is greater than user's tick ID\n            if (((tickData_ & 1) == 1) || (((tickData_ >> 1) & X24) > tickId_)) {\n                // User got liquidated\n                (, posDebt_, , , ) = IFluidVault(address(this)).fetchLatestPosition(\n                    posTick_,\n                    tickId_,\n                    posDebt_,\n                    tickData_\n                );\n                if (posDebt_ > 0) {\n                    revert FluidVaultError(ErrorTypes.VaultAdmin__FinalDebtShouldBeZero);\n                }\n                // absorbing user's debt as it's 100% or almost 100% liquidated\n                absorbedDustDebt_ = absorbedDustDebt_ + posDustDebt_;\n                // making position as supply only\n                positionData[nftId_] = 1;\n            } else {\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotLiquidated);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n\n        if (absorbedDustDebt_ == 0) {\n            revert FluidVaultError(ErrorTypes.VaultAdmin__AbsorbedDustDebtIsZero);\n        }\n\n        uint totalBorrow_ = (vaultVariables_ >> 146) & X64;\n        // Converting big number into normal number\n        totalBorrow_ = (totalBorrow_ >> 8) << (totalBorrow_ & X8);\n        // note: by default dust debt is not added into total borrow but on 100% liquidation (aka absorb) dust debt equivalent\n        // is removed from total borrow so adding it back again here\n        totalBorrow_ = totalBorrow_ + absorbedDustDebt_;\n        totalBorrow_ = BigMathMinified.toBigNumber(totalBorrow_, 56, 8, BigMathMinified.ROUND_UP);\n\n        // adding absorbed dust debt to total borrow so it will get included in the next rebalancing.\n        // there is some fuzziness here as when the position got fully liquidated (aka absorbed) the exchange price was different\n        // than what it'll be now. The fuzziness which will be extremely small so we can ignore it\n        // updating on storage\n        vaultVariables =\n            (vaultVariables_ & 0xfffffffffffc0000000000000003ffffffffffffffffffffffffffffffffffff) |\n            (totalBorrow_ << 146);\n\n        // updating on storage\n        absorbedDustDebt = 0;\n\n        emit LogAbsorbDustDebt(nftIds_, absorbedDustDebt_);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/common/tokenTransfers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { SafeTransfer } from \"../../../../libraries/safeTransfer.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { Error } from \"../../error.sol\";\n\nabstract contract TokenTransfers is Error {\n    function _validateEth(uint initialEth_) internal {\n        uint finalEth_ = payable(address(this)).balance;\n        if (finalEth_ > initialEth_) {\n            unchecked {\n                SafeTransfer.safeTransferNative(msg.sender, finalEth_ - initialEth_); // sending back excess ETH\n            }\n        } else if (finalEth_ < initialEth_) {\n            revert FluidVaultError(ErrorTypes.Vault__InvalidMsgValueOperate);\n        }\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/common/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Variables {\n    /***********************************|\n    |         Storage Variables         |\n    |__________________________________*/\n\n    /// note: in all variables. For tick >= 0 are represented with bit as 1, tick < 0 are represented with bit as 0\n    /// note: read all the variables through storageRead.sol\n\n    /// note: vaultVariables contains vault variables which need regular updates through transactions\n    /// First 1 bit => 0 => re-entrancy. If 0 then allow transaction to go, else throw.\n    /// Next 1 bit => 1 => Is the current active branch liquidated? If true then check the branch's minima tick before creating a new position\n    /// If the new tick is greater than minima tick then initialize a new branch, make that as current branch & do proper linking\n    /// Next 1 bit => 2 => sign of topmost tick (0 -> negative; 1 -> positive)\n    /// Next 19 bits => 3-21 => absolute value of topmost tick\n    /// Next 30 bits => 22-51 => current branch ID\n    /// Next 30 bits => 52-81 => total branch ID\n    /// Next 64 bits => 82-145 => Total supply\n    /// Next 64 bits => 146-209 => Total borrow\n    /// Next 32 bits => 210-241 => Total positions\n    uint256 internal vaultVariables;\n\n    /// note: vaultVariables2 contains variables which do not update on every transaction. So mainly admin/auth set amount\n    /// First 16 bits => 0-15 => supply rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\n    /// Next 16 bits => 16-31 => borrow rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\n    /// Next 10 bits => 32-41 => collateral factor. 800 = 0.8 = 80% (max precision of 0.1%)\n    /// Next 10 bits => 42-51 => liquidation Threshold. 900 = 0.9 = 90% (max precision of 0.1%)\n    /// Next 10 bits => 52-61 => liquidation Max Limit. 950 = 0.95 = 95% (max precision of 0.1%) (above this 100% liquidation can happen)\n    /// Next 10 bits => 62-71 => withdraw gap. 100 = 0.1 = 10%. (max precision of 0.1%) (max 7 bits can also suffice for the requirement here of 0.1% to 10%). Needed to save some limits on withdrawals so liquidate can work seamlessly.\n    /// Next 10 bits => 72-81 => liquidation penalty. 100 = 0.01 = 1%. (max precision of 0.01%) (max liquidation penantly can be 10.23%). Applies when tick is in between liquidation Threshold & liquidation Max Limit.\n    /// Next 10 bits => 82-91 => borrow fee. 100 = 0.01 = 1%. (max precision of 0.01%) (max borrow fee can be 10.23%). Fees on borrow.\n    /// Next 30 bits => 92-121 => bits to calculate address of oracle\n    /// Next 33 bits => 122-154 => last update timestamp\n    uint256 internal vaultVariables2;\n\n    /// note: stores absorbed liquidity\n    /// First 128 bits raw debt amount\n    /// last 128 bits raw col amount\n    uint256 internal absorbedLiquidity;\n\n    /// position index => position data uint\n    /// if the entire variable is 0 (meaning not initialized) at the start that means no position at all\n    /// First 1 bit => 0 => position type (0 => borrow position; 1 => supply position)\n    /// Next 1 bit => 1 => sign of user's tick (0 => negative; 1 => positive)\n    /// Next 19 bits => 2-20 => absolute value of user's tick\n    /// Next 24 bits => 21-44 => user's tick's id\n    /// Below we are storing user's collateral & not debt, because the position can also be only collateral with no tick but it can never be only debt\n    /// Next 64 bits => 45-108 => user's supply amount. Debt will be calculated through supply & ratio.\n    /// Next 64 bits => 109-172 => user's dust debt amount. User's net debt = total debt - dust amount. Total debt is calculated through supply & ratio\n    /// User won't pay any extra interest on dust debt & hence we will not show it as a debt on UI. For user's there's no dust.\n    mapping(uint256 => uint256) internal positionData;\n\n    /// Tick has debt only keeps data of non liquidated positions. liquidated tick's data stays in branch itself\n    /// tick parent => uint (represents bool for 256 children)\n    /// parent of (i)th tick:-\n    /// if (i>=0) (i / 256);\n    /// else ((i + 1) / 256) - 1\n    /// first bit of the variable is the smallest tick & last bit is the biggest tick of that slot\n    mapping(int256 => uint256) internal tickHasDebt;\n\n    /// mapping tickId => tickData\n    /// Tick related data. Total debt & other things\n    /// First bit => 0 => If 1 then liquidated else not liquidated\n    /// Next 24 bits => 1-24 => Total IDs. ID should start from 1.\n    /// If not liquidated:\n    /// Next 64 bits => 25-88 => raw debt\n    /// If liquidated\n    /// The below 3 things are of last ID. This is to be updated when user creates a new position\n    /// Next 1 bit => 25 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated (100% liquidated)\n    /// Next 30 bits => 26-55 => branch ID where this tick got liquidated\n    /// Next 50 bits => 56-105 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    mapping(int256 => uint256) internal tickData;\n\n    /// tick id => previous tick id liquidation data. ID starts from 1\n    /// One tick ID contains 3 IDs of 80 bits in it, holding liquidation data of previously active but liquidated ticks\n    /// 81 bits data below\n    /// #### First 85 bits ####\n    /// 1st bit => 0 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 1-30 => branch ID where this tick got liquidated\n    /// Next 50 bits => 31-80 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    /// #### Second 85 bits ####\n    /// 85th bit => 85 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 86-115 => branch ID where this tick got liquidated\n    /// Next 50 bits => 116-165 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    /// #### Third 85 bits ####\n    /// 170th bit => 170 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\n    /// Next 30 bits => 171-200 => branch ID where this tick got liquidated\n    /// Next 50 bits => 201-250 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\n    mapping(int256 => mapping(uint256 => uint256)) internal tickId;\n\n    /// mapping branchId => branchData\n    /// First 2 bits => 0-1 => if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\n    /// merged means the branch is merged into it's base branch\n    /// closed means all the users are 100% liquidated\n    /// Next 1 bit => 2 => minima tick sign of this branch. Will only be there if any liquidation happened.\n    /// Next 19 bits => 3-21 => minima tick of this branch. Will only be there if any liquidation happened.\n    /// Next 30 bits => 22-51 => Partials of minima tick of branch this is connected to. 0 if master branch.\n    /// Next 64 bits => 52-115 Debt liquidity at this branch. Similar to last's top tick data. Remaining debt will move here from tickData after first liquidation\n    /// If not merged\n    /// Next 50 bits => 116-165 => Debt factor or of this branch. (35 bits coefficient | 15 bits expansion)\n    /// If merged\n    /// Next 50 bits => 116-165 => Connection/adjustment debt factor of this branch with the next branch.\n    /// If closed\n    /// Next 50 bits => 116-165 => Debt factor as 0. As all the user's positions are now fully gone\n    /// following values are present always again (merged / not merged / closed)\n    /// Next 30 bits => 166-195 => Branch's ID with which this branch is connected. If 0 then that means this is the master branch\n    /// Next 1 bit => 196 => sign of minima tick of branch this is connected to. 0 if master branch.\n    /// Next 19 bits => 197-215 => minima tick of branch this is connected to. 0 if master branch.\n    mapping(uint256 => uint256) internal branchData;\n\n    /// Exchange prices are in 1e12\n    /// First 64 bits => 0-63 => Liquidity's collateral token supply exchange price\n    /// First 64 bits => 64-127 => Liquidity's debt token borrow exchange price\n    /// First 64 bits => 128-191 => Vault's collateral token supply exchange price\n    /// First 64 bits => 192-255 => Vault's debt token borrow exchange price\n    uint256 internal rates;\n\n    /// address of rebalancer\n    address internal rebalancer;\n\n    uint256 internal absorbedDustDebt;\n\n    address internal dexFromAddress;\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/coreModule/constantVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidVaultFactory } from \"../../interfaces/iVaultFactory.sol\";\nimport { IFluidLiquidity } from \"../../../../liquidity/interfaces/iLiquidity.sol\";\nimport { StorageRead } from \"../../../../libraries/storageRead.sol\";\nimport { ILiquidityDexCommon } from \"../../interfaces/iLiquidityDexCommon.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { Error } from \"../../error.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { FluidProtocolTypes } from \"../../../../libraries/fluidProtocolTypes.sol\";\n\ninterface TokenInterface {\n    function decimals() external view returns (uint8);\n}\n\nabstract contract ConstantVariables is StorageRead, Structs, Error {\n    /***********************************|\n    |        Constant Variables         |\n    |__________________________________*/\n\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address internal constant DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n    /// @dev collateral token address\n    address internal immutable SUPPLY_TOKEN;\n    /// @dev borrow token address\n    address internal immutable BORROW_TOKEN;\n\n    /// @dev contract via which we deploy oracle contract\n    address internal immutable DEPLOYER_CONTRACT;\n\n    ILiquidityDexCommon internal immutable SUPPLY;\n    ILiquidityDexCommon internal immutable BORROW;\n\n    /// @dev if smart collateral then token0 is dex token0 address else it's normal collateral token0 address\n    address internal immutable SUPPLY_TOKEN0;\n    /// @dev if smart collateral then token1 is dex token1 address else it's address(0)\n    address internal immutable SUPPLY_TOKEN1;\n\n    /// @dev if smart debt then token0 is dex token0 address else it's normal borrow token0 address\n    address internal immutable BORROW_TOKEN0;\n    /// @dev if smart debt then token1 is dex token1 address else it's address(0)\n    address internal immutable BORROW_TOKEN1;\n\n    /// @dev Vault OperateModule implemenation address\n    address internal immutable OPERATE_IMPLEMENTATION;\n\n    /// @dev Vault AdminModule implemenation address\n    address internal immutable ADMIN_IMPLEMENTATION;\n\n    /// @dev Vault Secondary implemenation (main2.sol) address\n    address internal immutable SECONDARY_IMPLEMENTATION;\n\n    /// @dev liquidity proxy contract address\n    IFluidLiquidity public immutable LIQUIDITY;\n\n    /// @dev vault factory contract address\n    IFluidVaultFactory public immutable VAULT_FACTORY;\n\n    uint public immutable VAULT_ID;\n\n    uint public immutable TYPE;\n\n    uint internal constant X8 = 0xff;\n    uint internal constant X10 = 0x3ff;\n    uint internal constant X15 = 0x7fff;\n    uint internal constant X16 = 0xffff;\n    uint internal constant X19 = 0x7ffff;\n    uint internal constant X20 = 0xfffff;\n    uint internal constant X24 = 0xffffff;\n    uint internal constant X25 = 0x1ffffff;\n    uint internal constant X30 = 0x3fffffff;\n    uint internal constant X33 = 0x1ffffffff;\n    uint internal constant X35 = 0x7ffffffff;\n    uint internal constant X50 = 0x3ffffffffffff;\n    uint internal constant X64 = 0xffffffffffffffff;\n    uint internal constant X96 = 0xffffffffffffffffffffffff;\n    uint internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev slot ids in Liquidity contract. Helps in low gas fetch from liquidity contract by skipping delegate call\n    bytes32 internal immutable SUPPLY_EXCHANGE_PRICE_SLOT; // Can be of DEX or liquidity layer\n    bytes32 internal immutable BORROW_EXCHANGE_PRICE_SLOT; // Can be of DEX or liquidity layer\n    bytes32 internal immutable USER_SUPPLY_SLOT; // Can be of DEX or liquidity layer\n    bytes32 internal immutable USER_BORROW_SLOT; // Can be of DEX or liquidity layer\n\n    constructor(ConstantViews memory constants_) {\n        TYPE = constants_.vaultType;\n\n        if (\n            TYPE != FluidProtocolTypes.VAULT_T1_TYPE &&\n            TYPE != FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE &&\n            TYPE != FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE &&\n            TYPE != FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\n        ) {\n            revert FluidVaultError(ErrorTypes.Vault__ImproperConstantsSetup);\n        }\n\n        LIQUIDITY = IFluidLiquidity(constants_.liquidity);\n        VAULT_FACTORY = IFluidVaultFactory(constants_.factory);\n        DEPLOYER_CONTRACT = constants_.deployer;\n        SUPPLY = ILiquidityDexCommon(constants_.supply);\n        BORROW = ILiquidityDexCommon(constants_.borrow);\n        VAULT_ID = constants_.vaultId;\n\n        OPERATE_IMPLEMENTATION = constants_.operateImplementation == address(0)\n            ? address(this)\n            : constants_.operateImplementation;\n\n        // if smart collateral then adding dex address (even though it's not a token) else adding token address\n        if (\n            TYPE == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE ||\n            TYPE == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\n        ) {\n            SUPPLY_TOKEN = constants_.supply;\n        } else {\n            SUPPLY_TOKEN = constants_.supplyToken.token0;\n            if (constants_.supply != constants_.liquidity) {\n                revert FluidVaultError(ErrorTypes.Vault__ImproperConstantsSetup);\n            }\n        }\n\n        // if smart debt then adding dex address (even though it's not a token) else adding token address\n        if (\n            TYPE == FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE ||\n            TYPE == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\n        ) {\n            BORROW_TOKEN = constants_.borrow;\n        } else {\n            BORROW_TOKEN = constants_.borrowToken.token0;\n            if (constants_.borrow != constants_.liquidity) {\n                revert FluidVaultError(ErrorTypes.Vault__ImproperConstantsSetup);\n            }\n        }\n\n        SUPPLY_TOKEN0 = constants_.supplyToken.token0;\n        BORROW_TOKEN0 = constants_.borrowToken.token0;\n        SUPPLY_TOKEN1 = constants_.supplyToken.token1;\n        BORROW_TOKEN1 = constants_.borrowToken.token1;\n\n        // below slots are calculated in the deploymentLogics / VaultFactory\n        // if supply is directly on liquidity layer then liquidity layer storage slot else if supply is via DEX then bytes32(0)\n        SUPPLY_EXCHANGE_PRICE_SLOT = constants_.supplyExchangePriceSlot;\n        // if borrow is directly on liquidity layer then liquidity layer storage slot else if borrow is via DEX then bytes32(0)\n        BORROW_EXCHANGE_PRICE_SLOT = constants_.borrowExchangePriceSlot;\n        // if supply is directly on liquidity layer then liquidity layer storage slot else if supply is via DEX then dex storage slot\n        USER_SUPPLY_SLOT = constants_.userSupplySlot;\n        // if borrow is directly on liquidity layer then liquidity layer storage slot else if borrow is via DEX then dex storage slot\n        USER_BORROW_SLOT = constants_.userBorrowSlot;\n\n        ADMIN_IMPLEMENTATION = constants_.adminImplementation;\n        SECONDARY_IMPLEMENTATION = constants_.secondaryImplementation;\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/coreModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Events {\n    /// @notice emitted when an operate() method is executed that changes collateral (`colAmt_`) / debt (debtAmt_`)\n    /// amount for a `user_` position with `nftId_`. Receiver of any funds is the address `to_`.\n    event LogOperate(address user_, uint256 nftId_, int256 colAmt_, int256 debtAmt_, address to_);\n\n    /// @notice emitted when the exchange prices are updated in storage.\n    event LogUpdateExchangePrice(uint256 supplyExPrice_, uint256 borrowExPrice_);\n\n    /// @notice emitted when a liquidation has been executed.\n    event LogLiquidate(address liquidator_, uint256 colAmt_, uint256 debtAmt_, address to_);\n\n    /// @notice emitted when `absorb()` was executed to absorb bad debt.\n    event LogAbsorb(uint colAbsorbedRaw_, uint debtAbsorbedRaw_);\n\n    /// @notice emitted when a `rebalance()` has been executed, balancing out total supply / borrow between Vault\n    /// and Fluid Liquidity pools.\n    /// if `colAmt_` is positive then loss, meaning transfer from rebalancer address to vault and deposit.\n    /// if `colAmt_` is negative then profit, meaning withdrawn from vault and sent to rebalancer address.\n    /// if `debtAmt_` is positive then profit, meaning borrow from vault and sent to rebalancer address.\n    /// if `debtAmt_` is negative then loss, meaning transfer from rebalancer address to vault and payback.\n    event LogRebalance(int colAmt_, int debtAmt_);\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/coreModule/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Variables } from \"../common/variables.sol\";\nimport { TokenTransfers } from \"../common/tokenTransfers.sol\";\nimport { ConstantVariables } from \"./constantVariables.sol\";\nimport { Events } from \"./events.sol\";\nimport { TickMath } from \"../../../../libraries/tickMath.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { BigMathVault } from \"../../../../libraries/bigMathVault.sol\";\nimport { LiquidityCalcs } from \"../../../../libraries/liquidityCalcs.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { FluidProtocolTypes } from \"../../../../libraries/fluidProtocolTypes.sol\";\n\n/// @dev Fluid vault protocol helper methods. Mostly used for `operate()` and `liquidate()` methods of CoreModule.\nabstract contract Helpers is Variables, ConstantVariables, Events, TokenTransfers {\n    using BigMathMinified for uint256;\n    using BigMathVault for uint256;\n\n    modifier _dexFromAddress() {\n        if (dexFromAddress != DEAD_ADDRESS) revert FluidVaultError(ErrorTypes.Vault__DexFromAddressAlreadySet);\n        dexFromAddress = msg.sender;\n        _;\n        dexFromAddress = DEAD_ADDRESS;\n    }\n\n    /// @notice Calculates new vault exchange prices. Does not update values in storage.\n    /// @param vaultVariables2_ exactly same as vaultVariables2 from storage\n    /// @return liqSupplyExPrice_ latest liquidity's supply token supply exchange price\n    /// @return liqBorrowExPrice_ latest liquidity's borrow token borrow exchange price\n    /// @return vaultSupplyExPrice_ latest vault's supply token exchange price\n    /// @return vaultBorrowExPrice_ latest vault's borrow token exchange price\n    function updateExchangePrices(\n        uint256 vaultVariables2_\n    )\n        public\n        view\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        )\n    {\n        // Fetching last stored rates\n        uint rates_ = rates;\n\n        // in case of smart collateral oldLiqSupplyExPrice_ will be 0\n        uint256 oldLiqSupplyExPrice_ = (rates_ & X64);\n        // in case of smart debt oldLiqBorrowExPrice_ will be 0\n        uint256 oldLiqBorrowExPrice_ = ((rates_ >> 64) & X64);\n\n        uint timeStampDiff_ = block.timestamp - ((vaultVariables2_ >> 122) & X33);\n\n        if (\n            TYPE == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE ||\n            TYPE == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\n        ) {\n            liqSupplyExPrice_ = EXCHANGE_PRICES_PRECISION;\n            // in case of smart collateral supply magnifier bits stores, supply interest rate positive or negative\n            // negative meaning charging users, positive means incentivizing users\n            vaultSupplyExPrice_ = ((rates_ >> 128) & X64);\n            // if 1 then positive else negative\n            if ((vaultVariables2_ & 1) == 1) {\n                vaultSupplyExPrice_ =\n                    vaultSupplyExPrice_ +\n                    (vaultSupplyExPrice_ * timeStampDiff_ * ((vaultVariables2_ >> 1) & X15)) /\n                    (10000 * LiquidityCalcs.SECONDS_PER_YEAR);\n            } else {\n                vaultSupplyExPrice_ =\n                    vaultSupplyExPrice_ -\n                    (vaultSupplyExPrice_ * timeStampDiff_ * ((vaultVariables2_ >> 1) & X15)) /\n                    (10000 * LiquidityCalcs.SECONDS_PER_YEAR);\n            }\n        } else {\n            (liqSupplyExPrice_, ) = LiquidityCalcs.calcExchangePrices(\n                LIQUIDITY.readFromStorage(SUPPLY_EXCHANGE_PRICE_SLOT)\n            );\n            if (liqSupplyExPrice_ < oldLiqSupplyExPrice_) {\n                // new liquidity exchange price is < than the old one. liquidity exchange price should only ever increase.\n                // If not, something went wrong and avoid proceeding with unknown outcome.\n                revert FluidVaultError(ErrorTypes.Vault__LiquidityExchangePriceUnexpected);\n            }\n\n            // liquidity Exchange Prices always increases in next block. Hence substraction with old will never be negative\n            // uint64 * 1e18 is the max the number that could be\n            unchecked {\n                // Calculating increase in supply exchange price w.r.t last stored liquidity's exchange price\n                // vaultSupplyExPrice_ => supplyIncreaseInPercent_\n                vaultSupplyExPrice_ =\n                    ((((liqSupplyExPrice_ * 1e18) / oldLiqSupplyExPrice_) - 1e18) * (vaultVariables2_ & X16)) /\n                    10000; // supply rate magnifier\n\n                // It's extremely hard the exchange prices to overflow even in 100 years but if it does it's not an\n                // issue here as we are not updating on storage\n                // (rates_ >> 128) & X64) -> last stored vault's supply token exchange price\n                vaultSupplyExPrice_ = (((rates_ >> 128) & X64) * (1e18 + vaultSupplyExPrice_)) / 1e18;                \n            }\n        }\n\n        if (\n            TYPE == FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE ||\n            TYPE == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\n        ) {\n            liqBorrowExPrice_ = EXCHANGE_PRICES_PRECISION;\n            // in case of smart debt borrow magnifier bits stores, borrow interest rate positive or negative\n            // negative meaning incentivizing users, positive means charging users\n            vaultBorrowExPrice_ = ((rates_ >> 192) & X64);\n            // if 1 then positive else negative\n            if (((vaultVariables2_ >> 16) & 1) == 1) {\n                vaultBorrowExPrice_ =\n                    vaultBorrowExPrice_ +\n                    (vaultBorrowExPrice_ * timeStampDiff_ * (((vaultVariables2_ >> 17) & X15))) /\n                    (10000 * LiquidityCalcs.SECONDS_PER_YEAR);\n            } else {\n                vaultBorrowExPrice_ =\n                    vaultBorrowExPrice_ -\n                    (vaultBorrowExPrice_ * timeStampDiff_ * (((vaultVariables2_ >> 17) & X15))) /\n                    (10000 * LiquidityCalcs.SECONDS_PER_YEAR);\n            }\n        } else {\n            (, liqBorrowExPrice_) = LiquidityCalcs.calcExchangePrices(\n                LIQUIDITY.readFromStorage(BORROW_EXCHANGE_PRICE_SLOT)\n            );\n            if (liqBorrowExPrice_ < oldLiqBorrowExPrice_) {\n                // new liquidity exchange price is < than the old one. liquidity exchange price should only ever increase.\n                // If not, something went wrong and avoid proceeding with unknown outcome.\n                revert FluidVaultError(ErrorTypes.Vault__LiquidityExchangePriceUnexpected);\n            }\n            // liquidity Exchange Prices always increases in next block. Hence substraction with old will never be negative\n            // uint64 * 1e18 is the max the number that could be\n            unchecked {\n                // Calculating increase in borrow exchange price w.r.t last stored liquidity's exchange price\n                // vaultBorrowExPrice_ => borrowIncreaseInPercent_\n                vaultBorrowExPrice_ =\n                    ((((liqBorrowExPrice_ * 1e18) / oldLiqBorrowExPrice_) - 1e18) * ((vaultVariables2_ >> 16) & X16)) /\n                    10000; // borrow rate magnifier\n\n                // It's extremely hard the exchange prices to overflow even in 100 years but if it does it's not an\n                // issue here as we are not updating on storage\n                // (rates_ >> 192) -> last stored vault's borrow token exchange price (no need to mask with & X64 as it is anyway max 64 bits)\n                vaultBorrowExPrice_ = ((rates_ >> 192) * (1e18 + vaultBorrowExPrice_)) / 1e18;\n            }\n        }\n    }\n\n    /// @dev fetches new user's position after liquidation. The new liquidated position's debt is decreased by 0.01%\n    /// to make sure that branch's liquidity never becomes 0 as if it would have gotten 0 then there will be multiple cases that we would need to tackle.\n    /// @param positionTick_ position's tick when it was last updated through operate\n    /// @param positionTickId_ position's tick Id. This stores the debt factor and branch to make the first connection\n    /// @param positionRawDebt_ position's raw debt when it was last updated through operate\n    /// @param tickData_ position's tick's tickData just for minor comparison to know if data is moved to tick Id or is still in tick data\n    /// @return final tick position after all the liquidation\n    /// @return final debt of position after all the liquidation\n    /// @return positionRawCol_ final collateral of position after all the liquidation\n    /// @return branchId_ final branch's ID where the position is at currently\n    /// @return branchData_ final branch's data where the position is at currently\n    function fetchLatestPosition(\n        int256 positionTick_,\n        uint256 positionTickId_,\n        uint256 positionRawDebt_,\n        uint256 tickData_\n    )\n        public\n        view\n        returns (\n            int256, // positionTick_\n            uint256, // positionRawDebt_\n            uint256 positionRawCol_,\n            uint256 branchId_,\n            uint256 branchData_\n        )\n    {\n        uint256 initialPositionRawDebt_ = positionRawDebt_;\n        uint256 connectionFactor_;\n        bool isFullyLiquidated_;\n\n        // Checking if tick's total ID = user's tick ID\n        if (((tickData_ >> 1) & X24) == positionTickId_) {\n            // fetching from tick data itself\n            isFullyLiquidated_ = ((tickData_ >> 25) & 1) == 1;\n            branchId_ = (tickData_ >> 26) & X30;\n            connectionFactor_ = (tickData_ >> 56) & X50;\n        } else {\n            {\n                uint256 tickLiquidationData_;\n                unchecked {\n                    // Fetching tick's liquidation data. One variable contains data of 3 IDs. Tick Id mapping is starting from 1.\n                    tickLiquidationData_ =\n                        tickId[positionTick_][(positionTickId_ + 2) / 3] >>\n                        (((positionTickId_ + 2) % 3) * 85);\n                }\n\n                isFullyLiquidated_ = (tickLiquidationData_ & 1) == 1;\n                branchId_ = (tickLiquidationData_ >> 1) & X30;\n                connectionFactor_ = (tickLiquidationData_ >> 31) & X50;\n            }\n        }\n\n        // data of branch\n        branchData_ = branchData[branchId_];\n\n        if (isFullyLiquidated_) {\n            positionTick_ = type(int).min;\n            positionRawDebt_ = 0;\n        } else {\n            // Below information about connection debt factor\n            // If branch is merged, Connection debt factor is used to multiply in order to get perfect liquidation of user\n            // For example: Considering user was at the top.\n            // In first branch, the user liquidated to debt factor 0.5 and then branch got merged (branching starting from 1)\n            // In second branch, it got liquidated to 0.4 but when the above branch merged the debt factor on this branch was 0.6\n            // Meaning on 1st branch, user got liquidated by 50% & on 2nd by 33.33%. So a total of 66.6%.\n            // What we will set a connection factor will be 0.6/0.5 = 1.2\n            // So now to get user's position, this is what we'll do:\n            // finalDebt = (0.4 / (1 * 1.2)) * debtBeforeLiquidation\n            // 0.4 is current active branch's minima debt factor\n            // 1 is debt factor from where user started\n            // 1.2 is connection factor which we found out through 0.6 / 0.5\n            while ((branchData_ & 3) == 2) {\n                // If true then the branch is merged\n\n                // userTickDebtFactor * connectionDebtFactor *... connectionDebtFactor aka adjustmentDebtFactor\n                connectionFactor_ = connectionFactor_.mulBigNumber(((branchData_ >> 116) & X50));\n                if (connectionFactor_ == BigMathVault.MAX_MASK_DEBT_FACTOR) break; // user ~100% liquidated\n                // Note we don't need updated branch data in case of 100% liquidated so saving gas for fetching it\n\n                // Fetching new branch data\n                branchId_ = (branchData_ >> 166) & X30; // Link to base branch of current branch\n                branchData_ = branchData[branchId_];\n            }\n            // When the while loop breaks meaning the branch now has minima Debt Factor or is a closed branch;\n\n            if (((branchData_ & 3) == 3) || (connectionFactor_ == BigMathVault.MAX_MASK_DEBT_FACTOR)) {\n                // Branch got closed (or user liquidated ~100%). Hence make the user's position 0\n                // Rare cases to get into this situation\n                // Branch can get close often but once closed it's tricky that some user might come iterating through there\n                // If a user comes then that user will be very mini user like some cents probably\n                positionTick_ = type(int).min;\n                positionRawDebt_ = 0;\n            } else {\n                // If branch is not merged, the main branch it's connected to then it'll have minima debt factor\n\n                // position debt = debt * base branch minimaDebtFactor / connectionFactor\n                positionRawDebt_ = positionRawDebt_.mulDivNormal(\n                    (branchData_ >> 116) & X50, // minimaDebtFactor\n                    connectionFactor_\n                );\n\n                unchecked {\n                    // Reducing user's liquidity by 0.01% if user got liquidated.\n                    // As this will make sure that the branch always have some debt even if all liquidated user left\n                    // This saves a lot more logics & consideration on Operate function\n                    // if we don't do this then we have to add logics related to closing the branch and factor connections accordingly.\n                    if (positionRawDebt_ > (initialPositionRawDebt_ / 100)) {\n                        positionRawDebt_ = (positionRawDebt_ * 9999) / 10000;\n                    } else {\n                        // if user debt reduced by more than 99% in liquidation then making user as fully liquidated\n                        positionRawDebt_ = 0;\n                    }\n                }\n\n                {\n                    if (positionRawDebt_ > 0) {\n                        // positionTick_ -> read minima tick of branch\n                        unchecked {\n                            positionTick_ = branchData_ & 4 == 4\n                                ? int((branchData_ >> 3) & X19)\n                                : -int((branchData_ >> 3) & X19);\n                        }\n                        // Calculating user's collateral\n                        uint256 ratioAtTick_ = TickMath.getRatioAtTick(int24(positionTick_));\n                        uint256 ratioOneLess_;\n                        unchecked {\n                            ratioOneLess_ = (ratioAtTick_ * 10000) / 10015;\n                        }\n                        // formula below for better readability:\n                        // length = ratioAtTick_ - ratioOneLess_\n                        // ratio = ratioOneLess_ + (length * positionPartials_) / X30\n                        // positionRawCol_ = (positionRawDebt_ * (1 << 96)) / ratio_\n                        positionRawCol_ =\n                            (positionRawDebt_ * TickMath.ZERO_TICK_SCALED_RATIO) /\n                            (ratioOneLess_ + ((ratioAtTick_ - ratioOneLess_) * ((branchData_ >> 22) & X30)) / X30);\n                    } else {\n                        positionTick_ = type(int).min;\n                    }\n                }\n            }\n        }\n        return (positionTick_, positionRawDebt_, positionRawCol_, branchId_, branchData_);\n    }\n\n    constructor(ConstantViews memory constants_) ConstantVariables(constants_) {}\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/coreModule/helpersLiquidate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Helpers } from \"./helpers.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\n\n/// @dev Fluid vault protocol helper methods. Mostly used for `operate()` and `liquidate()` methods of CoreModule.\nabstract contract HelpersLiquidate is Helpers {\n    /// note admin module is also calling this function self call\n    /// @dev updating exchange price on storage. Only need to update on storage when changing supply or borrow magnifier\n    function updateExchangePricesOnStorage()\n        public\n        returns (\n            uint256 liqSupplyExPrice_,\n            uint256 liqBorrowExPrice_,\n            uint256 vaultSupplyExPrice_,\n            uint256 vaultBorrowExPrice_\n        )\n    {\n        (liqSupplyExPrice_, liqBorrowExPrice_, vaultSupplyExPrice_, vaultBorrowExPrice_) = updateExchangePrices(\n            vaultVariables2\n        );\n\n        if (\n            liqSupplyExPrice_ > X64 || liqBorrowExPrice_ > X64 || vaultSupplyExPrice_ > X64 || vaultBorrowExPrice_ > X64\n        ) {\n            revert FluidVaultError(ErrorTypes.Vault__ExchangePriceOverFlow);\n        }\n\n        // Updating in storage\n        rates =\n            liqSupplyExPrice_ |\n            (liqBorrowExPrice_ << 64) |\n            (vaultSupplyExPrice_ << 128) |\n            (vaultBorrowExPrice_ << 192);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffff800000003ffffffffffffffffffffffffffffff) |\n            (block.timestamp << 122);\n\n        emit LogUpdateExchangePrice(vaultSupplyExPrice_, vaultBorrowExPrice_);\n    }\n\n    constructor(ConstantViews memory constants_) Helpers(constants_) {}\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/coreModule/helpersOperate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Helpers } from \"./helpers.sol\";\nimport { TickMath } from \"../../../../libraries/tickMath.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { BigMathVault } from \"../../../../libraries/bigMathVault.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\n\n/// @dev Fluid vault protocol helper methods. Mostly used for `operate()` and `liquidate()` methods of CoreModule.\nabstract contract HelpersOperate is Helpers {\n    using BigMathMinified for uint256;\n    using BigMathVault for uint256;\n\n    /// @dev sets `tick_` as having debt or no debt in storage `tickHasDebt` depending on `addOrRemove_`\n    /// @param tick_ tick to add or remove from tickHasDebt\n    /// @param addOrRemove_ if true then add else remove\n    function _updateTickHasDebt(int tick_, bool addOrRemove_) internal {\n        // Positive mapID_ starts from 0 & above and negative starts below 0.\n        // tick 0 to 255 will have mapId_ as 0 while tick -256 to -1 will have mapId_ as -1.\n        unchecked {\n            int mapId_ = tick_ < 0 ? ((tick_ + 1) / 256) - 1 : tick_ / 256;\n\n            // in case of removing:\n            // (tick == 255) tickHasDebt[mapId_] - 1 << 255\n            // (tick == 0) tickHasDebt[mapId_] - 1 << 0\n            // (tick == -1) tickHasDebt[mapId_] - 1 << 255\n            // (tick == -256) tickHasDebt[mapId_] - 1 << 0\n            // in case of adding:\n            // (tick == 255) tickHasDebt[mapId_] - 1 << 255\n            // (tick == 0) tickHasDebt[mapId_] - 1 << 0\n            // (tick == -1) tickHasDebt[mapId_] - 1 << 255\n            // (tick == -256) tickHasDebt[mapId_] - 1 << 0\n            uint position_ = uint(tick_ - (mapId_ * 256));\n\n            tickHasDebt[mapId_] = addOrRemove_\n                ? tickHasDebt[mapId_] | (1 << position_)\n                : tickHasDebt[mapId_] & ~(1 << position_);\n        }\n    }\n\n    /// @dev gets next perfect top tick (tick which is not liquidated)\n    /// @param topTick_ current top tick which will no longer be top tick\n    /// @return nextTick_ next top tick which will become the new top tick\n    function _fetchNextTopTick(int topTick_) internal view returns (int nextTick_) {\n        int mapId_;\n        uint tickHasDebt_;\n\n        unchecked {\n            mapId_ = topTick_ < 0 ? ((topTick_ + 1) / 256) - 1 : topTick_ / 256;\n            uint bitsToRemove_ = uint(-topTick_ + (mapId_ * 256 + 256));\n            // Removing current top tick from tickHasDebt\n            tickHasDebt_ = (tickHasDebt[mapId_] << bitsToRemove_) >> bitsToRemove_;\n\n            // For last user remaining in vault there could be a lot of iterations in the while loop.\n            // Chances of this to happen is extremely low (like ~0%)\n            while (true) {\n                if (tickHasDebt_ > 0) {\n                    nextTick_ = mapId_ * 256 + int(tickHasDebt_.mostSignificantBit()) - 1;\n                    break;\n                }\n\n                // Reducing mapId_ by 1 in every loop; if it reaches to -129 then no filled tick exist, meaning it's the last tick\n                if (--mapId_ == -129) {\n                    nextTick_ = type(int).min;\n                    break;\n                }\n\n                tickHasDebt_ = tickHasDebt[mapId_];\n            }\n        }\n    }\n\n    /// @dev adding debt to a particular tick\n    /// @param totalColRaw_ total raw collateral of position\n    /// @param netDebtRaw_ net raw debt (total debt - dust debt)\n    /// @return tick_ tick where the debt is being added\n    /// @return tickId_ tick current id\n    /// @return userRawDebt_ user's total raw debt\n    /// @return rawDust_ dust debt used for adjustment\n    function _addDebtToTickWrite(\n        uint256 totalColRaw_,\n        uint256 netDebtRaw_ // debtRaw - dust\n    ) internal returns (int256 tick_, uint256 tickId_, uint256 userRawDebt_, uint256 rawDust_) {\n        if (netDebtRaw_ < 10000) {\n            // thrown if user's debt is too low\n            revert FluidVaultError(ErrorTypes.Vault__UserDebtTooLow);\n        }\n        // tick_ & ratio_ returned from library is round down. Hence increasing it by 1 and increasing ratio by 1 tick.\n        uint ratio_ = (netDebtRaw_ * TickMath.ZERO_TICK_SCALED_RATIO) / totalColRaw_;\n        (tick_, ratio_) = TickMath.getTickAtRatio(ratio_);\n        unchecked {\n            ++tick_;\n            ratio_ = (ratio_ * 10015) / 10000;\n        }\n        userRawDebt_ = (ratio_ * totalColRaw_) >> 96;\n        rawDust_ = userRawDebt_ - netDebtRaw_;\n\n        // Current state of tick\n        uint256 tickData_ = tickData[tick_];\n        tickId_ = (tickData_ >> 1) & X24;\n\n        uint tickNewDebt_;\n        if (tickId_ > 0 && tickData_ & 1 == 0) {\n            // Current debt in the tick\n            uint256 tickExistingRawDebt_ = (tickData_ >> 25) & X64;\n            tickExistingRawDebt_ = (tickExistingRawDebt_ >> 8) << (tickExistingRawDebt_ & X8);\n\n            // Tick's already initialized and not liquidated. Hence simply add the debt\n            tickNewDebt_ = tickExistingRawDebt_ + userRawDebt_;\n            if (tickExistingRawDebt_ == 0) {\n                // Adding tick into tickHasDebt\n                _updateTickHasDebt(tick_, true);\n            }\n        } else {\n            // Liquidation happened or tick getting initialized for the very first time.\n            if (tickId_ > 0) {\n                // Meaning a liquidation happened. Hence move the data to tickID\n                unchecked {\n                    uint tickMap_ = (tickId_ + 2) / 3;\n                    // Adding 2 in ID so we can get right mapping ID. For example for ID 1, 2 & 3 mapping should be 1 and so on..\n                    // For example shift for id 1 should be 0, for id 2 should be 85, for id 3 it should be 170 and so on..\n                    tickId[tick_][tickMap_] =\n                        tickId[tick_][tickMap_] |\n                        ((tickData_ >> 25) << (((tickId_ + 2) % 3) * 85));\n                }\n            }\n            // Increasing total ID by one\n            unchecked {\n                ++tickId_;\n            }\n            tickNewDebt_ = userRawDebt_;\n\n            // Adding tick into tickHasDebt\n            _updateTickHasDebt(tick_, true);\n        }\n        if (tickNewDebt_ < 10000) {\n            // thrown if tick's debt/liquidity is too low\n            revert FluidVaultError(ErrorTypes.Vault__TickDebtTooLow);\n        }\n        tickData[tick_] = (tickId_ << 1) | (tickNewDebt_.toBigNumber(56, 8, BigMathMinified.ROUND_DOWN) << 25);\n    }\n\n    /// @dev sets new top tick. If it comes to this function then that means current top tick is perfect tick.\n    /// if next top tick is liquidated then unitializes the current non liquidated branch and make the liquidated branch as current branch\n    /// @param topTick_ current top tick\n    /// @param vaultVariables_ vaultVariables of storage but with newer updates\n    /// @return newVaultVariables_ newVaultVariables_ updated vault variable internally to this function\n    /// @return newTopTick_ new top tick\n    function _setNewTopTick(\n        int topTick_,\n        uint vaultVariables_\n    ) internal returns (uint newVaultVariables_, int newTopTick_) {\n        // This function considers that the current top tick was not liquidated\n        // Overall flow of function:\n        // if new top tick liquidated (aka base branch's minima tick) -> Close the current branch and make base branch as current branch\n        // if new top tick not liquidated -> update things in current branch.\n        // if new top tick is not liquidated and same tick exist in base branch then tick is considered as not liquidated.\n\n        uint branchId_ = (vaultVariables_ >> 22) & X30; // branch id of current branch\n\n        uint256 branchData_ = branchData[branchId_];\n        int256 baseBranchMinimaTick_;\n        if ((branchData_ >> 196) & 1 == 1) {\n            baseBranchMinimaTick_ = int((branchData_ >> 197) & X19);\n        } else {\n            unchecked {\n                baseBranchMinimaTick_ = -int((branchData_ >> 197) & X19);\n            }\n            if (baseBranchMinimaTick_ == 0) {\n                // meaning the current branch is the master branch\n                baseBranchMinimaTick_ = type(int).min;\n            }\n        }\n\n        // Returns type(int).min if no top tick exist\n        int nextTopTickNotLiquidated_ = _fetchNextTopTick(topTick_);\n\n        newTopTick_ = baseBranchMinimaTick_ > nextTopTickNotLiquidated_\n            ? baseBranchMinimaTick_\n            : nextTopTickNotLiquidated_;\n\n        if (newTopTick_ == type(int).min) {\n            // if this happens that means this was the last user of the vault :(\n            vaultVariables_ = vaultVariables_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00001;\n        } else if (newTopTick_ == nextTopTickNotLiquidated_) {\n            // New top tick exist in current non liquidated branch\n            if (newTopTick_ < 0) {\n                unchecked {\n                    vaultVariables_ =\n                        (vaultVariables_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00001) |\n                        (uint(-newTopTick_) << 3);\n                }\n            } else {\n                vaultVariables_ =\n                    (vaultVariables_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00001) |\n                    4 | // setting top tick as positive\n                    (uint(newTopTick_) << 3);\n            }\n        } else {\n            // if this happens that means base branch exists & is the next top tick\n            // Remove current non liquidated branch as active.\n            // Not deleting here as it's going to get initialize again whenever a new top tick comes\n            branchData[branchId_] = 0;\n            // Inserting liquidated branch's minima tick\n            unchecked {\n                vaultVariables_ =\n                    (vaultVariables_ & 0xfffffffffffffffffffffffffffffffffffffffffffc00000000000000000001) |\n                    2 | // Setting top tick as liquidated\n                    (((branchData_ >> 196) & X20) << 2) | // new current top tick = base branch minima tick\n                    (((branchData_ >> 166) & X30) << 22) | // new current branch id = base branch id\n                    ((branchId_ - 1) << 52); // reduce total branch id by 1\n            }\n        }\n\n        newVaultVariables_ = vaultVariables_;\n    }\n\n    constructor(ConstantViews memory constants_) Helpers(constants_) {}\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/coreModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"../../../../oracle/fluidOracle.sol\";\nimport { TickMath } from \"../../../../libraries/tickMath.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { BigMathVault } from \"../../../../libraries/bigMathVault.sol\";\nimport { SafeTransfer } from \"../../../../libraries/safeTransfer.sol\";\nimport { HelpersLiquidate } from \"./helpersLiquidate.sol\";\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\nimport { FluidProtocolTypes } from \"../../../../libraries/fluidProtocolTypes.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { AddressCalcs } from \"../../../../libraries/addressCalcs.sol\";\n\n/// @notice Fluid vault protocol main contract base.\n///         Fluid Vault protocol is a borrow / lending protocol, allowing users to create collateral / borrow positions.\n///         All funds are deposited into / borrowed from Fluid Liquidity layer.\n///         Positions are represented through NFTs minted by the VaultFactory.\n///         Deployed by \"VaultFactory\" and linked together with Vault AdminModule `ADMIN_IMPLEMENTATION` and\n///         FluidVaultSecondary (main2.sol) `SECONDARY_IMPLEMENTATION`.\n///         AdminModule & FluidVaultSecondary methods are delegateCalled, if the msg.sender has the required authorization.\n///         This contract links to an Oracle, which is used to assess collateral / debt value. Oracles implement the\n///         \"FluidOracle\" base contract and return the price in 1e27 precision.\n/// @dev    For view methods / accessing data, use the \"VaultResolver\" periphery contract.\n//\n// vaults can only be deployed for tokens that are listed at Liquidity (constructor reverts otherwise\n// if either the exchange price for the supply token or the borrow token is still not set at Liquidity).\nabstract contract FluidVault is HelpersLiquidate {\n    using BigMathMinified for uint256;\n    using BigMathVault for uint256;\n\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external {\n        uint vaultVariables_ = vaultVariables;\n        // ############# turning re-entrancy bit on #############\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        debtAmt_ = debtAmt_ == 0 ? X128 : debtAmt_;\n\n        _liquidate(X128, 0, DEAD_ADDRESS, absorb_, vaultVariables_);\n\n        // this revert will never reach as the revert is inside the liquidate function due to to_ = DEAD_ADDRESS\n        // but still added just to be extra safe\n        revert();\n    }\n\n    /// @dev allows to liquidate all bad debt of all users at once. Liquidator can also liquidate partially any amount they want.\n    /// @param debtAmt_ total debt to liquidate (aka debt token to swap into collateral token)\n    /// @param colPerUnitDebt_ minimum collateral token per unit of debt in 1e18 decimals\n    /// @param to_ address at which collateral token should go to.\n    ///            If dead address (DEAD_ADDRESS) then reverts with custom error \"FluidLiquidateResult\"\n    ///            returning the actual collateral and actual debt liquidated. Useful to find max liquidatable amounts via try / catch.\n    /// @param absorb_ if true then liquidate from absorbed first\n    /// @param vaultVariables_ the current state of the vaultVariables from storage\n    /// @return bytes with 3 uints, r_[0] = actualDebtAmt, r_[1] = actualColAmt, r_[2] = vaultVariables_\n    ///         actualDebtAmt if liquidator sends debtAmt_ more than debt remaining to liquidate then actualDebtAmt changes from debtAmt_ else remains same\n    ///         actualColAmt total liquidated collateral which liquidator will get\n    function _liquidate(\n        uint256 debtAmt_,\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\n        address to_,\n        bool absorb_,\n        uint vaultVariables_\n    ) internal returns (bytes memory) {\n        LiquidateMemoryVars memory memoryVars_;\n\n        memoryVars_.vaultVariables2 = vaultVariables2;\n\n        if (((vaultVariables_ >> 2) & X20) == 0) {\n            revert FluidVaultError(ErrorTypes.Vault__TopTickDoesNotExist);\n        }\n\n        // Below are exchange prices of vaults\n        (, , memoryVars_.supplyExPrice, memoryVars_.borrowExPrice) = updateExchangePrices(memoryVars_.vaultVariables2);\n\n        CurrentLiquidity memory currentData_;\n        BranchData memory branch_;\n        // Temporary holder variables, used many times for different small things\n        uint temp_;\n        uint temp2_;\n\n        {\n            // ############# Oracle related stuff #############\n            // Col price w.r.t debt. For example: 1 ETH = 1000 DAI\n            // temp_ -> debtPerCol\n            temp_ = IFluidOracle(\n                AddressCalcs.addressCalc(DEPLOYER_CONTRACT, ((memoryVars_.vaultVariables2 >> 92) & X30))\n            ).getExchangeRateLiquidate(); // Price in 27 decimals\n\n            // not reverting if oracle price is lower than 1e9 as it can pause potential liquidation in this edge case situations\n            if (temp_ > 1e54 || temp_ == 0) {\n                revert FluidVaultError(ErrorTypes.Vault__InvalidOraclePrice);\n            }\n\n            unchecked {\n                // temp_ -> debtPerCol Converting in terms of raw amount\n                temp_ = (temp_ * memoryVars_.supplyExPrice) / memoryVars_.borrowExPrice;\n\n                // capping oracle pricing to 1e45\n                // Reason mentioned at (search: #487RGF783GF)\n                if (temp_ > 1e45) {\n                    temp_ = 1e45;\n                }\n                // temp2_ -> Raw colPerDebt_ in 27 decimals\n                temp2_ = 1e54 / temp_;\n\n                // temp2_ can never be > 1e54\n                // Oracle price should never be > 1e54\n                // Liquidation penalty in 4 decimals (1e2 = 1%) (max: 10.23%) -> (vaultVariables2_ >> 72) & X10\n                currentData_.colPerDebt = (temp2_ * (10000 + ((memoryVars_.vaultVariables2 >> 72) & X10))) / 10000;\n\n                // get liquidiation tick (tick at liquidation threshold ratio)\n                // Liquidation threshold in 3 decimals (900 = 90%) -> (vaultVariables2_ >> 42) & X10\n                // Dividing by 1e27 to convert temp_ into normal number\n                temp_ = ((temp_ * TickMath.ZERO_TICK_SCALED_RATIO) / 1e27);\n                // temp2_ -> liquidationRatio_\n                temp2_ = (temp_ * ((memoryVars_.vaultVariables2 >> 42) & X10)) / 1000;\n            }\n            (memoryVars_.liquidationTick, ) = TickMath.getTickAtRatio(temp2_);\n\n            // get liquidiation max limit tick (tick at liquidation max limit ratio)\n            // Max limit in 3 decimals (900 = 90%) -> (vaultVariables2_ >> 52) & X10\n            // temp2_ -> maxRatio_\n            unchecked {\n                temp2_ = (temp_ * ((memoryVars_.vaultVariables2 >> 52) & X10)) / 1000;\n            }\n            (memoryVars_.maxTick, ) = TickMath.getTickAtRatio(temp2_);\n        }\n\n        // extracting top tick as top tick will be the current tick\n        unchecked {\n            currentData_.tick = (vaultVariables_ & 4) == 4\n                ? int256((vaultVariables_ >> 3) & X19)\n                : -int256((vaultVariables_ >> 3) & X19);\n        }\n\n        if (currentData_.tick > memoryVars_.maxTick) {\n            // absorbing all the debt above maxTick if available\n            vaultVariables_ = (\n                abi.decode(\n                    _spell(\n                        SECONDARY_IMPLEMENTATION,\n                        abi.encodeWithSignature(\"absorb(uint256,int256)\", vaultVariables_, memoryVars_.maxTick)\n                    ),\n                    (uint256)\n                )\n            );\n\n            // updating current tick to new topTick after absorb\n            unchecked {\n                currentData_.tick = (vaultVariables_ & 4) == 4\n                    ? int256((vaultVariables_ >> 3) & X19)\n                    : -int256((vaultVariables_ >> 3) & X19);\n            }\n            if (debtAmt_ == 0) {\n                // updating vault variables on storage as the transaction was for only absorb\n                // Vault variables is getting updated through liquidate function\n                return abi.encode(0, 0, vaultVariables_);\n            }\n        }\n\n        if (debtAmt_ < 10000 || debtAmt_ > X128) {\n            revert FluidVaultError(ErrorTypes.Vault__InvalidLiquidationAmt);\n        }\n\n        // setting up status if top tick is liquidated or not\n        currentData_.tickStatus = vaultVariables_ & 2 == 0 ? 1 : 2;\n        // Tick info is mainly used as a place holder to store temporary tick related data\n        // (it can be current or ref using same memory variable)\n        TickData memory tickInfo_;\n        tickInfo_.tick = currentData_.tick;\n\n        {\n            // ############# Setting current branch in memory #############\n\n            // Updating branch related data\n            branch_.id = (vaultVariables_ >> 22) & X30;\n            branch_.data = branchData[branch_.id];\n            branch_.debtFactor = (branch_.data >> 116) & X50;\n            if (branch_.debtFactor == 0) {\n                // Initializing branch debt factor. 35 | 15 bit number. Where full 35 bits and 15th bit is occupied.\n                // Making the total number as (2**35 - 1) << 2**14.\n                // note: initial debt factor can be any number.\n                branch_.debtFactor = ((X35 << 15) | (1 << 14));\n            }\n            // fetching base branch's minima tick. if 0 that means it's a master branch\n            temp_ = (branch_.data >> 196) & X20;\n            if (temp_ > 0) {\n                unchecked {\n                    branch_.minimaTick = (temp_ & 1) == 1 ? int256((temp_ >> 1) & X19) : -int256((temp_ >> 1) & X19);\n                }\n            } else {\n                branch_.minimaTick = type(int).min;\n            }\n        }\n\n        // debtAmt_ should be less than 2**128 & EXCHANGE_PRICES_PRECISION is 1e12\n        unchecked {\n            currentData_.debtRemaining = (debtAmt_ * EXCHANGE_PRICES_PRECISION) / memoryVars_.borrowExPrice;\n        }\n\n        // extracting total debt\n        temp2_ = (vaultVariables_ >> 146) & X64;\n        temp2_ = ((temp2_ >> 8) << (temp2_ & X8));\n\n        if ((temp2_ / 1e9) > currentData_.debtRemaining) {\n            // if liquidation amount is less than 1e9 of total debt then revert\n            // so if total debt is $1B then minimum liquidation limit = $1\n            // so if total debt is $1T then minimum liquidation limit = $1000\n            // partials precision is slightlty above 1e9 so this will make sure that on every liquidation atleast 1 partial gets liquidated\n            // not sure if it can result in any issue but restricting amount further more to remove very low amount scenarios totally\n            revert FluidVaultError(ErrorTypes.Vault__InvalidLiquidationAmt);\n        }\n\n        if (absorb_) {\n            temp_ = absorbedLiquidity;\n            // temp2_ -> absorbed col\n            temp2_ = (temp_ >> 128) & X128;\n            // temp_ -> absorbed debt\n            temp_ = temp_ & X128;\n\n            if (temp_ > currentData_.debtRemaining) {\n                // Removing collateral in equal proportion as debt\n                currentData_.totalColLiq = ((temp2_ * currentData_.debtRemaining) / temp_);\n                temp2_ -= currentData_.totalColLiq;\n                // Removing debt\n                currentData_.totalDebtLiq = currentData_.debtRemaining;\n                unchecked {\n                    temp_ -= currentData_.debtRemaining;\n                }\n                currentData_.debtRemaining = 0;\n\n                // updating on storage\n                absorbedLiquidity = temp_ | (temp2_ << 128);\n            } else {\n                // updating on storage\n                absorbedLiquidity = 0;\n                unchecked {\n                    currentData_.debtRemaining -= temp_;\n                }\n                currentData_.totalDebtLiq = temp_;\n                currentData_.totalColLiq = temp2_;\n            }\n        }\n\n        // current tick should be greater than liquidationTick and it cannot be greater than maxTick as absorb will run\n        if (currentData_.tick > memoryVars_.liquidationTick) {\n            if (currentData_.debtRemaining > 0) {\n                // Stores liquidated debt & collateral in each loop\n                uint debtLiquidated_;\n                uint colLiquidated_;\n                uint debtFactor_ = BigMathVault.TWO_POWER_64;\n\n                TickHasDebt memory tickHasDebt_;\n                unchecked {\n                    tickHasDebt_.mapId = (currentData_.tick < 0)\n                        ? (((currentData_.tick + 1) / 256) - 1)\n                        : (currentData_.tick / 256);\n                }\n\n                tickInfo_.ratio = TickMath.getRatioAtTick(tickInfo_.tick);\n\n                if (currentData_.tickStatus == 1) {\n                    // top tick is not liquidated. Hence it's a perfect tick.\n                    currentData_.ratio = tickInfo_.ratio;\n                    // if current tick in liquidation is a perfect tick then it is also the next tick that has debt.\n                    tickHasDebt_.nextTick = currentData_.tick;\n                } else {\n                    // top tick is liquidated. Hence it has partials.\n                    // next tick that has debt liquidity will have to be fetched from tickHasDebt\n                    unchecked {\n                        tickInfo_.ratioOneLess = (tickInfo_.ratio * 10000) / 10015;\n                        tickInfo_.length = tickInfo_.ratio - tickInfo_.ratioOneLess;\n                        tickInfo_.partials = (branch_.data >> 22) & X30;\n                        currentData_.ratio = tickInfo_.ratioOneLess + ((tickInfo_.length * tickInfo_.partials) / X30);\n\n                        if ((memoryVars_.liquidationTick + 1) == tickInfo_.tick && (tickInfo_.partials == 1)) {\n                            if (to_ == DEAD_ADDRESS) {\n                                // revert with liquidated amounts if to_ address is the dead address.\n                                // this can be used in a resolver to find the max liquidatable amounts.\n                                revert FluidLiquidateResult(0, 0);\n                            }\n                            revert FluidVaultError(ErrorTypes.Vault__InvalidLiquidation);\n                        }\n                    }\n                }\n\n                while (true) {\n                    if (currentData_.tickStatus == 1) {\n                        // not liquidated -> Getting the debt from tick data itself\n                        temp2_ = tickData[currentData_.tick];\n                        // temp_ => tick debt\n                        temp_ = (temp2_ >> 25) & X64;\n                        // Converting big number into normal number\n                        temp_ = (temp_ >> 8) << (temp_ & X8);\n                        // Updating tickData on storage with removing debt & adding connection to branch\n                        tickData[currentData_.tick] =\n                            1 | // set tick as liquidated\n                            (temp2_ & 0x1fffffe) | // set same total tick ids\n                            (branch_.id << 26) | // branch id where this tick got liquidated\n                            (branch_.debtFactor << 56);\n                    } else {\n                        // already liquidated -> Get the debt from branch data in big number\n                        // temp_ => tick debt\n                        temp_ = (branch_.data >> 52) & X64;\n                        // Converting big number into normal number\n                        temp_ = (temp_ >> 8) << (temp_ & X8);\n                        // Branch is getting updated over the end\n                    }\n\n                    // Adding new debt into active debt for liquidation\n                    currentData_.debt += temp_;\n\n                    // Adding new col into active col for liquidation\n                    // Ratio is in 2**96 decimals hence multiplying debt with 2**96 to get proper collateral\n                    currentData_.col += (temp_ * TickMath.ZERO_TICK_SCALED_RATIO) / currentData_.ratio;\n\n                    if (\n                        (tickHasDebt_.nextTick == currentData_.tick && currentData_.tickStatus == 1) ||\n                        tickHasDebt_.tickHasDebt == 0\n                    ) {\n                        // Fetching next perfect tick with liquidity\n                        // tickHasDebt_.tickHasDebt == 0 will only happen in the first while loop\n                        // in the very first perfect tick liquidation it'll be 0\n                        if (tickHasDebt_.tickHasDebt == 0) {\n                            tickHasDebt_.tickHasDebt = tickHasDebt[tickHasDebt_.mapId];\n                        }\n\n                        // in 1st loop tickStatus can be 2. Meaning not a perfect current tick\n                        if (currentData_.tickStatus == 1) {\n                            unchecked {\n                                tickHasDebt_.bitsToRemove = uint(-currentData_.tick + (tickHasDebt_.mapId * 256 + 256));\n                            }\n                            // Removing current top tick from tickHasDebt\n                            tickHasDebt_.tickHasDebt =\n                                (tickHasDebt_.tickHasDebt << tickHasDebt_.bitsToRemove) >>\n                                tickHasDebt_.bitsToRemove;\n                            // Updating in storage if tickHasDebt becomes 0.\n                            if (tickHasDebt_.tickHasDebt == 0) {\n                                tickHasDebt[tickHasDebt_.mapId] = 0;\n                            }\n                        }\n\n                        // For last user remaining in vault there could be a lot of while loop.\n                        // Chances of this to happen is extremely low (like ~0%)\n                        while (true) {\n                            if (tickHasDebt_.tickHasDebt > 0) {\n                                unchecked {\n                                    tickHasDebt_.nextTick =\n                                        tickHasDebt_.mapId *\n                                        256 +\n                                        int(tickHasDebt_.tickHasDebt.mostSignificantBit()) -\n                                        1;\n                                }\n                                break;\n                            }\n\n                            // tickHasDebt_.tickHasDebt == 0. Checking if minimum tick of this mapID is less than liquidationTick_\n                            // if true that means now the next tick is not needed as liquidation gets over minimum at liquidationTick_\n                            unchecked {\n                                if ((tickHasDebt_.mapId * 256) < memoryVars_.liquidationTick) {\n                                    tickHasDebt_.nextTick = type(int).min;\n                                    break;\n                                }\n\n                                // Fetching next tick has debt by decreasing tickHasDebt_.mapId first\n                                tickHasDebt_.tickHasDebt = tickHasDebt[--tickHasDebt_.mapId];\n                            }\n                        }\n                    }\n\n                    // Fetching refTick. refTick is the biggest tick of these 3:\n                    // 1. Next tick with liquidity (from tickHasDebt)\n                    // 2. Minima tick of current branch\n                    // 3. Liquidation threshold tick\n                    {\n                        // Setting currentData_.refTick & currentData_.refTickStatus\n                        if (\n                            branch_.minimaTick > tickHasDebt_.nextTick &&\n                            branch_.minimaTick > memoryVars_.liquidationTick\n                        ) {\n                            // next tick will be of base branch (merge)\n                            currentData_.refTick = branch_.minimaTick;\n                            currentData_.refTickStatus = 2;\n                        } else if (tickHasDebt_.nextTick > memoryVars_.liquidationTick) {\n                            // next tick will be next tick from perfect tick\n                            currentData_.refTick = tickHasDebt_.nextTick;\n                            currentData_.refTickStatus = 1;\n                        } else {\n                            // next tick is threshold tick\n                            currentData_.refTick = memoryVars_.liquidationTick;\n                            currentData_.refTickStatus = 3; // leads to end of liquidation loop\n                        }\n                    }\n\n                    // using tickInfo variable again for ref tick as we don't have the need for it any more\n                    tickInfo_.ratio = TickMath.getRatioAtTick(int24(currentData_.refTick));\n                    if (currentData_.refTickStatus == 2) {\n                        // merge current branch with base branch\n                        unchecked {\n                            tickInfo_.ratioOneLess = (tickInfo_.ratio * 10000) / 10015;\n                            tickInfo_.length = tickInfo_.ratio - tickInfo_.ratioOneLess;\n                            // Fetching base branch data to get the base branch's partial\n                            branch_.baseBranchData = branchData[((branch_.data >> 166) & X30)];\n                            tickInfo_.partials = (branch_.baseBranchData >> 22) & X30;\n                            tickInfo_.currentRatio =\n                                tickInfo_.ratioOneLess +\n                                ((tickInfo_.length * tickInfo_.partials) / X30);\n                            currentData_.refRatio = tickInfo_.currentRatio;\n                        }\n                    } else {\n                        // refTickStatus can only be 1 (next tick from perfect tick) or 3 (liquidation threshold tick)\n                        tickInfo_.currentRatio = tickInfo_.ratio;\n                        currentData_.refRatio = tickInfo_.ratio;\n                        tickInfo_.partials = X30;\n                    }\n\n                    // Formula: (debt_ - x) / (col_ - (x * colPerDebt_)) = ratioEnd_\n                    // x = ((ratioEnd_ * col) - debt_) / ((colPerDebt_ * ratioEnd_) - 1)\n                    // x is debtToLiquidate_\n                    // col_ = debt_ / ratioStart_ -> (currentData_.debt / currentData_.ratio)\n                    // ratioEnd_ is currentData_.refRatio\n                    //\n                    // Calculation results of numerator & denominator is always negative\n                    // which will cancel out to give positive output in the end so we can safely cast to uint.\n                    // for nominator:\n                    // ratioStart can only be >= ratioEnd so first part can only be reducing currentData_.debt leading to\n                    // currentData_.debt reduced - currentData_.debt original * 1e27 -> can only be a negative number\n                    // for denominator:\n                    // currentData_.colPerDebt and currentData_.refRatio are inversely proportional to each other.\n                    // the maximum value they can ever be is ~9.97e26 which is the 0.3% away from 100% because liquidation\n                    // threshold + liquidation penalty can never be > 99.7%. This can also be verified by going back from\n                    // min / max ratio values further up where we fetch oracle price etc.\n                    // as optimization we can inverse nominator and denominator subtraction to directly get a positive number.\n\n                    debtLiquidated_ =\n                        // nominator\n                        ((currentData_.debt - (currentData_.refRatio * currentData_.debt) / currentData_.ratio) *\n                            1e27) /\n                        // denominator\n                        (1e27 - ((currentData_.colPerDebt * currentData_.refRatio) / TickMath.ZERO_TICK_SCALED_RATIO));\n\n                    colLiquidated_ = (debtLiquidated_ * currentData_.colPerDebt) / 1e27;\n\n                    if (currentData_.debt == debtLiquidated_) {\n                        debtLiquidated_ -= 1;\n                    }\n\n                    if (debtLiquidated_ >= currentData_.debtRemaining || currentData_.refTickStatus == 3) {\n                        // End of liquidation as full amount to liquidate or liquidation threshold tick has been reached;\n\n                        // Updating tickHasDebt on storage.\n                        tickHasDebt[tickHasDebt_.mapId] = tickHasDebt_.tickHasDebt;\n\n                        if (debtLiquidated_ >= currentData_.debtRemaining) {\n                            // Liquidation ended between currentTick & refTick.\n                            // Not all of liquidatable debt is actually liquidated -> recalculate\n                            debtLiquidated_ = currentData_.debtRemaining;\n                            colLiquidated_ = (debtLiquidated_ * currentData_.colPerDebt) / 1e27;\n                            // Liquidating to debt. temp_ => final ratio after liquidation\n                            // liquidatable debt - debtLiquidated / liquidatable col - colLiquidated\n                            temp_ =\n                                ((currentData_.debt - debtLiquidated_) * TickMath.ZERO_TICK_SCALED_RATIO) /\n                                (currentData_.col - colLiquidated_);\n                            // Fetching tick of where liquidation ended\n                            (tickInfo_.tick, tickInfo_.ratioOneLess) = TickMath.getTickAtRatio(temp_);\n                            if ((tickInfo_.tick < currentData_.refTick) && (tickInfo_.partials == X30)) {\n                                // this situation might never happen\n                                // if this happens then there might be some very edge case precision of few weis which is returning 1 tick less\n                                // if the above were to ever happen then tickInfo_.tick only be currentData_.refTick - 1\n                                // in this case the partial will be very very near to full (X30)\n                                // increasing tick by 2 and making partial as 1 which is basically very very near to currentData_.refTick\n                                unchecked {\n                                    tickInfo_.tick += 2;\n                                }\n                                tickInfo_.partials = 1;\n                            } else {\n                                unchecked {\n                                    // Increasing tick by 1 as final ratio will probably be a partial\n                                    ++tickInfo_.tick;\n\n                                    // if ref tick is old liquidated tick then storing partials in temp2_\n                                    // tickInfo_.partials contains partial of branch which is the current ref tick\n                                    temp2_ = (currentData_.refTickStatus == 2 && tickInfo_.tick == currentData_.refTick)\n                                        ? tickInfo_.partials\n                                        : 0;\n\n                                    tickInfo_.ratio = (tickInfo_.ratioOneLess * 10015) / 10000;\n                                    tickInfo_.length = tickInfo_.ratio - tickInfo_.ratioOneLess;\n                                    tickInfo_.partials = ((temp_ - tickInfo_.ratioOneLess) * X30) / tickInfo_.length;\n\n                                    // Taking edge cases where partial comes as 0 or X30 meaning perfect tick.\n                                    // Hence, increasing or reducing it by 1 as liquidation tick cannot be perfect tick.\n                                    tickInfo_.partials = tickInfo_.partials == 0\n                                        ? 1\n                                        : tickInfo_.partials >= X30\n                                            ? X30 - 1\n                                            : tickInfo_.partials;\n                                }\n                                if (temp2_ > 0 && temp2_ >= tickInfo_.partials) {\n                                    // if refTick is liquidated tick and hence contains partials then checking that\n                                    // current liquidation tick's partial should not be less than last liquidation refTick\n\n                                    // not sure if this is even possible to happen but adding checks to avoid it fully\n                                    // if it reverts here then next liquidation on next block should go through fine\n                                    revert FluidVaultError(ErrorTypes.Vault__LiquidationReverts);\n                                }\n                            }\n                        } else {\n                            // End in liquidation threshold.\n                            // finalRatio_ = currentData_.refRatio;\n                            // Increasing liquidation threshold tick by 1 partial. With 1 partial it'll reach to the next tick.\n                            // Ratio change will be negligible. Doing this as liquidation threshold tick can also be a perfect non-liquidated tick.\n                            unchecked {\n                                tickInfo_.tick = currentData_.refTick + 1;\n                            }\n                            // Making partial as 1 so it doesn't stay perfect tick\n                            tickInfo_.partials = 1;\n                            // length is not needed as only partials are written to storage\n                        }\n\n                        // debtFactor = debtFactor * (liquidatableDebt - debtLiquidated) / liquidatableDebt\n                        // -> debtFactor * leftOverDebt / liquidatableDebt\n                        debtFactor_ = (debtFactor_ * (currentData_.debt - debtLiquidated_)) / currentData_.debt;\n                        currentData_.totalDebtLiq += debtLiquidated_;\n                        currentData_.debt -= debtLiquidated_; // currentData_.debt => leftOverDebt after debtLiquidated_\n                        currentData_.totalColLiq += colLiquidated_;\n                        currentData_.col -= colLiquidated_; // currentData_.col => leftOverCol after colLiquidated_\n\n                        // Updating branch's debt factor & write to storage as liquidation is over\n                        branch_.debtFactor = branch_.debtFactor.mulDivBigNumber(debtFactor_);\n\n                        if (currentData_.debt < 100) {\n                            // this can happen when someone tries to create a dust tick\n                            revert FluidVaultError(ErrorTypes.Vault__BranchDebtTooLow);\n                        }\n\n                        unchecked {\n                            // Tick to insert\n                            temp2_ = tickInfo_.tick < 0\n                                ? (uint(-tickInfo_.tick) << 1)\n                                : ((uint(tickInfo_.tick) << 1) | 1);\n                        }\n\n                        // Updating Branch data with debt factor, debt, partials, minima tick & assigning is liquidated\n                        branchData[branch_.id] =\n                            ((branch_.data >> 166) << 166) |\n                            1 | // set as liquidated\n                            (temp2_ << 2) | // minima tick of branch\n                            (tickInfo_.partials << 22) |\n                            (currentData_.debt.toBigNumber(56, 8, BigMathMinified.ROUND_UP) << 52) | // branch debt\n                            (branch_.debtFactor << 116);\n\n                        // Updating vault variables with current branch & tick\n                        vaultVariables_ =\n                            ((vaultVariables_ >> 52) << 52) |\n                            2 | // set as liquidated\n                            (temp2_ << 2) | // top tick\n                            (branch_.id << 22);\n                        break;\n                    }\n\n                    unchecked {\n                        // debtLiquidated_ >= currentData_.debtRemaining leads to loop break in if statement above\n                        // so this can be unchecked\n                        currentData_.debtRemaining -= debtLiquidated_;\n                    }\n\n                    // debtFactor = debtFactor * (liquidatableDebt - debtLiquidated) / liquidatableDebt\n                    // -> debtFactor * leftOverDebt / liquidatableDebt\n                    debtFactor_ = (debtFactor_ * (currentData_.debt - debtLiquidated_)) / currentData_.debt;\n                    currentData_.totalDebtLiq += debtLiquidated_;\n                    currentData_.debt -= debtLiquidated_;\n                    currentData_.totalColLiq += colLiquidated_;\n                    currentData_.col -= colLiquidated_;\n\n                    // updating branch's debt factor\n                    branch_.debtFactor = branch_.debtFactor.mulDivBigNumber(debtFactor_);\n                    // Setting debt factor as 1 << 64 again\n                    debtFactor_ = BigMathVault.TWO_POWER_64;\n\n                    if (currentData_.refTickStatus == 2) {\n                        // ref tick is base branch's minima hence merging current branch to base branch\n                        // and making base branch as current branch.\n\n                        // read base branch related data\n                        temp_ = (branch_.data >> 166) & X30; // temp_ -> base branch id\n                        temp2_ = branch_.baseBranchData;\n                        {\n                            uint newBranchDebtFactor_ = (temp2_ >> 116) & X50;\n\n                            // connectionFactor_ = baseBranchDebtFactor / currentBranchDebtFactor\n                            uint connectionFactor_ = newBranchDebtFactor_.divBigNumber(branch_.debtFactor);\n                            // Updating current branch in storage\n                            branchData[branch_.id] =\n                                ((branch_.data >> 166) << 166) | // deleting debt / partials / minima tick\n                                2 | // setting as merged\n                                (connectionFactor_ << 116); // set new connectionFactor\n\n                            // Storing base branch in memory\n                            // Updating branch ID to base branch ID\n                            branch_.id = temp_;\n                            // Updating branch data with base branch data\n                            branch_.data = temp2_;\n                            // Remove next branch connection from base branch\n                            branch_.debtFactor = newBranchDebtFactor_;\n                            // temp_ => minima tick of base branch\n                            temp_ = (temp2_ >> 196) & X20;\n                            if (temp_ > 0) {\n                                unchecked {\n                                    branch_.minimaTick = (temp_ & 1) == 1\n                                        ? int256((temp_ >> 1) & X19)\n                                        : -int256((temp_ >> 1) & X19);\n                                }\n                            } else {\n                                branch_.minimaTick = type(int).min;\n                            }\n                        }\n                    }\n\n                    // Making refTick as currentTick\n                    currentData_.tick = currentData_.refTick;\n                    currentData_.tickStatus = currentData_.refTickStatus;\n                    currentData_.ratio = currentData_.refRatio;\n                }\n            }\n        }\n\n        // calculating net token amounts using exchange price\n        memoryVars_.actualDebtAmt = (currentData_.totalDebtLiq * memoryVars_.borrowExPrice) / EXCHANGE_PRICES_PRECISION;\n        memoryVars_.actualColAmt = (currentData_.totalColLiq * memoryVars_.supplyExPrice) / EXCHANGE_PRICES_PRECISION;\n\n        // Chances of this to happen are in few wei\n        if (memoryVars_.actualDebtAmt > debtAmt_) {\n            // calc new memoryVars_.actualColAmt via ratio.\n            memoryVars_.actualColAmt = memoryVars_.actualColAmt * (debtAmt_ / memoryVars_.actualDebtAmt);\n            memoryVars_.actualDebtAmt = debtAmt_;\n        }\n\n        if (memoryVars_.actualDebtAmt == 0) {\n            revert FluidVaultError(ErrorTypes.Vault__InvalidLiquidation);\n        }\n\n        if (((memoryVars_.actualColAmt * 1e18) / memoryVars_.actualDebtAmt) < colPerUnitDebt_) {\n            revert FluidVaultError(ErrorTypes.Vault__ExcessSlippageLiquidation);\n        }\n\n        if (to_ == DEAD_ADDRESS) {\n            // revert with liquidated amounts if to_ address is the dead address.\n            // this can be used in a resolver to find the max liquidatable amounts.\n            revert FluidLiquidateResult(memoryVars_.actualColAmt, memoryVars_.actualDebtAmt);\n        }\n\n        if (\n            !(TYPE == FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE ||\n                TYPE == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE)\n        ) {\n            // payback at Liquidity\n            if (BORROW_TOKEN == NATIVE_TOKEN) {\n                temp_ = memoryVars_.actualDebtAmt;\n            } else {\n                temp_ = 0;\n            }\n\n            // payback at liquidity\n            LIQUIDITY.operate{ value: temp_ }(\n                BORROW_TOKEN,\n                0,\n                -int(memoryVars_.actualDebtAmt),\n                address(0),\n                address(0),\n                abi.encode(msg.sender)\n            );\n        }\n\n        if (\n            !(TYPE == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE ||\n                TYPE == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE)\n        ) {\n            // withdraw at liquidity\n            LIQUIDITY.operate(SUPPLY_TOKEN, -int(memoryVars_.actualColAmt), 0, to_, address(0), new bytes(0));\n        }\n\n        // Calculating new total collateral & total debt.\n        // temp_ -> total supply\n        temp_ = (vaultVariables_ >> 82) & X64;\n        temp_ = ((temp_ >> 8) << (temp_ & X8)) - currentData_.totalColLiq;\n        // temp2_ -> total borrow\n        temp2_ = (vaultVariables_ >> 146) & X64;\n        temp2_ = ((temp2_ >> 8) << (temp2_ & X8)) - currentData_.totalDebtLiq;\n        // Updating vault variables on storage\n        // Converting total supply & total borrow in 64 bits (56 | 8) bignumber\n        vaultVariables_ =\n            (vaultVariables_ & 0xfffffffffffc00000000000000000000000000000003ffffffffffffffffffff) |\n            (temp_.toBigNumber(56, 8, BigMathMinified.ROUND_DOWN) << 82) | // total supply\n            (temp2_.toBigNumber(56, 8, BigMathMinified.ROUND_UP) << 146); // total borrow\n\n        emit LogLiquidate(msg.sender, memoryVars_.actualColAmt, memoryVars_.actualDebtAmt, to_);\n\n        return abi.encode(memoryVars_.actualDebtAmt, memoryVars_.actualColAmt, vaultVariables_);\n    }\n\n    /// @dev Checks total supply of vault's in Liquidity Layer & Vault contract and rebalance it accordingly\n    /// if vault supply is more than LiquidityLayer/DEX then deposit difference through reserve/rebalance contract\n    /// if vault supply is less than LiquidityLayer/DEX then withdraw difference to reserve/rebalance contract\n    /// if vault borrow is more than LiquidityLayer/DEX then borrow difference to reserve/rebalance contract\n    /// if vault borrow is less than LiquidityLayer/DEX then payback difference through reserve/rebalance contract\n    function rebalance(int, int, int, int) external payable _dexFromAddress returns (int supplyAmt_, int borrowAmt_) {\n        (supplyAmt_, borrowAmt_) = abi.decode(_spell(SECONDARY_IMPLEMENTATION, msg.data), (int, int));\n    }\n\n    /// @dev liquidity callback for cheaper token transfers in case of deposit or payback.\n    /// only callable by Liquidity during an operation.\n    function liquidityCallback(address token_, uint amount_, bytes calldata data_) external {\n        if (msg.sender != address(LIQUIDITY)) {\n            revert FluidVaultError(ErrorTypes.Vault__InvalidLiquidityCallbackAddress);\n        }\n        if (vaultVariables & 1 == 0) revert FluidVaultError(ErrorTypes.Vault__NotEntered);\n\n        SafeTransfer.safeTransferFrom(token_, abi.decode(data_, (address)), address(LIQUIDITY), amount_);\n    }\n\n    /// @dev dex callback for cheaper token transfers in case of deposit or payback.\n    /// only callable by dex during an operation.\n    function dexCallback(address token_, uint amount_) external {\n        if (!(msg.sender == address(SUPPLY) || msg.sender == address(BORROW))) {\n            revert FluidVaultError(ErrorTypes.Vault__InvalidDexCallbackAddress);\n        }\n        if (vaultVariables & 1 == 0) revert FluidVaultError(ErrorTypes.Vault__NotEntered);\n\n        SafeTransfer.safeTransferFrom(token_, dexFromAddress, address(LIQUIDITY), amount_);\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_) {\n        constantsView_.liquidity = address(LIQUIDITY);\n        constantsView_.factory = address(VAULT_FACTORY);\n        constantsView_.operateImplementation = OPERATE_IMPLEMENTATION;\n        constantsView_.adminImplementation = ADMIN_IMPLEMENTATION;\n        constantsView_.secondaryImplementation = SECONDARY_IMPLEMENTATION;\n        constantsView_.deployer = DEPLOYER_CONTRACT;\n        constantsView_.supply = address(SUPPLY);\n        constantsView_.borrow = address(BORROW);\n        constantsView_.supplyToken.token0 = SUPPLY_TOKEN0;\n        constantsView_.supplyToken.token1 = SUPPLY_TOKEN1;\n        constantsView_.borrowToken.token0 = BORROW_TOKEN0;\n        constantsView_.borrowToken.token1 = BORROW_TOKEN1;\n        constantsView_.vaultId = VAULT_ID;\n        constantsView_.vaultType = TYPE;\n        constantsView_.supplyExchangePriceSlot = SUPPLY_EXCHANGE_PRICE_SLOT;\n        constantsView_.borrowExchangePriceSlot = BORROW_EXCHANGE_PRICE_SLOT;\n        constantsView_.userSupplySlot = USER_SUPPLY_SLOT;\n        constantsView_.userBorrowSlot = USER_BORROW_SLOT;\n    }\n\n    constructor(ConstantViews memory constants_) HelpersLiquidate(constants_) {\n        // Note that vaults are deployed by VaultFactory so we somewhat trust the values being passed in\n\n        // Setting branch in vault.\n        vaultVariables = (vaultVariables) | (1 << 22) | (1 << 52);\n\n        dexFromAddress = DEAD_ADDRESS;\n\n        // If smart collateral then liqSupplyExchangePrice_ will always be EXCHANGE_PRICES_PRECISION\n        uint liqSupplyExchangePrice_ = (constants_.vaultType == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE ||\n            constants_.vaultType == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE)\n            ? EXCHANGE_PRICES_PRECISION\n            : ((SUPPLY.readFromStorage(SUPPLY_EXCHANGE_PRICE_SLOT) >>\n                LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) & X64);\n\n        // If smart debt then liqBorrowExchangePrice_ will always be EXCHANGE_PRICES_PRECISION\n        uint liqBorrowExchangePrice_ = (constants_.vaultType == FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE ||\n            constants_.vaultType == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE)\n            ? EXCHANGE_PRICES_PRECISION\n            : ((BORROW.readFromStorage(BORROW_EXCHANGE_PRICE_SLOT) >>\n                LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) & X64);\n\n        if (\n            liqSupplyExchangePrice_ < EXCHANGE_PRICES_PRECISION || liqBorrowExchangePrice_ < EXCHANGE_PRICES_PRECISION\n        ) {\n            revert FluidVaultError(ErrorTypes.Vault__TokenNotInitialized);\n        }\n\n        if (constants_.operateImplementation == address(0)) {\n            revert FluidVaultError(ErrorTypes.Vault__ImproperConstantsSetup);\n        }\n\n        // Updating initial rates in storage\n        rates =\n            liqSupplyExchangePrice_ |\n            (liqBorrowExchangePrice_ << 64) |\n            (EXCHANGE_PRICES_PRECISION << 128) |\n            (EXCHANGE_PRICES_PRECISION << 192);\n\n        vaultVariables2 =\n            (vaultVariables2 & 0xfffffffffffffffffffffffff800000003ffffffffffffffffffffffffffffff) |\n            (block.timestamp << 122);\n    }\n\n    fallback() external {\n        if (!(VAULT_FACTORY.isGlobalAuth(msg.sender) || VAULT_FACTORY.isVaultAuth(address(this), msg.sender))) {\n            revert FluidVaultError(ErrorTypes.Vault__NotAnAuth);\n        }\n\n        // Delegate the current call to `implementation`.\n        // This does not return to its internall call site, it will return directly to the external caller.\n        // solhint-disable-next-line no-inline-assembly\n        _spell(ADMIN_IMPLEMENTATION, msg.data);\n    }\n\n    receive() external payable {}\n\n    function _spell(address target_, bytes memory data_) internal returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/coreModule/main2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { Variables } from \"../common/variables.sol\";\nimport { TickMath } from \"../../../../libraries/tickMath.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { Error } from \"../../error.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { IFluidVault } from \"../../interfaces/iVault.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { Events } from \"./events.sol\";\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\nimport { LiquidityCalcs } from \"../../../../libraries/liquidityCalcs.sol\";\nimport { ILiquidityDexCommon } from \"../../interfaces/iLiquidityDexCommon.sol\";\nimport { SafeTransfer } from \"../../../../libraries/safeTransfer.sol\";\nimport { TokenTransfers } from \"../common/tokenTransfers.sol\";\nimport { FluidProtocolTypes } from \"../../../../libraries/fluidProtocolTypes.sol\";\n\n/// @notice Fluid Vault protocol secondary methods contract.\n///         Implements `absorb()` and `rebalance()` methods, extracted from main contract due to contract size limits.\n///         Methods are limited to be called via delegateCall only (as done by Vault CoreModule contract).\ncontract FluidVaultSecondary is Variables, Error, Structs, Events, TokenTransfers {\n    using BigMathMinified for uint;\n\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // 30 bits (used for partials mainly)\n    uint internal constant X8 = 0xff;\n    uint internal constant X10 = 0x3ff;\n    uint internal constant X16 = 0xffff;\n    uint internal constant X19 = 0x7ffff;\n    uint internal constant X20 = 0xfffff;\n    uint internal constant X24 = 0xffffff;\n    uint internal constant X25 = 0x1ffffff;\n    uint internal constant X30 = 0x3fffffff;\n    uint internal constant X35 = 0x7ffffffff;\n    uint internal constant X50 = 0x3ffffffffffff;\n    uint internal constant X64 = 0xffffffffffffffff;\n    uint internal constant X96 = 0xffffffffffffffffffffffff;\n    uint internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n\n    address private immutable addressThis;\n\n    constructor() {\n        addressThis = address(this);\n    }\n\n    modifier _verifyCaller() {\n        if (address(this) == addressThis) {\n            revert FluidVaultError(ErrorTypes.Vault__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev absorb function absorbs the bad debt if the bad debt is above max limit. The main use of it is\n    /// if the bad debt didn't got liquidated in time maybe due to sudden price drop or bad debt was extremely small to liquidate\n    /// and the bad debt goes above 100% ratio then there's no incentive for anyone to liquidate now\n    /// hence absorb functions absorbs that bad debt to allow newer bad debt to liquidate seamlessly.\n    /// if absorbing were to happen after this it's on governance on how to deal with it\n    /// although it can still be removed through liquidate via liquidator if the price goes back up and liquidation becomes beneficial\n    /// upon absorbed user position gets 100% liquidated.\n    function absorb(uint vaultVariables_, int maxTick_) public _verifyCaller returns (uint) {\n        AbsorbMemoryVariables memory a_;\n\n        // Temporary holder variables, used many times for different small few liner things\n        uint temp_;\n        uint temp2_;\n\n        TickHasDebt memory tickHasDebt_;\n\n        {\n            // liquidating ticks above max ratio\n\n            // temp_ -> top tick\n            temp_ = ((vaultVariables_ >> 2) & X20);\n            // increasing startingTick_ by 1 so the current tick comes into looping equation\n            a_.startingTick = (temp_ & 1) == 1 ? (int(temp_ >> 1) + 1) : (-int(temp_ >> 1) + 1);\n\n            tickHasDebt_.mapId = a_.startingTick < 0 ? ((a_.startingTick + 1) / 256) - 1 : a_.startingTick / 256;\n\n            tickHasDebt_.tickHasDebt = tickHasDebt[tickHasDebt_.mapId];\n\n            {\n                // For last user remaining in vault there could be a lot of while loop.\n                // Chances of this to happen is extremely low (like ~0%)\n                tickHasDebt_.nextTick = TickMath.MAX_TICK;\n                while (true) {\n                    if (tickHasDebt_.tickHasDebt > 0) {\n                        a_.mostSigBit = tickHasDebt_.tickHasDebt.mostSignificantBit();\n                        tickHasDebt_.nextTick = tickHasDebt_.mapId * 256 + int(a_.mostSigBit) - 1;\n\n                        while (tickHasDebt_.nextTick > maxTick_) {\n                            // storing tickData into temp_\n                            temp_ = tickData[tickHasDebt_.nextTick];\n                            // temp2_ -> tick's debt\n                            temp2_ = (temp_ >> 25) & X64;\n                            // converting big number into normal number\n                            temp2_ = (temp2_ >> 8) << (temp2_ & X8);\n                            // Absorbing tick's debt & collateral\n                            a_.debtAbsorbed += temp2_;\n                            // calculating collateral from debt & ratio and adding to a_.colAbsorbed\n                            a_.colAbsorbed += ((temp2_ * TickMath.ZERO_TICK_SCALED_RATIO) /\n                                TickMath.getRatioAtTick(int24(tickHasDebt_.nextTick)));\n                            // Update tick data on storage. Making tick as 100% liquidated\n                            tickData[tickHasDebt_.nextTick] = 1 | (temp_ & 0x1fffffe) | (1 << 25); // set as 100% liquidated\n\n                            // temp_ = bits to remove\n                            temp_ = 257 - a_.mostSigBit;\n                            tickHasDebt_.tickHasDebt = (tickHasDebt_.tickHasDebt << temp_) >> temp_;\n                            if (tickHasDebt_.tickHasDebt == 0) break;\n\n                            a_.mostSigBit = tickHasDebt_.tickHasDebt.mostSignificantBit();\n                            tickHasDebt_.nextTick = tickHasDebt_.mapId * 256 + int(a_.mostSigBit) - 1;\n                        }\n                        // updating tickHasDebt on storage\n                        tickHasDebt[tickHasDebt_.mapId] = tickHasDebt_.tickHasDebt;\n                    }\n\n                    // tickHasDebt_.tickHasDebt == 0 from here.\n\n                    if (tickHasDebt_.nextTick <= maxTick_) {\n                        break;\n                    }\n\n                    if (tickHasDebt_.mapId < -129) {\n                        tickHasDebt_.nextTick = type(int).min;\n                        break;\n                    }\n\n                    // Fetching next tickHasDebt by decreasing tickHasDebt_.mapId first\n                    tickHasDebt_.tickHasDebt = tickHasDebt[--tickHasDebt_.mapId];\n                }\n            }\n        }\n\n        // After the above loop we will get nextTick stored in tickHasDebt_ which we will use to compare & set things in the end\n\n        {\n            TickData memory tickInfo_;\n            BranchData memory branch_;\n            // if this remains 0 that means create a new branch over the end\n            uint newBranchId_;\n\n            {\n                // Liquidate branches in a loop and store the end branch\n                branch_.id = (vaultVariables_ >> 22) & X30;\n                branch_.data = branchData[branch_.id];\n                // Checking if current branch is liquidated\n                if ((vaultVariables_ & 2) == 0) {\n                    // current branch is not liquidated hence it can be used as a new branch if needed\n                    newBranchId_ = branch_.id;\n\n                    // Checking the base branch minima tick. temp_ = base branch minima tick\n                    temp_ = (branch_.data >> 196) & X20;\n                    if (temp_ > 0) {\n                        // Setting the base branch as current liquidatable branch\n                        branch_.id = (branch_.data >> 166) & X30;\n                        branch_.data = branchData[branch_.id];\n                        branch_.minimaTick = (temp_ & 1) == 1 ? int(temp_ >> 1) : -int(temp_ >> 1);\n                    } else {\n                        // the current branch is base branch, hence need to setup a new base branch\n                        branch_.id = 0;\n                        branch_.data = 0;\n                        branch_.minimaTick = type(int).min;\n                    }\n                } else {\n                    // current branch is liquidated\n                    temp_ = (branch_.data >> 2) & X20;\n                    branch_.minimaTick = (temp_ & 1) == 1 ? int(temp_ >> 1) : -int(temp_ >> 1);\n                }\n                while (branch_.minimaTick > maxTick_) {\n                    // Check base branch, if exists then check if minima tick is above max tick then liquidate it.\n                    tickInfo_.ratio = TickMath.getRatioAtTick(int24(branch_.minimaTick));\n                    tickInfo_.ratioOneLess = (tickInfo_.ratio * 10000) / 10015;\n                    tickInfo_.length = tickInfo_.ratio - tickInfo_.ratioOneLess;\n\n                    // partials\n                    tickInfo_.partials = (branch_.data >> 22) & X30;\n\n                    tickInfo_.currentRatio = tickInfo_.ratioOneLess + ((tickInfo_.length * tickInfo_.partials) / X30);\n\n                    // debt in branch\n                    temp2_ = (branch_.data >> 52) & X64;\n                    // converting big number into normal number\n                    temp2_ = (temp2_ >> 8) << (temp2_ & X8);\n                    // Absorbing branch's debt & collateral\n                    a_.debtAbsorbed += temp2_;\n                    // calculating branch's collateral using debt & ratio and adding it to a_.colAbsorbed\n                    a_.colAbsorbed += (temp2_ * TickMath.ZERO_TICK_SCALED_RATIO) / tickInfo_.currentRatio;\n\n                    // Closing branch\n                    branchData[branch_.id] = branch_.data | 3;\n\n                    // Setting new branch\n                    temp_ = (branch_.data >> 196) & X20; // temp_ -> minima tick of connected branch\n                    if (temp_ > 0) {\n                        // Setting the base branch as current liquidatable branch\n                        branch_.id = (branch_.data >> 166) & X30;\n                        branch_.data = branchData[branch_.id];\n                        branch_.minimaTick = (temp_ & 1) == 1 ? int(temp_ >> 1) : -int(temp_ >> 1);\n                    } else {\n                        // the current branch is base branch, hence need to setup a new base branch\n                        branch_.id = 0;\n                        branch_.data = 0;\n                        branch_.minimaTick = type(int).min;\n                    }\n                }\n            }\n\n            if (tickHasDebt_.nextTick >= branch_.minimaTick) {\n                // new top tick is not liquidated\n                // temp2_ = tick to insert\n                if (tickHasDebt_.nextTick > type(int).min) {\n                    temp2_ = tickHasDebt_.nextTick < 0\n                        ? (uint(-tickHasDebt_.nextTick) << 1)\n                        : ((uint(tickHasDebt_.nextTick) << 1) | 1);\n                } else {\n                    temp2_ = 0;\n                }\n                if (newBranchId_ == 0) {\n                    // initializing a new branch\n                    // newBranchId_ = total current branches + 1\n                    unchecked {\n                        newBranchId_ = ((vaultVariables_ >> 52) & X30) + 1;\n                    }\n                    vaultVariables_ =\n                        ((vaultVariables_ >> 82) << 82) |\n                        (temp2_ << 2) |\n                        (newBranchId_ << 22) |\n                        (newBranchId_ << 52);\n                } else {\n                    // using already initialized non liquidated branch\n                    vaultVariables_ = ((vaultVariables_ >> 22) << 22) | (temp2_ << 2);\n                }\n\n                if (branch_.minimaTick > type(int).min) {\n                    temp2_ = branch_.minimaTick < 0\n                        ? (uint(-branch_.minimaTick) << 1)\n                        : ((uint(branch_.minimaTick) << 1) | 1);\n                    // set base branch id and minima tick\n                    branchData[newBranchId_] = (branch_.id << 166) | (temp2_ << 196);\n                } else {\n                    // new base branch does not have any connected branch\n                    branchData[newBranchId_] = 0;\n                }\n            } else {\n                // new top tick is liquidated\n                temp2_ = branch_.minimaTick < 0\n                    ? (uint(-branch_.minimaTick) << 1)\n                    : ((uint(branch_.minimaTick) << 1) | 1);\n                if (newBranchId_ == 0) {\n                    vaultVariables_ = ((vaultVariables_ >> 52) << 52) | 2 | (temp2_ << 2) | (branch_.id << 22);\n                } else {\n                    // uninitializing the non liquidated branch\n                    vaultVariables_ =\n                        ((vaultVariables_ >> 82) << 82) |\n                        2 |\n                        (temp2_ << 2) |\n                        (branch_.id << 22) |\n                        ((newBranchId_ - 1) << 52); // decreasing total branch by 1\n                    branchData[newBranchId_] = 0;\n                }\n            }\n        }\n\n        // updating absorbed liquidity on storage\n        absorbedLiquidity = absorbedLiquidity + a_.debtAbsorbed + (a_.colAbsorbed << 128);\n\n        emit LogAbsorb(a_.colAbsorbed, a_.debtAbsorbed);\n\n        // returning updated vault variables\n        return vaultVariables_;\n    }\n\n    /// @dev Checks total supply of vault's in Liquidity Layer & Vault contract and rebalance it accordingly\n    /// if vault supply is more than Liquidity Layer then deposit difference through reserve/rebalance contract\n    /// if vault supply is less than Liquidity Layer then withdraw difference to reserve/rebalance contract\n    /// if vault borrow is more than Liquidity Layer then borrow difference to reserve/rebalance contract\n    /// if vault borrow is less than Liquidity Layer then payback difference through reserve/rebalance contract\n    function rebalance(\n        int colToken0MinMax_,\n        int colToken1MinMax_,\n        int debtToken0MinMax_,\n        int debtToken1MinMax_\n    ) external payable _verifyCaller returns (int supplyAmt_, int borrowAmt_) {\n        if (msg.sender != rebalancer) {\n            revert FluidVaultError(ErrorTypes.Vault__NotRebalancer);\n        }\n\n        uint vaultVariables_ = vaultVariables;\n        // ############# turning re-entrancy bit on #############\n        if (vaultVariables_ & 1 == 0) {\n            // Updating on storage\n            vaultVariables = vaultVariables_ | 1;\n        } else {\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\n        }\n\n        RebalanceMemoryVariables memory r_;\n        // note: any of the excess ETH sent will be returned back by checking initial and final balance\n        r_.initialEth = address(this).balance - msg.value;\n\n        IFluidVault.ConstantViews memory c_ = IFluidVault(address(this)).constantsView();\n\n        // if supply is smart col then it's DEX address else liquidity address\n        ILiquidityDexCommon supply_ = ILiquidityDexCommon(c_.supply);\n        // if borrow is smart debt then it's DEX address else liquidity address\n        ILiquidityDexCommon borrow_ = ILiquidityDexCommon(c_.borrow);\n\n        (r_.liqSupplyExPrice, r_.liqBorrowExPrice, r_.vaultSupplyExPrice, r_.vaultBorrowExPrice) = IFluidVault(\n            address(this)\n        ).updateExchangePrices(vaultVariables2);\n\n        // extract vault supply at Liquidity -> 64 bits starting from bit 1 (first bit is interest mode)\n        r_.totalSupply =\n            (supply_.readFromStorage(c_.userSupplySlot) >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) &\n            X64;\n        r_.totalSupply = (r_.totalSupply >> 8) << (r_.totalSupply & X8);\n        r_.totalSupply = (r_.totalSupply * r_.liqSupplyExPrice) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n\n        // extract vault borrowings at Liquidity -> 64 bits starting from bit 1 (first bit is interest mode)\n        r_.totalBorrow =\n            (borrow_.readFromStorage(c_.userBorrowSlot) >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) &\n            X64;\n        r_.totalBorrow = (r_.totalBorrow >> 8) << (r_.totalBorrow & X8);\n        r_.totalBorrow = (r_.totalBorrow * r_.liqBorrowExPrice) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n\n        r_.totalSupplyVault = (vaultVariables_ >> 82) & X64;\n        r_.totalSupplyVault = (r_.totalSupplyVault >> 8) << (r_.totalSupplyVault & X8);\n        r_.totalSupplyVault = (r_.totalSupplyVault * r_.vaultSupplyExPrice) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n\n        r_.totalBorrowVault = (vaultVariables_ >> 146) & X64;\n        r_.totalBorrowVault = (r_.totalBorrowVault >> 8) << (r_.totalBorrowVault & X8);\n        r_.totalBorrowVault = (r_.totalBorrowVault * r_.vaultBorrowExPrice) / LiquidityCalcs.EXCHANGE_PRICES_PRECISION;\n\n        uint value_;\n\n        if (r_.totalSupplyVault > r_.totalSupply) {\n            // Fetch tokens from revenue/rebalance contract and supply in liquidity/dex contract\n            // This is the scenario when the supply rewards are going in vault, hence\n            // the vault total supply is increasing at a higher pace than Liquidity/DEX contract.\n            // We are not transferring rewards right when we set the rewards to keep things clean.\n            // Also, this can also happen in case when supply rate magnifier is greater than 1.\n\n            supplyAmt_ = int(r_.totalSupplyVault) - int(r_.totalSupply);\n\n            if (\n                c_.vaultType == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE ||\n                c_.vaultType == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\n            ) {\n                if (colToken0MinMax_ <= 0 || colToken1MinMax_ <= 0) {\n                    revert FluidVaultError(ErrorTypes.Vault__InvalidMinMaxInRebalance);\n                }\n\n                try\n                    supply_.depositPerfect{\n                        value: (c_.supplyToken.token0 == NATIVE_TOKEN)\n                            ? uint(colToken0MinMax_)\n                            : (c_.supplyToken.token1 == NATIVE_TOKEN)\n                                ? uint(colToken1MinMax_)\n                                : 0\n                    }(uint(supplyAmt_), uint(colToken0MinMax_), uint(colToken1MinMax_), false)\n                returns (uint, uint) {\n                    // if success then do nothing\n                } catch {\n                    supplyAmt_ = 0;\n                }\n            } else {\n                if (c_.supplyToken.token0 == NATIVE_TOKEN) {\n                    value_ = uint(supplyAmt_);\n                } else {\n                    value_ = 0;\n                }\n\n                try\n                    supply_.operate{ value: value_ }(\n                        c_.supplyToken.token0,\n                        supplyAmt_,\n                        0,\n                        address(0),\n                        address(0),\n                        abi.encode(msg.sender)\n                    )\n                {\n                    // if success then do nothing\n                } catch {\n                    supplyAmt_ = 0;\n                }\n            }\n        } else if (r_.totalSupply > r_.totalSupplyVault) {\n            // Withdraw from Liquidity/DEX contract and send it to revenue contract.\n            // This is the scenario when the vault user's are getting less APR than what's going on Liquidity contract.\n            // When supply rate magnifier is less than 1.\n\n            supplyAmt_ = int(r_.totalSupplyVault) - int(r_.totalSupply);\n\n            if (\n                c_.vaultType == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE ||\n                c_.vaultType == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\n            ) {\n                if (colToken0MinMax_ >= 0 || colToken1MinMax_ >= 0) {\n                    revert FluidVaultError(ErrorTypes.Vault__InvalidMinMaxInRebalance);\n                }\n\n                try\n                    supply_.withdrawPerfect(\n                        uint(-supplyAmt_),\n                        uint(-colToken0MinMax_),\n                        uint(-colToken1MinMax_),\n                        msg.sender\n                    )\n                returns (uint, uint) {\n                    // if success then do nothing\n                } catch {\n                    supplyAmt_ = 0;\n                }\n            } else {\n                try supply_.operate(c_.supplyToken.token0, supplyAmt_, 0, msg.sender, address(0), new bytes(0)) {\n                    // if success then do nothing\n                } catch {\n                    supplyAmt_ = 0;\n                }\n            }\n        }\n\n        if (r_.totalBorrowVault > r_.totalBorrow) {\n            // Borrow from Liquidity/DEX contract and send to revenue/rebalance contract\n            // This is the scenario when the vault is charging more borrow to user than the Liquidity contract.\n            // When borrow rate magnifier is greater than 1.\n\n            borrowAmt_ = int(r_.totalBorrowVault) - int(r_.totalBorrow);\n\n            if (\n                c_.vaultType == FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE ||\n                c_.vaultType == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\n            ) {\n                if (debtToken0MinMax_ <= 0 || debtToken1MinMax_ <= 0) {\n                    revert FluidVaultError(ErrorTypes.Vault__InvalidMinMaxInRebalance);\n                }\n\n                try\n                    borrow_.borrowPerfect(\n                        uint(borrowAmt_),\n                        uint(debtToken0MinMax_),\n                        uint(debtToken1MinMax_),\n                        msg.sender\n                    )\n                returns (uint, uint) {\n                    // if success then do nothing\n                } catch {\n                    borrowAmt_ = 0;\n                }\n            } else {\n                try borrow_.operate(c_.borrowToken.token0, 0, borrowAmt_, address(0), msg.sender, new bytes(0)) {\n                    // if success then do nothing\n                } catch {\n                    borrowAmt_ = 0;\n                }\n            }\n        } else if (r_.totalBorrow > r_.totalBorrowVault) {\n            // Transfer from revenue/rebalance contract and payback on Liquidity contract\n            // This is the scenario when vault protocol is earning rewards so effective borrow rate for users is low.\n            // Or the case where borrow rate magnifier is less than 1\n\n            borrowAmt_ = int(r_.totalBorrow) - int(r_.totalBorrowVault);\n\n            if (\n                c_.vaultType == FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE ||\n                c_.vaultType == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\n            ) {\n                if (debtToken0MinMax_ >= 0 || debtToken1MinMax_ >= 0) {\n                    revert FluidVaultError(ErrorTypes.Vault__InvalidMinMaxInRebalance);\n                }\n\n                try\n                    borrow_.paybackPerfect{\n                        value: (c_.borrowToken.token0 == NATIVE_TOKEN)\n                            ? uint(-debtToken0MinMax_)\n                            : (c_.borrowToken.token1 == NATIVE_TOKEN)\n                                ? uint(-debtToken1MinMax_)\n                                : 0\n                    }(\n                        uint(borrowAmt_), // not doing -borrowAmt_ because we already calculated it positively\n                        uint(-debtToken0MinMax_),\n                        uint(-debtToken1MinMax_),\n                        false\n                    )\n                returns (uint, uint) {\n                    // if success then do nothing\n                    borrowAmt_ = -borrowAmt_;\n                } catch {\n                    borrowAmt_ = 0;\n                }\n            } else {\n                if (c_.borrowToken.token0 == NATIVE_TOKEN) {\n                    value_ = uint(borrowAmt_);\n                } else {\n                    value_ = 0;\n                }\n\n                borrowAmt_ = -borrowAmt_;\n\n                try\n                    borrow_.operate{ value: value_ }(\n                        c_.borrowToken.token0,\n                        0,\n                        borrowAmt_,\n                        address(0),\n                        address(0),\n                        abi.encode(msg.sender)\n                    )\n                {\n                    // if success then do nothing\n                } catch {\n                    borrowAmt_ = 0;\n                }\n            }\n        }\n\n        if (supplyAmt_ == 0 && borrowAmt_ == 0) {\n            revert FluidVaultError(ErrorTypes.Vault__NothingToRebalance);\n        }\n\n        // Updating vault variable on storage to turn off the reentrancy bit\n        vaultVariables = vaultVariables_;\n\n        _validateEth(r_.initialEth);\n\n        emit LogRebalance(supplyAmt_, borrowAmt_);\n    }\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/coreModule/mainOperate.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidOracle } from \"../../../../oracle/fluidOracle.sol\";\nimport { TickMath } from \"../../../../libraries/tickMath.sol\";\nimport { BigMathMinified } from \"../../../../libraries/bigMathMinified.sol\";\nimport { BigMathVault } from \"../../../../libraries/bigMathVault.sol\";\nimport { LiquidityCalcs } from \"../../../../libraries/liquidityCalcs.sol\";\nimport { SafeTransfer } from \"../../../../libraries/safeTransfer.sol\";\nimport { HelpersOperate } from \"./helpersOperate.sol\";\nimport { LiquiditySlotsLink } from \"../../../../libraries/liquiditySlotsLink.sol\";\nimport { ErrorTypes } from \"../../errorTypes.sol\";\nimport { AddressCalcs } from \"../../../../libraries/addressCalcs.sol\";\nimport { FluidProtocolTypes } from \"../../../../libraries/fluidProtocolTypes.sol\";\n\n/// @dev Fluid vault protocol main operate contract base.\nabstract contract FluidVaultOperate is HelpersOperate {\n    using BigMathMinified for uint256;\n    using BigMathVault for uint256;\n\n    modifier _delegateCallCheck() {\n        if (address(this) == OPERATE_IMPLEMENTATION) {\n            revert FluidVaultError(ErrorTypes.Vault__OnlyDelegateCallAllowed);\n        }\n        _;\n    }\n\n    /// @dev Single function which handles supply, withdraw, borrow & payback\n    /// @param nftId_ NFT ID for interaction. If 0 then create new NFT/position.\n    /// @param newCol_ new collateral. If positive then deposit, if negative then withdraw, if 0 then do nohing\n    /// @param newDebt_ new debt. If positive then borrow, if negative then payback, if 0 then do nohing\n    /// @param to_ address where withdraw or borrow should go. If address(0) then msg.sender\n    /// @param vaultVariables_ the current state of the vaultVariables from storage\n    /// @return nftId_ if 0 then this returns the newly created NFT Id else returns the same NFT ID\n    /// @return newCol_ final supply amount. Mainly if max withdraw using type(int).min then this is useful to get perfect amount else remain same as newCol_\n    /// @return newDebt_ final borrow amount. Mainly if max payback using type(int).min then this is useful to get perfect amount else remain same as newDebt_\n    /// @return vaultVariables_ the updated state of the vaultVariables\n    function _operate(\n        uint256 nftId_, // if 0 then new position\n        int256 newCol_, // if negative then withdraw\n        int256 newDebt_, // if negative then payback\n        address to_, // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\n        uint256 vaultVariables_\n    )\n        internal\n        returns (\n            uint256, // nftId_\n            int256, // final supply amount. if - then withdraw\n            int256, // final borrow amount. if - then payback\n            uint256 // vaultVariables_\n        )\n    {\n        if (\n            (newCol_ == 0 && newDebt_ == 0) ||\n            // withdrawal or deposit cannot be too small\n            ((newCol_ != 0) && (newCol_ > -10000 && newCol_ < 10000)) ||\n            // borrow or payback cannot be too small\n            ((newDebt_ != 0) && (newDebt_ > -10000 && newDebt_ < 10000))\n        ) {\n            revert FluidVaultError(ErrorTypes.Vault__InvalidOperateAmount);\n        }\n\n        OperateMemoryVars memory o_;\n        // Temporary variables used as helpers at many places\n        uint256 temp_;\n        uint256 temp2_;\n        int256 temp3_;\n\n        o_.vaultVariables2 = vaultVariables2;\n\n        temp_ = (vaultVariables_ >> 2) & X20;\n        unchecked {\n            o_.topTick = (temp_ == 0)\n                ? type(int).min\n                : ((temp_ & 1) == 1)\n                    ? int((temp_ >> 1) & X19)\n                    : -int((temp_ >> 1) & X19);\n        }\n\n        {\n            // Fetching user's position\n            if (nftId_ == 0) {\n                // creating new position.\n                o_.tick = type(int).min;\n                // minting new NFT vault for user.\n                nftId_ = VAULT_FACTORY.mint(VAULT_ID, msg.sender);\n                // Adding 1 in total positions. Total positions cannot exceed 32bits as NFT minting checks for that\n                unchecked {\n                    vaultVariables_ = vaultVariables_ + (1 << 210);\n                }\n            } else {\n                // Updating existing position\n\n                // checking owner only in case of withdraw or borrow\n                temp_ = nftId_;\n                if ((newCol_ < 0 || newDebt_ > 0) && (VAULT_FACTORY.ownerOf(temp_) != msg.sender)) {\n                    revert FluidVaultError(ErrorTypes.Vault__NotAnOwner);\n                }\n\n                // temp_ => user's position data\n                temp_ = positionData[nftId_];\n\n                if (temp_ == 0) {\n                    revert FluidVaultError(ErrorTypes.Vault__NftNotOfThisVault);\n                }\n                // temp2_ => user's supply amount\n                temp2_ = (temp_ >> 45) & X64;\n                // Converting big number into normal number\n                o_.colRaw = (temp2_ >> 8) << (temp2_ & X8);\n                // temp2_ => user's  dust debt amount\n                temp2_ = (temp_ >> 109) & X64;\n                // Converting big number into normal number\n                o_.dustDebtRaw = (temp2_ >> 8) << (temp2_ & X8);\n\n                // 1 is supply & 0 is borrow\n                if (temp_ & 1 == 1) {\n                    // only supply position (has no debt)\n                    o_.tick = type(int).min;\n                } else {\n                    // borrow position (has collateral & debt)\n                    unchecked {\n                        o_.tick = temp_ & 2 == 2 ? int((temp_ >> 2) & X19) : -int((temp_ >> 2) & X19);\n                    }\n                    o_.tickId = (temp_ >> 21) & X24;\n                }\n            }\n        }\n\n        // Get latest updated Position's debt & supply (if position is with debt -> not new / supply position)\n        if (o_.tick > type(int).min) {\n            // if entering this if statement then temp_ here will always be user's position data\n            // extracting collateral exponent\n            temp_ = (temp_ >> 45) & X8;\n            // if exponent is > 0 then rounding up the collateral just for calculating debt\n            unchecked {\n                temp_ = temp_ == 0 ? (o_.colRaw + 1) : o_.colRaw + (1 << temp_);\n            }\n            // fetch current debt\n            o_.debtRaw = ((TickMath.getRatioAtTick(int24(o_.tick)) * temp_) >> 96) + 1;\n\n            // Tick data from user's tick\n            temp_ = tickData[o_.tick];\n\n            // Checking if tick is liquidated (first bit 1) OR if the total IDs of tick is greater than user's tick ID\n            if (((temp_ & 1) == 1) || (((temp_ >> 1) & X24) > o_.tickId)) {\n                // User got liquidated\n                (\n                    // returns the position of the user if the user got liquidated.\n                    o_.tick,\n                    o_.debtRaw,\n                    o_.colRaw,\n                    temp2_, // final branchId from liquidation where position exist right now\n                    o_.branchData\n                ) = fetchLatestPosition(o_.tick, o_.tickId, o_.debtRaw, temp_);\n\n                if (o_.debtRaw > o_.dustDebtRaw) {\n                    // temp_ => branch's Debt\n                    temp_ = (o_.branchData >> 52) & X64;\n                    temp_ = (temp_ >> 8) << (temp_ & X8);\n\n                    // o_.debtRaw should always be < branch's Debt (temp_).\n                    // Taking margin (0.01%) in fetchLatestPosition to make sure it's always less\n                    temp_ -= o_.debtRaw;\n                    if (temp_ < 100) {\n                        // explicitly making sure that branch debt/liquidity doesn't get super low.\n                        temp_ = 100;\n                    }\n                    // Inserting updated branch's debt\n                    branchData[temp2_] =\n                        (o_.branchData & 0xfffffffffffffffffffffffffffffffffff0000000000000000fffffffffffff) |\n                        (temp_.toBigNumber(56, 8, BigMathMinified.ROUND_UP) << 52);\n\n                    unchecked {\n                        // Converted positionRawDebt_ in net position debt\n                        o_.debtRaw -= o_.dustDebtRaw;\n                    }\n                } else {\n                    // Liquidated 100% or almost 100%\n                    // absorbing dust debt\n                    absorbedDustDebt = absorbedDustDebt + o_.dustDebtRaw - o_.debtRaw;\n                    o_.debtRaw = 0;\n                    o_.colRaw = 0;\n                }\n            } else {\n                // User didn't got liquidated\n                // Removing user's debt from tick data\n                // temp2_ => debt in tick\n                temp2_ = (temp_ >> 25) & X64;\n                // below require can fail when a user liquidity is extremely low (talking about way less than even $1)\n                // adding require meaning this vault user won't be able to interact unless someone makes the liquidity in tick as non 0.\n                // reason of adding is the tick has already removed from everywhere. Can removing it again break something? Better to simply remove that case entirely\n                if (temp2_ == 0) {\n                    revert FluidVaultError(ErrorTypes.Vault__TickIsEmpty);\n                }\n                // Converting big number into normal number\n                temp2_ = (temp2_ >> 8) << (temp2_ & X8);\n                // debtInTick (temp2_) < debtToRemove (o_.debtRaw) that means minor precision error. Hence make the debtInTick as 0.\n                // The precision error can be caused with Bigmath library limiting the precision to 2**56.\n                unchecked {\n                    temp2_ = o_.debtRaw < temp2_ ? temp2_ - o_.debtRaw : 0;\n                }\n\n                if (temp2_ < 10000) {\n                    temp2_ = 0;\n                    // if debt becomes 0 then remove from tick has debt\n\n                    if (o_.tick == o_.topTick) {\n                        // if tick is top tick then current top tick is perfect tick -> fetch & set new top tick\n\n                        // Updating new top tick in vaultVariables_ and topTick_\n                        (vaultVariables_, o_.topTick) = _setNewTopTick(o_.topTick, vaultVariables_);\n                    }\n\n                    // Removing from tickHasDebt\n                    _updateTickHasDebt(o_.tick, false);\n                }\n\n                tickData[o_.tick] = (temp_ & X25) | (temp2_.toBigNumber(56, 8, BigMathMinified.ROUND_DOWN) << 25);\n\n                // Converted positionRawDebt_ in net position debt\n                o_.debtRaw -= o_.dustDebtRaw;\n            }\n            o_.dustDebtRaw = 0;\n        }\n\n        // Setting the current tick into old tick as the position tick is going to change now.\n        o_.oldTick = o_.tick;\n        o_.oldColRaw = o_.colRaw;\n        o_.oldNetDebtRaw = o_.debtRaw;\n\n        {\n            (o_.liquidityExPrice, , o_.supplyExPrice, o_.borrowExPrice) = updateExchangePrices(o_.vaultVariables2);\n\n            {\n                // supply or withdraw\n                if (newCol_ > 0) {\n                    // supply new col, rounding down\n                    o_.colRaw += (uint256(newCol_) * EXCHANGE_PRICES_PRECISION) / o_.supplyExPrice;\n                    // final user's collateral should not be above 2**128 bits\n                    if (o_.colRaw > X128) {\n                        revert FluidVaultError(ErrorTypes.Vault__UserCollateralDebtExceed);\n                    }\n                } else if (newCol_ < 0) {\n                    // if withdraw equals type(int).min then max withdraw\n                    if (newCol_ > type(int128).min) {\n                        // partial withdraw, rounding up removing extra wei from collateral\n                        temp3_ = ((newCol_ * int(EXCHANGE_PRICES_PRECISION)) / int256(o_.supplyExPrice)) - 1;\n                        unchecked {\n                            if (uint256(-temp3_) > o_.colRaw) {\n                                revert FluidVaultError(ErrorTypes.Vault__ExcessCollateralWithdrawal);\n                            }\n                            o_.colRaw -= uint256(-temp3_);\n                        }\n                    } else if (newCol_ == type(int).min) {\n                        // max withdraw, rounding up:\n                        // adding +1 to negative withdrawAmount newCol_ for safe rounding (reducing withdraw)\n                        newCol_ = -(int256((o_.colRaw * o_.supplyExPrice) / EXCHANGE_PRICES_PRECISION)) + 1;\n                        o_.colRaw = 0;\n                    } else {\n                        revert FluidVaultError(ErrorTypes.Vault__UserCollateralDebtExceed);\n                    }\n                }\n            }\n            {\n                // borrow or payback\n                if (newDebt_ > 0) {\n                    // borrow new debt, rounding up adding extra wei in debt\n                    temp_ = ((uint(newDebt_) * EXCHANGE_PRICES_PRECISION) / o_.borrowExPrice) + 1;\n                    // if borrow fee is 0 then it'll become temp_ + 0.\n                    // Only adding fee in o_.debtRaw and not in newDebt_ as newDebt_ is debt that needs to be borrowed from Liquidity\n                    // as we have added fee in debtRaw hence it will get added in user's position & vault's total borrow.\n                    // It can be collected with rebalance function.\n                    o_.debtRaw += temp_ + (temp_ * ((o_.vaultVariables2 >> 82) & X10)) / 10000;\n                    // final user's debt should not be above 2**128 bits\n                    if (o_.debtRaw > X128) {\n                        revert FluidVaultError(ErrorTypes.Vault__UserCollateralDebtExceed);\n                    }\n                } else if (newDebt_ < 0) {\n                    // if payback equals type(int).min then max payback\n                    if (newDebt_ > type(int128).min) {\n                        // partial payback.\n                        // temp3_ => newDebt_ in raw terms, safe rounding up negative amount to rounding reduce payback\n                        temp3_ = (newDebt_ * int256(EXCHANGE_PRICES_PRECISION)) / int256(o_.borrowExPrice) + 1;\n                        unchecked {\n                            temp3_ = -temp3_;\n                            if (uint256(temp3_) > o_.debtRaw) {\n                                revert FluidVaultError(ErrorTypes.Vault__ExcessDebtPayback);\n                            }\n                            o_.debtRaw -= uint256(temp3_);\n                        }\n                    } else if (newDebt_ == type(int).min) {\n                        // max payback, rounding up amount that will be transferred in to pay back full debt:\n                        // subtracting -1 of negative debtAmount newDebt_ for safe rounding (increasing payback)\n                        newDebt_ = -(int256((o_.debtRaw * o_.borrowExPrice) / EXCHANGE_PRICES_PRECISION)) - 1;\n                        o_.debtRaw = 0;\n                    } else {\n                        revert FluidVaultError(ErrorTypes.Vault__UserCollateralDebtExceed);\n                    }\n                }\n            }\n        }\n\n        // if position has no collateral or debt and user sends type(int).min for withdraw and payback then this results in 0\n        // there's is no issue if it stays 0 but better to throw here to avoid checking for potential issues if there could be\n        if (newCol_ == 0 && newDebt_ == 0) {\n            revert FluidVaultError(ErrorTypes.Vault__InvalidOperateAmount);\n        }\n\n        // Assign new tick\n        if (o_.debtRaw > 0) {\n            // updating tickHasDebt in the below function if required\n            // o_.debtRaw here is updated to new debt raw incl. dust debt (not net debt)\n            unchecked {\n                (o_.tick, o_.tickId, o_.debtRaw, o_.dustDebtRaw) = _addDebtToTickWrite(\n                    o_.colRaw,\n                    ((o_.debtRaw * 1000000001) / 1000000000) + 1\n                );\n            }\n\n            if (newDebt_ < 0) {\n                // anyone can payback debt of any position\n                // hence, explicitly checking the debt should decrease\n                if ((o_.debtRaw - o_.dustDebtRaw) > o_.oldNetDebtRaw) {\n                    revert FluidVaultError(ErrorTypes.Vault__InvalidPaybackOrDeposit);\n                }\n            }\n            if ((newCol_ > 0) && (newDebt_ == 0)) {\n                // anyone can deposit collateral in any position\n                // Hence, explicitly checking that new ratio should be less than old ratio\n                if (\n                    (((o_.debtRaw - o_.dustDebtRaw) * TickMath.ZERO_TICK_SCALED_RATIO) / o_.colRaw) >\n                    ((o_.oldNetDebtRaw * TickMath.ZERO_TICK_SCALED_RATIO) / o_.oldColRaw)\n                ) {\n                    revert FluidVaultError(ErrorTypes.Vault__InvalidPaybackOrDeposit);\n                }\n            }\n\n            if (o_.tick >= o_.topTick) {\n                // Updating topTick in storage\n                // temp_ => tick to insert in vault variables\n                unchecked {\n                    temp_ = o_.tick < 0 ? uint(-o_.tick) << 1 : (uint(o_.tick) << 1) | 1;\n                }\n                if (vaultVariables_ & 2 == 0) {\n                    // Current branch not liquidated. Hence, just update top tick\n                    vaultVariables_ =\n                        (vaultVariables_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00000) |\n                        (temp_ << 2);\n                } else {\n                    // Current branch liquidated\n                    // Initialize a new branch\n                    // temp2_ => totalBranchId_\n                    unchecked {\n                        temp2_ = ((vaultVariables_ >> 52) & X30) + 1; // would take 34 years to overflow if a new branch is created every second\n                    }\n                    // Connecting new active branch with current active branch which is now base branch\n                    // Current top tick is now base branch's minima tick\n                    branchData[temp2_] =\n                        (((vaultVariables_ >> 22) & X30) << 166) | // current branch id set as base branch id\n                        (((vaultVariables_ >> 2) & X20) << 196); // current top tick set as base branch minima tick\n                    // Updating new vault variables in memory with new branch\n                    vaultVariables_ =\n                        (vaultVariables_ & 0xfffffffffffffffffffffffffffffffffffffffffffc00000000000000000000) |\n                        (temp_ << 2) | // new top tick\n                        (temp2_ << 22) | // new branch id\n                        (temp2_ << 52); // total branch ids\n                }\n            }\n        } else {\n            // debtRaw_ remains 0 in this situation\n            // This kind of position will not have any tick. Meaning it'll be a supply position.\n            o_.tick = type(int).min;\n        }\n\n        {\n            if (newCol_ < 0 || newDebt_ > 0) {\n                // withdraw or borrow\n                if (to_ == address(0)) {\n                    to_ = msg.sender;\n                }\n\n                unchecked {\n                    // if debt is greater than 0 & transaction includes borrow or withdraw (incl. combinations such as deposit + borrow etc.)\n                    // -> check collateral factor\n                    // calc for net debt can be unchecked as o_.dustDebtRaw can not be > o_.debtRaw:\n                    // o_.dustDebtRaw is the result of o_.debtRaw - x where x > 0 see _addDebtToTickWrite()\n\n                    // Only fetch oracle if position is getting riskier or if borrowing is involved\n                    // if user is withdrawing and paying back in the same transaction such that the final ratio\n                    // is lower than initial then as well no need to check oracle aka user is doing payback & withdraw or deleverage\n                    if (\n                        o_.debtRaw > 0 &&\n                        (o_.oldTick <= o_.tick ||\n                            (o_.debtRaw - o_.dustDebtRaw) > (((o_.oldNetDebtRaw * 1000000001) / 1000000000) + 1))\n                    ) {\n                        // Oracle returns price at 100% ratio.\n                        // converting oracle 160 bits into oracle address\n                        // temp_ => debt price w.r.t to col in 1e27\n                        temp_ = IFluidOracle(\n                            AddressCalcs.addressCalc(DEPLOYER_CONTRACT, ((o_.vaultVariables2 >> 92) & X30))\n                        ).getExchangeRateOperate();\n                        // Note if price would come back as 0 `getTickAtRatio` will fail\n\n                        // reverting if oracle price is too high or lower than 1e9 to avoid precision issues\n                        if (temp_ > 1e54 || temp_ < 1e9) {\n                            revert FluidVaultError(ErrorTypes.Vault__InvalidOraclePrice);\n                        }\n\n                        // Converting price in terms of raw amounts\n                        temp_ = (temp_ * o_.supplyExPrice) / o_.borrowExPrice;\n\n                        // capping oracle pricing to 1e45 (#487RGF783GF: id reference for other similar cases in codebase)\n                        // This means we are restricting collateral price to never go above 1e45\n                        // Above 1e45 precisions gets too low for calculations\n                        // This can will never happen for all good token pairs (for example, WBTC/DAI pair when WBTC price is $1M, oracle price will come as 1e43)\n                        // Restricting oracle price doesn't pose any risk to protocol as we are capping collateral price, meaning if price is above 1e45\n                        // user is simply not able to borrow more\n                        if (temp_ > 1e45) {\n                            temp_ = 1e45;\n                        }\n\n                        // temp2_ => ratio at CF. CF is in 3 decimals. 900 = 90%\n                        temp2_ = ((temp_ * ((o_.vaultVariables2 >> 32) & X10)) / 1000);\n\n                        // Price from oracle is in 1e27 decimals. Converting it into (1 << 96) decimals\n                        temp2_ = ((temp2_ * TickMath.ZERO_TICK_SCALED_RATIO) / 1e27);\n\n                        // temp3_ => tickAtCF_\n                        (temp3_, ) = TickMath.getTickAtRatio(temp2_);\n                        if (o_.tick > temp3_) {\n                            // Above CF, user should only be allowed to reduce ratio either by paying debt or by depositing more collateral\n                            // Not comparing collateral as user can potentially use safe/deleverage to reduce tick & debt.\n                            // On use of safe/deleverage, collateral will decrease but debt will decrease as well making the overall position safer.\n                            revert FluidVaultError(ErrorTypes.Vault__PositionAboveCF);\n                        }\n                    }\n                }\n            }\n        }\n\n        {\n            // Updating user's new position on storage\n            // temp_ => tick to insert as user position tick\n            if (o_.tick > type(int).min) {\n                unchecked {\n                    temp_ = o_.tick < 0 ? (uint(-o_.tick) << 1) : ((uint(o_.tick) << 1) | 1);\n                }\n            } else {\n                // if positionTick_ = type(int).min OR positionRawDebt_ == 0 then that means it's only supply position\n                // (for case of positionRawDebt_ == 0, tick is set to type(int).min further up)\n                temp_ = 0;\n            }\n\n            positionData[nftId_] =\n                ((temp_ == 0) ? 1 : 0) | // setting if supply only position (1) or not (first bit)\n                (temp_ << 1) |\n                (o_.tickId << 21) |\n                (o_.colRaw.toBigNumber(56, 8, BigMathMinified.ROUND_DOWN) << 45) |\n                // dust debt is rounded down because user debt = debt - dustDebt. rounding up would mean we reduce user debt\n                (o_.dustDebtRaw.toBigNumber(56, 8, BigMathMinified.ROUND_DOWN) << 109);\n        }\n\n        // Withdrawal gap to make sure there's always liquidity for liquidation\n        // For example if withdrawal allowance is 15% on liquidity then we can limit operate's withdrawal allowance to 10%\n        // this will allow liquidate function to get extra 5% buffer for potential liquidations.\n        if (newCol_ < 0) {\n            // extracting withdrawal gap which is in 0.1% precision.\n            temp_ = (o_.vaultVariables2 >> 62) & X10;\n            if (temp_ > 0) {\n                // fetching user's supply slot data\n                o_.userSupplyLiquidityData = SUPPLY.readFromStorage(USER_SUPPLY_SLOT);\n\n                // converting current user's supply from big number to normal\n                temp2_ = (o_.userSupplyLiquidityData >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n                temp2_ = (temp2_ >> 8) << (temp2_ & X8);\n\n                // fetching liquidity's withdrawal limit\n                temp3_ = int(LiquidityCalcs.calcWithdrawalLimitBeforeOperate(o_.userSupplyLiquidityData, temp2_));\n\n                unchecked {\n                    // max the number could go is vault's supply * 1000. Overflowing is almost impossible.\n                    if (\n                        TYPE == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE ||\n                        TYPE == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE\n                    ) {\n                        // withdrawal already happened in smart col so checking according to that\n                        if (\n                            (temp3_ > 0) &&\n                            // userSupply * (100% - withdrawalGap) < withdrawalLimit\n                            // i.e. if limit for next tx is not below userSupply - withdrawalGap -> revert\n                            (((int(temp2_ * (1000 - temp_)) / 1000)) < temp3_)\n                        ) {\n                            revert FluidVaultError(ErrorTypes.Vault__WithdrawMoreThanOperateLimit);\n                        }\n                    } else {\n                        // (liquidityUserSupply - withdrawalGap - liquidityWithdrawaLimit) should be less than user's withdrawal\n                        if (\n                            (temp3_ > 0) &&\n                            // userSupply * (100% - withdrawalGap) - withdrawalLimit < withdrawColRaw\n                            // i.e. if withdrawableRaw < withdrawColRaw -> revert\n                            (((int(temp2_ * (1000 - temp_)) / 1000)) - temp3_) <\n                            (((-newCol_) * int(EXCHANGE_PRICES_PRECISION)) / int(o_.liquidityExPrice))\n                        ) {\n                            revert FluidVaultError(ErrorTypes.Vault__WithdrawMoreThanOperateLimit);\n                        }\n                    }\n                }\n            }\n        }\n\n        {\n            // with TYPE we are checking if we should interact with Liquidity Layer or interaction will happen with DEX\n\n            // execute actions at Liquidity: deposit & payback is first and then withdraw & borrow\n            if (\n                newCol_ > 0 &&\n                !(TYPE == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE ||\n                    TYPE == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE)\n            ) {\n                // deposit\n                LIQUIDITY.operate{ value: SUPPLY_TOKEN == NATIVE_TOKEN ? uint256(newCol_) : 0 }(\n                    SUPPLY_TOKEN,\n                    newCol_,\n                    0,\n                    address(0),\n                    address(0),\n                    abi.encode(msg.sender)\n                );\n            }\n            if (\n                newDebt_ < 0 &&\n                !(TYPE == FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE ||\n                    TYPE == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE)\n            ) {\n                if (BORROW_TOKEN == NATIVE_TOKEN) {\n                    unchecked {\n                        temp_ = uint(-newDebt_);\n                    }\n                } else {\n                    temp_ = 0;\n                }\n                // payback\n                LIQUIDITY.operate{ value: temp_ }(\n                    BORROW_TOKEN,\n                    0,\n                    newDebt_,\n                    address(0),\n                    address(0),\n                    abi.encode(msg.sender)\n                );\n            }\n            if (\n                newCol_ < 0 &&\n                !(TYPE == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE ||\n                    TYPE == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE)\n            ) {\n                // withdraw\n                LIQUIDITY.operate(SUPPLY_TOKEN, newCol_, 0, to_, address(0), new bytes(0));\n            }\n            if (\n                newDebt_ > 0 &&\n                !(TYPE == FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE ||\n                    TYPE == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE)\n            ) {\n                // borrow\n                LIQUIDITY.operate(BORROW_TOKEN, 0, newDebt_, address(0), to_, new bytes(0));\n            }\n        }\n\n        {\n            // Updating vault variables on storage\n\n            // Calculating new total collateral & total debt.\n            temp_ = (vaultVariables_ >> 82) & X64;\n            temp_ = ((temp_ >> 8) << (temp_ & X8)) + o_.colRaw - o_.oldColRaw;\n            temp2_ = (vaultVariables_ >> 146) & X64;\n            temp2_ = ((temp2_ >> 8) << (temp2_ & X8)) + (o_.debtRaw - o_.dustDebtRaw) - o_.oldNetDebtRaw;\n            // Updating vault variables on storage. This will also reentrancy 0 back again\n            // Converting total supply & total borrow in 64 bits (56 | 8) bignumber\n            vaultVariables_ =\n                (vaultVariables_ & 0xfffffffffffc00000000000000000000000000000003ffffffffffffffffffff) |\n                (temp_.toBigNumber(56, 8, BigMathMinified.ROUND_DOWN) << 82) | // total supply\n                (temp2_.toBigNumber(56, 8, BigMathMinified.ROUND_UP) << 146); // total borrow\n        }\n\n        emit LogOperate(msg.sender, nftId_, newCol_, newDebt_, to_);\n\n        return (nftId_, newCol_, newDebt_, vaultVariables_);\n    }\n\n    constructor(ConstantViews memory constants_) HelpersOperate(constants_) {}\n}\n"
    },
    "contracts/protocols/vault/vaultTypesCommon/coreModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nabstract contract Structs {\n    // structs are used to mitigate Stack too deep errors\n\n    struct OperateMemoryVars {\n        // ## User's position before update ##\n        uint oldColRaw;\n        uint oldNetDebtRaw; // total debt - dust debt\n        int oldTick;\n        // ## User's position after update ##\n        uint colRaw;\n        uint debtRaw;\n        uint dustDebtRaw;\n        int tick;\n        uint tickId;\n        // others\n        uint256 vaultVariables2;\n        uint256 branchId;\n        int256 topTick;\n        uint liquidityExPrice;\n        uint supplyExPrice;\n        uint borrowExPrice;\n        uint branchData;\n        // user's supply slot data in liquidity\n        uint userSupplyLiquidityData;\n    }\n\n    struct BranchData {\n        uint id;\n        uint data;\n        uint ratio;\n        uint debtFactor;\n        int minimaTick;\n        uint baseBranchData;\n    }\n\n    struct TickData {\n        int tick;\n        uint data;\n        uint ratio;\n        uint ratioOneLess;\n        uint length;\n        uint currentRatio; // current tick is ratio with partials.\n        uint partials;\n    }\n\n    // note: All the below token amounts are in raw form.\n    struct CurrentLiquidity {\n        uint256 debtRemaining; // Debt remaining to liquidate\n        uint256 debt; // Current liquidatable debt before reaching next check point\n        uint256 col; // Calculate using debt & ratioCurrent\n        uint256 colPerDebt; // How much collateral to liquidate per unit of Debt\n        uint256 totalDebtLiq; // Total debt liquidated till now\n        uint256 totalColLiq; // Total collateral liquidated till now\n        int tick; // Current tick to liquidate\n        uint ratio; // Current ratio to liquidate\n        uint tickStatus; // if 1 then it's a perfect tick, if 2 that means it's a liquidated tick\n        int refTick; // ref tick to liquidate\n        uint refRatio; // ratio at ref tick\n        uint refTickStatus; // if 1 then it's a perfect tick, if 2 that means it's a liquidated tick, if 3 that means it's a liquidation threshold\n    }\n\n    struct TickHasDebt {\n        int tick; // current tick\n        int nextTick; // next tick with liquidity\n        int mapId; // mapping ID of tickHasDebt\n        uint bitsToRemove; // liquidity to remove till tick_ so we can search for next tick\n        uint tickHasDebt; // getting tickHasDebt_ from tickHasDebt[mapId_]\n        uint mostSigBit; // most significant bit in tickHasDebt_ to get the next tick\n    }\n\n    struct LiquidateMemoryVars {\n        uint256 vaultVariables2;\n        int liquidationTick;\n        int maxTick;\n        uint256 supplyExPrice;\n        uint256 borrowExPrice;\n        uint256 actualDebtAmt;\n        uint256 actualColAmt;\n    }\n\n    struct AbsorbMemoryVariables {\n        uint256 debtAbsorbed;\n        uint256 colAbsorbed;\n        int256 startingTick;\n        uint256 mostSigBit;\n    }\n\n    struct Tokens {\n        address token0;\n        address token1;\n    }\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address operateImplementation;\n        address adminImplementation;\n        address secondaryImplementation;\n        address deployer; // address which deploys oracle\n        address supply; // either liquidity layer or DEX protocol\n        address borrow; // either liquidity layer or DEX protocol\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\n        uint256 vaultId;\n        uint256 vaultType;\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n    }\n\n    struct RebalanceMemoryVariables {\n        uint256 liqSupplyExPrice;\n        uint256 liqBorrowExPrice;\n        uint256 vaultSupplyExPrice;\n        uint256 vaultBorrowExPrice;\n        uint256 totalSupply;\n        uint256 totalBorrow;\n        uint256 totalSupplyVault;\n        uint256 totalBorrowVault;\n        uint256 initialEth;\n    }\n}\n"
    },
    "contracts/reserve/interfaces/iReserveContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IFluidLiquidity } from \"../../liquidity/interfaces/iLiquidity.sol\";\n\ninterface IFluidReserveContract {\n    function isRebalancer(address user) external returns (bool);\n\n    function initialize(\n        address[] memory _auths,\n        address[] memory _rebalancers,\n        IFluidLiquidity liquidity_,\n        address owner_\n    ) external;\n\n    function rebalanceFToken(address protocol_) external;\n\n    function rebalanceVault(address protocol_) external;\n\n    function transferFunds(address token_) external;\n\n    function getProtocolTokens(address protocol_) external;\n\n    function updateAuth(address auth_, bool isAuth_) external;\n\n    function updateRebalancer(address rebalancer_, bool isRebalancer_) external;\n\n    function approve(address[] memory protocols_, address[] memory tokens_, uint256[] memory amounts_) external;\n\n    function revoke(address[] memory protocols_, address[] memory tokens_) external;\n}\n"
    },
    "solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
    },
    "solmate/src/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}